diff --git a/20160914.diff b/20160914.diff
new file mode 100644
index 0000000..967dd31
--- /dev/null
+++ b/20160914.diff
@@ -0,0 +1,11627 @@
+diff --git a/2016_09012.diff b/2016_09012.diff
+new file mode 100644
+index 0000000..3930c27
+--- /dev/null
++++ b/2016_09012.diff
+@@ -0,0 +1,10886 @@
++diff --git a/.DS_Store b/.DS_Store
++index 0ab3ed8..cc4920b 100644
++Binary files a/.DS_Store and b/.DS_Store differ
++diff --git a/CRMCall092016.xcodeproj/project.pbxproj b/CRMCall092016.xcodeproj/project.pbxproj
++index 6a921f0..7c41d9c 100644
++--- a/CRMCall092016.xcodeproj/project.pbxproj
+++++ b/CRMCall092016.xcodeproj/project.pbxproj
++@@ -7,14 +7,18 @@
++ 	objects = {
++ 
++ /* Begin PBXBuildFile section */
+++		922840301D865A720059A0D7 /* CRMCallSocket.swift in Sources */ = {isa = PBXBuildFile; fileRef = 9228402F1D865A720059A0D7 /* CRMCallSocket.swift */; };
+++		92E2341A1D812899006C988E /* ModelManger.swift in Sources */ = {isa = PBXBuildFile; fileRef = 92E234191D812899006C988E /* ModelManger.swift */; };
+++		92E2341D1D81443F006C988E /* AlamofireManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 92E2341C1D81443F006C988E /* AlamofireManager.swift */; };
+++		92E2341F1D81447D006C988E /* SWXMLHashManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 92E2341E1D81447D006C988E /* SWXMLHashManager.swift */; };
+++		92E234241D814647006C988E /* XMLRequestBuilder.swift in Sources */ = {isa = PBXBuildFile; fileRef = 92E234231D814647006C988E /* XMLRequestBuilder.swift */; };
++ 		92E3E3131D8004C3008033ED /* AppDelegate.swift in Sources */ = {isa = PBXBuildFile; fileRef = 92E3E3121D8004C3008033ED /* AppDelegate.swift */; };
++ 		92E3E3151D8004C3008033ED /* ViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 92E3E3141D8004C3008033ED /* ViewController.swift */; };
++ 		92E3E3171D8004C3008033ED /* Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = 92E3E3161D8004C3008033ED /* Assets.xcassets */; };
++ 		92E3E31A1D8004C3008033ED /* Main.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = 92E3E3181D8004C3008033ED /* Main.storyboard */; };
++ 		92E3E3291D8005E2008033ED /* AESExtension.m in Sources */ = {isa = PBXBuildFile; fileRef = 92E3E3281D8005E2008033ED /* AESExtension.m */; };
++-		92E3E32F1D8008B9008033ED /* XMLRequestBuilder.swift in Sources */ = {isa = PBXBuildFile; fileRef = 92E3E32E1D8008B9008033ED /* XMLRequestBuilder.swift */; };
++ 		92E3E3311D800947008033ED /* CRMCallConfig.swift in Sources */ = {isa = PBXBuildFile; fileRef = 92E3E3301D800947008033ED /* CRMCallConfig.swift */; };
++-		92E3E3331D800C8B008033ED /* SocketManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 92E3E3321D800C8B008033ED /* SocketManager.swift */; };
+++		92E3E3331D800C8B008033ED /* BaseSocket.swift in Sources */ = {isa = PBXBuildFile; fileRef = 92E3E3321D800C8B008033ED /* BaseSocket.swift */; };
++ 		92E3E3351D8011FC008033ED /* CRMCallLog.swift in Sources */ = {isa = PBXBuildFile; fileRef = 92E3E3341D8011FC008033ED /* CRMCallLog.swift */; };
++ 		A786E68B3F379810ED36B746 /* Pods_CRMCall092016.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 0F2F9C69A515659B29DDA8FF /* Pods_CRMCall092016.framework */; };
++ /* End PBXBuildFile section */
++@@ -23,6 +27,11 @@
++ 		0F2F9C69A515659B29DDA8FF /* Pods_CRMCall092016.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Pods_CRMCall092016.framework; sourceTree = BUILT_PRODUCTS_DIR; };
++ 		638056E88800D61CD44C46F6 /* Pods-CRMCall092016.release.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-CRMCall092016.release.xcconfig"; path = "Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016.release.xcconfig"; sourceTree = "<group>"; };
++ 		867B73DF25B4547C396A7607 /* Pods-CRMCall092016.debug.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-CRMCall092016.debug.xcconfig"; path = "Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016.debug.xcconfig"; sourceTree = "<group>"; };
+++		9228402F1D865A720059A0D7 /* CRMCallSocket.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = CRMCallSocket.swift; sourceTree = "<group>"; };
+++		92E234191D812899006C988E /* ModelManger.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = ModelManger.swift; sourceTree = "<group>"; };
+++		92E2341C1D81443F006C988E /* AlamofireManager.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = AlamofireManager.swift; sourceTree = "<group>"; };
+++		92E2341E1D81447D006C988E /* SWXMLHashManager.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = SWXMLHashManager.swift; sourceTree = "<group>"; };
+++		92E234231D814647006C988E /* XMLRequestBuilder.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = XMLRequestBuilder.swift; sourceTree = "<group>"; };
++ 		92E3E30F1D8004C3008033ED /* CRMCall092016.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = CRMCall092016.app; sourceTree = BUILT_PRODUCTS_DIR; };
++ 		92E3E3121D8004C3008033ED /* AppDelegate.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AppDelegate.swift; sourceTree = "<group>"; };
++ 		92E3E3141D8004C3008033ED /* ViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ViewController.swift; sourceTree = "<group>"; };
++@@ -32,9 +41,8 @@
++ 		92E3E3221D800538008033ED /* CRMCall092016-Bridging-Header.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = "CRMCall092016-Bridging-Header.h"; sourceTree = "<group>"; };
++ 		92E3E3271D8005E2008033ED /* AESExtension.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = AESExtension.h; sourceTree = "<group>"; };
++ 		92E3E3281D8005E2008033ED /* AESExtension.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = AESExtension.m; sourceTree = "<group>"; };
++-		92E3E32E1D8008B9008033ED /* XMLRequestBuilder.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = XMLRequestBuilder.swift; sourceTree = "<group>"; };
++ 		92E3E3301D800947008033ED /* CRMCallConfig.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = CRMCallConfig.swift; sourceTree = "<group>"; };
++-		92E3E3321D800C8B008033ED /* SocketManager.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = SocketManager.swift; sourceTree = "<group>"; };
+++		92E3E3321D800C8B008033ED /* BaseSocket.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = BaseSocket.swift; sourceTree = "<group>"; };
++ 		92E3E3341D8011FC008033ED /* CRMCallLog.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = CRMCallLog.swift; sourceTree = "<group>"; };
++ /* End PBXFileReference section */
++ 
++@@ -50,6 +58,22 @@
++ /* End PBXFrameworksBuildPhase section */
++ 
++ /* Begin PBXGroup section */
+++		92E234181D81281D006C988E /* Models */ = {
+++			isa = PBXGroup;
+++			children = (
+++				92E234191D812899006C988E /* ModelManger.swift */,
+++			);
+++			path = Models;
+++			sourceTree = "<group>";
+++		};
+++		92E234221D8145ED006C988E /* XML */ = {
+++			isa = PBXGroup;
+++			children = (
+++				92E234231D814647006C988E /* XMLRequestBuilder.swift */,
+++			);
+++			path = XML;
+++			sourceTree = "<group>";
+++		};
++ 		92E3E3061D8004C3008033ED = {
++ 			isa = PBXGroup;
++ 			children = (
++@@ -71,6 +95,7 @@
++ 		92E3E3111D8004C3008033ED /* CRMCall092016 */ = {
++ 			isa = PBXGroup;
++ 			children = (
+++				92E234181D81281D006C988E /* Models */,
++ 				92E3E3211D8004F4008033ED /* Helpers */,
++ 				92E3E32C1D80066C008033ED /* Library */,
++ 				92E3E32B1D80063C008033ED /* Server */,
++@@ -87,6 +112,7 @@
++ 		92E3E3211D8004F4008033ED /* Helpers */ = {
++ 			isa = PBXGroup;
++ 			children = (
+++				92E234221D8145ED006C988E /* XML */,
++ 				92E3E3261D8005E2008033ED /* AES */,
++ 				92E3E3221D800538008033ED /* CRMCall092016-Bridging-Header.h */,
++ 				92E3E3301D800947008033ED /* CRMCallConfig.swift */,
++@@ -115,7 +141,6 @@
++ 			isa = PBXGroup;
++ 			children = (
++ 				92E3E32D1D8007F4008033ED /* Socket */,
++-				92E3E32E1D8008B9008033ED /* XMLRequestBuilder.swift */,
++ 			);
++ 			path = Server;
++ 			sourceTree = "<group>";
++@@ -123,6 +148,8 @@
++ 		92E3E32C1D80066C008033ED /* Library */ = {
++ 			isa = PBXGroup;
++ 			children = (
+++				92E2341C1D81443F006C988E /* AlamofireManager.swift */,
+++				92E2341E1D81447D006C988E /* SWXMLHashManager.swift */,
++ 			);
++ 			path = Library;
++ 			sourceTree = "<group>";
++@@ -130,7 +157,8 @@
++ 		92E3E32D1D8007F4008033ED /* Socket */ = {
++ 			isa = PBXGroup;
++ 			children = (
++-				92E3E3321D800C8B008033ED /* SocketManager.swift */,
+++				92E3E3321D800C8B008033ED /* BaseSocket.swift */,
+++				9228402F1D865A720059A0D7 /* CRMCallSocket.swift */,
++ 			);
++ 			path = Socket;
++ 			sourceTree = "<group>";
++@@ -273,12 +301,16 @@
++ 			isa = PBXSourcesBuildPhase;
++ 			buildActionMask = 2147483647;
++ 			files = (
+++				92E2341F1D81447D006C988E /* SWXMLHashManager.swift in Sources */,
+++				922840301D865A720059A0D7 /* CRMCallSocket.swift in Sources */,
+++				92E234241D814647006C988E /* XMLRequestBuilder.swift in Sources */,
++ 				92E3E3151D8004C3008033ED /* ViewController.swift in Sources */,
++ 				92E3E3131D8004C3008033ED /* AppDelegate.swift in Sources */,
++ 				92E3E3291D8005E2008033ED /* AESExtension.m in Sources */,
++-				92E3E32F1D8008B9008033ED /* XMLRequestBuilder.swift in Sources */,
++-				92E3E3331D800C8B008033ED /* SocketManager.swift in Sources */,
+++				92E2341A1D812899006C988E /* ModelManger.swift in Sources */,
+++				92E3E3331D800C8B008033ED /* BaseSocket.swift in Sources */,
++ 				92E3E3351D8011FC008033ED /* CRMCallLog.swift in Sources */,
+++				92E2341D1D81443F006C988E /* AlamofireManager.swift in Sources */,
++ 				92E3E3311D800947008033ED /* CRMCallConfig.swift in Sources */,
++ 			);
++ 			runOnlyForDeploymentPostprocessing = 0;
++@@ -388,7 +420,7 @@
++ 				COMBINE_HIDPI_IMAGES = YES;
++ 				INFOPLIST_FILE = CRMCall092016/Info.plist;
++ 				LD_RUNPATH_SEARCH_PATHS = "$(inherited) @executable_path/../Frameworks";
++-				OTHER_SWIFT_FLAGS = "-DDEBUG";
+++				OTHER_SWIFT_FLAGS = "$(inherited) -D DEBUG";
++ 				PRODUCT_BUNDLE_IDENTIFIER = com.xuanvintd.CRMCall092016;
++ 				PRODUCT_NAME = "$(TARGET_NAME)";
++ 				SWIFT_OBJC_BRIDGING_HEADER = "CRMCall092016/Helpers/CRMCall092016-Bridging-Header.h";
++@@ -405,6 +437,7 @@
++ 				COMBINE_HIDPI_IMAGES = YES;
++ 				INFOPLIST_FILE = CRMCall092016/Info.plist;
++ 				LD_RUNPATH_SEARCH_PATHS = "$(inherited) @executable_path/../Frameworks";
+++				OTHER_SWIFT_FLAGS = "$(inherited)";
++ 				PRODUCT_BUNDLE_IDENTIFIER = com.xuanvintd.CRMCall092016;
++ 				PRODUCT_NAME = "$(TARGET_NAME)";
++ 				SWIFT_OBJC_BRIDGING_HEADER = "CRMCall092016/Helpers/CRMCall092016-Bridging-Header.h";
++diff --git a/CRMCall092016.xcworkspace/xcuserdata/hanbiro.xcuserdatad/UserInterfaceState.xcuserstate b/CRMCall092016.xcworkspace/xcuserdata/hanbiro.xcuserdatad/UserInterfaceState.xcuserstate
++index 626175e..9ee2155 100644
++Binary files a/CRMCall092016.xcworkspace/xcuserdata/hanbiro.xcuserdatad/UserInterfaceState.xcuserstate and b/CRMCall092016.xcworkspace/xcuserdata/hanbiro.xcuserdatad/UserInterfaceState.xcuserstate differ
++diff --git a/CRMCall092016/.DS_Store b/CRMCall092016/.DS_Store
++new file mode 100644
++index 0000000..e9dd625
++Binary files /dev/null and b/CRMCall092016/.DS_Store differ
++diff --git a/CRMCall092016/Base.lproj/Main.storyboard b/CRMCall092016/Base.lproj/Main.storyboard
++index bce5247..6971220 100644
++--- a/CRMCall092016/Base.lproj/Main.storyboard
+++++ b/CRMCall092016/Base.lproj/Main.storyboard
++@@ -672,7 +672,117 @@
++                     <view key="view" id="m2S-Jp-Qdl">
++                         <rect key="frame" x="0.0" y="0.0" width="480" height="270"/>
++                         <autoresizingMask key="autoresizingMask"/>
+++                        <subviews>
+++                            <textField horizontalHuggingPriority="251" verticalHuggingPriority="750" translatesAutoresizingMaskIntoConstraints="NO" id="YWn-PH-WzV">
+++                                <rect key="frame" x="49" y="210" width="50" height="17"/>
+++                                <textFieldCell key="cell" scrollable="YES" lineBreakMode="clipping" sendsActionOnEndEditing="YES" title="Domain" id="mWy-w5-bSu">
+++                                    <font key="font" metaFont="system"/>
+++                                    <color key="textColor" name="labelColor" catalog="System" colorSpace="catalog"/>
+++                                    <color key="backgroundColor" name="controlColor" catalog="System" colorSpace="catalog"/>
+++                                </textFieldCell>
+++                            </textField>
+++                            <textField horizontalHuggingPriority="251" verticalHuggingPriority="750" translatesAutoresizingMaskIntoConstraints="NO" id="SDN-0s-DTb">
+++                                <rect key="frame" x="49" y="171" width="33" height="17"/>
+++                                <textFieldCell key="cell" scrollable="YES" lineBreakMode="clipping" sendsActionOnEndEditing="YES" title="User" id="UKh-EO-mUV">
+++                                    <font key="font" metaFont="system"/>
+++                                    <color key="textColor" name="labelColor" catalog="System" colorSpace="catalog"/>
+++                                    <color key="backgroundColor" name="controlColor" catalog="System" colorSpace="catalog"/>
+++                                </textFieldCell>
+++                            </textField>
+++                            <textField horizontalHuggingPriority="251" verticalHuggingPriority="750" translatesAutoresizingMaskIntoConstraints="NO" id="JS7-Io-Koi">
+++                                <rect key="frame" x="49" y="132" width="63" height="17"/>
+++                                <textFieldCell key="cell" scrollable="YES" lineBreakMode="clipping" sendsActionOnEndEditing="YES" title="Password" id="DgM-0W-UBM">
+++                                    <font key="font" metaFont="system"/>
+++                                    <color key="textColor" name="labelColor" catalog="System" colorSpace="catalog"/>
+++                                    <color key="backgroundColor" name="controlColor" catalog="System" colorSpace="catalog"/>
+++                                </textFieldCell>
+++                            </textField>
+++                            <textField hidden="YES" horizontalHuggingPriority="251" verticalHuggingPriority="750" translatesAutoresizingMaskIntoConstraints="NO" id="nGf-xq-RQu">
+++                                <rect key="frame" x="194" y="40" width="92" height="17"/>
+++                                <textFieldCell key="cell" scrollable="YES" lineBreakMode="clipping" sendsActionOnEndEditing="YES" title="login Success!" id="h53-kc-rEE">
+++                                    <font key="font" metaFont="system"/>
+++                                    <color key="textColor" red="0.0" green="0.50196081400000003" blue="0.0" alpha="1" colorSpace="calibratedRGB"/>
+++                                    <color key="backgroundColor" name="controlColor" catalog="System" colorSpace="catalog"/>
+++                                </textFieldCell>
+++                            </textField>
+++                            <textField verticalHuggingPriority="750" translatesAutoresizingMaskIntoConstraints="NO" id="ohl-5L-mtw">
+++                                <rect key="frame" x="117" y="205" width="263" height="22"/>
+++                                <textFieldCell key="cell" scrollable="YES" lineBreakMode="clipping" selectable="YES" editable="YES" sendsActionOnEndEditing="YES" state="on" borderStyle="bezel" title="global3.hanbiro.com" placeholderString="" drawsBackground="YES" id="Osp-Th-EIE">
+++                                    <font key="font" metaFont="system"/>
+++                                    <color key="textColor" name="textColor" catalog="System" colorSpace="catalog"/>
+++                                    <color key="backgroundColor" name="textBackgroundColor" catalog="System" colorSpace="catalog"/>
+++                                </textFieldCell>
+++                            </textField>
+++                            <textField verticalHuggingPriority="750" translatesAutoresizingMaskIntoConstraints="NO" id="KtV-vx-4vz">
+++                                <rect key="frame" x="117" y="166" width="263" height="22"/>
+++                                <textFieldCell key="cell" scrollable="YES" lineBreakMode="clipping" selectable="YES" editable="YES" sendsActionOnEndEditing="YES" state="on" borderStyle="bezel" title="hcsong" drawsBackground="YES" id="l0S-uL-xDB">
+++                                    <font key="font" metaFont="system"/>
+++                                    <color key="textColor" name="textColor" catalog="System" colorSpace="catalog"/>
+++                                    <color key="backgroundColor" name="textBackgroundColor" catalog="System" colorSpace="catalog"/>
+++                                </textFieldCell>
+++                            </textField>
+++                            <secureTextField verticalHuggingPriority="750" translatesAutoresizingMaskIntoConstraints="NO" id="p4h-qf-Wor">
+++                                <rect key="frame" x="117" y="127" width="263" height="22"/>
+++                                <secureTextFieldCell key="cell" scrollable="YES" lineBreakMode="clipping" selectable="YES" editable="YES" sendsActionOnEndEditing="YES" borderStyle="bezel" title="gksqlfhWkd1!" drawsBackground="YES" usesSingleLineMode="YES" id="esa-sk-9hO">
+++                                    <font key="font" metaFont="system"/>
+++                                    <color key="textColor" name="textColor" catalog="System" colorSpace="catalog"/>
+++                                    <color key="backgroundColor" name="textBackgroundColor" catalog="System" colorSpace="catalog"/>
+++                                    <allowedInputSourceLocales>
+++                                        <string>NSAllRomanInputSourcesLocaleIdentifier</string>
+++                                    </allowedInputSourceLocales>
+++                                </secureTextFieldCell>
+++                            </secureTextField>
+++                            <button verticalHuggingPriority="750" translatesAutoresizingMaskIntoConstraints="NO" id="U6H-wJ-C1H">
+++                                <rect key="frame" x="135" y="81" width="74" height="32"/>
+++                                <buttonCell key="cell" type="push" title="Login" bezelStyle="rounded" alignment="center" borderStyle="border" imageScaling="proportionallyDown" inset="2" id="het-M0-VTE">
+++                                    <behavior key="behavior" pushIn="YES" lightByBackground="YES" lightByGray="YES"/>
+++                                    <font key="font" metaFont="system"/>
+++                                </buttonCell>
+++                                <connections>
+++                                    <action selector="actionLogin:" target="XfG-lQ-9wD" id="tak-Hv-Wh1"/>
+++                                </connections>
+++                            </button>
+++                            <button verticalHuggingPriority="750" translatesAutoresizingMaskIntoConstraints="NO" id="7TL-H2-Tmu">
+++                                <rect key="frame" x="276" y="81" width="83" height="32"/>
+++                                <buttonCell key="cell" type="push" title="Logout" bezelStyle="rounded" alignment="center" borderStyle="border" imageScaling="proportionallyDown" inset="2" id="huG-hN-Hf8">
+++                                    <behavior key="behavior" pushIn="YES" lightByBackground="YES" lightByGray="YES"/>
+++                                    <font key="font" metaFont="system"/>
+++                                </buttonCell>
+++                                <connections>
+++                                    <action selector="actionLogout:" target="XfG-lQ-9wD" id="Cm8-rP-HqD"/>
+++                                </connections>
+++                            </button>
+++                        </subviews>
+++                        <constraints>
+++                            <constraint firstItem="SDN-0s-DTb" firstAttribute="leading" secondItem="YWn-PH-WzV" secondAttribute="leading" id="0bQ-a5-6v5"/>
+++                            <constraint firstItem="p4h-qf-Wor" firstAttribute="top" secondItem="JS7-Io-Koi" secondAttribute="top" id="1Vw-w7-BgT"/>
+++                            <constraint firstAttribute="trailing" secondItem="KtV-vx-4vz" secondAttribute="trailing" constant="100" id="4Me-Lx-2oV"/>
+++                            <constraint firstItem="nGf-xq-RQu" firstAttribute="centerX" secondItem="m2S-Jp-Qdl" secondAttribute="centerX" id="6sK-sd-xaz"/>
+++                            <constraint firstAttribute="trailing" secondItem="ohl-5L-mtw" secondAttribute="trailing" constant="100" id="6uU-Jd-wgH"/>
+++                            <constraint firstItem="ohl-5L-mtw" firstAttribute="top" secondItem="YWn-PH-WzV" secondAttribute="top" id="FGv-8D-zBy"/>
+++                            <constraint firstItem="JS7-Io-Koi" firstAttribute="top" secondItem="SDN-0s-DTb" secondAttribute="bottom" constant="22" id="MdJ-Rh-cUc"/>
+++                            <constraint firstItem="YWn-PH-WzV" firstAttribute="top" secondItem="m2S-Jp-Qdl" secondAttribute="top" constant="43" id="Nwz-DJ-TYu"/>
+++                            <constraint firstItem="U6H-wJ-C1H" firstAttribute="top" secondItem="p4h-qf-Wor" secondAttribute="bottom" constant="18" id="SoE-dx-UYh"/>
+++                            <constraint firstItem="U6H-wJ-C1H" firstAttribute="leading" secondItem="m2S-Jp-Qdl" secondAttribute="leading" constant="141" id="TBJ-Nv-2wi"/>
+++                            <constraint firstItem="7TL-H2-Tmu" firstAttribute="top" secondItem="p4h-qf-Wor" secondAttribute="bottom" constant="18" id="Tpd-KH-xFG"/>
+++                            <constraint firstItem="p4h-qf-Wor" firstAttribute="leading" secondItem="KtV-vx-4vz" secondAttribute="leading" id="VP5-RK-Zmd"/>
+++                            <constraint firstItem="SDN-0s-DTb" firstAttribute="top" secondItem="YWn-PH-WzV" secondAttribute="bottom" constant="22" id="g5B-y9-RWb"/>
+++                            <constraint firstItem="YWn-PH-WzV" firstAttribute="leading" secondItem="m2S-Jp-Qdl" secondAttribute="leading" constant="51" id="h6A-wr-R66"/>
+++                            <constraint firstAttribute="bottom" secondItem="nGf-xq-RQu" secondAttribute="bottom" constant="40" id="iG9-Fb-lxv"/>
+++                            <constraint firstItem="KtV-vx-4vz" firstAttribute="leading" secondItem="ohl-5L-mtw" secondAttribute="leading" id="oWd-Ad-Omk"/>
+++                            <constraint firstItem="ohl-5L-mtw" firstAttribute="leading" secondItem="YWn-PH-WzV" secondAttribute="trailing" constant="20" id="pGC-hm-gqw"/>
+++                            <constraint firstItem="JS7-Io-Koi" firstAttribute="leading" secondItem="YWn-PH-WzV" secondAttribute="leading" id="pZC-ai-PHd"/>
+++                            <constraint firstItem="KtV-vx-4vz" firstAttribute="top" secondItem="SDN-0s-DTb" secondAttribute="top" id="rpH-EV-ily"/>
+++                            <constraint firstAttribute="trailing" secondItem="p4h-qf-Wor" secondAttribute="trailing" constant="100" id="sDU-vI-rBb"/>
+++                            <constraint firstItem="7TL-H2-Tmu" firstAttribute="leading" secondItem="U6H-wJ-C1H" secondAttribute="trailing" constant="79" id="uL1-yw-ven"/>
+++                        </constraints>
++                     </view>
+++                    <connections>
+++                        <outlet property="domanTextField" destination="ohl-5L-mtw" id="9cW-Cd-wuR"/>
+++                        <outlet property="passTextField" destination="p4h-qf-Wor" id="dE8-Dr-Kou"/>
+++                        <outlet property="statusLogin" destination="nGf-xq-RQu" id="CiT-Yx-cBU"/>
+++                        <outlet property="userTextField" destination="KtV-vx-4vz" id="0lv-YN-WQw"/>
+++                    </connections>
++                 </viewController>
++                 <customObject id="rPt-NT-nkU" userLabel="First Responder" customClass="NSResponder" sceneMemberID="firstResponder"/>
++             </objects>
++diff --git a/CRMCall092016/Helpers/CRMCallConfig.swift b/CRMCall092016/Helpers/CRMCallConfig.swift
++index eb697bd..e3d3a96 100644
++--- a/CRMCall092016/Helpers/CRMCallConfig.swift
+++++ b/CRMCall092016/Helpers/CRMCallConfig.swift
++@@ -12,13 +12,29 @@ final class CRMCallConfig {
++     
++     static let Version = "20150202"
++     static let DeviceID = "MAC"
+++    static let HostName = "global3.hanbiro.com"
++     
+++    static let HeaderLength:UInt = 6
+++    
+++    // MARK: Tab
++     struct Tab {
++         static let Default = 0
++         static let Header = 1
++         static let BodyData = 2
++     }
++     
+++    // MARK: Notification
+++    struct Notification {
+++        static let SocketDidConnected = "SocketManager.SocketDidConnected"
+++        static let SocketDisConnected = "SocketManager.SocketDisConnected"
+++    }
+++    
+++    // MARK: API
+++    struct API {
+++        static let GetPortAndHostURL = "http://\(CRMCallConfig.HostName)/winapp/hcsong/crmcall/\(CRMCallConfig.HostName)/server.xml"
+++    }
+++    
+++    
++     
++     
++ }
++diff --git a/CRMCall092016/Helpers/XML/XMLRequestBuilder.swift b/CRMCall092016/Helpers/XML/XMLRequestBuilder.swift
++new file mode 100644
++index 0000000..db4a433
++--- /dev/null
+++++ b/CRMCall092016/Helpers/XML/XMLRequestBuilder.swift
++@@ -0,0 +1,28 @@
+++//
+++//  XMLRequestBuilder.swift
+++//  CRMCall092016
+++//
+++//  Created by Hanbiro on 9/7/16.
+++//  Copyright © 2016 xuanvinhtd. All rights reserved.
+++//
+++
+++import Foundation
+++
+++final class XMLRequestBuilder {
+++    
+++    // MARK: - LOGIN/LOGOUT
+++    static func loginRequest(with userID: String, pass: String, domain: String) -> String {
+++        
+++        return  String(format: "<XML> <VER>%@</VER> <USER> <LOGIN ID=\"%@\" PASSWORD=\"%@\" DOMAIN=\"%@\" VER=\"1.0\" ISPTYPE=\"\" PHONE=\"\" DEVICE=\"%@\"></LOGIN> </USER> </XML>", CRMCallConfig.Version, userID, pass, domain, CRMCallConfig.DeviceID)
+++        
+++    }
+++    
+++    static func logOutRequest() -> String {
+++        
+++        return String(format: "<XML><VER>%@</VER><USER><LOGOUT></LOGOUT></USER></XML>", CRMCallConfig.Version)
+++    }
+++    
+++    static func liveRequest() -> String {
+++        return String(format: "<XML><VER>%@</VER><ALARM><LIVE/></ALARM></XML>", CRMCallConfig.Version)
+++    }
+++}
++\ No newline at end of file
++diff --git a/CRMCall092016/Info.plist b/CRMCall092016/Info.plist
++index e435186..4001dfd 100644
++--- a/CRMCall092016/Info.plist
+++++ b/CRMCall092016/Info.plist
++@@ -2,6 +2,11 @@
++ <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
++ <plist version="1.0">
++ <dict>
+++	<key>NSAppTransportSecurity</key>
+++	<dict>
+++		<key>NSAllowsArbitraryLoads</key>
+++		<true/>
+++	</dict>
++ 	<key>CFBundleDevelopmentRegion</key>
++ 	<string>en</string>
++ 	<key>CFBundleExecutable</key>
++diff --git a/CRMCall092016/Library/AlamofireManager.swift b/CRMCall092016/Library/AlamofireManager.swift
++new file mode 100644
++index 0000000..ddf3f38
++--- /dev/null
+++++ b/CRMCall092016/Library/AlamofireManager.swift
++@@ -0,0 +1,36 @@
+++//
+++//  AlamofireManager.swift
+++//  CRMCall092016
+++//
+++//  Created by Hanbiro on 9/8/16.
+++//  Copyright © 2016 xuanvinhtd. All rights reserved.
+++//
+++
+++import Foundation
+++import Alamofire
+++
+++final class AlamofireManager {
+++    
+++    static func getData(withURL url: String, withCompletion completion: ((withData: NSData?) ->Void)?) {
+++    
+++        Alamofire.request(.GET, url)
+++            .responseString { response in
+++                
+++                println("\(response)")
+++                
+++                guard let Completion = completion else {
+++                    fatalError("Not found Closure completion")
+++                }
+++                
+++                if response.result.isSuccess {
+++                    
+++                    Completion(withData: response.data)
+++
+++                } else {
+++                    println("get data by Alamofire fail")
+++                    Completion(withData: nil)
+++                }
+++        }
+++        
+++    }
+++}
++\ No newline at end of file
++diff --git a/CRMCall092016/Library/SWXMLHashManager.swift b/CRMCall092016/Library/SWXMLHashManager.swift
++new file mode 100644
++index 0000000..aa21a07
++--- /dev/null
+++++ b/CRMCall092016/Library/SWXMLHashManager.swift
++@@ -0,0 +1,113 @@
+++//
+++//  SWXMLHashManager.swift
+++//  CRMCall092016
+++//
+++//  Created by Hanbiro on 9/8/16.
+++//  Copyright © 2016 xuanvinhtd. All rights reserved.
+++//
+++
+++import Foundation
+++
+++import SWXMLHash
+++
+++
+++final class SWXMLHashManager {
+++    
+++    // MARK: - XML PARSER
+++    static func parseXMLToDictionary(withXML xmlData: String) -> [String: String] {
+++        
+++        let xmlDocument = SWXMLHash.parse(xmlData)
+++        
+++        if let _ = xmlDocument["XML"]["USER"].element {
+++            return userData(withData: xmlDocument)
+++        }
+++        
+++        if let _ = xmlDocument["XML"]["SERVERINFO"].element {
+++            return getHostAndPost(withData: xmlDocument)
+++        }
+++        
+++        return [:]
+++    }
+++    
+++    private static func userData(withData data: XMLIndexer) -> [String: String]{
+++        
+++        if let _ = data["XML"]["USER"]["LOGIN"].element {
+++            
+++            guard let userDictionnary = data["XML"]["USER"].element else {
+++                println("Cannot parse XML: USER LOGIN")
+++                return [:]
+++            }
+++            
+++            println("Result parse User: --------XXX------- \n \(userDictionnary)")
+++            
+++            NSNotificationCenter.defaultCenter().postNotificationName(ViewController.Notification.loginSuccess, object: nil, userInfo: nil)
+++            
+++            return userDictionnary.attributes
+++        }
+++        
+++        if let _ = data["XML"]["USER"]["LOGOUT"].element {
+++
+++            guard let userDictionnary = data["XML"]["USER"].element else {
+++                println("Cannot parse XML: USER LOGIN")
+++                return [:]
+++            }
+++
+++            println("Result parse User: --------XXX------- \n \(userDictionnary)")
+++            
+++            NSNotificationCenter.defaultCenter().postNotificationName(ViewController.Notification.logoutSuccess, object: nil, userInfo: nil)
+++            
+++            return userDictionnary.attributes
+++        }
+++        
+++        return [:]
+++    }
+++
+++    private static func getHostAndPost(withData data: XMLIndexer) -> [String: String]{
+++
+++        guard let userDictionnary = data["XML"]["SERVERINFO"].element else {
+++            println("Cannot parse XML: SERVERINFO")
+++            return [:]
+++        }
+++        
+++        println("Result parse SERVERINFO: --------XXX------- \n \(userDictionnary)")
+++        
+++        return userDictionnary.attributes
+++    }
+++}
+++
+++// MARK: USER
+++struct User: XMLIndexerDeserializable {
+++    let baseURL: String?
+++    let cacheProduct: Int?
+++    let cachePurpose: String?
+++    let companyPhone: String?
+++    let email: String?
+++    let nickName: String?
+++    let id: String?
+++    let localPhone: String?
+++    let mobilePhone: String?
+++    let telephone: String?
+++    let sex: String?
+++    let userKey: String?
+++    let userName: String?
+++    let result: String?
+++    
+++    static func deserialize(note: XMLIndexer) throws -> User {
+++        return try User(
+++            baseURL: note["BASEURL"].value(),
+++            cacheProduct: note["CACHE_PRODUCT"].value(),
+++            cachePurpose: note["CACHE_PURPOSE"].value(),
+++            companyPhone: note["COMPANYPHONE"].value(),
+++            email: note["EMAIL"].value(),
+++            nickName: note["NICKNAME"].value(),
+++            id: note["ID"].value(),
+++            localPhone: note["LOCALPHONE"].value(),
+++            mobilePhone: note["MOBILEPHONE"].value(),
+++            telephone: note["TELEPHONE"].value(),
+++            sex: note["SEX"].value(),
+++            userKey: note["USERKEY"].value(),
+++            userName: note["USERNAME"].value(),
+++            result: note["RESULT"].value()
+++        )
+++    }
+++}
++\ No newline at end of file
++diff --git a/CRMCall092016/Models/ModelManger.swift b/CRMCall092016/Models/ModelManger.swift
++new file mode 100644
++index 0000000..2ec3b9e
++--- /dev/null
+++++ b/CRMCall092016/Models/ModelManger.swift
++@@ -0,0 +1,12 @@
+++//
+++//  User.swift
+++//  CRMCall092016
+++//
+++//  Created by Hanbiro on 9/8/16.
+++//  Copyright © 2016 xuanvinhtd. All rights reserved.
+++//
+++
+++import Foundation
+++
+++
+++
++diff --git a/CRMCall092016/Server/.DS_Store b/CRMCall092016/Server/.DS_Store
++new file mode 100644
++index 0000000..5008ddf
++Binary files /dev/null and b/CRMCall092016/Server/.DS_Store differ
++diff --git a/CRMCall092016/Server/Socket/BaseSocket.swift b/CRMCall092016/Server/Socket/BaseSocket.swift
++new file mode 100644
++index 0000000..a74e975
++--- /dev/null
+++++ b/CRMCall092016/Server/Socket/BaseSocket.swift
++@@ -0,0 +1,178 @@
+++//
+++//  SocketManager.swift
+++//  CRMCall092016
+++//
+++//  Created by Hanbiro on 9/7/16.
+++//  Copyright © 2016 xuanvinhtd. All rights reserved.
+++//
+++
+++import Foundation
+++import CocoaAsyncSocket
+++
+++class BaseSocket: NSObject {
+++    
+++    // MARK: - Properties
+++    private var flagEncrypt: String = "1"
+++    private var readTimeOut: Double = 60.0
+++    private var writeTimeOut: Double = 5.0
+++    
+++    var isConnectedToHost: Bool = false
+++    
+++    private var aesExtension: AESExtension
+++    private var asynSocket: GCDAsyncSocket!
+++
+++    private var port: UInt16
+++    private var host: String
+++    
+++    // MARK: - Initialize
+++    
+++    init(withHost host: String, port: UInt16) {
+++
+++        self.host = host
+++        self.port = port
+++        self.aesExtension = AESExtension()
+++        
+++        super.init()
+++        
+++        self.asynSocket = GCDAsyncSocket(delegate: self, delegateQueue: dispatch_get_main_queue())
+++    }
+++    
+++    override init() {
+++        
+++        self.host = ""
+++        self.port = 0
+++        self.aesExtension = AESExtension()
+++        
+++        super.init()
+++        
+++        self.asynSocket = GCDAsyncSocket(delegate: self, delegateQueue: dispatch_get_main_queue())
+++        
+++        getIdAndHost()
+++    }
+++    
+++    // MARK: - Socket handling
+++    
+++    func connect() {
+++        
+++        do {
+++
+++           try asynSocket.connectToHost(host, onPort: port)
+++            
+++        } catch let err {
+++            println("Error connect socket: \(err)")
+++        }
+++    }
+++    
+++    func disConnect() {
+++        
+++        asynSocket.disconnect()
+++        
+++        isConnectedToHost = false
+++    }
+++    
+++    func configData(withData strData: String) {
+++        
+++        let encryptData = aesExtension.aesEncryptString(strData)
+++        
+++        let headerData = String(format: "%05lu", (encryptData?.characters.count)! + 1)
+++        
+++        let requestData = headerData + String(format: "%@%@", flagEncrypt, encryptData!)
+++        
+++        sendData(requestData.dataUsingEncoding(NSUTF8StringEncoding)!)
+++    }
+++    
+++   private func sendData(data: NSData) {
+++    
+++    asynSocket.writeData(data, withTimeout: writeTimeOut, tag: CRMCallConfig.Tab.Default)
+++    
+++    }
+++    
+++    private func getIdAndHost() {
+++        
+++        AlamofireManager.getData(withURL: CRMCallConfig.API.GetPortAndHostURL) { response in
+++            
+++            guard let _response = response else {
+++                println("Cannot get port and host to hostName: \(CRMCallConfig.HostName)")
+++                return
+++            }
+++            
+++            guard let result = NSString(data: _response, encoding: NSUTF8StringEncoding) as? String else {
+++                println("Not found data to server")
+++                return
+++            }
+++            
+++            let resultDic = SWXMLHashManager.parseXMLToDictionary(withXML: result)
+++            
+++            if let port = resultDic["PORT"], host = resultDic["IP"] {
+++                self.port = UInt16(port)!
+++                self.host = host
+++            } else {
+++                println("Cannot parse port and host: \(CRMCallConfig.HostName)")
+++            }
+++            
+++            NSNotificationCenter.defaultCenter().postNotificationName(ViewController.Notification.connectToHost, object: nil, userInfo: nil)
+++        }
+++    }
+++}
+++
+++// MARK: - Socket Delegate 
+++extension BaseSocket: GCDAsyncSocketDelegate {
+++    
+++    func socket(sock: GCDAsyncSocket, didReadData data: NSData, withTag tag: Int) {
+++        
+++        if tag == CRMCallConfig.Tab.Header {
+++            
+++            guard let headerData = NSString(data: data, encoding: NSUTF8StringEncoding) else {
+++                fatalError("Not found header data")
+++            }
+++
+++            println("Data header: \(headerData)")
+++            
+++            let lenghtHeader = (UInt(headerData.substringToIndex(5))! - 1)
+++            flagEncrypt = headerData.substringFromIndex(5)
+++            
+++            asynSocket.readDataToLength(lenghtHeader, withTimeout: readTimeOut , tag: CRMCallConfig.Tab.BodyData)
+++            
+++            
+++        } else if (tag == CRMCallConfig.Tab.BodyData) {
+++            
+++            guard let bodyData = NSString(data: data, encoding: NSUTF8StringEncoding) as? String else {
+++                fatalError("Not found body data")
+++            }
+++
+++            var decryptBodyData = ""
+++            
+++            if flagEncrypt == "1" {
+++                
+++                guard let dataDecrypt = aesExtension.aesDecryptString(bodyData) else {
+++                    fatalError("Not Decrypt body data")
+++                }
+++                
+++                decryptBodyData = dataDecrypt
+++            } else {
+++                decryptBodyData = bodyData
+++            }
+++            
+++            println("Data body: \(decryptBodyData)")
+++            
+++            asynSocket.readDataToLength(CRMCallConfig.HeaderLength, withTimeout: readTimeOut, tag: CRMCallConfig.Tab.Header)
+++            
+++            SWXMLHashManager.parseXMLToDictionary(withXML: decryptBodyData)
+++        }
+++    }
+++    
+++    func socket(sock: GCDAsyncSocket, didWritePartialDataOfLength partialLength: UInt, tag: Int) {
+++        println("lenght: \(partialLength)")
+++    }
+++    
+++    func socket(sock: GCDAsyncSocket, didConnectToHost host: String, port: UInt16) {
+++        
+++        println("Did connet to host: \(host) and post: \(port)")
+++        
+++        isConnectedToHost = true
+++        
+++        asynSocket.readDataToLength(CRMCallConfig.HeaderLength, withTimeout: readTimeOut, tag: CRMCallConfig.Tab.Header)
+++        
+++        NSNotificationCenter.defaultCenter().postNotificationName(CRMCallConfig.Notification.SocketDidConnected, object: nil, userInfo: nil)
+++    }
+++}
++diff --git a/CRMCall092016/Server/Socket/CRMCallSocket.swift b/CRMCall092016/Server/Socket/CRMCallSocket.swift
++new file mode 100644
++index 0000000..bcc5fb3
++--- /dev/null
+++++ b/CRMCall092016/Server/Socket/CRMCallSocket.swift
++@@ -0,0 +1,40 @@
+++//
+++//  CRMCallSocket.swift
+++//  CRMCall092016
+++//
+++//  Created by Hanbiro on 9/12/16.
+++//  Copyright © 2016 xuanvinhtd. All rights reserved.
+++//
+++
+++import Foundation
+++
+++final class CRMCallSocket: BaseSocket {
+++    
+++    // MARK: - Properties
+++    var timerLive: String
+++    
+++    // MARK: - Initialzation
+++    override init() {
+++        
+++        timerLive = ""
+++        super.init()
+++        
+++    }
+++    
+++    // MARK: - COMUNICATION API
+++    
+++    func requestLogin(withUserID userID: String, passwold: String, domain: String) {
+++        
+++        let xmlLogin = XMLRequestBuilder.loginRequest(with: userID, pass: passwold, domain: domain)
+++        
+++        configData(withData: xmlLogin)
+++    }
+++    
+++    func requestLogout() {
+++        
+++        let xmlLogOut = XMLRequestBuilder.logOutRequest()
+++        
+++        configData(withData: xmlLogOut)
+++    }
+++    
+++}
++\ No newline at end of file
++diff --git a/CRMCall092016/Server/Socket/SocketManager.swift b/CRMCall092016/Server/Socket/SocketManager.swift
++deleted file mode 100644
++index 13022fb..0000000
++--- a/CRMCall092016/Server/Socket/SocketManager.swift
+++++ /dev/null
++@@ -1,98 +0,0 @@
++-//
++-//  SocketManager.swift
++-//  CRMCall092016
++-//
++-//  Created by Hanbiro on 9/7/16.
++-//  Copyright © 2016 xuanvinhtd. All rights reserved.
++-//
++-
++-import Foundation
++-import CocoaAsyncSocket
++-
++-class SocketManager: NSObject {
++-    
++-    // MARK: - Properties
++-    private var flagEncrypt: String = "1"
++-    private var readTimeOut: Double = 60.0
++-    private var writeTimeOut: Double = 5.0
++-    
++-    private var aesExtension: AESExtension?
++-    private var asynSocket: GCDAsyncSocket?
++-    
++-    private var port: UInt16?
++-    private var host: String?
++-    
++-    // MARK: - Initialize
++-     init (with host: String, port: UInt16) {
++-        
++-        super.init()
++-        
++-        self.host = host
++-        self.port = port
++-        self.aesExtension = AESExtension()
++-        self.asynSocket = GCDAsyncSocket(delegate: self, delegateQueue: dispatch_get_main_queue())
++-    }
++-    
++-    // MARK: - Socket handling
++-    func connect() {
++-        
++-        guard let host = self.host, port = self.port else { fatalError() }
++-        
++-        do {
++-
++-           try asynSocket?.connectToHost(host, onPort: port)
++-            
++-        } catch let err {
++-            println("Error connect socket: \(err)")
++-        }
++-    }
++-    
++-    func disConnect() {
++-        
++-        guard let socket = self.asynSocket else { fatalError() }
++-        
++-        socket.disconnect()
++-    }
++-    
++-    func configData(With strData: String) {
++-        
++-        let encryptData = aesExtension?.aesEncryptString(strData)
++-        
++-        let headerData = String(format: "%05lu", (encryptData?.characters.count)! + 1)
++-        
++-        let requestData = headerData + String(format: "%@%@", flagEncrypt, encryptData!)
++-        
++-        sendData(requestData.dataUsingEncoding(NSUTF8StringEncoding)!)
++-    }
++-    
++-    func sendData(data: NSData) {
++-        asynSocket?.writeData(data, withTimeout: writeTimeOut, tag: CRMCallConfig.Tab.Default)
++-    }
++-    
++-}
++-
++-// MARK: - Delegate Socket
++-extension SocketManager: GCDAsyncSocketDelegate {
++-    
++-    func socket(sock: GCDAsyncSocket, didReadData data: NSData, withTag tag: Int) {
++-        
++-        if tag == CRMCallConfig.Tab.Header {
++-            print("data server: \(data)")
++-        } else if (tag == CRMCallConfig.Tab.BodyData) {
++-            
++-        } else {
++-            
++-        }
++-        
++-    }
++-    
++-    func socket(sock: GCDAsyncSocket, didWritePartialDataOfLength partialLength: UInt, tag: Int) {
++-        print("lenght: \(partialLength)")
++-    }
++-    
++-    func socket(sock: GCDAsyncSocket, didConnectToHost host: String, port: UInt16) {
++-        
++-        println("DidConnet to host: \(host) and post: \(port)")
++-        
++-    }
++-}
++diff --git a/CRMCall092016/Server/XMLRequestBuilder.swift b/CRMCall092016/Server/XMLRequestBuilder.swift
++deleted file mode 100644
++index 202f606..0000000
++--- a/CRMCall092016/Server/XMLRequestBuilder.swift
+++++ /dev/null
++@@ -1,20 +0,0 @@
++-//
++-//  XMLRequestBuilder.swift
++-//  CRMCall092016
++-//
++-//  Created by Hanbiro on 9/7/16.
++-//  Copyright © 2016 xuanvinhtd. All rights reserved.
++-//
++-
++-import Foundation
++-
++-final class XMLRequestBuilder {
++-    
++-    // MARK: - LOGIN/LOGOUT
++-    class func createLoginRequest(with userID: String, pass: String, domain: String) -> String {
++-        
++-        let xml = String(format: "<XML> <VER>%@</VER> <USER> <LOGIN ID=\"%@\" PASSWORD=\"%@\" DOMAIN=\"%@\" VER=\"1.0\" ISPTYPE=\"\" PHONE=\"\" DEVICE=\"%@\"></LOGIN> </USER> </XML>", CRMCallConfig.Version, userID, pass, domain, CRMCallConfig.DeviceID)
++-        
++-        return xml
++-    }
++-}
++\ No newline at end of file
++diff --git a/CRMCall092016/ViewController.swift b/CRMCall092016/ViewController.swift
++index 95fd570..7872dd3 100644
++--- a/CRMCall092016/ViewController.swift
+++++ b/CRMCall092016/ViewController.swift
++@@ -10,22 +10,126 @@ import Cocoa
++ 
++ class ViewController: NSViewController {
++ 
++-    var aesExtension: AESExtension?
+++    // MARK: - Properties
+++    private var socketManager: BaseSocket!
+++    
+++    private var handlerNotificationSocketDidConnected: AnyObject?
+++    private var handlerNotificationLoginSuccess: AnyObject?
+++    private var handlerNotificationLogoutSuccess: AnyObject?
+++    private var handlerNotificationConnectToHost: AnyObject?
+++    
+++    @IBOutlet weak var domanTextField: NSTextField!
+++    @IBOutlet weak var userTextField: NSTextField!
+++    @IBOutlet weak var passTextField: NSSecureTextField!
+++    @IBOutlet weak var statusLogin: NSTextField!
+++    
+++    // MARK: - View life cycle
++     
++     override func viewDidLoad() {
++         super.viewDidLoad()
++-
++-        aesExtension = AESExtension()
++         
++-        // Do any additional setup after loading the view.
+++        registerNotification()
+++        
+++        socketManager = CRMCallSocket()
++     }
++ 
+++    deinit {
+++        deRegisterNotification()
+++    }
+++    
++     override var representedObject: AnyObject? {
++         didSet {
++         // Update the view, if already loaded.
++         }
++     }
+++    
+++    
+++    // MARK: - Handling event
+++    
+++    @IBAction func actionLogin(sender: AnyObject) {
+++        
+++        if socketManager.isConnectedToHost == true {
+++            
+++            requestLogin(withUserID: userTextField.stringValue, pass: passTextField.stringValue, domain: domanTextField.stringValue)
+++        } else {
+++            println("Waiting connect to server .....")
+++        }
+++        
+++    }
+++    
+++    @IBAction func actionLogout(sender: AnyObject) {
+++        
+++        if socketManager.isConnectedToHost == true {
+++            requestLogOut()
+++        } else {
+++            println("Disconnect to server")
+++        }
++ 
++-
+++    }
+++    
+++    // MARK: - Notification
+++    struct Notification {
+++        static let loginSuccess = "LoginSuccessNotification"
+++        static let logoutSuccess = "LogoutSuccessNotification"
+++        static let connectToHost = "ConnectHostNotification"
+++    }
+++    
+++    private func registerNotification() {
+++        
+++        handlerNotificationSocketDidConnected = NSNotificationCenter.defaultCenter().addObserverForName(CRMCallConfig.Notification.SocketDidConnected, object: nil, queue: nil) { notification in
+++            
+++            println("\(notification)")
+++        }
+++        
+++        handlerNotificationLoginSuccess = NSNotificationCenter.defaultCenter().addObserverForName(ViewController.Notification.loginSuccess, object: nil, queue: nil) { notification in
+++            
+++            println("\(notification)")
+++            self.statusLogin.hidden = false
+++        }
+++        
+++        handlerNotificationLogoutSuccess = NSNotificationCenter.defaultCenter().addObserverForName(ViewController.Notification.logoutSuccess, object: nil, queue: nil) { notification in
+++            
+++            println("\(notification)")
+++            self.statusLogin.hidden = true
+++        }
+++        
+++        handlerNotificationConnectToHost = NSNotificationCenter.defaultCenter().addObserverForName(ViewController.Notification.connectToHost, object: nil, queue: nil) { notification in
+++            
+++            println("\(notification)")
+++            
+++            self.socketManager.connect()
+++        }
+++    }
+++    
+++    private func deRegisterNotification() {
+++        
+++        if let notification = handlerNotificationSocketDidConnected {
+++            NSNotificationCenter.defaultCenter().removeObserver(notification)
+++        }
+++        
+++        if let notification = handlerNotificationLoginSuccess {
+++            NSNotificationCenter.defaultCenter().removeObserver(notification)
+++        }
+++        
+++        if let notification = handlerNotificationLogoutSuccess {
+++            NSNotificationCenter.defaultCenter().removeObserver(notification)
+++        }
+++        
+++        if let notification = handlerNotificationConnectToHost {
+++            NSNotificationCenter.defaultCenter().removeObserver(notification)
+++        }
+++    }
+++    
+++    // MARK: - USER LOGIN/OUT
+++    private func requestLogin(withUserID userID: String, pass: String, domain: String) {
+++        
+++        let xmlLogin = XMLRequestBuilder.loginRequest(with: userID, pass: pass, domain: domain)
+++        
+++        socketManager.configData(withData: xmlLogin)
+++    }
+++    
+++    private func requestLogOut() {
+++        
+++    }
++ }
++ 
++diff --git a/Podfile b/Podfile
++index 3f528b0..f57e6c5 100644
++--- a/Podfile
+++++ b/Podfile
++@@ -5,6 +5,9 @@ project 'CRMCall092016.xcodeproj'
++ 
++ target 'CRMCall092016' do
++  use_frameworks!
+++ 
++ pod 'CocoaAsyncSocket'
+++pod 'Alamofire'
+++pod 'SWXMLHash'
++ 
++ end
++diff --git a/Podfile.lock b/Podfile.lock
++index 4be331a..0ae9987 100644
++--- a/Podfile.lock
+++++ b/Podfile.lock
++@@ -1,14 +1,20 @@
++ PODS:
+++  - Alamofire (3.4.1)
++   - CocoaAsyncSocket (7.5.0):
++     - CocoaAsyncSocket/GCD (= 7.5.0)
++   - CocoaAsyncSocket/GCD (7.5.0)
+++  - SWXMLHash (2.4.0)
++ 
++ DEPENDENCIES:
+++  - Alamofire
++   - CocoaAsyncSocket
+++  - SWXMLHash
++ 
++ SPEC CHECKSUMS:
+++  Alamofire: 01a82e2f6c0f860ade35534c8dd88be61bdef40c
++   CocoaAsyncSocket: 3baeb1ddd969f81cf9fca81053ae49ef2d1cbbfa
+++  SWXMLHash: 507397103325f140863d09040c04ae14a49a16cb
++ 
++-PODFILE CHECKSUM: e6332a1e2227a6d3ff82fcc374286642be589891
+++PODFILE CHECKSUM: 3d088204bac8fcec64bd2420b15ef2f3c7764d77
++ 
++ COCOAPODS: 1.0.0
++diff --git a/Pods/Alamofire/LICENSE b/Pods/Alamofire/LICENSE
++new file mode 100644
++index 0000000..4cfbf72
++--- /dev/null
+++++ b/Pods/Alamofire/LICENSE
++@@ -0,0 +1,19 @@
+++Copyright (c) 2014-2016 Alamofire Software Foundation (http://alamofire.org/)
+++
+++Permission is hereby granted, free of charge, to any person obtaining a copy
+++of this software and associated documentation files (the "Software"), to deal
+++in the Software without restriction, including without limitation the rights
+++to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+++copies of the Software, and to permit persons to whom the Software is
+++furnished to do so, subject to the following conditions:
+++
+++The above copyright notice and this permission notice shall be included in
+++all copies or substantial portions of the Software.
+++
+++THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+++IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+++FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+++AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+++LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+++OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+++THE SOFTWARE.
++diff --git a/Pods/Alamofire/README.md b/Pods/Alamofire/README.md
++new file mode 100644
++index 0000000..56a6771
++--- /dev/null
+++++ b/Pods/Alamofire/README.md
++@@ -0,0 +1,1297 @@
+++![Alamofire: Elegant Networking in Swift](https://raw.githubusercontent.com/Alamofire/Alamofire/assets/alamofire.png)
+++
+++[![Build Status](https://travis-ci.org/Alamofire/Alamofire.svg)](https://travis-ci.org/Alamofire/Alamofire)
+++[![CocoaPods Compatible](https://img.shields.io/cocoapods/v/Alamofire.svg)](https://img.shields.io/cocoapods/v/Alamofire.svg)
+++[![Carthage Compatible](https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat)](https://github.com/Carthage/Carthage)
+++[![Platform](https://img.shields.io/cocoapods/p/Alamofire.svg?style=flat)](http://cocoadocs.org/docsets/Alamofire)
+++[![Twitter](https://img.shields.io/badge/twitter-@AlamofireSF-blue.svg?style=flat)](http://twitter.com/AlamofireSF)
+++
+++Alamofire is an HTTP networking library written in Swift.
+++
+++## Features
+++
+++- [x] Chainable Request / Response methods
+++- [x] URL / JSON / plist Parameter Encoding
+++- [x] Upload File / Data / Stream / MultipartFormData
+++- [x] Download using Request or Resume data
+++- [x] Authentication with NSURLCredential
+++- [x] HTTP Response Validation
+++- [x] TLS Certificate and Public Key Pinning
+++- [x] Progress Closure & NSProgress
+++- [x] cURL Debug Output
+++- [x] Comprehensive Unit Test Coverage
+++- [x] [Complete Documentation](http://cocoadocs.org/docsets/Alamofire)
+++
+++## Component Libraries
+++
+++In order to keep Alamofire focused specifically on core networking implementations, additional component libraries have been created by the [Alamofire Software Foundation](https://github.com/Alamofire/Foundation) to bring additional functionality to the Alamofire ecosystem.
+++
+++* [AlamofireImage](https://github.com/Alamofire/AlamofireImage) - An image library including image response serializers, `UIImage` and `UIImageView` extensions, custom image filters, an auto-purging in-memory cache and a priority-based image downloading system.
+++* [AlamofireNetworkActivityIndicator](https://github.com/Alamofire/AlamofireNetworkActivityIndicator) - Controls the visibility of the network activity indicator on iOS using Alamofire. It contains configurable delay timers to help mitigate flicker and can support `NSURLSession` instances not managed by Alamofire.
+++
+++## Requirements
+++
+++- iOS 8.0+ / Mac OS X 10.9+ / tvOS 9.0+ / watchOS 2.0+
+++- Xcode 7.3+
+++
+++## Migration Guides
+++
+++- [Alamofire 3.0 Migration Guide](https://github.com/Alamofire/Alamofire/blob/master/Documentation/Alamofire%203.0%20Migration%20Guide.md)
+++- [Alamofire 2.0 Migration Guide](https://github.com/Alamofire/Alamofire/blob/master/Documentation/Alamofire%202.0%20Migration%20Guide.md)
+++
+++## Communication
+++
+++- If you **need help**, use [Stack Overflow](http://stackoverflow.com/questions/tagged/alamofire). (Tag 'alamofire')
+++- If you'd like to **ask a general question**, use [Stack Overflow](http://stackoverflow.com/questions/tagged/alamofire).
+++- If you **found a bug**, open an issue.
+++- If you **have a feature request**, open an issue.
+++- If you **want to contribute**, submit a pull request.
+++
+++## Installation
+++
+++> **Embedded frameworks require a minimum deployment target of iOS 8 or OS X Mavericks (10.9).**
+++>
+++> Alamofire is no longer supported on iOS 7 due to the lack of support for frameworks. Without frameworks, running Travis-CI against iOS 7 would require a second duplicated test target. The separate test suite would need to import all the Swift files and the tests would need to be duplicated and re-written. This split would be too difficult to maintain to ensure the highest possible quality of the Alamofire ecosystem.
+++
+++### CocoaPods
+++
+++[CocoaPods](http://cocoapods.org) is a dependency manager for Cocoa projects. You can install it with the following command:
+++
+++```bash
+++$ gem install cocoapods
+++```
+++
+++> CocoaPods 0.39.0+ is required to build Alamofire 3.0.0+.
+++
+++To integrate Alamofire into your Xcode project using CocoaPods, specify it in your `Podfile`:
+++
+++```ruby
+++source 'https://github.com/CocoaPods/Specs.git'
+++platform :ios, '9.0'
+++use_frameworks!
+++
+++target '<Your Target Name>' do
+++    pod 'Alamofire', '~> 3.4'
+++end
+++```
+++
+++Then, run the following command:
+++
+++```bash
+++$ pod install
+++```
+++
+++### Carthage
+++
+++[Carthage](https://github.com/Carthage/Carthage) is a decentralized dependency manager that builds your dependencies and provides you with binary frameworks.
+++
+++You can install Carthage with [Homebrew](http://brew.sh/) using the following command:
+++
+++```bash
+++$ brew update
+++$ brew install carthage
+++```
+++
+++To integrate Alamofire into your Xcode project using Carthage, specify it in your `Cartfile`:
+++
+++```ogdl
+++github "Alamofire/Alamofire" ~> 3.4
+++```
+++
+++Run `carthage update` to build the framework and drag the built `Alamofire.framework` into your Xcode project.
+++
+++### Manually
+++
+++If you prefer not to use either of the aforementioned dependency managers, you can integrate Alamofire into your project manually.
+++
+++#### Embedded Framework
+++
+++- Open up Terminal, `cd` into your top-level project directory, and run the following command "if" your project is not initialized as a git repository:
+++
+++```bash
+++$ git init
+++```
+++
+++- Add Alamofire as a git [submodule](http://git-scm.com/docs/git-submodule) by running the following command:
+++
+++```bash
+++$ git submodule add https://github.com/Alamofire/Alamofire.git
+++```
+++
+++- Open the new `Alamofire` folder, and drag the `Alamofire.xcodeproj` into the Project Navigator of your application's Xcode project.
+++
+++    > It should appear nested underneath your application's blue project icon. Whether it is above or below all the other Xcode groups does not matter.
+++
+++- Select the `Alamofire.xcodeproj` in the Project Navigator and verify the deployment target matches that of your application target.
+++- Next, select your application project in the Project Navigator (blue project icon) to navigate to the target configuration window and select the application target under the "Targets" heading in the sidebar.
+++- In the tab bar at the top of that window, open the "General" panel.
+++- Click on the `+` button under the "Embedded Binaries" section.
+++- You will see two different `Alamofire.xcodeproj` folders each with two different versions of the `Alamofire.framework` nested inside a `Products` folder.
+++
+++    > It does not matter which `Products` folder you choose from, but it does matter whether you choose the top or bottom `Alamofire.framework`. 
+++    
+++- Select the top `Alamofire.framework` for iOS and the bottom one for OS X.
+++
+++    > You can verify which one you selected by inspecting the build log for your project. The build target for `Alamofire` will be listed as either `Alamofire iOS` or `Alamofire OSX`.
+++
+++- And that's it!
+++
+++> The `Alamofire.framework` is automagically added as a target dependency, linked framework and embedded framework in a copy files build phase which is all you need to build on the simulator and a device.
+++
+++---
+++
+++## Usage
+++
+++### Making a Request
+++
+++```swift
+++import Alamofire
+++
+++Alamofire.request(.GET, "https://httpbin.org/get")
+++```
+++
+++### Response Handling
+++
+++```swift
+++Alamofire.request(.GET, "https://httpbin.org/get", parameters: ["foo": "bar"])
+++         .responseJSON { response in
+++             print(response.request)  // original URL request
+++             print(response.response) // URL response
+++             print(response.data)     // server data
+++             print(response.result)   // result of response serialization
+++
+++             if let JSON = response.result.value {
+++                 print("JSON: \(JSON)")
+++             }
+++         }
+++```
+++
+++> Networking in Alamofire is done _asynchronously_. Asynchronous programming may be a source of frustration to programmers unfamiliar with the concept, but there are [very good reasons](https://developer.apple.com/library/ios/qa/qa1693/_index.html) for doing it this way.
+++
+++> Rather than blocking execution to wait for a response from the server, a [callback](http://en.wikipedia.org/wiki/Callback_%28computer_programming%29) is specified to handle the response once it's received. The result of a request is only available inside the scope of a response handler. Any execution contingent on the response or data received from the server must be done within a handler.
+++
+++### Validation
+++
+++By default, Alamofire treats any completed request to be successful, regardless of the content of the response. Calling `validate` before a response handler causes an error to be generated if the response had an unacceptable status code or MIME type.
+++
+++#### Manual Validation
+++
+++```swift
+++Alamofire.request(.GET, "https://httpbin.org/get", parameters: ["foo": "bar"])
+++         .validate(statusCode: 200..<300)
+++         .validate(contentType: ["application/json"])
+++         .response { response in
+++             print(response)
+++         }
+++```
+++
+++#### Automatic Validation
+++
+++Automatically validates status code within `200...299` range, and that the `Content-Type` header of the response matches the `Accept` header of the request, if one is provided.
+++
+++```swift
+++Alamofire.request(.GET, "https://httpbin.org/get", parameters: ["foo": "bar"])
+++         .validate()
+++         .responseJSON { response in
+++             switch response.result {
+++             case .Success:
+++                 print("Validation Successful")
+++             case .Failure(let error):
+++                 print(error)
+++             }
+++         }
+++```
+++
+++### Response Serialization
+++
+++**Built-in Response Methods**
+++
+++- `response()`
+++- `responseData()`
+++- `responseString(encoding: NSStringEncoding)`
+++- `responseJSON(options: NSJSONReadingOptions)`
+++- `responsePropertyList(options: NSPropertyListReadOptions)`
+++
+++#### Response Handler
+++
+++```swift
+++Alamofire.request(.GET, "https://httpbin.org/get", parameters: ["foo": "bar"])
+++         .validate()
+++         .response { request, response, data, error in
+++             print(request)
+++             print(response)
+++             print(data)
+++             print(error)
+++          }
+++```
+++
+++> The `response` serializer does NOT evaluate any of the response data. It merely forwards on all the information directly from the URL session delegate. We strongly encourage you to leverage the other response serializers taking advantage of `Response` and `Result` types.
+++
+++#### Response Data Handler
+++
+++```swift
+++Alamofire.request(.GET, "https://httpbin.org/get", parameters: ["foo": "bar"])
+++         .validate()
+++         .responseData { response in
+++             print(response.request)
+++             print(response.response)
+++             print(response.result)
+++          }
+++```
+++
+++#### Response String Handler
+++
+++```swift
+++Alamofire.request(.GET, "https://httpbin.org/get")
+++         .validate()
+++         .responseString { response in
+++             print("Success: \(response.result.isSuccess)")
+++             print("Response String: \(response.result.value)")
+++         }
+++```
+++
+++#### Response JSON Handler
+++
+++```swift
+++Alamofire.request(.GET, "https://httpbin.org/get")
+++         .validate()
+++         .responseJSON { response in
+++             debugPrint(response)
+++         }
+++```
+++
+++#### Chained Response Handlers
+++
+++Response handlers can even be chained:
+++
+++```swift
+++Alamofire.request(.GET, "https://httpbin.org/get")
+++         .validate()
+++         .responseString { response in
+++             print("Response String: \(response.result.value)")
+++         }
+++         .responseJSON { response in
+++             print("Response JSON: \(response.result.value)")
+++         }
+++```
+++
+++### HTTP Methods
+++
+++`Alamofire.Method` lists the HTTP methods defined in [RFC 7231 §4.3](http://tools.ietf.org/html/rfc7231#section-4.3):
+++
+++```swift
+++public enum Method: String {
+++    case OPTIONS, GET, HEAD, POST, PUT, PATCH, DELETE, TRACE, CONNECT
+++}
+++```
+++
+++These values can be passed as the first argument of the `Alamofire.request` method:
+++
+++```swift
+++Alamofire.request(.POST, "https://httpbin.org/post")
+++
+++Alamofire.request(.PUT, "https://httpbin.org/put")
+++
+++Alamofire.request(.DELETE, "https://httpbin.org/delete")
+++```
+++
+++### Parameters
+++
+++#### GET Request With URL-Encoded Parameters
+++
+++```swift
+++Alamofire.request(.GET, "https://httpbin.org/get", parameters: ["foo": "bar"])
+++// https://httpbin.org/get?foo=bar
+++```
+++
+++#### POST Request With URL-Encoded Parameters
+++
+++```swift
+++let parameters = [
+++    "foo": "bar",
+++    "baz": ["a", 1],
+++    "qux": [
+++        "x": 1,
+++        "y": 2,
+++        "z": 3
+++    ]
+++]
+++
+++Alamofire.request(.POST, "https://httpbin.org/post", parameters: parameters)
+++// HTTP body: foo=bar&baz[]=a&baz[]=1&qux[x]=1&qux[y]=2&qux[z]=3
+++```
+++
+++### Parameter Encoding
+++
+++Parameters can also be encoded as JSON, Property List, or any custom format, using the `ParameterEncoding` enum:
+++
+++```swift
+++enum ParameterEncoding {
+++    case URL
+++    case URLEncodedInURL
+++    case JSON
+++    case PropertyList(format: NSPropertyListFormat, options: NSPropertyListWriteOptions)
+++    case Custom((URLRequestConvertible, [String: AnyObject]?) -> (NSMutableURLRequest, NSError?))
+++
+++    func encode(request: NSURLRequest, parameters: [String: AnyObject]?) -> (NSURLRequest, NSError?)
+++    { ... }
+++}
+++```
+++
+++- `URL`: A query string to be set as or appended to any existing URL query for `GET`, `HEAD`, and `DELETE` requests, or set as the body for requests with any other HTTP method. The `Content-Type` HTTP header field of an encoded request with HTTP body is set to `application/x-www-form-urlencoded`. _Since there is no published specification for how to encode collection types, Alamofire follows the convention of appending `[]` to the key for array values (`foo[]=1&foo[]=2`), and appending the key surrounded by square brackets for nested dictionary values (`foo[bar]=baz`)._
+++- `URLEncodedInURL`: Creates query string to be set as or appended to any existing URL query. Uses the same implementation as the `.URL` case, but always applies the encoded result to the URL.
+++- `JSON`: Uses `NSJSONSerialization` to create a JSON representation of the parameters object, which is set as the body of the request. The `Content-Type` HTTP header field of an encoded request is set to `application/json`.
+++- `PropertyList`: Uses `NSPropertyListSerialization` to create a plist representation of the parameters object, according to the associated format and write options values, which is set as the body of the request. The `Content-Type` HTTP header field of an encoded request is set to `application/x-plist`.
+++- `Custom`: Uses the associated closure value to construct a new request given an existing request and parameters.
+++
+++#### Manual Parameter Encoding of an NSURLRequest
+++
+++```swift
+++let URL = NSURL(string: "https://httpbin.org/get")!
+++var request = NSMutableURLRequest(URL: URL)
+++
+++let parameters = ["foo": "bar"]
+++let encoding = Alamofire.ParameterEncoding.URL
+++(request, _) = encoding.encode(request, parameters: parameters)
+++```
+++
+++#### POST Request with JSON-encoded Parameters
+++
+++```swift
+++let parameters = [
+++    "foo": [1,2,3],
+++    "bar": [
+++        "baz": "qux"
+++    ]
+++]
+++
+++Alamofire.request(.POST, "https://httpbin.org/post", parameters: parameters, encoding: .JSON)
+++// HTTP body: {"foo": [1, 2, 3], "bar": {"baz": "qux"}}
+++```
+++
+++### HTTP Headers
+++
+++Adding a custom HTTP header to a `Request` is supported directly in the global `request` method. This makes it easy to attach HTTP headers to a `Request` that can be constantly changing.
+++
+++> For HTTP headers that do not change, it is recommended to set them on the `NSURLSessionConfiguration` so they are automatically applied to any `NSURLSessionTask` created by the underlying `NSURLSession`.
+++
+++```swift
+++let headers = [
+++    "Authorization": "Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==",
+++    "Accept": "application/json"
+++]
+++
+++Alamofire.request(.GET, "https://httpbin.org/get", headers: headers)
+++         .responseJSON { response in
+++             debugPrint(response)
+++         }
+++```
+++
+++### Caching
+++
+++Caching is handled on the system framework level by [`NSURLCache`](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html#//apple_ref/occ/cl/NSURLCache).
+++
+++### Uploading
+++
+++**Supported Upload Types**
+++
+++- File
+++- Data
+++- Stream
+++- MultipartFormData
+++
+++#### Uploading a File
+++
+++```swift
+++let fileURL = NSBundle.mainBundle().URLForResource("Default", withExtension: "png")
+++Alamofire.upload(.POST, "https://httpbin.org/post", file: fileURL)
+++```
+++
+++#### Uploading with Progress
+++
+++```swift
+++Alamofire.upload(.POST, "https://httpbin.org/post", file: fileURL)
+++         .progress { bytesWritten, totalBytesWritten, totalBytesExpectedToWrite in
+++             print(totalBytesWritten)
+++
+++             // This closure is NOT called on the main queue for performance
+++             // reasons. To update your ui, dispatch to the main queue.
+++             dispatch_async(dispatch_get_main_queue()) {
+++                 print("Total bytes written on main queue: \(totalBytesWritten)")
+++             }
+++         }
+++         .validate()
+++         .responseJSON { response in
+++             debugPrint(response)
+++         }
+++```
+++
+++#### Uploading MultipartFormData
+++
+++```swift
+++Alamofire.upload(
+++    .POST,
+++    "https://httpbin.org/post",
+++    multipartFormData: { multipartFormData in
+++        multipartFormData.appendBodyPart(fileURL: unicornImageURL, name: "unicorn")
+++        multipartFormData.appendBodyPart(fileURL: rainbowImageURL, name: "rainbow")
+++    },
+++    encodingCompletion: { encodingResult in
+++    	switch encodingResult {
+++    	case .Success(let upload, _, _):
+++            upload.responseJSON { response in
+++                debugPrint(response)
+++            }
+++    	case .Failure(let encodingError):
+++    	    print(encodingError)
+++    	}
+++    }
+++)
+++```
+++
+++### Downloading
+++
+++**Supported Download Types**
+++
+++- Request
+++- Resume Data
+++
+++#### Downloading a File
+++
+++```swift
+++Alamofire.download(.GET, "https://httpbin.org/stream/100") { temporaryURL, response in
+++    let fileManager = NSFileManager.defaultManager()
+++    let directoryURL = fileManager.URLsForDirectory(.DocumentDirectory, inDomains: .UserDomainMask)[0]
+++    let pathComponent = response.suggestedFilename
+++
+++    return directoryURL.URLByAppendingPathComponent(pathComponent!)
+++}
+++```
+++
+++#### Using the Default Download Destination
+++
+++```swift
+++let destination = Alamofire.Request.suggestedDownloadDestination(directory: .DocumentDirectory, domain: .UserDomainMask)
+++Alamofire.download(.GET, "https://httpbin.org/stream/100", destination: destination)
+++```
+++
+++#### Downloading a File w/Progress
+++
+++```swift
+++Alamofire.download(.GET, "https://httpbin.org/stream/100", destination: destination)
+++         .progress { bytesRead, totalBytesRead, totalBytesExpectedToRead in
+++             print(totalBytesRead)
+++
+++             // This closure is NOT called on the main queue for performance
+++             // reasons. To update your ui, dispatch to the main queue.
+++             dispatch_async(dispatch_get_main_queue()) {
+++                 print("Total bytes read on main queue: \(totalBytesRead)")
+++             }
+++         }
+++         .response { _, _, _, error in
+++             if let error = error {
+++                 print("Failed with error: \(error)")
+++             } else {
+++                 print("Downloaded file successfully")
+++             }
+++         }
+++```
+++
+++#### Accessing Resume Data for Failed Downloads
+++
+++```swift
+++Alamofire.download(.GET, "https://httpbin.org/stream/100", destination: destination)
+++         .response { _, _, data, _ in
+++             if let
+++                 data = data,
+++                 resumeDataString = NSString(data: data, encoding: NSUTF8StringEncoding)
+++             {
+++                 print("Resume Data: \(resumeDataString)")
+++             } else {
+++                 print("Resume Data was empty")
+++             }
+++         }
+++```
+++
+++> The `data` parameter is automatically populated with the `resumeData` if available.
+++
+++```swift
+++let download = Alamofire.download(.GET, "https://httpbin.org/stream/100", destination: destination)
+++download.response { _, _, _, _ in
+++    if let
+++        resumeData = download.resumeData,
+++        resumeDataString = NSString(data: resumeData, encoding: NSUTF8StringEncoding)
+++    {
+++        print("Resume Data: \(resumeDataString)")
+++    } else {
+++        print("Resume Data was empty")
+++    }
+++}
+++```
+++
+++### Authentication
+++
+++Authentication is handled on the system framework level by [`NSURLCredential` and `NSURLAuthenticationChallenge`](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLAuthenticationChallenge_Class/Reference/Reference.html).
+++
+++**Supported Authentication Schemes**
+++
+++- [HTTP Basic](http://en.wikipedia.org/wiki/Basic_access_authentication)
+++- [HTTP Digest](http://en.wikipedia.org/wiki/Digest_access_authentication)
+++- [Kerberos](http://en.wikipedia.org/wiki/Kerberos_%28protocol%29)
+++- [NTLM](http://en.wikipedia.org/wiki/NT_LAN_Manager)
+++
+++#### HTTP Basic Authentication
+++
+++The `authenticate` method on a `Request` will automatically provide an `NSURLCredential` to an `NSURLAuthenticationChallenge` when appropriate:
+++
+++```swift
+++let user = "user"
+++let password = "password"
+++
+++Alamofire.request(.GET, "https://httpbin.org/basic-auth/\(user)/\(password)")
+++         .authenticate(user: user, password: password)
+++         .responseJSON { response in
+++             debugPrint(response)
+++         }
+++```
+++
+++Depending upon your server implementation, an `Authorization` header may also be appropriate:
+++
+++```swift
+++let user = "user"
+++let password = "password"
+++
+++let credentialData = "\(user):\(password)".dataUsingEncoding(NSUTF8StringEncoding)!
+++let base64Credentials = credentialData.base64EncodedStringWithOptions([])
+++
+++let headers = ["Authorization": "Basic \(base64Credentials)"]
+++
+++Alamofire.request(.GET, "https://httpbin.org/basic-auth/user/password", headers: headers)
+++         .responseJSON { response in
+++             debugPrint(response)
+++         }
+++```
+++
+++#### Authentication with NSURLCredential
+++
+++```swift
+++let user = "user"
+++let password = "password"
+++
+++let credential = NSURLCredential(user: user, password: password, persistence: .ForSession)
+++
+++Alamofire.request(.GET, "https://httpbin.org/basic-auth/\(user)/\(password)")
+++         .authenticate(usingCredential: credential)
+++         .responseJSON { response in
+++             debugPrint(response)
+++         }
+++```
+++
+++### Timeline
+++
+++Alamofire collects timings throughout the lifecycle of a `Request` and creates a `Timeline` object exposed as a property on a `Response`.
+++
+++```swift
+++Alamofire.request(.GET, "https://httpbin.org/get", parameters: ["foo": "bar"])
+++         .validate()
+++         .responseJSON { response in
+++             print(response.timeline)
+++         }
+++```
+++
+++The above reports the following `Timeline` info:
+++
+++- `Latency`: 0.428 seconds
+++- `Request Duration`: 0.428 seconds
+++- `Serialization Duration`: 0.001 seconds
+++- `Total Duration`: 0.429 seconds
+++
+++### Printable
+++
+++```swift
+++let request = Alamofire.request(.GET, "https://httpbin.org/ip")
+++
+++print(request)
+++// GET https://httpbin.org/ip (200)
+++```
+++
+++### DebugPrintable
+++
+++```swift
+++let request = Alamofire.request(.GET, "https://httpbin.org/get", parameters: ["foo": "bar"])
+++
+++debugPrint(request)
+++```
+++
+++#### Output (cURL)
+++
+++```bash
+++$ curl -i \
+++	-H "User-Agent: Alamofire" \
+++	-H "Accept-Encoding: Accept-Encoding: gzip;q=1.0,compress;q=0.5" \
+++	-H "Accept-Language: en;q=1.0,fr;q=0.9,de;q=0.8,zh-Hans;q=0.7,zh-Hant;q=0.6,ja;q=0.5" \
+++	"https://httpbin.org/get?foo=bar"
+++```
+++
+++---
+++
+++## Advanced Usage
+++
+++> Alamofire is built on `NSURLSession` and the Foundation URL Loading System. To make the most of
+++this framework, it is recommended that you be familiar with the concepts and capabilities of the underlying networking stack.
+++
+++**Recommended Reading**
+++
+++- [URL Loading System Programming Guide](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html)
+++- [NSURLSession Class Reference](https://developer.apple.com/library/mac/documentation/Foundation/Reference/NSURLSession_class/Introduction/Introduction.html#//apple_ref/occ/cl/NSURLSession)
+++- [NSURLCache Class Reference](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html#//apple_ref/occ/cl/NSURLCache)
+++- [NSURLAuthenticationChallenge Class Reference](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLAuthenticationChallenge_Class/Reference/Reference.html)
+++
+++### Manager
+++
+++Top-level convenience methods like `Alamofire.request` use a shared instance of `Alamofire.Manager`, which is configured with the default `NSURLSessionConfiguration`.
+++
+++As such, the following two statements are equivalent:
+++
+++```swift
+++Alamofire.request(.GET, "https://httpbin.org/get")
+++```
+++
+++```swift
+++let manager = Alamofire.Manager.sharedInstance
+++manager.request(NSURLRequest(URL: NSURL(string: "https://httpbin.org/get")!))
+++```
+++
+++Applications can create managers for background and ephemeral sessions, as well as new managers that customize the default session configuration, such as for default headers (`HTTPAdditionalHeaders`) or timeout interval (`timeoutIntervalForRequest`).
+++
+++#### Creating a Manager with Default Configuration
+++
+++```swift
+++let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
+++let manager = Alamofire.Manager(configuration: configuration)
+++```
+++
+++#### Creating a Manager with Background Configuration
+++
+++```swift
+++let configuration = NSURLSessionConfiguration.backgroundSessionConfigurationWithIdentifier("com.example.app.background")
+++let manager = Alamofire.Manager(configuration: configuration)
+++```
+++
+++#### Creating a Manager with Ephemeral Configuration
+++
+++```swift
+++let configuration = NSURLSessionConfiguration.ephemeralSessionConfiguration()
+++let manager = Alamofire.Manager(configuration: configuration)
+++```
+++
+++#### Modifying Session Configuration
+++
+++```swift
+++var defaultHeaders = Alamofire.Manager.sharedInstance.session.configuration.HTTPAdditionalHeaders ?? [:]
+++defaultHeaders["DNT"] = "1 (Do Not Track Enabled)"
+++
+++let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
+++configuration.HTTPAdditionalHeaders = defaultHeaders
+++
+++let manager = Alamofire.Manager(configuration: configuration)
+++```
+++
+++> This is **not** recommended for `Authorization` or `Content-Type` headers. Instead, use `URLRequestConvertible` and `ParameterEncoding`, respectively.
+++
+++### Request
+++
+++The result of a `request`, `upload`, or `download` method is an instance of `Alamofire.Request`. A request is always created using a constructor method from an owning manager, and never initialized directly.
+++
+++Methods like `authenticate`, `validate` and `responseData` return the caller in order to facilitate chaining.
+++
+++Requests can be suspended, resumed, and cancelled:
+++
+++- `suspend()`: Suspends the underlying task and dispatch queue
+++- `resume()`: Resumes the underlying task and dispatch queue. If the owning manager does not have `startRequestsImmediately` set to `true`, the request must call `resume()` in order to start.
+++- `cancel()`: Cancels the underlying task, producing an error that is passed to any registered response handlers.
+++
+++### Response Serialization
+++
+++#### Handling Errors
+++
+++Before implementing custom response serializers or object serialization methods, it's important to be prepared to handle any errors that may occur. Alamofire recommends handling these through the use of either your own `NSError` creation methods, or a simple `enum` that conforms to `ErrorType`. For example, this `BackendError` type, which will be used in later examples:
+++
+++```swift
+++enum BackendError: ErrorType {
+++    case Network(error: NSError)
+++    case DataSerialization(reason: String)
+++    case JSONSerialization(error: NSError)
+++    case ObjectSerialization(reason: String)
+++    case XMLSerialization(error: NSError)
+++}
+++```
+++
+++#### Creating a Custom Response Serializer
+++
+++Alamofire provides built-in response serialization for strings, JSON, and property lists, but others can be added in extensions on `Alamofire.Request`.
+++
+++For example, here's how a response handler using [Ono](https://github.com/mattt/Ono) might be implemented:
+++
+++```swift
+++extension Request {
+++    public static func XMLResponseSerializer() -> ResponseSerializer<ONOXMLDocument, BackendError> {
+++        return ResponseSerializer { request, response, data, error in
+++            guard error == nil else { return .Failure(.Network(error: error!)) }
+++
+++            guard let validData = data else {
+++                return .Failure(.DataSerialization(reason: "Data could not be serialized. Input data was nil."))
+++            }
+++
+++            do {
+++                let XML = try ONOXMLDocument(data: validData)
+++                return .Success(XML)
+++            } catch {
+++                return .Failure(.XMLSerialization(error: error as NSError))
+++            }
+++        }
+++    }
+++
+++    public func responseXMLDocument(completionHandler: Response<ONOXMLDocument, BackendError> -> Void) -> Self {
+++        return response(responseSerializer: Request.XMLResponseSerializer(), completionHandler: completionHandler)
+++    }
+++}
+++```
+++
+++#### Generic Response Object Serialization
+++
+++Generics can be used to provide automatic, type-safe response object serialization.
+++
+++```swift
+++public protocol ResponseObjectSerializable {
+++    init?(response: NSHTTPURLResponse, representation: AnyObject)
+++}
+++
+++extension Request {
+++    public func responseObject<T: ResponseObjectSerializable>(completionHandler: Response<T, BackendError> -> Void) -> Self {
+++        let responseSerializer = ResponseSerializer<T, BackendError> { request, response, data, error in
+++            guard error == nil else { return .Failure(.Network(error: error!)) }
+++
+++            let JSONResponseSerializer = Request.JSONResponseSerializer(options: .AllowFragments)
+++            let result = JSONResponseSerializer.serializeResponse(request, response, data, error)
+++
+++            switch result {
+++            case .Success(let value):
+++                if let
+++                    response = response,
+++                    responseObject = T(response: response, representation: value)
+++                {
+++                    return .Success(responseObject)
+++                } else {
+++                    return .Failure(.ObjectSerialization(reason: "JSON could not be serialized into response object: \(value)"))
+++                }
+++            case .Failure(let error):
+++                return .Failure(.JSONSerialization(error: error))
+++            }
+++        }
+++
+++        return response(responseSerializer: responseSerializer, completionHandler: completionHandler)
+++    }
+++}
+++```
+++
+++```swift
+++final class User: ResponseObjectSerializable {
+++    let username: String
+++    let name: String
+++
+++    init?(response: NSHTTPURLResponse, representation: AnyObject) {
+++        self.username = response.URL!.lastPathComponent!
+++        self.name = representation.valueForKeyPath("name") as! String
+++    }
+++}
+++```
+++
+++```swift
+++Alamofire.request(.GET, "https://example.com/users/mattt")
+++         .responseObject { (response: Response<User, BackendError>) in
+++             debugPrint(response)
+++         }
+++```
+++
+++The same approach can also be used to handle endpoints that return a representation of a collection of objects:
+++
+++```swift
+++public protocol ResponseCollectionSerializable {
+++    static func collection(response response: NSHTTPURLResponse, representation: AnyObject) -> [Self]
+++}
+++
+++extension ResponseCollectionSerializable where Self: ResponseObjectSerializable {
+++    static func collection(response response: NSHTTPURLResponse, representation: AnyObject) -> [Self] {
+++        var collection = [Self]()
+++        
+++        if let representation = representation as? [[String: AnyObject]] {
+++            for itemRepresentation in representation {
+++                if let item = Self(response: response, representation: itemRepresentation) {
+++                    collection.append(item)
+++                }
+++            }
+++        }
+++        
+++        return collection
+++    }
+++}
+++
+++extension Alamofire.Request {
+++    public func responseCollection<T: ResponseCollectionSerializable>(completionHandler: Response<[T], BackendError> -> Void) -> Self {
+++        let responseSerializer = ResponseSerializer<[T], BackendError> { request, response, data, error in
+++            guard error == nil else { return .Failure(.Network(error: error!)) }
+++
+++            let JSONSerializer = Request.JSONResponseSerializer(options: .AllowFragments)
+++            let result = JSONSerializer.serializeResponse(request, response, data, error)
+++
+++            switch result {
+++            case .Success(let value):
+++                if let response = response {
+++                    return .Success(T.collection(response: response, representation: value))
+++                } else {
+++                    return .Failure(. ObjectSerialization(reason: "Response collection could not be serialized due to nil response"))
+++                }
+++            case .Failure(let error):
+++                return .Failure(.JSONSerialization(error: error))
+++            }
+++        }
+++
+++        return response(responseSerializer: responseSerializer, completionHandler: completionHandler)
+++    }
+++}
+++```
+++
+++```swift
+++final class User: ResponseObjectSerializable, ResponseCollectionSerializable {
+++    let username: String
+++    let name: String
+++
+++    init?(response: NSHTTPURLResponse, representation: AnyObject) {
+++        self.username = response.URL!.lastPathComponent!
+++        self.name = representation.valueForKeyPath("name") as! String
+++    }
+++}
+++```
+++
+++```swift
+++Alamofire.request(.GET, "http://example.com/users")
+++         .responseCollection { (response: Response<[User], BackendError>) in
+++             debugPrint(response)
+++         }
+++```
+++
+++### URLStringConvertible
+++
+++Types adopting the `URLStringConvertible` protocol can be used to construct URL strings, which are then used to construct URL requests. `NSString`, `NSURL`, `NSURLComponents`, and `NSURLRequest` conform to `URLStringConvertible` by default, allowing any of them to be passed as `URLString` parameters to the `request`, `upload`, and `download` methods:
+++
+++```swift
+++let string = NSString(string: "https://httpbin.org/post")
+++Alamofire.request(.POST, string)
+++
+++let URL = NSURL(string: string)!
+++Alamofire.request(.POST, URL)
+++
+++let URLRequest = NSURLRequest(URL: URL)
+++Alamofire.request(.POST, URLRequest) // overrides `HTTPMethod` of `URLRequest`
+++
+++let URLComponents = NSURLComponents(URL: URL, resolvingAgainstBaseURL: true)
+++Alamofire.request(.POST, URLComponents)
+++```
+++
+++Applications interacting with web applications in a significant manner are encouraged to have custom types conform to `URLStringConvertible` as a convenient way to map domain-specific models to server resources.
+++
+++#### Type-Safe Routing
+++
+++```swift
+++extension User: URLStringConvertible {
+++    static let baseURLString = "http://example.com"
+++
+++    var URLString: String {
+++        return User.baseURLString + "/users/\(username)/"
+++    }
+++}
+++```
+++
+++```swift
+++let user = User(username: "mattt")
+++Alamofire.request(.GET, user) // http://example.com/users/mattt
+++```
+++
+++### URLRequestConvertible
+++
+++Types adopting the `URLRequestConvertible` protocol can be used to construct URL requests. `NSURLRequest` conforms to `URLRequestConvertible` by default, allowing it to be passed into `request`, `upload`, and `download` methods directly (this is the recommended way to specify custom HTTP body for individual requests):
+++
+++```swift
+++let URL = NSURL(string: "https://httpbin.org/post")!
+++let mutableURLRequest = NSMutableURLRequest(URL: URL)
+++mutableURLRequest.HTTPMethod = "POST"
+++
+++let parameters = ["foo": "bar"]
+++
+++do {
+++    mutableURLRequest.HTTPBody = try NSJSONSerialization.dataWithJSONObject(parameters, options: NSJSONWritingOptions())
+++} catch {
+++    // No-op
+++}
+++
+++mutableURLRequest.setValue("application/json", forHTTPHeaderField: "Content-Type")
+++
+++Alamofire.request(mutableURLRequest)
+++```
+++
+++Applications interacting with web applications in a significant manner are encouraged to have custom types conform to `URLRequestConvertible` as a way to ensure consistency of requested endpoints. Such an approach can be used to abstract away server-side inconsistencies and provide type-safe routing, as well as manage authentication credentials and other state.
+++
+++#### API Parameter Abstraction
+++
+++```swift
+++enum Router: URLRequestConvertible {
+++    static let baseURLString = "http://example.com"
+++    static let perPage = 50
+++
+++    case Search(query: String, page: Int)
+++
+++    // MARK: URLRequestConvertible
+++
+++    var URLRequest: NSMutableURLRequest {
+++        let result: (path: String, parameters: [String: AnyObject]) = {
+++            switch self {
+++            case .Search(let query, let page) where page > 0:
+++                return ("/search", ["q": query, "offset": Router.perPage * page])
+++            case .Search(let query, _):
+++                return ("/search", ["q": query])
+++            }
+++        }()
+++
+++        let URL = NSURL(string: Router.baseURLString)!
+++        let URLRequest = NSURLRequest(URL: URL.URLByAppendingPathComponent(result.path))
+++        let encoding = Alamofire.ParameterEncoding.URL
+++
+++        return encoding.encode(URLRequest, parameters: result.parameters).0
+++    }
+++}
+++```
+++
+++```swift
+++Alamofire.request(Router.Search(query: "foo bar", page: 1)) // ?q=foo%20bar&offset=50
+++```
+++
+++#### CRUD & Authorization
+++
+++```swift
+++enum Router: URLRequestConvertible {
+++    static let baseURLString = "http://example.com"
+++    static var OAuthToken: String?
+++
+++    case CreateUser([String: AnyObject])
+++    case ReadUser(String)
+++    case UpdateUser(String, [String: AnyObject])
+++    case DestroyUser(String)
+++
+++    var method: Alamofire.Method {
+++        switch self {
+++        case .CreateUser:
+++            return .POST
+++        case .ReadUser:
+++            return .GET
+++        case .UpdateUser:
+++            return .PUT
+++        case .DestroyUser:
+++            return .DELETE
+++        }
+++    }
+++
+++    var path: String {
+++        switch self {
+++        case .CreateUser:
+++            return "/users"
+++        case .ReadUser(let username):
+++            return "/users/\(username)"
+++        case .UpdateUser(let username, _):
+++            return "/users/\(username)"
+++        case .DestroyUser(let username):
+++            return "/users/\(username)"
+++        }
+++    }
+++
+++    // MARK: URLRequestConvertible
+++
+++    var URLRequest: NSMutableURLRequest {
+++        let URL = NSURL(string: Router.baseURLString)!
+++        let mutableURLRequest = NSMutableURLRequest(URL: URL.URLByAppendingPathComponent(path))
+++        mutableURLRequest.HTTPMethod = method.rawValue
+++
+++        if let token = Router.OAuthToken {
+++            mutableURLRequest.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
+++        }
+++
+++        switch self {
+++        case .CreateUser(let parameters):
+++            return Alamofire.ParameterEncoding.JSON.encode(mutableURLRequest, parameters: parameters).0
+++        case .UpdateUser(_, let parameters):
+++            return Alamofire.ParameterEncoding.URL.encode(mutableURLRequest, parameters: parameters).0
+++        default:
+++            return mutableURLRequest
+++        }
+++    }
+++}
+++```
+++
+++```swift
+++Alamofire.request(Router.ReadUser("mattt")) // GET /users/mattt
+++```
+++
+++### SessionDelegate
+++
+++By default, an Alamofire `Manager` instance creates an internal `SessionDelegate` object to handle all the various types of delegate callbacks that are generated by the underlying `NSURLSession`. The implementations of each delegate method handle the most common use cases for these types of calls abstracting the complexity away from the top-level APIs. However, advanced users may find the need to override the default functionality for various reasons.
+++
+++#### Override Closures
+++
+++The first way to customize the `SessionDelegate` behavior is through the use of the override closures. Each closure gives you the ability to override the implementation of the matching `SessionDelegate` API, yet still use the default implementation for all other APIs. This makes it easy to customize subsets of the delegate functionality. Here are a few examples of some of the override closures available:
+++
+++```swift
+++/// Overrides default behavior for NSURLSessionDelegate method `URLSession:didReceiveChallenge:completionHandler:`.
+++public var sessionDidReceiveChallenge: ((NSURLSession, NSURLAuthenticationChallenge) -> (NSURLSessionAuthChallengeDisposition, NSURLCredential?))?
+++
+++/// Overrides default behavior for NSURLSessionDelegate method `URLSessionDidFinishEventsForBackgroundURLSession:`.
+++public var sessionDidFinishEventsForBackgroundURLSession: ((NSURLSession) -> Void)?
+++
+++/// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:`.
+++public var taskWillPerformHTTPRedirection: ((NSURLSession, NSURLSessionTask, NSHTTPURLResponse, NSURLRequest) -> NSURLRequest?)?
+++
+++/// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:willCacheResponse:completionHandler:`.
+++public var dataTaskWillCacheResponse: ((NSURLSession, NSURLSessionDataTask, NSCachedURLResponse) -> NSCachedURLResponse?)?
+++```
+++
+++The following is a short example of how to use the `taskWillPerformHTTPRedirection` to avoid following redirects to any `apple.com` domains.
+++
+++```swift
+++let delegate: Alamofire.Manager.SessionDelegate = manager.delegate
+++
+++delegate.taskWillPerformHTTPRedirection = { session, task, response, request in
+++    var finalRequest = request
+++
+++    if let originalRequest = task.originalRequest where originalRequest.URLString.containsString("apple.com") {
+++		finalRequest = originalRequest
+++	}
+++
+++	return finalRequest
+++}
+++```
+++
+++#### Subclassing
+++
+++Another way to override the default implementation of the `SessionDelegate` is to subclass it. Subclassing allows you completely customize the behavior of the API or to create a proxy for the API and still use the default implementation. Creating a proxy allows you to log events, emit notifications, provide pre and post hook implementations, etc. Here's a quick example of subclassing the `SessionDelegate` and logging a message when a redirect occurs.
+++
+++```swift
+++class LoggingSessionDelegate: Manager.SessionDelegate {
+++    override func URLSession(
+++        session: NSURLSession,
+++        task: NSURLSessionTask,
+++        willPerformHTTPRedirection response: NSHTTPURLResponse,
+++        newRequest request: NSURLRequest,
+++        completionHandler: NSURLRequest? -> Void)
+++    {
+++        print("URLSession will perform HTTP redirection to request: \(request)")
+++
+++        super.URLSession(
+++            session,
+++            task: task,
+++            willPerformHTTPRedirection: response,
+++            newRequest: request,
+++            completionHandler: completionHandler
+++        )
+++    }
+++}
+++```
+++
+++Generally, either the default implementation or the override closures should provide the necessary functionality required. Subclassing should only be used as a last resort.
+++
+++> It is important to keep in mind that the `subdelegates` are initialized and destroyed in the default implementation. Be careful when subclassing to not introduce memory leaks.
+++
+++### Security
+++
+++Using a secure HTTPS connection when communicating with servers and web services is an important step in securing sensitive data. By default, Alamofire will evaluate the certificate chain provided by the server using Apple's built in validation provided by the Security framework. While this guarantees the certificate chain is valid, it does not prevent man-in-the-middle (MITM) attacks or other potential vulnerabilities. In order to mitigate MITM attacks, applications dealing with sensitive customer data or financial information should use certificate or public key pinning provided by the `ServerTrustPolicy`.
+++
+++#### ServerTrustPolicy
+++
+++The `ServerTrustPolicy` enumeration evaluates the server trust generally provided by an `NSURLAuthenticationChallenge` when connecting to a server over a secure HTTPS connection.
+++
+++```swift
+++let serverTrustPolicy = ServerTrustPolicy.PinCertificates(
+++    certificates: ServerTrustPolicy.certificatesInBundle(),
+++    validateCertificateChain: true,
+++    validateHost: true
+++)
+++```
+++
+++There are many different cases of server trust evaluation giving you complete control over the validation process:
+++
+++* `PerformDefaultEvaluation`: Uses the default server trust evaluation while allowing you to control whether to validate the host provided by the challenge. 
+++* `PinCertificates`: Uses the pinned certificates to validate the server trust. The server trust is considered valid if one of the pinned certificates match one of the server certificates.
+++* `PinPublicKeys`: Uses the pinned public keys to validate the server trust. The server trust is considered valid if one of the pinned public keys match one of the server certificate public keys.
+++* `DisableEvaluation`: Disables all evaluation which in turn will always consider any server trust as valid.
+++* `CustomEvaluation`: Uses the associated closure to evaluate the validity of the server trust thus giving you complete control over the validation process. Use with caution.
+++
+++#### Server Trust Policy Manager
+++
+++The `ServerTrustPolicyManager` is responsible for storing an internal mapping of server trust policies to a particular host. This allows Alamofire to evaluate each host against a different server trust policy. 
+++
+++```swift
+++let serverTrustPolicies: [String: ServerTrustPolicy] = [
+++    "test.example.com": .PinCertificates(
+++        certificates: ServerTrustPolicy.certificatesInBundle(),
+++        validateCertificateChain: true,
+++        validateHost: true
+++    ),
+++    "insecure.expired-apis.com": .DisableEvaluation
+++]
+++
+++let manager = Manager(
+++    serverTrustPolicyManager: ServerTrustPolicyManager(policies: serverTrustPolicies)
+++)
+++```
+++
+++> Make sure to keep a reference to the new `Manager` instance, otherwise your requests will all get cancelled when your `manager` is deallocated.
+++
+++These server trust policies will result in the following behavior:
+++
+++* `test.example.com` will always use certificate pinning with certificate chain and host validation enabled thus requiring the following criteria to be met to allow the TLS handshake to succeed:
+++  * Certificate chain MUST be valid.
+++  * Certificate chain MUST include one of the pinned certificates.
+++  * Challenge host MUST match the host in the certificate chain's leaf certificate.
+++* `insecure.expired-apis.com` will never evaluate the certificate chain and will always allow the TLS handshake to succeed.
+++* All other hosts will use the default evaluation provided by Apple.
+++
+++##### Subclassing Server Trust Policy Manager
+++
+++If you find yourself needing more flexible server trust policy matching behavior (i.e. wildcarded domains), then subclass the `ServerTrustPolicyManager` and override the `serverTrustPolicyForHost` method with your own custom implementation.
+++
+++```swift
+++class CustomServerTrustPolicyManager: ServerTrustPolicyManager {
+++    override func serverTrustPolicyForHost(host: String) -> ServerTrustPolicy? {
+++        var policy: ServerTrustPolicy?
+++
+++        // Implement your custom domain matching behavior...
+++
+++        return policy
+++    }
+++}
+++```
+++
+++#### Validating the Host
+++
+++The `.PerformDefaultEvaluation`, `.PinCertificates` and `.PinPublicKeys` server trust policies all take a `validateHost` parameter. Setting the value to `true` will cause the server trust evaluation to verify that hostname in the certificate matches the hostname of the challenge. If they do not match, evaluation will fail. A `validateHost` value of `false` will still evaluate the full certificate chain, but will not validate the hostname of the leaf certificate.
+++
+++> It is recommended that `validateHost` always be set to `true` in production environments.
+++
+++#### Validating the Certificate Chain
+++
+++Pinning certificates and public keys both have the option of validating the certificate chain using the `validateCertificateChain` parameter. By setting this value to `true`, the full certificate chain will be evaluated in addition to performing a byte equality check against the pinned certificates or public keys. A value of `false` will skip the certificate chain validation, but will still perform the byte equality check.
+++
+++There are several cases where it may make sense to disable certificate chain validation. The most common use cases for disabling validation are self-signed and expired certificates. The evaluation would always fail in both of these cases, but the byte equality check will still ensure you are receiving the certificate you expect from the server.
+++
+++> It is recommended that `validateCertificateChain` always be set to `true` in production environments.
+++
+++#### App Transport Security
+++
+++With the addition of App Transport Security (ATS) in iOS 9, it is possible that using a custom `ServerTrustPolicyManager` with several `ServerTrustPolicy` objects will have no effect. If you continuously see `CFNetwork SSLHandshake failed (-9806)` errors, you have probably run into this problem. Apple's ATS system overrides the entire challenge system unless you configure the ATS settings in your app's plist to disable enough of it to allow your app to evaluate the server trust.
+++
+++If you run into this problem (high probability with self-signed certificates), you can work around this issue by adding the following to your `Info.plist`.
+++
+++```xml
+++<dict>
+++	<key>NSAppTransportSecurity</key>
+++	<dict>
+++		<key>NSExceptionDomains</key>
+++		<dict>
+++			<key>example.com</key>
+++			<dict>
+++				<key>NSExceptionAllowsInsecureHTTPLoads</key>
+++				<true/>
+++				<key>NSExceptionRequiresForwardSecrecy</key>
+++				<false/>
+++				<key>NSIncludesSubdomains</key>
+++				<true/>
+++				<!-- Optional: Specify minimum TLS version -->
+++				<key>NSTemporaryExceptionMinimumTLSVersion</key>
+++				<string>TLSv1.2</string>
+++			</dict>
+++		</dict>
+++	</dict>
+++</dict>
+++```
+++
+++Whether you need to set the `NSExceptionRequiresForwardSecrecy` to `NO` depends on whether your TLS connection is using an allowed cipher suite. In certain cases, it will need to be set to `NO`. The `NSExceptionAllowsInsecureHTTPLoads` MUST be set to `YES` in order to allow the `SessionDelegate` to receive challenge callbacks. Once the challenge callbacks are being called, the `ServerTrustPolicyManager` will take over the server trust evaluation. You may also need to specify the `NSTemporaryExceptionMinimumTLSVersion` if you're trying to connect to a host that only supports TLS versions less than `1.2`.
+++
+++> It is recommended to always use valid certificates in production environments.
+++
+++### Network Reachability
+++
+++The `NetworkReachabilityManager` listens for reachability changes of hosts and addresses for both WWAN and WiFi network interfaces.
+++
+++```swift
+++let manager = NetworkReachabilityManager(host: "www.apple.com")
+++
+++manager?.listener = { status in
+++    print("Network Status Changed: \(status)")
+++}
+++
+++manager?.startListening()
+++```
+++
+++> Make sure to remember to retain the `manager` in the above example, or no status changes will be reported.
+++
+++There are some important things to remember when using network reachability to determine what to do next.
+++
+++* **Do NOT** use Reachability to determine if a network request should be sent.
+++  * You should **ALWAYS** send it.
+++* When Reachability is restored, use the event to retry failed network requests.
+++  * Even though the network requests may still fail, this is a good moment to retry them.
+++* The network reachability status can be useful for determining why a network request may have failed.
+++  * If a network request fails, it is more useful to tell the user that the network request failed due to being offline rather than a more technical error, such as "request timed out."
+++
+++> It is recommended to check out [WWDC 2012 Session 706, "Networking Best Practices"](https://developer.apple.com/videos/play/wwdc2012-706/) for more info.
+++
+++---
+++
+++## Open Rdars
+++
+++The following rdars have some affect on the current implementation of Alamofire.
+++
+++* [rdar://21349340](http://www.openradar.me/radar?id=5517037090635776) - Compiler throwing warning due to toll-free bridging issue in test case
+++* [rdar://26761490](http://www.openradar.me/radar?id=5010235949318144) - Swift string interpolation causing memory leak with common usage
+++
+++## FAQ
+++
+++### What's the origin of the name Alamofire?
+++
+++Alamofire is named after the [Alamo Fire flower](https://aggie-horticulture.tamu.edu/wildseed/alamofire.html), a hybrid variant of the Bluebonnet, the official state flower of Texas.
+++
+++---
+++
+++## Credits
+++
+++Alamofire is owned and maintained by the [Alamofire Software Foundation](http://alamofire.org). You can follow them on Twitter at [@AlamofireSF](https://twitter.com/AlamofireSF) for project updates and releases.
+++
+++### Security Disclosure
+++
+++If you believe you have identified a security vulnerability with Alamofire, you should report it as soon as possible via email to security@alamofire.org. Please do not post it to a public issue tracker.
+++
+++## Donations
+++
+++The [ASF](https://github.com/Alamofire/Foundation#members) is looking to raise money to officially register as a federal non-profit organization. Registering will allow us members to gain some legal protections and also allow us to put donations to use, tax free. Donating to the ASF will enable us to:
+++
+++* Pay our legal fees to register as a federal non-profit organization
+++* Pay our yearly legal fees to keep the non-profit in good status
+++* Pay for our mail servers to help us stay on top of all questions and security issues
+++* Potentially fund test servers to make it easier for us to test the edge cases
+++* Potentially fund developers to work on one of our projects full-time
+++
+++The community adoption of the ASF libraries has been amazing. We are greatly humbled by your enthusiam around the projects, and want to continue to do everything we can to move the needle forward. With your continued support, the ASF will be able to improve its reach and also provide better legal safety for the core members. If you use any of our libraries for work, see if your employers would be interested in donating. Our initial goal is to raise $1000 to get all our legal ducks in a row and kickstart this campaign. Any amount you can donate today to help us reach our goal would be greatly appreciated.
+++
+++<a href='https://pledgie.com/campaigns/31474'><img alt='Click here to lend your support to: Alamofire Software Foundation and make a donation at pledgie.com !' src='https://pledgie.com/campaigns/31474.png?skin_name=chrome' border='0' ></a>
+++
+++## License
+++
+++Alamofire is released under the MIT license. See LICENSE for details.
++diff --git a/Pods/Alamofire/Source/Alamofire.swift b/Pods/Alamofire/Source/Alamofire.swift
++new file mode 100644
++index 0000000..cb4b36a
++--- /dev/null
+++++ b/Pods/Alamofire/Source/Alamofire.swift
++@@ -0,0 +1,370 @@
+++//
+++//  Alamofire.swift
+++//
+++//  Copyright (c) 2014-2016 Alamofire Software Foundation (http://alamofire.org/)
+++//
+++//  Permission is hereby granted, free of charge, to any person obtaining a copy
+++//  of this software and associated documentation files (the "Software"), to deal
+++//  in the Software without restriction, including without limitation the rights
+++//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+++//  copies of the Software, and to permit persons to whom the Software is
+++//  furnished to do so, subject to the following conditions:
+++//
+++//  The above copyright notice and this permission notice shall be included in
+++//  all copies or substantial portions of the Software.
+++//
+++//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+++//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+++//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+++//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+++//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+++//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+++//  THE SOFTWARE.
+++//
+++
+++import Foundation
+++
+++// MARK: - URLStringConvertible
+++
+++/**
+++    Types adopting the `URLStringConvertible` protocol can be used to construct URL strings, which are then used to 
+++    construct URL requests.
+++*/
+++public protocol URLStringConvertible {
+++    /**
+++        A URL that conforms to RFC 2396.
+++
+++        Methods accepting a `URLStringConvertible` type parameter parse it according to RFCs 1738 and 1808.
+++
+++        See https://tools.ietf.org/html/rfc2396
+++        See https://tools.ietf.org/html/rfc1738
+++        See https://tools.ietf.org/html/rfc1808
+++    */
+++    var URLString: String { get }
+++}
+++
+++extension String: URLStringConvertible {
+++    public var URLString: String {
+++        return self
+++    }
+++}
+++
+++extension NSURL: URLStringConvertible {
+++    public var URLString: String {
+++        return absoluteString
+++    }
+++}
+++
+++extension NSURLComponents: URLStringConvertible {
+++    public var URLString: String {
+++        return URL!.URLString
+++    }
+++}
+++
+++extension NSURLRequest: URLStringConvertible {
+++    public var URLString: String {
+++        return URL!.URLString
+++    }
+++}
+++
+++// MARK: - URLRequestConvertible
+++
+++/**
+++    Types adopting the `URLRequestConvertible` protocol can be used to construct URL requests.
+++*/
+++public protocol URLRequestConvertible {
+++    /// The URL request.
+++    var URLRequest: NSMutableURLRequest { get }
+++}
+++
+++extension NSURLRequest: URLRequestConvertible {
+++    public var URLRequest: NSMutableURLRequest {
+++        return self.mutableCopy() as! NSMutableURLRequest
+++    }
+++}
+++
+++// MARK: - Convenience
+++
+++func URLRequest(
+++    method: Method,
+++    _ URLString: URLStringConvertible,
+++    headers: [String: String]? = nil)
+++    -> NSMutableURLRequest
+++{
+++    let mutableURLRequest = NSMutableURLRequest(URL: NSURL(string: URLString.URLString)!)
+++    mutableURLRequest.HTTPMethod = method.rawValue
+++
+++    if let headers = headers {
+++        for (headerField, headerValue) in headers {
+++            mutableURLRequest.setValue(headerValue, forHTTPHeaderField: headerField)
+++        }
+++    }
+++
+++    return mutableURLRequest
+++}
+++
+++// MARK: - Request Methods
+++
+++/**
+++    Creates a request using the shared manager instance for the specified method, URL string, parameters, and
+++    parameter encoding.
+++
+++    - parameter method:     The HTTP method.
+++    - parameter URLString:  The URL string.
+++    - parameter parameters: The parameters. `nil` by default.
+++    - parameter encoding:   The parameter encoding. `.URL` by default.
+++    - parameter headers:    The HTTP headers. `nil` by default.
+++
+++    - returns: The created request.
+++*/
+++public func request(
+++    method: Method,
+++    _ URLString: URLStringConvertible,
+++    parameters: [String: AnyObject]? = nil,
+++    encoding: ParameterEncoding = .URL,
+++    headers: [String: String]? = nil)
+++    -> Request
+++{
+++    return Manager.sharedInstance.request(
+++        method,
+++        URLString,
+++        parameters: parameters,
+++        encoding: encoding,
+++        headers: headers
+++    )
+++}
+++
+++/**
+++    Creates a request using the shared manager instance for the specified URL request.
+++
+++    If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
+++
+++    - parameter URLRequest: The URL request
+++
+++    - returns: The created request.
+++*/
+++public func request(URLRequest: URLRequestConvertible) -> Request {
+++    return Manager.sharedInstance.request(URLRequest.URLRequest)
+++}
+++
+++// MARK: - Upload Methods
+++
+++// MARK: File
+++
+++/**
+++    Creates an upload request using the shared manager instance for the specified method, URL string, and file.
+++
+++    - parameter method:    The HTTP method.
+++    - parameter URLString: The URL string.
+++    - parameter headers:   The HTTP headers. `nil` by default.
+++    - parameter file:      The file to upload.
+++
+++    - returns: The created upload request.
+++*/
+++public func upload(
+++    method: Method,
+++    _ URLString: URLStringConvertible,
+++    headers: [String: String]? = nil,
+++    file: NSURL)
+++    -> Request
+++{
+++    return Manager.sharedInstance.upload(method, URLString, headers: headers, file: file)
+++}
+++
+++/**
+++    Creates an upload request using the shared manager instance for the specified URL request and file.
+++
+++    - parameter URLRequest: The URL request.
+++    - parameter file:       The file to upload.
+++
+++    - returns: The created upload request.
+++*/
+++public func upload(URLRequest: URLRequestConvertible, file: NSURL) -> Request {
+++    return Manager.sharedInstance.upload(URLRequest, file: file)
+++}
+++
+++// MARK: Data
+++
+++/**
+++    Creates an upload request using the shared manager instance for the specified method, URL string, and data.
+++
+++    - parameter method:    The HTTP method.
+++    - parameter URLString: The URL string.
+++    - parameter headers:   The HTTP headers. `nil` by default.
+++    - parameter data:      The data to upload.
+++
+++    - returns: The created upload request.
+++*/
+++public func upload(
+++    method: Method,
+++    _ URLString: URLStringConvertible,
+++    headers: [String: String]? = nil,
+++    data: NSData)
+++    -> Request
+++{
+++    return Manager.sharedInstance.upload(method, URLString, headers: headers, data: data)
+++}
+++
+++/**
+++    Creates an upload request using the shared manager instance for the specified URL request and data.
+++
+++    - parameter URLRequest: The URL request.
+++    - parameter data:       The data to upload.
+++
+++    - returns: The created upload request.
+++*/
+++public func upload(URLRequest: URLRequestConvertible, data: NSData) -> Request {
+++    return Manager.sharedInstance.upload(URLRequest, data: data)
+++}
+++
+++// MARK: Stream
+++
+++/**
+++    Creates an upload request using the shared manager instance for the specified method, URL string, and stream.
+++
+++    - parameter method:    The HTTP method.
+++    - parameter URLString: The URL string.
+++    - parameter headers:   The HTTP headers. `nil` by default.
+++    - parameter stream:    The stream to upload.
+++
+++    - returns: The created upload request.
+++*/
+++public func upload(
+++    method: Method,
+++    _ URLString: URLStringConvertible,
+++    headers: [String: String]? = nil,
+++    stream: NSInputStream)
+++    -> Request
+++{
+++    return Manager.sharedInstance.upload(method, URLString, headers: headers, stream: stream)
+++}
+++
+++/**
+++    Creates an upload request using the shared manager instance for the specified URL request and stream.
+++
+++    - parameter URLRequest: The URL request.
+++    - parameter stream:     The stream to upload.
+++
+++    - returns: The created upload request.
+++*/
+++public func upload(URLRequest: URLRequestConvertible, stream: NSInputStream) -> Request {
+++    return Manager.sharedInstance.upload(URLRequest, stream: stream)
+++}
+++
+++// MARK: MultipartFormData
+++
+++/**
+++    Creates an upload request using the shared manager instance for the specified method and URL string.
+++
+++    - parameter method:                  The HTTP method.
+++    - parameter URLString:               The URL string.
+++    - parameter headers:                 The HTTP headers. `nil` by default.
+++    - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
+++    - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
+++                                         `MultipartFormDataEncodingMemoryThreshold` by default.
+++    - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
+++*/
+++public func upload(
+++    method: Method,
+++    _ URLString: URLStringConvertible,
+++    headers: [String: String]? = nil,
+++    multipartFormData: MultipartFormData -> Void,
+++    encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
+++    encodingCompletion: (Manager.MultipartFormDataEncodingResult -> Void)?)
+++{
+++    return Manager.sharedInstance.upload(
+++        method,
+++        URLString,
+++        headers: headers,
+++        multipartFormData: multipartFormData,
+++        encodingMemoryThreshold: encodingMemoryThreshold,
+++        encodingCompletion: encodingCompletion
+++    )
+++}
+++
+++/**
+++    Creates an upload request using the shared manager instance for the specified method and URL string.
+++
+++    - parameter URLRequest:              The URL request.
+++    - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
+++    - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
+++                                         `MultipartFormDataEncodingMemoryThreshold` by default.
+++    - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
+++*/
+++public func upload(
+++    URLRequest: URLRequestConvertible,
+++    multipartFormData: MultipartFormData -> Void,
+++    encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
+++    encodingCompletion: (Manager.MultipartFormDataEncodingResult -> Void)?)
+++{
+++    return Manager.sharedInstance.upload(
+++        URLRequest,
+++        multipartFormData: multipartFormData,
+++        encodingMemoryThreshold: encodingMemoryThreshold,
+++        encodingCompletion: encodingCompletion
+++    )
+++}
+++
+++// MARK: - Download Methods
+++
+++// MARK: URL Request
+++
+++/**
+++    Creates a download request using the shared manager instance for the specified method and URL string.
+++
+++    - parameter method:      The HTTP method.
+++    - parameter URLString:   The URL string.
+++    - parameter parameters:  The parameters. `nil` by default.
+++    - parameter encoding:    The parameter encoding. `.URL` by default.
+++    - parameter headers:     The HTTP headers. `nil` by default.
+++    - parameter destination: The closure used to determine the destination of the downloaded file.
+++
+++    - returns: The created download request.
+++*/
+++public func download(
+++    method: Method,
+++    _ URLString: URLStringConvertible,
+++    parameters: [String: AnyObject]? = nil,
+++    encoding: ParameterEncoding = .URL,
+++    headers: [String: String]? = nil,
+++    destination: Request.DownloadFileDestination)
+++    -> Request
+++{
+++    return Manager.sharedInstance.download(
+++        method,
+++        URLString,
+++        parameters: parameters,
+++        encoding: encoding,
+++        headers: headers,
+++        destination: destination
+++    )
+++}
+++
+++/**
+++    Creates a download request using the shared manager instance for the specified URL request.
+++
+++    - parameter URLRequest:  The URL request.
+++    - parameter destination: The closure used to determine the destination of the downloaded file.
+++
+++    - returns: The created download request.
+++*/
+++public func download(URLRequest: URLRequestConvertible, destination: Request.DownloadFileDestination) -> Request {
+++    return Manager.sharedInstance.download(URLRequest, destination: destination)
+++}
+++
+++// MARK: Resume Data
+++
+++/**
+++    Creates a request using the shared manager instance for downloading from the resume data produced from a 
+++    previous request cancellation.
+++
+++    - parameter resumeData:  The resume data. This is an opaque data blob produced by `NSURLSessionDownloadTask`
+++                             when a task is cancelled. See `NSURLSession -downloadTaskWithResumeData:` for additional 
+++                             information.
+++    - parameter destination: The closure used to determine the destination of the downloaded file.
+++
+++    - returns: The created download request.
+++*/
+++public func download(resumeData data: NSData, destination: Request.DownloadFileDestination) -> Request {
+++    return Manager.sharedInstance.download(data, destination: destination)
+++}
++diff --git a/Pods/Alamofire/Source/Download.swift b/Pods/Alamofire/Source/Download.swift
++new file mode 100644
++index 0000000..97b146f
++--- /dev/null
+++++ b/Pods/Alamofire/Source/Download.swift
++@@ -0,0 +1,248 @@
+++//
+++//  Download.swift
+++//
+++//  Copyright (c) 2014-2016 Alamofire Software Foundation (http://alamofire.org/)
+++//
+++//  Permission is hereby granted, free of charge, to any person obtaining a copy
+++//  of this software and associated documentation files (the "Software"), to deal
+++//  in the Software without restriction, including without limitation the rights
+++//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+++//  copies of the Software, and to permit persons to whom the Software is
+++//  furnished to do so, subject to the following conditions:
+++//
+++//  The above copyright notice and this permission notice shall be included in
+++//  all copies or substantial portions of the Software.
+++//
+++//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+++//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+++//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+++//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+++//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+++//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+++//  THE SOFTWARE.
+++//
+++
+++import Foundation
+++
+++extension Manager {
+++    private enum Downloadable {
+++        case Request(NSURLRequest)
+++        case ResumeData(NSData)
+++    }
+++
+++    private func download(downloadable: Downloadable, destination: Request.DownloadFileDestination) -> Request {
+++        var downloadTask: NSURLSessionDownloadTask!
+++
+++        switch downloadable {
+++        case .Request(let request):
+++            dispatch_sync(queue) {
+++                downloadTask = self.session.downloadTaskWithRequest(request)
+++            }
+++        case .ResumeData(let resumeData):
+++            dispatch_sync(queue) {
+++                downloadTask = self.session.downloadTaskWithResumeData(resumeData)
+++            }
+++        }
+++
+++        let request = Request(session: session, task: downloadTask)
+++
+++        if let downloadDelegate = request.delegate as? Request.DownloadTaskDelegate {
+++            downloadDelegate.downloadTaskDidFinishDownloadingToURL = { session, downloadTask, URL in
+++                return destination(URL, downloadTask.response as! NSHTTPURLResponse)
+++            }
+++        }
+++
+++        delegate[request.delegate.task] = request.delegate
+++
+++        if startRequestsImmediately {
+++            request.resume()
+++        }
+++
+++        return request
+++    }
+++
+++    // MARK: Request
+++
+++    /**
+++        Creates a download request for the specified method, URL string, parameters, parameter encoding, headers
+++        and destination.
+++
+++        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
+++
+++        - parameter method:      The HTTP method.
+++        - parameter URLString:   The URL string.
+++        - parameter parameters:  The parameters. `nil` by default.
+++        - parameter encoding:    The parameter encoding. `.URL` by default.
+++        - parameter headers:     The HTTP headers. `nil` by default.
+++        - parameter destination: The closure used to determine the destination of the downloaded file.
+++
+++        - returns: The created download request.
+++    */
+++    public func download(
+++        method: Method,
+++        _ URLString: URLStringConvertible,
+++        parameters: [String: AnyObject]? = nil,
+++        encoding: ParameterEncoding = .URL,
+++        headers: [String: String]? = nil,
+++        destination: Request.DownloadFileDestination)
+++        -> Request
+++    {
+++        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
+++        let encodedURLRequest = encoding.encode(mutableURLRequest, parameters: parameters).0
+++
+++        return download(encodedURLRequest, destination: destination)
+++    }
+++
+++    /**
+++        Creates a request for downloading from the specified URL request.
+++
+++        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
+++
+++        - parameter URLRequest:  The URL request
+++        - parameter destination: The closure used to determine the destination of the downloaded file.
+++
+++        - returns: The created download request.
+++    */
+++    public func download(URLRequest: URLRequestConvertible, destination: Request.DownloadFileDestination) -> Request {
+++        return download(.Request(URLRequest.URLRequest), destination: destination)
+++    }
+++
+++    // MARK: Resume Data
+++
+++    /**
+++        Creates a request for downloading from the resume data produced from a previous request cancellation.
+++
+++        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
+++
+++        - parameter resumeData:  The resume data. This is an opaque data blob produced by `NSURLSessionDownloadTask` 
+++                                 when a task is cancelled. See `NSURLSession -downloadTaskWithResumeData:` for 
+++                                 additional information.
+++        - parameter destination: The closure used to determine the destination of the downloaded file.
+++
+++        - returns: The created download request.
+++    */
+++    public func download(resumeData: NSData, destination: Request.DownloadFileDestination) -> Request {
+++        return download(.ResumeData(resumeData), destination: destination)
+++    }
+++}
+++
+++// MARK: -
+++
+++extension Request {
+++    /**
+++        A closure executed once a request has successfully completed in order to determine where to move the temporary 
+++        file written to during the download process. The closure takes two arguments: the temporary file URL and the URL 
+++        response, and returns a single argument: the file URL where the temporary file should be moved.
+++    */
+++    public typealias DownloadFileDestination = (NSURL, NSHTTPURLResponse) -> NSURL
+++
+++    /**
+++        Creates a download file destination closure which uses the default file manager to move the temporary file to a 
+++        file URL in the first available directory with the specified search path directory and search path domain mask.
+++
+++        - parameter directory: The search path directory. `.DocumentDirectory` by default.
+++        - parameter domain:    The search path domain mask. `.UserDomainMask` by default.
+++
+++        - returns: A download file destination closure.
+++    */
+++    public class func suggestedDownloadDestination(
+++        directory directory: NSSearchPathDirectory = .DocumentDirectory,
+++        domain: NSSearchPathDomainMask = .UserDomainMask)
+++        -> DownloadFileDestination
+++    {
+++        return { temporaryURL, response -> NSURL in
+++            let directoryURLs = NSFileManager.defaultManager().URLsForDirectory(directory, inDomains: domain)
+++
+++            if !directoryURLs.isEmpty {
+++                return directoryURLs[0].URLByAppendingPathComponent(response.suggestedFilename!)
+++            }
+++
+++            return temporaryURL
+++        }
+++    }
+++
+++    /// The resume data of the underlying download task if available after a failure.
+++    public var resumeData: NSData? {
+++        var data: NSData?
+++
+++        if let delegate = delegate as? DownloadTaskDelegate {
+++            data = delegate.resumeData
+++        }
+++
+++        return data
+++    }
+++
+++    // MARK: - DownloadTaskDelegate
+++
+++    class DownloadTaskDelegate: TaskDelegate, NSURLSessionDownloadDelegate {
+++        var downloadTask: NSURLSessionDownloadTask? { return task as? NSURLSessionDownloadTask }
+++        var downloadProgress: ((Int64, Int64, Int64) -> Void)?
+++
+++        var resumeData: NSData?
+++        override var data: NSData? { return resumeData }
+++
+++        // MARK: - NSURLSessionDownloadDelegate
+++
+++        // MARK: Override Closures
+++
+++        var downloadTaskDidFinishDownloadingToURL: ((NSURLSession, NSURLSessionDownloadTask, NSURL) -> NSURL)?
+++        var downloadTaskDidWriteData: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64, Int64) -> Void)?
+++        var downloadTaskDidResumeAtOffset: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64) -> Void)?
+++
+++        // MARK: Delegate Methods
+++
+++        func URLSession(
+++            session: NSURLSession,
+++            downloadTask: NSURLSessionDownloadTask,
+++            didFinishDownloadingToURL location: NSURL)
+++        {
+++            if let downloadTaskDidFinishDownloadingToURL = downloadTaskDidFinishDownloadingToURL {
+++                do {
+++                    let destination = downloadTaskDidFinishDownloadingToURL(session, downloadTask, location)
+++                    try NSFileManager.defaultManager().moveItemAtURL(location, toURL: destination)
+++                } catch {
+++                    self.error = error as NSError
+++                }
+++            }
+++        }
+++
+++        func URLSession(
+++            session: NSURLSession,
+++            downloadTask: NSURLSessionDownloadTask,
+++            didWriteData bytesWritten: Int64,
+++            totalBytesWritten: Int64,
+++            totalBytesExpectedToWrite: Int64)
+++        {
+++            if initialResponseTime == nil { initialResponseTime = CFAbsoluteTimeGetCurrent() }
+++
+++            if let downloadTaskDidWriteData = downloadTaskDidWriteData {
+++                downloadTaskDidWriteData(
+++                    session,
+++                    downloadTask,
+++                    bytesWritten,
+++                    totalBytesWritten, 
+++                    totalBytesExpectedToWrite
+++                )
+++            } else {
+++                progress.totalUnitCount = totalBytesExpectedToWrite
+++                progress.completedUnitCount = totalBytesWritten
+++
+++                downloadProgress?(bytesWritten, totalBytesWritten, totalBytesExpectedToWrite)
+++            }
+++        }
+++
+++        func URLSession(
+++            session: NSURLSession,
+++            downloadTask: NSURLSessionDownloadTask,
+++            didResumeAtOffset fileOffset: Int64,
+++            expectedTotalBytes: Int64)
+++        {
+++            if let downloadTaskDidResumeAtOffset = downloadTaskDidResumeAtOffset {
+++                downloadTaskDidResumeAtOffset(session, downloadTask, fileOffset, expectedTotalBytes)
+++            } else {
+++                progress.totalUnitCount = expectedTotalBytes
+++                progress.completedUnitCount = fileOffset
+++            }
+++        }
+++    }
+++}
++diff --git a/Pods/Alamofire/Source/Error.swift b/Pods/Alamofire/Source/Error.swift
++new file mode 100644
++index 0000000..467d99c
++--- /dev/null
+++++ b/Pods/Alamofire/Source/Error.swift
++@@ -0,0 +1,88 @@
+++//
+++//  Error.swift
+++//
+++//  Copyright (c) 2014-2016 Alamofire Software Foundation (http://alamofire.org/)
+++//
+++//  Permission is hereby granted, free of charge, to any person obtaining a copy
+++//  of this software and associated documentation files (the "Software"), to deal
+++//  in the Software without restriction, including without limitation the rights
+++//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+++//  copies of the Software, and to permit persons to whom the Software is
+++//  furnished to do so, subject to the following conditions:
+++//
+++//  The above copyright notice and this permission notice shall be included in
+++//  all copies or substantial portions of the Software.
+++//
+++//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+++//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+++//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+++//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+++//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+++//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+++//  THE SOFTWARE.
+++//
+++
+++import Foundation
+++
+++/// The `Error` struct provides a convenience for creating custom Alamofire NSErrors.
+++public struct Error {
+++    /// The domain used for creating all Alamofire errors.
+++    public static let Domain = "com.alamofire.error"
+++
+++    /// The custom error codes generated by Alamofire.
+++    public enum Code: Int {
+++        case InputStreamReadFailed           = -6000
+++        case OutputStreamWriteFailed         = -6001
+++        case ContentTypeValidationFailed     = -6002
+++        case StatusCodeValidationFailed      = -6003
+++        case DataSerializationFailed         = -6004
+++        case StringSerializationFailed       = -6005
+++        case JSONSerializationFailed         = -6006
+++        case PropertyListSerializationFailed = -6007
+++    }
+++
+++    /// Custom keys contained within certain NSError `userInfo` dictionaries generated by Alamofire.
+++    public struct UserInfoKeys {
+++        /// The content type user info key for a `.ContentTypeValidationFailed` error stored as a `String` value.
+++        public static let ContentType = "ContentType"
+++
+++        /// The status code user info key for a `.StatusCodeValidationFailed` error stored as an `Int` value.
+++        public static let StatusCode = "StatusCode"
+++    }
+++
+++    /**
+++        Creates an `NSError` with the given error code and failure reason.
+++
+++        - parameter code:          The error code.
+++        - parameter failureReason: The failure reason.
+++
+++        - returns: An `NSError` with the given error code and failure reason.
+++    */
+++    @available(*, deprecated=3.4.0)
+++    public static func errorWithCode(code: Code, failureReason: String) -> NSError {
+++        return errorWithCode(code.rawValue, failureReason: failureReason)
+++    }
+++
+++    /**
+++        Creates an `NSError` with the given error code and failure reason.
+++
+++        - parameter code:          The error code.
+++        - parameter failureReason: The failure reason.
+++
+++        - returns: An `NSError` with the given error code and failure reason.
+++    */
+++    @available(*, deprecated=3.4.0)
+++    public static func errorWithCode(code: Int, failureReason: String) -> NSError {
+++        let userInfo = [NSLocalizedFailureReasonErrorKey: failureReason]
+++        return NSError(domain: Domain, code: code, userInfo: userInfo)
+++    }
+++
+++    static func error(domain domain: String = Error.Domain, code: Code, failureReason: String) -> NSError {
+++        return error(domain: domain, code: code.rawValue, failureReason: failureReason)
+++    }
+++
+++    static func error(domain domain: String = Error.Domain, code: Int, failureReason: String) -> NSError {
+++        let userInfo = [NSLocalizedFailureReasonErrorKey: failureReason]
+++        return NSError(domain: domain, code: code, userInfo: userInfo)
+++    }
+++}
++diff --git a/Pods/Alamofire/Source/Manager.swift b/Pods/Alamofire/Source/Manager.swift
++new file mode 100644
++index 0000000..691d31f
++--- /dev/null
+++++ b/Pods/Alamofire/Source/Manager.swift
++@@ -0,0 +1,778 @@
+++//
+++//  Manager.swift
+++//
+++//  Copyright (c) 2014-2016 Alamofire Software Foundation (http://alamofire.org/)
+++//
+++//  Permission is hereby granted, free of charge, to any person obtaining a copy
+++//  of this software and associated documentation files (the "Software"), to deal
+++//  in the Software without restriction, including without limitation the rights
+++//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+++//  copies of the Software, and to permit persons to whom the Software is
+++//  furnished to do so, subject to the following conditions:
+++//
+++//  The above copyright notice and this permission notice shall be included in
+++//  all copies or substantial portions of the Software.
+++//
+++//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+++//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+++//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+++//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+++//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+++//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+++//  THE SOFTWARE.
+++//
+++
+++import Foundation
+++
+++/**
+++    Responsible for creating and managing `Request` objects, as well as their underlying `NSURLSession`.
+++*/
+++public class Manager {
+++
+++    // MARK: - Properties
+++
+++    /**
+++        A shared instance of `Manager`, used by top-level Alamofire request methods, and suitable for use directly 
+++        for any ad hoc requests.
+++    */
+++    public static let sharedInstance: Manager = {
+++        let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
+++        configuration.HTTPAdditionalHeaders = Manager.defaultHTTPHeaders
+++
+++        return Manager(configuration: configuration)
+++    }()
+++
+++    /**
+++        Creates default values for the "Accept-Encoding", "Accept-Language" and "User-Agent" headers.
+++    */
+++    public static let defaultHTTPHeaders: [String: String] = {
+++        // Accept-Encoding HTTP Header; see https://tools.ietf.org/html/rfc7230#section-4.2.3
+++        let acceptEncoding: String = "gzip;q=1.0, compress;q=0.5"
+++
+++        // Accept-Language HTTP Header; see https://tools.ietf.org/html/rfc7231#section-5.3.5
+++        let acceptLanguage = NSLocale.preferredLanguages().prefix(6).enumerate().map { index, languageCode in
+++            let quality = 1.0 - (Double(index) * 0.1)
+++            return "\(languageCode);q=\(quality)"
+++        }.joinWithSeparator(", ")
+++
+++        // User-Agent Header; see https://tools.ietf.org/html/rfc7231#section-5.5.3
+++        let userAgent: String = {
+++            if let info = NSBundle.mainBundle().infoDictionary {
+++                let executable = info[kCFBundleExecutableKey as String] as? String ?? "Unknown"
+++                let bundle = info[kCFBundleIdentifierKey as String] as? String ?? "Unknown"
+++                let version = info[kCFBundleVersionKey as String] as? String ?? "Unknown"
+++
+++                let osNameVersion: String = {
+++                    let versionString: String
+++
+++                    if #available(OSX 10.10, *) {
+++                        let version = NSProcessInfo.processInfo().operatingSystemVersion
+++                        versionString = "\(version.majorVersion).\(version.minorVersion).\(version.patchVersion)"
+++                    } else {
+++                        versionString = "10.9"
+++                    }
+++
+++                    let osName: String = {
+++                        #if os(iOS)
+++                            return "iOS"
+++                        #elseif os(watchOS)
+++                            return "watchOS"
+++                        #elseif os(tvOS)
+++                            return "tvOS"
+++                        #elseif os(OSX)
+++                            return "OS X"
+++                        #elseif os(Linux)
+++                            return "Linux"
+++                        #else
+++                            return "Unknown"
+++                        #endif
+++                    }()
+++
+++                    return "\(osName) \(versionString)"
+++                }()
+++
+++                return "\(executable)/\(bundle) (\(version); \(osNameVersion))"
+++            }
+++
+++            return "Alamofire"
+++        }()
+++
+++        return [
+++            "Accept-Encoding": acceptEncoding,
+++            "Accept-Language": acceptLanguage,
+++            "User-Agent": userAgent
+++        ]
+++    }()
+++
+++    let queue = dispatch_queue_create(nil, DISPATCH_QUEUE_SERIAL)
+++
+++    /// The underlying session.
+++    public let session: NSURLSession
+++
+++    /// The session delegate handling all the task and session delegate callbacks.
+++    public let delegate: SessionDelegate
+++
+++    /// Whether to start requests immediately after being constructed. `true` by default.
+++    public var startRequestsImmediately: Bool = true
+++
+++    /**
+++        The background completion handler closure provided by the UIApplicationDelegate 
+++        `application:handleEventsForBackgroundURLSession:completionHandler:` method. By setting the background 
+++        completion handler, the SessionDelegate `sessionDidFinishEventsForBackgroundURLSession` closure implementation 
+++        will automatically call the handler.
+++    
+++        If you need to handle your own events before the handler is called, then you need to override the 
+++        SessionDelegate `sessionDidFinishEventsForBackgroundURLSession` and manually call the handler when finished.
+++    
+++        `nil` by default.
+++    */
+++    public var backgroundCompletionHandler: (() -> Void)?
+++
+++    // MARK: - Lifecycle
+++
+++    /**
+++        Initializes the `Manager` instance with the specified configuration, delegate and server trust policy.
+++
+++        - parameter configuration:            The configuration used to construct the managed session. 
+++                                              `NSURLSessionConfiguration.defaultSessionConfiguration()` by default.
+++        - parameter delegate:                 The delegate used when initializing the session. `SessionDelegate()` by
+++                                              default.
+++        - parameter serverTrustPolicyManager: The server trust policy manager to use for evaluating all server trust 
+++                                              challenges. `nil` by default.
+++
+++        - returns: The new `Manager` instance.
+++    */
+++    public init(
+++        configuration: NSURLSessionConfiguration = NSURLSessionConfiguration.defaultSessionConfiguration(),
+++        delegate: SessionDelegate = SessionDelegate(),
+++        serverTrustPolicyManager: ServerTrustPolicyManager? = nil)
+++    {
+++        self.delegate = delegate
+++        self.session = NSURLSession(configuration: configuration, delegate: delegate, delegateQueue: nil)
+++
+++        commonInit(serverTrustPolicyManager: serverTrustPolicyManager)
+++    }
+++
+++    /**
+++        Initializes the `Manager` instance with the specified session, delegate and server trust policy.
+++
+++        - parameter session:                  The URL session.
+++        - parameter delegate:                 The delegate of the URL session. Must equal the URL session's delegate.
+++        - parameter serverTrustPolicyManager: The server trust policy manager to use for evaluating all server trust
+++                                              challenges. `nil` by default.
+++
+++        - returns: The new `Manager` instance if the URL session's delegate matches the delegate parameter.
+++    */
+++    public init?(
+++        session: NSURLSession,
+++        delegate: SessionDelegate,
+++        serverTrustPolicyManager: ServerTrustPolicyManager? = nil)
+++    {
+++        guard delegate === session.delegate else { return nil }
+++
+++        self.delegate = delegate
+++        self.session = session
+++
+++        commonInit(serverTrustPolicyManager: serverTrustPolicyManager)
+++    }
+++
+++    private func commonInit(serverTrustPolicyManager serverTrustPolicyManager: ServerTrustPolicyManager?) {
+++        session.serverTrustPolicyManager = serverTrustPolicyManager
+++
+++        delegate.sessionDidFinishEventsForBackgroundURLSession = { [weak self] session in
+++            guard let strongSelf = self else { return }
+++            dispatch_async(dispatch_get_main_queue()) { strongSelf.backgroundCompletionHandler?() }
+++        }
+++    }
+++
+++    deinit {
+++        session.invalidateAndCancel()
+++    }
+++
+++    // MARK: - Request
+++
+++    /**
+++        Creates a request for the specified method, URL string, parameters, parameter encoding and headers.
+++
+++        - parameter method:     The HTTP method.
+++        - parameter URLString:  The URL string.
+++        - parameter parameters: The parameters. `nil` by default.
+++        - parameter encoding:   The parameter encoding. `.URL` by default.
+++        - parameter headers:    The HTTP headers. `nil` by default.
+++
+++        - returns: The created request.
+++    */
+++    public func request(
+++        method: Method,
+++        _ URLString: URLStringConvertible,
+++        parameters: [String: AnyObject]? = nil,
+++        encoding: ParameterEncoding = .URL,
+++        headers: [String: String]? = nil)
+++        -> Request
+++    {
+++        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
+++        let encodedURLRequest = encoding.encode(mutableURLRequest, parameters: parameters).0
+++        return request(encodedURLRequest)
+++    }
+++
+++    /**
+++        Creates a request for the specified URL request.
+++
+++        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
+++
+++        - parameter URLRequest: The URL request
+++
+++        - returns: The created request.
+++    */
+++    public func request(URLRequest: URLRequestConvertible) -> Request {
+++        var dataTask: NSURLSessionDataTask!
+++        dispatch_sync(queue) { dataTask = self.session.dataTaskWithRequest(URLRequest.URLRequest) }
+++
+++        let request = Request(session: session, task: dataTask)
+++        delegate[request.delegate.task] = request.delegate
+++
+++        if startRequestsImmediately {
+++            request.resume()
+++        }
+++
+++        return request
+++    }
+++
+++    // MARK: - SessionDelegate
+++
+++    /**
+++        Responsible for handling all delegate callbacks for the underlying session.
+++    */
+++    public class SessionDelegate: NSObject, NSURLSessionDelegate, NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate {
+++        private var subdelegates: [Int: Request.TaskDelegate] = [:]
+++        private let subdelegateQueue = dispatch_queue_create(nil, DISPATCH_QUEUE_CONCURRENT)
+++
+++        /// Access the task delegate for the specified task in a thread-safe manner.
+++        public subscript(task: NSURLSessionTask) -> Request.TaskDelegate? {
+++            get {
+++                var subdelegate: Request.TaskDelegate?
+++                dispatch_sync(subdelegateQueue) { subdelegate = self.subdelegates[task.taskIdentifier] }
+++
+++                return subdelegate
+++            }
+++            set {
+++                dispatch_barrier_async(subdelegateQueue) { self.subdelegates[task.taskIdentifier] = newValue }
+++            }
+++        }
+++
+++        /**
+++            Initializes the `SessionDelegate` instance.
+++
+++            - returns: The new `SessionDelegate` instance.
+++        */
+++        public override init() {
+++            super.init()
+++        }
+++
+++        // MARK: - NSURLSessionDelegate
+++
+++        // MARK: Override Closures
+++
+++        /// Overrides default behavior for NSURLSessionDelegate method `URLSession:didBecomeInvalidWithError:`.
+++        public var sessionDidBecomeInvalidWithError: ((NSURLSession, NSError?) -> Void)?
+++
+++        /// Overrides default behavior for NSURLSessionDelegate method `URLSession:didReceiveChallenge:completionHandler:`.
+++        public var sessionDidReceiveChallenge: ((NSURLSession, NSURLAuthenticationChallenge) -> (NSURLSessionAuthChallengeDisposition, NSURLCredential?))?
+++
+++        /// Overrides all behavior for NSURLSessionDelegate method `URLSession:didReceiveChallenge:completionHandler:` and requires the caller to call the `completionHandler`.
+++        public var sessionDidReceiveChallengeWithCompletion: ((NSURLSession, NSURLAuthenticationChallenge, (NSURLSessionAuthChallengeDisposition, NSURLCredential?) -> Void) -> Void)?
+++
+++        /// Overrides default behavior for NSURLSessionDelegate method `URLSessionDidFinishEventsForBackgroundURLSession:`.
+++        public var sessionDidFinishEventsForBackgroundURLSession: ((NSURLSession) -> Void)?
+++
+++        // MARK: Delegate Methods
+++
+++        /**
+++            Tells the delegate that the session has been invalidated.
+++
+++            - parameter session: The session object that was invalidated.
+++            - parameter error:   The error that caused invalidation, or nil if the invalidation was explicit.
+++        */
+++        public func URLSession(session: NSURLSession, didBecomeInvalidWithError error: NSError?) {
+++            sessionDidBecomeInvalidWithError?(session, error)
+++        }
+++
+++        /**
+++            Requests credentials from the delegate in response to a session-level authentication request from the remote server.
+++
+++            - parameter session:           The session containing the task that requested authentication.
+++            - parameter challenge:         An object that contains the request for authentication.
+++            - parameter completionHandler: A handler that your delegate method must call providing the disposition and credential.
+++        */
+++        public func URLSession(
+++            session: NSURLSession,
+++            didReceiveChallenge challenge: NSURLAuthenticationChallenge,
+++            completionHandler: ((NSURLSessionAuthChallengeDisposition, NSURLCredential?) -> Void))
+++        {
+++            guard sessionDidReceiveChallengeWithCompletion == nil else {
+++                sessionDidReceiveChallengeWithCompletion?(session, challenge, completionHandler)
+++                return
+++            }
+++
+++            var disposition: NSURLSessionAuthChallengeDisposition = .PerformDefaultHandling
+++            var credential: NSURLCredential?
+++
+++            if let sessionDidReceiveChallenge = sessionDidReceiveChallenge {
+++                (disposition, credential) = sessionDidReceiveChallenge(session, challenge)
+++            } else if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
+++                let host = challenge.protectionSpace.host
+++
+++                if let
+++                    serverTrustPolicy = session.serverTrustPolicyManager?.serverTrustPolicyForHost(host),
+++                    serverTrust = challenge.protectionSpace.serverTrust
+++                {
+++                    if serverTrustPolicy.evaluateServerTrust(serverTrust, isValidForHost: host) {
+++                        disposition = .UseCredential
+++                        credential = NSURLCredential(forTrust: serverTrust)
+++                    } else {
+++                        disposition = .CancelAuthenticationChallenge
+++                    }
+++                }
+++            }
+++
+++            completionHandler(disposition, credential)
+++        }
+++
+++        /**
+++            Tells the delegate that all messages enqueued for a session have been delivered.
+++
+++            - parameter session: The session that no longer has any outstanding requests.
+++        */
+++        public func URLSessionDidFinishEventsForBackgroundURLSession(session: NSURLSession) {
+++            sessionDidFinishEventsForBackgroundURLSession?(session)
+++        }
+++
+++        // MARK: - NSURLSessionTaskDelegate
+++
+++        // MARK: Override Closures
+++
+++        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:`.
+++        public var taskWillPerformHTTPRedirection: ((NSURLSession, NSURLSessionTask, NSHTTPURLResponse, NSURLRequest) -> NSURLRequest?)?
+++
+++        /// Overrides all behavior for NSURLSessionTaskDelegate method `URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:` and
+++        /// requires the caller to call the `completionHandler`.
+++        public var taskWillPerformHTTPRedirectionWithCompletion: ((NSURLSession, NSURLSessionTask, NSHTTPURLResponse, NSURLRequest, NSURLRequest? -> Void) -> Void)?
+++
+++        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:didReceiveChallenge:completionHandler:`.
+++        public var taskDidReceiveChallenge: ((NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge) -> (NSURLSessionAuthChallengeDisposition, NSURLCredential?))?
+++
+++        /// Overrides all behavior for NSURLSessionTaskDelegate method `URLSession:task:didReceiveChallenge:completionHandler:` and 
+++        /// requires the caller to call the `completionHandler`.
+++        public var taskDidReceiveChallengeWithCompletion: ((NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge, (NSURLSessionAuthChallengeDisposition, NSURLCredential?) -> Void) -> Void)?
+++
+++        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:session:task:needNewBodyStream:`.
+++        public var taskNeedNewBodyStream: ((NSURLSession, NSURLSessionTask) -> NSInputStream?)?
+++
+++        /// Overrides all behavior for NSURLSessionTaskDelegate method `URLSession:session:task:needNewBodyStream:` and 
+++        /// requires the caller to call the `completionHandler`.
+++        public var taskNeedNewBodyStreamWithCompletion: ((NSURLSession, NSURLSessionTask, NSInputStream? -> Void) -> Void)?
+++
+++        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:`.
+++        public var taskDidSendBodyData: ((NSURLSession, NSURLSessionTask, Int64, Int64, Int64) -> Void)?
+++
+++        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:didCompleteWithError:`.
+++        public var taskDidComplete: ((NSURLSession, NSURLSessionTask, NSError?) -> Void)?
+++
+++        // MARK: Delegate Methods
+++
+++        /**
+++            Tells the delegate that the remote server requested an HTTP redirect.
+++
+++            - parameter session:           The session containing the task whose request resulted in a redirect.
+++            - parameter task:              The task whose request resulted in a redirect.
+++            - parameter response:          An object containing the server’s response to the original request.
+++            - parameter request:           A URL request object filled out with the new location.
+++            - parameter completionHandler: A closure that your handler should call with either the value of the request 
+++                                           parameter, a modified URL request object, or NULL to refuse the redirect and 
+++                                           return the body of the redirect response.
+++        */
+++        public func URLSession(
+++            session: NSURLSession,
+++            task: NSURLSessionTask,
+++            willPerformHTTPRedirection response: NSHTTPURLResponse,
+++            newRequest request: NSURLRequest,
+++            completionHandler: NSURLRequest? -> Void)
+++        {
+++            guard taskWillPerformHTTPRedirectionWithCompletion == nil else {
+++                taskWillPerformHTTPRedirectionWithCompletion?(session, task, response, request, completionHandler)
+++                return
+++            }
+++
+++            var redirectRequest: NSURLRequest? = request
+++
+++            if let taskWillPerformHTTPRedirection = taskWillPerformHTTPRedirection {
+++                redirectRequest = taskWillPerformHTTPRedirection(session, task, response, request)
+++            }
+++
+++            completionHandler(redirectRequest)
+++        }
+++
+++        /**
+++            Requests credentials from the delegate in response to an authentication request from the remote server.
+++
+++            - parameter session:           The session containing the task whose request requires authentication.
+++            - parameter task:              The task whose request requires authentication.
+++            - parameter challenge:         An object that contains the request for authentication.
+++            - parameter completionHandler: A handler that your delegate method must call providing the disposition and credential.
+++        */
+++        public func URLSession(
+++            session: NSURLSession,
+++            task: NSURLSessionTask,
+++            didReceiveChallenge challenge: NSURLAuthenticationChallenge,
+++            completionHandler: (NSURLSessionAuthChallengeDisposition, NSURLCredential?) -> Void)
+++        {
+++            guard taskDidReceiveChallengeWithCompletion == nil else {
+++                taskDidReceiveChallengeWithCompletion?(session, task, challenge, completionHandler)
+++                return
+++            }
+++
+++            if let taskDidReceiveChallenge = taskDidReceiveChallenge {
+++                let result = taskDidReceiveChallenge(session, task, challenge)
+++                completionHandler(result.0, result.1)
+++            } else if let delegate = self[task] {
+++                delegate.URLSession(
+++                    session,
+++                    task: task,
+++                    didReceiveChallenge: challenge,
+++                    completionHandler: completionHandler
+++                )
+++            } else {
+++                URLSession(session, didReceiveChallenge: challenge, completionHandler: completionHandler)
+++            }
+++        }
+++
+++        /**
+++            Tells the delegate when a task requires a new request body stream to send to the remote server.
+++
+++            - parameter session:           The session containing the task that needs a new body stream.
+++            - parameter task:              The task that needs a new body stream.
+++            - parameter completionHandler: A completion handler that your delegate method should call with the new body stream.
+++        */
+++        public func URLSession(
+++            session: NSURLSession,
+++            task: NSURLSessionTask,
+++            needNewBodyStream completionHandler: NSInputStream? -> Void)
+++        {
+++            guard taskNeedNewBodyStreamWithCompletion == nil else {
+++                taskNeedNewBodyStreamWithCompletion?(session, task, completionHandler)
+++                return
+++            }
+++
+++            if let taskNeedNewBodyStream = taskNeedNewBodyStream {
+++                completionHandler(taskNeedNewBodyStream(session, task))
+++            } else if let delegate = self[task] {
+++                delegate.URLSession(session, task: task, needNewBodyStream: completionHandler)
+++            }
+++        }
+++
+++        /**
+++            Periodically informs the delegate of the progress of sending body content to the server.
+++
+++            - parameter session:                  The session containing the data task.
+++            - parameter task:                     The data task.
+++            - parameter bytesSent:                The number of bytes sent since the last time this delegate method was called.
+++            - parameter totalBytesSent:           The total number of bytes sent so far.
+++            - parameter totalBytesExpectedToSend: The expected length of the body data.
+++        */
+++        public func URLSession(
+++            session: NSURLSession,
+++            task: NSURLSessionTask,
+++            didSendBodyData bytesSent: Int64,
+++            totalBytesSent: Int64,
+++            totalBytesExpectedToSend: Int64)
+++        {
+++            if let taskDidSendBodyData = taskDidSendBodyData {
+++                taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalBytesExpectedToSend)
+++            } else if let delegate = self[task] as? Request.UploadTaskDelegate {
+++                delegate.URLSession(
+++                    session,
+++                    task: task,
+++                    didSendBodyData: bytesSent,
+++                    totalBytesSent: totalBytesSent,
+++                    totalBytesExpectedToSend: totalBytesExpectedToSend
+++                )
+++            }
+++        }
+++
+++        /**
+++            Tells the delegate that the task finished transferring data.
+++
+++            - parameter session: The session containing the task whose request finished transferring data.
+++            - parameter task:    The task whose request finished transferring data.
+++            - parameter error:   If an error occurred, an error object indicating how the transfer failed, otherwise nil.
+++        */
+++        public func URLSession(session: NSURLSession, task: NSURLSessionTask, didCompleteWithError error: NSError?) {
+++            if let taskDidComplete = taskDidComplete {
+++                taskDidComplete(session, task, error)
+++            } else if let delegate = self[task] {
+++                delegate.URLSession(session, task: task, didCompleteWithError: error)
+++            }
+++
+++            NSNotificationCenter.defaultCenter().postNotificationName(Notifications.Task.DidComplete, object: task)
+++
+++            self[task] = nil
+++        }
+++
+++        // MARK: - NSURLSessionDataDelegate
+++
+++        // MARK: Override Closures
+++
+++        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:didReceiveResponse:completionHandler:`.
+++        public var dataTaskDidReceiveResponse: ((NSURLSession, NSURLSessionDataTask, NSURLResponse) -> NSURLSessionResponseDisposition)?
+++
+++        /// Overrides all behavior for NSURLSessionDataDelegate method `URLSession:dataTask:didReceiveResponse:completionHandler:` and 
+++        /// requires caller to call the `completionHandler`.
+++        public var dataTaskDidReceiveResponseWithCompletion: ((NSURLSession, NSURLSessionDataTask, NSURLResponse, NSURLSessionResponseDisposition -> Void) -> Void)?
+++
+++        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:didBecomeDownloadTask:`.
+++        public var dataTaskDidBecomeDownloadTask: ((NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask) -> Void)?
+++
+++        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:didReceiveData:`.
+++        public var dataTaskDidReceiveData: ((NSURLSession, NSURLSessionDataTask, NSData) -> Void)?
+++
+++        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:willCacheResponse:completionHandler:`.
+++        public var dataTaskWillCacheResponse: ((NSURLSession, NSURLSessionDataTask, NSCachedURLResponse) -> NSCachedURLResponse?)?
+++
+++        /// Overrides all behavior for NSURLSessionDataDelegate method `URLSession:dataTask:willCacheResponse:completionHandler:` and 
+++        /// requires caller to call the `completionHandler`.
+++        public var dataTaskWillCacheResponseWithCompletion: ((NSURLSession, NSURLSessionDataTask, NSCachedURLResponse, NSCachedURLResponse? -> Void) -> Void)?
+++
+++        // MARK: Delegate Methods
+++
+++        /**
+++            Tells the delegate that the data task received the initial reply (headers) from the server.
+++
+++            - parameter session:           The session containing the data task that received an initial reply.
+++            - parameter dataTask:          The data task that received an initial reply.
+++            - parameter response:          A URL response object populated with headers.
+++            - parameter completionHandler: A completion handler that your code calls to continue the transfer, passing a 
+++                                           constant to indicate whether the transfer should continue as a data task or 
+++                                           should become a download task.
+++        */
+++        public func URLSession(
+++            session: NSURLSession,
+++            dataTask: NSURLSessionDataTask,
+++            didReceiveResponse response: NSURLResponse,
+++            completionHandler: NSURLSessionResponseDisposition -> Void)
+++        {
+++            guard dataTaskDidReceiveResponseWithCompletion == nil else {
+++                dataTaskDidReceiveResponseWithCompletion?(session, dataTask, response, completionHandler)
+++                return
+++            }
+++
+++            var disposition: NSURLSessionResponseDisposition = .Allow
+++
+++            if let dataTaskDidReceiveResponse = dataTaskDidReceiveResponse {
+++                disposition = dataTaskDidReceiveResponse(session, dataTask, response)
+++            }
+++
+++            completionHandler(disposition)
+++        }
+++
+++        /**
+++            Tells the delegate that the data task was changed to a download task.
+++
+++            - parameter session:      The session containing the task that was replaced by a download task.
+++            - parameter dataTask:     The data task that was replaced by a download task.
+++            - parameter downloadTask: The new download task that replaced the data task.
+++        */
+++        public func URLSession(
+++            session: NSURLSession,
+++            dataTask: NSURLSessionDataTask,
+++            didBecomeDownloadTask downloadTask: NSURLSessionDownloadTask)
+++        {
+++            if let dataTaskDidBecomeDownloadTask = dataTaskDidBecomeDownloadTask {
+++                dataTaskDidBecomeDownloadTask(session, dataTask, downloadTask)
+++            } else {
+++                let downloadDelegate = Request.DownloadTaskDelegate(task: downloadTask)
+++                self[downloadTask] = downloadDelegate
+++            }
+++        }
+++
+++        /**
+++            Tells the delegate that the data task has received some of the expected data.
+++
+++            - parameter session:  The session containing the data task that provided data.
+++            - parameter dataTask: The data task that provided data.
+++            - parameter data:     A data object containing the transferred data.
+++        */
+++        public func URLSession(session: NSURLSession, dataTask: NSURLSessionDataTask, didReceiveData data: NSData) {
+++            if let dataTaskDidReceiveData = dataTaskDidReceiveData {
+++                dataTaskDidReceiveData(session, dataTask, data)
+++            } else if let delegate = self[dataTask] as? Request.DataTaskDelegate {
+++                delegate.URLSession(session, dataTask: dataTask, didReceiveData: data)
+++            }
+++        }
+++
+++        /**
+++            Asks the delegate whether the data (or upload) task should store the response in the cache.
+++
+++            - parameter session:           The session containing the data (or upload) task.
+++            - parameter dataTask:          The data (or upload) task.
+++            - parameter proposedResponse:  The default caching behavior. This behavior is determined based on the current 
+++                                           caching policy and the values of certain received headers, such as the Pragma 
+++                                           and Cache-Control headers.
+++            - parameter completionHandler: A block that your handler must call, providing either the original proposed 
+++                                           response, a modified version of that response, or NULL to prevent caching the 
+++                                           response. If your delegate implements this method, it must call this completion 
+++                                           handler; otherwise, your app leaks memory.
+++        */
+++        public func URLSession(
+++            session: NSURLSession,
+++            dataTask: NSURLSessionDataTask,
+++            willCacheResponse proposedResponse: NSCachedURLResponse,
+++            completionHandler: NSCachedURLResponse? -> Void)
+++        {
+++            guard dataTaskWillCacheResponseWithCompletion == nil else {
+++                dataTaskWillCacheResponseWithCompletion?(session, dataTask, proposedResponse, completionHandler)
+++                return
+++            }
+++
+++            if let dataTaskWillCacheResponse = dataTaskWillCacheResponse {
+++                completionHandler(dataTaskWillCacheResponse(session, dataTask, proposedResponse))
+++            } else if let delegate = self[dataTask] as? Request.DataTaskDelegate {
+++                delegate.URLSession(
+++                    session,
+++                    dataTask: dataTask,
+++                    willCacheResponse: proposedResponse,
+++                    completionHandler: completionHandler
+++                )
+++            } else {
+++                completionHandler(proposedResponse)
+++            }
+++        }
+++
+++        // MARK: - NSURLSessionDownloadDelegate
+++
+++        // MARK: Override Closures
+++
+++        /// Overrides default behavior for NSURLSessionDownloadDelegate method `URLSession:downloadTask:didFinishDownloadingToURL:`.
+++        public var downloadTaskDidFinishDownloadingToURL: ((NSURLSession, NSURLSessionDownloadTask, NSURL) -> Void)?
+++
+++        /// Overrides default behavior for NSURLSessionDownloadDelegate method `URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:`.
+++        public var downloadTaskDidWriteData: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64, Int64) -> Void)?
+++
+++        /// Overrides default behavior for NSURLSessionDownloadDelegate method `URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:`.
+++        public var downloadTaskDidResumeAtOffset: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64) -> Void)?
+++
+++        // MARK: Delegate Methods
+++
+++        /**
+++            Tells the delegate that a download task has finished downloading.
+++
+++            - parameter session:      The session containing the download task that finished.
+++            - parameter downloadTask: The download task that finished.
+++            - parameter location:     A file URL for the temporary file. Because the file is temporary, you must either 
+++                                      open the file for reading or move it to a permanent location in your app’s sandbox 
+++                                      container directory before returning from this delegate method.
+++        */
+++        public func URLSession(
+++            session: NSURLSession,
+++            downloadTask: NSURLSessionDownloadTask,
+++            didFinishDownloadingToURL location: NSURL)
+++        {
+++            if let downloadTaskDidFinishDownloadingToURL = downloadTaskDidFinishDownloadingToURL {
+++                downloadTaskDidFinishDownloadingToURL(session, downloadTask, location)
+++            } else if let delegate = self[downloadTask] as? Request.DownloadTaskDelegate {
+++                delegate.URLSession(session, downloadTask: downloadTask, didFinishDownloadingToURL: location)
+++            }
+++        }
+++
+++        /**
+++            Periodically informs the delegate about the download’s progress.
+++
+++            - parameter session:                   The session containing the download task.
+++            - parameter downloadTask:              The download task.
+++            - parameter bytesWritten:              The number of bytes transferred since the last time this delegate 
+++                                                   method was called.
+++            - parameter totalBytesWritten:         The total number of bytes transferred so far.
+++            - parameter totalBytesExpectedToWrite: The expected length of the file, as provided by the Content-Length 
+++                                                   header. If this header was not provided, the value is 
+++                                                   `NSURLSessionTransferSizeUnknown`.
+++        */
+++        public func URLSession(
+++            session: NSURLSession,
+++            downloadTask: NSURLSessionDownloadTask,
+++            didWriteData bytesWritten: Int64,
+++            totalBytesWritten: Int64,
+++            totalBytesExpectedToWrite: Int64)
+++        {
+++            if let downloadTaskDidWriteData = downloadTaskDidWriteData {
+++                downloadTaskDidWriteData(session, downloadTask, bytesWritten, totalBytesWritten, totalBytesExpectedToWrite)
+++            } else if let delegate = self[downloadTask] as? Request.DownloadTaskDelegate {
+++                delegate.URLSession(
+++                    session,
+++                    downloadTask: downloadTask,
+++                    didWriteData: bytesWritten,
+++                    totalBytesWritten: totalBytesWritten,
+++                    totalBytesExpectedToWrite: totalBytesExpectedToWrite
+++                )
+++            }
+++        }
+++
+++        /**
+++            Tells the delegate that the download task has resumed downloading.
+++
+++            - parameter session:            The session containing the download task that finished.
+++            - parameter downloadTask:       The download task that resumed. See explanation in the discussion.
+++            - parameter fileOffset:         If the file's cache policy or last modified date prevents reuse of the 
+++                                            existing content, then this value is zero. Otherwise, this value is an 
+++                                            integer representing the number of bytes on disk that do not need to be 
+++                                            retrieved again.
+++            - parameter expectedTotalBytes: The expected length of the file, as provided by the Content-Length header. 
+++                                            If this header was not provided, the value is NSURLSessionTransferSizeUnknown.
+++        */
+++        public func URLSession(
+++            session: NSURLSession,
+++            downloadTask: NSURLSessionDownloadTask,
+++            didResumeAtOffset fileOffset: Int64,
+++            expectedTotalBytes: Int64)
+++        {
+++            if let downloadTaskDidResumeAtOffset = downloadTaskDidResumeAtOffset {
+++                downloadTaskDidResumeAtOffset(session, downloadTask, fileOffset, expectedTotalBytes)
+++            } else if let delegate = self[downloadTask] as? Request.DownloadTaskDelegate {
+++                delegate.URLSession(
+++                    session,
+++                    downloadTask: downloadTask,
+++                    didResumeAtOffset: fileOffset,
+++                    expectedTotalBytes: expectedTotalBytes
+++                )
+++            }
+++        }
+++
+++        // MARK: - NSURLSessionStreamDelegate
+++
+++        var _streamTaskReadClosed: Any?
+++        var _streamTaskWriteClosed: Any?
+++        var _streamTaskBetterRouteDiscovered: Any?
+++        var _streamTaskDidBecomeInputStream: Any?
+++
+++        // MARK: - NSObject
+++
+++        public override func respondsToSelector(selector: Selector) -> Bool {
+++            #if !os(OSX)
+++                if selector == #selector(NSURLSessionDelegate.URLSessionDidFinishEventsForBackgroundURLSession(_:)) {
+++                    return sessionDidFinishEventsForBackgroundURLSession != nil
+++                }
+++            #endif
+++
+++            switch selector {
+++            case #selector(NSURLSessionDelegate.URLSession(_:didBecomeInvalidWithError:)):
+++                return sessionDidBecomeInvalidWithError != nil
+++            case #selector(NSURLSessionDelegate.URLSession(_:didReceiveChallenge:completionHandler:)):
+++                return (sessionDidReceiveChallenge != nil  || sessionDidReceiveChallengeWithCompletion != nil)
+++            case #selector(NSURLSessionTaskDelegate.URLSession(_:task:willPerformHTTPRedirection:newRequest:completionHandler:)):
+++                return (taskWillPerformHTTPRedirection != nil || taskWillPerformHTTPRedirectionWithCompletion != nil)
+++            case #selector(NSURLSessionDataDelegate.URLSession(_:dataTask:didReceiveResponse:completionHandler:)):
+++                return (dataTaskDidReceiveResponse != nil || dataTaskDidReceiveResponseWithCompletion != nil)
+++            default:
+++                return self.dynamicType.instancesRespondToSelector(selector)
+++            }
+++        }
+++    }
+++}
++diff --git a/Pods/Alamofire/Source/MultipartFormData.swift b/Pods/Alamofire/Source/MultipartFormData.swift
++new file mode 100644
++index 0000000..b4087ec
++--- /dev/null
+++++ b/Pods/Alamofire/Source/MultipartFormData.swift
++@@ -0,0 +1,659 @@
+++//
+++//  MultipartFormData.swift
+++//
+++//  Copyright (c) 2014-2016 Alamofire Software Foundation (http://alamofire.org/)
+++//
+++//  Permission is hereby granted, free of charge, to any person obtaining a copy
+++//  of this software and associated documentation files (the "Software"), to deal
+++//  in the Software without restriction, including without limitation the rights
+++//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+++//  copies of the Software, and to permit persons to whom the Software is
+++//  furnished to do so, subject to the following conditions:
+++//
+++//  The above copyright notice and this permission notice shall be included in
+++//  all copies or substantial portions of the Software.
+++//
+++//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+++//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+++//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+++//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+++//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+++//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+++//  THE SOFTWARE.
+++//
+++
+++import Foundation
+++
+++#if os(iOS) || os(watchOS) || os(tvOS)
+++import MobileCoreServices
+++#elseif os(OSX)
+++import CoreServices
+++#endif
+++
+++/**
+++    Constructs `multipart/form-data` for uploads within an HTTP or HTTPS body. There are currently two ways to encode 
+++    multipart form data. The first way is to encode the data directly in memory. This is very efficient, but can lead 
+++    to memory issues if the dataset is too large. The second way is designed for larger datasets and will write all the 
+++    data to a single file on disk with all the proper boundary segmentation. The second approach MUST be used for 
+++    larger datasets such as video content, otherwise your app may run out of memory when trying to encode the dataset.
+++
+++    For more information on `multipart/form-data` in general, please refer to the RFC-2388 and RFC-2045 specs as well
+++    and the w3 form documentation.
+++
+++    - https://www.ietf.org/rfc/rfc2388.txt
+++    - https://www.ietf.org/rfc/rfc2045.txt
+++    - https://www.w3.org/TR/html401/interact/forms.html#h-17.13
+++*/
+++public class MultipartFormData {
+++
+++    // MARK: - Helper Types
+++
+++    struct EncodingCharacters {
+++        static let CRLF = "\r\n"
+++    }
+++
+++    struct BoundaryGenerator {
+++        enum BoundaryType {
+++            case Initial, Encapsulated, Final
+++        }
+++
+++        static func randomBoundary() -> String {
+++            return String(format: "alamofire.boundary.%08x%08x", arc4random(), arc4random())
+++        }
+++
+++        static func boundaryData(boundaryType boundaryType: BoundaryType, boundary: String) -> NSData {
+++            let boundaryText: String
+++
+++            switch boundaryType {
+++            case .Initial:
+++                boundaryText = "--\(boundary)\(EncodingCharacters.CRLF)"
+++            case .Encapsulated:
+++                boundaryText = "\(EncodingCharacters.CRLF)--\(boundary)\(EncodingCharacters.CRLF)"
+++            case .Final:
+++                boundaryText = "\(EncodingCharacters.CRLF)--\(boundary)--\(EncodingCharacters.CRLF)"
+++            }
+++
+++            return boundaryText.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)!
+++        }
+++    }
+++
+++    class BodyPart {
+++        let headers: [String: String]
+++        let bodyStream: NSInputStream
+++        let bodyContentLength: UInt64
+++        var hasInitialBoundary = false
+++        var hasFinalBoundary = false
+++
+++        init(headers: [String: String], bodyStream: NSInputStream, bodyContentLength: UInt64) {
+++            self.headers = headers
+++            self.bodyStream = bodyStream
+++            self.bodyContentLength = bodyContentLength
+++        }
+++    }
+++
+++    // MARK: - Properties
+++
+++    /// The `Content-Type` header value containing the boundary used to generate the `multipart/form-data`.
+++    public var contentType: String { return "multipart/form-data; boundary=\(boundary)" }
+++
+++    /// The content length of all body parts used to generate the `multipart/form-data` not including the boundaries.
+++    public var contentLength: UInt64 { return bodyParts.reduce(0) { $0 + $1.bodyContentLength } }
+++
+++    /// The boundary used to separate the body parts in the encoded form data.
+++    public let boundary: String
+++
+++    private var bodyParts: [BodyPart]
+++    private var bodyPartError: NSError?
+++    private let streamBufferSize: Int
+++
+++    // MARK: - Lifecycle
+++
+++    /**
+++        Creates a multipart form data object.
+++
+++        - returns: The multipart form data object.
+++    */
+++    public init() {
+++        self.boundary = BoundaryGenerator.randomBoundary()
+++        self.bodyParts = []
+++
+++        /**
+++         *  The optimal read/write buffer size in bytes for input and output streams is 1024 (1KB). For more 
+++         *  information, please refer to the following article:
+++         *    - https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Streams/Articles/ReadingInputStreams.html
+++         */
+++
+++        self.streamBufferSize = 1024
+++    }
+++
+++    // MARK: - Body Parts
+++
+++    /**
+++        Creates a body part from the data and appends it to the multipart form data object.
+++
+++        The body part data will be encoded using the following format:
+++
+++        - `Content-Disposition: form-data; name=#{name}` (HTTP Header)
+++        - Encoded data
+++        - Multipart form boundary
+++
+++        - parameter data: The data to encode into the multipart form data.
+++        - parameter name: The name to associate with the data in the `Content-Disposition` HTTP header.
+++    */
+++    public func appendBodyPart(data data: NSData, name: String) {
+++        let headers = contentHeaders(name: name)
+++        let stream = NSInputStream(data: data)
+++        let length = UInt64(data.length)
+++
+++        appendBodyPart(stream: stream, length: length, headers: headers)
+++    }
+++
+++    /**
+++        Creates a body part from the data and appends it to the multipart form data object.
+++
+++        The body part data will be encoded using the following format:
+++
+++        - `Content-Disposition: form-data; name=#{name}` (HTTP Header)
+++        - `Content-Type: #{generated mimeType}` (HTTP Header)
+++        - Encoded data
+++        - Multipart form boundary
+++
+++        - parameter data:     The data to encode into the multipart form data.
+++        - parameter name:     The name to associate with the data in the `Content-Disposition` HTTP header.
+++        - parameter mimeType: The MIME type to associate with the data content type in the `Content-Type` HTTP header.
+++    */
+++    public func appendBodyPart(data data: NSData, name: String, mimeType: String) {
+++        let headers = contentHeaders(name: name, mimeType: mimeType)
+++        let stream = NSInputStream(data: data)
+++        let length = UInt64(data.length)
+++
+++        appendBodyPart(stream: stream, length: length, headers: headers)
+++    }
+++
+++    /**
+++        Creates a body part from the data and appends it to the multipart form data object.
+++
+++        The body part data will be encoded using the following format:
+++
+++        - `Content-Disposition: form-data; name=#{name}; filename=#{filename}` (HTTP Header)
+++        - `Content-Type: #{mimeType}` (HTTP Header)
+++        - Encoded file data
+++        - Multipart form boundary
+++
+++        - parameter data:     The data to encode into the multipart form data.
+++        - parameter name:     The name to associate with the data in the `Content-Disposition` HTTP header.
+++        - parameter fileName: The filename to associate with the data in the `Content-Disposition` HTTP header.
+++        - parameter mimeType: The MIME type to associate with the data in the `Content-Type` HTTP header.
+++    */
+++    public func appendBodyPart(data data: NSData, name: String, fileName: String, mimeType: String) {
+++        let headers = contentHeaders(name: name, fileName: fileName, mimeType: mimeType)
+++        let stream = NSInputStream(data: data)
+++        let length = UInt64(data.length)
+++
+++        appendBodyPart(stream: stream, length: length, headers: headers)
+++    }
+++
+++    /**
+++        Creates a body part from the file and appends it to the multipart form data object.
+++
+++        The body part data will be encoded using the following format:
+++
+++        - `Content-Disposition: form-data; name=#{name}; filename=#{generated filename}` (HTTP Header)
+++        - `Content-Type: #{generated mimeType}` (HTTP Header)
+++        - Encoded file data
+++        - Multipart form boundary
+++
+++        The filename in the `Content-Disposition` HTTP header is generated from the last path component of the
+++        `fileURL`. The `Content-Type` HTTP header MIME type is generated by mapping the `fileURL` extension to the
+++        system associated MIME type.
+++
+++        - parameter fileURL: The URL of the file whose content will be encoded into the multipart form data.
+++        - parameter name:    The name to associate with the file content in the `Content-Disposition` HTTP header.
+++    */
+++    public func appendBodyPart(fileURL fileURL: NSURL, name: String) {
+++        if let
+++            fileName = fileURL.lastPathComponent,
+++            pathExtension = fileURL.pathExtension
+++        {
+++            let mimeType = mimeTypeForPathExtension(pathExtension)
+++            appendBodyPart(fileURL: fileURL, name: name, fileName: fileName, mimeType: mimeType)
+++        } else {
+++            let failureReason = "Failed to extract the fileName of the provided URL: \(fileURL)"
+++            setBodyPartError(code: NSURLErrorBadURL, failureReason: failureReason)
+++        }
+++    }
+++
+++    /**
+++        Creates a body part from the file and appends it to the multipart form data object.
+++
+++        The body part data will be encoded using the following format:
+++
+++        - Content-Disposition: form-data; name=#{name}; filename=#{filename} (HTTP Header)
+++        - Content-Type: #{mimeType} (HTTP Header)
+++        - Encoded file data
+++        - Multipart form boundary
+++
+++        - parameter fileURL:  The URL of the file whose content will be encoded into the multipart form data.
+++        - parameter name:     The name to associate with the file content in the `Content-Disposition` HTTP header.
+++        - parameter fileName: The filename to associate with the file content in the `Content-Disposition` HTTP header.
+++        - parameter mimeType: The MIME type to associate with the file content in the `Content-Type` HTTP header.
+++    */
+++    public func appendBodyPart(fileURL fileURL: NSURL, name: String, fileName: String, mimeType: String) {
+++        let headers = contentHeaders(name: name, fileName: fileName, mimeType: mimeType)
+++
+++        //============================================================
+++        //                 Check 1 - is file URL?
+++        //============================================================
+++
+++        guard fileURL.fileURL else {
+++            let failureReason = "The file URL does not point to a file URL: \(fileURL)"
+++            setBodyPartError(code: NSURLErrorBadURL, failureReason: failureReason)
+++            return
+++        }
+++
+++        //============================================================
+++        //              Check 2 - is file URL reachable?
+++        //============================================================
+++
+++        var isReachable = true
+++
+++        if #available(OSX 10.10, *) {
+++            isReachable = fileURL.checkPromisedItemIsReachableAndReturnError(nil)
+++        }
+++
+++        guard isReachable else {
+++            setBodyPartError(code: NSURLErrorBadURL, failureReason: "The file URL is not reachable: \(fileURL)")
+++            return
+++        }
+++
+++        //============================================================
+++        //            Check 3 - is file URL a directory?
+++        //============================================================
+++
+++        var isDirectory: ObjCBool = false
+++
+++        guard let
+++            path = fileURL.path
+++            where NSFileManager.defaultManager().fileExistsAtPath(path, isDirectory: &isDirectory) && !isDirectory else
+++        {
+++            let failureReason = "The file URL is a directory, not a file: \(fileURL)"
+++            setBodyPartError(code: NSURLErrorBadURL, failureReason: failureReason)
+++            return
+++        }
+++
+++        //============================================================
+++        //          Check 4 - can the file size be extracted?
+++        //============================================================
+++
+++        var bodyContentLength: UInt64?
+++
+++        do {
+++            if let
+++                path = fileURL.path,
+++                fileSize = try NSFileManager.defaultManager().attributesOfItemAtPath(path)[NSFileSize] as? NSNumber
+++            {
+++                bodyContentLength = fileSize.unsignedLongLongValue
+++            }
+++        } catch {
+++            // No-op
+++        }
+++
+++        guard let length = bodyContentLength else {
+++            let failureReason = "Could not fetch attributes from the file URL: \(fileURL)"
+++            setBodyPartError(code: NSURLErrorBadURL, failureReason: failureReason)
+++            return
+++        }
+++
+++        //============================================================
+++        //       Check 5 - can a stream be created from file URL?
+++        //============================================================
+++
+++        guard let stream = NSInputStream(URL: fileURL) else {
+++            let failureReason = "Failed to create an input stream from the file URL: \(fileURL)"
+++            setBodyPartError(code: NSURLErrorCannotOpenFile, failureReason: failureReason)
+++            return
+++        }
+++
+++        appendBodyPart(stream: stream, length: length, headers: headers)
+++    }
+++
+++    /**
+++        Creates a body part from the stream and appends it to the multipart form data object.
+++
+++        The body part data will be encoded using the following format:
+++
+++        - `Content-Disposition: form-data; name=#{name}; filename=#{filename}` (HTTP Header)
+++        - `Content-Type: #{mimeType}` (HTTP Header)
+++        - Encoded stream data
+++        - Multipart form boundary
+++
+++        - parameter stream:   The input stream to encode in the multipart form data.
+++        - parameter length:   The content length of the stream.
+++        - parameter name:     The name to associate with the stream content in the `Content-Disposition` HTTP header.
+++        - parameter fileName: The filename to associate with the stream content in the `Content-Disposition` HTTP header.
+++        - parameter mimeType: The MIME type to associate with the stream content in the `Content-Type` HTTP header.
+++    */
+++    public func appendBodyPart(
+++        stream stream: NSInputStream,
+++        length: UInt64,
+++        name: String,
+++        fileName: String,
+++        mimeType: String)
+++    {
+++        let headers = contentHeaders(name: name, fileName: fileName, mimeType: mimeType)
+++        appendBodyPart(stream: stream, length: length, headers: headers)
+++    }
+++
+++    /**
+++        Creates a body part with the headers, stream and length and appends it to the multipart form data object.
+++
+++        The body part data will be encoded using the following format:
+++
+++        - HTTP headers
+++        - Encoded stream data
+++        - Multipart form boundary
+++
+++        - parameter stream:  The input stream to encode in the multipart form data.
+++        - parameter length:  The content length of the stream.
+++        - parameter headers: The HTTP headers for the body part.
+++    */
+++    public func appendBodyPart(stream stream: NSInputStream, length: UInt64, headers: [String: String]) {
+++        let bodyPart = BodyPart(headers: headers, bodyStream: stream, bodyContentLength: length)
+++        bodyParts.append(bodyPart)
+++    }
+++
+++    // MARK: - Data Encoding
+++
+++    /**
+++        Encodes all the appended body parts into a single `NSData` object.
+++
+++        It is important to note that this method will load all the appended body parts into memory all at the same 
+++        time. This method should only be used when the encoded data will have a small memory footprint. For large data 
+++        cases, please use the `writeEncodedDataToDisk(fileURL:completionHandler:)` method.
+++
+++        - throws: An `NSError` if encoding encounters an error.
+++
+++        - returns: The encoded `NSData` if encoding is successful.
+++    */
+++    public func encode() throws -> NSData {
+++        if let bodyPartError = bodyPartError {
+++            throw bodyPartError
+++        }
+++
+++        let encoded = NSMutableData()
+++
+++        bodyParts.first?.hasInitialBoundary = true
+++        bodyParts.last?.hasFinalBoundary = true
+++
+++        for bodyPart in bodyParts {
+++            let encodedData = try encodeBodyPart(bodyPart)
+++            encoded.appendData(encodedData)
+++        }
+++
+++        return encoded
+++    }
+++
+++    /**
+++        Writes the appended body parts into the given file URL.
+++
+++        This process is facilitated by reading and writing with input and output streams, respectively. Thus,
+++        this approach is very memory efficient and should be used for large body part data.
+++
+++        - parameter fileURL: The file URL to write the multipart form data into.
+++
+++        - throws: An `NSError` if encoding encounters an error.
+++    */
+++    public func writeEncodedDataToDisk(fileURL: NSURL) throws {
+++        if let bodyPartError = bodyPartError {
+++            throw bodyPartError
+++        }
+++
+++        if let path = fileURL.path where NSFileManager.defaultManager().fileExistsAtPath(path) {
+++            let failureReason = "A file already exists at the given file URL: \(fileURL)"
+++            throw Error.error(domain: NSURLErrorDomain, code: NSURLErrorBadURL, failureReason: failureReason)
+++        } else if !fileURL.fileURL {
+++            let failureReason = "The URL does not point to a valid file: \(fileURL)"
+++            throw Error.error(domain: NSURLErrorDomain, code: NSURLErrorBadURL, failureReason: failureReason)
+++        }
+++
+++        let outputStream: NSOutputStream
+++
+++        if let possibleOutputStream = NSOutputStream(URL: fileURL, append: false) {
+++            outputStream = possibleOutputStream
+++        } else {
+++            let failureReason = "Failed to create an output stream with the given URL: \(fileURL)"
+++            throw Error.error(domain: NSURLErrorDomain, code: NSURLErrorCannotOpenFile, failureReason: failureReason)
+++        }
+++
+++        outputStream.open()
+++
+++        self.bodyParts.first?.hasInitialBoundary = true
+++        self.bodyParts.last?.hasFinalBoundary = true
+++
+++        for bodyPart in self.bodyParts {
+++            try writeBodyPart(bodyPart, toOutputStream: outputStream)
+++        }
+++
+++        outputStream.close()
+++    }
+++
+++    // MARK: - Private - Body Part Encoding
+++
+++    private func encodeBodyPart(bodyPart: BodyPart) throws -> NSData {
+++        let encoded = NSMutableData()
+++
+++        let initialData = bodyPart.hasInitialBoundary ? initialBoundaryData() : encapsulatedBoundaryData()
+++        encoded.appendData(initialData)
+++
+++        let headerData = encodeHeaderDataForBodyPart(bodyPart)
+++        encoded.appendData(headerData)
+++
+++        let bodyStreamData = try encodeBodyStreamDataForBodyPart(bodyPart)
+++        encoded.appendData(bodyStreamData)
+++
+++        if bodyPart.hasFinalBoundary {
+++            encoded.appendData(finalBoundaryData())
+++        }
+++
+++        return encoded
+++    }
+++
+++    private func encodeHeaderDataForBodyPart(bodyPart: BodyPart) -> NSData {
+++        var headerText = ""
+++
+++        for (key, value) in bodyPart.headers {
+++            headerText += "\(key): \(value)\(EncodingCharacters.CRLF)"
+++        }
+++        headerText += EncodingCharacters.CRLF
+++
+++        return headerText.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)!
+++    }
+++
+++    private func encodeBodyStreamDataForBodyPart(bodyPart: BodyPart) throws -> NSData {
+++        let inputStream = bodyPart.bodyStream
+++        inputStream.open()
+++
+++        var error: NSError?
+++        let encoded = NSMutableData()
+++
+++        while inputStream.hasBytesAvailable {
+++            var buffer = [UInt8](count: streamBufferSize, repeatedValue: 0)
+++            let bytesRead = inputStream.read(&buffer, maxLength: streamBufferSize)
+++
+++            if inputStream.streamError != nil {
+++                error = inputStream.streamError
+++                break
+++            }
+++
+++            if bytesRead > 0 {
+++                encoded.appendBytes(buffer, length: bytesRead)
+++            } else if bytesRead < 0 {
+++                let failureReason = "Failed to read from input stream: \(inputStream)"
+++                error = Error.error(domain: NSURLErrorDomain, code: .InputStreamReadFailed, failureReason: failureReason)
+++                break
+++            } else {
+++                break
+++            }
+++        }
+++
+++        inputStream.close()
+++
+++        if let error = error {
+++            throw error
+++        }
+++
+++        return encoded
+++    }
+++
+++    // MARK: - Private - Writing Body Part to Output Stream
+++
+++    private func writeBodyPart(bodyPart: BodyPart, toOutputStream outputStream: NSOutputStream) throws {
+++        try writeInitialBoundaryDataForBodyPart(bodyPart, toOutputStream: outputStream)
+++        try writeHeaderDataForBodyPart(bodyPart, toOutputStream: outputStream)
+++        try writeBodyStreamForBodyPart(bodyPart, toOutputStream: outputStream)
+++        try writeFinalBoundaryDataForBodyPart(bodyPart, toOutputStream: outputStream)
+++    }
+++
+++    private func writeInitialBoundaryDataForBodyPart(
+++        bodyPart: BodyPart,
+++        toOutputStream outputStream: NSOutputStream)
+++        throws
+++    {
+++        let initialData = bodyPart.hasInitialBoundary ? initialBoundaryData() : encapsulatedBoundaryData()
+++        return try writeData(initialData, toOutputStream: outputStream)
+++    }
+++
+++    private func writeHeaderDataForBodyPart(bodyPart: BodyPart, toOutputStream outputStream: NSOutputStream) throws {
+++        let headerData = encodeHeaderDataForBodyPart(bodyPart)
+++        return try writeData(headerData, toOutputStream: outputStream)
+++    }
+++
+++    private func writeBodyStreamForBodyPart(bodyPart: BodyPart, toOutputStream outputStream: NSOutputStream) throws {
+++        let inputStream = bodyPart.bodyStream
+++        inputStream.open()
+++
+++        while inputStream.hasBytesAvailable {
+++            var buffer = [UInt8](count: streamBufferSize, repeatedValue: 0)
+++            let bytesRead = inputStream.read(&buffer, maxLength: streamBufferSize)
+++
+++            if let streamError = inputStream.streamError {
+++                throw streamError
+++            }
+++
+++            if bytesRead > 0 {
+++                if buffer.count != bytesRead {
+++                    buffer = Array(buffer[0..<bytesRead])
+++                }
+++
+++                try writeBuffer(&buffer, toOutputStream: outputStream)
+++            } else if bytesRead < 0 {
+++                let failureReason = "Failed to read from input stream: \(inputStream)"
+++                throw Error.error(domain: NSURLErrorDomain, code: .InputStreamReadFailed, failureReason: failureReason)
+++            } else {
+++                break
+++            }
+++        }
+++
+++        inputStream.close()
+++    }
+++
+++    private func writeFinalBoundaryDataForBodyPart(
+++        bodyPart: BodyPart,
+++        toOutputStream outputStream: NSOutputStream)
+++        throws
+++    {
+++        if bodyPart.hasFinalBoundary {
+++            return try writeData(finalBoundaryData(), toOutputStream: outputStream)
+++        }
+++    }
+++
+++    // MARK: - Private - Writing Buffered Data to Output Stream
+++
+++    private func writeData(data: NSData, toOutputStream outputStream: NSOutputStream) throws {
+++        var buffer = [UInt8](count: data.length, repeatedValue: 0)
+++        data.getBytes(&buffer, length: data.length)
+++
+++        return try writeBuffer(&buffer, toOutputStream: outputStream)
+++    }
+++
+++    private func writeBuffer(inout buffer: [UInt8], toOutputStream outputStream: NSOutputStream) throws {
+++        var bytesToWrite = buffer.count
+++
+++        while bytesToWrite > 0 {
+++            if outputStream.hasSpaceAvailable {
+++                let bytesWritten = outputStream.write(buffer, maxLength: bytesToWrite)
+++
+++                if let streamError = outputStream.streamError {
+++                    throw streamError
+++                }
+++
+++                if bytesWritten < 0 {
+++                    let failureReason = "Failed to write to output stream: \(outputStream)"
+++                    throw Error.error(domain: NSURLErrorDomain, code: .OutputStreamWriteFailed, failureReason: failureReason)
+++                }
+++
+++                bytesToWrite -= bytesWritten
+++
+++                if bytesToWrite > 0 {
+++                    buffer = Array(buffer[bytesWritten..<buffer.count])
+++                }
+++            } else if let streamError = outputStream.streamError {
+++                throw streamError
+++            }
+++        }
+++    }
+++
+++    // MARK: - Private - Mime Type
+++
+++    private func mimeTypeForPathExtension(pathExtension: String) -> String {
+++        if let
+++            id = UTTypeCreatePreferredIdentifierForTag(kUTTagClassFilenameExtension, pathExtension, nil)?.takeRetainedValue(),
+++            contentType = UTTypeCopyPreferredTagWithClass(id, kUTTagClassMIMEType)?.takeRetainedValue()
+++        {
+++            return contentType as String
+++        }
+++
+++        return "application/octet-stream"
+++    }
+++
+++    // MARK: - Private - Content Headers
+++
+++    private func contentHeaders(name name: String) -> [String: String] {
+++        return ["Content-Disposition": "form-data; name=\"\(name)\""]
+++    }
+++
+++    private func contentHeaders(name name: String, mimeType: String) -> [String: String] {
+++        return [
+++            "Content-Disposition": "form-data; name=\"\(name)\"",
+++            "Content-Type": "\(mimeType)"
+++        ]
+++    }
+++
+++    private func contentHeaders(name name: String, fileName: String, mimeType: String) -> [String: String] {
+++        return [
+++            "Content-Disposition": "form-data; name=\"\(name)\"; filename=\"\(fileName)\"",
+++            "Content-Type": "\(mimeType)"
+++        ]
+++    }
+++
+++    // MARK: - Private - Boundary Encoding
+++
+++    private func initialBoundaryData() -> NSData {
+++        return BoundaryGenerator.boundaryData(boundaryType: .Initial, boundary: boundary)
+++    }
+++
+++    private func encapsulatedBoundaryData() -> NSData {
+++        return BoundaryGenerator.boundaryData(boundaryType: .Encapsulated, boundary: boundary)
+++    }
+++
+++    private func finalBoundaryData() -> NSData {
+++        return BoundaryGenerator.boundaryData(boundaryType: .Final, boundary: boundary)
+++    }
+++
+++    // MARK: - Private - Errors
+++
+++    private func setBodyPartError(code code: Int, failureReason: String) {
+++        guard bodyPartError == nil else { return }
+++        bodyPartError = Error.error(domain: NSURLErrorDomain, code: code, failureReason: failureReason)
+++    }
+++}
++diff --git a/Pods/Alamofire/Source/NetworkReachabilityManager.swift b/Pods/Alamofire/Source/NetworkReachabilityManager.swift
++new file mode 100644
++index 0000000..1e5c7b0
++--- /dev/null
+++++ b/Pods/Alamofire/Source/NetworkReachabilityManager.swift
++@@ -0,0 +1,244 @@
+++//
+++//  NetworkReachabilityManager.swift
+++//
+++//  Copyright (c) 2014-2016 Alamofire Software Foundation (http://alamofire.org/)
+++//
+++//  Permission is hereby granted, free of charge, to any person obtaining a copy
+++//  of this software and associated documentation files (the "Software"), to deal
+++//  in the Software without restriction, including without limitation the rights
+++//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+++//  copies of the Software, and to permit persons to whom the Software is
+++//  furnished to do so, subject to the following conditions:
+++//
+++//  The above copyright notice and this permission notice shall be included in
+++//  all copies or substantial portions of the Software.
+++//
+++//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+++//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+++//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+++//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+++//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+++//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+++//  THE SOFTWARE.
+++//
+++
+++#if !os(watchOS)
+++
+++import Foundation
+++import SystemConfiguration
+++
+++/**
+++    The `NetworkReachabilityManager` class listens for reachability changes of hosts and addresses for both WWAN and
+++    WiFi network interfaces.
+++
+++    Reachability can be used to determine background information about why a network operation failed, or to retry
+++    network requests when a connection is established. It should not be used to prevent a user from initiating a network
+++    request, as it's possible that an initial request may be required to establish reachability.
+++*/
+++public class NetworkReachabilityManager {
+++    /**
+++        Defines the various states of network reachability.
+++
+++        - Unknown:         It is unknown whether the network is reachable.
+++        - NotReachable:    The network is not reachable.
+++        - ReachableOnWWAN: The network is reachable over the WWAN connection.
+++        - ReachableOnWiFi: The network is reachable over the WiFi connection.
+++    */
+++    public enum NetworkReachabilityStatus {
+++        case Unknown
+++        case NotReachable
+++        case Reachable(ConnectionType)
+++    }
+++
+++    /**
+++        Defines the various connection types detected by reachability flags.
+++
+++        - EthernetOrWiFi: The connection type is either over Ethernet or WiFi.
+++        - WWAN:           The connection type is a WWAN connection.
+++    */
+++    public enum ConnectionType {
+++        case EthernetOrWiFi
+++        case WWAN
+++    }
+++
+++    /// A closure executed when the network reachability status changes. The closure takes a single argument: the 
+++    /// network reachability status.
+++    public typealias Listener = NetworkReachabilityStatus -> Void
+++
+++    // MARK: - Properties
+++
+++    /// Whether the network is currently reachable.
+++    public var isReachable: Bool { return isReachableOnWWAN || isReachableOnEthernetOrWiFi }
+++
+++    /// Whether the network is currently reachable over the WWAN interface.
+++    public var isReachableOnWWAN: Bool { return networkReachabilityStatus == .Reachable(.WWAN) }
+++
+++    /// Whether the network is currently reachable over Ethernet or WiFi interface.
+++    public var isReachableOnEthernetOrWiFi: Bool { return networkReachabilityStatus == .Reachable(.EthernetOrWiFi) }
+++
+++    /// The current network reachability status.
+++    public var networkReachabilityStatus: NetworkReachabilityStatus {
+++        guard let flags = self.flags else { return .Unknown }
+++        return networkReachabilityStatusForFlags(flags)
+++    }
+++
+++    /// The dispatch queue to execute the `listener` closure on.
+++    public var listenerQueue: dispatch_queue_t = dispatch_get_main_queue()
+++
+++    /// A closure executed when the network reachability status changes.
+++    public var listener: Listener?
+++
+++    private var flags: SCNetworkReachabilityFlags? {
+++        var flags = SCNetworkReachabilityFlags()
+++
+++        if SCNetworkReachabilityGetFlags(reachability, &flags) {
+++            return flags
+++        }
+++
+++        return nil
+++    }
+++
+++    private let reachability: SCNetworkReachability
+++    private var previousFlags: SCNetworkReachabilityFlags
+++
+++    // MARK: - Initialization
+++
+++    /**
+++        Creates a `NetworkReachabilityManager` instance with the specified host.
+++
+++        - parameter host: The host used to evaluate network reachability.
+++
+++        - returns: The new `NetworkReachabilityManager` instance.
+++    */
+++    public convenience init?(host: String) {
+++        guard let reachability = SCNetworkReachabilityCreateWithName(nil, host) else { return nil }
+++        self.init(reachability: reachability)
+++    }
+++
+++    /**
+++        Creates a `NetworkReachabilityManager` instance that monitors the address 0.0.0.0.
+++
+++        Reachability treats the 0.0.0.0 address as a special token that causes it to monitor the general routing
+++        status of the device, both IPv4 and IPv6.
+++
+++        - returns: The new `NetworkReachabilityManager` instance.
+++    */
+++    public convenience init?() {
+++        var address = sockaddr_in()
+++        address.sin_len = UInt8(sizeofValue(address))
+++        address.sin_family = sa_family_t(AF_INET)
+++
+++        guard let reachability = withUnsafePointer(&address, {
+++            SCNetworkReachabilityCreateWithAddress(nil, UnsafePointer($0))
+++        }) else { return nil }
+++
+++        self.init(reachability: reachability)
+++    }
+++
+++    private init(reachability: SCNetworkReachability) {
+++        self.reachability = reachability
+++        self.previousFlags = SCNetworkReachabilityFlags()
+++    }
+++
+++    deinit {
+++        stopListening()
+++    }
+++
+++    // MARK: - Listening
+++
+++    /**
+++        Starts listening for changes in network reachability status.
+++
+++        - returns: `true` if listening was started successfully, `false` otherwise.
+++    */
+++    public func startListening() -> Bool {
+++        var context = SCNetworkReachabilityContext(version: 0, info: nil, retain: nil, release: nil, copyDescription: nil)
+++        context.info = UnsafeMutablePointer(Unmanaged.passUnretained(self).toOpaque())
+++
+++        let callbackEnabled = SCNetworkReachabilitySetCallback(
+++            reachability,
+++            { (_, flags, info) in
+++                let reachability = Unmanaged<NetworkReachabilityManager>.fromOpaque(COpaquePointer(info)).takeUnretainedValue()
+++                reachability.notifyListener(flags)
+++            },
+++            &context
+++        )
+++
+++        let queueEnabled = SCNetworkReachabilitySetDispatchQueue(reachability, listenerQueue)
+++
+++        dispatch_async(listenerQueue) {
+++            self.previousFlags = SCNetworkReachabilityFlags()
+++            self.notifyListener(self.flags ?? SCNetworkReachabilityFlags())
+++        }
+++
+++        return callbackEnabled && queueEnabled
+++    }
+++
+++    /**
+++        Stops listening for changes in network reachability status.
+++    */
+++    public func stopListening() {
+++        SCNetworkReachabilitySetCallback(reachability, nil, nil)
+++        SCNetworkReachabilitySetDispatchQueue(reachability, nil)
+++    }
+++
+++    // MARK: - Internal - Listener Notification
+++
+++    func notifyListener(flags: SCNetworkReachabilityFlags) {
+++        guard previousFlags != flags else { return }
+++        previousFlags = flags
+++
+++        listener?(networkReachabilityStatusForFlags(flags))
+++    }
+++
+++    // MARK: - Internal - Network Reachability Status
+++
+++    func networkReachabilityStatusForFlags(flags: SCNetworkReachabilityFlags) -> NetworkReachabilityStatus {
+++        guard flags.contains(.Reachable) else { return .NotReachable }
+++
+++        var networkStatus: NetworkReachabilityStatus = .NotReachable
+++
+++        if !flags.contains(.ConnectionRequired) { networkStatus = .Reachable(.EthernetOrWiFi) }
+++
+++        if flags.contains(.ConnectionOnDemand) || flags.contains(.ConnectionOnTraffic) {
+++            if !flags.contains(.InterventionRequired) { networkStatus = .Reachable(.EthernetOrWiFi) }
+++        }
+++
+++        #if os(iOS)
+++            if flags.contains(.IsWWAN) { networkStatus = .Reachable(.WWAN) }
+++        #endif
+++
+++        return networkStatus
+++    }
+++}
+++
+++// MARK: -
+++
+++extension NetworkReachabilityManager.NetworkReachabilityStatus: Equatable {}
+++
+++/**
+++    Returns whether the two network reachability status values are equal.
+++
+++    - parameter lhs: The left-hand side value to compare.
+++    - parameter rhs: The right-hand side value to compare.
+++
+++    - returns: `true` if the two values are equal, `false` otherwise.
+++*/
+++public func ==(
+++    lhs: NetworkReachabilityManager.NetworkReachabilityStatus,
+++    rhs: NetworkReachabilityManager.NetworkReachabilityStatus)
+++    -> Bool
+++{
+++    switch (lhs, rhs) {
+++    case (.Unknown, .Unknown):
+++        return true
+++    case (.NotReachable, .NotReachable):
+++        return true
+++    case let (.Reachable(lhsConnectionType), .Reachable(rhsConnectionType)):
+++        return lhsConnectionType == rhsConnectionType
+++    default:
+++        return false
+++    }
+++}
+++
+++#endif
++diff --git a/Pods/Alamofire/Source/Notifications.swift b/Pods/Alamofire/Source/Notifications.swift
++new file mode 100644
++index 0000000..cece87a
++--- /dev/null
+++++ b/Pods/Alamofire/Source/Notifications.swift
++@@ -0,0 +1,47 @@
+++//
+++//  Notifications.swift
+++//
+++//  Copyright (c) 2014-2016 Alamofire Software Foundation (http://alamofire.org/)
+++//
+++//  Permission is hereby granted, free of charge, to any person obtaining a copy
+++//  of this software and associated documentation files (the "Software"), to deal
+++//  in the Software without restriction, including without limitation the rights
+++//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+++//  copies of the Software, and to permit persons to whom the Software is
+++//  furnished to do so, subject to the following conditions:
+++//
+++//  The above copyright notice and this permission notice shall be included in
+++//  all copies or substantial portions of the Software.
+++//
+++//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+++//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+++//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+++//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+++//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+++//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+++//  THE SOFTWARE.
+++//
+++
+++import Foundation
+++
+++/// Contains all the `NSNotification` names posted by Alamofire with descriptions of each notification's payload.
+++public struct Notifications {
+++    /// Used as a namespace for all `NSURLSessionTask` related notifications.
+++    public struct Task {
+++        /// Notification posted when an `NSURLSessionTask` is resumed. The notification `object` contains the resumed
+++        /// `NSURLSessionTask`.
+++        public static let DidResume = "com.alamofire.notifications.task.didResume"
+++
+++        /// Notification posted when an `NSURLSessionTask` is suspended. The notification `object` contains the 
+++        /// suspended `NSURLSessionTask`.
+++        public static let DidSuspend = "com.alamofire.notifications.task.didSuspend"
+++
+++        /// Notification posted when an `NSURLSessionTask` is cancelled. The notification `object` contains the
+++        /// cancelled `NSURLSessionTask`.
+++        public static let DidCancel = "com.alamofire.notifications.task.didCancel"
+++
+++        /// Notification posted when an `NSURLSessionTask` is completed. The notification `object` contains the
+++        /// completed `NSURLSessionTask`.
+++        public static let DidComplete = "com.alamofire.notifications.task.didComplete"
+++    }
+++}
++diff --git a/Pods/Alamofire/Source/ParameterEncoding.swift b/Pods/Alamofire/Source/ParameterEncoding.swift
++new file mode 100644
++index 0000000..32e63d9
++--- /dev/null
+++++ b/Pods/Alamofire/Source/ParameterEncoding.swift
++@@ -0,0 +1,261 @@
+++//
+++//  ParameterEncoding.swift
+++//
+++//  Copyright (c) 2014-2016 Alamofire Software Foundation (http://alamofire.org/)
+++//
+++//  Permission is hereby granted, free of charge, to any person obtaining a copy
+++//  of this software and associated documentation files (the "Software"), to deal
+++//  in the Software without restriction, including without limitation the rights
+++//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+++//  copies of the Software, and to permit persons to whom the Software is
+++//  furnished to do so, subject to the following conditions:
+++//
+++//  The above copyright notice and this permission notice shall be included in
+++//  all copies or substantial portions of the Software.
+++//
+++//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+++//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+++//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+++//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+++//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+++//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+++//  THE SOFTWARE.
+++//
+++
+++import Foundation
+++
+++/**
+++    HTTP method definitions.
+++
+++    See https://tools.ietf.org/html/rfc7231#section-4.3
+++*/
+++public enum Method: String {
+++    case OPTIONS, GET, HEAD, POST, PUT, PATCH, DELETE, TRACE, CONNECT
+++}
+++
+++// MARK: ParameterEncoding
+++
+++/**
+++    Used to specify the way in which a set of parameters are applied to a URL request.
+++
+++    - `URL`:             Creates a query string to be set as or appended to any existing URL query for `GET`, `HEAD`, 
+++                         and `DELETE` requests, or set as the body for requests with any other HTTP method. The 
+++                         `Content-Type` HTTP header field of an encoded request with HTTP body is set to
+++                         `application/x-www-form-urlencoded; charset=utf-8`. Since there is no published specification
+++                         for how to encode collection types, the convention of appending `[]` to the key for array
+++                         values (`foo[]=1&foo[]=2`), and appending the key surrounded by square brackets for nested
+++                         dictionary values (`foo[bar]=baz`).
+++
+++    - `URLEncodedInURL`: Creates query string to be set as or appended to any existing URL query. Uses the same
+++                         implementation as the `.URL` case, but always applies the encoded result to the URL.
+++
+++    - `JSON`:            Uses `NSJSONSerialization` to create a JSON representation of the parameters object, which is 
+++                         set as the body of the request. The `Content-Type` HTTP header field of an encoded request is 
+++                         set to `application/json`.
+++
+++    - `PropertyList`:    Uses `NSPropertyListSerialization` to create a plist representation of the parameters object,
+++                         according to the associated format and write options values, which is set as the body of the
+++                         request. The `Content-Type` HTTP header field of an encoded request is set to
+++                         `application/x-plist`.
+++
+++    - `Custom`:          Uses the associated closure value to construct a new request given an existing request and
+++                         parameters.
+++*/
+++public enum ParameterEncoding {
+++    case URL
+++    case URLEncodedInURL
+++    case JSON
+++    case PropertyList(NSPropertyListFormat, NSPropertyListWriteOptions)
+++    case Custom((URLRequestConvertible, [String: AnyObject]?) -> (NSMutableURLRequest, NSError?))
+++
+++    /**
+++        Creates a URL request by encoding parameters and applying them onto an existing request.
+++
+++        - parameter URLRequest: The request to have parameters applied.
+++        - parameter parameters: The parameters to apply.
+++
+++        - returns: A tuple containing the constructed request and the error that occurred during parameter encoding, 
+++                   if any.
+++    */
+++    public func encode(
+++        URLRequest: URLRequestConvertible,
+++        parameters: [String: AnyObject]?)
+++        -> (NSMutableURLRequest, NSError?)
+++    {
+++        var mutableURLRequest = URLRequest.URLRequest
+++
+++        guard let parameters = parameters else { return (mutableURLRequest, nil) }
+++
+++        var encodingError: NSError? = nil
+++
+++        switch self {
+++        case .URL, .URLEncodedInURL:
+++            func query(parameters: [String: AnyObject]) -> String {
+++                var components: [(String, String)] = []
+++
+++                for key in parameters.keys.sort(<) {
+++                    let value = parameters[key]!
+++                    components += queryComponents(key, value)
+++                }
+++
+++                return (components.map { "\($0)=\($1)" } as [String]).joinWithSeparator("&")
+++            }
+++
+++            func encodesParametersInURL(method: Method) -> Bool {
+++                switch self {
+++                case .URLEncodedInURL:
+++                    return true
+++                default:
+++                    break
+++                }
+++
+++                switch method {
+++                case .GET, .HEAD, .DELETE:
+++                    return true
+++                default:
+++                    return false
+++                }
+++            }
+++
+++            if let method = Method(rawValue: mutableURLRequest.HTTPMethod) where encodesParametersInURL(method) {
+++                if let
+++                    URLComponents = NSURLComponents(URL: mutableURLRequest.URL!, resolvingAgainstBaseURL: false)
+++                    where !parameters.isEmpty
+++                {
+++                    let percentEncodedQuery = (URLComponents.percentEncodedQuery.map { $0 + "&" } ?? "") + query(parameters)
+++                    URLComponents.percentEncodedQuery = percentEncodedQuery
+++                    mutableURLRequest.URL = URLComponents.URL
+++                }
+++            } else {
+++                if mutableURLRequest.valueForHTTPHeaderField("Content-Type") == nil {
+++                    mutableURLRequest.setValue(
+++                        "application/x-www-form-urlencoded; charset=utf-8",
+++                        forHTTPHeaderField: "Content-Type"
+++                    )
+++                }
+++
+++                mutableURLRequest.HTTPBody = query(parameters).dataUsingEncoding(
+++                    NSUTF8StringEncoding,
+++                    allowLossyConversion: false
+++                )
+++            }
+++        case .JSON:
+++            do {
+++                let options = NSJSONWritingOptions()
+++                let data = try NSJSONSerialization.dataWithJSONObject(parameters, options: options)
+++
+++                if mutableURLRequest.valueForHTTPHeaderField("Content-Type") == nil {
+++                    mutableURLRequest.setValue("application/json", forHTTPHeaderField: "Content-Type")
+++                }
+++
+++                mutableURLRequest.HTTPBody = data
+++            } catch {
+++                encodingError = error as NSError
+++            }
+++        case .PropertyList(let format, let options):
+++            do {
+++                let data = try NSPropertyListSerialization.dataWithPropertyList(
+++                    parameters,
+++                    format: format,
+++                    options: options
+++                )
+++
+++                if mutableURLRequest.valueForHTTPHeaderField("Content-Type") == nil {
+++                    mutableURLRequest.setValue("application/x-plist", forHTTPHeaderField: "Content-Type")
+++                }
+++
+++                mutableURLRequest.HTTPBody = data
+++            } catch {
+++                encodingError = error as NSError
+++            }
+++        case .Custom(let closure):
+++            (mutableURLRequest, encodingError) = closure(mutableURLRequest, parameters)
+++        }
+++
+++        return (mutableURLRequest, encodingError)
+++    }
+++
+++    /**
+++        Creates percent-escaped, URL encoded query string components from the given key-value pair using recursion.
+++
+++        - parameter key:   The key of the query component.
+++        - parameter value: The value of the query component.
+++
+++        - returns: The percent-escaped, URL encoded query string components.
+++    */
+++    public func queryComponents(key: String, _ value: AnyObject) -> [(String, String)] {
+++        var components: [(String, String)] = []
+++
+++        if let dictionary = value as? [String: AnyObject] {
+++            for (nestedKey, value) in dictionary {
+++                components += queryComponents("\(key)[\(nestedKey)]", value)
+++            }
+++        } else if let array = value as? [AnyObject] {
+++            for value in array {
+++                components += queryComponents("\(key)[]", value)
+++            }
+++        } else {
+++            components.append((escape(key), escape("\(value)")))
+++        }
+++
+++        return components
+++    }
+++
+++    /**
+++        Returns a percent-escaped string following RFC 3986 for a query string key or value.
+++
+++        RFC 3986 states that the following characters are "reserved" characters.
+++
+++        - General Delimiters: ":", "#", "[", "]", "@", "?", "/"
+++        - Sub-Delimiters: "!", "$", "&", "'", "(", ")", "*", "+", ",", ";", "="
+++
+++        In RFC 3986 - Section 3.4, it states that the "?" and "/" characters should not be escaped to allow
+++        query strings to include a URL. Therefore, all "reserved" characters with the exception of "?" and "/"
+++        should be percent-escaped in the query string.
+++
+++        - parameter string: The string to be percent-escaped.
+++
+++        - returns: The percent-escaped string.
+++    */
+++    public func escape(string: String) -> String {
+++        let generalDelimitersToEncode = ":#[]@" // does not include "?" or "/" due to RFC 3986 - Section 3.4
+++        let subDelimitersToEncode = "!$&'()*+,;="
+++
+++        let allowedCharacterSet = NSCharacterSet.URLQueryAllowedCharacterSet().mutableCopy() as! NSMutableCharacterSet
+++        allowedCharacterSet.removeCharactersInString(generalDelimitersToEncode + subDelimitersToEncode)
+++
+++        var escaped = ""
+++
+++        //==========================================================================================================
+++        //
+++        //  Batching is required for escaping due to an internal bug in iOS 8.1 and 8.2. Encoding more than a few
+++        //  hundred Chinese characters causes various malloc error crashes. To avoid this issue until iOS 8 is no
+++        //  longer supported, batching MUST be used for encoding. This introduces roughly a 20% overhead. For more
+++        //  info, please refer to:
+++        //
+++        //      - https://github.com/Alamofire/Alamofire/issues/206
+++        //
+++        //==========================================================================================================
+++
+++        if #available(iOS 8.3, OSX 10.10, *) {
+++            escaped = string.stringByAddingPercentEncodingWithAllowedCharacters(allowedCharacterSet) ?? string
+++        } else {
+++            let batchSize = 50
+++            var index = string.startIndex
+++
+++            while index != string.endIndex {
+++                let startIndex = index
+++                let endIndex = index.advancedBy(batchSize, limit: string.endIndex)
+++                let range = startIndex..<endIndex
+++
+++                let substring = string.substringWithRange(range)
+++
+++                escaped += substring.stringByAddingPercentEncodingWithAllowedCharacters(allowedCharacterSet) ?? substring
+++
+++                index = endIndex
+++            }
+++        }
+++
+++        return escaped
+++    }
+++}
++diff --git a/Pods/Alamofire/Source/Request.swift b/Pods/Alamofire/Source/Request.swift
++new file mode 100644
++index 0000000..817cca5
++--- /dev/null
+++++ b/Pods/Alamofire/Source/Request.swift
++@@ -0,0 +1,568 @@
+++//
+++//  Request.swift
+++//
+++//  Copyright (c) 2014-2016 Alamofire Software Foundation (http://alamofire.org/)
+++//
+++//  Permission is hereby granted, free of charge, to any person obtaining a copy
+++//  of this software and associated documentation files (the "Software"), to deal
+++//  in the Software without restriction, including without limitation the rights
+++//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+++//  copies of the Software, and to permit persons to whom the Software is
+++//  furnished to do so, subject to the following conditions:
+++//
+++//  The above copyright notice and this permission notice shall be included in
+++//  all copies or substantial portions of the Software.
+++//
+++//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+++//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+++//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+++//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+++//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+++//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+++//  THE SOFTWARE.
+++//
+++
+++import Foundation
+++
+++/**
+++    Responsible for sending a request and receiving the response and associated data from the server, as well as 
+++    managing its underlying `NSURLSessionTask`.
+++*/
+++public class Request {
+++
+++    // MARK: - Properties
+++
+++    /// The delegate for the underlying task.
+++    public let delegate: TaskDelegate
+++
+++    /// The underlying task.
+++    public var task: NSURLSessionTask { return delegate.task }
+++
+++    /// The session belonging to the underlying task.
+++    public let session: NSURLSession
+++
+++    /// The request sent or to be sent to the server.
+++    public var request: NSURLRequest? { return task.originalRequest }
+++
+++    /// The response received from the server, if any.
+++    public var response: NSHTTPURLResponse? { return task.response as? NSHTTPURLResponse }
+++
+++    /// The progress of the request lifecycle.
+++    public var progress: NSProgress { return delegate.progress }
+++
+++    var startTime: CFAbsoluteTime?
+++    var endTime: CFAbsoluteTime?
+++
+++    // MARK: - Lifecycle
+++
+++    init(session: NSURLSession, task: NSURLSessionTask) {
+++        self.session = session
+++
+++        switch task {
+++        case is NSURLSessionUploadTask:
+++            delegate = UploadTaskDelegate(task: task)
+++        case is NSURLSessionDataTask:
+++            delegate = DataTaskDelegate(task: task)
+++        case is NSURLSessionDownloadTask:
+++            delegate = DownloadTaskDelegate(task: task)
+++        default:
+++            delegate = TaskDelegate(task: task)
+++        }
+++
+++        delegate.queue.addOperationWithBlock { self.endTime = CFAbsoluteTimeGetCurrent() }
+++    }
+++
+++    // MARK: - Authentication
+++
+++    /**
+++        Associates an HTTP Basic credential with the request.
+++
+++        - parameter user:        The user.
+++        - parameter password:    The password.
+++        - parameter persistence: The URL credential persistence. `.ForSession` by default.
+++
+++        - returns: The request.
+++    */
+++    public func authenticate(
+++        user user: String,
+++        password: String,
+++        persistence: NSURLCredentialPersistence = .ForSession)
+++        -> Self
+++    {
+++        let credential = NSURLCredential(user: user, password: password, persistence: persistence)
+++
+++        return authenticate(usingCredential: credential)
+++    }
+++
+++    /**
+++        Associates a specified credential with the request.
+++
+++        - parameter credential: The credential.
+++
+++        - returns: The request.
+++    */
+++    public func authenticate(usingCredential credential: NSURLCredential) -> Self {
+++        delegate.credential = credential
+++
+++        return self
+++    }
+++
+++    /**
+++        Returns a base64 encoded basic authentication credential as an authorization header dictionary.
+++
+++        - parameter user:     The user.
+++        - parameter password: The password.
+++
+++        - returns: A dictionary with Authorization key and credential value or empty dictionary if encoding fails.
+++    */
+++    public static func authorizationHeader(user user: String, password: String) -> [String: String] {
+++        guard let data = "\(user):\(password)".dataUsingEncoding(NSUTF8StringEncoding) else { return [:] }
+++
+++        let credential = data.base64EncodedStringWithOptions([])
+++
+++        return ["Authorization": "Basic \(credential)"]
+++    }
+++
+++    // MARK: - Progress
+++
+++    /**
+++        Sets a closure to be called periodically during the lifecycle of the request as data is written to or read 
+++        from the server.
+++
+++        - For uploads, the progress closure returns the bytes written, total bytes written, and total bytes expected 
+++          to write.
+++        - For downloads and data tasks, the progress closure returns the bytes read, total bytes read, and total bytes 
+++          expected to read.
+++
+++        - parameter closure: The code to be executed periodically during the lifecycle of the request.
+++
+++        - returns: The request.
+++    */
+++    public func progress(closure: ((Int64, Int64, Int64) -> Void)? = nil) -> Self {
+++        if let uploadDelegate = delegate as? UploadTaskDelegate {
+++            uploadDelegate.uploadProgress = closure
+++        } else if let dataDelegate = delegate as? DataTaskDelegate {
+++            dataDelegate.dataProgress = closure
+++        } else if let downloadDelegate = delegate as? DownloadTaskDelegate {
+++            downloadDelegate.downloadProgress = closure
+++        }
+++
+++        return self
+++    }
+++
+++    /**
+++        Sets a closure to be called periodically during the lifecycle of the request as data is read from the server.
+++
+++        This closure returns the bytes most recently received from the server, not including data from previous calls. 
+++        If this closure is set, data will only be available within this closure, and will not be saved elsewhere. It is 
+++        also important to note that the `response` closure will be called with nil `responseData`.
+++
+++        - parameter closure: The code to be executed periodically during the lifecycle of the request.
+++
+++        - returns: The request.
+++    */
+++    public func stream(closure: (NSData -> Void)? = nil) -> Self {
+++        if let dataDelegate = delegate as? DataTaskDelegate {
+++            dataDelegate.dataStream = closure
+++        }
+++
+++        return self
+++    }
+++
+++    // MARK: - State
+++
+++    /**
+++        Resumes the request.
+++    */
+++    public func resume() {
+++        if startTime == nil { startTime = CFAbsoluteTimeGetCurrent() }
+++
+++        task.resume()
+++        NSNotificationCenter.defaultCenter().postNotificationName(Notifications.Task.DidResume, object: task)
+++    }
+++
+++    /**
+++        Suspends the request.
+++    */
+++    public func suspend() {
+++        task.suspend()
+++        NSNotificationCenter.defaultCenter().postNotificationName(Notifications.Task.DidSuspend, object: task)
+++    }
+++
+++    /**
+++        Cancels the request.
+++    */
+++    public func cancel() {
+++        if let
+++            downloadDelegate = delegate as? DownloadTaskDelegate,
+++            downloadTask = downloadDelegate.downloadTask
+++        {
+++            downloadTask.cancelByProducingResumeData { data in
+++                downloadDelegate.resumeData = data
+++            }
+++        } else {
+++            task.cancel()
+++        }
+++
+++        NSNotificationCenter.defaultCenter().postNotificationName(Notifications.Task.DidCancel, object: task)
+++    }
+++
+++    // MARK: - TaskDelegate
+++
+++    /**
+++        The task delegate is responsible for handling all delegate callbacks for the underlying task as well as 
+++        executing all operations attached to the serial operation queue upon task completion.
+++    */
+++    public class TaskDelegate: NSObject {
+++
+++        /// The serial operation queue used to execute all operations after the task completes.
+++        public let queue: NSOperationQueue
+++
+++        let task: NSURLSessionTask
+++        let progress: NSProgress
+++
+++        var data: NSData? { return nil }
+++        var error: NSError?
+++
+++        var initialResponseTime: CFAbsoluteTime?
+++        var credential: NSURLCredential?
+++
+++        init(task: NSURLSessionTask) {
+++            self.task = task
+++            self.progress = NSProgress(totalUnitCount: 0)
+++            self.queue = {
+++                let operationQueue = NSOperationQueue()
+++                operationQueue.maxConcurrentOperationCount = 1
+++                operationQueue.suspended = true
+++
+++                if #available(OSX 10.10, *) {
+++                    operationQueue.qualityOfService = NSQualityOfService.Utility
+++                }
+++
+++                return operationQueue
+++            }()
+++        }
+++
+++        deinit {
+++            queue.cancelAllOperations()
+++            queue.suspended = false
+++        }
+++
+++        // MARK: - NSURLSessionTaskDelegate
+++
+++        // MARK: Override Closures
+++
+++        var taskWillPerformHTTPRedirection: ((NSURLSession, NSURLSessionTask, NSHTTPURLResponse, NSURLRequest) -> NSURLRequest?)?
+++        var taskDidReceiveChallenge: ((NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge) -> (NSURLSessionAuthChallengeDisposition, NSURLCredential?))?
+++        var taskNeedNewBodyStream: ((NSURLSession, NSURLSessionTask) -> NSInputStream?)?
+++        var taskDidCompleteWithError: ((NSURLSession, NSURLSessionTask, NSError?) -> Void)?
+++
+++        // MARK: Delegate Methods
+++
+++        func URLSession(
+++            session: NSURLSession,
+++            task: NSURLSessionTask,
+++            willPerformHTTPRedirection response: NSHTTPURLResponse,
+++            newRequest request: NSURLRequest,
+++            completionHandler: ((NSURLRequest?) -> Void))
+++        {
+++            var redirectRequest: NSURLRequest? = request
+++
+++            if let taskWillPerformHTTPRedirection = taskWillPerformHTTPRedirection {
+++                redirectRequest = taskWillPerformHTTPRedirection(session, task, response, request)
+++            }
+++
+++            completionHandler(redirectRequest)
+++        }
+++
+++        func URLSession(
+++            session: NSURLSession,
+++            task: NSURLSessionTask,
+++            didReceiveChallenge challenge: NSURLAuthenticationChallenge,
+++            completionHandler: ((NSURLSessionAuthChallengeDisposition, NSURLCredential?) -> Void))
+++        {
+++            var disposition: NSURLSessionAuthChallengeDisposition = .PerformDefaultHandling
+++            var credential: NSURLCredential?
+++
+++            if let taskDidReceiveChallenge = taskDidReceiveChallenge {
+++                (disposition, credential) = taskDidReceiveChallenge(session, task, challenge)
+++            } else if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
+++                let host = challenge.protectionSpace.host
+++
+++                if let
+++                    serverTrustPolicy = session.serverTrustPolicyManager?.serverTrustPolicyForHost(host),
+++                    serverTrust = challenge.protectionSpace.serverTrust
+++                {
+++                    if serverTrustPolicy.evaluateServerTrust(serverTrust, isValidForHost: host) {
+++                        disposition = .UseCredential
+++                        credential = NSURLCredential(forTrust: serverTrust)
+++                    } else {
+++                        disposition = .CancelAuthenticationChallenge
+++                    }
+++                }
+++            } else {
+++                if challenge.previousFailureCount > 0 {
+++                    disposition = .RejectProtectionSpace
+++                } else {
+++                    credential = self.credential ?? session.configuration.URLCredentialStorage?.defaultCredentialForProtectionSpace(challenge.protectionSpace)
+++
+++                    if credential != nil {
+++                        disposition = .UseCredential
+++                    }
+++                }
+++            }
+++
+++            completionHandler(disposition, credential)
+++        }
+++
+++        func URLSession(
+++            session: NSURLSession,
+++            task: NSURLSessionTask,
+++            needNewBodyStream completionHandler: ((NSInputStream?) -> Void))
+++        {
+++            var bodyStream: NSInputStream?
+++
+++            if let taskNeedNewBodyStream = taskNeedNewBodyStream {
+++                bodyStream = taskNeedNewBodyStream(session, task)
+++            }
+++
+++            completionHandler(bodyStream)
+++        }
+++
+++        func URLSession(session: NSURLSession, task: NSURLSessionTask, didCompleteWithError error: NSError?) {
+++            if let taskDidCompleteWithError = taskDidCompleteWithError {
+++                taskDidCompleteWithError(session, task, error)
+++            } else {
+++                if let error = error {
+++                    self.error = error
+++
+++                    if let
+++                        downloadDelegate = self as? DownloadTaskDelegate,
+++                        userInfo = error.userInfo as? [String: AnyObject],
+++                        resumeData = userInfo[NSURLSessionDownloadTaskResumeData] as? NSData
+++                    {
+++                        downloadDelegate.resumeData = resumeData
+++                    }
+++                }
+++
+++                queue.suspended = false
+++            }
+++        }
+++    }
+++
+++    // MARK: - DataTaskDelegate
+++
+++    class DataTaskDelegate: TaskDelegate, NSURLSessionDataDelegate {
+++        var dataTask: NSURLSessionDataTask? { return task as? NSURLSessionDataTask }
+++
+++        private var totalBytesReceived: Int64 = 0
+++        private var mutableData: NSMutableData
+++        override var data: NSData? {
+++            if dataStream != nil {
+++                return nil
+++            } else {
+++                return mutableData
+++            }
+++        }
+++
+++        private var expectedContentLength: Int64?
+++        private var dataProgress: ((bytesReceived: Int64, totalBytesReceived: Int64, totalBytesExpectedToReceive: Int64) -> Void)?
+++        private var dataStream: ((data: NSData) -> Void)?
+++
+++        override init(task: NSURLSessionTask) {
+++            mutableData = NSMutableData()
+++            super.init(task: task)
+++        }
+++
+++        // MARK: - NSURLSessionDataDelegate
+++
+++        // MARK: Override Closures
+++
+++        var dataTaskDidReceiveResponse: ((NSURLSession, NSURLSessionDataTask, NSURLResponse) -> NSURLSessionResponseDisposition)?
+++        var dataTaskDidBecomeDownloadTask: ((NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask) -> Void)?
+++        var dataTaskDidReceiveData: ((NSURLSession, NSURLSessionDataTask, NSData) -> Void)?
+++        var dataTaskWillCacheResponse: ((NSURLSession, NSURLSessionDataTask, NSCachedURLResponse) -> NSCachedURLResponse?)?
+++
+++        // MARK: Delegate Methods
+++
+++        func URLSession(
+++            session: NSURLSession,
+++            dataTask: NSURLSessionDataTask,
+++            didReceiveResponse response: NSURLResponse,
+++            completionHandler: (NSURLSessionResponseDisposition -> Void))
+++        {
+++            var disposition: NSURLSessionResponseDisposition = .Allow
+++
+++            expectedContentLength = response.expectedContentLength
+++
+++            if let dataTaskDidReceiveResponse = dataTaskDidReceiveResponse {
+++                disposition = dataTaskDidReceiveResponse(session, dataTask, response)
+++            }
+++
+++            completionHandler(disposition)
+++        }
+++
+++        func URLSession(
+++            session: NSURLSession,
+++            dataTask: NSURLSessionDataTask,
+++            didBecomeDownloadTask downloadTask: NSURLSessionDownloadTask)
+++        {
+++            dataTaskDidBecomeDownloadTask?(session, dataTask, downloadTask)
+++        }
+++
+++        func URLSession(session: NSURLSession, dataTask: NSURLSessionDataTask, didReceiveData data: NSData) {
+++            if initialResponseTime == nil { initialResponseTime = CFAbsoluteTimeGetCurrent() }
+++
+++            if let dataTaskDidReceiveData = dataTaskDidReceiveData {
+++                dataTaskDidReceiveData(session, dataTask, data)
+++            } else {
+++                if let dataStream = dataStream {
+++                    dataStream(data: data)
+++                } else {
+++                    mutableData.appendData(data)
+++                }
+++
+++                totalBytesReceived += data.length
+++                let totalBytesExpected = dataTask.response?.expectedContentLength ?? NSURLSessionTransferSizeUnknown
+++
+++                progress.totalUnitCount = totalBytesExpected
+++                progress.completedUnitCount = totalBytesReceived
+++
+++                dataProgress?(
+++                    bytesReceived: Int64(data.length),
+++                    totalBytesReceived: totalBytesReceived,
+++                    totalBytesExpectedToReceive: totalBytesExpected
+++                )
+++            }
+++        }
+++
+++        func URLSession(
+++            session: NSURLSession,
+++            dataTask: NSURLSessionDataTask,
+++            willCacheResponse proposedResponse: NSCachedURLResponse,
+++            completionHandler: ((NSCachedURLResponse?) -> Void))
+++        {
+++            var cachedResponse: NSCachedURLResponse? = proposedResponse
+++
+++            if let dataTaskWillCacheResponse = dataTaskWillCacheResponse {
+++                cachedResponse = dataTaskWillCacheResponse(session, dataTask, proposedResponse)
+++            }
+++
+++            completionHandler(cachedResponse)
+++        }
+++    }
+++}
+++
+++// MARK: - CustomStringConvertible
+++
+++extension Request: CustomStringConvertible {
+++
+++    /**
+++        The textual representation used when written to an output stream, which includes the HTTP method and URL, as 
+++        well as the response status code if a response has been received.
+++    */
+++    public var description: String {
+++        var components: [String] = []
+++
+++        if let HTTPMethod = request?.HTTPMethod {
+++            components.append(HTTPMethod)
+++        }
+++
+++        if let URLString = request?.URL?.absoluteString {
+++            components.append(URLString)
+++        }
+++
+++        if let response = response {
+++            components.append("(\(response.statusCode))")
+++        }
+++
+++        return components.joinWithSeparator(" ")
+++    }
+++}
+++
+++// MARK: - CustomDebugStringConvertible
+++
+++extension Request: CustomDebugStringConvertible {
+++    func cURLRepresentation() -> String {
+++        var components = ["$ curl -i"]
+++
+++        guard let
+++            request = self.request,
+++            URL = request.URL,
+++            host = URL.host
+++        else {
+++            return "$ curl command could not be created"
+++        }
+++
+++        if let HTTPMethod = request.HTTPMethod where HTTPMethod != "GET" {
+++            components.append("-X \(HTTPMethod)")
+++        }
+++
+++        if let credentialStorage = self.session.configuration.URLCredentialStorage {
+++            let protectionSpace = NSURLProtectionSpace(
+++                host: host,
+++                port: URL.port?.integerValue ?? 0,
+++                protocol: URL.scheme,
+++                realm: host,
+++                authenticationMethod: NSURLAuthenticationMethodHTTPBasic
+++            )
+++
+++            if let credentials = credentialStorage.credentialsForProtectionSpace(protectionSpace)?.values {
+++                for credential in credentials {
+++                    components.append("-u \(credential.user!):\(credential.password!)")
+++                }
+++            } else {
+++                if let credential = delegate.credential {
+++                    components.append("-u \(credential.user!):\(credential.password!)")
+++                }
+++            }
+++        }
+++
+++        if session.configuration.HTTPShouldSetCookies {
+++            if let
+++                cookieStorage = session.configuration.HTTPCookieStorage,
+++                cookies = cookieStorage.cookiesForURL(URL) where !cookies.isEmpty
+++            {
+++                let string = cookies.reduce("") { $0 + "\($1.name)=\($1.value ?? String());" }
+++                components.append("-b \"\(string.substringToIndex(string.endIndex.predecessor()))\"")
+++            }
+++        }
+++
+++        var headers: [NSObject: AnyObject] = [:]
+++
+++        if let additionalHeaders = session.configuration.HTTPAdditionalHeaders {
+++            for (field, value) in additionalHeaders where field != "Cookie" {
+++                headers[field] = value
+++            }
+++        }
+++
+++        if let headerFields = request.allHTTPHeaderFields {
+++            for (field, value) in headerFields where field != "Cookie" {
+++                headers[field] = value
+++            }
+++        }
+++
+++        for (field, value) in headers {
+++            components.append("-H \"\(field): \(value)\"")
+++        }
+++
+++        if let
+++            HTTPBodyData = request.HTTPBody,
+++            HTTPBody = String(data: HTTPBodyData, encoding: NSUTF8StringEncoding)
+++        {
+++            var escapedBody = HTTPBody.stringByReplacingOccurrencesOfString("\\\"", withString: "\\\\\"")
+++            escapedBody = escapedBody.stringByReplacingOccurrencesOfString("\"", withString: "\\\"")
+++
+++            components.append("-d \"\(escapedBody)\"")
+++        }
+++
+++        components.append("\"\(URL.absoluteString)\"")
+++
+++        return components.joinWithSeparator(" \\\n\t")
+++    }
+++
+++    /// The textual representation used when written to an output stream, in the form of a cURL command.
+++    public var debugDescription: String {
+++        return cURLRepresentation()
+++    }
+++}
++diff --git a/Pods/Alamofire/Source/Response.swift b/Pods/Alamofire/Source/Response.swift
++new file mode 100644
++index 0000000..dd700bb
++--- /dev/null
+++++ b/Pods/Alamofire/Source/Response.swift
++@@ -0,0 +1,97 @@
+++//
+++//  Response.swift
+++//
+++//  Copyright (c) 2014-2016 Alamofire Software Foundation (http://alamofire.org/)
+++//
+++//  Permission is hereby granted, free of charge, to any person obtaining a copy
+++//  of this software and associated documentation files (the "Software"), to deal
+++//  in the Software without restriction, including without limitation the rights
+++//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+++//  copies of the Software, and to permit persons to whom the Software is
+++//  furnished to do so, subject to the following conditions:
+++//
+++//  The above copyright notice and this permission notice shall be included in
+++//  all copies or substantial portions of the Software.
+++//
+++//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+++//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+++//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+++//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+++//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+++//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+++//  THE SOFTWARE.
+++//
+++
+++import Foundation
+++
+++/// Used to store all response data returned from a completed `Request`.
+++public struct Response<Value, Error: ErrorType> {
+++    /// The URL request sent to the server.
+++    public let request: NSURLRequest?
+++
+++    /// The server's response to the URL request.
+++    public let response: NSHTTPURLResponse?
+++
+++    /// The data returned by the server.
+++    public let data: NSData?
+++
+++    /// The result of response serialization.
+++    public let result: Result<Value, Error>
+++
+++    /// The timeline of the complete lifecycle of the `Request`.
+++    public let timeline: Timeline
+++
+++    /**
+++        Initializes the `Response` instance with the specified URL request, URL response, server data and response
+++        serialization result.
+++    
+++        - parameter request:  The URL request sent to the server.
+++        - parameter response: The server's response to the URL request.
+++        - parameter data:     The data returned by the server.
+++        - parameter result:   The result of response serialization.
+++        - parameter timeline: The timeline of the complete lifecycle of the `Request`. Defaults to `Timeline()`.
+++
+++        - returns: the new `Response` instance.
+++    */
+++    public init(
+++        request: NSURLRequest?,
+++        response: NSHTTPURLResponse?,
+++        data: NSData?,
+++        result: Result<Value, Error>,
+++        timeline: Timeline = Timeline())
+++    {
+++        self.request = request
+++        self.response = response
+++        self.data = data
+++        self.result = result
+++        self.timeline = timeline
+++    }
+++}
+++
+++// MARK: - CustomStringConvertible
+++
+++extension Response: CustomStringConvertible {
+++    /// The textual representation used when written to an output stream, which includes whether the result was a
+++    /// success or failure.
+++    public var description: String {
+++        return result.debugDescription
+++    }
+++}
+++
+++// MARK: - CustomDebugStringConvertible
+++
+++extension Response: CustomDebugStringConvertible {
+++    /// The debug textual representation used when written to an output stream, which includes the URL request, the URL
+++    /// response, the server data and the response serialization result.
+++    public var debugDescription: String {
+++        var output: [String] = []
+++
+++        output.append(request != nil ? "[Request]: \(request!)" : "[Request]: nil")
+++        output.append(response != nil ? "[Response]: \(response!)" : "[Response]: nil")
+++        output.append("[Data]: \(data?.length ?? 0) bytes")
+++        output.append("[Result]: \(result.debugDescription)")
+++        output.append("[Timeline]: \(timeline.debugDescription)")
+++
+++        return output.joinWithSeparator("\n")
+++    }
+++}
++diff --git a/Pods/Alamofire/Source/ResponseSerialization.swift b/Pods/Alamofire/Source/ResponseSerialization.swift
++new file mode 100644
++index 0000000..5b7b61f
++--- /dev/null
+++++ b/Pods/Alamofire/Source/ResponseSerialization.swift
++@@ -0,0 +1,378 @@
+++//
+++//  ResponseSerialization.swift
+++//
+++//  Copyright (c) 2014-2016 Alamofire Software Foundation (http://alamofire.org/)
+++//
+++//  Permission is hereby granted, free of charge, to any person obtaining a copy
+++//  of this software and associated documentation files (the "Software"), to deal
+++//  in the Software without restriction, including without limitation the rights
+++//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+++//  copies of the Software, and to permit persons to whom the Software is
+++//  furnished to do so, subject to the following conditions:
+++//
+++//  The above copyright notice and this permission notice shall be included in
+++//  all copies or substantial portions of the Software.
+++//
+++//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+++//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+++//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+++//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+++//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+++//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+++//  THE SOFTWARE.
+++//
+++
+++import Foundation
+++
+++// MARK: ResponseSerializer
+++
+++/**
+++    The type in which all response serializers must conform to in order to serialize a response.
+++*/
+++public protocol ResponseSerializerType {
+++    /// The type of serialized object to be created by this `ResponseSerializerType`.
+++    associatedtype SerializedObject
+++
+++    /// The type of error to be created by this `ResponseSerializer` if serialization fails.
+++    associatedtype ErrorObject: ErrorType
+++
+++    /**
+++        A closure used by response handlers that takes a request, response, data and error and returns a result.
+++    */
+++    var serializeResponse: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Result<SerializedObject, ErrorObject> { get }
+++}
+++
+++// MARK: -
+++
+++/**
+++    A generic `ResponseSerializerType` used to serialize a request, response, and data into a serialized object.
+++*/
+++public struct ResponseSerializer<Value, Error: ErrorType>: ResponseSerializerType {
+++    /// The type of serialized object to be created by this `ResponseSerializer`.
+++    public typealias SerializedObject = Value
+++
+++    /// The type of error to be created by this `ResponseSerializer` if serialization fails.
+++    public typealias ErrorObject = Error
+++
+++    /**
+++        A closure used by response handlers that takes a request, response, data and error and returns a result.
+++    */
+++    public var serializeResponse: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Result<Value, Error>
+++
+++    /**
+++        Initializes the `ResponseSerializer` instance with the given serialize response closure.
+++
+++        - parameter serializeResponse: The closure used to serialize the response.
+++
+++        - returns: The new generic response serializer instance.
+++    */
+++    public init(serializeResponse: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Result<Value, Error>) {
+++        self.serializeResponse = serializeResponse
+++    }
+++}
+++
+++// MARK: - Default
+++
+++extension Request {
+++
+++    /**
+++        Adds a handler to be called once the request has finished.
+++
+++        - parameter queue:             The queue on which the completion handler is dispatched.
+++        - parameter completionHandler: The code to be executed once the request has finished.
+++
+++        - returns: The request.
+++    */
+++    public func response(
+++        queue queue: dispatch_queue_t? = nil,
+++        completionHandler: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Void)
+++        -> Self
+++    {
+++        delegate.queue.addOperationWithBlock {
+++            dispatch_async(queue ?? dispatch_get_main_queue()) {
+++                completionHandler(self.request, self.response, self.delegate.data, self.delegate.error)
+++            }
+++        }
+++
+++        return self
+++    }
+++
+++    /**
+++        Adds a handler to be called once the request has finished.
+++
+++        - parameter queue:              The queue on which the completion handler is dispatched.
+++        - parameter responseSerializer: The response serializer responsible for serializing the request, response, 
+++                                        and data.
+++        - parameter completionHandler:  The code to be executed once the request has finished.
+++
+++        - returns: The request.
+++    */
+++    public func response<T: ResponseSerializerType>(
+++        queue queue: dispatch_queue_t? = nil,
+++        responseSerializer: T,
+++        completionHandler: Response<T.SerializedObject, T.ErrorObject> -> Void)
+++        -> Self
+++    {
+++        delegate.queue.addOperationWithBlock {
+++            let result = responseSerializer.serializeResponse(
+++                self.request,
+++                self.response,
+++                self.delegate.data,
+++                self.delegate.error
+++            )
+++
+++            let requestCompletedTime = self.endTime ?? CFAbsoluteTimeGetCurrent()
+++            let initialResponseTime = self.delegate.initialResponseTime ?? requestCompletedTime
+++
+++            let timeline = Timeline(
+++                requestStartTime: self.startTime ?? CFAbsoluteTimeGetCurrent(),
+++                initialResponseTime: initialResponseTime,
+++                requestCompletedTime: requestCompletedTime,
+++                serializationCompletedTime: CFAbsoluteTimeGetCurrent()
+++            )
+++
+++            let response = Response<T.SerializedObject, T.ErrorObject>(
+++                request: self.request,
+++                response: self.response,
+++                data: self.delegate.data,
+++                result: result,
+++                timeline: timeline
+++            )
+++
+++            dispatch_async(queue ?? dispatch_get_main_queue()) { completionHandler(response) }
+++        }
+++
+++        return self
+++    }
+++}
+++
+++// MARK: - Data
+++
+++extension Request {
+++
+++    /**
+++        Creates a response serializer that returns the associated data as-is.
+++
+++        - returns: A data response serializer.
+++    */
+++    public static func dataResponseSerializer() -> ResponseSerializer<NSData, NSError> {
+++        return ResponseSerializer { _, response, data, error in
+++            guard error == nil else { return .Failure(error!) }
+++
+++            if let response = response where response.statusCode == 204 { return .Success(NSData()) }
+++
+++            guard let validData = data else {
+++                let failureReason = "Data could not be serialized. Input data was nil."
+++                let error = Error.error(code: .DataSerializationFailed, failureReason: failureReason)
+++                return .Failure(error)
+++            }
+++
+++            return .Success(validData)
+++        }
+++    }
+++
+++    /**
+++        Adds a handler to be called once the request has finished.
+++
+++        - parameter completionHandler: The code to be executed once the request has finished.
+++
+++        - returns: The request.
+++    */
+++    public func responseData(
+++        queue queue: dispatch_queue_t? = nil,
+++        completionHandler: Response<NSData, NSError> -> Void)
+++        -> Self
+++    {
+++        return response(queue: queue, responseSerializer: Request.dataResponseSerializer(), completionHandler: completionHandler)
+++    }
+++}
+++
+++// MARK: - String
+++
+++extension Request {
+++
+++    /**
+++        Creates a response serializer that returns a string initialized from the response data with the specified 
+++        string encoding.
+++
+++        - parameter encoding: The string encoding. If `nil`, the string encoding will be determined from the server 
+++                              response, falling back to the default HTTP default character set, ISO-8859-1.
+++
+++        - returns: A string response serializer.
+++    */
+++    public static func stringResponseSerializer(
+++        encoding encoding: NSStringEncoding? = nil)
+++        -> ResponseSerializer<String, NSError>
+++    {
+++        return ResponseSerializer { _, response, data, error in
+++            guard error == nil else { return .Failure(error!) }
+++
+++            if let response = response where response.statusCode == 204 { return .Success("") }
+++
+++            guard let validData = data else {
+++                let failureReason = "String could not be serialized. Input data was nil."
+++                let error = Error.error(code: .StringSerializationFailed, failureReason: failureReason)
+++                return .Failure(error)
+++            }
+++            
+++            var convertedEncoding = encoding
+++            
+++            if let encodingName = response?.textEncodingName where convertedEncoding == nil {
+++                convertedEncoding = CFStringConvertEncodingToNSStringEncoding(
+++                    CFStringConvertIANACharSetNameToEncoding(encodingName)
+++                )
+++            }
+++
+++            let actualEncoding = convertedEncoding ?? NSISOLatin1StringEncoding
+++
+++            if let string = String(data: validData, encoding: actualEncoding) {
+++                return .Success(string)
+++            } else {
+++                let failureReason = "String could not be serialized with encoding: \(actualEncoding)"
+++                let error = Error.error(code: .StringSerializationFailed, failureReason: failureReason)
+++                return .Failure(error)
+++            }
+++        }
+++    }
+++
+++    /**
+++        Adds a handler to be called once the request has finished.
+++
+++        - parameter encoding:          The string encoding. If `nil`, the string encoding will be determined from the 
+++                                       server response, falling back to the default HTTP default character set, 
+++                                       ISO-8859-1.
+++        - parameter completionHandler: A closure to be executed once the request has finished.
+++
+++        - returns: The request.
+++    */
+++    public func responseString(
+++        queue queue: dispatch_queue_t? = nil,
+++        encoding: NSStringEncoding? = nil,
+++        completionHandler: Response<String, NSError> -> Void)
+++        -> Self
+++    {
+++        return response(
+++            queue: queue,
+++            responseSerializer: Request.stringResponseSerializer(encoding: encoding),
+++            completionHandler: completionHandler
+++        )
+++    }
+++}
+++
+++// MARK: - JSON
+++
+++extension Request {
+++
+++    /**
+++        Creates a response serializer that returns a JSON object constructed from the response data using 
+++        `NSJSONSerialization` with the specified reading options.
+++
+++        - parameter options: The JSON serialization reading options. `.AllowFragments` by default.
+++
+++        - returns: A JSON object response serializer.
+++    */
+++    public static func JSONResponseSerializer(
+++        options options: NSJSONReadingOptions = .AllowFragments)
+++        -> ResponseSerializer<AnyObject, NSError>
+++    {
+++        return ResponseSerializer { _, response, data, error in
+++            guard error == nil else { return .Failure(error!) }
+++
+++            if let response = response where response.statusCode == 204 { return .Success(NSNull()) }
+++
+++            guard let validData = data where validData.length > 0 else {
+++                let failureReason = "JSON could not be serialized. Input data was nil or zero length."
+++                let error = Error.error(code: .JSONSerializationFailed, failureReason: failureReason)
+++                return .Failure(error)
+++            }
+++
+++            do {
+++                let JSON = try NSJSONSerialization.JSONObjectWithData(validData, options: options)
+++                return .Success(JSON)
+++            } catch {
+++                return .Failure(error as NSError)
+++            }
+++        }
+++    }
+++
+++    /**
+++        Adds a handler to be called once the request has finished.
+++
+++        - parameter options:           The JSON serialization reading options. `.AllowFragments` by default.
+++        - parameter completionHandler: A closure to be executed once the request has finished.
+++
+++        - returns: The request.
+++    */
+++    public func responseJSON(
+++        queue queue: dispatch_queue_t? = nil,
+++        options: NSJSONReadingOptions = .AllowFragments,
+++        completionHandler: Response<AnyObject, NSError> -> Void)
+++        -> Self
+++    {
+++        return response(
+++            queue: queue,
+++            responseSerializer: Request.JSONResponseSerializer(options: options),
+++            completionHandler: completionHandler
+++        )
+++    }
+++}
+++
+++// MARK: - Property List
+++
+++extension Request {
+++
+++    /**
+++        Creates a response serializer that returns an object constructed from the response data using 
+++        `NSPropertyListSerialization` with the specified reading options.
+++
+++        - parameter options: The property list reading options. `NSPropertyListReadOptions()` by default.
+++
+++        - returns: A property list object response serializer.
+++    */
+++    public static func propertyListResponseSerializer(
+++        options options: NSPropertyListReadOptions = NSPropertyListReadOptions())
+++        -> ResponseSerializer<AnyObject, NSError>
+++    {
+++        return ResponseSerializer { _, response, data, error in
+++            guard error == nil else { return .Failure(error!) }
+++
+++            if let response = response where response.statusCode == 204 { return .Success(NSNull()) }
+++
+++            guard let validData = data where validData.length > 0 else {
+++                let failureReason = "Property list could not be serialized. Input data was nil or zero length."
+++                let error = Error.error(code: .PropertyListSerializationFailed, failureReason: failureReason)
+++                return .Failure(error)
+++            }
+++
+++            do {
+++                let plist = try NSPropertyListSerialization.propertyListWithData(validData, options: options, format: nil)
+++                return .Success(plist)
+++            } catch {
+++                return .Failure(error as NSError)
+++            }
+++        }
+++    }
+++
+++    /**
+++        Adds a handler to be called once the request has finished.
+++
+++        - parameter options:           The property list reading options. `0` by default.
+++        - parameter completionHandler: A closure to be executed once the request has finished. The closure takes 3
+++                                       arguments: the URL request, the URL response, the server data and the result 
+++                                       produced while creating the property list.
+++
+++        - returns: The request.
+++    */
+++    public func responsePropertyList(
+++        queue queue: dispatch_queue_t? = nil,
+++        options: NSPropertyListReadOptions = NSPropertyListReadOptions(),
+++        completionHandler: Response<AnyObject, NSError> -> Void)
+++        -> Self
+++    {
+++        return response(
+++            queue: queue,
+++            responseSerializer: Request.propertyListResponseSerializer(options: options),
+++            completionHandler: completionHandler
+++        )
+++    }
+++}
++diff --git a/Pods/Alamofire/Source/Result.swift b/Pods/Alamofire/Source/Result.swift
++new file mode 100644
++index 0000000..ed1df0f
++--- /dev/null
+++++ b/Pods/Alamofire/Source/Result.swift
++@@ -0,0 +1,103 @@
+++//
+++//  Result.swift
+++//
+++//  Copyright (c) 2014-2016 Alamofire Software Foundation (http://alamofire.org/)
+++//
+++//  Permission is hereby granted, free of charge, to any person obtaining a copy
+++//  of this software and associated documentation files (the "Software"), to deal
+++//  in the Software without restriction, including without limitation the rights
+++//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+++//  copies of the Software, and to permit persons to whom the Software is
+++//  furnished to do so, subject to the following conditions:
+++//
+++//  The above copyright notice and this permission notice shall be included in
+++//  all copies or substantial portions of the Software.
+++//
+++//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+++//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+++//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+++//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+++//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+++//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+++//  THE SOFTWARE.
+++//
+++
+++import Foundation
+++
+++/**
+++    Used to represent whether a request was successful or encountered an error.
+++
+++    - Success: The request and all post processing operations were successful resulting in the serialization of the 
+++               provided associated value.
+++    - Failure: The request encountered an error resulting in a failure. The associated values are the original data 
+++               provided by the server as well as the error that caused the failure.
+++*/
+++public enum Result<Value, Error: ErrorType> {
+++    case Success(Value)
+++    case Failure(Error)
+++
+++    /// Returns `true` if the result is a success, `false` otherwise.
+++    public var isSuccess: Bool {
+++        switch self {
+++        case .Success:
+++            return true
+++        case .Failure:
+++            return false
+++        }
+++    }
+++
+++    /// Returns `true` if the result is a failure, `false` otherwise.
+++    public var isFailure: Bool {
+++        return !isSuccess
+++    }
+++
+++    /// Returns the associated value if the result is a success, `nil` otherwise.
+++    public var value: Value? {
+++        switch self {
+++        case .Success(let value):
+++            return value
+++        case .Failure:
+++            return nil
+++        }
+++    }
+++
+++    /// Returns the associated error value if the result is a failure, `nil` otherwise.
+++    public var error: Error? {
+++        switch self {
+++        case .Success:
+++            return nil
+++        case .Failure(let error):
+++            return error
+++        }
+++    }
+++}
+++
+++// MARK: - CustomStringConvertible
+++
+++extension Result: CustomStringConvertible {
+++    /// The textual representation used when written to an output stream, which includes whether the result was a 
+++    /// success or failure.
+++    public var description: String {
+++        switch self {
+++        case .Success:
+++            return "SUCCESS"
+++        case .Failure:
+++            return "FAILURE"
+++        }
+++    }
+++}
+++
+++// MARK: - CustomDebugStringConvertible
+++
+++extension Result: CustomDebugStringConvertible {
+++    /// The debug textual representation used when written to an output stream, which includes whether the result was a
+++    /// success or failure in addition to the value or error.
+++    public var debugDescription: String {
+++        switch self {
+++        case .Success(let value):
+++            return "SUCCESS: \(value)"
+++        case .Failure(let error):
+++            return "FAILURE: \(error)"
+++        }
+++    }
+++}
++diff --git a/Pods/Alamofire/Source/ServerTrustPolicy.swift b/Pods/Alamofire/Source/ServerTrustPolicy.swift
++new file mode 100644
++index 0000000..44ba100
++--- /dev/null
+++++ b/Pods/Alamofire/Source/ServerTrustPolicy.swift
++@@ -0,0 +1,304 @@
+++//
+++//  ServerTrustPolicy.swift
+++//
+++//  Copyright (c) 2014-2016 Alamofire Software Foundation (http://alamofire.org/)
+++//
+++//  Permission is hereby granted, free of charge, to any person obtaining a copy
+++//  of this software and associated documentation files (the "Software"), to deal
+++//  in the Software without restriction, including without limitation the rights
+++//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+++//  copies of the Software, and to permit persons to whom the Software is
+++//  furnished to do so, subject to the following conditions:
+++//
+++//  The above copyright notice and this permission notice shall be included in
+++//  all copies or substantial portions of the Software.
+++//
+++//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+++//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+++//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+++//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+++//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+++//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+++//  THE SOFTWARE.
+++//
+++
+++import Foundation
+++
+++/// Responsible for managing the mapping of `ServerTrustPolicy` objects to a given host.
+++public class ServerTrustPolicyManager {
+++    /// The dictionary of policies mapped to a particular host.
+++    public let policies: [String: ServerTrustPolicy]
+++
+++    /**
+++        Initializes the `ServerTrustPolicyManager` instance with the given policies.
+++
+++        Since different servers and web services can have different leaf certificates, intermediate and even root 
+++        certficates, it is important to have the flexibility to specify evaluation policies on a per host basis. This 
+++        allows for scenarios such as using default evaluation for host1, certificate pinning for host2, public key 
+++        pinning for host3 and disabling evaluation for host4.
+++
+++        - parameter policies: A dictionary of all policies mapped to a particular host.
+++
+++        - returns: The new `ServerTrustPolicyManager` instance.
+++    */
+++    public init(policies: [String: ServerTrustPolicy]) {
+++        self.policies = policies
+++    }
+++
+++    /**
+++        Returns the `ServerTrustPolicy` for the given host if applicable.
+++
+++        By default, this method will return the policy that perfectly matches the given host. Subclasses could override
+++        this method and implement more complex mapping implementations such as wildcards.
+++
+++        - parameter host: The host to use when searching for a matching policy.
+++
+++        - returns: The server trust policy for the given host if found.
+++    */
+++    public func serverTrustPolicyForHost(host: String) -> ServerTrustPolicy? {
+++        return policies[host]
+++    }
+++}
+++
+++// MARK: -
+++
+++extension NSURLSession {
+++    private struct AssociatedKeys {
+++        static var ManagerKey = "NSURLSession.ServerTrustPolicyManager"
+++    }
+++
+++    var serverTrustPolicyManager: ServerTrustPolicyManager? {
+++        get {
+++            return objc_getAssociatedObject(self, &AssociatedKeys.ManagerKey) as? ServerTrustPolicyManager
+++        }
+++        set (manager) {
+++            objc_setAssociatedObject(self, &AssociatedKeys.ManagerKey, manager, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
+++        }
+++    }
+++}
+++
+++// MARK: - ServerTrustPolicy
+++
+++/**
+++    The `ServerTrustPolicy` evaluates the server trust generally provided by an `NSURLAuthenticationChallenge` when 
+++    connecting to a server over a secure HTTPS connection. The policy configuration then evaluates the server trust 
+++    with a given set of criteria to determine whether the server trust is valid and the connection should be made.
+++
+++    Using pinned certificates or public keys for evaluation helps prevent man-in-the-middle (MITM) attacks and other 
+++    vulnerabilities. Applications dealing with sensitive customer data or financial information are strongly encouraged 
+++    to route all communication over an HTTPS connection with pinning enabled.
+++
+++    - PerformDefaultEvaluation: Uses the default server trust evaluation while allowing you to control whether to 
+++                                validate the host provided by the challenge. Applications are encouraged to always 
+++                                validate the host in production environments to guarantee the validity of the server's 
+++                                certificate chain.
+++
+++    - PinCertificates:          Uses the pinned certificates to validate the server trust. The server trust is
+++                                considered valid if one of the pinned certificates match one of the server certificates. 
+++                                By validating both the certificate chain and host, certificate pinning provides a very 
+++                                secure form of server trust validation mitigating most, if not all, MITM attacks. 
+++                                Applications are encouraged to always validate the host and require a valid certificate 
+++                                chain in production environments.
+++
+++    - PinPublicKeys:            Uses the pinned public keys to validate the server trust. The server trust is considered
+++                                valid if one of the pinned public keys match one of the server certificate public keys. 
+++                                By validating both the certificate chain and host, public key pinning provides a very 
+++                                secure form of server trust validation mitigating most, if not all, MITM attacks. 
+++                                Applications are encouraged to always validate the host and require a valid certificate 
+++                                chain in production environments.
+++
+++    - DisableEvaluation:        Disables all evaluation which in turn will always consider any server trust as valid.
+++
+++    - CustomEvaluation:         Uses the associated closure to evaluate the validity of the server trust.
+++*/
+++public enum ServerTrustPolicy {
+++    case PerformDefaultEvaluation(validateHost: Bool)
+++    case PinCertificates(certificates: [SecCertificate], validateCertificateChain: Bool, validateHost: Bool)
+++    case PinPublicKeys(publicKeys: [SecKey], validateCertificateChain: Bool, validateHost: Bool)
+++    case DisableEvaluation
+++    case CustomEvaluation((serverTrust: SecTrust, host: String) -> Bool)
+++
+++    // MARK: - Bundle Location
+++
+++    /**
+++        Returns all certificates within the given bundle with a `.cer` file extension.
+++
+++        - parameter bundle: The bundle to search for all `.cer` files.
+++
+++        - returns: All certificates within the given bundle.
+++    */
+++    public static func certificatesInBundle(bundle: NSBundle = NSBundle.mainBundle()) -> [SecCertificate] {
+++        var certificates: [SecCertificate] = []
+++
+++        let paths = Set([".cer", ".CER", ".crt", ".CRT", ".der", ".DER"].map { fileExtension in
+++            bundle.pathsForResourcesOfType(fileExtension, inDirectory: nil)
+++        }.flatten())
+++
+++        for path in paths {
+++            if let
+++                certificateData = NSData(contentsOfFile: path),
+++                certificate = SecCertificateCreateWithData(nil, certificateData)
+++            {
+++                certificates.append(certificate)
+++            }
+++        }
+++
+++        return certificates
+++    }
+++
+++    /**
+++        Returns all public keys within the given bundle with a `.cer` file extension.
+++
+++        - parameter bundle: The bundle to search for all `*.cer` files.
+++
+++        - returns: All public keys within the given bundle.
+++    */
+++    public static func publicKeysInBundle(bundle: NSBundle = NSBundle.mainBundle()) -> [SecKey] {
+++        var publicKeys: [SecKey] = []
+++
+++        for certificate in certificatesInBundle(bundle) {
+++            if let publicKey = publicKeyForCertificate(certificate) {
+++                publicKeys.append(publicKey)
+++            }
+++        }
+++
+++        return publicKeys
+++    }
+++
+++    // MARK: - Evaluation
+++
+++    /**
+++        Evaluates whether the server trust is valid for the given host.
+++
+++        - parameter serverTrust: The server trust to evaluate.
+++        - parameter host:        The host of the challenge protection space.
+++
+++        - returns: Whether the server trust is valid.
+++    */
+++    public func evaluateServerTrust(serverTrust: SecTrust, isValidForHost host: String) -> Bool {
+++        var serverTrustIsValid = false
+++
+++        switch self {
+++        case let .PerformDefaultEvaluation(validateHost):
+++            let policy = SecPolicyCreateSSL(true, validateHost ? host as CFString : nil)
+++            SecTrustSetPolicies(serverTrust, [policy])
+++
+++            serverTrustIsValid = trustIsValid(serverTrust)
+++        case let .PinCertificates(pinnedCertificates, validateCertificateChain, validateHost):
+++            if validateCertificateChain {
+++                let policy = SecPolicyCreateSSL(true, validateHost ? host as CFString : nil)
+++                SecTrustSetPolicies(serverTrust, [policy])
+++
+++                SecTrustSetAnchorCertificates(serverTrust, pinnedCertificates)
+++                SecTrustSetAnchorCertificatesOnly(serverTrust, true)
+++
+++                serverTrustIsValid = trustIsValid(serverTrust)
+++            } else {
+++                let serverCertificatesDataArray = certificateDataForTrust(serverTrust)
+++                let pinnedCertificatesDataArray = certificateDataForCertificates(pinnedCertificates)
+++
+++                outerLoop: for serverCertificateData in serverCertificatesDataArray {
+++                    for pinnedCertificateData in pinnedCertificatesDataArray {
+++                        if serverCertificateData.isEqualToData(pinnedCertificateData) {
+++                            serverTrustIsValid = true
+++                            break outerLoop
+++                        }
+++                    }
+++                }
+++            }
+++        case let .PinPublicKeys(pinnedPublicKeys, validateCertificateChain, validateHost):
+++            var certificateChainEvaluationPassed = true
+++
+++            if validateCertificateChain {
+++                let policy = SecPolicyCreateSSL(true, validateHost ? host as CFString : nil)
+++                SecTrustSetPolicies(serverTrust, [policy])
+++
+++                certificateChainEvaluationPassed = trustIsValid(serverTrust)
+++            }
+++
+++            if certificateChainEvaluationPassed {
+++                outerLoop: for serverPublicKey in ServerTrustPolicy.publicKeysForTrust(serverTrust) as [AnyObject] {
+++                    for pinnedPublicKey in pinnedPublicKeys as [AnyObject] {
+++                        if serverPublicKey.isEqual(pinnedPublicKey) {
+++                            serverTrustIsValid = true
+++                            break outerLoop
+++                        }
+++                    }
+++                }
+++            }
+++        case .DisableEvaluation:
+++            serverTrustIsValid = true
+++        case let .CustomEvaluation(closure):
+++            serverTrustIsValid = closure(serverTrust: serverTrust, host: host)
+++        }
+++
+++        return serverTrustIsValid
+++    }
+++
+++    // MARK: - Private - Trust Validation
+++
+++    private func trustIsValid(trust: SecTrust) -> Bool {
+++        var isValid = false
+++
+++        var result = SecTrustResultType(kSecTrustResultInvalid)
+++        let status = SecTrustEvaluate(trust, &result)
+++
+++        if status == errSecSuccess {
+++            let unspecified = SecTrustResultType(kSecTrustResultUnspecified)
+++            let proceed = SecTrustResultType(kSecTrustResultProceed)
+++
+++            isValid = result == unspecified || result == proceed
+++        }
+++
+++        return isValid
+++    }
+++
+++    // MARK: - Private - Certificate Data
+++
+++    private func certificateDataForTrust(trust: SecTrust) -> [NSData] {
+++        var certificates: [SecCertificate] = []
+++
+++        for index in 0..<SecTrustGetCertificateCount(trust) {
+++            if let certificate = SecTrustGetCertificateAtIndex(trust, index) {
+++                certificates.append(certificate)
+++            }
+++        }
+++
+++        return certificateDataForCertificates(certificates)
+++    }
+++
+++    private func certificateDataForCertificates(certificates: [SecCertificate]) -> [NSData] {
+++        return certificates.map { SecCertificateCopyData($0) as NSData }
+++    }
+++
+++    // MARK: - Private - Public Key Extraction
+++
+++    private static func publicKeysForTrust(trust: SecTrust) -> [SecKey] {
+++        var publicKeys: [SecKey] = []
+++
+++        for index in 0..<SecTrustGetCertificateCount(trust) {
+++            if let
+++                certificate = SecTrustGetCertificateAtIndex(trust, index),
+++                publicKey = publicKeyForCertificate(certificate)
+++            {
+++                publicKeys.append(publicKey)
+++            }
+++        }
+++
+++        return publicKeys
+++    }
+++
+++    private static func publicKeyForCertificate(certificate: SecCertificate) -> SecKey? {
+++        var publicKey: SecKey?
+++
+++        let policy = SecPolicyCreateBasicX509()
+++        var trust: SecTrust?
+++        let trustCreationStatus = SecTrustCreateWithCertificates(certificate, policy, &trust)
+++
+++        if let trust = trust where trustCreationStatus == errSecSuccess {
+++            publicKey = SecTrustCopyPublicKey(trust)
+++        }
+++
+++        return publicKey
+++    }
+++}
++diff --git a/Pods/Alamofire/Source/Stream.swift b/Pods/Alamofire/Source/Stream.swift
++new file mode 100644
++index 0000000..07ebe33
++--- /dev/null
+++++ b/Pods/Alamofire/Source/Stream.swift
++@@ -0,0 +1,182 @@
+++//
+++//  Stream.swift
+++//
+++//  Copyright (c) 2014-2016 Alamofire Software Foundation (http://alamofire.org/)
+++//
+++//  Permission is hereby granted, free of charge, to any person obtaining a copy
+++//  of this software and associated documentation files (the "Software"), to deal
+++//  in the Software without restriction, including without limitation the rights
+++//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+++//  copies of the Software, and to permit persons to whom the Software is
+++//  furnished to do so, subject to the following conditions:
+++//
+++//  The above copyright notice and this permission notice shall be included in
+++//  all copies or substantial portions of the Software.
+++//
+++//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+++//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+++//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+++//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+++//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+++//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+++//  THE SOFTWARE.
+++//
+++
+++import Foundation
+++
+++#if !os(watchOS)
+++
+++@available(iOS 9.0, OSX 10.11, tvOS 9.0, *)
+++extension Manager {
+++    private enum Streamable {
+++        case Stream(String, Int)
+++        case NetService(NSNetService)
+++    }
+++
+++    private func stream(streamable: Streamable) -> Request {
+++        var streamTask: NSURLSessionStreamTask!
+++
+++        switch streamable {
+++        case .Stream(let hostName, let port):
+++            dispatch_sync(queue) {
+++                streamTask = self.session.streamTaskWithHostName(hostName, port: port)
+++            }
+++        case .NetService(let netService):
+++            dispatch_sync(queue) {
+++                streamTask = self.session.streamTaskWithNetService(netService)
+++            }
+++        }
+++
+++        let request = Request(session: session, task: streamTask)
+++
+++        delegate[request.delegate.task] = request.delegate
+++
+++        if startRequestsImmediately {
+++            request.resume()
+++        }
+++
+++        return request
+++    }
+++
+++    /**
+++        Creates a request for bidirectional streaming with the given hostname and port.
+++
+++        - parameter hostName: The hostname of the server to connect to.
+++        - parameter port:     The port of the server to connect to.
+++
+++        :returns: The created stream request.
+++    */
+++    public func stream(hostName hostName: String, port: Int) -> Request {
+++        return stream(.Stream(hostName, port))
+++    }
+++
+++    /**
+++        Creates a request for bidirectional streaming with the given `NSNetService`.
+++
+++        - parameter netService: The net service used to identify the endpoint.
+++
+++        - returns: The created stream request.
+++    */
+++    public func stream(netService netService: NSNetService) -> Request {
+++        return stream(.NetService(netService))
+++    }
+++}
+++
+++// MARK: -
+++
+++@available(iOS 9.0, OSX 10.11, tvOS 9.0, *)
+++extension Manager.SessionDelegate: NSURLSessionStreamDelegate {
+++
+++    // MARK: Override Closures
+++
+++    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:readClosedForStreamTask:`.
+++    public var streamTaskReadClosed: ((NSURLSession, NSURLSessionStreamTask) -> Void)? {
+++        get {
+++            return _streamTaskReadClosed as? (NSURLSession, NSURLSessionStreamTask) -> Void
+++        }
+++        set {
+++            _streamTaskReadClosed = newValue
+++        }
+++    }
+++
+++    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:writeClosedForStreamTask:`.
+++    public var streamTaskWriteClosed: ((NSURLSession, NSURLSessionStreamTask) -> Void)? {
+++        get {
+++            return _streamTaskWriteClosed as? (NSURLSession, NSURLSessionStreamTask) -> Void
+++        }
+++        set {
+++            _streamTaskWriteClosed = newValue
+++        }
+++    }
+++
+++    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:betterRouteDiscoveredForStreamTask:`.
+++    public var streamTaskBetterRouteDiscovered: ((NSURLSession, NSURLSessionStreamTask) -> Void)? {
+++        get {
+++            return _streamTaskBetterRouteDiscovered as? (NSURLSession, NSURLSessionStreamTask) -> Void
+++        }
+++        set {
+++            _streamTaskBetterRouteDiscovered = newValue
+++        }
+++    }
+++
+++    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:streamTask:didBecomeInputStream:outputStream:`.
+++    public var streamTaskDidBecomeInputStream: ((NSURLSession, NSURLSessionStreamTask, NSInputStream, NSOutputStream) -> Void)? {
+++        get {
+++            return _streamTaskDidBecomeInputStream as? (NSURLSession, NSURLSessionStreamTask, NSInputStream, NSOutputStream) -> Void
+++        }
+++        set {
+++            _streamTaskDidBecomeInputStream = newValue
+++        }
+++    }
+++
+++    // MARK: Delegate Methods
+++
+++    /**
+++        Tells the delegate that the read side of the connection has been closed.
+++
+++        - parameter session:    The session.
+++        - parameter streamTask: The stream task.
+++    */
+++    public func URLSession(session: NSURLSession, readClosedForStreamTask streamTask: NSURLSessionStreamTask) {
+++        streamTaskReadClosed?(session, streamTask)
+++    }
+++
+++    /**
+++        Tells the delegate that the write side of the connection has been closed.
+++
+++        - parameter session:    The session.
+++        - parameter streamTask: The stream task.
+++    */
+++    public func URLSession(session: NSURLSession, writeClosedForStreamTask streamTask: NSURLSessionStreamTask) {
+++        streamTaskWriteClosed?(session, streamTask)
+++    }
+++
+++    /**
+++        Tells the delegate that the system has determined that a better route to the host is available.
+++
+++        - parameter session:    The session.
+++        - parameter streamTask: The stream task.
+++    */
+++    public func URLSession(session: NSURLSession, betterRouteDiscoveredForStreamTask streamTask: NSURLSessionStreamTask) {
+++        streamTaskBetterRouteDiscovered?(session, streamTask)
+++    }
+++
+++    /**
+++        Tells the delegate that the stream task has been completed and provides the unopened stream objects.
+++
+++        - parameter session:      The session.
+++        - parameter streamTask:   The stream task.
+++        - parameter inputStream:  The new input stream.
+++        - parameter outputStream: The new output stream.
+++    */
+++    public func URLSession(
+++        session: NSURLSession,
+++        streamTask: NSURLSessionStreamTask,
+++        didBecomeInputStream inputStream: NSInputStream,
+++        outputStream: NSOutputStream)
+++    {
+++        streamTaskDidBecomeInputStream?(session, streamTask, inputStream, outputStream)
+++    }
+++}
+++
+++#endif
++diff --git a/Pods/Alamofire/Source/Timeline.swift b/Pods/Alamofire/Source/Timeline.swift
++new file mode 100644
++index 0000000..9593682
++--- /dev/null
+++++ b/Pods/Alamofire/Source/Timeline.swift
++@@ -0,0 +1,138 @@
+++//
+++//  Timeline.swift
+++//
+++//  Copyright (c) 2014-2016 Alamofire Software Foundation (http://alamofire.org/)
+++//
+++//  Permission is hereby granted, free of charge, to any person obtaining a copy
+++//  of this software and associated documentation files (the "Software"), to deal
+++//  in the Software without restriction, including without limitation the rights
+++//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+++//  copies of the Software, and to permit persons to whom the Software is
+++//  furnished to do so, subject to the following conditions:
+++//
+++//  The above copyright notice and this permission notice shall be included in
+++//  all copies or substantial portions of the Software.
+++//
+++//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+++//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+++//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+++//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+++//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+++//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+++//  THE SOFTWARE.
+++//
+++
+++import Foundation
+++
+++/// Responsible for computing the timing metrics for the complete lifecycle of a `Request`.
+++public struct Timeline {
+++    /// The time the request was initialized.
+++    public let requestStartTime: CFAbsoluteTime
+++
+++    /// The time the first bytes were received from or sent to the server.
+++    public let initialResponseTime: CFAbsoluteTime
+++
+++    /// The time when the request was completed.
+++    public let requestCompletedTime: CFAbsoluteTime
+++
+++    /// The time when the response serialization was completed.
+++    public let serializationCompletedTime: CFAbsoluteTime
+++
+++    /// The time interval in seconds from the time the request started to the initial response from the server.
+++    public let latency: NSTimeInterval
+++
+++    /// The time interval in seconds from the time the request started to the time the request completed.
+++    public let requestDuration: NSTimeInterval
+++
+++    /// The time interval in seconds from the time the request completed to the time response serialization completed.
+++    public let serializationDuration: NSTimeInterval
+++
+++    /// The time interval in seconds from the time the request started to the time response serialization completed.
+++    public let totalDuration: NSTimeInterval
+++
+++    /**
+++        Creates a new `Timeline` instance with the specified request times.
+++
+++        - parameter requestStartTime:           The time the request was initialized. Defaults to `0.0`.
+++        - parameter initialResponseTime:        The time the first bytes were received from or sent to the server. 
+++                                                Defaults to `0.0`.
+++        - parameter requestCompletedTime:       The time when the request was completed. Defaults to `0.0`.
+++        - parameter serializationCompletedTime: The time when the response serialization was completed. Defaults 
+++                                                to `0.0`.
+++
+++        - returns: The new `Timeline` instance.
+++    */
+++    public init(
+++        requestStartTime: CFAbsoluteTime = 0.0,
+++        initialResponseTime: CFAbsoluteTime = 0.0,
+++        requestCompletedTime: CFAbsoluteTime = 0.0,
+++        serializationCompletedTime: CFAbsoluteTime = 0.0)
+++    {
+++        self.requestStartTime = requestStartTime
+++        self.initialResponseTime = initialResponseTime
+++        self.requestCompletedTime = requestCompletedTime
+++        self.serializationCompletedTime = serializationCompletedTime
+++
+++        self.latency = initialResponseTime - requestStartTime
+++        self.requestDuration = requestCompletedTime - requestStartTime
+++        self.serializationDuration = serializationCompletedTime - requestCompletedTime
+++        self.totalDuration = serializationCompletedTime - requestStartTime
+++    }
+++}
+++
+++// MARK: - CustomStringConvertible
+++
+++extension Timeline: CustomStringConvertible {
+++    /// The textual representation used when written to an output stream, which includes the latency, the request 
+++    /// duration and the total duration.
+++    public var description: String {
+++        let latency = String(format: "%.3f", self.latency)
+++        let requestDuration = String(format: "%.3f", self.requestDuration)
+++        let serializationDuration = String(format: "%.3f", self.serializationDuration)
+++        let totalDuration = String(format: "%.3f", self.totalDuration)
+++
+++        // NOTE: Had to move to string concatenation due to memory leak filed as rdar://26761490. Once memory leak is
+++        // fixed, we should move back to string interpolation by reverting commit 7d4a43b1.
+++        let timings = [
+++            "\"Latency\": " + latency + " secs",
+++            "\"Request Duration\": " + requestDuration + " secs",
+++            "\"Serialization Duration\": " + serializationDuration + " secs",
+++            "\"Total Duration\": " + totalDuration + " secs"
+++        ]
+++
+++        return "Timeline: { " + timings.joinWithSeparator(", ") + " }"
+++    }
+++}
+++
+++// MARK: - CustomDebugStringConvertible
+++
+++extension Timeline: CustomDebugStringConvertible {
+++    /// The textual representation used when written to an output stream, which includes the request start time, the 
+++    /// initial response time, the request completed time, the serialization completed time, the latency, the request
+++    /// duration and the total duration.
+++    public var debugDescription: String {
+++        let requestStartTime = String(format: "%.3f", self.requestStartTime)
+++        let initialResponseTime = String(format: "%.3f", self.initialResponseTime)
+++        let requestCompletedTime = String(format: "%.3f", self.requestCompletedTime)
+++        let serializationCompletedTime = String(format: "%.3f", self.serializationCompletedTime)
+++        let latency = String(format: "%.3f", self.latency)
+++        let requestDuration = String(format: "%.3f", self.requestDuration)
+++        let serializationDuration = String(format: "%.3f", self.serializationDuration)
+++        let totalDuration = String(format: "%.3f", self.totalDuration)
+++
+++        // NOTE: Had to move to string concatenation due to memory leak filed as rdar://26761490. Once memory leak is
+++        // fixed, we should move back to string interpolation by reverting commit 7d4a43b1.
+++        let timings = [
+++            "\"Request Start Time\": " + requestStartTime,
+++            "\"Initial Response Time\": " + initialResponseTime,
+++            "\"Request Completed Time\": " + requestCompletedTime,
+++            "\"Serialization Completed Time\": " + serializationCompletedTime,
+++            "\"Latency\": " + latency + " secs",
+++            "\"Request Duration\": " + requestDuration + " secs",
+++            "\"Serialization Duration\": " + serializationDuration + " secs",
+++            "\"Total Duration\": " + totalDuration + " secs"
+++        ]
+++
+++        return "Timeline: { " + timings.joinWithSeparator(", ") + " }"
+++    }
+++}
++diff --git a/Pods/Alamofire/Source/Upload.swift b/Pods/Alamofire/Source/Upload.swift
++new file mode 100644
++index 0000000..7b31ba5
++--- /dev/null
+++++ b/Pods/Alamofire/Source/Upload.swift
++@@ -0,0 +1,376 @@
+++//
+++//  Upload.swift
+++//
+++//  Copyright (c) 2014-2016 Alamofire Software Foundation (http://alamofire.org/)
+++//
+++//  Permission is hereby granted, free of charge, to any person obtaining a copy
+++//  of this software and associated documentation files (the "Software"), to deal
+++//  in the Software without restriction, including without limitation the rights
+++//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+++//  copies of the Software, and to permit persons to whom the Software is
+++//  furnished to do so, subject to the following conditions:
+++//
+++//  The above copyright notice and this permission notice shall be included in
+++//  all copies or substantial portions of the Software.
+++//
+++//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+++//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+++//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+++//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+++//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+++//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+++//  THE SOFTWARE.
+++//
+++
+++import Foundation
+++
+++extension Manager {
+++    private enum Uploadable {
+++        case Data(NSURLRequest, NSData)
+++        case File(NSURLRequest, NSURL)
+++        case Stream(NSURLRequest, NSInputStream)
+++    }
+++
+++    private func upload(uploadable: Uploadable) -> Request {
+++        var uploadTask: NSURLSessionUploadTask!
+++        var HTTPBodyStream: NSInputStream?
+++
+++        switch uploadable {
+++        case .Data(let request, let data):
+++            dispatch_sync(queue) {
+++                uploadTask = self.session.uploadTaskWithRequest(request, fromData: data)
+++            }
+++        case .File(let request, let fileURL):
+++            dispatch_sync(queue) {
+++                uploadTask = self.session.uploadTaskWithRequest(request, fromFile: fileURL)
+++            }
+++        case .Stream(let request, let stream):
+++            dispatch_sync(queue) {
+++                uploadTask = self.session.uploadTaskWithStreamedRequest(request)
+++            }
+++
+++            HTTPBodyStream = stream
+++        }
+++
+++        let request = Request(session: session, task: uploadTask)
+++
+++        if HTTPBodyStream != nil {
+++            request.delegate.taskNeedNewBodyStream = { _, _ in
+++                return HTTPBodyStream
+++            }
+++        }
+++
+++        delegate[request.delegate.task] = request.delegate
+++
+++        if startRequestsImmediately {
+++            request.resume()
+++        }
+++
+++        return request
+++    }
+++
+++    // MARK: File
+++
+++    /**
+++        Creates a request for uploading a file to the specified URL request.
+++
+++        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
+++
+++        - parameter URLRequest: The URL request
+++        - parameter file:       The file to upload
+++
+++        - returns: The created upload request.
+++    */
+++    public func upload(URLRequest: URLRequestConvertible, file: NSURL) -> Request {
+++        return upload(.File(URLRequest.URLRequest, file))
+++    }
+++
+++    /**
+++        Creates a request for uploading a file to the specified URL request.
+++
+++        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
+++
+++        - parameter method:    The HTTP method.
+++        - parameter URLString: The URL string.
+++        - parameter headers:   The HTTP headers. `nil` by default.
+++        - parameter file:      The file to upload
+++
+++        - returns: The created upload request.
+++    */
+++    public func upload(
+++        method: Method,
+++        _ URLString: URLStringConvertible,
+++        headers: [String: String]? = nil,
+++        file: NSURL)
+++        -> Request
+++    {
+++        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
+++        return upload(mutableURLRequest, file: file)
+++    }
+++
+++    // MARK: Data
+++
+++    /**
+++        Creates a request for uploading data to the specified URL request.
+++
+++        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
+++
+++        - parameter URLRequest: The URL request.
+++        - parameter data:       The data to upload.
+++
+++        - returns: The created upload request.
+++    */
+++    public func upload(URLRequest: URLRequestConvertible, data: NSData) -> Request {
+++        return upload(.Data(URLRequest.URLRequest, data))
+++    }
+++
+++    /**
+++        Creates a request for uploading data to the specified URL request.
+++
+++        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
+++
+++        - parameter method:    The HTTP method.
+++        - parameter URLString: The URL string.
+++        - parameter headers:   The HTTP headers. `nil` by default.
+++        - parameter data:      The data to upload
+++
+++        - returns: The created upload request.
+++    */
+++    public func upload(
+++        method: Method,
+++        _ URLString: URLStringConvertible,
+++        headers: [String: String]? = nil,
+++        data: NSData)
+++        -> Request
+++    {
+++        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
+++
+++        return upload(mutableURLRequest, data: data)
+++    }
+++
+++    // MARK: Stream
+++
+++    /**
+++        Creates a request for uploading a stream to the specified URL request.
+++
+++        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
+++
+++        - parameter URLRequest: The URL request.
+++        - parameter stream:     The stream to upload.
+++
+++        - returns: The created upload request.
+++    */
+++    public func upload(URLRequest: URLRequestConvertible, stream: NSInputStream) -> Request {
+++        return upload(.Stream(URLRequest.URLRequest, stream))
+++    }
+++
+++    /**
+++        Creates a request for uploading a stream to the specified URL request.
+++
+++        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
+++
+++        - parameter method:    The HTTP method.
+++        - parameter URLString: The URL string.
+++        - parameter headers:   The HTTP headers. `nil` by default.
+++        - parameter stream:    The stream to upload.
+++
+++        - returns: The created upload request.
+++    */
+++    public func upload(
+++        method: Method,
+++        _ URLString: URLStringConvertible,
+++        headers: [String: String]? = nil,
+++        stream: NSInputStream)
+++        -> Request
+++    {
+++        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
+++
+++        return upload(mutableURLRequest, stream: stream)
+++    }
+++
+++    // MARK: MultipartFormData
+++
+++    /// Default memory threshold used when encoding `MultipartFormData`.
+++    public static let MultipartFormDataEncodingMemoryThreshold: UInt64 = 10 * 1024 * 1024
+++
+++    /**
+++        Defines whether the `MultipartFormData` encoding was successful and contains result of the encoding as 
+++        associated values.
+++
+++        - Success: Represents a successful `MultipartFormData` encoding and contains the new `Request` along with 
+++                   streaming information.
+++        - Failure: Used to represent a failure in the `MultipartFormData` encoding and also contains the encoding 
+++                   error.
+++    */
+++    public enum MultipartFormDataEncodingResult {
+++        case Success(request: Request, streamingFromDisk: Bool, streamFileURL: NSURL?)
+++        case Failure(ErrorType)
+++    }
+++
+++    /**
+++        Encodes the `MultipartFormData` and creates a request to upload the result to the specified URL request.
+++
+++        It is important to understand the memory implications of uploading `MultipartFormData`. If the cummulative 
+++        payload is small, encoding the data in-memory and directly uploading to a server is the by far the most 
+++        efficient approach. However, if the payload is too large, encoding the data in-memory could cause your app to 
+++        be terminated. Larger payloads must first be written to disk using input and output streams to keep the memory 
+++        footprint low, then the data can be uploaded as a stream from the resulting file. Streaming from disk MUST be 
+++        used for larger payloads such as video content.
+++
+++        The `encodingMemoryThreshold` parameter allows Alamofire to automatically determine whether to encode in-memory 
+++        or stream from disk. If the content length of the `MultipartFormData` is below the `encodingMemoryThreshold`,
+++        encoding takes place in-memory. If the content length exceeds the threshold, the data is streamed to disk 
+++        during the encoding process. Then the result is uploaded as data or as a stream depending on which encoding 
+++        technique was used.
+++
+++        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
+++
+++        - parameter method:                  The HTTP method.
+++        - parameter URLString:               The URL string.
+++        - parameter headers:                 The HTTP headers. `nil` by default.
+++        - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
+++        - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
+++                                             `MultipartFormDataEncodingMemoryThreshold` by default.
+++        - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
+++    */
+++    public func upload(
+++        method: Method,
+++        _ URLString: URLStringConvertible,
+++        headers: [String: String]? = nil,
+++        multipartFormData: MultipartFormData -> Void,
+++        encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
+++        encodingCompletion: (MultipartFormDataEncodingResult -> Void)?)
+++    {
+++        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
+++
+++        return upload(
+++            mutableURLRequest,
+++            multipartFormData: multipartFormData,
+++            encodingMemoryThreshold: encodingMemoryThreshold,
+++            encodingCompletion: encodingCompletion
+++        )
+++    }
+++
+++    /**
+++        Encodes the `MultipartFormData` and creates a request to upload the result to the specified URL request.
+++
+++        It is important to understand the memory implications of uploading `MultipartFormData`. If the cummulative
+++        payload is small, encoding the data in-memory and directly uploading to a server is the by far the most
+++        efficient approach. However, if the payload is too large, encoding the data in-memory could cause your app to
+++        be terminated. Larger payloads must first be written to disk using input and output streams to keep the memory
+++        footprint low, then the data can be uploaded as a stream from the resulting file. Streaming from disk MUST be
+++        used for larger payloads such as video content.
+++
+++        The `encodingMemoryThreshold` parameter allows Alamofire to automatically determine whether to encode in-memory
+++        or stream from disk. If the content length of the `MultipartFormData` is below the `encodingMemoryThreshold`,
+++        encoding takes place in-memory. If the content length exceeds the threshold, the data is streamed to disk
+++        during the encoding process. Then the result is uploaded as data or as a stream depending on which encoding
+++        technique was used.
+++
+++        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
+++
+++        - parameter URLRequest:              The URL request.
+++        - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
+++        - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
+++                                             `MultipartFormDataEncodingMemoryThreshold` by default.
+++        - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
+++    */
+++    public func upload(
+++        URLRequest: URLRequestConvertible,
+++        multipartFormData: MultipartFormData -> Void,
+++        encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
+++        encodingCompletion: (MultipartFormDataEncodingResult -> Void)?)
+++    {
+++        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)) {
+++            let formData = MultipartFormData()
+++            multipartFormData(formData)
+++
+++            let URLRequestWithContentType = URLRequest.URLRequest
+++            URLRequestWithContentType.setValue(formData.contentType, forHTTPHeaderField: "Content-Type")
+++
+++            let isBackgroundSession = self.session.configuration.identifier != nil
+++
+++            if formData.contentLength < encodingMemoryThreshold && !isBackgroundSession {
+++                do {
+++                    let data = try formData.encode()
+++                    let encodingResult = MultipartFormDataEncodingResult.Success(
+++                        request: self.upload(URLRequestWithContentType, data: data),
+++                        streamingFromDisk: false,
+++                        streamFileURL: nil
+++                    )
+++
+++                    dispatch_async(dispatch_get_main_queue()) {
+++                        encodingCompletion?(encodingResult)
+++                    }
+++                } catch {
+++                    dispatch_async(dispatch_get_main_queue()) {
+++                        encodingCompletion?(.Failure(error as NSError))
+++                    }
+++                }
+++            } else {
+++                let fileManager = NSFileManager.defaultManager()
+++                let tempDirectoryURL = NSURL(fileURLWithPath: NSTemporaryDirectory())
+++                let directoryURL = tempDirectoryURL.URLByAppendingPathComponent("com.alamofire.manager/multipart.form.data")
+++                let fileName = NSUUID().UUIDString
+++                let fileURL = directoryURL.URLByAppendingPathComponent(fileName)
+++
+++                do {
+++                    try fileManager.createDirectoryAtURL(directoryURL, withIntermediateDirectories: true, attributes: nil)
+++                    try formData.writeEncodedDataToDisk(fileURL)
+++
+++                    dispatch_async(dispatch_get_main_queue()) {
+++                        let encodingResult = MultipartFormDataEncodingResult.Success(
+++                            request: self.upload(URLRequestWithContentType, file: fileURL),
+++                            streamingFromDisk: true,
+++                            streamFileURL: fileURL
+++                        )
+++                        encodingCompletion?(encodingResult)
+++                    }
+++                } catch {
+++                    dispatch_async(dispatch_get_main_queue()) {
+++                        encodingCompletion?(.Failure(error as NSError))
+++                    }
+++                }
+++            }
+++        }
+++    }
+++}
+++
+++// MARK: -
+++
+++extension Request {
+++
+++    // MARK: - UploadTaskDelegate
+++
+++    class UploadTaskDelegate: DataTaskDelegate {
+++        var uploadTask: NSURLSessionUploadTask? { return task as? NSURLSessionUploadTask }
+++        var uploadProgress: ((Int64, Int64, Int64) -> Void)!
+++
+++        // MARK: - NSURLSessionTaskDelegate
+++
+++        // MARK: Override Closures
+++
+++        var taskDidSendBodyData: ((NSURLSession, NSURLSessionTask, Int64, Int64, Int64) -> Void)?
+++
+++        // MARK: Delegate Methods
+++
+++        func URLSession(
+++            session: NSURLSession,
+++            task: NSURLSessionTask,
+++            didSendBodyData bytesSent: Int64,
+++            totalBytesSent: Int64,
+++            totalBytesExpectedToSend: Int64)
+++        {
+++            if initialResponseTime == nil { initialResponseTime = CFAbsoluteTimeGetCurrent() }
+++
+++            if let taskDidSendBodyData = taskDidSendBodyData {
+++                taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalBytesExpectedToSend)
+++            } else {
+++                progress.totalUnitCount = totalBytesExpectedToSend
+++                progress.completedUnitCount = totalBytesSent
+++
+++                uploadProgress?(bytesSent, totalBytesSent, totalBytesExpectedToSend)
+++            }
+++        }
+++    }
+++}
++diff --git a/Pods/Alamofire/Source/Validation.swift b/Pods/Alamofire/Source/Validation.swift
++new file mode 100644
++index 0000000..e90db2d
++--- /dev/null
+++++ b/Pods/Alamofire/Source/Validation.swift
++@@ -0,0 +1,214 @@
+++//
+++//  Validation.swift
+++//
+++//  Copyright (c) 2014-2016 Alamofire Software Foundation (http://alamofire.org/)
+++//
+++//  Permission is hereby granted, free of charge, to any person obtaining a copy
+++//  of this software and associated documentation files (the "Software"), to deal
+++//  in the Software without restriction, including without limitation the rights
+++//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+++//  copies of the Software, and to permit persons to whom the Software is
+++//  furnished to do so, subject to the following conditions:
+++//
+++//  The above copyright notice and this permission notice shall be included in
+++//  all copies or substantial portions of the Software.
+++//
+++//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+++//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+++//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+++//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+++//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+++//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+++//  THE SOFTWARE.
+++//
+++
+++import Foundation
+++
+++extension Request {
+++
+++    /**
+++        Used to represent whether validation was successful or encountered an error resulting in a failure.
+++
+++        - Success: The validation was successful.
+++        - Failure: The validation failed encountering the provided error.
+++    */
+++    public enum ValidationResult {
+++        case Success
+++        case Failure(NSError)
+++    }
+++
+++    /**
+++        A closure used to validate a request that takes a URL request and URL response, and returns whether the 
+++        request was valid.
+++    */
+++    public typealias Validation = (NSURLRequest?, NSHTTPURLResponse) -> ValidationResult
+++
+++    /**
+++        Validates the request, using the specified closure.
+++
+++        If validation fails, subsequent calls to response handlers will have an associated error.
+++
+++        - parameter validation: A closure to validate the request.
+++
+++        - returns: The request.
+++    */
+++    public func validate(validation: Validation) -> Self {
+++        delegate.queue.addOperationWithBlock {
+++            if let
+++                response = self.response where self.delegate.error == nil,
+++                case let .Failure(error) = validation(self.request, response)
+++            {
+++                self.delegate.error = error
+++            }
+++        }
+++
+++        return self
+++    }
+++
+++    // MARK: - Status Code
+++
+++    /**
+++        Validates that the response has a status code in the specified range.
+++
+++        If validation fails, subsequent calls to response handlers will have an associated error.
+++
+++        - parameter range: The range of acceptable status codes.
+++
+++        - returns: The request.
+++    */
+++    public func validate<S: SequenceType where S.Generator.Element == Int>(statusCode acceptableStatusCode: S) -> Self {
+++        return validate { _, response in
+++            if acceptableStatusCode.contains(response.statusCode) {
+++                return .Success
+++            } else {
+++                let failureReason = "Response status code was unacceptable: \(response.statusCode)"
+++
+++                let error = NSError(
+++                    domain: Error.Domain,
+++                    code: Error.Code.StatusCodeValidationFailed.rawValue,
+++                    userInfo: [
+++                        NSLocalizedFailureReasonErrorKey: failureReason,
+++                        Error.UserInfoKeys.StatusCode: response.statusCode
+++                    ]
+++                )
+++
+++                return .Failure(error)
+++            }
+++        }
+++    }
+++
+++    // MARK: - Content-Type
+++
+++    private struct MIMEType {
+++        let type: String
+++        let subtype: String
+++
+++        init?(_ string: String) {
+++            let components: [String] = {
+++                let stripped = string.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet())
+++                let split = stripped.substringToIndex(stripped.rangeOfString(";")?.startIndex ?? stripped.endIndex)
+++                return split.componentsSeparatedByString("/")
+++            }()
+++
+++            if let
+++                type = components.first,
+++                subtype = components.last
+++            {
+++                self.type = type
+++                self.subtype = subtype
+++            } else {
+++                return nil
+++            }
+++        }
+++
+++        func matches(MIME: MIMEType) -> Bool {
+++            switch (type, subtype) {
+++            case (MIME.type, MIME.subtype), (MIME.type, "*"), ("*", MIME.subtype), ("*", "*"):
+++                return true
+++            default:
+++                return false
+++            }
+++        }
+++    }
+++
+++    /**
+++        Validates that the response has a content type in the specified array.
+++
+++        If validation fails, subsequent calls to response handlers will have an associated error.
+++
+++        - parameter contentType: The acceptable content types, which may specify wildcard types and/or subtypes.
+++
+++        - returns: The request.
+++    */
+++    public func validate<S : SequenceType where S.Generator.Element == String>(contentType acceptableContentTypes: S) -> Self {
+++        return validate { _, response in
+++            guard let validData = self.delegate.data where validData.length > 0 else { return .Success }
+++
+++            if let
+++                responseContentType = response.MIMEType,
+++                responseMIMEType = MIMEType(responseContentType)
+++            {
+++                for contentType in acceptableContentTypes {
+++                    if let acceptableMIMEType = MIMEType(contentType) where acceptableMIMEType.matches(responseMIMEType) {
+++                        return .Success
+++                    }
+++                }
+++            } else {
+++                for contentType in acceptableContentTypes {
+++                    if let MIMEType = MIMEType(contentType) where MIMEType.type == "*" && MIMEType.subtype == "*" {
+++                        return .Success
+++                    }
+++                }
+++            }
+++
+++            let contentType: String
+++            let failureReason: String
+++
+++            if let responseContentType = response.MIMEType {
+++                contentType = responseContentType
+++
+++                failureReason = (
+++                    "Response content type \"\(responseContentType)\" does not match any acceptable " +
+++                    "content types: \(acceptableContentTypes)"
+++                )
+++            } else {
+++                contentType = ""
+++                failureReason = "Response content type was missing and acceptable content type does not match \"*/*\""
+++            }
+++
+++            let error = NSError(
+++                domain: Error.Domain,
+++                code: Error.Code.ContentTypeValidationFailed.rawValue,
+++                userInfo: [
+++                    NSLocalizedFailureReasonErrorKey: failureReason,
+++                    Error.UserInfoKeys.ContentType: contentType
+++                ]
+++            )
+++
+++            return .Failure(error)
+++        }
+++    }
+++
+++    // MARK: - Automatic
+++
+++    /**
+++        Validates that the response has a status code in the default acceptable range of 200...299, and that the content 
+++        type matches any specified in the Accept HTTP header field.
+++
+++        If validation fails, subsequent calls to response handlers will have an associated error.
+++
+++        - returns: The request.
+++    */
+++    public func validate() -> Self {
+++        let acceptableStatusCodes: Range<Int> = 200..<300
+++        let acceptableContentTypes: [String] = {
+++            if let accept = request?.valueForHTTPHeaderField("Accept") {
+++                return accept.componentsSeparatedByString(",")
+++            }
+++
+++            return ["*/*"]
+++        }()
+++
+++        return validate(statusCode: acceptableStatusCodes).validate(contentType: acceptableContentTypes)
+++    }
+++}
++diff --git a/Pods/Manifest.lock b/Pods/Manifest.lock
++index 4be331a..0ae9987 100644
++--- a/Pods/Manifest.lock
+++++ b/Pods/Manifest.lock
++@@ -1,14 +1,20 @@
++ PODS:
+++  - Alamofire (3.4.1)
++   - CocoaAsyncSocket (7.5.0):
++     - CocoaAsyncSocket/GCD (= 7.5.0)
++   - CocoaAsyncSocket/GCD (7.5.0)
+++  - SWXMLHash (2.4.0)
++ 
++ DEPENDENCIES:
+++  - Alamofire
++   - CocoaAsyncSocket
+++  - SWXMLHash
++ 
++ SPEC CHECKSUMS:
+++  Alamofire: 01a82e2f6c0f860ade35534c8dd88be61bdef40c
++   CocoaAsyncSocket: 3baeb1ddd969f81cf9fca81053ae49ef2d1cbbfa
+++  SWXMLHash: 507397103325f140863d09040c04ae14a49a16cb
++ 
++-PODFILE CHECKSUM: e6332a1e2227a6d3ff82fcc374286642be589891
+++PODFILE CHECKSUM: 3d088204bac8fcec64bd2420b15ef2f3c7764d77
++ 
++ COCOAPODS: 1.0.0
++diff --git a/Pods/Pods.xcodeproj/project.pbxproj b/Pods/Pods.xcodeproj/project.pbxproj
++index dc930dc..a791ba2 100644
++--- a/Pods/Pods.xcodeproj/project.pbxproj
+++++ b/Pods/Pods.xcodeproj/project.pbxproj
++@@ -7,65 +7,153 @@
++ 	objects = {
++ 
++ /* Begin PBXBuildFile section */
++-		3A3F65A9CFEBD04E71A6E05108F795D0 /* Cocoa.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 7C56649C408E00F4469558EBC9AF1BA3 /* Cocoa.framework */; };
+++		095406039B4D371E48D08B38A2975AC8 /* Error.swift in Sources */ = {isa = PBXBuildFile; fileRef = EF9B2AFCE03477C50F07C48E33A463FF /* Error.swift */; };
+++		16102E4E35FAA0FC4161282FECE56469 /* Timeline.swift in Sources */ = {isa = PBXBuildFile; fileRef = D77E19C3839748928122D0DEAC1BA1F4 /* Timeline.swift */; };
+++		1E5602BF3A87A7353DA77A2EE51EED93 /* SWXMLHash-umbrella.h in Headers */ = {isa = PBXBuildFile; fileRef = 5F0B453266F2DE0B098E2B994FE716CD /* SWXMLHash-umbrella.h */; settings = {ATTRIBUTES = (Public, ); }; };
+++		2D3405986FC586FA6C0A5E0B6BA7E64E /* Validation.swift in Sources */ = {isa = PBXBuildFile; fileRef = 84395B1E623BD8F9DE2F7E16CA43251F /* Validation.swift */; };
+++		34CCDCA848A701466256BC2927DA8856 /* NetworkReachabilityManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 64E8485F5FCFC4FDB8D6CE0BFC980C58 /* NetworkReachabilityManager.swift */; };
+++		3EA8F215C9C1432D74E5CCA4834AA8C0 /* ResponseSerialization.swift in Sources */ = {isa = PBXBuildFile; fileRef = B7C925E8849659F01450961BB1FFA23D /* ResponseSerialization.swift */; };
+++		4081EA628AF0B73AC51FFB9D7AB3B89E /* Manager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 7031D4000017108DC80504B065340368 /* Manager.swift */; };
+++		515FD66E0570F0E6B6D6F6B4AE427CC2 /* Pods-CRMCall092016-dummy.m in Sources */ = {isa = PBXBuildFile; fileRef = 2AE57F75653AE6E263CFF4332F052094 /* Pods-CRMCall092016-dummy.m */; };
++ 		551864BF98FF39945A2F33B4C0B97A06 /* Cocoa.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 7C56649C408E00F4469558EBC9AF1BA3 /* Cocoa.framework */; };
++ 		58CE33E7875BEC7B12D551A398FB9A97 /* Security.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = E35F27DD11D07BB27A6C8CE52CD34061 /* Security.framework */; };
++-		6AAFA2F344A6B58F728AF958F3FE6D89 /* GCDAsyncSocket.h in Headers */ = {isa = PBXBuildFile; fileRef = 4CA8FFB2F306345702A20E3FE7CE6EF7 /* GCDAsyncSocket.h */; settings = {ATTRIBUTES = (Public, ); }; };
++-		92AED971B91C640191A5ABA1567FE358 /* GCDAsyncUdpSocket.h in Headers */ = {isa = PBXBuildFile; fileRef = 84A110336E93C3E786F9B32956E29A3E /* GCDAsyncUdpSocket.h */; settings = {ATTRIBUTES = (Public, ); }; };
++-		991BFD139F6A45C9B654960C2F6A7F09 /* GCDAsyncSocket.m in Sources */ = {isa = PBXBuildFile; fileRef = 1D696A8CDEBE87CDE80E57AE0E305C5F /* GCDAsyncSocket.m */; settings = {COMPILER_FLAGS = "-DOS_OBJECT_USE_OBJC=0"; }; };
++-		AC9CFE1768573A23FAACC873AAFA8EA1 /* Pods-CRMCall092016-umbrella.h in Headers */ = {isa = PBXBuildFile; fileRef = 8204EF2923FBB8554D93693870D0BBBC /* Pods-CRMCall092016-umbrella.h */; settings = {ATTRIBUTES = (Public, ); }; };
++-		ACFE60AB34A7FEF697E6EEFB62436A8D /* CocoaAsyncSocket-umbrella.h in Headers */ = {isa = PBXBuildFile; fileRef = D6D9F3F23E9E53DAFA379995A9E13E58 /* CocoaAsyncSocket-umbrella.h */; settings = {ATTRIBUTES = (Public, ); }; };
+++		5BC19E6E0F199276003F0AF96838BCE5 /* Upload.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8991BF3DBE2A9AD6CB35BF27297CC8FD /* Upload.swift */; };
+++		5CB05FBCB32D21E194B5ECF680CB6AE0 /* Download.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2AA16A476F2771B1B74FB14947F24E02 /* Download.swift */; };
+++		5CEBE5DA1F9A37F09EE1389B645FD1B4 /* Cocoa.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 7C56649C408E00F4469558EBC9AF1BA3 /* Cocoa.framework */; };
+++		62E8346F03C03E7F4D631361F325689E /* Response.swift in Sources */ = {isa = PBXBuildFile; fileRef = DDE49D9DCF93A390B23188C67221ECA8 /* Response.swift */; };
+++		6AAFA2F344A6B58F728AF958F3FE6D89 /* GCDAsyncSocket.h in Headers */ = {isa = PBXBuildFile; fileRef = D1519185135D5351111F109E89AF0F64 /* GCDAsyncSocket.h */; settings = {ATTRIBUTES = (Public, ); }; };
+++		723E6C875E842A6DA996001BDFAF520E /* SWXMLHash+TypeConversion.swift in Sources */ = {isa = PBXBuildFile; fileRef = CE89954F8A8211757E95D5E68308F52F /* SWXMLHash+TypeConversion.swift */; };
+++		72504A8A3AD0249F8A37515A72C2DF98 /* SWXMLHash.swift in Sources */ = {isa = PBXBuildFile; fileRef = 7201E46C9812098E184043C076154118 /* SWXMLHash.swift */; };
+++		7560CA92AA1E62C1C39BBA309960C36A /* SWXMLHash-dummy.m in Sources */ = {isa = PBXBuildFile; fileRef = 2BDE952759498BFF23C89A0302BD584C /* SWXMLHash-dummy.m */; };
+++		7B48852C4D848FA2DA416A98F6425869 /* ServerTrustPolicy.swift in Sources */ = {isa = PBXBuildFile; fileRef = 62073F3761055A46F154B11F061A08AF /* ServerTrustPolicy.swift */; };
+++		8EB11202167FCDDF1257AAAB1D1FB244 /* Alamofire.swift in Sources */ = {isa = PBXBuildFile; fileRef = E01E26D8749A98484E8DD7726148EC20 /* Alamofire.swift */; };
+++		92AED971B91C640191A5ABA1567FE358 /* GCDAsyncUdpSocket.h in Headers */ = {isa = PBXBuildFile; fileRef = 540A59953BD2C3205CF5F2CE7B7BFC1F /* GCDAsyncUdpSocket.h */; settings = {ATTRIBUTES = (Public, ); }; };
+++		9469DF81ECB494E84675969B5E13374C /* Alamofire-umbrella.h in Headers */ = {isa = PBXBuildFile; fileRef = 588A6F6AFA80EA93ECB5E93B156711EC /* Alamofire-umbrella.h */; settings = {ATTRIBUTES = (Public, ); }; };
+++		991BFD139F6A45C9B654960C2F6A7F09 /* GCDAsyncSocket.m in Sources */ = {isa = PBXBuildFile; fileRef = FB4019B4F3DF5D7B015227F280ABBE9C /* GCDAsyncSocket.m */; settings = {COMPILER_FLAGS = "-DOS_OBJECT_USE_OBJC=0"; }; };
+++		A2BFC3BB72F0CAF82F3CEF224DE6752D /* Pods-CRMCall092016-umbrella.h in Headers */ = {isa = PBXBuildFile; fileRef = 8204EF2923FBB8554D93693870D0BBBC /* Pods-CRMCall092016-umbrella.h */; settings = {ATTRIBUTES = (Public, ); }; };
+++		AA314156AC500125F4078EE968DB14C6 /* Result.swift in Sources */ = {isa = PBXBuildFile; fileRef = E2A2BD6EE0720A5171EF80B09CFD4224 /* Result.swift */; };
+++		ACFE60AB34A7FEF697E6EEFB62436A8D /* CocoaAsyncSocket-umbrella.h in Headers */ = {isa = PBXBuildFile; fileRef = 5F955B5F2D78E83D6BA538909B360F55 /* CocoaAsyncSocket-umbrella.h */; settings = {ATTRIBUTES = (Public, ); }; };
+++		ADF19C953CE2A7D0B72EC93A81FCCC26 /* Alamofire-dummy.m in Sources */ = {isa = PBXBuildFile; fileRef = 5399F7CAF2240783134915CC1CBEF3E5 /* Alamofire-dummy.m */; };
+++		AE4CF87C02C042DF13ED5B21C4FDC1E0 /* Stream.swift in Sources */ = {isa = PBXBuildFile; fileRef = 5B2BB4979BAD0CF7156F74E71CAD3041 /* Stream.swift */; };
+++		B93BDD4D746BA45D62DC63CA9E5BF338 /* Cocoa.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 7C56649C408E00F4469558EBC9AF1BA3 /* Cocoa.framework */; };
+++		BE41196F6A3903E59C3306FE3F8B43FE /* Notifications.swift in Sources */ = {isa = PBXBuildFile; fileRef = ECD84F348832D77D5059D066749346A4 /* Notifications.swift */; };
+++		C0DB70AB368765DC64BFB5FEA75E0696 /* ParameterEncoding.swift in Sources */ = {isa = PBXBuildFile; fileRef = 125D17DF5E6A1A7420D1F1A975DD7EB9 /* ParameterEncoding.swift */; };
++ 		C5C58FEE0A35A9EF7DA80B26B6DF2089 /* CoreServices.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 8028EBFA77CCF460ADEBC79B87525C3D /* CoreServices.framework */; };
++-		D9A44696356E299F3C9A4BFF9E57343F /* GCDAsyncUdpSocket.m in Sources */ = {isa = PBXBuildFile; fileRef = 098765466D421180F3953EF8EEDDCEF1 /* GCDAsyncUdpSocket.m */; settings = {COMPILER_FLAGS = "-DOS_OBJECT_USE_OBJC=0"; }; };
++-		F32AB407361604D69C1D26A59004F99F /* Pods-CRMCall092016-dummy.m in Sources */ = {isa = PBXBuildFile; fileRef = 2AE57F75653AE6E263CFF4332F052094 /* Pods-CRMCall092016-dummy.m */; };
++-		F45B40DF0BF596BDCD96B2D85EF848FA /* CocoaAsyncSocket-dummy.m in Sources */ = {isa = PBXBuildFile; fileRef = 8E98378F2CF04086E8088C6A14347C33 /* CocoaAsyncSocket-dummy.m */; };
+++		C7B6DD7C0456C50289A2C381DFE9FA3F /* MultipartFormData.swift in Sources */ = {isa = PBXBuildFile; fileRef = AF650B57C6596DA153F5900EA61CC5A7 /* MultipartFormData.swift */; };
+++		D9A44696356E299F3C9A4BFF9E57343F /* GCDAsyncUdpSocket.m in Sources */ = {isa = PBXBuildFile; fileRef = ED466E93414A976222AFAF321E9AF11C /* GCDAsyncUdpSocket.m */; settings = {COMPILER_FLAGS = "-DOS_OBJECT_USE_OBJC=0"; }; };
+++		EFE92E8D3813DD26E78E93EEAF6D7E7E /* Request.swift in Sources */ = {isa = PBXBuildFile; fileRef = F14E627DC549703B46315BBCCDD362AE /* Request.swift */; };
+++		F3F3FD9096F43B73CBB52EF0E1CCF73E /* Cocoa.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 7C56649C408E00F4469558EBC9AF1BA3 /* Cocoa.framework */; };
+++		F45B40DF0BF596BDCD96B2D85EF848FA /* CocoaAsyncSocket-dummy.m in Sources */ = {isa = PBXBuildFile; fileRef = ABC09E1DCC49261B7629CD82626C21FA /* CocoaAsyncSocket-dummy.m */; };
++ /* End PBXBuildFile section */
++ 
++ /* Begin PBXContainerItemProxy section */
++-		FEE18F96712D8E1EC56662C660E9DB97 /* PBXContainerItemProxy */ = {
+++		1F41FB1990B1F3A39ADE4AEDF3C3DE3A /* PBXContainerItemProxy */ = {
+++			isa = PBXContainerItemProxy;
+++			containerPortal = D41D8CD98F00B204E9800998ECF8427E /* Project object */;
+++			proxyType = 1;
+++			remoteGlobalIDString = 79C040AFDDCE1BCBF6D8B5EB0B85887F;
+++			remoteInfo = Alamofire;
+++		};
+++		A6ED361CEE1ECD9230711154275A9274 /* PBXContainerItemProxy */ = {
++ 			isa = PBXContainerItemProxy;
++ 			containerPortal = D41D8CD98F00B204E9800998ECF8427E /* Project object */;
++ 			proxyType = 1;
++ 			remoteGlobalIDString = B37E19CA872A7535725D1E1946E5C271;
++ 			remoteInfo = CocoaAsyncSocket;
++ 		};
+++		A98B988E365E15D4E2D8C73D59A5F0EE /* PBXContainerItemProxy */ = {
+++			isa = PBXContainerItemProxy;
+++			containerPortal = D41D8CD98F00B204E9800998ECF8427E /* Project object */;
+++			proxyType = 1;
+++			remoteGlobalIDString = 67C63D588DA997BFF7D3C999DA7A5A23;
+++			remoteInfo = SWXMLHash;
+++		};
++ /* End PBXContainerItemProxy section */
++ 
++ /* Begin PBXFileReference section */
++-		02F721520946E3ED0F5A5A2CBC3AA2F1 /* CocoaAsyncSocket.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = CocoaAsyncSocket.framework; sourceTree = BUILT_PRODUCTS_DIR; };
++ 		06FB8D033CAD052B54E275B7C0A5F2A4 /* Pods-CRMCall092016-resources.sh */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.script.sh; path = "Pods-CRMCall092016-resources.sh"; sourceTree = "<group>"; };
++-		098765466D421180F3953EF8EEDDCEF1 /* GCDAsyncUdpSocket.m */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.objc; name = GCDAsyncUdpSocket.m; path = Source/GCD/GCDAsyncUdpSocket.m; sourceTree = "<group>"; };
+++		0E50EC0B768D99DF8AA54CEF00DCD620 /* CocoaAsyncSocket-prefix.pch */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; path = "CocoaAsyncSocket-prefix.pch"; sourceTree = "<group>"; };
++ 		11566DE119910F4F8728001B55582E0A /* Pods-CRMCall092016.debug.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; path = "Pods-CRMCall092016.debug.xcconfig"; sourceTree = "<group>"; };
++-		1D696A8CDEBE87CDE80E57AE0E305C5F /* GCDAsyncSocket.m */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.objc; name = GCDAsyncSocket.m; path = Source/GCD/GCDAsyncSocket.m; sourceTree = "<group>"; };
+++		125D17DF5E6A1A7420D1F1A975DD7EB9 /* ParameterEncoding.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = ParameterEncoding.swift; path = Source/ParameterEncoding.swift; sourceTree = "<group>"; };
+++		26831C2816B1A793F64FFC713F267BB3 /* Pods_CRMCall092016.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Pods_CRMCall092016.framework; sourceTree = BUILT_PRODUCTS_DIR; };
++ 		27183F652B0581A2389A12BA7AFAF98A /* Pods-CRMCall092016-frameworks.sh */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.script.sh; path = "Pods-CRMCall092016-frameworks.sh"; sourceTree = "<group>"; };
+++		2AA16A476F2771B1B74FB14947F24E02 /* Download.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Download.swift; path = Source/Download.swift; sourceTree = "<group>"; };
++ 		2AE57F75653AE6E263CFF4332F052094 /* Pods-CRMCall092016-dummy.m */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.objc; path = "Pods-CRMCall092016-dummy.m"; sourceTree = "<group>"; };
++-		2EF436B09B560AF848B4D98C55F61FE0 /* CocoaAsyncSocket.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; path = CocoaAsyncSocket.xcconfig; sourceTree = "<group>"; };
+++		2BDE952759498BFF23C89A0302BD584C /* SWXMLHash-dummy.m */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.objc; path = "SWXMLHash-dummy.m"; sourceTree = "<group>"; };
++ 		3344C80F9295CA22275F8A0581FF4EAB /* Pods-CRMCall092016.release.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; path = "Pods-CRMCall092016.release.xcconfig"; sourceTree = "<group>"; };
++ 		38BAD449C799FB480EAEF1177A7D5534 /* Pods-CRMCall092016-acknowledgements.plist */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.plist.xml; path = "Pods-CRMCall092016-acknowledgements.plist"; sourceTree = "<group>"; };
++-		4CA8FFB2F306345702A20E3FE7CE6EF7 /* GCDAsyncSocket.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = GCDAsyncSocket.h; path = Source/GCD/GCDAsyncSocket.h; sourceTree = "<group>"; };
+++		3E8CB71BFFC59E2E3BA715D7AEF30B56 /* SWXMLHash.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; path = SWXMLHash.xcconfig; sourceTree = "<group>"; };
+++		421DBE2696953979E49FD7BBE38C3847 /* CocoaAsyncSocket.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; path = CocoaAsyncSocket.xcconfig; sourceTree = "<group>"; };
+++		428FFE99F83C8F7F2E1E0A88D7622693 /* Alamofire-prefix.pch */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; path = "Alamofire-prefix.pch"; sourceTree = "<group>"; };
+++		530C70E607990B234619FFA25EF6C451 /* SWXMLHash-prefix.pch */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; path = "SWXMLHash-prefix.pch"; sourceTree = "<group>"; };
+++		5399F7CAF2240783134915CC1CBEF3E5 /* Alamofire-dummy.m */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.objc; path = "Alamofire-dummy.m"; sourceTree = "<group>"; };
+++		540A59953BD2C3205CF5F2CE7B7BFC1F /* GCDAsyncUdpSocket.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = GCDAsyncUdpSocket.h; path = Source/GCD/GCDAsyncUdpSocket.h; sourceTree = "<group>"; };
+++		588A6F6AFA80EA93ECB5E93B156711EC /* Alamofire-umbrella.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; path = "Alamofire-umbrella.h"; sourceTree = "<group>"; };
+++		5B2BB4979BAD0CF7156F74E71CAD3041 /* Stream.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Stream.swift; path = Source/Stream.swift; sourceTree = "<group>"; };
+++		5F0B453266F2DE0B098E2B994FE716CD /* SWXMLHash-umbrella.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; path = "SWXMLHash-umbrella.h"; sourceTree = "<group>"; };
++ 		5F10F69CC4AED6A9E8880E0026D1641C /* Pods-CRMCall092016.modulemap */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = "sourcecode.module-map"; path = "Pods-CRMCall092016.modulemap"; sourceTree = "<group>"; };
++-		607059846E83C82CDCE4A0DC0CC4E112 /* Pods_CRMCall092016.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Pods_CRMCall092016.framework; sourceTree = BUILT_PRODUCTS_DIR; };
+++		5F955B5F2D78E83D6BA538909B360F55 /* CocoaAsyncSocket-umbrella.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; path = "CocoaAsyncSocket-umbrella.h"; sourceTree = "<group>"; };
+++		62073F3761055A46F154B11F061A08AF /* ServerTrustPolicy.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = ServerTrustPolicy.swift; path = Source/ServerTrustPolicy.swift; sourceTree = "<group>"; };
+++		64E8485F5FCFC4FDB8D6CE0BFC980C58 /* NetworkReachabilityManager.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = NetworkReachabilityManager.swift; path = Source/NetworkReachabilityManager.swift; sourceTree = "<group>"; };
++ 		686F90C995F21EC49B98AEDDD4DFE31A /* Info.plist */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
++-		75F9206B99E5B5423D6B61D755C011CC /* CocoaAsyncSocket-prefix.pch */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; path = "CocoaAsyncSocket-prefix.pch"; sourceTree = "<group>"; };
+++		6D0E27C7C865AC6950E934CB59C487B1 /* Alamofire.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; path = Alamofire.xcconfig; sourceTree = "<group>"; };
+++		7031D4000017108DC80504B065340368 /* Manager.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Manager.swift; path = Source/Manager.swift; sourceTree = "<group>"; };
+++		7201E46C9812098E184043C076154118 /* SWXMLHash.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = SWXMLHash.swift; path = Source/SWXMLHash.swift; sourceTree = "<group>"; };
+++		72118B3908192BACF6200F55157D9D71 /* Info.plist */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
+++		7911AB14649A75D2129B7AF99D9F284F /* CocoaAsyncSocket.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = CocoaAsyncSocket.framework; sourceTree = BUILT_PRODUCTS_DIR; };
+++		7B57FE540E66A44F3A0381EE3E553552 /* Alamofire.modulemap */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = "sourcecode.module-map"; path = Alamofire.modulemap; sourceTree = "<group>"; };
++ 		7C56649C408E00F4469558EBC9AF1BA3 /* Cocoa.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Cocoa.framework; path = Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk/System/Library/Frameworks/Cocoa.framework; sourceTree = DEVELOPER_DIR; };
++ 		8028EBFA77CCF460ADEBC79B87525C3D /* CoreServices.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = CoreServices.framework; path = Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk/System/Library/Frameworks/CoreServices.framework; sourceTree = DEVELOPER_DIR; };
++ 		8204EF2923FBB8554D93693870D0BBBC /* Pods-CRMCall092016-umbrella.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; path = "Pods-CRMCall092016-umbrella.h"; sourceTree = "<group>"; };
++-		84A110336E93C3E786F9B32956E29A3E /* GCDAsyncUdpSocket.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = GCDAsyncUdpSocket.h; path = Source/GCD/GCDAsyncUdpSocket.h; sourceTree = "<group>"; };
++-		86340A99F20BEC0D9E6F18F9080B8720 /* CocoaAsyncSocket.modulemap */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = "sourcecode.module-map"; path = CocoaAsyncSocket.modulemap; sourceTree = "<group>"; };
++-		8897EF90B2D55946A61AD5A10C38B75C /* Info.plist */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
++-		8E98378F2CF04086E8088C6A14347C33 /* CocoaAsyncSocket-dummy.m */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.objc; path = "CocoaAsyncSocket-dummy.m"; sourceTree = "<group>"; };
+++		84395B1E623BD8F9DE2F7E16CA43251F /* Validation.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Validation.swift; path = Source/Validation.swift; sourceTree = "<group>"; };
+++		875107E5B1CD30A24F90CC34B1452862 /* Info.plist */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
+++		8991BF3DBE2A9AD6CB35BF27297CC8FD /* Upload.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Upload.swift; path = Source/Upload.swift; sourceTree = "<group>"; };
+++		8D365AF8CA284382154A3FCADC2924CC /* Alamofire.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Alamofire.framework; sourceTree = BUILT_PRODUCTS_DIR; };
++ 		92BE530B50F95F40971BFC22BF7114AF /* Pods-CRMCall092016-acknowledgements.markdown */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text; path = "Pods-CRMCall092016-acknowledgements.markdown"; sourceTree = "<group>"; };
++ 		93A4A3777CF96A4AAC1D13BA6DCCEA73 /* Podfile */ = {isa = PBXFileReference; explicitFileType = text.script.ruby; includeInIndex = 1; name = Podfile; path = ../Podfile; sourceTree = SOURCE_ROOT; xcLanguageSpecificationIdentifier = xcode.lang.ruby; };
++-		D6D9F3F23E9E53DAFA379995A9E13E58 /* CocoaAsyncSocket-umbrella.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; path = "CocoaAsyncSocket-umbrella.h"; sourceTree = "<group>"; };
+++		ABC09E1DCC49261B7629CD82626C21FA /* CocoaAsyncSocket-dummy.m */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.objc; path = "CocoaAsyncSocket-dummy.m"; sourceTree = "<group>"; };
+++		AF650B57C6596DA153F5900EA61CC5A7 /* MultipartFormData.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = MultipartFormData.swift; path = Source/MultipartFormData.swift; sourceTree = "<group>"; };
+++		B7C925E8849659F01450961BB1FFA23D /* ResponseSerialization.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = ResponseSerialization.swift; path = Source/ResponseSerialization.swift; sourceTree = "<group>"; };
+++		BC6E9E2C5DCCD36683912082D39D119C /* SWXMLHash.modulemap */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = "sourcecode.module-map"; path = SWXMLHash.modulemap; sourceTree = "<group>"; };
+++		C3D72D35EB73312A9630B6441B6D65DC /* Info.plist */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
+++		C608DAD3E8D1E316C917482D1150C9E4 /* SWXMLHash.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = SWXMLHash.framework; sourceTree = BUILT_PRODUCTS_DIR; };
+++		CE89954F8A8211757E95D5E68308F52F /* SWXMLHash+TypeConversion.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = "SWXMLHash+TypeConversion.swift"; path = "Source/SWXMLHash+TypeConversion.swift"; sourceTree = "<group>"; };
+++		D1519185135D5351111F109E89AF0F64 /* GCDAsyncSocket.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = GCDAsyncSocket.h; path = Source/GCD/GCDAsyncSocket.h; sourceTree = "<group>"; };
+++		D77E19C3839748928122D0DEAC1BA1F4 /* Timeline.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Timeline.swift; path = Source/Timeline.swift; sourceTree = "<group>"; };
+++		DDE49D9DCF93A390B23188C67221ECA8 /* Response.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Response.swift; path = Source/Response.swift; sourceTree = "<group>"; };
+++		E01E26D8749A98484E8DD7726148EC20 /* Alamofire.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Alamofire.swift; path = Source/Alamofire.swift; sourceTree = "<group>"; };
+++		E0D2633544BCFC90D4DD429B2FE884D7 /* CocoaAsyncSocket.modulemap */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = "sourcecode.module-map"; path = CocoaAsyncSocket.modulemap; sourceTree = "<group>"; };
+++		E2A2BD6EE0720A5171EF80B09CFD4224 /* Result.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Result.swift; path = Source/Result.swift; sourceTree = "<group>"; };
++ 		E35F27DD11D07BB27A6C8CE52CD34061 /* Security.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Security.framework; path = Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk/System/Library/Frameworks/Security.framework; sourceTree = DEVELOPER_DIR; };
+++		ECD84F348832D77D5059D066749346A4 /* Notifications.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Notifications.swift; path = Source/Notifications.swift; sourceTree = "<group>"; };
+++		ED466E93414A976222AFAF321E9AF11C /* GCDAsyncUdpSocket.m */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.objc; name = GCDAsyncUdpSocket.m; path = Source/GCD/GCDAsyncUdpSocket.m; sourceTree = "<group>"; };
+++		EF9B2AFCE03477C50F07C48E33A463FF /* Error.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Error.swift; path = Source/Error.swift; sourceTree = "<group>"; };
+++		F14E627DC549703B46315BBCCDD362AE /* Request.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Request.swift; path = Source/Request.swift; sourceTree = "<group>"; };
+++		FB4019B4F3DF5D7B015227F280ABBE9C /* GCDAsyncSocket.m */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.objc; name = GCDAsyncSocket.m; path = Source/GCD/GCDAsyncSocket.m; sourceTree = "<group>"; };
++ /* End PBXFileReference section */
++ 
++ /* Begin PBXFrameworksBuildPhase section */
++-		EDB9B30DC8B486582976DE7ABD029042 /* Frameworks */ = {
+++		057374DBF94AB4C711C95D3C81644697 /* Frameworks */ = {
+++			isa = PBXFrameworksBuildPhase;
+++			buildActionMask = 2147483647;
+++			files = (
+++				B93BDD4D746BA45D62DC63CA9E5BF338 /* Cocoa.framework in Frameworks */,
+++			);
+++			runOnlyForDeploymentPostprocessing = 0;
+++		};
+++		86631BCDD6995CFD2A8A7716F3673282 /* Frameworks */ = {
+++			isa = PBXFrameworksBuildPhase;
+++			buildActionMask = 2147483647;
+++			files = (
+++				F3F3FD9096F43B73CBB52EF0E1CCF73E /* Cocoa.framework in Frameworks */,
+++			);
+++			runOnlyForDeploymentPostprocessing = 0;
+++		};
+++		88126D8EF116B657E2FD26AB2C7D7C76 /* Frameworks */ = {
++ 			isa = PBXFrameworksBuildPhase;
++ 			buildActionMask = 2147483647;
++ 			files = (
++-				3A3F65A9CFEBD04E71A6E05108F795D0 /* Cocoa.framework in Frameworks */,
+++				5CEBE5DA1F9A37F09EE1389B645FD1B4 /* Cocoa.framework in Frameworks */,
++ 			);
++ 			runOnlyForDeploymentPostprocessing = 0;
++ 		};
++@@ -82,6 +170,30 @@
++ /* End PBXFrameworksBuildPhase section */
++ 
++ /* Begin PBXGroup section */
+++		01B95DBFE667B00CC6977BD31CE4F3B2 /* Support Files */ = {
+++			isa = PBXGroup;
+++			children = (
+++				7B57FE540E66A44F3A0381EE3E553552 /* Alamofire.modulemap */,
+++				6D0E27C7C865AC6950E934CB59C487B1 /* Alamofire.xcconfig */,
+++				5399F7CAF2240783134915CC1CBEF3E5 /* Alamofire-dummy.m */,
+++				428FFE99F83C8F7F2E1E0A88D7622693 /* Alamofire-prefix.pch */,
+++				588A6F6AFA80EA93ECB5E93B156711EC /* Alamofire-umbrella.h */,
+++				72118B3908192BACF6200F55157D9D71 /* Info.plist */,
+++			);
+++			name = "Support Files";
+++			path = "../Target Support Files/Alamofire";
+++			sourceTree = "<group>";
+++		};
+++		0D755FC3415F3E7464CA4F3CD0BEF91A /* Pods */ = {
+++			isa = PBXGroup;
+++			children = (
+++				71982584ECA5E3C8D7B92572F29AA8DA /* Alamofire */,
+++				FF778D1838A3F60CF9CF2403E182E955 /* CocoaAsyncSocket */,
+++				E7FACF9BF4BA24608BB789AF7D8A102F /* SWXMLHash */,
+++			);
+++			name = Pods;
+++			sourceTree = "<group>";
+++		};
++ 		125C76EFFE45A468598601061FFD20C1 /* OS X */ = {
++ 			isa = PBXGroup;
++ 			children = (
++@@ -92,34 +204,48 @@
++ 			name = "OS X";
++ 			sourceTree = "<group>";
++ 		};
++-		3750E20CAB4987ACB8AB27B6C25C1D60 /* Pods */ = {
+++		6B7D6DAD89010B625FD7D6631AB356FF /* Products */ = {
++ 			isa = PBXGroup;
++ 			children = (
++-				B16CCCC916CD9D13BBF53EA0C69C4615 /* CocoaAsyncSocket */,
+++				8D365AF8CA284382154A3FCADC2924CC /* Alamofire.framework */,
+++				7911AB14649A75D2129B7AF99D9F284F /* CocoaAsyncSocket.framework */,
+++				26831C2816B1A793F64FFC713F267BB3 /* Pods_CRMCall092016.framework */,
+++				C608DAD3E8D1E316C917482D1150C9E4 /* SWXMLHash.framework */,
++ 			);
++-			name = Pods;
+++			name = Products;
++ 			sourceTree = "<group>";
++ 		};
++-		557C7CF8D4466D636F16673BAB31EEF1 /* Support Files */ = {
+++		6BAE03FB7B81BD8D4DD2F62159D790F2 /* Targets Support Files */ = {
++ 			isa = PBXGroup;
++ 			children = (
++-				86340A99F20BEC0D9E6F18F9080B8720 /* CocoaAsyncSocket.modulemap */,
++-				2EF436B09B560AF848B4D98C55F61FE0 /* CocoaAsyncSocket.xcconfig */,
++-				8E98378F2CF04086E8088C6A14347C33 /* CocoaAsyncSocket-dummy.m */,
++-				75F9206B99E5B5423D6B61D755C011CC /* CocoaAsyncSocket-prefix.pch */,
++-				D6D9F3F23E9E53DAFA379995A9E13E58 /* CocoaAsyncSocket-umbrella.h */,
++-				8897EF90B2D55946A61AD5A10C38B75C /* Info.plist */,
+++				B8A9724351936E298AF17D9B38E4AA57 /* Pods-CRMCall092016 */,
++ 			);
++-			name = "Support Files";
++-			path = "../Target Support Files/CocoaAsyncSocket";
+++			name = "Targets Support Files";
++ 			sourceTree = "<group>";
++ 		};
++-		6BAE03FB7B81BD8D4DD2F62159D790F2 /* Targets Support Files */ = {
+++		71982584ECA5E3C8D7B92572F29AA8DA /* Alamofire */ = {
++ 			isa = PBXGroup;
++ 			children = (
++-				B8A9724351936E298AF17D9B38E4AA57 /* Pods-CRMCall092016 */,
+++				E01E26D8749A98484E8DD7726148EC20 /* Alamofire.swift */,
+++				2AA16A476F2771B1B74FB14947F24E02 /* Download.swift */,
+++				EF9B2AFCE03477C50F07C48E33A463FF /* Error.swift */,
+++				7031D4000017108DC80504B065340368 /* Manager.swift */,
+++				AF650B57C6596DA153F5900EA61CC5A7 /* MultipartFormData.swift */,
+++				64E8485F5FCFC4FDB8D6CE0BFC980C58 /* NetworkReachabilityManager.swift */,
+++				ECD84F348832D77D5059D066749346A4 /* Notifications.swift */,
+++				125D17DF5E6A1A7420D1F1A975DD7EB9 /* ParameterEncoding.swift */,
+++				F14E627DC549703B46315BBCCDD362AE /* Request.swift */,
+++				DDE49D9DCF93A390B23188C67221ECA8 /* Response.swift */,
+++				B7C925E8849659F01450961BB1FFA23D /* ResponseSerialization.swift */,
+++				E2A2BD6EE0720A5171EF80B09CFD4224 /* Result.swift */,
+++				62073F3761055A46F154B11F061A08AF /* ServerTrustPolicy.swift */,
+++				5B2BB4979BAD0CF7156F74E71CAD3041 /* Stream.swift */,
+++				D77E19C3839748928122D0DEAC1BA1F4 /* Timeline.swift */,
+++				8991BF3DBE2A9AD6CB35BF27297CC8FD /* Upload.swift */,
+++				84395B1E623BD8F9DE2F7E16CA43251F /* Validation.swift */,
+++				01B95DBFE667B00CC6977BD31CE4F3B2 /* Support Files */,
++ 			);
++-			name = "Targets Support Files";
+++			path = Alamofire;
++ 			sourceTree = "<group>";
++ 		};
++ 		7DB346D0F39D3F0E887471402A8071AB = {
++@@ -127,19 +253,24 @@
++ 			children = (
++ 				93A4A3777CF96A4AAC1D13BA6DCCEA73 /* Podfile */,
++ 				96D996393384F21972E2DD81788EE22C /* Frameworks */,
++-				3750E20CAB4987ACB8AB27B6C25C1D60 /* Pods */,
++-				89C122A58C976DAED8C4212AAC8AFB74 /* Products */,
+++				0D755FC3415F3E7464CA4F3CD0BEF91A /* Pods */,
+++				6B7D6DAD89010B625FD7D6631AB356FF /* Products */,
++ 				6BAE03FB7B81BD8D4DD2F62159D790F2 /* Targets Support Files */,
++ 			);
++ 			sourceTree = "<group>";
++ 		};
++-		89C122A58C976DAED8C4212AAC8AFB74 /* Products */ = {
+++		93A0D837347BC14B6101239D93030AC4 /* Support Files */ = {
++ 			isa = PBXGroup;
++ 			children = (
++-				02F721520946E3ED0F5A5A2CBC3AA2F1 /* CocoaAsyncSocket.framework */,
++-				607059846E83C82CDCE4A0DC0CC4E112 /* Pods_CRMCall092016.framework */,
+++				E0D2633544BCFC90D4DD429B2FE884D7 /* CocoaAsyncSocket.modulemap */,
+++				421DBE2696953979E49FD7BBE38C3847 /* CocoaAsyncSocket.xcconfig */,
+++				ABC09E1DCC49261B7629CD82626C21FA /* CocoaAsyncSocket-dummy.m */,
+++				0E50EC0B768D99DF8AA54CEF00DCD620 /* CocoaAsyncSocket-prefix.pch */,
+++				5F955B5F2D78E83D6BA538909B360F55 /* CocoaAsyncSocket-umbrella.h */,
+++				875107E5B1CD30A24F90CC34B1452862 /* Info.plist */,
++ 			);
++-			name = Products;
+++			name = "Support Files";
+++			path = "../Target Support Files/CocoaAsyncSocket";
++ 			sourceTree = "<group>";
++ 		};
++ 		96D996393384F21972E2DD81788EE22C /* Frameworks */ = {
++@@ -150,26 +281,17 @@
++ 			name = Frameworks;
++ 			sourceTree = "<group>";
++ 		};
++-		982AE8715AD34D5D99A50B615809B1F1 /* GCD */ = {
+++		B4AEF557D0B20590FFF106A8AB52A7AE /* GCD */ = {
++ 			isa = PBXGroup;
++ 			children = (
++-				4CA8FFB2F306345702A20E3FE7CE6EF7 /* GCDAsyncSocket.h */,
++-				1D696A8CDEBE87CDE80E57AE0E305C5F /* GCDAsyncSocket.m */,
++-				84A110336E93C3E786F9B32956E29A3E /* GCDAsyncUdpSocket.h */,
++-				098765466D421180F3953EF8EEDDCEF1 /* GCDAsyncUdpSocket.m */,
+++				D1519185135D5351111F109E89AF0F64 /* GCDAsyncSocket.h */,
+++				FB4019B4F3DF5D7B015227F280ABBE9C /* GCDAsyncSocket.m */,
+++				540A59953BD2C3205CF5F2CE7B7BFC1F /* GCDAsyncUdpSocket.h */,
+++				ED466E93414A976222AFAF321E9AF11C /* GCDAsyncUdpSocket.m */,
++ 			);
++ 			name = GCD;
++ 			sourceTree = "<group>";
++ 		};
++-		B16CCCC916CD9D13BBF53EA0C69C4615 /* CocoaAsyncSocket */ = {
++-			isa = PBXGroup;
++-			children = (
++-				982AE8715AD34D5D99A50B615809B1F1 /* GCD */,
++-				557C7CF8D4466D636F16673BAB31EEF1 /* Support Files */,
++-			);
++-			path = CocoaAsyncSocket;
++-			sourceTree = "<group>";
++-		};
++ 		B8A9724351936E298AF17D9B38E4AA57 /* Pods-CRMCall092016 */ = {
++ 			isa = PBXGroup;
++ 			children = (
++@@ -188,63 +310,148 @@
++ 			path = "Target Support Files/Pods-CRMCall092016";
++ 			sourceTree = "<group>";
++ 		};
+++		DE3FD61F7CCDAC4566744964D80318A9 /* Support Files */ = {
+++			isa = PBXGroup;
+++			children = (
+++				C3D72D35EB73312A9630B6441B6D65DC /* Info.plist */,
+++				BC6E9E2C5DCCD36683912082D39D119C /* SWXMLHash.modulemap */,
+++				3E8CB71BFFC59E2E3BA715D7AEF30B56 /* SWXMLHash.xcconfig */,
+++				2BDE952759498BFF23C89A0302BD584C /* SWXMLHash-dummy.m */,
+++				530C70E607990B234619FFA25EF6C451 /* SWXMLHash-prefix.pch */,
+++				5F0B453266F2DE0B098E2B994FE716CD /* SWXMLHash-umbrella.h */,
+++			);
+++			name = "Support Files";
+++			path = "../Target Support Files/SWXMLHash";
+++			sourceTree = "<group>";
+++		};
+++		E7FACF9BF4BA24608BB789AF7D8A102F /* SWXMLHash */ = {
+++			isa = PBXGroup;
+++			children = (
+++				7201E46C9812098E184043C076154118 /* SWXMLHash.swift */,
+++				CE89954F8A8211757E95D5E68308F52F /* SWXMLHash+TypeConversion.swift */,
+++				DE3FD61F7CCDAC4566744964D80318A9 /* Support Files */,
+++			);
+++			path = SWXMLHash;
+++			sourceTree = "<group>";
+++		};
+++		FF778D1838A3F60CF9CF2403E182E955 /* CocoaAsyncSocket */ = {
+++			isa = PBXGroup;
+++			children = (
+++				B4AEF557D0B20590FFF106A8AB52A7AE /* GCD */,
+++				93A0D837347BC14B6101239D93030AC4 /* Support Files */,
+++			);
+++			path = CocoaAsyncSocket;
+++			sourceTree = "<group>";
+++		};
++ /* End PBXGroup section */
++ 
++ /* Begin PBXHeadersBuildPhase section */
++-		31CCA99E660F3538D5DF69A9EED7821E /* Headers */ = {
+++		41F6279547BA8C6095CA882FB1059614 /* Headers */ = {
++ 			isa = PBXHeadersBuildPhase;
++ 			buildActionMask = 2147483647;
++ 			files = (
++-				AC9CFE1768573A23FAACC873AAFA8EA1 /* Pods-CRMCall092016-umbrella.h in Headers */,
+++				ACFE60AB34A7FEF697E6EEFB62436A8D /* CocoaAsyncSocket-umbrella.h in Headers */,
+++				6AAFA2F344A6B58F728AF958F3FE6D89 /* GCDAsyncSocket.h in Headers */,
+++				92AED971B91C640191A5ABA1567FE358 /* GCDAsyncUdpSocket.h in Headers */,
++ 			);
++ 			runOnlyForDeploymentPostprocessing = 0;
++ 		};
++-		41F6279547BA8C6095CA882FB1059614 /* Headers */ = {
+++		97EF195315ED04EDCCAC31D70A583B2E /* Headers */ = {
++ 			isa = PBXHeadersBuildPhase;
++ 			buildActionMask = 2147483647;
++ 			files = (
++-				ACFE60AB34A7FEF697E6EEFB62436A8D /* CocoaAsyncSocket-umbrella.h in Headers */,
++-				6AAFA2F344A6B58F728AF958F3FE6D89 /* GCDAsyncSocket.h in Headers */,
++-				92AED971B91C640191A5ABA1567FE358 /* GCDAsyncUdpSocket.h in Headers */,
+++				1E5602BF3A87A7353DA77A2EE51EED93 /* SWXMLHash-umbrella.h in Headers */,
+++			);
+++			runOnlyForDeploymentPostprocessing = 0;
+++		};
+++		EFDF3B631BBB965A372347705CA14854 /* Headers */ = {
+++			isa = PBXHeadersBuildPhase;
+++			buildActionMask = 2147483647;
+++			files = (
+++				9469DF81ECB494E84675969B5E13374C /* Alamofire-umbrella.h in Headers */,
+++			);
+++			runOnlyForDeploymentPostprocessing = 0;
+++		};
+++		FA82F97F3394B160E11E80A19D26FB84 /* Headers */ = {
+++			isa = PBXHeadersBuildPhase;
+++			buildActionMask = 2147483647;
+++			files = (
+++				A2BFC3BB72F0CAF82F3CEF224DE6752D /* Pods-CRMCall092016-umbrella.h in Headers */,
++ 			);
++ 			runOnlyForDeploymentPostprocessing = 0;
++ 		};
++ /* End PBXHeadersBuildPhase section */
++ 
++ /* Begin PBXNativeTarget section */
++-		B37E19CA872A7535725D1E1946E5C271 /* CocoaAsyncSocket */ = {
+++		67C63D588DA997BFF7D3C999DA7A5A23 /* SWXMLHash */ = {
++ 			isa = PBXNativeTarget;
++-			buildConfigurationList = 551479B287B69C7447DFBC6CA5EADF0B /* Build configuration list for PBXNativeTarget "CocoaAsyncSocket" */;
+++			buildConfigurationList = 659D84DB6B9CFB1996FB238A044A68A1 /* Build configuration list for PBXNativeTarget "SWXMLHash" */;
++ 			buildPhases = (
++-				217D9EA001DB8A7A00EBCC79A99280A3 /* Sources */,
++-				F324C34599273EC2FE98A8DA30CE302F /* Frameworks */,
++-				41F6279547BA8C6095CA882FB1059614 /* Headers */,
+++				6266862713B40A60E6D5BC64F94F70F7 /* Sources */,
+++				057374DBF94AB4C711C95D3C81644697 /* Frameworks */,
+++				97EF195315ED04EDCCAC31D70A583B2E /* Headers */,
++ 			);
++ 			buildRules = (
++ 			);
++ 			dependencies = (
++ 			);
++-			name = CocoaAsyncSocket;
++-			productName = CocoaAsyncSocket;
++-			productReference = 02F721520946E3ED0F5A5A2CBC3AA2F1 /* CocoaAsyncSocket.framework */;
+++			name = SWXMLHash;
+++			productName = SWXMLHash;
+++			productReference = C608DAD3E8D1E316C917482D1150C9E4 /* SWXMLHash.framework */;
++ 			productType = "com.apple.product-type.framework";
++ 		};
++-		ED9EA20B7A8CD0AA34A09F4F5CB87BEB /* Pods-CRMCall092016 */ = {
+++		6A0818B9C68C8B9F82A2B6E85576006B /* Pods-CRMCall092016 */ = {
++ 			isa = PBXNativeTarget;
++-			buildConfigurationList = B03ED2000B166CDC5CD804541F3FA0E9 /* Build configuration list for PBXNativeTarget "Pods-CRMCall092016" */;
+++			buildConfigurationList = 238EE128C1BFD4365A9742EBAD4D8641 /* Build configuration list for PBXNativeTarget "Pods-CRMCall092016" */;
++ 			buildPhases = (
++-				912F583C9F47FD8040B2EC902E7C303C /* Sources */,
++-				EDB9B30DC8B486582976DE7ABD029042 /* Frameworks */,
++-				31CCA99E660F3538D5DF69A9EED7821E /* Headers */,
+++				32B5968CACDE4124ECD593156BE64DF2 /* Sources */,
+++				88126D8EF116B657E2FD26AB2C7D7C76 /* Frameworks */,
+++				FA82F97F3394B160E11E80A19D26FB84 /* Headers */,
++ 			);
++ 			buildRules = (
++ 			);
++ 			dependencies = (
++-				AC6BD82C86275A2C3A88628826BFD192 /* PBXTargetDependency */,
+++				71045A2931E715998C8E89599499B57E /* PBXTargetDependency */,
+++				868B73927BF599C3CA77C6C45D6DD6E1 /* PBXTargetDependency */,
+++				0DC5F42F629BD17706FF7A44455C12F4 /* PBXTargetDependency */,
++ 			);
++ 			name = "Pods-CRMCall092016";
++ 			productName = "Pods-CRMCall092016";
++-			productReference = 607059846E83C82CDCE4A0DC0CC4E112 /* Pods_CRMCall092016.framework */;
+++			productReference = 26831C2816B1A793F64FFC713F267BB3 /* Pods_CRMCall092016.framework */;
+++			productType = "com.apple.product-type.framework";
+++		};
+++		79C040AFDDCE1BCBF6D8B5EB0B85887F /* Alamofire */ = {
+++			isa = PBXNativeTarget;
+++			buildConfigurationList = 3CFB42910790CF0BDBCCEBAACD6B9367 /* Build configuration list for PBXNativeTarget "Alamofire" */;
+++			buildPhases = (
+++				95CC2C7E06DC188A05DAAEE9CAA555A3 /* Sources */,
+++				86631BCDD6995CFD2A8A7716F3673282 /* Frameworks */,
+++				EFDF3B631BBB965A372347705CA14854 /* Headers */,
+++			);
+++			buildRules = (
+++			);
+++			dependencies = (
+++			);
+++			name = Alamofire;
+++			productName = Alamofire;
+++			productReference = 8D365AF8CA284382154A3FCADC2924CC /* Alamofire.framework */;
+++			productType = "com.apple.product-type.framework";
+++		};
+++		B37E19CA872A7535725D1E1946E5C271 /* CocoaAsyncSocket */ = {
+++			isa = PBXNativeTarget;
+++			buildConfigurationList = 551479B287B69C7447DFBC6CA5EADF0B /* Build configuration list for PBXNativeTarget "CocoaAsyncSocket" */;
+++			buildPhases = (
+++				217D9EA001DB8A7A00EBCC79A99280A3 /* Sources */,
+++				F324C34599273EC2FE98A8DA30CE302F /* Frameworks */,
+++				41F6279547BA8C6095CA882FB1059614 /* Headers */,
+++			);
+++			buildRules = (
+++			);
+++			dependencies = (
+++			);
+++			name = CocoaAsyncSocket;
+++			productName = CocoaAsyncSocket;
+++			productReference = 7911AB14649A75D2129B7AF99D9F284F /* CocoaAsyncSocket.framework */;
++ 			productType = "com.apple.product-type.framework";
++ 		};
++ /* End PBXNativeTarget section */
++@@ -264,12 +471,14 @@
++ 				en,
++ 			);
++ 			mainGroup = 7DB346D0F39D3F0E887471402A8071AB;
++-			productRefGroup = 89C122A58C976DAED8C4212AAC8AFB74 /* Products */;
+++			productRefGroup = 6B7D6DAD89010B625FD7D6631AB356FF /* Products */;
++ 			projectDirPath = "";
++ 			projectRoot = "";
++ 			targets = (
+++				79C040AFDDCE1BCBF6D8B5EB0B85887F /* Alamofire */,
++ 				B37E19CA872A7535725D1E1946E5C271 /* CocoaAsyncSocket */,
++-				ED9EA20B7A8CD0AA34A09F4F5CB87BEB /* Pods-CRMCall092016 */,
+++				6A0818B9C68C8B9F82A2B6E85576006B /* Pods-CRMCall092016 */,
+++				67C63D588DA997BFF7D3C999DA7A5A23 /* SWXMLHash */,
++ 			);
++ 		};
++ /* End PBXProject section */
++@@ -285,22 +494,69 @@
++ 			);
++ 			runOnlyForDeploymentPostprocessing = 0;
++ 		};
++-		912F583C9F47FD8040B2EC902E7C303C /* Sources */ = {
+++		32B5968CACDE4124ECD593156BE64DF2 /* Sources */ = {
++ 			isa = PBXSourcesBuildPhase;
++ 			buildActionMask = 2147483647;
++ 			files = (
++-				F32AB407361604D69C1D26A59004F99F /* Pods-CRMCall092016-dummy.m in Sources */,
+++				515FD66E0570F0E6B6D6F6B4AE427CC2 /* Pods-CRMCall092016-dummy.m in Sources */,
+++			);
+++			runOnlyForDeploymentPostprocessing = 0;
+++		};
+++		6266862713B40A60E6D5BC64F94F70F7 /* Sources */ = {
+++			isa = PBXSourcesBuildPhase;
+++			buildActionMask = 2147483647;
+++			files = (
+++				723E6C875E842A6DA996001BDFAF520E /* SWXMLHash+TypeConversion.swift in Sources */,
+++				7560CA92AA1E62C1C39BBA309960C36A /* SWXMLHash-dummy.m in Sources */,
+++				72504A8A3AD0249F8A37515A72C2DF98 /* SWXMLHash.swift in Sources */,
+++			);
+++			runOnlyForDeploymentPostprocessing = 0;
+++		};
+++		95CC2C7E06DC188A05DAAEE9CAA555A3 /* Sources */ = {
+++			isa = PBXSourcesBuildPhase;
+++			buildActionMask = 2147483647;
+++			files = (
+++				ADF19C953CE2A7D0B72EC93A81FCCC26 /* Alamofire-dummy.m in Sources */,
+++				8EB11202167FCDDF1257AAAB1D1FB244 /* Alamofire.swift in Sources */,
+++				5CB05FBCB32D21E194B5ECF680CB6AE0 /* Download.swift in Sources */,
+++				095406039B4D371E48D08B38A2975AC8 /* Error.swift in Sources */,
+++				4081EA628AF0B73AC51FFB9D7AB3B89E /* Manager.swift in Sources */,
+++				C7B6DD7C0456C50289A2C381DFE9FA3F /* MultipartFormData.swift in Sources */,
+++				34CCDCA848A701466256BC2927DA8856 /* NetworkReachabilityManager.swift in Sources */,
+++				BE41196F6A3903E59C3306FE3F8B43FE /* Notifications.swift in Sources */,
+++				C0DB70AB368765DC64BFB5FEA75E0696 /* ParameterEncoding.swift in Sources */,
+++				EFE92E8D3813DD26E78E93EEAF6D7E7E /* Request.swift in Sources */,
+++				62E8346F03C03E7F4D631361F325689E /* Response.swift in Sources */,
+++				3EA8F215C9C1432D74E5CCA4834AA8C0 /* ResponseSerialization.swift in Sources */,
+++				AA314156AC500125F4078EE968DB14C6 /* Result.swift in Sources */,
+++				7B48852C4D848FA2DA416A98F6425869 /* ServerTrustPolicy.swift in Sources */,
+++				AE4CF87C02C042DF13ED5B21C4FDC1E0 /* Stream.swift in Sources */,
+++				16102E4E35FAA0FC4161282FECE56469 /* Timeline.swift in Sources */,
+++				5BC19E6E0F199276003F0AF96838BCE5 /* Upload.swift in Sources */,
+++				2D3405986FC586FA6C0A5E0B6BA7E64E /* Validation.swift in Sources */,
++ 			);
++ 			runOnlyForDeploymentPostprocessing = 0;
++ 		};
++ /* End PBXSourcesBuildPhase section */
++ 
++ /* Begin PBXTargetDependency section */
++-		AC6BD82C86275A2C3A88628826BFD192 /* PBXTargetDependency */ = {
+++		0DC5F42F629BD17706FF7A44455C12F4 /* PBXTargetDependency */ = {
+++			isa = PBXTargetDependency;
+++			name = SWXMLHash;
+++			target = 67C63D588DA997BFF7D3C999DA7A5A23 /* SWXMLHash */;
+++			targetProxy = A98B988E365E15D4E2D8C73D59A5F0EE /* PBXContainerItemProxy */;
+++		};
+++		71045A2931E715998C8E89599499B57E /* PBXTargetDependency */ = {
+++			isa = PBXTargetDependency;
+++			name = Alamofire;
+++			target = 79C040AFDDCE1BCBF6D8B5EB0B85887F /* Alamofire */;
+++			targetProxy = 1F41FB1990B1F3A39ADE4AEDF3C3DE3A /* PBXContainerItemProxy */;
+++		};
+++		868B73927BF599C3CA77C6C45D6DD6E1 /* PBXTargetDependency */ = {
++ 			isa = PBXTargetDependency;
++ 			name = CocoaAsyncSocket;
++ 			target = B37E19CA872A7535725D1E1946E5C271 /* CocoaAsyncSocket */;
++-			targetProxy = FEE18F96712D8E1EC56662C660E9DB97 /* PBXContainerItemProxy */;
+++			targetProxy = A6ED361CEE1ECD9230711154275A9274 /* PBXContainerItemProxy */;
++ 		};
++ /* End PBXTargetDependency section */
++ 
++@@ -349,7 +605,7 @@
++ 		};
++ 		22E1B933B435A6CDC7F2DDEA5826ADB0 /* Release */ = {
++ 			isa = XCBuildConfiguration;
++-			baseConfigurationReference = 2EF436B09B560AF848B4D98C55F61FE0 /* CocoaAsyncSocket.xcconfig */;
+++			baseConfigurationReference = 421DBE2696953979E49FD7BBE38C3847 /* CocoaAsyncSocket.xcconfig */;
++ 			buildSettings = {
++ 				CODE_SIGN_IDENTITY = "-";
++ 				COMBINE_HIDPI_IMAGES = YES;
++@@ -377,40 +633,6 @@
++ 			};
++ 			name = Release;
++ 		};
++-		521DC92EB5E96081859D95B644FA15CF /* Debug */ = {
++-			isa = XCBuildConfiguration;
++-			baseConfigurationReference = 11566DE119910F4F8728001B55582E0A /* Pods-CRMCall092016.debug.xcconfig */;
++-			buildSettings = {
++-				CODE_SIGN_IDENTITY = "-";
++-				COMBINE_HIDPI_IMAGES = YES;
++-				CURRENT_PROJECT_VERSION = 1;
++-				DEBUG_INFORMATION_FORMAT = dwarf;
++-				DEFINES_MODULE = YES;
++-				DYLIB_COMPATIBILITY_VERSION = 1;
++-				DYLIB_CURRENT_VERSION = 1;
++-				DYLIB_INSTALL_NAME_BASE = "@rpath";
++-				ENABLE_STRICT_OBJC_MSGSEND = YES;
++-				FRAMEWORK_VERSION = A;
++-				GCC_NO_COMMON_BLOCKS = YES;
++-				INFOPLIST_FILE = "Target Support Files/Pods-CRMCall092016/Info.plist";
++-				INSTALL_PATH = "$(LOCAL_LIBRARY_DIR)/Frameworks";
++-				LD_RUNPATH_SEARCH_PATHS = "$(inherited) @executable_path/../Frameworks @loader_path/Frameworks";
++-				MACH_O_TYPE = staticlib;
++-				MACOSX_DEPLOYMENT_TARGET = 10.11;
++-				MODULEMAP_FILE = "Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016.modulemap";
++-				MTL_ENABLE_DEBUG_INFO = YES;
++-				OTHER_LDFLAGS = "";
++-				OTHER_LIBTOOLFLAGS = "";
++-				PODS_ROOT = "$(SRCROOT)";
++-				PRODUCT_BUNDLE_IDENTIFIER = "org.cocoapods.${PRODUCT_NAME:rfc1034identifier}";
++-				PRODUCT_NAME = Pods_CRMCall092016;
++-				SDKROOT = macosx;
++-				SKIP_INSTALL = YES;
++-				VERSIONING_SYSTEM = "apple-generic";
++-				VERSION_INFO_PREFIX = "";
++-			};
++-			name = Debug;
++-		};
++ 		578820E498FFD85CA5D93A33D365FBED /* Release */ = {
++ 			isa = XCBuildConfiguration;
++ 			buildSettings = {
++@@ -449,9 +671,135 @@
++ 			};
++ 			name = Release;
++ 		};
+++		6CE0C113B81940025E3A2FB05117B621 /* Release */ = {
+++			isa = XCBuildConfiguration;
+++			baseConfigurationReference = 3E8CB71BFFC59E2E3BA715D7AEF30B56 /* SWXMLHash.xcconfig */;
+++			buildSettings = {
+++				CODE_SIGN_IDENTITY = "-";
+++				COMBINE_HIDPI_IMAGES = YES;
+++				CURRENT_PROJECT_VERSION = 1;
+++				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
+++				DEFINES_MODULE = YES;
+++				DYLIB_COMPATIBILITY_VERSION = 1;
+++				DYLIB_CURRENT_VERSION = 1;
+++				DYLIB_INSTALL_NAME_BASE = "@rpath";
+++				ENABLE_STRICT_OBJC_MSGSEND = YES;
+++				FRAMEWORK_VERSION = A;
+++				GCC_NO_COMMON_BLOCKS = YES;
+++				GCC_PREFIX_HEADER = "Target Support Files/SWXMLHash/SWXMLHash-prefix.pch";
+++				INFOPLIST_FILE = "Target Support Files/SWXMLHash/Info.plist";
+++				INSTALL_PATH = "$(LOCAL_LIBRARY_DIR)/Frameworks";
+++				LD_RUNPATH_SEARCH_PATHS = "$(inherited) @executable_path/../Frameworks @loader_path/Frameworks";
+++				MACOSX_DEPLOYMENT_TARGET = 10.9;
+++				MODULEMAP_FILE = "Target Support Files/SWXMLHash/SWXMLHash.modulemap";
+++				MTL_ENABLE_DEBUG_INFO = NO;
+++				PRODUCT_NAME = SWXMLHash;
+++				SDKROOT = macosx;
+++				SKIP_INSTALL = YES;
+++				VERSIONING_SYSTEM = "apple-generic";
+++				VERSION_INFO_PREFIX = "";
+++			};
+++			name = Release;
+++		};
+++		81B3096945D568104AC14EE4F805950B /* Release */ = {
+++			isa = XCBuildConfiguration;
+++			baseConfigurationReference = 6D0E27C7C865AC6950E934CB59C487B1 /* Alamofire.xcconfig */;
+++			buildSettings = {
+++				CODE_SIGN_IDENTITY = "-";
+++				COMBINE_HIDPI_IMAGES = YES;
+++				CURRENT_PROJECT_VERSION = 1;
+++				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
+++				DEFINES_MODULE = YES;
+++				DYLIB_COMPATIBILITY_VERSION = 1;
+++				DYLIB_CURRENT_VERSION = 1;
+++				DYLIB_INSTALL_NAME_BASE = "@rpath";
+++				ENABLE_STRICT_OBJC_MSGSEND = YES;
+++				FRAMEWORK_VERSION = A;
+++				GCC_NO_COMMON_BLOCKS = YES;
+++				GCC_PREFIX_HEADER = "Target Support Files/Alamofire/Alamofire-prefix.pch";
+++				INFOPLIST_FILE = "Target Support Files/Alamofire/Info.plist";
+++				INSTALL_PATH = "$(LOCAL_LIBRARY_DIR)/Frameworks";
+++				LD_RUNPATH_SEARCH_PATHS = "$(inherited) @executable_path/../Frameworks @loader_path/Frameworks";
+++				MACOSX_DEPLOYMENT_TARGET = 10.9;
+++				MODULEMAP_FILE = "Target Support Files/Alamofire/Alamofire.modulemap";
+++				MTL_ENABLE_DEBUG_INFO = NO;
+++				PRODUCT_NAME = Alamofire;
+++				SDKROOT = macosx;
+++				SKIP_INSTALL = YES;
+++				VERSIONING_SYSTEM = "apple-generic";
+++				VERSION_INFO_PREFIX = "";
+++			};
+++			name = Release;
+++		};
+++		82B1EC5E8815E78991717D970C44B8D8 /* Debug */ = {
+++			isa = XCBuildConfiguration;
+++			baseConfigurationReference = 6D0E27C7C865AC6950E934CB59C487B1 /* Alamofire.xcconfig */;
+++			buildSettings = {
+++				CODE_SIGN_IDENTITY = "-";
+++				COMBINE_HIDPI_IMAGES = YES;
+++				CURRENT_PROJECT_VERSION = 1;
+++				DEBUG_INFORMATION_FORMAT = dwarf;
+++				DEFINES_MODULE = YES;
+++				DYLIB_COMPATIBILITY_VERSION = 1;
+++				DYLIB_CURRENT_VERSION = 1;
+++				DYLIB_INSTALL_NAME_BASE = "@rpath";
+++				ENABLE_STRICT_OBJC_MSGSEND = YES;
+++				FRAMEWORK_VERSION = A;
+++				GCC_NO_COMMON_BLOCKS = YES;
+++				GCC_PREFIX_HEADER = "Target Support Files/Alamofire/Alamofire-prefix.pch";
+++				INFOPLIST_FILE = "Target Support Files/Alamofire/Info.plist";
+++				INSTALL_PATH = "$(LOCAL_LIBRARY_DIR)/Frameworks";
+++				LD_RUNPATH_SEARCH_PATHS = "$(inherited) @executable_path/../Frameworks @loader_path/Frameworks";
+++				MACOSX_DEPLOYMENT_TARGET = 10.9;
+++				MODULEMAP_FILE = "Target Support Files/Alamofire/Alamofire.modulemap";
+++				MTL_ENABLE_DEBUG_INFO = YES;
+++				PRODUCT_NAME = Alamofire;
+++				SDKROOT = macosx;
+++				SKIP_INSTALL = YES;
+++				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
+++				VERSIONING_SYSTEM = "apple-generic";
+++				VERSION_INFO_PREFIX = "";
+++			};
+++			name = Debug;
+++		};
+++		ABD52582A0CA0880395B592CF2D53A8C /* Debug */ = {
+++			isa = XCBuildConfiguration;
+++			baseConfigurationReference = 11566DE119910F4F8728001B55582E0A /* Pods-CRMCall092016.debug.xcconfig */;
+++			buildSettings = {
+++				CODE_SIGN_IDENTITY = "-";
+++				COMBINE_HIDPI_IMAGES = YES;
+++				CURRENT_PROJECT_VERSION = 1;
+++				DEBUG_INFORMATION_FORMAT = dwarf;
+++				DEFINES_MODULE = YES;
+++				DYLIB_COMPATIBILITY_VERSION = 1;
+++				DYLIB_CURRENT_VERSION = 1;
+++				DYLIB_INSTALL_NAME_BASE = "@rpath";
+++				ENABLE_STRICT_OBJC_MSGSEND = YES;
+++				FRAMEWORK_VERSION = A;
+++				GCC_NO_COMMON_BLOCKS = YES;
+++				INFOPLIST_FILE = "Target Support Files/Pods-CRMCall092016/Info.plist";
+++				INSTALL_PATH = "$(LOCAL_LIBRARY_DIR)/Frameworks";
+++				LD_RUNPATH_SEARCH_PATHS = "$(inherited) @executable_path/../Frameworks @loader_path/Frameworks";
+++				MACH_O_TYPE = staticlib;
+++				MACOSX_DEPLOYMENT_TARGET = 10.11;
+++				MODULEMAP_FILE = "Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016.modulemap";
+++				MTL_ENABLE_DEBUG_INFO = YES;
+++				OTHER_LDFLAGS = "";
+++				OTHER_LIBTOOLFLAGS = "";
+++				PODS_ROOT = "$(SRCROOT)";
+++				PRODUCT_BUNDLE_IDENTIFIER = "org.cocoapods.${PRODUCT_NAME:rfc1034identifier}";
+++				PRODUCT_NAME = Pods_CRMCall092016;
+++				SDKROOT = macosx;
+++				SKIP_INSTALL = YES;
+++				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
+++				VERSIONING_SYSTEM = "apple-generic";
+++				VERSION_INFO_PREFIX = "";
+++			};
+++			name = Debug;
+++		};
++ 		AC06A033185F3EDFA2433C8F90A0A7F2 /* Debug */ = {
++ 			isa = XCBuildConfiguration;
++-			baseConfigurationReference = 2EF436B09B560AF848B4D98C55F61FE0 /* CocoaAsyncSocket.xcconfig */;
+++			baseConfigurationReference = 421DBE2696953979E49FD7BBE38C3847 /* CocoaAsyncSocket.xcconfig */;
++ 			buildSettings = {
++ 				CODE_SIGN_IDENTITY = "-";
++ 				COMBINE_HIDPI_IMAGES = YES;
++@@ -479,7 +827,38 @@
++ 			};
++ 			name = Debug;
++ 		};
++-		E4DEC30E809251C58B0C7BF7802F5CFD /* Release */ = {
+++		AC82647F4C2BE5E8CCF859C6D6F8141E /* Debug */ = {
+++			isa = XCBuildConfiguration;
+++			baseConfigurationReference = 3E8CB71BFFC59E2E3BA715D7AEF30B56 /* SWXMLHash.xcconfig */;
+++			buildSettings = {
+++				CODE_SIGN_IDENTITY = "-";
+++				COMBINE_HIDPI_IMAGES = YES;
+++				CURRENT_PROJECT_VERSION = 1;
+++				DEBUG_INFORMATION_FORMAT = dwarf;
+++				DEFINES_MODULE = YES;
+++				DYLIB_COMPATIBILITY_VERSION = 1;
+++				DYLIB_CURRENT_VERSION = 1;
+++				DYLIB_INSTALL_NAME_BASE = "@rpath";
+++				ENABLE_STRICT_OBJC_MSGSEND = YES;
+++				FRAMEWORK_VERSION = A;
+++				GCC_NO_COMMON_BLOCKS = YES;
+++				GCC_PREFIX_HEADER = "Target Support Files/SWXMLHash/SWXMLHash-prefix.pch";
+++				INFOPLIST_FILE = "Target Support Files/SWXMLHash/Info.plist";
+++				INSTALL_PATH = "$(LOCAL_LIBRARY_DIR)/Frameworks";
+++				LD_RUNPATH_SEARCH_PATHS = "$(inherited) @executable_path/../Frameworks @loader_path/Frameworks";
+++				MACOSX_DEPLOYMENT_TARGET = 10.9;
+++				MODULEMAP_FILE = "Target Support Files/SWXMLHash/SWXMLHash.modulemap";
+++				MTL_ENABLE_DEBUG_INFO = YES;
+++				PRODUCT_NAME = SWXMLHash;
+++				SDKROOT = macosx;
+++				SKIP_INSTALL = YES;
+++				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
+++				VERSIONING_SYSTEM = "apple-generic";
+++				VERSION_INFO_PREFIX = "";
+++			};
+++			name = Debug;
+++		};
+++		D1217757FF60B0DDC6ED1BAE3F3421A4 /* Release */ = {
++ 			isa = XCBuildConfiguration;
++ 			baseConfigurationReference = 3344C80F9295CA22275F8A0581FF4EAB /* Pods-CRMCall092016.release.xcconfig */;
++ 			buildSettings = {
++@@ -516,6 +895,15 @@
++ /* End XCBuildConfiguration section */
++ 
++ /* Begin XCConfigurationList section */
+++		238EE128C1BFD4365A9742EBAD4D8641 /* Build configuration list for PBXNativeTarget "Pods-CRMCall092016" */ = {
+++			isa = XCConfigurationList;
+++			buildConfigurations = (
+++				ABD52582A0CA0880395B592CF2D53A8C /* Debug */,
+++				D1217757FF60B0DDC6ED1BAE3F3421A4 /* Release */,
+++			);
+++			defaultConfigurationIsVisible = 0;
+++			defaultConfigurationName = Release;
+++		};
++ 		2D8E8EC45A3A1A1D94AE762CB5028504 /* Build configuration list for PBXProject "Pods" */ = {
++ 			isa = XCConfigurationList;
++ 			buildConfigurations = (
++@@ -525,6 +913,15 @@
++ 			defaultConfigurationIsVisible = 0;
++ 			defaultConfigurationName = Release;
++ 		};
+++		3CFB42910790CF0BDBCCEBAACD6B9367 /* Build configuration list for PBXNativeTarget "Alamofire" */ = {
+++			isa = XCConfigurationList;
+++			buildConfigurations = (
+++				82B1EC5E8815E78991717D970C44B8D8 /* Debug */,
+++				81B3096945D568104AC14EE4F805950B /* Release */,
+++			);
+++			defaultConfigurationIsVisible = 0;
+++			defaultConfigurationName = Release;
+++		};
++ 		551479B287B69C7447DFBC6CA5EADF0B /* Build configuration list for PBXNativeTarget "CocoaAsyncSocket" */ = {
++ 			isa = XCConfigurationList;
++ 			buildConfigurations = (
++@@ -534,11 +931,11 @@
++ 			defaultConfigurationIsVisible = 0;
++ 			defaultConfigurationName = Release;
++ 		};
++-		B03ED2000B166CDC5CD804541F3FA0E9 /* Build configuration list for PBXNativeTarget "Pods-CRMCall092016" */ = {
+++		659D84DB6B9CFB1996FB238A044A68A1 /* Build configuration list for PBXNativeTarget "SWXMLHash" */ = {
++ 			isa = XCConfigurationList;
++ 			buildConfigurations = (
++-				521DC92EB5E96081859D95B644FA15CF /* Debug */,
++-				E4DEC30E809251C58B0C7BF7802F5CFD /* Release */,
+++				AC82647F4C2BE5E8CCF859C6D6F8141E /* Debug */,
+++				6CE0C113B81940025E3A2FB05117B621 /* Release */,
++ 			);
++ 			defaultConfigurationIsVisible = 0;
++ 			defaultConfigurationName = Release;
++diff --git a/Pods/Pods.xcodeproj/xcuserdata/.xcuserdatad/xcschemes/Alamofire.xcscheme b/Pods/Pods.xcodeproj/xcuserdata/.xcuserdatad/xcschemes/Alamofire.xcscheme
++new file mode 100644
++index 0000000..c0e3115
++--- /dev/null
+++++ b/Pods/Pods.xcodeproj/xcuserdata/.xcuserdatad/xcschemes/Alamofire.xcscheme
++@@ -0,0 +1,60 @@
+++<?xml version="1.0" encoding="UTF-8"?>
+++<Scheme
+++   LastUpgradeVersion = "0700"
+++   version = "1.3">
+++   <BuildAction
+++      parallelizeBuildables = "YES"
+++      buildImplicitDependencies = "YES">
+++      <BuildActionEntries>
+++         <BuildActionEntry
+++            buildForAnalyzing = "YES"
+++            buildForTesting = "YES"
+++            buildForRunning = "YES"
+++            buildForProfiling = "YES"
+++            buildForArchiving = "YES">
+++            <BuildableReference
+++               BuildableIdentifier = 'primary'
+++               BlueprintIdentifier = '79C040AFDDCE1BCBF6D8B5EB0B85887F'
+++               BlueprintName = 'Alamofire'
+++               ReferencedContainer = 'container:Pods.xcodeproj'
+++               BuildableName = 'Alamofire.framework'>
+++            </BuildableReference>
+++         </BuildActionEntry>
+++      </BuildActionEntries>
+++   </BuildAction>
+++   <TestAction
+++      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
+++      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
+++      shouldUseLaunchSchemeArgsEnv = "YES"
+++      buildConfiguration = "Debug">
+++      <AdditionalOptions>
+++      </AdditionalOptions>
+++   </TestAction>
+++   <LaunchAction
+++      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
+++      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
+++      launchStyle = "0"
+++      useCustomWorkingDirectory = "NO"
+++      ignoresPersistentStateOnLaunch = "NO"
+++      debugDocumentVersioning = "YES"
+++      debugServiceExtension = "internal"
+++      buildConfiguration = "Debug"
+++      allowLocationSimulation = "YES">
+++      <AdditionalOptions>
+++      </AdditionalOptions>
+++   </LaunchAction>
+++   <ProfileAction
+++      savedToolIdentifier = ""
+++      useCustomWorkingDirectory = "NO"
+++      debugDocumentVersioning = "YES"
+++      buildConfiguration = "Release"
+++      shouldUseLaunchSchemeArgsEnv = "YES">
+++   </ProfileAction>
+++   <AnalyzeAction
+++      buildConfiguration = "Debug">
+++   </AnalyzeAction>
+++   <ArchiveAction
+++      buildConfiguration = "Release"
+++      revealArchiveInOrganizer = "YES">
+++   </ArchiveAction>
+++</Scheme>
++diff --git a/Pods/Pods.xcodeproj/xcuserdata/.xcuserdatad/xcschemes/Pods-CRMCall092016.xcscheme b/Pods/Pods.xcodeproj/xcuserdata/.xcuserdatad/xcschemes/Pods-CRMCall092016.xcscheme
++index 993381f..9e1ec01 100644
++--- a/Pods/Pods.xcodeproj/xcuserdata/.xcuserdatad/xcschemes/Pods-CRMCall092016.xcscheme
+++++ b/Pods/Pods.xcodeproj/xcuserdata/.xcuserdatad/xcschemes/Pods-CRMCall092016.xcscheme
++@@ -14,7 +14,7 @@
++             buildForArchiving = "YES">
++             <BuildableReference
++                BuildableIdentifier = 'primary'
++-               BlueprintIdentifier = 'ED9EA20B7A8CD0AA34A09F4F5CB87BEB'
+++               BlueprintIdentifier = '6A0818B9C68C8B9F82A2B6E85576006B'
++                BlueprintName = 'Pods-CRMCall092016'
++                ReferencedContainer = 'container:Pods.xcodeproj'
++                BuildableName = 'Pods-CRMCall092016.framework'>
++diff --git a/Pods/Pods.xcodeproj/xcuserdata/.xcuserdatad/xcschemes/SWXMLHash.xcscheme b/Pods/Pods.xcodeproj/xcuserdata/.xcuserdatad/xcschemes/SWXMLHash.xcscheme
++new file mode 100644
++index 0000000..ef70ff0
++--- /dev/null
+++++ b/Pods/Pods.xcodeproj/xcuserdata/.xcuserdatad/xcschemes/SWXMLHash.xcscheme
++@@ -0,0 +1,60 @@
+++<?xml version="1.0" encoding="UTF-8"?>
+++<Scheme
+++   LastUpgradeVersion = "0700"
+++   version = "1.3">
+++   <BuildAction
+++      parallelizeBuildables = "YES"
+++      buildImplicitDependencies = "YES">
+++      <BuildActionEntries>
+++         <BuildActionEntry
+++            buildForAnalyzing = "YES"
+++            buildForTesting = "YES"
+++            buildForRunning = "YES"
+++            buildForProfiling = "YES"
+++            buildForArchiving = "YES">
+++            <BuildableReference
+++               BuildableIdentifier = 'primary'
+++               BlueprintIdentifier = '67C63D588DA997BFF7D3C999DA7A5A23'
+++               BlueprintName = 'SWXMLHash'
+++               ReferencedContainer = 'container:Pods.xcodeproj'
+++               BuildableName = 'SWXMLHash.framework'>
+++            </BuildableReference>
+++         </BuildActionEntry>
+++      </BuildActionEntries>
+++   </BuildAction>
+++   <TestAction
+++      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
+++      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
+++      shouldUseLaunchSchemeArgsEnv = "YES"
+++      buildConfiguration = "Debug">
+++      <AdditionalOptions>
+++      </AdditionalOptions>
+++   </TestAction>
+++   <LaunchAction
+++      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
+++      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
+++      launchStyle = "0"
+++      useCustomWorkingDirectory = "NO"
+++      ignoresPersistentStateOnLaunch = "NO"
+++      debugDocumentVersioning = "YES"
+++      debugServiceExtension = "internal"
+++      buildConfiguration = "Debug"
+++      allowLocationSimulation = "YES">
+++      <AdditionalOptions>
+++      </AdditionalOptions>
+++   </LaunchAction>
+++   <ProfileAction
+++      savedToolIdentifier = ""
+++      useCustomWorkingDirectory = "NO"
+++      debugDocumentVersioning = "YES"
+++      buildConfiguration = "Release"
+++      shouldUseLaunchSchemeArgsEnv = "YES">
+++   </ProfileAction>
+++   <AnalyzeAction
+++      buildConfiguration = "Debug">
+++   </AnalyzeAction>
+++   <ArchiveAction
+++      buildConfiguration = "Release"
+++      revealArchiveInOrganizer = "YES">
+++   </ArchiveAction>
+++</Scheme>
++diff --git a/Pods/Pods.xcodeproj/xcuserdata/.xcuserdatad/xcschemes/xcschememanagement.plist b/Pods/Pods.xcodeproj/xcuserdata/.xcuserdatad/xcschemes/xcschememanagement.plist
++index 2bef9aa..015401b 100644
++--- a/Pods/Pods.xcodeproj/xcuserdata/.xcuserdatad/xcschemes/xcschememanagement.plist
+++++ b/Pods/Pods.xcodeproj/xcuserdata/.xcuserdatad/xcschemes/xcschememanagement.plist
++@@ -4,6 +4,11 @@
++ <dict>
++ 	<key>SchemeUserState</key>
++ 	<dict>
+++		<key>Alamofire.xcscheme</key>
+++		<dict>
+++			<key>isShown</key>
+++			<false/>
+++		</dict>
++ 		<key>CocoaAsyncSocket.xcscheme</key>
++ 		<dict>
++ 			<key>isShown</key>
++@@ -14,6 +19,11 @@
++ 			<key>isShown</key>
++ 			<false/>
++ 		</dict>
+++		<key>SWXMLHash.xcscheme</key>
+++		<dict>
+++			<key>isShown</key>
+++			<false/>
+++		</dict>
++ 	</dict>
++ 	<key>SuppressBuildableAutocreation</key>
++ 	<dict/>
++diff --git a/Pods/Pods.xcodeproj/xcuserdata/hanbiro.xcuserdatad/xcschemes/Alamofire.xcscheme b/Pods/Pods.xcodeproj/xcuserdata/hanbiro.xcuserdatad/xcschemes/Alamofire.xcscheme
++new file mode 100644
++index 0000000..e393073
++--- /dev/null
+++++ b/Pods/Pods.xcodeproj/xcuserdata/hanbiro.xcuserdatad/xcschemes/Alamofire.xcscheme
++@@ -0,0 +1,80 @@
+++<?xml version="1.0" encoding="UTF-8"?>
+++<Scheme
+++   LastUpgradeVersion = "0730"
+++   version = "1.3">
+++   <BuildAction
+++      parallelizeBuildables = "YES"
+++      buildImplicitDependencies = "YES">
+++      <BuildActionEntries>
+++         <BuildActionEntry
+++            buildForTesting = "YES"
+++            buildForRunning = "YES"
+++            buildForProfiling = "YES"
+++            buildForArchiving = "YES"
+++            buildForAnalyzing = "YES">
+++            <BuildableReference
+++               BuildableIdentifier = "primary"
+++               BlueprintIdentifier = "79C040AFDDCE1BCBF6D8B5EB0B85887F"
+++               BuildableName = "Alamofire.framework"
+++               BlueprintName = "Alamofire"
+++               ReferencedContainer = "container:Pods.xcodeproj">
+++            </BuildableReference>
+++         </BuildActionEntry>
+++      </BuildActionEntries>
+++   </BuildAction>
+++   <TestAction
+++      buildConfiguration = "Debug"
+++      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
+++      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
+++      shouldUseLaunchSchemeArgsEnv = "YES">
+++      <Testables>
+++      </Testables>
+++      <AdditionalOptions>
+++      </AdditionalOptions>
+++   </TestAction>
+++   <LaunchAction
+++      buildConfiguration = "Debug"
+++      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
+++      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
+++      launchStyle = "0"
+++      useCustomWorkingDirectory = "NO"
+++      ignoresPersistentStateOnLaunch = "NO"
+++      debugDocumentVersioning = "YES"
+++      debugServiceExtension = "internal"
+++      allowLocationSimulation = "YES">
+++      <MacroExpansion>
+++         <BuildableReference
+++            BuildableIdentifier = "primary"
+++            BlueprintIdentifier = "79C040AFDDCE1BCBF6D8B5EB0B85887F"
+++            BuildableName = "Alamofire.framework"
+++            BlueprintName = "Alamofire"
+++            ReferencedContainer = "container:Pods.xcodeproj">
+++         </BuildableReference>
+++      </MacroExpansion>
+++      <AdditionalOptions>
+++      </AdditionalOptions>
+++   </LaunchAction>
+++   <ProfileAction
+++      buildConfiguration = "Release"
+++      shouldUseLaunchSchemeArgsEnv = "YES"
+++      savedToolIdentifier = ""
+++      useCustomWorkingDirectory = "NO"
+++      debugDocumentVersioning = "YES">
+++      <MacroExpansion>
+++         <BuildableReference
+++            BuildableIdentifier = "primary"
+++            BlueprintIdentifier = "79C040AFDDCE1BCBF6D8B5EB0B85887F"
+++            BuildableName = "Alamofire.framework"
+++            BlueprintName = "Alamofire"
+++            ReferencedContainer = "container:Pods.xcodeproj">
+++         </BuildableReference>
+++      </MacroExpansion>
+++   </ProfileAction>
+++   <AnalyzeAction
+++      buildConfiguration = "Debug">
+++   </AnalyzeAction>
+++   <ArchiveAction
+++      buildConfiguration = "Release"
+++      revealArchiveInOrganizer = "YES">
+++   </ArchiveAction>
+++</Scheme>
++diff --git a/Pods/Pods.xcodeproj/xcuserdata/hanbiro.xcuserdatad/xcschemes/Pods-CRMCall092016.xcscheme b/Pods/Pods.xcodeproj/xcuserdata/hanbiro.xcuserdatad/xcschemes/Pods-CRMCall092016.xcscheme
++index bcfec86..03cb029 100644
++--- a/Pods/Pods.xcodeproj/xcuserdata/hanbiro.xcuserdatad/xcschemes/Pods-CRMCall092016.xcscheme
+++++ b/Pods/Pods.xcodeproj/xcuserdata/hanbiro.xcuserdatad/xcschemes/Pods-CRMCall092016.xcscheme
++@@ -14,7 +14,7 @@
++             buildForAnalyzing = "YES">
++             <BuildableReference
++                BuildableIdentifier = "primary"
++-               BlueprintIdentifier = "ED9EA20B7A8CD0AA34A09F4F5CB87BEB"
+++               BlueprintIdentifier = "6DC3AF9E2B939DEDE599F677CB6A2DFC"
++                BuildableName = "Pods_CRMCall092016.framework"
++                BlueprintName = "Pods-CRMCall092016"
++                ReferencedContainer = "container:Pods.xcodeproj">
++@@ -45,7 +45,7 @@
++       <MacroExpansion>
++          <BuildableReference
++             BuildableIdentifier = "primary"
++-            BlueprintIdentifier = "ED9EA20B7A8CD0AA34A09F4F5CB87BEB"
+++            BlueprintIdentifier = "6DC3AF9E2B939DEDE599F677CB6A2DFC"
++             BuildableName = "Pods_CRMCall092016.framework"
++             BlueprintName = "Pods-CRMCall092016"
++             ReferencedContainer = "container:Pods.xcodeproj">
++@@ -63,7 +63,7 @@
++       <MacroExpansion>
++          <BuildableReference
++             BuildableIdentifier = "primary"
++-            BlueprintIdentifier = "ED9EA20B7A8CD0AA34A09F4F5CB87BEB"
+++            BlueprintIdentifier = "6DC3AF9E2B939DEDE599F677CB6A2DFC"
++             BuildableName = "Pods_CRMCall092016.framework"
++             BlueprintName = "Pods-CRMCall092016"
++             ReferencedContainer = "container:Pods.xcodeproj">
++diff --git a/Pods/Pods.xcodeproj/xcuserdata/hanbiro.xcuserdatad/xcschemes/SWXMLHash 2.xcscheme b/Pods/Pods.xcodeproj/xcuserdata/hanbiro.xcuserdatad/xcschemes/SWXMLHash 2.xcscheme
++new file mode 100644
++index 0000000..4903aa6
++--- /dev/null
+++++ b/Pods/Pods.xcodeproj/xcuserdata/hanbiro.xcuserdatad/xcschemes/SWXMLHash 2.xcscheme	
++@@ -0,0 +1,80 @@
+++<?xml version="1.0" encoding="UTF-8"?>
+++<Scheme
+++   LastUpgradeVersion = "0730"
+++   version = "1.3">
+++   <BuildAction
+++      parallelizeBuildables = "YES"
+++      buildImplicitDependencies = "YES">
+++      <BuildActionEntries>
+++         <BuildActionEntry
+++            buildForTesting = "YES"
+++            buildForRunning = "YES"
+++            buildForProfiling = "YES"
+++            buildForArchiving = "YES"
+++            buildForAnalyzing = "YES">
+++            <BuildableReference
+++               BuildableIdentifier = "primary"
+++               BlueprintIdentifier = "67C63D588DA997BFF7D3C999DA7A5A23"
+++               BuildableName = "SWXMLHash.framework"
+++               BlueprintName = "SWXMLHash"
+++               ReferencedContainer = "container:Pods.xcodeproj">
+++            </BuildableReference>
+++         </BuildActionEntry>
+++      </BuildActionEntries>
+++   </BuildAction>
+++   <TestAction
+++      buildConfiguration = "Debug"
+++      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
+++      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
+++      shouldUseLaunchSchemeArgsEnv = "YES">
+++      <Testables>
+++      </Testables>
+++      <AdditionalOptions>
+++      </AdditionalOptions>
+++   </TestAction>
+++   <LaunchAction
+++      buildConfiguration = "Debug"
+++      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
+++      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
+++      launchStyle = "0"
+++      useCustomWorkingDirectory = "NO"
+++      ignoresPersistentStateOnLaunch = "NO"
+++      debugDocumentVersioning = "YES"
+++      debugServiceExtension = "internal"
+++      allowLocationSimulation = "YES">
+++      <MacroExpansion>
+++         <BuildableReference
+++            BuildableIdentifier = "primary"
+++            BlueprintIdentifier = "67C63D588DA997BFF7D3C999DA7A5A23"
+++            BuildableName = "SWXMLHash.framework"
+++            BlueprintName = "SWXMLHash"
+++            ReferencedContainer = "container:Pods.xcodeproj">
+++         </BuildableReference>
+++      </MacroExpansion>
+++      <AdditionalOptions>
+++      </AdditionalOptions>
+++   </LaunchAction>
+++   <ProfileAction
+++      buildConfiguration = "Release"
+++      shouldUseLaunchSchemeArgsEnv = "YES"
+++      savedToolIdentifier = ""
+++      useCustomWorkingDirectory = "NO"
+++      debugDocumentVersioning = "YES">
+++      <MacroExpansion>
+++         <BuildableReference
+++            BuildableIdentifier = "primary"
+++            BlueprintIdentifier = "67C63D588DA997BFF7D3C999DA7A5A23"
+++            BuildableName = "SWXMLHash.framework"
+++            BlueprintName = "SWXMLHash"
+++            ReferencedContainer = "container:Pods.xcodeproj">
+++         </BuildableReference>
+++      </MacroExpansion>
+++   </ProfileAction>
+++   <AnalyzeAction
+++      buildConfiguration = "Debug">
+++   </AnalyzeAction>
+++   <ArchiveAction
+++      buildConfiguration = "Release"
+++      revealArchiveInOrganizer = "YES">
+++   </ArchiveAction>
+++</Scheme>
++diff --git a/Pods/Pods.xcodeproj/xcuserdata/hanbiro.xcuserdatad/xcschemes/SWXMLHash.xcscheme b/Pods/Pods.xcodeproj/xcuserdata/hanbiro.xcuserdatad/xcschemes/SWXMLHash.xcscheme
++new file mode 100644
++index 0000000..9a1df9b
++--- /dev/null
+++++ b/Pods/Pods.xcodeproj/xcuserdata/hanbiro.xcuserdatad/xcschemes/SWXMLHash.xcscheme
++@@ -0,0 +1,46 @@
+++<?xml version="1.0" encoding="UTF-8"?>
+++<Scheme
+++   LastUpgradeVersion = "0730"
+++   version = "1.3">
+++   <BuildAction
+++      parallelizeBuildables = "YES"
+++      buildImplicitDependencies = "YES">
+++   </BuildAction>
+++   <TestAction
+++      buildConfiguration = "Debug"
+++      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
+++      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
+++      shouldUseLaunchSchemeArgsEnv = "YES">
+++      <Testables>
+++      </Testables>
+++      <AdditionalOptions>
+++      </AdditionalOptions>
+++   </TestAction>
+++   <LaunchAction
+++      buildConfiguration = "Debug"
+++      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
+++      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
+++      launchStyle = "0"
+++      useCustomWorkingDirectory = "NO"
+++      ignoresPersistentStateOnLaunch = "NO"
+++      debugDocumentVersioning = "YES"
+++      debugServiceExtension = "internal"
+++      allowLocationSimulation = "YES">
+++      <AdditionalOptions>
+++      </AdditionalOptions>
+++   </LaunchAction>
+++   <ProfileAction
+++      buildConfiguration = "Release"
+++      shouldUseLaunchSchemeArgsEnv = "YES"
+++      savedToolIdentifier = ""
+++      useCustomWorkingDirectory = "NO"
+++      debugDocumentVersioning = "YES">
+++   </ProfileAction>
+++   <AnalyzeAction
+++      buildConfiguration = "Debug">
+++   </AnalyzeAction>
+++   <ArchiveAction
+++      buildConfiguration = "Release"
+++      revealArchiveInOrganizer = "YES">
+++   </ArchiveAction>
+++</Scheme>
++diff --git a/Pods/Pods.xcodeproj/xcuserdata/hanbiro.xcuserdatad/xcschemes/xcschememanagement.plist b/Pods/Pods.xcodeproj/xcuserdata/hanbiro.xcuserdatad/xcschemes/xcschememanagement.plist
++index 91212f6..18f8564 100644
++--- a/Pods/Pods.xcodeproj/xcuserdata/hanbiro.xcuserdatad/xcschemes/xcschememanagement.plist
+++++ b/Pods/Pods.xcodeproj/xcuserdata/hanbiro.xcuserdatad/xcschemes/xcschememanagement.plist
++@@ -4,6 +4,11 @@
++ <dict>
++ 	<key>SchemeUserState</key>
++ 	<dict>
+++		<key>Alamofire.xcscheme</key>
+++		<dict>
+++			<key>orderHint</key>
+++			<integer>4</integer>
+++		</dict>
++ 		<key>CocoaAsyncSocket.xcscheme</key>
++ 		<dict>
++ 			<key>orderHint</key>
++@@ -14,9 +19,49 @@
++ 			<key>orderHint</key>
++ 			<integer>2</integer>
++ 		</dict>
+++		<key>SWXMLHash 2.xcscheme</key>
+++		<dict>
+++			<key>orderHint</key>
+++			<integer>5</integer>
+++		</dict>
+++		<key>SWXMLHash.xcscheme</key>
+++		<dict>
+++			<key>orderHint</key>
+++			<integer>3</integer>
+++		</dict>
++ 	</dict>
++ 	<key>SuppressBuildableAutocreation</key>
++ 	<dict>
+++		<key>67C63D588DA997BFF7D3C999DA7A5A23</key>
+++		<dict>
+++			<key>primary</key>
+++			<true/>
+++		</dict>
+++		<key>6A0818B9C68C8B9F82A2B6E85576006B</key>
+++		<dict>
+++			<key>primary</key>
+++			<true/>
+++		</dict>
+++		<key>6DC3AF9E2B939DEDE599F677CB6A2DFC</key>
+++		<dict>
+++			<key>primary</key>
+++			<true/>
+++		</dict>
+++		<key>6FF4900D90DA59447E562D6888408670</key>
+++		<dict>
+++			<key>primary</key>
+++			<true/>
+++		</dict>
+++		<key>79C040AFDDCE1BCBF6D8B5EB0B85887F</key>
+++		<dict>
+++			<key>primary</key>
+++			<true/>
+++		</dict>
+++		<key>B146E7512E9CA5F0BB2EDF3F86841CA4</key>
+++		<dict>
+++			<key>primary</key>
+++			<true/>
+++		</dict>
++ 		<key>B37E19CA872A7535725D1E1946E5C271</key>
++ 		<dict>
++ 			<key>primary</key>
++diff --git a/Pods/SWXMLHash/LICENSE b/Pods/SWXMLHash/LICENSE
++new file mode 100644
++index 0000000..3d21445
++--- /dev/null
+++++ b/Pods/SWXMLHash/LICENSE
++@@ -0,0 +1,20 @@
+++Copyright (c) 2014 David Mohundro
+++ 
+++Permission is hereby granted, free of charge, to any person obtaining
+++a copy of this software and associated documentation files (the
+++"Software"), to deal in the Software without restriction, including
+++without limitation the rights to use, copy, modify, merge, publish,
+++distribute, sublicense, and/or sell copies of the Software, and to
+++permit persons to whom the Software is furnished to do so, subject to
+++the following conditions:
+++ 
+++The above copyright notice and this permission notice shall be
+++included in all copies or substantial portions of the Software.
+++ 
+++THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+++EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+++MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+++NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+++LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+++OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+++WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
++diff --git a/Pods/SWXMLHash/README.md b/Pods/SWXMLHash/README.md
++new file mode 100644
++index 0000000..25e83a6
++--- /dev/null
+++++ b/Pods/SWXMLHash/README.md
++@@ -0,0 +1,387 @@
+++# SWXMLHash
+++
+++[![CocoaPods](https://img.shields.io/cocoapods/p/SWXMLHash.svg)]()
+++[![Carthage compatible](https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat)](https://github.com/Carthage/Carthage)
+++[![CocoaPods](https://img.shields.io/cocoapods/v/SWXMLHash.svg)](https://cocoapods.org/pods/SWXMLHash)
+++[![Join the chat at https://gitter.im/drmohundro/SWXMLHash](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/drmohundro/SWXMLHash?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)
+++[![codebeat](https://codebeat.co/badges/893cc640-c5d9-45b2-a3ff-426e6e6b7b80)](https://codebeat.co/projects/github-com-drmohundro-swxmlhash)
+++
+++SWXMLHash is a relatively simple way to parse XML in Swift. If you're familiar with `NSXMLParser`, this library is a simple wrapper around it. Conceptually, it provides a translation from XML to a dictionary of arrays (aka hash).
+++
+++The API takes a lot of inspiration from [SwiftyJSON](https://github.com/SwiftyJSON/SwiftyJSON).
+++
+++## Contents
+++
+++* [Requirements](#requirements)
+++* [Installation](#installation)
+++* [Getting Started](#getting-started)
+++* [Configuration](#configuration)
+++* [Examples](#examples)
+++* [FAQ](#faq)
+++* [Changelog](#changelog)
+++* [Contributing](#contributing)
+++* [License](#license)
+++
+++## Requirements
+++
+++- iOS 8.0+ / Mac OS X 10.9+ / tvOS 9.0+ / watchOS 2.0+
+++- Xcode 7.1+
+++
+++(note that Xcode 8 beta and Swift 3 support are being tracked in [PR 78](https://github.com/drmohundro/SWXMLHash/pull/78))
+++
+++## Installation
+++
+++SWXMLHash can be installed using [CocoaPods](http://cocoapods.org/), [Carthage](https://github.com/Carthage/Carthage), or manually.
+++
+++### CocoaPods
+++
+++To install CocoaPods, run:
+++
+++```bash
+++$ gem install cocoapods
+++```
+++
+++Then create a `Podfile` with the following contents:
+++
+++```ruby
+++source 'https://github.com/CocoaPods/Specs.git'
+++platform :ios, '8.0'
+++
+++pod 'SWXMLHash', '~> 2.4.0'
+++```
+++
+++Finally, run the following command to install it:
+++
+++```bash
+++$ pod install
+++```
+++
+++### Carthage
+++
+++To install Carthage, run (using Homebrew):
+++
+++```bash
+++$ brew update
+++$ brew install carthage
+++```
+++
+++Then add the following line to your `Cartfile`:
+++
+++```
+++github "drmohundro/SWXMLHash" ~> 2.3
+++```
+++
+++### Manual Installation
+++
+++To install manually, you'll need to clone the SWXMLHash repository. You can do this in a separate directory or you can make use of git submodules - in this case, git submodules are recommended so that your repository has details about which commit of SWXMLHash you're using. Once this is done, you can just drop the `SWXMLHash.swift` file into your project.
+++
+++> NOTE: if you're targeting iOS 7, you'll have to install manually because embedded frameworks require a minimum deployment target of iOS 8 or OSX Mavericks.
+++
+++## Getting Started
+++
+++If you're just getting started with SWXMLHash, I'd recommend cloning the repository down and opening the workspace. I've included a Swift playground in the workspace which makes it *very* easy to experiment with the API and the calls.
+++
+++<img src="https://raw.githubusercontent.com/drmohundro/SWXMLHash/assets/swift-playground@2x.png" width="600" alt="Swift Playground" />
+++
+++## Configuration
+++
+++SWXMLHash allows for limited configuration in terms of its approach to parsing. To set any of the configuration options, you use the `configure` method, like so:
+++
+++```swift
+++let xml = SWXMLHash.config {
+++              config in
+++              // set any config options here
+++          }.parse(xmlToParse)
+++```
+++
+++The available options at this time are:
+++
+++* `shouldProcessLazily`
+++    * This determines whether not to use lazy loading of the XML. It can significantly increase the performance of parsing if your XML is very large.
+++    * Defaults to `false`
+++* `shouldProcessNamespaces`
+++    * This setting is forwarded on to the internal `NSXMLParser` instance. It will return any XML elements without their namespace parts (i.e. "\<h:table\>" will be returned as "\<table\>")
+++    * Defaults to `false`
+++
+++## Examples
+++
+++All examples below can be found in the included [specs](https://github.com/drmohundro/SWXMLHash/blob/master/Tests/SWXMLHashSpecs.swift).
+++
+++### Initialization
+++
+++```swift
+++let xml = SWXMLHash.parse(xmlToParse)
+++```
+++
+++Alternatively, if you're parsing a large XML file and need the best performance, you may wish to configure the parsing to be processed lazily. Lazy processing avoids loading the entire XML document into memory, so it could be preferable for performance reasons. See the error handling for one caveat regarding lazy loading.
+++
+++```swift
+++let xml = SWXMLHash.config {
+++              config in
+++              config.shouldProcessLazily = true
+++          }.parse(xmlToParse)
+++```
+++
+++The above approach uses the new config method, but there is also a `lazy` method directly off of `SWXMLHash`.
+++
+++```swift
+++let xml = SWXMLHash.lazy(xmlToParse)
+++```
+++
+++### Single Element Lookup
+++
+++Given:
+++
+++```xml
+++<root>
+++  <header>
+++    <title>Foo</title>
+++  </header>
+++  ...
+++</root>
+++```
+++
+++Will return "Foo".
+++
+++```swift
+++xml["root"]["header"]["title"].element?.text
+++```
+++
+++### Multiple Elements Lookup
+++
+++Given:
+++
+++```xml
+++<root>
+++  ...
+++  <catalog>
+++    <book><author>Bob</author></book>
+++    <book><author>John</author></book>
+++    <book><author>Mark</author></book>
+++  </catalog>
+++  ...
+++</root>
+++```
+++
+++The below will return "John".
+++
+++```swift
+++xml["root"]["catalog"]["book"][1]["author"].element?.text
+++```
+++
+++### Attributes Usage
+++
+++Given:
+++
+++```xml
+++<root>
+++  ...
+++  <catalog>
+++    <book id="1"><author>Bob</author></book>
+++    <book id="123"><author>John</author></book>
+++    <book id="456"><author>Mark</author></book>
+++  </catalog>
+++  ...
+++</root>
+++```
+++
+++The below will return "123".
+++
+++```swift
+++xml["root"]["catalog"]["book"][1].element?.attributes["id"]
+++```
+++
+++Alternatively, you can look up an element with specific attributes. The below will return "John".
+++
+++```swift
+++xml["root"]["catalog"]["book"].withAttr("id", "123")["author"].element?.text
+++```
+++
+++### Returning All Elements At Current Level
+++
+++Given:
+++
+++```xml
+++<root>
+++  ...
+++  <catalog>
+++    <book><genre>Fiction</genre></book>
+++    <book><genre>Non-fiction</genre></book>
+++    <book><genre>Technical</genre></book>
+++  </catalog>
+++  ...
+++</root>
+++```
+++
+++The below will return "Fiction, Non-fiction, Technical" (note the `all` method).
+++
+++```swift
+++", ".join(xml["root"]["catalog"]["book"].all.map { elem in
+++  elem["genre"].element!.text!
+++})
+++```
+++
+++Alternatively, you can just iterate over the elements using `for-in` directly against an element.
+++
+++```swift
+++for elem in xml["root"]["catalog"]["book"] {
+++  NSLog(elem["genre"].element!.text!)
+++}
+++```
+++
+++### Returning All Child Elements At Current Level
+++
+++Given:
+++
+++```xml
+++<root>
+++  <catalog>
+++    <book>
+++      <genre>Fiction</genre>
+++      <title>Book</title>
+++      <date>1/1/2015</date>
+++    </book>
+++  </catalog>
+++</root>
+++```
+++
+++The below will `NSLog` "root", "catalog", "book", "genre", "title", and "date" (note the `children` method).
+++
+++```swift
+++func enumerate(indexer: XMLIndexer) {
+++  for child in indexer.children {
+++    NSLog(child.element!.name)
+++    enumerate(child)
+++  }
+++}
+++
+++enumerate(xml)
+++```
+++
+++### Error Handling
+++
+++Using Swift 2.0's new error handling feature:
+++
+++```swift
+++do {
+++  try xml!.byKey("root").byKey("what").byKey("header").byKey("foo")
+++} catch let error as XMLIndexer.Error {
+++  // error is an XMLIndexer.Error instance that you can deal with
+++}
+++```
+++
+++__Or__ using the existing indexing functionality (__NOTE__ that the `.Error` case has been renamed to `.XMLError` so as to not conflict with the `XMLIndexer.Error` error type):
+++
+++```swift
+++switch xml["root"]["what"]["header"]["foo"] {
+++case .Element(let elem):
+++  // everything is good, code away!
+++case .XMLError(let error):
+++  // error is an XMLIndexer.Error instance that you can deal with
+++}
+++```
+++
+++Note that error handling as shown above will not work with lazy loaded XML. The lazy parsing doesn't actually occur until the `element` or `all` method are called - as a result, there isn't any way to know prior to asking for an element if it exists or not.
+++
+++### Types conversion
+++
+++Given:
+++
+++```xml
+++<root>
+++  <books>
+++    <book>
+++      <title>Book A</title>
+++      <price>12.5</price>
+++      <year>2015</year>
+++    </book>
+++    <book>
+++      <title>Book B</title>
+++      <price>10</price>
+++      <year>1988</year>
+++    </book>
+++    <book>
+++      <title>Book C</title>
+++      <price>8.33</price>
+++      <year>1990</year>
+++      <amount>10</amount>
+++    </book>
+++  <books>
+++</root>
+++```
+++with `Book` struct implementing `XMLIndexerDeserializable`:
+++
+++```swift
+++struct Book: XMLIndexerDeserializable {
+++    let title: String
+++    let price: Double
+++    let year: Int
+++    let amount: Int?
+++
+++    static func deserialize(node: XMLIndexer) throws -> Book {
+++        return try Book(
+++            title: node["title"].value(),
+++            price: node["price"].value(),
+++            year: node["year"].value(),
+++            amount: node["amount"].value()
+++        )
+++    }
+++}
+++```
+++
+++The below will return array of `Book` structs:
+++
+++```swift
+++let books: [Book] = try xml["root"]["books"]["book"].value()
+++```
+++
+++<img src="https://raw.githubusercontent.com/ncreated/SWXMLHash/assets/types-conversion%402x.png" width="600" alt="Types Conversion" />
+++
+++Built-in, leaf-nodes converters support `Int`, `Double`, `Float`, `Bool`, and `String` values (both non- and -optional variants). Custom converters can be added by implementing `XMLElementDeserializable`.
+++
+++You can convert any XML to your custom type by implementing `XMLIndexerDeserializable`.
+++
+++Types conversion supports error handling, optionals and arrays. For more examples, look into `SWXMLHashTests.swift` or play with types conversion directly in the Swift playground.
+++
+++
+++## FAQ
+++
+++### Does SWXMLHash handle URLs for me?
+++
+++No - SWXMLHash only handles parsing of XML. If you have a URL that has XML content on it, I'd recommend using a library like [AlamoFire](https://github.com/Alamofire/Alamofire) to download the content into a string and then parsing it.
+++
+++### Does SWXMLHash support writing XML content?
+++
+++No, not at the moment - SWXMLHash only supports parsing XML (via indexing, deserialization, etc.).
+++
+++### I'm getting an "Ambiguous reference to member 'subscript'" when I call `.value()`.
+++
+++`.value()` is used for deserialization - you have to have something that implements `XMLIndexerDeserializable` and that can handle deserialization to the left-hand side of expression.
+++
+++For example, given the following:
+++
+++```swift
+++let dateValue: NSDate = try! xml["root"]["date"].value()
+++```
+++
+++You'll get an error because there isn't any built-in deserializer for `NSDate`. See the above documentation on adding your own deserialization support.
+++
+++### I'm getting an `EXC_BAD_ACCESS (SIGSEGV)` when I call `parse()`
+++
+++Chances are very good that your XML content has what is called a "byte order mark" or BOM. SWXMLHash uses `NSXMLParser` for its parsing logic and there are issues with it and handling BOM characters. See [issue #65](https://github.com/drmohundro/SWXMLHash/issues/65) for more details. Others who have run into this problem have just rstripped the BOM out of their content prior to parsing.
+++
+++### Have a different question?
+++
+++Feel free to shoot me an email, post a [question on StackOverflow](http://stackoverflow.com/questions/tagged/swxmlhash), or open an issue if you think you've found a bug. I'm happy to try to help!
+++
+++## Changelog
+++
+++See [CHANGELOG](CHANGELOG.md) for a list of all changes and their corresponding versions.
+++
+++## Contributing
+++
+++See [CONTRIBUTING](CONTRIBUTING.md) for guidelines to contribute back to SWXMLHash.
+++
+++## License
+++
+++SWXMLHash is released under the MIT license. See [LICENSE](LICENSE) for details.
++diff --git a/Pods/SWXMLHash/Source/SWXMLHash+TypeConversion.swift b/Pods/SWXMLHash/Source/SWXMLHash+TypeConversion.swift
++new file mode 100644
++index 0000000..a4e1bef
++--- /dev/null
+++++ b/Pods/SWXMLHash/Source/SWXMLHash+TypeConversion.swift
++@@ -0,0 +1,364 @@
+++//
+++//  SWXMLHash+TypeConversion.swift
+++//  SWXMLHash
+++//
+++//  Created by Maciek Grzybowski on 29.02.2016.
+++//
+++//
+++
+++import Foundation
+++
+++// MARK: - XMLIndexerDeserializable
+++
+++/// Provides XMLIndexer deserialization / type transformation support
+++public protocol XMLIndexerDeserializable {
+++    static func deserialize(element: XMLIndexer) throws -> Self
+++}
+++
+++/// Provides XMLIndexer deserialization / type transformation support
+++public extension XMLIndexerDeserializable {
+++    /**
+++    A default implementation that will throw an error if it is called
+++
+++    - parameters:
+++        - element: the XMLIndexer to be deserialized
+++    - throws: an XMLDeserializationError.ImplementationIsMissing if no implementation is found
+++    - returns: this won't ever return because of the error being thrown
+++    */
+++    static func deserialize(element: XMLIndexer) throws -> Self {
+++        throw XMLDeserializationError.ImplementationIsMissing(
+++            method: "XMLIndexerDeserializable.deserialize(element: XMLIndexer)")
+++    }
+++}
+++
+++
+++// MARK: - XMLElementDeserializable
+++
+++/// Provides XMLElement deserialization / type transformation support
+++public protocol XMLElementDeserializable {
+++    static func deserialize(element: XMLElement) throws -> Self
+++}
+++
+++/// Provides XMLElement deserialization / type transformation support
+++public extension XMLElementDeserializable {
+++    /**
+++    A default implementation that will throw an error if it is called
+++
+++    - parameters:
+++        - element: the XMLElement to be deserialized
+++    - throws: an XMLDeserializationError.ImplementationIsMissing if no implementation is found
+++    - returns: this won't ever return because of the error being thrown
+++    */
+++    static func deserialize(element: XMLElement) throws -> Self {
+++        throw XMLDeserializationError.ImplementationIsMissing(
+++            method: "XMLElementDeserializable.deserialize(element: XMLElement)")
+++    }
+++}
+++
+++
+++public extension XMLIndexer {
+++
+++    // MARK: - XMLElementDeserializable
+++
+++    /**
+++    Attempts to deserialize the current XMLElement element to `T`
+++
+++    - throws: an XMLDeserializationError.NodeIsInvalid if the current indexed level isn't an Element
+++    - returns: the deserialized `T` value
+++    */
+++    func value<T: XMLElementDeserializable>() throws -> T {
+++        switch self {
+++        case .Element(let element):
+++            return try T.deserialize(element)
+++        case .Stream(let opStream):
+++            return try! opStream.findElements().value()
+++        default:
+++            throw XMLDeserializationError.NodeIsInvalid(node: self)
+++        }
+++    }
+++
+++    /**
+++    Attempts to deserialize the current XMLElement element to `T?`
+++
+++    - returns: the deserialized `T?` value
+++    - throws: an XMLDeserializationError is there is a problem with deserialization
+++    */
+++    func value<T: XMLElementDeserializable>() throws -> T? {
+++        switch self {
+++        case .Element(let element):
+++            return try T.deserialize(element)
+++        case .Stream(let opStream):
+++            return try! opStream.findElements().value()
+++        default:
+++            return nil
+++        }
+++    }
+++
+++    /**
+++    Attempts to deserialize the current XMLElement element to `[T]`
+++
+++    - returns: the deserialized `[T]` value
+++    - throws: an XMLDeserializationError is there is a problem with deserialization
+++    */
+++    func value<T: XMLElementDeserializable>() throws -> [T] {
+++        switch self {
+++        case .List(let elements):
+++            return try elements.map { try T.deserialize($0) }
+++        case .Element(let element):
+++            return try [element].map { try T.deserialize($0) }
+++        case .Stream(let opStream):
+++            return try! opStream.findElements().value()
+++        default:
+++            return []
+++        }
+++    }
+++
+++    /**
+++    Attempts to deserialize the current XMLElement element to `[T]?`
+++
+++    - returns: the deserialized `[T]?` value
+++    - throws: an XMLDeserializationError is there is a problem with deserialization
+++    */
+++    func value<T: XMLElementDeserializable>() throws -> [T]? {
+++        switch self {
+++        case .List(let elements):
+++            return try elements.map { try T.deserialize($0) }
+++        case .Element(let element):
+++            return try [element].map { try T.deserialize($0) }
+++        case .Stream(let opStream):
+++            return try! opStream.findElements().value()
+++        default:
+++            return nil
+++        }
+++    }
+++
+++    /**
+++    Attempts to deserialize the current XMLElement element to `[T?]`
+++
+++    - returns: the deserialized `[T?]` value
+++    - throws: an XMLDeserializationError is there is a problem with deserialization
+++    */
+++    func value<T: XMLElementDeserializable>() throws -> [T?] {
+++        switch self {
+++        case .List(let elements):
+++            return try elements.map { try T.deserialize($0) }
+++        case .Element(let element):
+++            return try [element].map { try T.deserialize($0) }
+++        case .Stream(let opStream):
+++            return try! opStream.findElements().value()
+++        default:
+++            return []
+++        }
+++    }
+++
+++
+++    // MARK: - XMLIndexerDeserializable
+++
+++    /**
+++    Attempts to deserialize the current XMLIndexer element to `T`
+++
+++    - returns: the deserialized `T` value
+++    - throws: an XMLDeserializationError is there is a problem with deserialization
+++    */
+++    func value<T: XMLIndexerDeserializable>() throws -> T {
+++        switch self {
+++        case .Element:
+++            return try T.deserialize(self)
+++        case .Stream(let opStream):
+++            return try! opStream.findElements().value()
+++        default:
+++            throw XMLDeserializationError.NodeIsInvalid(node: self)
+++        }
+++    }
+++
+++    /**
+++    Attempts to deserialize the current XMLIndexer element to `T?`
+++
+++    - returns: the deserialized `T?` value
+++    - throws: an XMLDeserializationError is there is a problem with deserialization
+++    */
+++    func value<T: XMLIndexerDeserializable>() throws -> T? {
+++        switch self {
+++        case .Element:
+++            return try T.deserialize(self)
+++        case .Stream(let opStream):
+++            return try! opStream.findElements().value()
+++        default:
+++            return nil
+++        }
+++    }
+++
+++    /**
+++    Attempts to deserialize the current XMLIndexer element to `[T]`
+++
+++    - returns: the deserialized `[T]` value
+++    - throws: an XMLDeserializationError is there is a problem with deserialization
+++    */
+++    func value<T where T: XMLIndexerDeserializable>() throws -> [T] {
+++        switch self {
+++        case .List(let elements):
+++            return try elements.map { try T.deserialize( XMLIndexer($0) ) }
+++        case .Element(let element):
+++            return try [element].map { try T.deserialize( XMLIndexer($0) ) }
+++        case .Stream(let opStream):
+++            return try! opStream.findElements().value()
+++        default:
+++            throw XMLDeserializationError.NodeIsInvalid(node: self)
+++        }
+++    }
+++
+++    /**
+++    Attempts to deserialize the current XMLIndexer element to `[T]?`
+++
+++    - returns: the deserialized `[T]?` value
+++    - throws: an XMLDeserializationError is there is a problem with deserialization
+++    */
+++    func value<T: XMLIndexerDeserializable>() throws -> [T]? {
+++        switch self {
+++        case .List(let elements):
+++            return try elements.map { try T.deserialize( XMLIndexer($0) ) }
+++        case .Element(let element):
+++            return try [element].map { try T.deserialize( XMLIndexer($0) ) }
+++        case .Stream(let opStream):
+++            return try! opStream.findElements().value()
+++        default:
+++            throw XMLDeserializationError.NodeIsInvalid(node: self)
+++        }
+++    }
+++
+++    /**
+++    Attempts to deserialize the current XMLIndexer element to `[T?]`
+++
+++    - returns: the deserialized `[T?]` value
+++    - throws: an XMLDeserializationError is there is a problem with deserialization
+++    */
+++    func value<T: XMLIndexerDeserializable>() throws -> [T?] {
+++        switch self {
+++        case .List(let elements):
+++            return try elements.map {  try T.deserialize( XMLIndexer($0) ) }
+++        case .Element(let element):
+++            return try [element].map { try T.deserialize( XMLIndexer($0) ) }
+++        case .Stream(let opStream):
+++            return try! opStream.findElements().value()
+++        default:
+++            throw XMLDeserializationError.NodeIsInvalid(node: self)
+++        }
+++    }
+++}
+++
+++private extension XMLElement {
+++    func nonEmptyTextOrThrow() throws -> String {
+++        if let text = self.text where !text.characters.isEmpty {
+++            return text
+++        } else { throw XMLDeserializationError.NodeHasNoValue }
+++    }
+++}
+++
+++/// The error that is thrown if there is a problem with deserialization
+++public enum XMLDeserializationError: ErrorType, CustomStringConvertible {
+++    case ImplementationIsMissing(method: String)
+++    case NodeIsInvalid(node: XMLIndexer)
+++    case NodeHasNoValue
+++    case TypeConversionFailed(type: String, element: XMLElement)
+++
+++    /// The text description for the error thrown
+++    public var description: String {
+++        switch self {
+++        case .ImplementationIsMissing(let method):
+++            return "This deserialization method is not implemented: \(method)"
+++        case .NodeIsInvalid(let node):
+++            return "This node is invalid: \(node)"
+++        case .NodeHasNoValue:
+++            return "This node is empty"
+++        case .TypeConversionFailed(let type, let node):
+++            return "Can't convert node \(node) to value of type \(type)"
+++        }
+++    }
+++}
+++
+++
+++// MARK: - Common types deserialization
+++
+++extension String: XMLElementDeserializable {
+++    /**
+++    Attempts to deserialize XML element content to a String
+++
+++    - parameters:
+++        - element: the XMLElement to be deserialized
+++    - throws: an XMLDeserializationError.TypeConversionFailed if the element cannot be deserialized
+++    - returns: the deserialized String value
+++    */
+++    public static func deserialize(element: XMLElement) throws -> String {
+++        guard let text = element.text
+++        else {
+++            throw XMLDeserializationError.TypeConversionFailed(type: "String", element: element)
+++        }
+++        return text
+++    }
+++}
+++
+++extension Int: XMLElementDeserializable {
+++    /**
+++    Attempts to deserialize XML element content to a Int
+++
+++    - parameters:
+++        - element: the XMLElement to be deserialized
+++    - throws: an XMLDeserializationError.TypeConversionFailed if the element cannot be deserialized
+++    - returns: the deserialized Int value
+++    */
+++    public static func deserialize(element: XMLElement) throws -> Int {
+++        guard let value = Int(try element.nonEmptyTextOrThrow())
+++        else { throw XMLDeserializationError.TypeConversionFailed(type: "Int", element: element) }
+++        return value
+++    }
+++}
+++
+++extension Double: XMLElementDeserializable {
+++    /**
+++    Attempts to deserialize XML element content to a Double
+++
+++    - parameters:
+++        - element: the XMLElement to be deserialized
+++    - throws: an XMLDeserializationError.TypeConversionFailed if the element cannot be deserialized
+++    - returns: the deserialized Double value
+++    */
+++    public static func deserialize(element: XMLElement) throws -> Double {
+++        guard let value = Double(try element.nonEmptyTextOrThrow())
+++        else {
+++            throw XMLDeserializationError.TypeConversionFailed(type: "Double", element: element)
+++        }
+++        return value
+++    }
+++}
+++
+++extension Float: XMLElementDeserializable {
+++    /**
+++    Attempts to deserialize XML element content to a Float
+++
+++    - parameters:
+++        - element: the XMLElement to be deserialized
+++    - throws: an XMLDeserializationError.TypeConversionFailed if the element cannot be deserialized
+++    - returns: the deserialized Float value
+++    */
+++    public static func deserialize(element: XMLElement) throws -> Float {
+++        guard let value = Float(try element.nonEmptyTextOrThrow())
+++        else { throw XMLDeserializationError.TypeConversionFailed(type: "Float", element: element) }
+++        return value
+++    }
+++}
+++
+++extension Bool: XMLElementDeserializable {
+++    /**
+++     Attempts to deserialize XML element content to a Bool. This uses NSString's 'boolValue' described
+++     [here](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSString_Class/#//apple_ref/occ/instp/NSString/boolValue)
+++
+++     - parameters:
+++     - element: the XMLElement to be deserialized
+++     - throws: an XMLDeserializationError.TypeConversionFailed if the element cannot be deserialized
+++     - returns: the deserialized Bool value
+++     */
+++    public static func deserialize(element: XMLElement) throws -> Bool {
+++        let value = Bool(NSString(string: try element.nonEmptyTextOrThrow()).boolValue)
+++        return value
+++    }
+++}
++diff --git a/Pods/SWXMLHash/Source/SWXMLHash.swift b/Pods/SWXMLHash/Source/SWXMLHash.swift
++new file mode 100644
++index 0000000..da75fc9
++--- /dev/null
+++++ b/Pods/SWXMLHash/Source/SWXMLHash.swift
++@@ -0,0 +1,732 @@
+++//
+++//  SWXMLHash.swift
+++//
+++//  Copyright (c) 2014 David Mohundro
+++//
+++//  Permission is hereby granted, free of charge, to any person obtaining a copy
+++//  of this software and associated documentation files (the "Software"), to deal
+++//  in the Software without restriction, including without limitation the rights
+++//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+++//  copies of the Software, and to permit persons to whom the Software is
+++//  furnished to do so, subject to the following conditions:
+++//
+++//  The above copyright notice and this permission notice shall be included in
+++//  all copies or substantial portions of the Software.
+++//
+++//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+++//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+++//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+++//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+++//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+++//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+++//  THE SOFTWARE.
+++
+++// swiftlint exceptions:
+++// - Disabled file_length because there are a number of users that still pull the
+++//   source down as is and it makes pulling the code into a project easier.
+++
+++// swiftlint:disable file_length
+++
+++import Foundation
+++
+++let rootElementName = "SWXMLHash_Root_Element"
+++
+++/// Parser options
+++public class SWXMLHashOptions {
+++    internal init() {}
+++
+++    /// determines whether to parse the XML with lazy parsing or not
+++    public var shouldProcessLazily = false
+++
+++    /// determines whether to parse XML namespaces or not (forwards to
+++    /// `NSXMLParser.shouldProcessNamespaces`)
+++    public var shouldProcessNamespaces = false
+++}
+++
+++/// Simple XML parser
+++public class SWXMLHash {
+++    let options: SWXMLHashOptions
+++
+++    private init(_ options: SWXMLHashOptions = SWXMLHashOptions()) {
+++        self.options = options
+++    }
+++
+++    /**
+++    Method to configure how parsing works.
+++
+++    - parameters:
+++        - configAction: a block that passes in an `SWXMLHashOptions` object with
+++        options to be set
+++    - returns: an `SWXMLHash` instance
+++    */
+++    class public func config(configAction: (SWXMLHashOptions) -> ()) -> SWXMLHash {
+++        let opts = SWXMLHashOptions()
+++        configAction(opts)
+++        return SWXMLHash(opts)
+++    }
+++
+++    /**
+++    Begins parsing the passed in XML string.
+++
+++    - parameters:
+++        - xml: an XML string. __Note__ that this is not a URL but a
+++        string containing XML.
+++    - returns: an `XMLIndexer` instance that can be iterated over
+++    */
+++    public func parse(xml: String) -> XMLIndexer {
+++        return parse((xml as NSString).dataUsingEncoding(NSUTF8StringEncoding)!)
+++    }
+++
+++    /**
+++    Begins parsing the passed in XML string.
+++
+++    - parameters:
+++        - data: an `NSData` instance containing XML
+++        - returns: an `XMLIndexer` instance that can be iterated over
+++    */
+++    public func parse(data: NSData) -> XMLIndexer {
+++        let parser: SimpleXmlParser = options.shouldProcessLazily
+++            ? LazyXMLParser(options)
+++            : XMLParser(options)
+++        return parser.parse(data)
+++    }
+++
+++    /**
+++    Method to parse XML passed in as a string.
+++
+++    - parameter xml: The XML to be parsed
+++    - returns: An XMLIndexer instance that is used to look up elements in the XML
+++    */
+++    class public func parse(xml: String) -> XMLIndexer {
+++        return SWXMLHash().parse(xml)
+++    }
+++
+++    /**
+++    Method to parse XML passed in as an NSData instance.
+++
+++    - parameter data: The XML to be parsed
+++    - returns: An XMLIndexer instance that is used to look up elements in the XML
+++    */
+++    class public func parse(data: NSData) -> XMLIndexer {
+++        return SWXMLHash().parse(data)
+++    }
+++
+++    /**
+++    Method to lazily parse XML passed in as a string.
+++
+++    - parameter xml: The XML to be parsed
+++    - returns: An XMLIndexer instance that is used to look up elements in the XML
+++    */
+++    class public func lazy(xml: String) -> XMLIndexer {
+++        return config { conf in conf.shouldProcessLazily = true }.parse(xml)
+++    }
+++
+++    /**
+++    Method to lazily parse XML passed in as an NSData instance.
+++
+++    - parameter data: The XML to be parsed
+++    - returns: An XMLIndexer instance that is used to look up elements in the XML
+++    */
+++    class public func lazy(data: NSData) -> XMLIndexer {
+++        return config { conf in conf.shouldProcessLazily = true }.parse(data)
+++    }
+++}
+++
+++struct Stack<T> {
+++    var items = [T]()
+++    mutating func push(item: T) {
+++        items.append(item)
+++    }
+++    mutating func pop() -> T {
+++        return items.removeLast()
+++    }
+++    mutating func removeAll() {
+++        items.removeAll(keepCapacity: false)
+++    }
+++    func top() -> T {
+++        return items[items.count - 1]
+++    }
+++}
+++
+++protocol SimpleXmlParser {
+++    init(_ options: SWXMLHashOptions)
+++    func parse(data: NSData) -> XMLIndexer
+++}
+++
+++/// The implementation of NSXMLParserDelegate and where the lazy parsing actually happens.
+++class LazyXMLParser: NSObject, SimpleXmlParser, NSXMLParserDelegate {
+++    required init(_ options: SWXMLHashOptions) {
+++        self.options = options
+++        super.init()
+++    }
+++
+++    var root = XMLElement(name: rootElementName)
+++    var parentStack = Stack<XMLElement>()
+++    var elementStack = Stack<String>()
+++
+++    var data: NSData?
+++    var ops: [IndexOp] = []
+++    let options: SWXMLHashOptions
+++
+++    func parse(data: NSData) -> XMLIndexer {
+++        self.data = data
+++        return XMLIndexer(self)
+++    }
+++
+++    func startParsing(ops: [IndexOp]) {
+++        // clear any prior runs of parse... expected that this won't be necessary,
+++        // but you never know
+++        parentStack.removeAll()
+++        root = XMLElement(name: rootElementName)
+++        parentStack.push(root)
+++
+++        self.ops = ops
+++        let parser = NSXMLParser(data: data!)
+++        parser.shouldProcessNamespaces = options.shouldProcessNamespaces
+++        parser.delegate = self
+++        parser.parse()
+++    }
+++
+++    func parser(parser: NSXMLParser,
+++                didStartElement elementName: String,
+++                namespaceURI: String?,
+++                qualifiedName qName: String?,
+++                attributes attributeDict: [String: String]) {
+++
+++        elementStack.push(elementName)
+++
+++        if !onMatch() {
+++            return
+++        }
+++        let currentNode = parentStack.top().addElement(elementName, withAttributes: attributeDict)
+++        parentStack.push(currentNode)
+++    }
+++
+++    func parser(parser: NSXMLParser, foundCharacters string: String) {
+++        if !onMatch() {
+++            return
+++        }
+++
+++        let current = parentStack.top()
+++
+++        current.addText(string)
+++    }
+++
+++    func parser(parser: NSXMLParser,
+++                didEndElement elementName: String,
+++                namespaceURI: String?,
+++                qualifiedName qName: String?) {
+++
+++        let match = onMatch()
+++
+++        elementStack.pop()
+++
+++        if match {
+++            parentStack.pop()
+++        }
+++    }
+++
+++    func onMatch() -> Bool {
+++        // we typically want to compare against the elementStack to see if it matches ops, *but*
+++        // if we're on the first element, we'll instead compare the other direction.
+++        if elementStack.items.count > ops.count {
+++            return elementStack.items.startsWith(ops.map { $0.key })
+++        } else {
+++            return ops.map { $0.key }.startsWith(elementStack.items)
+++        }
+++    }
+++}
+++
+++/// The implementation of NSXMLParserDelegate and where the parsing actually happens.
+++class XMLParser: NSObject, SimpleXmlParser, NSXMLParserDelegate {
+++    required init(_ options: SWXMLHashOptions) {
+++        self.options = options
+++        super.init()
+++    }
+++
+++    var root = XMLElement(name: rootElementName)
+++    var parentStack = Stack<XMLElement>()
+++    let options: SWXMLHashOptions
+++
+++    func parse(data: NSData) -> XMLIndexer {
+++        // clear any prior runs of parse... expected that this won't be necessary,
+++        // but you never know
+++        parentStack.removeAll()
+++
+++        parentStack.push(root)
+++
+++        let parser = NSXMLParser(data: data)
+++        parser.shouldProcessNamespaces = options.shouldProcessNamespaces
+++        parser.delegate = self
+++        parser.parse()
+++
+++        return XMLIndexer(root)
+++    }
+++
+++    func parser(parser: NSXMLParser,
+++                didStartElement elementName: String,
+++                namespaceURI: String?,
+++                qualifiedName qName: String?,
+++                attributes attributeDict: [String: String]) {
+++
+++        let currentNode = parentStack.top().addElement(elementName, withAttributes: attributeDict)
+++        parentStack.push(currentNode)
+++    }
+++
+++    func parser(parser: NSXMLParser, foundCharacters string: String) {
+++        let current = parentStack.top()
+++
+++        current.addText(string)
+++    }
+++
+++    func parser(parser: NSXMLParser,
+++                didEndElement elementName: String,
+++                namespaceURI: String?,
+++                qualifiedName qName: String?) {
+++
+++        parentStack.pop()
+++    }
+++}
+++
+++/// Represents an indexed operation against a lazily parsed `XMLIndexer`
+++public class IndexOp {
+++    var index: Int
+++    let key: String
+++
+++    init(_ key: String) {
+++        self.key = key
+++        self.index = -1
+++    }
+++
+++    func toString() -> String {
+++        if index >= 0 {
+++            return key + " " + index.description
+++        }
+++
+++        return key
+++    }
+++}
+++
+++/// Represents a collection of `IndexOp` instances. Provides a means of iterating them
+++/// to find a match in a lazily parsed `XMLIndexer` instance.
+++public class IndexOps {
+++    var ops: [IndexOp] = []
+++
+++    let parser: LazyXMLParser
+++
+++    init(parser: LazyXMLParser) {
+++        self.parser = parser
+++    }
+++
+++    func findElements() -> XMLIndexer {
+++        parser.startParsing(ops)
+++        let indexer = XMLIndexer(parser.root)
+++        var childIndex = indexer
+++        for op in ops {
+++            childIndex = childIndex[op.key]
+++            if op.index >= 0 {
+++                childIndex = childIndex[op.index]
+++            }
+++        }
+++        ops.removeAll(keepCapacity: false)
+++        return childIndex
+++    }
+++
+++    func stringify() -> String {
+++        var s = ""
+++        for op in ops {
+++            s += "[" + op.toString() + "]"
+++        }
+++        return s
+++    }
+++}
+++
+++/// Returned from SWXMLHash, allows easy element lookup into XML data.
+++public enum XMLIndexer: SequenceType {
+++    case Element(XMLElement)
+++    case List([XMLElement])
+++    case Stream(IndexOps)
+++    case XMLError(Error)
+++
+++    /// Error type that is thrown when an indexing or parsing operation fails.
+++    public enum Error: ErrorType {
+++        case Attribute(attr: String)
+++        case AttributeValue(attr: String, value: String)
+++        case Key(key: String)
+++        case Index(idx: Int)
+++        case Init(instance: AnyObject)
+++        case Error
+++    }
+++
+++    /// The underlying XMLElement at the currently indexed level of XML.
+++    public var element: XMLElement? {
+++        switch self {
+++        case .Element(let elem):
+++            return elem
+++        case .Stream(let ops):
+++            let list = ops.findElements()
+++            return list.element
+++        default:
+++            return nil
+++        }
+++    }
+++
+++    /// All elements at the currently indexed level
+++    public var all: [XMLIndexer] {
+++        switch self {
+++        case .List(let list):
+++            var xmlList = [XMLIndexer]()
+++            for elem in list {
+++                xmlList.append(XMLIndexer(elem))
+++            }
+++            return xmlList
+++        case .Element(let elem):
+++            return [XMLIndexer(elem)]
+++        case .Stream(let ops):
+++            let list = ops.findElements()
+++            return list.all
+++        default:
+++            return []
+++        }
+++    }
+++
+++    /// All child elements from the currently indexed level
+++    public var children: [XMLIndexer] {
+++        var list = [XMLIndexer]()
+++        for elem in all.map({ $0.element! }).flatMap({ $0 }) {
+++            for elem in elem.xmlChildren {
+++                list.append(XMLIndexer(elem))
+++            }
+++        }
+++        return list
+++    }
+++
+++    /**
+++    Allows for element lookup by matching attribute values.
+++
+++    - parameters:
+++        - attr: should the name of the attribute to match on
+++        - value: should be the value of the attribute to match on
+++    - throws: an XMLIndexer.XMLError if an element with the specified attribute isn't found
+++    - returns: instance of XMLIndexer
+++    */
+++    public func withAttr(attr: String, _ value: String) throws -> XMLIndexer {
+++        switch self {
+++        case .Stream(let opStream):
+++            let match = opStream.findElements()
+++            return try match.withAttr(attr, value)
+++        case .List(let list):
+++            if let elem = list.filter({$0.attributes[attr] == value}).first {
+++                return .Element(elem)
+++            }
+++            throw Error.AttributeValue(attr: attr, value: value)
+++        case .Element(let elem):
+++            if let attr = elem.attributes[attr] {
+++                if attr == value {
+++                    return .Element(elem)
+++                }
+++                throw Error.AttributeValue(attr: attr, value: value)
+++            }
+++            fallthrough
+++        default:
+++            throw Error.Attribute(attr: attr)
+++        }
+++    }
+++
+++    /**
+++    Initializes the XMLIndexer
+++
+++    - parameter _: should be an instance of XMLElement, but supports other values for error handling
+++    - throws: an Error if the object passed in isn't an XMLElement or LaxyXMLParser
+++    */
+++    public init(_ rawObject: AnyObject) throws {
+++        switch rawObject {
+++        case let value as XMLElement:
+++            self = .Element(value)
+++        case let value as LazyXMLParser:
+++            self = .Stream(IndexOps(parser: value))
+++        default:
+++            throw Error.Init(instance: rawObject)
+++        }
+++    }
+++
+++    /**
+++    Initializes the XMLIndexer
+++
+++    - parameter _: an instance of XMLElement
+++    */
+++    public init(_ elem: XMLElement) {
+++        self = .Element(elem)
+++    }
+++
+++    init(_ stream: LazyXMLParser) {
+++        self = .Stream(IndexOps(parser: stream))
+++    }
+++
+++    /**
+++    Find an XML element at the current level by element name
+++
+++    - parameter key: The element name to index by
+++    - returns: instance of XMLIndexer to match the element (or elements) found by key
+++    - throws: Throws an XMLIndexerError.Key if no element was found
+++    */
+++    public func byKey(key: String) throws -> XMLIndexer {
+++        switch self {
+++        case .Stream(let opStream):
+++            let op = IndexOp(key)
+++            opStream.ops.append(op)
+++            return .Stream(opStream)
+++        case .Element(let elem):
+++            let match = elem.xmlChildren.filter({ $0.name == key })
+++            if !match.isEmpty {
+++                if match.count == 1 {
+++                    return .Element(match[0])
+++                } else {
+++                    return .List(match)
+++                }
+++            }
+++            fallthrough
+++        default:
+++            throw Error.Key(key: key)
+++        }
+++    }
+++
+++    /**
+++    Find an XML element at the current level by element name
+++
+++    - parameter key: The element name to index by
+++    - returns: instance of XMLIndexer to match the element (or elements) found by
+++    */
+++    public subscript(key: String) -> XMLIndexer {
+++        do {
+++           return try self.byKey(key)
+++        } catch let error as Error {
+++            return .XMLError(error)
+++        } catch {
+++            return .XMLError(.Key(key: key))
+++        }
+++    }
+++
+++    /**
+++    Find an XML element by index within a list of XML Elements at the current level
+++
+++    - parameter index: The 0-based index to index by
+++    - throws: XMLIndexer.XMLError if the index isn't found
+++    - returns: instance of XMLIndexer to match the element (or elements) found by index
+++    */
+++    public func byIndex(index: Int) throws -> XMLIndexer {
+++        switch self {
+++        case .Stream(let opStream):
+++            opStream.ops[opStream.ops.count - 1].index = index
+++            return .Stream(opStream)
+++        case .List(let list):
+++            if index <= list.count {
+++                return .Element(list[index])
+++            }
+++            return .XMLError(.Index(idx: index))
+++        case .Element(let elem):
+++            if index == 0 {
+++                return .Element(elem)
+++            }
+++            fallthrough
+++        default:
+++            return .XMLError(.Index(idx: index))
+++        }
+++    }
+++
+++    /**
+++    Find an XML element by index
+++
+++    - parameter index: The 0-based index to index by
+++    - returns: instance of XMLIndexer to match the element (or elements) found by index
+++    */
+++    public subscript(index: Int) -> XMLIndexer {
+++        do {
+++            return try byIndex(index)
+++        } catch let error as Error {
+++            return .XMLError(error)
+++        } catch {
+++            return .XMLError(.Index(idx: index))
+++        }
+++    }
+++
+++    typealias GeneratorType = XMLIndexer
+++
+++    /**
+++    Method to iterate (for-in) over the `all` collection
+++
+++    - returns: an array of `XMLIndexer` instances
+++    */
+++    public func generate() -> IndexingGenerator<[XMLIndexer]> {
+++        return all.generate()
+++    }
+++}
+++
+++/// XMLIndexer extensions
+++extension XMLIndexer: BooleanType {
+++    /// True if a valid XMLIndexer, false if an error type
+++    public var boolValue: Bool {
+++        switch self {
+++        case .XMLError:
+++            return false
+++        default:
+++            return true
+++        }
+++    }
+++}
+++
+++extension XMLIndexer: CustomStringConvertible {
+++    /// The XML representation of the XMLIndexer at the current level
+++    public var description: String {
+++        switch self {
+++        case .List(let list):
+++            return list.map { $0.description }.joinWithSeparator("")
+++        case .Element(let elem):
+++            if elem.name == rootElementName {
+++                return elem.children.map { $0.description }.joinWithSeparator("")
+++            }
+++
+++            return elem.description
+++        default:
+++            return ""
+++        }
+++    }
+++}
+++
+++extension XMLIndexer.Error: CustomStringConvertible {
+++    /// The description for the `XMLIndexer.Error`.
+++    public var description: String {
+++        switch self {
+++        case .Attribute(let attr):
+++            return "XML Attribute Error: Missing attribute [\"\(attr)\"]"
+++        case .AttributeValue(let attr, let value):
+++            return "XML Attribute Error: Missing attribute [\"\(attr)\"] with value [\"\(value)\"]"
+++        case .Key(let key):
+++            return "XML Element Error: Incorrect key [\"\(key)\"]"
+++        case .Index(let index):
+++            return "XML Element Error: Incorrect index [\"\(index)\"]"
+++        case .Init(let instance):
+++            return "XML Indexer Error: initialization with Object [\"\(instance)\"]"
+++        case .Error:
+++            return "Unknown Error"
+++        }
+++    }
+++}
+++
+++/// Models content for an XML doc, whether it is text or XML
+++public protocol XMLContent: CustomStringConvertible {
+++}
+++
+++/// Models a text element
+++public class TextElement: XMLContent {
+++    public let text: String
+++    init(text: String) {
+++        self.text = text
+++    }
+++}
+++
+++/// Models an XML element, including name, text and attributes
+++public class XMLElement: XMLContent {
+++    /// The name of the element
+++    public let name: String
+++    /// The attributes of the element
+++    public var attributes = [String:String]()
+++
+++    /// The inner text of the element, if it exists
+++    public var text: String? {
+++        return children
+++            .map({ $0 as? TextElement })
+++            .flatMap({ $0 })
+++            .reduce("", combine: { $0 + $1!.text })
+++    }
+++
+++    public var children = [XMLContent]()
+++    var count: Int = 0
+++    var index: Int
+++
+++    var xmlChildren: [XMLElement] {
+++        return children.map { $0 as? XMLElement }.flatMap { $0 }
+++    }
+++
+++    /**
+++    Initialize an XMLElement instance
+++
+++    - parameters:
+++        - name: The name of the element to be initialized
+++        - index: The index of the element to be initialized
+++    */
+++    init(name: String, index: Int = 0) {
+++        self.name = name
+++        self.index = index
+++    }
+++
+++    /**
+++    Adds a new XMLElement underneath this instance of XMLElement
+++
+++    - parameters:
+++        - name: The name of the new element to be added
+++        - withAttributes: The attributes dictionary for the element being added
+++    - returns: The XMLElement that has now been added
+++    */
+++    func addElement(name: String, withAttributes attributes: NSDictionary) -> XMLElement {
+++        let element = XMLElement(name: name, index: count)
+++        count += 1
+++
+++        children.append(element)
+++
+++        for (keyAny, valueAny) in attributes {
+++            if let key = keyAny as? String,
+++                let value = valueAny as? String {
+++                element.attributes[key] = value
+++            }
+++        }
+++
+++        return element
+++    }
+++
+++    func addText(text: String) {
+++        let elem = TextElement(text: text)
+++
+++        children.append(elem)
+++    }
+++}
+++
+++extension TextElement: CustomStringConvertible {
+++    /// The text value for a `TextElement` instance.
+++    public var description: String {
+++        return text
+++    }
+++}
+++
+++extension XMLElement: CustomStringConvertible {
+++    /// The tag, attributes and content for a `XMLElement` instance (<elem id="foo">content</elem>)
+++    public var description: String {
+++        var attributesStringList = [String]()
+++        if !attributes.isEmpty {
+++            for (key, val) in attributes {
+++                attributesStringList.append("\(key)=\"\(val)\"")
+++            }
+++        }
+++
+++        var attributesString = attributesStringList.joinWithSeparator(" ")
+++        if !attributesString.isEmpty {
+++            attributesString = " " + attributesString
+++        }
+++
+++        if !children.isEmpty {
+++            var xmlReturn = [String]()
+++            xmlReturn.append("<\(name)\(attributesString)>")
+++            for child in children {
+++                xmlReturn.append(child.description)
+++            }
+++            xmlReturn.append("</\(name)>")
+++            return xmlReturn.joinWithSeparator("")
+++        }
+++
+++        if text != nil {
+++            return "<\(name)\(attributesString)>\(text!)</\(name)>"
+++        } else {
+++            return "<\(name)\(attributesString)/>"
+++        }
+++    }
+++}
++diff --git a/Pods/Target Support Files/Alamofire/Alamofire-dummy.m b/Pods/Target Support Files/Alamofire/Alamofire-dummy.m
++new file mode 100644
++index 0000000..a6c4594
++--- /dev/null
+++++ b/Pods/Target Support Files/Alamofire/Alamofire-dummy.m	
++@@ -0,0 +1,5 @@
+++#import <Foundation/Foundation.h>
+++@interface PodsDummy_Alamofire : NSObject
+++@end
+++@implementation PodsDummy_Alamofire
+++@end
++diff --git a/Pods/Target Support Files/Alamofire/Alamofire-prefix.pch b/Pods/Target Support Files/Alamofire/Alamofire-prefix.pch
++new file mode 100644
++index 0000000..b9c163b
++--- /dev/null
+++++ b/Pods/Target Support Files/Alamofire/Alamofire-prefix.pch	
++@@ -0,0 +1,4 @@
+++#ifdef __OBJC__
+++#import <Cocoa/Cocoa.h>
+++#endif
+++
++diff --git a/Pods/Target Support Files/Alamofire/Alamofire-umbrella.h b/Pods/Target Support Files/Alamofire/Alamofire-umbrella.h
++new file mode 100644
++index 0000000..17f78f7
++--- /dev/null
+++++ b/Pods/Target Support Files/Alamofire/Alamofire-umbrella.h	
++@@ -0,0 +1,6 @@
+++#import <Cocoa/Cocoa.h>
+++
+++
+++FOUNDATION_EXPORT double AlamofireVersionNumber;
+++FOUNDATION_EXPORT const unsigned char AlamofireVersionString[];
+++
++diff --git a/Pods/Target Support Files/Alamofire/Alamofire.modulemap b/Pods/Target Support Files/Alamofire/Alamofire.modulemap
++new file mode 100644
++index 0000000..d1f125f
++--- /dev/null
+++++ b/Pods/Target Support Files/Alamofire/Alamofire.modulemap	
++@@ -0,0 +1,6 @@
+++framework module Alamofire {
+++  umbrella header "Alamofire-umbrella.h"
+++
+++  export *
+++  module * { export * }
+++}
++diff --git a/Pods/Target Support Files/Alamofire/Alamofire.xcconfig b/Pods/Target Support Files/Alamofire/Alamofire.xcconfig
++new file mode 100644
++index 0000000..085c786
++--- /dev/null
+++++ b/Pods/Target Support Files/Alamofire/Alamofire.xcconfig	
++@@ -0,0 +1,10 @@
+++CODE_SIGN_IDENTITY =
+++CONFIGURATION_BUILD_DIR = $PODS_CONFIGURATION_BUILD_DIR/Alamofire
+++GCC_PREPROCESSOR_DEFINITIONS = $(inherited) COCOAPODS=1
+++HEADER_SEARCH_PATHS = "${PODS_ROOT}/Headers/Private" "${PODS_ROOT}/Headers/Public"
+++OTHER_SWIFT_FLAGS = $(inherited) "-D" "COCOAPODS"
+++PODS_BUILD_DIR = $BUILD_DIR
+++PODS_CONFIGURATION_BUILD_DIR = $PODS_BUILD_DIR/$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME)
+++PODS_ROOT = ${SRCROOT}
+++PRODUCT_BUNDLE_IDENTIFIER = org.cocoapods.${PRODUCT_NAME:rfc1034identifier}
+++SKIP_INSTALL = YES
++diff --git a/Pods/Target Support Files/Alamofire/Info.plist b/Pods/Target Support Files/Alamofire/Info.plist
++new file mode 100644
++index 0000000..7694605
++--- /dev/null
+++++ b/Pods/Target Support Files/Alamofire/Info.plist	
++@@ -0,0 +1,26 @@
+++<?xml version="1.0" encoding="UTF-8"?>
+++<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+++<plist version="1.0">
+++<dict>
+++  <key>CFBundleDevelopmentRegion</key>
+++  <string>en</string>
+++  <key>CFBundleExecutable</key>
+++  <string>${EXECUTABLE_NAME}</string>
+++  <key>CFBundleIdentifier</key>
+++  <string>${PRODUCT_BUNDLE_IDENTIFIER}</string>
+++  <key>CFBundleInfoDictionaryVersion</key>
+++  <string>6.0</string>
+++  <key>CFBundleName</key>
+++  <string>${PRODUCT_NAME}</string>
+++  <key>CFBundlePackageType</key>
+++  <string>FMWK</string>
+++  <key>CFBundleShortVersionString</key>
+++  <string>3.4.1</string>
+++  <key>CFBundleSignature</key>
+++  <string>????</string>
+++  <key>CFBundleVersion</key>
+++  <string>${CURRENT_PROJECT_VERSION}</string>
+++  <key>NSPrincipalClass</key>
+++  <string></string>
+++</dict>
+++</plist>
++diff --git a/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016-acknowledgements.markdown b/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016-acknowledgements.markdown
++index 8909bc0..0fa66f5 100644
++--- a/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016-acknowledgements.markdown	
+++++ b/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016-acknowledgements.markdown	
++@@ -1,6 +1,29 @@
++ # Acknowledgements
++ This application makes use of the following third party libraries:
++ 
+++## Alamofire
+++
+++Copyright (c) 2014-2016 Alamofire Software Foundation (http://alamofire.org/)
+++
+++Permission is hereby granted, free of charge, to any person obtaining a copy
+++of this software and associated documentation files (the "Software"), to deal
+++in the Software without restriction, including without limitation the rights
+++to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+++copies of the Software, and to permit persons to whom the Software is
+++furnished to do so, subject to the following conditions:
+++
+++The above copyright notice and this permission notice shall be included in
+++all copies or substantial portions of the Software.
+++
+++THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+++IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+++FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+++AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+++LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+++OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+++THE SOFTWARE.
+++
+++
++ ## CocoaAsyncSocket
++ 
++ Public Domain License
++@@ -10,4 +33,28 @@ The CocoaAsyncSocket project is in the public domain.
++ The original TCP version (AsyncSocket) was created by Dustin Voss in January 2003.
++ Updated and maintained by Deusty LLC and the Apple development community.
++ 
+++
+++## SWXMLHash
+++
+++Copyright (c) 2014 David Mohundro
+++ 
+++Permission is hereby granted, free of charge, to any person obtaining
+++a copy of this software and associated documentation files (the
+++"Software"), to deal in the Software without restriction, including
+++without limitation the rights to use, copy, modify, merge, publish,
+++distribute, sublicense, and/or sell copies of the Software, and to
+++permit persons to whom the Software is furnished to do so, subject to
+++the following conditions:
+++ 
+++The above copyright notice and this permission notice shall be
+++included in all copies or substantial portions of the Software.
+++ 
+++THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+++EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+++MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+++NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+++LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+++OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+++WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+++
++ Generated by CocoaPods - https://cocoapods.org
++diff --git a/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016-acknowledgements.plist b/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016-acknowledgements.plist
++index c215120..bb3fd6f 100644
++--- a/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016-acknowledgements.plist	
+++++ b/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016-acknowledgements.plist	
++@@ -14,6 +14,33 @@
++ 		</dict>
++ 		<dict>
++ 			<key>FooterText</key>
+++			<string>Copyright (c) 2014-2016 Alamofire Software Foundation (http://alamofire.org/)
+++
+++Permission is hereby granted, free of charge, to any person obtaining a copy
+++of this software and associated documentation files (the "Software"), to deal
+++in the Software without restriction, including without limitation the rights
+++to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+++copies of the Software, and to permit persons to whom the Software is
+++furnished to do so, subject to the following conditions:
+++
+++The above copyright notice and this permission notice shall be included in
+++all copies or substantial portions of the Software.
+++
+++THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+++IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+++FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+++AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+++LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+++OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+++THE SOFTWARE.
+++</string>
+++			<key>Title</key>
+++			<string>Alamofire</string>
+++			<key>Type</key>
+++			<string>PSGroupSpecifier</string>
+++		</dict>
+++		<dict>
+++			<key>FooterText</key>
++ 			<string>Public Domain License
++ 
++ The CocoaAsyncSocket project is in the public domain.
++@@ -28,6 +55,34 @@ Updated and maintained by Deusty LLC and the Apple development community.
++ 		</dict>
++ 		<dict>
++ 			<key>FooterText</key>
+++			<string>Copyright (c) 2014 David Mohundro
+++ 
+++Permission is hereby granted, free of charge, to any person obtaining
+++a copy of this software and associated documentation files (the
+++"Software"), to deal in the Software without restriction, including
+++without limitation the rights to use, copy, modify, merge, publish,
+++distribute, sublicense, and/or sell copies of the Software, and to
+++permit persons to whom the Software is furnished to do so, subject to
+++the following conditions:
+++ 
+++The above copyright notice and this permission notice shall be
+++included in all copies or substantial portions of the Software.
+++ 
+++THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+++EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+++MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+++NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+++LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+++OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+++WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+++</string>
+++			<key>Title</key>
+++			<string>SWXMLHash</string>
+++			<key>Type</key>
+++			<string>PSGroupSpecifier</string>
+++		</dict>
+++		<dict>
+++			<key>FooterText</key>
++ 			<string>Generated by CocoaPods - https://cocoapods.org</string>
++ 			<key>Title</key>
++ 			<string></string>
++diff --git a/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016-frameworks.sh b/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016-frameworks.sh
++index 2cfb978..54d016b 100755
++--- a/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016-frameworks.sh	
+++++ b/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016-frameworks.sh	
++@@ -84,8 +84,12 @@ strip_invalid_archs() {
++ 
++ 
++ if [[ "$CONFIGURATION" == "Debug" ]]; then
+++  install_framework "$BUILT_PRODUCTS_DIR/Alamofire/Alamofire.framework"
++   install_framework "$BUILT_PRODUCTS_DIR/CocoaAsyncSocket/CocoaAsyncSocket.framework"
+++  install_framework "$BUILT_PRODUCTS_DIR/SWXMLHash/SWXMLHash.framework"
++ fi
++ if [[ "$CONFIGURATION" == "Release" ]]; then
+++  install_framework "$BUILT_PRODUCTS_DIR/Alamofire/Alamofire.framework"
++   install_framework "$BUILT_PRODUCTS_DIR/CocoaAsyncSocket/CocoaAsyncSocket.framework"
+++  install_framework "$BUILT_PRODUCTS_DIR/SWXMLHash/SWXMLHash.framework"
++ fi
++diff --git a/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016.debug.xcconfig b/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016.debug.xcconfig
++index 6699faa..261e5cb 100644
++--- a/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016.debug.xcconfig	
+++++ b/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016.debug.xcconfig	
++@@ -1,9 +1,11 @@
++ CODE_SIGN_IDENTITY =
++-FRAMEWORK_SEARCH_PATHS = $(inherited) "$PODS_CONFIGURATION_BUILD_DIR/CocoaAsyncSocket"
+++EMBEDDED_CONTENT_CONTAINS_SWIFT = YES
+++FRAMEWORK_SEARCH_PATHS = $(inherited) "$PODS_CONFIGURATION_BUILD_DIR/Alamofire" "$PODS_CONFIGURATION_BUILD_DIR/CocoaAsyncSocket" "$PODS_CONFIGURATION_BUILD_DIR/SWXMLHash"
++ GCC_PREPROCESSOR_DEFINITIONS = $(inherited) COCOAPODS=1
++ LD_RUNPATH_SEARCH_PATHS = $(inherited) '@executable_path/../Frameworks' '@loader_path/Frameworks'
++-OTHER_CFLAGS = $(inherited) -iquote "$PODS_CONFIGURATION_BUILD_DIR/CocoaAsyncSocket/CocoaAsyncSocket.framework/Headers"
++-OTHER_LDFLAGS = $(inherited) -framework "CocoaAsyncSocket"
+++OTHER_CFLAGS = $(inherited) -iquote "$PODS_CONFIGURATION_BUILD_DIR/Alamofire/Alamofire.framework/Headers" -iquote "$PODS_CONFIGURATION_BUILD_DIR/CocoaAsyncSocket/CocoaAsyncSocket.framework/Headers" -iquote "$PODS_CONFIGURATION_BUILD_DIR/SWXMLHash/SWXMLHash.framework/Headers"
+++OTHER_LDFLAGS = $(inherited) -framework "Alamofire" -framework "CocoaAsyncSocket" -framework "SWXMLHash"
+++OTHER_SWIFT_FLAGS = $(inherited) "-D" "COCOAPODS"
++ PODS_BUILD_DIR = $BUILD_DIR
++ PODS_CONFIGURATION_BUILD_DIR = $PODS_BUILD_DIR/$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME)
++ PODS_ROOT = ${SRCROOT}/Pods
++diff --git a/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016.release.xcconfig b/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016.release.xcconfig
++index 6699faa..261e5cb 100644
++--- a/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016.release.xcconfig	
+++++ b/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016.release.xcconfig	
++@@ -1,9 +1,11 @@
++ CODE_SIGN_IDENTITY =
++-FRAMEWORK_SEARCH_PATHS = $(inherited) "$PODS_CONFIGURATION_BUILD_DIR/CocoaAsyncSocket"
+++EMBEDDED_CONTENT_CONTAINS_SWIFT = YES
+++FRAMEWORK_SEARCH_PATHS = $(inherited) "$PODS_CONFIGURATION_BUILD_DIR/Alamofire" "$PODS_CONFIGURATION_BUILD_DIR/CocoaAsyncSocket" "$PODS_CONFIGURATION_BUILD_DIR/SWXMLHash"
++ GCC_PREPROCESSOR_DEFINITIONS = $(inherited) COCOAPODS=1
++ LD_RUNPATH_SEARCH_PATHS = $(inherited) '@executable_path/../Frameworks' '@loader_path/Frameworks'
++-OTHER_CFLAGS = $(inherited) -iquote "$PODS_CONFIGURATION_BUILD_DIR/CocoaAsyncSocket/CocoaAsyncSocket.framework/Headers"
++-OTHER_LDFLAGS = $(inherited) -framework "CocoaAsyncSocket"
+++OTHER_CFLAGS = $(inherited) -iquote "$PODS_CONFIGURATION_BUILD_DIR/Alamofire/Alamofire.framework/Headers" -iquote "$PODS_CONFIGURATION_BUILD_DIR/CocoaAsyncSocket/CocoaAsyncSocket.framework/Headers" -iquote "$PODS_CONFIGURATION_BUILD_DIR/SWXMLHash/SWXMLHash.framework/Headers"
+++OTHER_LDFLAGS = $(inherited) -framework "Alamofire" -framework "CocoaAsyncSocket" -framework "SWXMLHash"
+++OTHER_SWIFT_FLAGS = $(inherited) "-D" "COCOAPODS"
++ PODS_BUILD_DIR = $BUILD_DIR
++ PODS_CONFIGURATION_BUILD_DIR = $PODS_BUILD_DIR/$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME)
++ PODS_ROOT = ${SRCROOT}/Pods
++diff --git a/Pods/Target Support Files/SWXMLHash/Info.plist b/Pods/Target Support Files/SWXMLHash/Info.plist
++new file mode 100644
++index 0000000..e526849
++--- /dev/null
+++++ b/Pods/Target Support Files/SWXMLHash/Info.plist	
++@@ -0,0 +1,26 @@
+++<?xml version="1.0" encoding="UTF-8"?>
+++<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+++<plist version="1.0">
+++<dict>
+++  <key>CFBundleDevelopmentRegion</key>
+++  <string>en</string>
+++  <key>CFBundleExecutable</key>
+++  <string>${EXECUTABLE_NAME}</string>
+++  <key>CFBundleIdentifier</key>
+++  <string>${PRODUCT_BUNDLE_IDENTIFIER}</string>
+++  <key>CFBundleInfoDictionaryVersion</key>
+++  <string>6.0</string>
+++  <key>CFBundleName</key>
+++  <string>${PRODUCT_NAME}</string>
+++  <key>CFBundlePackageType</key>
+++  <string>FMWK</string>
+++  <key>CFBundleShortVersionString</key>
+++  <string>2.4.0</string>
+++  <key>CFBundleSignature</key>
+++  <string>????</string>
+++  <key>CFBundleVersion</key>
+++  <string>${CURRENT_PROJECT_VERSION}</string>
+++  <key>NSPrincipalClass</key>
+++  <string></string>
+++</dict>
+++</plist>
++diff --git a/Pods/Target Support Files/SWXMLHash/SWXMLHash-dummy.m b/Pods/Target Support Files/SWXMLHash/SWXMLHash-dummy.m
++new file mode 100644
++index 0000000..6a0dbe3
++--- /dev/null
+++++ b/Pods/Target Support Files/SWXMLHash/SWXMLHash-dummy.m	
++@@ -0,0 +1,5 @@
+++#import <Foundation/Foundation.h>
+++@interface PodsDummy_SWXMLHash : NSObject
+++@end
+++@implementation PodsDummy_SWXMLHash
+++@end
++diff --git a/Pods/Target Support Files/SWXMLHash/SWXMLHash-prefix.pch b/Pods/Target Support Files/SWXMLHash/SWXMLHash-prefix.pch
++new file mode 100644
++index 0000000..b9c163b
++--- /dev/null
+++++ b/Pods/Target Support Files/SWXMLHash/SWXMLHash-prefix.pch	
++@@ -0,0 +1,4 @@
+++#ifdef __OBJC__
+++#import <Cocoa/Cocoa.h>
+++#endif
+++
++diff --git a/Pods/Target Support Files/SWXMLHash/SWXMLHash-umbrella.h b/Pods/Target Support Files/SWXMLHash/SWXMLHash-umbrella.h
++new file mode 100644
++index 0000000..4031b21
++--- /dev/null
+++++ b/Pods/Target Support Files/SWXMLHash/SWXMLHash-umbrella.h	
++@@ -0,0 +1,6 @@
+++#import <Cocoa/Cocoa.h>
+++
+++
+++FOUNDATION_EXPORT double SWXMLHashVersionNumber;
+++FOUNDATION_EXPORT const unsigned char SWXMLHashVersionString[];
+++
++diff --git a/Pods/Target Support Files/SWXMLHash/SWXMLHash.modulemap b/Pods/Target Support Files/SWXMLHash/SWXMLHash.modulemap
++new file mode 100644
++index 0000000..42b046c
++--- /dev/null
+++++ b/Pods/Target Support Files/SWXMLHash/SWXMLHash.modulemap	
++@@ -0,0 +1,6 @@
+++framework module SWXMLHash {
+++  umbrella header "SWXMLHash-umbrella.h"
+++
+++  export *
+++  module * { export * }
+++}
++diff --git a/Pods/Target Support Files/SWXMLHash/SWXMLHash.xcconfig b/Pods/Target Support Files/SWXMLHash/SWXMLHash.xcconfig
++new file mode 100644
++index 0000000..a3b85e0
++--- /dev/null
+++++ b/Pods/Target Support Files/SWXMLHash/SWXMLHash.xcconfig	
++@@ -0,0 +1,10 @@
+++CODE_SIGN_IDENTITY =
+++CONFIGURATION_BUILD_DIR = $PODS_CONFIGURATION_BUILD_DIR/SWXMLHash
+++GCC_PREPROCESSOR_DEFINITIONS = $(inherited) COCOAPODS=1
+++HEADER_SEARCH_PATHS = "${PODS_ROOT}/Headers/Private" "${PODS_ROOT}/Headers/Public"
+++OTHER_SWIFT_FLAGS = $(inherited) "-D" "COCOAPODS"
+++PODS_BUILD_DIR = $BUILD_DIR
+++PODS_CONFIGURATION_BUILD_DIR = $PODS_BUILD_DIR/$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME)
+++PODS_ROOT = ${SRCROOT}
+++PRODUCT_BUNDLE_IDENTIFIER = org.cocoapods.${PRODUCT_NAME:rfc1034identifier}
+++SKIP_INSTALL = YES
++diff --git a/initDiff b/initDiff
++new file mode 100644
++index 0000000..e69de29
++diff --git a/output-file b/output-file
++new file mode 100644
++index 0000000..e69de29
++diff --git a/patch.diff b/patch.diff
++new file mode 100644
++index 0000000..e69de29
++diff --git a/patch.txt b/patch.txt
++new file mode 100644
++index 0000000..e69de29
+diff --git a/CRMCall092016.xcodeproj/project.pbxproj b/CRMCall092016.xcodeproj/project.pbxproj
+index 7c41d9c..5322e54 100644
+--- a/CRMCall092016.xcodeproj/project.pbxproj
++++ b/CRMCall092016.xcodeproj/project.pbxproj
+@@ -8,6 +8,7 @@
+ 
+ /* Begin PBXBuildFile section */
+ 		922840301D865A720059A0D7 /* CRMCallSocket.swift in Sources */ = {isa = PBXBuildFile; fileRef = 9228402F1D865A720059A0D7 /* CRMCallSocket.swift */; };
++		92B0F0481D88E53700C70BC3 /* CRMCallHelpers.swift in Sources */ = {isa = PBXBuildFile; fileRef = 92B0F0471D88E53700C70BC3 /* CRMCallHelpers.swift */; };
+ 		92E2341A1D812899006C988E /* ModelManger.swift in Sources */ = {isa = PBXBuildFile; fileRef = 92E234191D812899006C988E /* ModelManger.swift */; };
+ 		92E2341D1D81443F006C988E /* AlamofireManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 92E2341C1D81443F006C988E /* AlamofireManager.swift */; };
+ 		92E2341F1D81447D006C988E /* SWXMLHashManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 92E2341E1D81447D006C988E /* SWXMLHashManager.swift */; };
+@@ -28,6 +29,7 @@
+ 		638056E88800D61CD44C46F6 /* Pods-CRMCall092016.release.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-CRMCall092016.release.xcconfig"; path = "Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016.release.xcconfig"; sourceTree = "<group>"; };
+ 		867B73DF25B4547C396A7607 /* Pods-CRMCall092016.debug.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-CRMCall092016.debug.xcconfig"; path = "Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016.debug.xcconfig"; sourceTree = "<group>"; };
+ 		9228402F1D865A720059A0D7 /* CRMCallSocket.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = CRMCallSocket.swift; sourceTree = "<group>"; };
++		92B0F0471D88E53700C70BC3 /* CRMCallHelpers.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = CRMCallHelpers.swift; sourceTree = "<group>"; };
+ 		92E234191D812899006C988E /* ModelManger.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = ModelManger.swift; sourceTree = "<group>"; };
+ 		92E2341C1D81443F006C988E /* AlamofireManager.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = AlamofireManager.swift; sourceTree = "<group>"; };
+ 		92E2341E1D81447D006C988E /* SWXMLHashManager.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = SWXMLHashManager.swift; sourceTree = "<group>"; };
+@@ -58,6 +60,13 @@
+ /* End PBXFrameworksBuildPhase section */
+ 
+ /* Begin PBXGroup section */
++		92B0F0491D88F05800C70BC3 /* Caches */ = {
++			isa = PBXGroup;
++			children = (
++			);
++			path = Caches;
++			sourceTree = "<group>";
++		};
+ 		92E234181D81281D006C988E /* Models */ = {
+ 			isa = PBXGroup;
+ 			children = (
+@@ -95,6 +104,7 @@
+ 		92E3E3111D8004C3008033ED /* CRMCall092016 */ = {
+ 			isa = PBXGroup;
+ 			children = (
++				92B0F0491D88F05800C70BC3 /* Caches */,
+ 				92E234181D81281D006C988E /* Models */,
+ 				92E3E3211D8004F4008033ED /* Helpers */,
+ 				92E3E32C1D80066C008033ED /* Library */,
+@@ -117,6 +127,7 @@
+ 				92E3E3221D800538008033ED /* CRMCall092016-Bridging-Header.h */,
+ 				92E3E3301D800947008033ED /* CRMCallConfig.swift */,
+ 				92E3E3341D8011FC008033ED /* CRMCallLog.swift */,
++				92B0F0471D88E53700C70BC3 /* CRMCallHelpers.swift */,
+ 			);
+ 			path = Helpers;
+ 			sourceTree = "<group>";
+@@ -305,6 +316,7 @@
+ 				922840301D865A720059A0D7 /* CRMCallSocket.swift in Sources */,
+ 				92E234241D814647006C988E /* XMLRequestBuilder.swift in Sources */,
+ 				92E3E3151D8004C3008033ED /* ViewController.swift in Sources */,
++				92B0F0481D88E53700C70BC3 /* CRMCallHelpers.swift in Sources */,
+ 				92E3E3131D8004C3008033ED /* AppDelegate.swift in Sources */,
+ 				92E3E3291D8005E2008033ED /* AESExtension.m in Sources */,
+ 				92E2341A1D812899006C988E /* ModelManger.swift in Sources */,
+diff --git a/CRMCall092016.xcworkspace/xcuserdata/hanbiro.xcuserdatad/UserInterfaceState.xcuserstate b/CRMCall092016.xcworkspace/xcuserdata/hanbiro.xcuserdatad/UserInterfaceState.xcuserstate
+index 9ee2155..0dd48d4 100644
+Binary files a/CRMCall092016.xcworkspace/xcuserdata/hanbiro.xcuserdatad/UserInterfaceState.xcuserstate and b/CRMCall092016.xcworkspace/xcuserdata/hanbiro.xcuserdatad/UserInterfaceState.xcuserstate differ
+diff --git a/CRMCall092016/Helpers/CRMCallConfig.swift b/CRMCall092016/Helpers/CRMCallConfig.swift
+index e3d3a96..376b1f0 100644
+--- a/CRMCall092016/Helpers/CRMCallConfig.swift
++++ b/CRMCall092016/Helpers/CRMCallConfig.swift
+@@ -12,8 +12,11 @@ final class CRMCallConfig {
+     
+     static let Version = "20150202"
+     static let DeviceID = "MAC"
++    
+     static let HostName = "global3.hanbiro.com"
+     
++    static let TimerInterval = 10.0
++    
+     static let HeaderLength:UInt = 6
+     
+     // MARK: Tab
+@@ -25,8 +28,9 @@ final class CRMCallConfig {
+     
+     // MARK: Notification
+     struct Notification {
+-        static let SocketDidConnected = "SocketManager.SocketDidConnected"
+-        static let SocketDisConnected = "SocketManager.SocketDisConnected"
++        static let SocketDidConnected = "CRMCallConfig.Notification.SocketDidConnected"
++        static let SocketDisConnected = "CRMCallConfig.Notification.SocketDisConnected"
++        static let RecivedServerInfor = "CRMCallConfig.Notification.RecivedServerInfor"
+     }
+     
+     // MARK: API
+@@ -34,7 +38,4 @@ final class CRMCallConfig {
+         static let GetPortAndHostURL = "http://\(CRMCallConfig.HostName)/winapp/hcsong/crmcall/\(CRMCallConfig.HostName)/server.xml"
+     }
+     
+-    
+-    
+-    
+ }
+diff --git a/CRMCall092016/Helpers/CRMCallHelpers.swift b/CRMCall092016/Helpers/CRMCallHelpers.swift
+new file mode 100644
+index 0000000..a7759ba
+--- /dev/null
++++ b/CRMCall092016/Helpers/CRMCallHelpers.swift
+@@ -0,0 +1,19 @@
++//
++//  CRMCallHelpers.swift
++//  CRMCall092016
++//
++//  Created by Hanbiro on 9/14/16.
++//  Copyright © 2016 xuanvinhtd. All rights reserved.
++//
++
++import Foundation
++
++final class CRMCallHelpers {
++    
++    enum TypeData {
++        case UserLogin
++        case ServerInfo
++        case UserLive
++        case None
++    }
++}
+\ No newline at end of file
+diff --git a/CRMCall092016/Helpers/XML/XMLRequestBuilder.swift b/CRMCall092016/Helpers/XML/XMLRequestBuilder.swift
+index db4a433..00f40ec 100644
+--- a/CRMCall092016/Helpers/XML/XMLRequestBuilder.swift
++++ b/CRMCall092016/Helpers/XML/XMLRequestBuilder.swift
+@@ -19,10 +19,10 @@ final class XMLRequestBuilder {
+     
+     static func logOutRequest() -> String {
+         
+-        return String(format: "<XML><VER>%@</VER><USER><LOGOUT></LOGOUT></USER></XML>", CRMCallConfig.Version)
++        return String(format: "<XML> <VER>%@</VER> <USER> <LOGOUT> </LOGOUT> </USER> </XML>", CRMCallConfig.Version)
+     }
+     
+     static func liveRequest() -> String {
+-        return String(format: "<XML><VER>%@</VER><ALARM><LIVE/></ALARM></XML>", CRMCallConfig.Version)
++        return String(format: "<XML> <VER>PROTOCOL_VER</VER> <ALARM> <LIVE/> </ALARM> </XML> ", CRMCallConfig.Version)
+     }
+ }
+\ No newline at end of file
+diff --git a/CRMCall092016/Library/SWXMLHashManager.swift b/CRMCall092016/Library/SWXMLHashManager.swift
+index aa21a07..4d95cd9 100644
+--- a/CRMCall092016/Library/SWXMLHashManager.swift
++++ b/CRMCall092016/Library/SWXMLHashManager.swift
+@@ -14,22 +14,46 @@ import SWXMLHash
+ final class SWXMLHashManager {
+     
+     // MARK: - XML PARSER
+-    static func parseXMLToDictionary(withXML xmlData: String) -> [String: String] {
++    static func parseXMLToDictionary(withXML xmlData: String, Completion completion: (([String: String], CRMCallHelpers.TypeData) ->Void)?) {
++        
++        var result: [String: String] = [:]
++        
++        guard let completion = completion else {
++            
++            println("Do not found closure COMPLETION")
++            return
++        }
+         
+         let xmlDocument = SWXMLHash.parse(xmlData)
+         
+         if let _ = xmlDocument["XML"]["USER"].element {
+-            return userData(withData: xmlDocument)
++            
++            result =  userData(withData: xmlDocument)
++            completion(result, CRMCallHelpers.TypeData.UserLogin)
++            
++            return
+         }
+         
+         if let _ = xmlDocument["XML"]["SERVERINFO"].element {
+-            return getHostAndPost(withData: xmlDocument)
++            
++            result = getHostAndPost(withData: xmlDocument)
++            completion(result, CRMCallHelpers.TypeData.ServerInfo)
++            
++            return
+         }
+         
+-        return [:]
++        if let _ = xmlDocument["XML"]["LIVE"].element {
++            
++            result = getLiveData(withData: xmlDocument)
++            completion(result, CRMCallHelpers.TypeData.UserLive)
++            
++            return
++        }
++        
++        completion(result, CRMCallHelpers.TypeData.None)
+     }
+     
+-    private static func userData(withData data: XMLIndexer) -> [String: String]{
++    private static func userData(withData data: XMLIndexer) -> [String: String] {
+         
+         if let _ = data["XML"]["USER"]["LOGIN"].element {
+             
+@@ -40,7 +64,7 @@ final class SWXMLHashManager {
+             
+             println("Result parse User: --------XXX------- \n \(userDictionnary)")
+             
+-            NSNotificationCenter.defaultCenter().postNotificationName(ViewController.Notification.loginSuccess, object: nil, userInfo: nil)
++            NSNotificationCenter.defaultCenter().postNotificationName(ViewController.Notification.LoginSuccess, object: nil, userInfo: nil)
+             
+             return userDictionnary.attributes
+         }
+@@ -52,9 +76,9 @@ final class SWXMLHashManager {
+                 return [:]
+             }
+ 
+-            println("Result parse User: --------XXX------- \n \(userDictionnary)")
++            println("Result parse Logout user: --------XXX------- \n \(userDictionnary)")
+             
+-            NSNotificationCenter.defaultCenter().postNotificationName(ViewController.Notification.logoutSuccess, object: nil, userInfo: nil)
++            NSNotificationCenter.defaultCenter().postNotificationName(ViewController.Notification.LogoutSuccess, object: nil, userInfo: nil)
+             
+             return userDictionnary.attributes
+         }
+@@ -62,7 +86,7 @@ final class SWXMLHashManager {
+         return [:]
+     }
+ 
+-    private static func getHostAndPost(withData data: XMLIndexer) -> [String: String]{
++    private static func getHostAndPost(withData data: XMLIndexer) -> [String: String] {
+ 
+         guard let userDictionnary = data["XML"]["SERVERINFO"].element else {
+             println("Cannot parse XML: SERVERINFO")
+@@ -73,6 +97,18 @@ final class SWXMLHashManager {
+         
+         return userDictionnary.attributes
+     }
++    
++    private static func getLiveData(withData data: XMLIndexer) -> [String: String] {
++        
++        guard let userDictionnary = data["XML"]["ALARM"].element else {
++            println("Cannot parse XML: LIVE")
++            return [:]
++        }
++        
++        println("Result parse Live: --------XXX------- \n \(userDictionnary)")
++        
++        return userDictionnary.attributes
++    }
+ }
+ 
+ // MARK: USER
+diff --git a/CRMCall092016/Server/Socket/BaseSocket.swift b/CRMCall092016/Server/Socket/BaseSocket.swift
+index a74e975..eb23818 100644
+--- a/CRMCall092016/Server/Socket/BaseSocket.swift
++++ b/CRMCall092016/Server/Socket/BaseSocket.swift
+@@ -20,6 +20,8 @@ class BaseSocket: NSObject {
+     
+     private var aesExtension: AESExtension
+     private var asynSocket: GCDAsyncSocket!
++    
++    private var socketQueue: dispatch_queue_t
+ 
+     private var port: UInt16
+     private var host: String
+@@ -32,9 +34,11 @@ class BaseSocket: NSObject {
+         self.port = port
+         self.aesExtension = AESExtension()
+         
++        self.socketQueue = dispatch_queue_create("Socket.queue", DISPATCH_QUEUE_SERIAL)
++        
+         super.init()
+         
+-        self.asynSocket = GCDAsyncSocket(delegate: self, delegateQueue: dispatch_get_main_queue())
++        self.asynSocket = GCDAsyncSocket(delegate: self, delegateQueue: self.socketQueue)
+     }
+     
+     override init() {
+@@ -43,6 +47,8 @@ class BaseSocket: NSObject {
+         self.port = 0
+         self.aesExtension = AESExtension()
+         
++        self.socketQueue = dispatch_queue_create("Socket.queue", DISPATCH_QUEUE_SERIAL)
++        
+         super.init()
+         
+         self.asynSocket = GCDAsyncSocket(delegate: self, delegateQueue: dispatch_get_main_queue())
+@@ -54,13 +60,18 @@ class BaseSocket: NSObject {
+     
+     func connect() {
+         
+-        do {
+-
+-           try asynSocket.connectToHost(host, onPort: port)
+-            
+-        } catch let err {
+-            println("Error connect socket: \(err)")
+-        }
++        //dispatch_async(socketQueue) {
++            do {
++                if self.host != "" && self.port != 0 {
++                    try self.asynSocket.connectToHost(self.host, onPort: self.port)
++                } else {
++                    println("Not enought info host and port")
++                }
++                
++            } catch let err {
++                println("Error connect socket: \(err)")
++            }
++       // }
+     }
+     
+     func disConnect() {
+@@ -70,15 +81,19 @@ class BaseSocket: NSObject {
+         isConnectedToHost = false
+     }
+     
+-    func configData(withData strData: String) {
+-        
+-        let encryptData = aesExtension.aesEncryptString(strData)
+-        
+-        let headerData = String(format: "%05lu", (encryptData?.characters.count)! + 1)
++    func configAndSendData(withData strData: String) {
+         
+-        let requestData = headerData + String(format: "%@%@", flagEncrypt, encryptData!)
+-        
+-        sendData(requestData.dataUsingEncoding(NSUTF8StringEncoding)!)
++       // dispatch_async(socketQueue) {
++            let encryptData = self.aesExtension.aesEncryptString(strData)
++            
++            let headerData = String(format: "%05lu", (encryptData?.characters.count)! + 1)
++            
++            let requestData = headerData + String(format: "%@%@", self.flagEncrypt, encryptData!)
++            
++            println("Data request: \(requestData)")
++            
++            self.sendData(requestData.dataUsingEncoding(NSUTF8StringEncoding)!)
++      //  }
+     }
+     
+    private func sendData(data: NSData) {
+@@ -96,21 +111,25 @@ class BaseSocket: NSObject {
+                 return
+             }
+             
+-            guard let result = NSString(data: _response, encoding: NSUTF8StringEncoding) as? String else {
++            guard let xml = NSString(data: _response, encoding: NSUTF8StringEncoding) as? String else {
+                 println("Not found data to server")
+                 return
+             }
+             
+-            let resultDic = SWXMLHashManager.parseXMLToDictionary(withXML: result)
+-            
+-            if let port = resultDic["PORT"], host = resultDic["IP"] {
+-                self.port = UInt16(port)!
+-                self.host = host
+-            } else {
+-                println("Cannot parse port and host: \(CRMCallConfig.HostName)")
+-            }
+-            
+-            NSNotificationCenter.defaultCenter().postNotificationName(ViewController.Notification.connectToHost, object: nil, userInfo: nil)
++            SWXMLHashManager.parseXMLToDictionary(withXML: xml, Completion: { result, typeData in
++                
++                if typeData == CRMCallHelpers.TypeData.ServerInfo {
++                    
++                    if let port = result["PORT"], host = result["IP"] {
++                        self.port = UInt16(port)!
++                        self.host = host
++                        
++                        NSNotificationCenter.defaultCenter().postNotificationName(CRMCallConfig.Notification.RecivedServerInfor, object: nil, userInfo: nil)
++                    } else {
++                        println("Cannot parse port and host: \(CRMCallConfig.HostName)")
++                    }
++                }
++            })
+         }
+     }
+ }
+@@ -120,49 +139,60 @@ extension BaseSocket: GCDAsyncSocketDelegate {
+     
+     func socket(sock: GCDAsyncSocket, didReadData data: NSData, withTag tag: Int) {
+         
+-        if tag == CRMCallConfig.Tab.Header {
+-            
+-            guard let headerData = NSString(data: data, encoding: NSUTF8StringEncoding) else {
+-                fatalError("Not found header data")
+-            }
+-
+-            println("Data header: \(headerData)")
+-            
+-            let lenghtHeader = (UInt(headerData.substringToIndex(5))! - 1)
+-            flagEncrypt = headerData.substringFromIndex(5)
+-            
+-            asynSocket.readDataToLength(lenghtHeader, withTimeout: readTimeOut , tag: CRMCallConfig.Tab.BodyData)
+-            
+-            
+-        } else if (tag == CRMCallConfig.Tab.BodyData) {
+-            
+-            guard let bodyData = NSString(data: data, encoding: NSUTF8StringEncoding) as? String else {
+-                fatalError("Not found body data")
+-            }
+-
+-            var decryptBodyData = ""
+-            
+-            if flagEncrypt == "1" {
++      //  dispatch_async(socketQueue) {
++            if tag == CRMCallConfig.Tab.Header {
++                
++                guard let headerData = NSString(data: data, encoding: NSUTF8StringEncoding) else {
++                    fatalError("Not found header data")
++                }
++                
++                println("Recived data header: \(headerData)")
++                
++                let lenghtHeader = (UInt(headerData.substringToIndex(5))! - 1)
++                self.flagEncrypt = headerData.substringFromIndex(5)
++                
++                self.asynSocket.readDataToLength(lenghtHeader, withTimeout: self.readTimeOut , tag: CRMCallConfig.Tab.BodyData)
++                
++                
++            } else if (tag == CRMCallConfig.Tab.BodyData) {
++                
++                guard let bodyData = NSString(data: data, encoding: NSUTF8StringEncoding) as? String else {
++                    fatalError("Not found body data")
++                }
++                
++                var decryptBodyData = ""
+                 
+-                guard let dataDecrypt = aesExtension.aesDecryptString(bodyData) else {
+-                    fatalError("Not Decrypt body data")
++                if self.flagEncrypt == "1" {
++                    
++                    guard let dataDecrypt = self.aesExtension.aesDecryptString(bodyData) else {
++                        fatalError("Not Decrypt body data")
++                    }
++                    
++                    decryptBodyData = dataDecrypt
++                } else {
++                    decryptBodyData = bodyData
+                 }
+                 
+-                decryptBodyData = dataDecrypt
+-            } else {
+-                decryptBodyData = bodyData
++                println("Recived data body: \(decryptBodyData)")
++                
++                self.asynSocket.readDataToLength(CRMCallConfig.HeaderLength, withTimeout: self.readTimeOut, tag: CRMCallConfig.Tab.Header)
++                
++                SWXMLHashManager.parseXMLToDictionary(withXML: decryptBodyData, Completion: { result, typeData in
++                    
++                    
++                    if typeData == CRMCallHelpers.TypeData.UserLogin {
++                        
++                        println("Data user : \(result)")
++                    }
++                    
++                    if typeData == CRMCallHelpers.TypeData.UserLive {
++                        
++                        println("Data live : \(result)")
++                    }
++
++                })
+             }
+-            
+-            println("Data body: \(decryptBodyData)")
+-            
+-            asynSocket.readDataToLength(CRMCallConfig.HeaderLength, withTimeout: readTimeOut, tag: CRMCallConfig.Tab.Header)
+-            
+-            SWXMLHashManager.parseXMLToDictionary(withXML: decryptBodyData)
+-        }
+-    }
+-    
+-    func socket(sock: GCDAsyncSocket, didWritePartialDataOfLength partialLength: UInt, tag: Int) {
+-        println("lenght: \(partialLength)")
++     //   }
+     }
+     
+     func socket(sock: GCDAsyncSocket, didConnectToHost host: String, port: UInt16) {
+@@ -175,4 +205,13 @@ extension BaseSocket: GCDAsyncSocketDelegate {
+         
+         NSNotificationCenter.defaultCenter().postNotificationName(CRMCallConfig.Notification.SocketDidConnected, object: nil, userInfo: nil)
+     }
++    
++    func socketDidDisconnect(sock: GCDAsyncSocket, withError err: NSError?) {
++        
++        println("Error DidDisconnect: \(err)")
++        
++        self.isConnectedToHost = false
++        
++        NSNotificationCenter.defaultCenter().postNotificationName(CRMCallConfig.Notification.SocketDisConnected, object: nil, userInfo: nil)
++    }
+ }
+diff --git a/CRMCall092016/Server/Socket/CRMCallSocket.swift b/CRMCall092016/Server/Socket/CRMCallSocket.swift
+index bcc5fb3..8540d0d 100644
+--- a/CRMCall092016/Server/Socket/CRMCallSocket.swift
++++ b/CRMCall092016/Server/Socket/CRMCallSocket.swift
+@@ -11,14 +11,55 @@ import Foundation
+ final class CRMCallSocket: BaseSocket {
+     
+     // MARK: - Properties
+-    var timerLive: String
++    var liveTimer: NSTimer?
++    
++    var handerNotificationLoginSuccess: AnyObject?
++    var handerNotificationLogoutSuccess: AnyObject?
+     
+     // MARK: - Initialzation
+     override init() {
+         
+-        timerLive = ""
+         super.init()
+         
++        registerNotification()
++    }
++    
++    deinit {
++        deregisterNotification()
++    }
++    
++    // MARK: - NOTIFICATION
++    
++    private func registerNotification() {
++        
++        if handerNotificationLoginSuccess == nil {
++            handerNotificationLoginSuccess = NSNotificationCenter.defaultCenter().addObserverForName(ViewController.Notification.LoginSuccess, object: nil, queue: nil, usingBlock: { notification in
++                
++                println("Class: \(NSStringFromClass(self.dynamicType)) recived: \(notification.name)")
++                
++                self.startLiveTimer()
++            })
++        }
++        
++        if handerNotificationLogoutSuccess == nil {
++            handerNotificationLogoutSuccess = NSNotificationCenter.defaultCenter().addObserverForName(CRMCallConfig.Notification.SocketDisConnected, object: nil, queue: nil, usingBlock: { notification in
++                
++                println("Class: \(NSStringFromClass(self.dynamicType)) recived: \(notification.name)")
++                
++                self.stopLiveTimer()
++            })
++        }
++    }
++    
++    private func deregisterNotification() {
++        
++        if let handerNotificationLoginSuccess = handerNotificationLoginSuccess {
++            NSNotificationCenter.defaultCenter().removeObserver(handerNotificationLoginSuccess)
++        }
++        
++        if let handerNotificationLogoutSuccess = handerNotificationLogoutSuccess {
++            NSNotificationCenter.defaultCenter().removeObserver(handerNotificationLogoutSuccess)
++        }
+     }
+     
+     // MARK: - COMUNICATION API
+@@ -27,14 +68,54 @@ final class CRMCallSocket: BaseSocket {
+         
+         let xmlLogin = XMLRequestBuilder.loginRequest(with: userID, pass: passwold, domain: domain)
+         
+-        configData(withData: xmlLogin)
++        configAndSendData(withData: xmlLogin)
++    }
++    
++    func requestReLogin(withUserID userID: String, passwold: String, domain: String) {
++        
++        let xmlLogin = XMLRequestBuilder.loginRequest(with: userID, pass: passwold, domain: domain)
++        
++        configAndSendData(withData: xmlLogin)
+     }
+     
+     func requestLogout() {
+         
+         let xmlLogOut = XMLRequestBuilder.logOutRequest()
+         
+-        configData(withData: xmlLogOut)
++        configAndSendData(withData: xmlLogOut)
+     }
+     
++    // MARK: LIVE API
++    func startLiveTimer() {
++        
++       // dispatch_async(dispatch_get_main_queue()) {
++            
++            if self.liveTimer == nil {
++                self.liveTimer = NSTimer.scheduledTimerWithTimeInterval(CRMCallConfig.TimerInterval, target: self, selector: #selector(CRMCallSocket.requestLive), userInfo: nil, repeats: true)
++                
++                self.liveTimer?.fire()
++            }
++      //  }
++    }
++    
++    func stopLiveTimer() {
++        
++      //  dispatch_async(dispatch_get_main_queue()) {
++            guard let _liveTimer = self.liveTimer else {
++                println("liveTimer not init")
++                return
++            }
++            
++            _liveTimer.invalidate()
++     //   }
++    }
++    
++    func requestLive() {
++        
++        println("PING TO SERVER WITH SCHEDULE \(CRMCallConfig.TimerInterval)s")
++        
++        let strRequest = XMLRequestBuilder.liveRequest()
++        
++        configAndSendData(withData: strRequest)
++    }
+ }
+\ No newline at end of file
+diff --git a/CRMCall092016/ViewController.swift b/CRMCall092016/ViewController.swift
+index 7872dd3..de769e2 100644
+--- a/CRMCall092016/ViewController.swift
++++ b/CRMCall092016/ViewController.swift
+@@ -11,12 +11,12 @@ import Cocoa
+ class ViewController: NSViewController {
+ 
+     // MARK: - Properties
+-    private var socketManager: BaseSocket!
++    private var crmCallSocket: CRMCallSocket!
+     
+     private var handlerNotificationSocketDidConnected: AnyObject?
+     private var handlerNotificationLoginSuccess: AnyObject?
+     private var handlerNotificationLogoutSuccess: AnyObject?
+-    private var handlerNotificationConnectToHost: AnyObject?
++    private var handlerNotificationRevicedServerInfor: AnyObject?
+     
+     @IBOutlet weak var domanTextField: NSTextField!
+     @IBOutlet weak var userTextField: NSTextField!
+@@ -30,7 +30,7 @@ class ViewController: NSViewController {
+         
+         registerNotification()
+         
+-        socketManager = CRMCallSocket()
++        crmCallSocket = CRMCallSocket()
+     }
+ 
+     deinit {
+@@ -48,19 +48,20 @@ class ViewController: NSViewController {
+     
+     @IBAction func actionLogin(sender: AnyObject) {
+         
+-        if socketManager.isConnectedToHost == true {
++        if crmCallSocket.isConnectedToHost == true {
+             
+-            requestLogin(withUserID: userTextField.stringValue, pass: passTextField.stringValue, domain: domanTextField.stringValue)
++            crmCallSocket.requestLogin(withUserID: userTextField.stringValue, passwold: passTextField.stringValue, domain: domanTextField.stringValue)
++
+         } else {
+-            println("Waiting connect to server .....")
++            println("Please connect to server .....")
+         }
+         
+     }
+     
+     @IBAction func actionLogout(sender: AnyObject) {
+         
+-        if socketManager.isConnectedToHost == true {
+-            requestLogOut()
++        if crmCallSocket.isConnectedToHost == true {
++            crmCallSocket.requestLogout()
+         } else {
+             println("Disconnect to server")
+         }
+@@ -69,36 +70,34 @@ class ViewController: NSViewController {
+     
+     // MARK: - Notification
+     struct Notification {
+-        static let loginSuccess = "LoginSuccessNotification"
+-        static let logoutSuccess = "LogoutSuccessNotification"
+-        static let connectToHost = "ConnectHostNotification"
++        static let LoginSuccess = "LoginSuccessNotification"
++        static let LogoutSuccess = "LogoutSuccessNotification"
+     }
+     
+     private func registerNotification() {
+         
+-        handlerNotificationSocketDidConnected = NSNotificationCenter.defaultCenter().addObserverForName(CRMCallConfig.Notification.SocketDidConnected, object: nil, queue: nil) { notification in
++        handlerNotificationSocketDidConnected = NSNotificationCenter.defaultCenter().addObserverForName(CRMCallConfig.Notification.SocketDidConnected, object: nil, queue: nil, usingBlock: { notification in
+             
+-            println("\(notification)")
+-        }
++            println("Class: \(NSStringFromClass(self.dynamicType)) recived: \(notification.name)")
++        })
+         
+-        handlerNotificationLoginSuccess = NSNotificationCenter.defaultCenter().addObserverForName(ViewController.Notification.loginSuccess, object: nil, queue: nil) { notification in
++        handlerNotificationLoginSuccess = NSNotificationCenter.defaultCenter().addObserverForName(ViewController.Notification.LoginSuccess, object: nil, queue: nil, usingBlock: { notification in
+             
+-            println("\(notification)")
++            println("Class: \(NSStringFromClass(self.dynamicType)) recived: \(notification.name)")
+             self.statusLogin.hidden = false
+-        }
++        })
+         
+-        handlerNotificationLogoutSuccess = NSNotificationCenter.defaultCenter().addObserverForName(ViewController.Notification.logoutSuccess, object: nil, queue: nil) { notification in
++        handlerNotificationLogoutSuccess = NSNotificationCenter.defaultCenter().addObserverForName(ViewController.Notification.LogoutSuccess, object: nil, queue: nil, usingBlock: { notification in
+             
+-            println("\(notification)")
++            println("Class: \(NSStringFromClass(self.dynamicType)) recived: \(notification.name)")
+             self.statusLogin.hidden = true
+-        }
++        })
+         
+-        handlerNotificationConnectToHost = NSNotificationCenter.defaultCenter().addObserverForName(ViewController.Notification.connectToHost, object: nil, queue: nil) { notification in
++        handlerNotificationRevicedServerInfor = NSNotificationCenter.defaultCenter().addObserverForName(CRMCallConfig.Notification.RecivedServerInfor, object: nil, queue: nil, usingBlock: { notification in
+             
+-            println("\(notification)")
+-            
+-            self.socketManager.connect()
+-        }
++            println("Class: \(NSStringFromClass(self.dynamicType)) recived: \(notification.name)")
++            self.crmCallSocket.connect()
++        })
+     }
+     
+     private func deRegisterNotification() {
+@@ -115,21 +114,9 @@ class ViewController: NSViewController {
+             NSNotificationCenter.defaultCenter().removeObserver(notification)
+         }
+         
+-        if let notification = handlerNotificationConnectToHost {
++        if let notification = handlerNotificationRevicedServerInfor {
+             NSNotificationCenter.defaultCenter().removeObserver(notification)
+         }
+     }
+-    
+-    // MARK: - USER LOGIN/OUT
+-    private func requestLogin(withUserID userID: String, pass: String, domain: String) {
+-        
+-        let xmlLogin = XMLRequestBuilder.loginRequest(with: userID, pass: pass, domain: domain)
+-        
+-        socketManager.configData(withData: xmlLogin)
+-    }
+-    
+-    private func requestLogOut() {
+-        
+-    }
+ }
+ 
diff --git a/CRMCall092016.xcworkspace/xcuserdata/hanbiro.xcuserdatad/UserInterfaceState.xcuserstate b/CRMCall092016.xcworkspace/xcuserdata/hanbiro.xcuserdatad/UserInterfaceState.xcuserstate
index 0dd48d4..dcfcef3 100644
Binary files a/CRMCall092016.xcworkspace/xcuserdata/hanbiro.xcuserdatad/UserInterfaceState.xcuserstate and b/CRMCall092016.xcworkspace/xcuserdata/hanbiro.xcuserdatad/UserInterfaceState.xcuserstate differ
diff --git a/CRMCall092016/Helpers/CRMCallHelpers.swift b/CRMCall092016/Helpers/CRMCallHelpers.swift
index a7759ba..6926bfb 100644
--- a/CRMCall092016/Helpers/CRMCallHelpers.swift
+++ b/CRMCall092016/Helpers/CRMCallHelpers.swift
@@ -12,6 +12,7 @@ final class CRMCallHelpers {
     
     enum TypeData {
         case UserLogin
+        case UserLogout
         case ServerInfo
         case UserLive
         case None
diff --git a/CRMCall092016/Helpers/XML/XMLRequestBuilder.swift b/CRMCall092016/Helpers/XML/XMLRequestBuilder.swift
index 00f40ec..5dae250 100644
--- a/CRMCall092016/Helpers/XML/XMLRequestBuilder.swift
+++ b/CRMCall092016/Helpers/XML/XMLRequestBuilder.swift
@@ -13,16 +13,16 @@ final class XMLRequestBuilder {
     // MARK: - LOGIN/LOGOUT
     static func loginRequest(with userID: String, pass: String, domain: String) -> String {
         
-        return  String(format: "<XML> <VER>%@</VER> <USER> <LOGIN ID=\"%@\" PASSWORD=\"%@\" DOMAIN=\"%@\" VER=\"1.0\" ISPTYPE=\"\" PHONE=\"\" DEVICE=\"%@\"></LOGIN> </USER> </XML>", CRMCallConfig.Version, userID, pass, domain, CRMCallConfig.DeviceID)
+        return "<XML> <VER>\(CRMCallConfig.Version)</VER> <USER> <LOGIN ID=\"\(userID)\" PASSWORD=\"\(pass)\" DOMAIN=\"\(domain)\" VER=\"1.0\" ISPTYPE=\"\" PHONE=\"\" DEVICE=\"\(CRMCallConfig.DeviceID)\"></LOGIN> </USER> </XML>"
         
     }
     
     static func logOutRequest() -> String {
         
-        return String(format: "<XML> <VER>%@</VER> <USER> <LOGOUT> </LOGOUT> </USER> </XML>", CRMCallConfig.Version)
+        return "<XML><VER>\(CRMCallConfig.Version)</VER><USER><LOGOUT></LOGOUT></USER></XML>"
     }
     
     static func liveRequest() -> String {
-        return String(format: "<XML> <VER>PROTOCOL_VER</VER> <ALARM> <LIVE/> </ALARM> </XML> ", CRMCallConfig.Version)
+        return "<XML><VER>\(CRMCallConfig.Version)</VER><ALARM><LIVE/></ALARM></XML>"
     }
 }
\ No newline at end of file
diff --git a/CRMCall092016/Library/SWXMLHashManager.swift b/CRMCall092016/Library/SWXMLHashManager.swift
index 4d95cd9..b1bf966 100644
--- a/CRMCall092016/Library/SWXMLHashManager.swift
+++ b/CRMCall092016/Library/SWXMLHashManager.swift
@@ -15,100 +15,84 @@ final class SWXMLHashManager {
     
     // MARK: - XML PARSER
     static func parseXMLToDictionary(withXML xmlData: String, Completion completion: (([String: String], CRMCallHelpers.TypeData) ->Void)?) {
-        
-        var result: [String: String] = [:]
-        
+
         guard let completion = completion else {
             
-            println("Do not found closure COMPLETION")
+            println("Not found closure COMPLETION")
             return
         }
         
         let xmlDocument = SWXMLHash.parse(xmlData)
         
-        if let _ = xmlDocument["XML"]["USER"].element {
+        if let userDic = xmlDocument["XML"]["USER"]["LOGIN"].element {
             
-            result =  userData(withData: xmlDocument)
-            completion(result, CRMCallHelpers.TypeData.UserLogin)
+            completion(userDic.attributes, CRMCallHelpers.TypeData.UserLogin)
             
             return
         }
         
-        if let _ = xmlDocument["XML"]["SERVERINFO"].element {
+        if let userDic = xmlDocument["XML"]["USER"]["LOGOUT"].element {
             
-            result = getHostAndPost(withData: xmlDocument)
-            completion(result, CRMCallHelpers.TypeData.ServerInfo)
+            completion(userDic.attributes, CRMCallHelpers.TypeData.UserLogout)
             
             return
         }
         
-        if let _ = xmlDocument["XML"]["LIVE"].element {
+        if let dataDic = xmlDocument["XML"]["SERVERINFO"].element {
             
-            result = getLiveData(withData: xmlDocument)
-            completion(result, CRMCallHelpers.TypeData.UserLive)
+            completion(dataDic.attributes, CRMCallHelpers.TypeData.ServerInfo)
             
             return
         }
         
-        completion(result, CRMCallHelpers.TypeData.None)
-    }
-    
-    private static func userData(withData data: XMLIndexer) -> [String: String] {
-        
-        if let _ = data["XML"]["USER"]["LOGIN"].element {
-            
-            guard let userDictionnary = data["XML"]["USER"].element else {
-                println("Cannot parse XML: USER LOGIN")
-                return [:]
-            }
-            
-            println("Result parse User: --------XXX------- \n \(userDictionnary)")
+        if let dataDic = xmlDocument["XML"]["ALARM"].element {
             
-            NSNotificationCenter.defaultCenter().postNotificationName(ViewController.Notification.LoginSuccess, object: nil, userInfo: nil)
+            completion(dataDic.attributes, CRMCallHelpers.TypeData.UserLive)
             
-            return userDictionnary.attributes
-        }
-        
-        if let _ = data["XML"]["USER"]["LOGOUT"].element {
-
-            guard let userDictionnary = data["XML"]["USER"].element else {
-                println("Cannot parse XML: USER LOGIN")
-                return [:]
-            }
-
-            println("Result parse Logout user: --------XXX------- \n \(userDictionnary)")
-            
-            NSNotificationCenter.defaultCenter().postNotificationName(ViewController.Notification.LogoutSuccess, object: nil, userInfo: nil)
-            
-            return userDictionnary.attributes
-        }
-        
-        return [:]
-    }
-
-    private static func getHostAndPost(withData data: XMLIndexer) -> [String: String] {
-
-        guard let userDictionnary = data["XML"]["SERVERINFO"].element else {
-            println("Cannot parse XML: SERVERINFO")
-            return [:]
+            return
         }
         
-        println("Result parse SERVERINFO: --------XXX------- \n \(userDictionnary)")
-        
-        return userDictionnary.attributes
+        completion([:], CRMCallHelpers.TypeData.None)
     }
     
-    private static func getLiveData(withData data: XMLIndexer) -> [String: String] {
-        
-        guard let userDictionnary = data["XML"]["ALARM"].element else {
-            println("Cannot parse XML: LIVE")
-            return [:]
-        }
-        
-        println("Result parse Live: --------XXX------- \n \(userDictionnary)")
-        
-        return userDictionnary.attributes
-    }
+//    private static func userData(withData data: XMLIndexer) -> [String: String] {
+//        
+//        if let userDic = data["XML"]["USER"]["LOGIN"].element {
+//            
+//            NSNotificationCenter.defaultCenter().postNotificationName(ViewController.Notification.LoginSuccess, object: nil, userInfo: nil)
+//            
+//            return userDic.attributes
+//        }
+//        
+//        if let userDic = data["XML"]["USER"]["LOGOUT"].element {
+//            
+//            NSNotificationCenter.defaultCenter().postNotificationName(ViewController.Notification.LogoutSuccess, object: nil, userInfo: nil)
+//            
+//            return userDic.attributes
+//        }
+//        
+//        return [:]
+//    }
+
+//    private static func getHostAndPost(withData data: XMLIndexer) -> [String: String] {
+//
+//        guard let userDic = data["XML"]["SERVERINFO"].element else {
+//            println("Cannot parse XML: SERVERINFO")
+//            return [:]
+//        }
+//
+//        return userDic.attributes
+//    }
+//    
+//    private static func getLiveData(withData data: XMLIndexer) -> [String: String] {
+//        
+//        guard let userDic = data["XML"]["ALARM"].element else {
+//            println("Cannot parse XML: LIVE")
+//            return [:]
+//        }
+//                
+//        return userDic.attributes
+//    }
 }
 
 // MARK: USER
diff --git a/CRMCall092016/Server/Socket/BaseSocket.swift b/CRMCall092016/Server/Socket/BaseSocket.swift
index eb23818..3e62807 100644
--- a/CRMCall092016/Server/Socket/BaseSocket.swift
+++ b/CRMCall092016/Server/Socket/BaseSocket.swift
@@ -28,19 +28,6 @@ class BaseSocket: NSObject {
     
     // MARK: - Initialize
     
-    init(withHost host: String, port: UInt16) {
-
-        self.host = host
-        self.port = port
-        self.aesExtension = AESExtension()
-        
-        self.socketQueue = dispatch_queue_create("Socket.queue", DISPATCH_QUEUE_SERIAL)
-        
-        super.init()
-        
-        self.asynSocket = GCDAsyncSocket(delegate: self, delegateQueue: self.socketQueue)
-    }
-    
     override init() {
         
         self.host = ""
@@ -51,16 +38,20 @@ class BaseSocket: NSObject {
         
         super.init()
         
-        self.asynSocket = GCDAsyncSocket(delegate: self, delegateQueue: dispatch_get_main_queue())
+        self.asynSocket = GCDAsyncSocket(delegate: self, delegateQueue: self.socketQueue)
         
         getIdAndHost()
     }
     
+    deinit {
+        self.asynSocket = nil
+    }
+    
     // MARK: - Socket handling
     
     func connect() {
         
-        //dispatch_async(socketQueue) {
+        dispatch_async(socketQueue) {
             do {
                 if self.host != "" && self.port != 0 {
                     try self.asynSocket.connectToHost(self.host, onPort: self.port)
@@ -71,7 +62,7 @@ class BaseSocket: NSObject {
             } catch let err {
                 println("Error connect socket: \(err)")
             }
-       // }
+        }
     }
     
     func disConnect() {
@@ -83,17 +74,16 @@ class BaseSocket: NSObject {
     
     func configAndSendData(withData strData: String) {
         
-       // dispatch_async(socketQueue) {
+        dispatch_async(socketQueue) {
+            println("Data request server: \(strData)")
             let encryptData = self.aesExtension.aesEncryptString(strData)
             
             let headerData = String(format: "%05lu", (encryptData?.characters.count)! + 1)
             
             let requestData = headerData + String(format: "%@%@", self.flagEncrypt, encryptData!)
             
-            println("Data request: \(requestData)")
-            
             self.sendData(requestData.dataUsingEncoding(NSUTF8StringEncoding)!)
-      //  }
+        }
     }
     
    private func sendData(data: NSData) {
@@ -120,6 +110,8 @@ class BaseSocket: NSObject {
                 
                 if typeData == CRMCallHelpers.TypeData.ServerInfo {
                     
+                    println("---------> Data server infor: \n\(result)")
+                    
                     if let port = result["PORT"], host = result["IP"] {
                         self.port = UInt16(port)!
                         self.host = host
@@ -179,15 +171,23 @@ extension BaseSocket: GCDAsyncSocketDelegate {
                 
                 SWXMLHashManager.parseXMLToDictionary(withXML: decryptBodyData, Completion: { result, typeData in
                     
+                    if typeData == CRMCallHelpers.TypeData.UserLogout {
+                        
+                        println("---------> Data logout user : \n\(result)")
+                        
+                        NSNotificationCenter.defaultCenter().postNotificationName(ViewController.Notification.LogoutSuccess, object: nil, userInfo: nil)
+                    }
                     
                     if typeData == CRMCallHelpers.TypeData.UserLogin {
                         
-                        println("Data user : \(result)")
+                        println("---------> Data login user : \n\(result)")
+                        
+                        NSNotificationCenter.defaultCenter().postNotificationName(ViewController.Notification.LoginSuccess, object: nil, userInfo: nil)
                     }
                     
                     if typeData == CRMCallHelpers.TypeData.UserLive {
                         
-                        println("Data live : \(result)")
+                        println("---------> Data live : \n\(result)")
                     }
 
                 })
diff --git a/CRMCall092016/Server/Socket/CRMCallSocket.swift b/CRMCall092016/Server/Socket/CRMCallSocket.swift
index 8540d0d..9e8d822 100644
--- a/CRMCall092016/Server/Socket/CRMCallSocket.swift
+++ b/CRMCall092016/Server/Socket/CRMCallSocket.swift
@@ -14,7 +14,6 @@ final class CRMCallSocket: BaseSocket {
     var liveTimer: NSTimer?
     
     var handerNotificationLoginSuccess: AnyObject?
-    var handerNotificationLogoutSuccess: AnyObject?
     
     // MARK: - Initialzation
     override init() {
@@ -28,6 +27,9 @@ final class CRMCallSocket: BaseSocket {
         deregisterNotification()
     }
     
+    func deInit() {
+        deregisterNotification()
+    }
     // MARK: - NOTIFICATION
     
     private func registerNotification() {
@@ -40,26 +42,13 @@ final class CRMCallSocket: BaseSocket {
                 self.startLiveTimer()
             })
         }
-        
-        if handerNotificationLogoutSuccess == nil {
-            handerNotificationLogoutSuccess = NSNotificationCenter.defaultCenter().addObserverForName(CRMCallConfig.Notification.SocketDisConnected, object: nil, queue: nil, usingBlock: { notification in
-                
-                println("Class: \(NSStringFromClass(self.dynamicType)) recived: \(notification.name)")
-                
-                self.stopLiveTimer()
-            })
-        }
     }
     
-    private func deregisterNotification() {
+    func deregisterNotification() {
         
         if let handerNotificationLoginSuccess = handerNotificationLoginSuccess {
             NSNotificationCenter.defaultCenter().removeObserver(handerNotificationLoginSuccess)
         }
-        
-        if let handerNotificationLogoutSuccess = handerNotificationLogoutSuccess {
-            NSNotificationCenter.defaultCenter().removeObserver(handerNotificationLogoutSuccess)
-        }
     }
     
     // MARK: - COMUNICATION API
@@ -88,26 +77,26 @@ final class CRMCallSocket: BaseSocket {
     // MARK: LIVE API
     func startLiveTimer() {
         
-       // dispatch_async(dispatch_get_main_queue()) {
+        dispatch_async(dispatch_get_main_queue()) {
             
             if self.liveTimer == nil {
                 self.liveTimer = NSTimer.scheduledTimerWithTimeInterval(CRMCallConfig.TimerInterval, target: self, selector: #selector(CRMCallSocket.requestLive), userInfo: nil, repeats: true)
                 
                 self.liveTimer?.fire()
             }
-      //  }
+        }
     }
     
     func stopLiveTimer() {
         
-      //  dispatch_async(dispatch_get_main_queue()) {
+        dispatch_async(dispatch_get_main_queue()) {
             guard let _liveTimer = self.liveTimer else {
                 println("liveTimer not init")
                 return
             }
             
             _liveTimer.invalidate()
-     //   }
+        }
     }
     
     func requestLive() {
diff --git a/CRMCall092016/ViewController.swift b/CRMCall092016/ViewController.swift
index de769e2..e909449 100644
--- a/CRMCall092016/ViewController.swift
+++ b/CRMCall092016/ViewController.swift
@@ -11,8 +11,11 @@ import Cocoa
 class ViewController: NSViewController {
 
     // MARK: - Properties
-    private var crmCallSocket: CRMCallSocket!
+    private var crmCallSocket: CRMCallSocket? = nil
     
+    private var isAutoLogin = false
+    
+    private var handlerNotificationSocketDisConnected: AnyObject?
     private var handlerNotificationSocketDidConnected: AnyObject?
     private var handlerNotificationLoginSuccess: AnyObject?
     private var handlerNotificationLogoutSuccess: AnyObject?
@@ -48,24 +51,35 @@ class ViewController: NSViewController {
     
     @IBAction func actionLogin(sender: AnyObject) {
         
-        if crmCallSocket.isConnectedToHost == true {
+        if let crmCallSocket = crmCallSocket {
             
-            crmCallSocket.requestLogin(withUserID: userTextField.stringValue, passwold: passTextField.stringValue, domain: domanTextField.stringValue)
-
+            if crmCallSocket.isConnectedToHost == true {
+                
+                crmCallSocket.requestLogin(withUserID: userTextField.stringValue, passwold: passTextField.stringValue, domain: domanTextField.stringValue)
+                
+            } else {
+                println("Please connect to server .....")
+            }
         } else {
-            println("Please connect to server .....")
+            self.crmCallSocket = CRMCallSocket()
+            self.isAutoLogin = true
         }
-        
     }
     
     @IBAction func actionLogout(sender: AnyObject) {
         
-        if crmCallSocket.isConnectedToHost == true {
-            crmCallSocket.requestLogout()
+        if let crmCallSocket = self.crmCallSocket {
+            
+            if crmCallSocket.isConnectedToHost == true {
+                crmCallSocket.requestLogout()
+            } else {
+                println("Disconnect to server")
+            }
         } else {
-            println("Disconnect to server")
+            println("CRMCallSocket not init")
         }
-
+        
+        self.isAutoLogin = false
     }
     
     // MARK: - Notification
@@ -76,9 +90,20 @@ class ViewController: NSViewController {
     
     private func registerNotification() {
         
+        handlerNotificationSocketDisConnected = NSNotificationCenter.defaultCenter().addObserverForName(CRMCallConfig.Notification.SocketDisConnected, object: nil, queue: nil, usingBlock: { notification in
+            
+            println("Class: \(NSStringFromClass(self.dynamicType)) recived: \(notification.name)")
+            
+            self.crmCallSocket?.requestLogout()
+        })
+
         handlerNotificationSocketDidConnected = NSNotificationCenter.defaultCenter().addObserverForName(CRMCallConfig.Notification.SocketDidConnected, object: nil, queue: nil, usingBlock: { notification in
             
             println("Class: \(NSStringFromClass(self.dynamicType)) recived: \(notification.name)")
+            
+            if self.isAutoLogin {
+                self.crmCallSocket!.requestLogin(withUserID: self.userTextField.stringValue, passwold: self.passTextField.stringValue, domain: self.domanTextField.stringValue)
+            }
         })
         
         handlerNotificationLoginSuccess = NSNotificationCenter.defaultCenter().addObserverForName(ViewController.Notification.LoginSuccess, object: nil, queue: nil, usingBlock: { notification in
@@ -90,18 +115,34 @@ class ViewController: NSViewController {
         handlerNotificationLogoutSuccess = NSNotificationCenter.defaultCenter().addObserverForName(ViewController.Notification.LogoutSuccess, object: nil, queue: nil, usingBlock: { notification in
             
             println("Class: \(NSStringFromClass(self.dynamicType)) recived: \(notification.name)")
+            
+            self.crmCallSocket?.stopLiveTimer()
+            self.crmCallSocket?.disConnect()
+            self.crmCallSocket?.deInit()
+            self.crmCallSocket = nil
             self.statusLogin.hidden = true
         })
         
         handlerNotificationRevicedServerInfor = NSNotificationCenter.defaultCenter().addObserverForName(CRMCallConfig.Notification.RecivedServerInfor, object: nil, queue: nil, usingBlock: { notification in
             
             println("Class: \(NSStringFromClass(self.dynamicType)) recived: \(notification.name)")
-            self.crmCallSocket.connect()
+            
+            guard let crmCallSocket = self.crmCallSocket else {
+                println("CRMCallSocket not init")
+                return
+            }
+            
+            crmCallSocket.connect()
         })
     }
     
     private func deRegisterNotification() {
         
+        if let notification = handlerNotificationSocketDisConnected {
+            NSNotificationCenter.defaultCenter().removeObserver(notification)
+        }
+
+        
         if let notification = handlerNotificationSocketDidConnected {
             NSNotificationCenter.defaultCenter().removeObserver(notification)
         }
diff --git a/Podfile b/Podfile
index f57e6c5..a0030e0 100644
--- a/Podfile
+++ b/Podfile
@@ -9,5 +9,6 @@ target 'CRMCall092016' do
 pod 'CocoaAsyncSocket'
 pod 'Alamofire'
 pod 'SWXMLHash'
+pod 'RealmSwift'
 
 end
diff --git a/Podfile.lock b/Podfile.lock
index 0ae9987..e43f76a 100644
--- a/Podfile.lock
+++ b/Podfile.lock
@@ -3,18 +3,26 @@ PODS:
   - CocoaAsyncSocket (7.5.0):
     - CocoaAsyncSocket/GCD (= 7.5.0)
   - CocoaAsyncSocket/GCD (7.5.0)
+  - Realm (1.0.2):
+    - Realm/Headers (= 1.0.2)
+  - Realm/Headers (1.0.2)
+  - RealmSwift (1.0.2):
+    - Realm (= 1.0.2)
   - SWXMLHash (2.4.0)
 
 DEPENDENCIES:
   - Alamofire
   - CocoaAsyncSocket
+  - RealmSwift
   - SWXMLHash
 
 SPEC CHECKSUMS:
   Alamofire: 01a82e2f6c0f860ade35534c8dd88be61bdef40c
   CocoaAsyncSocket: 3baeb1ddd969f81cf9fca81053ae49ef2d1cbbfa
+  Realm: 9d5c46a4d7d27958530a8dfc58f63a99e5c2cba3
+  RealmSwift: 82f3ac5e24530143dddfde2033acc0d308f27d96
   SWXMLHash: 507397103325f140863d09040c04ae14a49a16cb
 
-PODFILE CHECKSUM: 3d088204bac8fcec64bd2420b15ef2f3c7764d77
+PODFILE CHECKSUM: 13a99d660f374edeef1138154d6613af9545144b
 
 COCOAPODS: 1.0.0
diff --git a/Pods/Manifest.lock b/Pods/Manifest.lock
index 0ae9987..e43f76a 100644
--- a/Pods/Manifest.lock
+++ b/Pods/Manifest.lock
@@ -3,18 +3,26 @@ PODS:
   - CocoaAsyncSocket (7.5.0):
     - CocoaAsyncSocket/GCD (= 7.5.0)
   - CocoaAsyncSocket/GCD (7.5.0)
+  - Realm (1.0.2):
+    - Realm/Headers (= 1.0.2)
+  - Realm/Headers (1.0.2)
+  - RealmSwift (1.0.2):
+    - Realm (= 1.0.2)
   - SWXMLHash (2.4.0)
 
 DEPENDENCIES:
   - Alamofire
   - CocoaAsyncSocket
+  - RealmSwift
   - SWXMLHash
 
 SPEC CHECKSUMS:
   Alamofire: 01a82e2f6c0f860ade35534c8dd88be61bdef40c
   CocoaAsyncSocket: 3baeb1ddd969f81cf9fca81053ae49ef2d1cbbfa
+  Realm: 9d5c46a4d7d27958530a8dfc58f63a99e5c2cba3
+  RealmSwift: 82f3ac5e24530143dddfde2033acc0d308f27d96
   SWXMLHash: 507397103325f140863d09040c04ae14a49a16cb
 
-PODFILE CHECKSUM: 3d088204bac8fcec64bd2420b15ef2f3c7764d77
+PODFILE CHECKSUM: 13a99d660f374edeef1138154d6613af9545144b
 
 COCOAPODS: 1.0.0
diff --git a/Pods/Pods.xcodeproj/project.pbxproj b/Pods/Pods.xcodeproj/project.pbxproj
index a791ba2..84be246 100644
--- a/Pods/Pods.xcodeproj/project.pbxproj
+++ b/Pods/Pods.xcodeproj/project.pbxproj
@@ -7,153 +7,465 @@
 	objects = {
 
 /* Begin PBXBuildFile section */
-		095406039B4D371E48D08B38A2975AC8 /* Error.swift in Sources */ = {isa = PBXBuildFile; fileRef = EF9B2AFCE03477C50F07C48E33A463FF /* Error.swift */; };
-		16102E4E35FAA0FC4161282FECE56469 /* Timeline.swift in Sources */ = {isa = PBXBuildFile; fileRef = D77E19C3839748928122D0DEAC1BA1F4 /* Timeline.swift */; };
-		1E5602BF3A87A7353DA77A2EE51EED93 /* SWXMLHash-umbrella.h in Headers */ = {isa = PBXBuildFile; fileRef = 5F0B453266F2DE0B098E2B994FE716CD /* SWXMLHash-umbrella.h */; settings = {ATTRIBUTES = (Public, ); }; };
-		2D3405986FC586FA6C0A5E0B6BA7E64E /* Validation.swift in Sources */ = {isa = PBXBuildFile; fileRef = 84395B1E623BD8F9DE2F7E16CA43251F /* Validation.swift */; };
-		34CCDCA848A701466256BC2927DA8856 /* NetworkReachabilityManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 64E8485F5FCFC4FDB8D6CE0BFC980C58 /* NetworkReachabilityManager.swift */; };
-		3EA8F215C9C1432D74E5CCA4834AA8C0 /* ResponseSerialization.swift in Sources */ = {isa = PBXBuildFile; fileRef = B7C925E8849659F01450961BB1FFA23D /* ResponseSerialization.swift */; };
-		4081EA628AF0B73AC51FFB9D7AB3B89E /* Manager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 7031D4000017108DC80504B065340368 /* Manager.swift */; };
-		515FD66E0570F0E6B6D6F6B4AE427CC2 /* Pods-CRMCall092016-dummy.m in Sources */ = {isa = PBXBuildFile; fileRef = 2AE57F75653AE6E263CFF4332F052094 /* Pods-CRMCall092016-dummy.m */; };
-		551864BF98FF39945A2F33B4C0B97A06 /* Cocoa.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 7C56649C408E00F4469558EBC9AF1BA3 /* Cocoa.framework */; };
-		58CE33E7875BEC7B12D551A398FB9A97 /* Security.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = E35F27DD11D07BB27A6C8CE52CD34061 /* Security.framework */; };
-		5BC19E6E0F199276003F0AF96838BCE5 /* Upload.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8991BF3DBE2A9AD6CB35BF27297CC8FD /* Upload.swift */; };
-		5CB05FBCB32D21E194B5ECF680CB6AE0 /* Download.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2AA16A476F2771B1B74FB14947F24E02 /* Download.swift */; };
-		5CEBE5DA1F9A37F09EE1389B645FD1B4 /* Cocoa.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 7C56649C408E00F4469558EBC9AF1BA3 /* Cocoa.framework */; };
-		62E8346F03C03E7F4D631361F325689E /* Response.swift in Sources */ = {isa = PBXBuildFile; fileRef = DDE49D9DCF93A390B23188C67221ECA8 /* Response.swift */; };
-		6AAFA2F344A6B58F728AF958F3FE6D89 /* GCDAsyncSocket.h in Headers */ = {isa = PBXBuildFile; fileRef = D1519185135D5351111F109E89AF0F64 /* GCDAsyncSocket.h */; settings = {ATTRIBUTES = (Public, ); }; };
-		723E6C875E842A6DA996001BDFAF520E /* SWXMLHash+TypeConversion.swift in Sources */ = {isa = PBXBuildFile; fileRef = CE89954F8A8211757E95D5E68308F52F /* SWXMLHash+TypeConversion.swift */; };
-		72504A8A3AD0249F8A37515A72C2DF98 /* SWXMLHash.swift in Sources */ = {isa = PBXBuildFile; fileRef = 7201E46C9812098E184043C076154118 /* SWXMLHash.swift */; };
-		7560CA92AA1E62C1C39BBA309960C36A /* SWXMLHash-dummy.m in Sources */ = {isa = PBXBuildFile; fileRef = 2BDE952759498BFF23C89A0302BD584C /* SWXMLHash-dummy.m */; };
-		7B48852C4D848FA2DA416A98F6425869 /* ServerTrustPolicy.swift in Sources */ = {isa = PBXBuildFile; fileRef = 62073F3761055A46F154B11F061A08AF /* ServerTrustPolicy.swift */; };
-		8EB11202167FCDDF1257AAAB1D1FB244 /* Alamofire.swift in Sources */ = {isa = PBXBuildFile; fileRef = E01E26D8749A98484E8DD7726148EC20 /* Alamofire.swift */; };
-		92AED971B91C640191A5ABA1567FE358 /* GCDAsyncUdpSocket.h in Headers */ = {isa = PBXBuildFile; fileRef = 540A59953BD2C3205CF5F2CE7B7BFC1F /* GCDAsyncUdpSocket.h */; settings = {ATTRIBUTES = (Public, ); }; };
-		9469DF81ECB494E84675969B5E13374C /* Alamofire-umbrella.h in Headers */ = {isa = PBXBuildFile; fileRef = 588A6F6AFA80EA93ECB5E93B156711EC /* Alamofire-umbrella.h */; settings = {ATTRIBUTES = (Public, ); }; };
-		991BFD139F6A45C9B654960C2F6A7F09 /* GCDAsyncSocket.m in Sources */ = {isa = PBXBuildFile; fileRef = FB4019B4F3DF5D7B015227F280ABBE9C /* GCDAsyncSocket.m */; settings = {COMPILER_FLAGS = "-DOS_OBJECT_USE_OBJC=0"; }; };
-		A2BFC3BB72F0CAF82F3CEF224DE6752D /* Pods-CRMCall092016-umbrella.h in Headers */ = {isa = PBXBuildFile; fileRef = 8204EF2923FBB8554D93693870D0BBBC /* Pods-CRMCall092016-umbrella.h */; settings = {ATTRIBUTES = (Public, ); }; };
-		AA314156AC500125F4078EE968DB14C6 /* Result.swift in Sources */ = {isa = PBXBuildFile; fileRef = E2A2BD6EE0720A5171EF80B09CFD4224 /* Result.swift */; };
-		ACFE60AB34A7FEF697E6EEFB62436A8D /* CocoaAsyncSocket-umbrella.h in Headers */ = {isa = PBXBuildFile; fileRef = 5F955B5F2D78E83D6BA538909B360F55 /* CocoaAsyncSocket-umbrella.h */; settings = {ATTRIBUTES = (Public, ); }; };
-		ADF19C953CE2A7D0B72EC93A81FCCC26 /* Alamofire-dummy.m in Sources */ = {isa = PBXBuildFile; fileRef = 5399F7CAF2240783134915CC1CBEF3E5 /* Alamofire-dummy.m */; };
-		AE4CF87C02C042DF13ED5B21C4FDC1E0 /* Stream.swift in Sources */ = {isa = PBXBuildFile; fileRef = 5B2BB4979BAD0CF7156F74E71CAD3041 /* Stream.swift */; };
-		B93BDD4D746BA45D62DC63CA9E5BF338 /* Cocoa.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 7C56649C408E00F4469558EBC9AF1BA3 /* Cocoa.framework */; };
-		BE41196F6A3903E59C3306FE3F8B43FE /* Notifications.swift in Sources */ = {isa = PBXBuildFile; fileRef = ECD84F348832D77D5059D066749346A4 /* Notifications.swift */; };
-		C0DB70AB368765DC64BFB5FEA75E0696 /* ParameterEncoding.swift in Sources */ = {isa = PBXBuildFile; fileRef = 125D17DF5E6A1A7420D1F1A975DD7EB9 /* ParameterEncoding.swift */; };
-		C5C58FEE0A35A9EF7DA80B26B6DF2089 /* CoreServices.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 8028EBFA77CCF460ADEBC79B87525C3D /* CoreServices.framework */; };
-		C7B6DD7C0456C50289A2C381DFE9FA3F /* MultipartFormData.swift in Sources */ = {isa = PBXBuildFile; fileRef = AF650B57C6596DA153F5900EA61CC5A7 /* MultipartFormData.swift */; };
-		D9A44696356E299F3C9A4BFF9E57343F /* GCDAsyncUdpSocket.m in Sources */ = {isa = PBXBuildFile; fileRef = ED466E93414A976222AFAF321E9AF11C /* GCDAsyncUdpSocket.m */; settings = {COMPILER_FLAGS = "-DOS_OBJECT_USE_OBJC=0"; }; };
-		EFE92E8D3813DD26E78E93EEAF6D7E7E /* Request.swift in Sources */ = {isa = PBXBuildFile; fileRef = F14E627DC549703B46315BBCCDD362AE /* Request.swift */; };
-		F3F3FD9096F43B73CBB52EF0E1CCF73E /* Cocoa.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 7C56649C408E00F4469558EBC9AF1BA3 /* Cocoa.framework */; };
-		F45B40DF0BF596BDCD96B2D85EF848FA /* CocoaAsyncSocket-dummy.m in Sources */ = {isa = PBXBuildFile; fileRef = ABC09E1DCC49261B7629CD82626C21FA /* CocoaAsyncSocket-dummy.m */; };
+		01C9290916D2BF94E65D61E762062511 /* RealmSwift-umbrella.h in Headers */ = {isa = PBXBuildFile; fileRef = 9F42B3D2E5CBDF7867A8A2DB4F9E99BD /* RealmSwift-umbrella.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		0388B2389A6E19ABB505118BF5000B88 /* format.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 6FD434DFF34C1B81255CAB7549272388 /* format.cpp */; settings = {COMPILER_FLAGS = "-DREALM_HAVE_CONFIG -DREALM_COCOA_VERSION='@\"1.0.2\"' -D__ASSERTMACROS__"; }; };
+		053931D45EC4C80CA9DCF5F919120019 /* RLMCollection.mm in Sources */ = {isa = PBXBuildFile; fileRef = 097CF3C9C7046A002A271EAC0EE74AFF /* RLMCollection.mm */; settings = {COMPILER_FLAGS = "-DREALM_HAVE_CONFIG -DREALM_COCOA_VERSION='@\"1.0.2\"' -D__ASSERTMACROS__"; }; };
+		095406039B4D371E48D08B38A2975AC8 /* Error.swift in Sources */ = {isa = PBXBuildFile; fileRef = DD11F05494F36665158CAA5C69C4CCDC /* Error.swift */; };
+		0A93F730B8DF64DB8BBA36ED0DC711F3 /* RLMObjectSchema.h in Copy . Public Headers */ = {isa = PBXBuildFile; fileRef = 0FBA0BF8AE6FB43DD83D8701888C4B27 /* RLMObjectSchema.h */; };
+		0B7E94EC25F925306BBCB3586134367E /* RLMObject.h in Headers */ = {isa = PBXBuildFile; fileRef = 13C423859E6ECC22EF81163F7C76147B /* RLMObject.h */; };
+		10FF6E7C34C062AE6FE7E0845560CE5C /* RLMUtil.mm in Sources */ = {isa = PBXBuildFile; fileRef = FCFF3DCB53CDB598EAC5ABE9AF1F2393 /* RLMUtil.mm */; settings = {COMPILER_FLAGS = "-DREALM_HAVE_CONFIG -DREALM_COCOA_VERSION='@\"1.0.2\"' -D__ASSERTMACROS__"; }; };
+		118DC01176373579D7511ECDC4956060 /* RLMResults.mm in Sources */ = {isa = PBXBuildFile; fileRef = E20874320351EC32784CC1743B614A6B /* RLMResults.mm */; settings = {COMPILER_FLAGS = "-DREALM_HAVE_CONFIG -DREALM_COCOA_VERSION='@\"1.0.2\"' -D__ASSERTMACROS__"; }; };
+		12F531E295FCC0CEB2BFB467774737E0 /* list.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 2A480B78E743AB3E12252457C8FC4737 /* list.cpp */; settings = {COMPILER_FLAGS = "-DREALM_HAVE_CONFIG -DREALM_COCOA_VERSION='@\"1.0.2\"' -D__ASSERTMACROS__"; }; };
+		134290289BEE62256C3E6CEEB2ED72BF /* Realm.h in Headers */ = {isa = PBXBuildFile; fileRef = B1049E8532A11B579AFE58F91D5DDF4A /* Realm.h */; };
+		14C7DFDD75F71FF6E49CC04730292D2F /* realm_coordinator.cpp in Sources */ = {isa = PBXBuildFile; fileRef = E7CAF6E8B1C938AF00BC311BB3EF2BF2 /* realm_coordinator.cpp */; settings = {COMPILER_FLAGS = "-DREALM_HAVE_CONFIG -DREALM_COCOA_VERSION='@\"1.0.2\"' -D__ASSERTMACROS__"; }; };
+		16102E4E35FAA0FC4161282FECE56469 /* Timeline.swift in Sources */ = {isa = PBXBuildFile; fileRef = 10B67EDC27ECC211EF700D8B9B864881 /* Timeline.swift */; };
+		17E53ACC2AFFA773DEBA79D04AC24F58 /* collection_change_builder.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 654F9073F4DB3BDB257921EE989FAA72 /* collection_change_builder.cpp */; settings = {COMPILER_FLAGS = "-DREALM_HAVE_CONFIG -DREALM_COCOA_VERSION='@\"1.0.2\"' -D__ASSERTMACROS__"; }; };
+		18718707EFB4C8F78980EC2DC2A67CBB /* RLMMigration.h in Headers */ = {isa = PBXBuildFile; fileRef = 9E18D43D3F5726FA53402C61C9042E7F /* RLMMigration.h */; };
+		189AA94B049D92CA32C03B25DAF61BBD /* RLMResults_Private.h in Copy . Private Headers */ = {isa = PBXBuildFile; fileRef = A27E57EF66172A47F951A951279641EB /* RLMResults_Private.h */; };
+		194052101382F3A145C81DA3E2D0D29F /* RealmSwift-dummy.m in Sources */ = {isa = PBXBuildFile; fileRef = C231809D6172C447734FABEDB09AD9FE /* RealmSwift-dummy.m */; };
+		1E0D0285F2684B3B8570735C107EADF0 /* shared_realm.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4031E673462ED1173C604881D275DD67 /* shared_realm.cpp */; settings = {COMPILER_FLAGS = "-DREALM_HAVE_CONFIG -DREALM_COCOA_VERSION='@\"1.0.2\"' -D__ASSERTMACROS__"; }; };
+		1FC39133E8B68A14A0F2F2C2AA315136 /* Cocoa.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = EF2CEACC97C084704B8C47B4AEF30B95 /* Cocoa.framework */; };
+		217B27984D97349329F798EF6956E722 /* RLMRealmConfiguration.mm in Sources */ = {isa = PBXBuildFile; fileRef = 83D17D99218E43E698EFBBEA8F1E16C1 /* RLMRealmConfiguration.mm */; settings = {COMPILER_FLAGS = "-DREALM_HAVE_CONFIG -DREALM_COCOA_VERSION='@\"1.0.2\"' -D__ASSERTMACROS__"; }; };
+		23200FC18EFD73BE2BE05D99847DE59A /* RLMObjectSchema.h in Headers */ = {isa = PBXBuildFile; fileRef = 0FBA0BF8AE6FB43DD83D8701888C4B27 /* RLMObjectSchema.h */; };
+		2359969B6D3A4D02AE072B56329D5619 /* RLMPlatform.h in Copy . Public Headers */ = {isa = PBXBuildFile; fileRef = A6A11EDB1E620C3C59416592096A83F4 /* RLMPlatform.h */; };
+		23EEA68F3EBF83EFA81EEDFB04249FCD /* SwiftVersion.swift in Sources */ = {isa = PBXBuildFile; fileRef = 710E8D676393E8E638B681FFE1148A77 /* SwiftVersion.swift */; };
+		250F3A5B3B905BC7586DFC4D46D47649 /* RLMRealmConfiguration.h in Copy . Public Headers */ = {isa = PBXBuildFile; fileRef = 2C921E459B087BFEF2796F7087F78F9C /* RLMRealmConfiguration.h */; };
+		25C84942AA159EFB1292D34782A8F355 /* results_notifier.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 3A6C08B4B95C6657BEA86714D5D87BF0 /* results_notifier.cpp */; settings = {COMPILER_FLAGS = "-DREALM_HAVE_CONFIG -DREALM_COCOA_VERSION='@\"1.0.2\"' -D__ASSERTMACROS__"; }; };
+		287433D3503B6F50768F3F01289DEAA8 /* List.swift in Sources */ = {isa = PBXBuildFile; fileRef = 13BC77519ED297D8940D08A13E00DD95 /* List.swift */; };
+		2B3992908CEEE412C9273EE8C7B6D8EE /* Cocoa.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = EF2CEACC97C084704B8C47B4AEF30B95 /* Cocoa.framework */; };
+		2D3405986FC586FA6C0A5E0B6BA7E64E /* Validation.swift in Sources */ = {isa = PBXBuildFile; fileRef = 1889046CFA08897333E9DC1E4311B3C8 /* Validation.swift */; };
+		2E6C91DE00AD3F2D62C42008533197D4 /* RLMSchema.mm in Sources */ = {isa = PBXBuildFile; fileRef = DE4DAE53005DB209CAC0601F2A3872FE /* RLMSchema.mm */; settings = {COMPILER_FLAGS = "-DREALM_HAVE_CONFIG -DREALM_COCOA_VERSION='@\"1.0.2\"' -D__ASSERTMACROS__"; }; };
+		305701DF6434F6D155D0ED68F70DA4FD /* collection_notifications.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 1AF6E060C7054FE55A838D6B0E0E4BD4 /* collection_notifications.cpp */; settings = {COMPILER_FLAGS = "-DREALM_HAVE_CONFIG -DREALM_COCOA_VERSION='@\"1.0.2\"' -D__ASSERTMACROS__"; }; };
+		31BC73C4AE794BE4D97A2B46F8728F02 /* Migration.swift in Sources */ = {isa = PBXBuildFile; fileRef = 7C7C032A575AE7ECF05272A7332C6DFB /* Migration.swift */; };
+		34CCDCA848A701466256BC2927DA8856 /* NetworkReachabilityManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 670515BB35AFEF410C80DC0D58E5DFD8 /* NetworkReachabilityManager.swift */; };
+		36AB6C9E06467598CC30D6EA37241D52 /* RLMObjectSchema.mm in Sources */ = {isa = PBXBuildFile; fileRef = 3D0184AC2929C1EA7FF747E2E43349EE /* RLMObjectSchema.mm */; settings = {COMPILER_FLAGS = "-DREALM_HAVE_CONFIG -DREALM_COCOA_VERSION='@\"1.0.2\"' -D__ASSERTMACROS__"; }; };
+		37A32603349C7A575815A76C9387D758 /* transact_log_handler.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 548C4A5E8A66BE8922AEFC3C49C1834B /* transact_log_handler.cpp */; settings = {COMPILER_FLAGS = "-DREALM_HAVE_CONFIG -DREALM_COCOA_VERSION='@\"1.0.2\"' -D__ASSERTMACROS__"; }; };
+		382A6FC3FD572FF3CED84F4171EC2FA8 /* RLMRealmConfiguration.h in Headers */ = {isa = PBXBuildFile; fileRef = 2C921E459B087BFEF2796F7087F78F9C /* RLMRealmConfiguration.h */; };
+		38B0B068A2F027A036046A5A469ACCF4 /* RLMPredicateUtil.mm in Sources */ = {isa = PBXBuildFile; fileRef = 721951E8312A8726BE2F5FF553509299 /* RLMPredicateUtil.mm */; settings = {COMPILER_FLAGS = "-DREALM_HAVE_CONFIG -DREALM_COCOA_VERSION='@\"1.0.2\"' -D__ASSERTMACROS__"; }; };
+		3A932F700B91F43CAE1F531EA7B7EB17 /* schema.cpp in Sources */ = {isa = PBXBuildFile; fileRef = EB1192D650447A0ED6CF4A8DB8C5C9FB /* schema.cpp */; settings = {COMPILER_FLAGS = "-DREALM_HAVE_CONFIG -DREALM_COCOA_VERSION='@\"1.0.2\"' -D__ASSERTMACROS__"; }; };
+		3B076C87960E8A67433E76C0CA2273B7 /* Cocoa.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = EF2CEACC97C084704B8C47B4AEF30B95 /* Cocoa.framework */; };
+		3EA8F215C9C1432D74E5CCA4834AA8C0 /* ResponseSerialization.swift in Sources */ = {isa = PBXBuildFile; fileRef = BA702A928A3EDB738041CEE543786650 /* ResponseSerialization.swift */; };
+		3F7E80E44B8AB2AC9BC0B7B8AB451E62 /* RLMUpdateChecker.mm in Sources */ = {isa = PBXBuildFile; fileRef = 2BCEF6A165FEA12AA3EA4EABBA761CF9 /* RLMUpdateChecker.mm */; settings = {COMPILER_FLAGS = "-DREALM_HAVE_CONFIG -DREALM_COCOA_VERSION='@\"1.0.2\"' -D__ASSERTMACROS__"; }; };
+		4081EA628AF0B73AC51FFB9D7AB3B89E /* Manager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 4B1A2836B3567ABD34B44D494734C530 /* Manager.swift */; };
+		408F2A71695E49C72B6E69F72F6CCE36 /* Pods-CRMCall092016-dummy.m in Sources */ = {isa = PBXBuildFile; fileRef = 2AE57F75653AE6E263CFF4332F052094 /* Pods-CRMCall092016-dummy.m */; };
+		411EDA9EFC8CCBEEC90F153061D3EDCE /* RLMArray.h in Copy . Public Headers */ = {isa = PBXBuildFile; fileRef = 08F91D1BF9071E5ADD08774AE07E8753 /* RLMArray.h */; };
+		4391880309D66B4EFE6A78B48B1C4727 /* RLMArray.mm in Sources */ = {isa = PBXBuildFile; fileRef = 86C1D7A6A276CDE0E92E766763E7CC2A /* RLMArray.mm */; settings = {COMPILER_FLAGS = "-DREALM_HAVE_CONFIG -DREALM_COCOA_VERSION='@\"1.0.2\"' -D__ASSERTMACROS__"; }; };
+		4837DA62EE2625AC429759B824184629 /* RLMObjectBase.h in Copy . Public Headers */ = {isa = PBXBuildFile; fileRef = 70D1FEC58F5689359AEBD4A4A39ABD0B /* RLMObjectBase.h */; };
+		48EAC52A897DAB77931ED70C0B75B4C3 /* RLMObjectBase_Dynamic.h in Copy . Public Headers */ = {isa = PBXBuildFile; fileRef = 993917E3199A0385691960033C7BEE0F /* RLMObjectBase_Dynamic.h */; };
+		4A78382491949627B30DD86C9E520AD9 /* RLMProperty.h in Headers */ = {isa = PBXBuildFile; fileRef = C385F154EFA2280EE2B25A9C8927532E /* RLMProperty.h */; };
+		4B6745C20956AC18A47CEAAF92C08E57 /* SWXMLHash+TypeConversion.swift in Sources */ = {isa = PBXBuildFile; fileRef = 4FCD5E9B89170963F9CB31AE398392B4 /* SWXMLHash+TypeConversion.swift */; };
+		4C0637B12574F5D1EB1F68E2F061E161 /* RLMArray.h in Headers */ = {isa = PBXBuildFile; fileRef = 08F91D1BF9071E5ADD08774AE07E8753 /* RLMArray.h */; };
+		4CD8A056B105609D0DA1C3DBFD17487E /* RLMObjectSchema_Private.h in Copy . Private Headers */ = {isa = PBXBuildFile; fileRef = 39EC2928C1CCBC39A921620DDFD96D82 /* RLMObjectSchema_Private.h */; };
+		51EAF68089AED4910CA5BCD81E9F94F4 /* RLMMigration.h in Copy . Public Headers */ = {isa = PBXBuildFile; fileRef = 9E18D43D3F5726FA53402C61C9042E7F /* RLMMigration.h */; };
+		5265ADE0A6269A478DEEA37FBC4B80E0 /* RLMProperty_Private.h in Headers */ = {isa = PBXBuildFile; fileRef = DCEFB5DFE4D76193F6FD235B405F46FA /* RLMProperty_Private.h */; };
+		534A9A7E425A0B4F41A0269093685234 /* RLMSchema_Private.h in Headers */ = {isa = PBXBuildFile; fileRef = F657C7C18C4DAAE7E00CD69442E14D56 /* RLMSchema_Private.h */; };
+		546EF4BD6447190C973348CE5851C952 /* RLMRealm.h in Headers */ = {isa = PBXBuildFile; fileRef = 72911E861245A78B7F5F53946D9CFD39 /* RLMRealm.h */; };
+		54F747D247AA9B7ED59308AFCE991970 /* RLMArray_Private.h in Copy . Private Headers */ = {isa = PBXBuildFile; fileRef = 603EE85140A9845165857F384CD8FDBE /* RLMArray_Private.h */; };
+		551864BF98FF39945A2F33B4C0B97A06 /* Cocoa.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = EF2CEACC97C084704B8C47B4AEF30B95 /* Cocoa.framework */; };
+		5864975709B7FE2025D430DBE809B29F /* Error.swift in Sources */ = {isa = PBXBuildFile; fileRef = ACFB0B2BC281EBF4FB0F22B8EDE34F3F /* Error.swift */; };
+		58CE33E7875BEC7B12D551A398FB9A97 /* Security.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 379FAEE80725487D7F3C6891939A7D54 /* Security.framework */; };
+		5A6C5E9420C798FDA1764A183A04EF48 /* RLMQueryUtil.mm in Sources */ = {isa = PBXBuildFile; fileRef = 38738ED527609FB98672FBC7A6CA4F90 /* RLMQueryUtil.mm */; settings = {COMPILER_FLAGS = "-DREALM_HAVE_CONFIG -DREALM_COCOA_VERSION='@\"1.0.2\"' -D__ASSERTMACROS__"; }; };
+		5AF429552999C3D472618BA0AB15932A /* RLMListBase.h in Copy . Private Headers */ = {isa = PBXBuildFile; fileRef = 8AB91E74D4B7B8C9746AC13E026868E5 /* RLMListBase.h */; };
+		5B4F95459073D3BC9AB05C31D06F56A9 /* Schema.swift in Sources */ = {isa = PBXBuildFile; fileRef = 43BBB01E7B94E0969186C664FC16998C /* Schema.swift */; };
+		5B9064296FBD8EA3F90B6AB2E1B5F580 /* SortDescriptor.swift in Sources */ = {isa = PBXBuildFile; fileRef = 4153ADCADFA2E29B38AAF7DA58B24B9C /* SortDescriptor.swift */; };
+		5BC19E6E0F199276003F0AF96838BCE5 /* Upload.swift in Sources */ = {isa = PBXBuildFile; fileRef = 53A5F544C86A60EE30CE30D71CF04329 /* Upload.swift */; };
+		5CB05FBCB32D21E194B5ECF680CB6AE0 /* Download.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2CC788BB98D1C340FD628F61B02A6A0B /* Download.swift */; };
+		5FEC38C12278DD40237061B2540CD07B /* weak_realm_notifier.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 2AC63EBBC84F7B64AF720C29432FAD33 /* weak_realm_notifier.cpp */; settings = {COMPILER_FLAGS = "-DREALM_HAVE_CONFIG -DREALM_COCOA_VERSION='@\"1.0.2\"' -D__ASSERTMACROS__"; }; };
+		5FF99131C449A8D9562842C352631433 /* RLMRealm.h in Copy . Public Headers */ = {isa = PBXBuildFile; fileRef = 72911E861245A78B7F5F53946D9CFD39 /* RLMRealm.h */; };
+		62E8346F03C03E7F4D631361F325689E /* Response.swift in Sources */ = {isa = PBXBuildFile; fileRef = 6C114501AD56C8B1F8B2932028D038BE /* Response.swift */; };
+		64AF480BC9EE1907089B3B38C95E63CC /* RLMListBase.mm in Sources */ = {isa = PBXBuildFile; fileRef = 3DCB0C38EB20D53EA34F4E4A62FBE439 /* RLMListBase.mm */; settings = {COMPILER_FLAGS = "-DREALM_HAVE_CONFIG -DREALM_COCOA_VERSION='@\"1.0.2\"' -D__ASSERTMACROS__"; }; };
+		65675FB7D0A68A7894FFCF81BD83A08E /* RLMObjectStore.h in Copy . Private Headers */ = {isa = PBXBuildFile; fileRef = A1DA88D1D060CF47706351C7EA1F1AAA /* RLMObjectStore.h */; };
+		657E5700E7FD31482F35761CA328D886 /* RLMOptionalBase.mm in Sources */ = {isa = PBXBuildFile; fileRef = 092AFAD3D3E246E82EABB3AEE25F0185 /* RLMOptionalBase.mm */; settings = {COMPILER_FLAGS = "-DREALM_HAVE_CONFIG -DREALM_COCOA_VERSION='@\"1.0.2\"' -D__ASSERTMACROS__"; }; };
+		66F5250FFDFF3477A6E6F9058826D67B /* RLMAccessor.mm in Sources */ = {isa = PBXBuildFile; fileRef = BABC0F59B38A48FA1B1487176D304E57 /* RLMAccessor.mm */; settings = {COMPILER_FLAGS = "-DREALM_HAVE_CONFIG -DREALM_COCOA_VERSION='@\"1.0.2\"' -D__ASSERTMACROS__"; }; };
+		68510367955CA4AD73A6AF6E230779DE /* RLMMigration.mm in Sources */ = {isa = PBXBuildFile; fileRef = 0EDB157896F85AE259E754C00D3636F7 /* RLMMigration.mm */; settings = {COMPILER_FLAGS = "-DREALM_HAVE_CONFIG -DREALM_COCOA_VERSION='@\"1.0.2\"' -D__ASSERTMACROS__"; }; };
+		6AAFA2F344A6B58F728AF958F3FE6D89 /* GCDAsyncSocket.h in Headers */ = {isa = PBXBuildFile; fileRef = 6DD9AC2FAD4B64F2D7CC258B71DF2BE1 /* GCDAsyncSocket.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		6B867F5EE4FD3E4A50A0C37316B51F0D /* RLMSchema.h in Headers */ = {isa = PBXBuildFile; fileRef = 759A40E09C374D9FAC2A32B6E6B51BEE /* RLMSchema.h */; };
+		6C0D034D17C2AA00E5268EFA425D2B0A /* RLMAccessor.h in Copy . Private Headers */ = {isa = PBXBuildFile; fileRef = A3920BF9AAF7A76983FA8FEBE4DD34A9 /* RLMAccessor.h */; };
+		6E5F9CE6D9BAFA6183B3D3A9AB698BB0 /* RLMConstants.m in Sources */ = {isa = PBXBuildFile; fileRef = F3B62BC2FEA22E8FB707DF6086ECBC5C /* RLMConstants.m */; settings = {COMPILER_FLAGS = "-DREALM_HAVE_CONFIG -DREALM_COCOA_VERSION='@\"1.0.2\"' -D__ASSERTMACROS__"; }; };
+		6E8D7745A9285374922AE1FBFC46B063 /* index_set.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 2BF418666618F7F4C8707584A96D3E15 /* index_set.cpp */; settings = {COMPILER_FLAGS = "-DREALM_HAVE_CONFIG -DREALM_COCOA_VERSION='@\"1.0.2\"' -D__ASSERTMACROS__"; }; };
+		73F64F78AE5F4B9EE6137FA0BA7583CC /* ObjectSchema.swift in Sources */ = {isa = PBXBuildFile; fileRef = C63CABFAC66CBD384E95B91088CD77AE /* ObjectSchema.swift */; };
+		769DD013CC1B7E48E851EE36FA99F14B /* Realm.h in Copy . Public Headers */ = {isa = PBXBuildFile; fileRef = B1049E8532A11B579AFE58F91D5DDF4A /* Realm.h */; };
+		76A088C8DC1E6B9ECFDEF27BFBE0BE01 /* RLMOptionalBase.h in Headers */ = {isa = PBXBuildFile; fileRef = 91B7D6B5E8A8B097A92B157F9338B850 /* RLMOptionalBase.h */; };
+		784AF43FC80EDF14A9086A58F9297BB9 /* RLMRealm_Dynamic.h in Copy . Public Headers */ = {isa = PBXBuildFile; fileRef = B50B323F3ACD65ABC1846D0E12764768 /* RLMRealm_Dynamic.h */; };
+		7B48852C4D848FA2DA416A98F6425869 /* ServerTrustPolicy.swift in Sources */ = {isa = PBXBuildFile; fileRef = A2A54645E8AA3FA9CBEA2A759DF82F29 /* ServerTrustPolicy.swift */; };
+		7F55BED9532AD711C390EDE26E347138 /* RLMAnalytics.mm in Sources */ = {isa = PBXBuildFile; fileRef = 6EAF315EE8B882259BBB61D457ECDE6B /* RLMAnalytics.mm */; settings = {COMPILER_FLAGS = "-DREALM_HAVE_CONFIG -DREALM_COCOA_VERSION='@\"1.0.2\"' -D__ASSERTMACROS__"; }; };
+		8453DBF3BB462903D8BC6E32A8DC96AA /* RLMObjectSchema_Private.h in Headers */ = {isa = PBXBuildFile; fileRef = 39EC2928C1CCBC39A921620DDFD96D82 /* RLMObjectSchema_Private.h */; };
+		8479807F7974205B3D692E79AD0CCAA6 /* RLMCollection.h in Headers */ = {isa = PBXBuildFile; fileRef = EF3EA0BB050ED9B069BACDB1D1C1C942 /* RLMCollection.h */; };
+		85084F8B7E7D814B9807B7E5F57BE855 /* Realm.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 93C15EEA27225C32D5CD86F6795C07FD /* Realm.framework */; };
+		8612106CD85D4711E58535EF91BF622E /* RLMMigration_Private.h in Headers */ = {isa = PBXBuildFile; fileRef = 6A48695E5A9BBEF17C74EFA848CB156C /* RLMMigration_Private.h */; };
+		8EB11202167FCDDF1257AAAB1D1FB244 /* Alamofire.swift in Sources */ = {isa = PBXBuildFile; fileRef = 7778BA02000FAE2E38D0B43CB0ADB041 /* Alamofire.swift */; };
+		8F560AF2BE8DCFA8613D1975DB75A13A /* RLMConstants.h in Headers */ = {isa = PBXBuildFile; fileRef = 05DE259AF15D0F93D3AFD57A59A9495C /* RLMConstants.h */; };
+		8FDF3EC6EB8508A8FF522475AD4D5258 /* collection_notifier.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 2A0BD6C6A1D8C4DF507292BAFE01A9AF /* collection_notifier.cpp */; settings = {COMPILER_FLAGS = "-DREALM_HAVE_CONFIG -DREALM_COCOA_VERSION='@\"1.0.2\"' -D__ASSERTMACROS__"; }; };
+		92AED971B91C640191A5ABA1567FE358 /* GCDAsyncUdpSocket.h in Headers */ = {isa = PBXBuildFile; fileRef = 3413716D28F08C9D32BACE01C76E0A6A /* GCDAsyncUdpSocket.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		93A0B7C8CF9835D0E08D253E7A2D429A /* Util.swift in Sources */ = {isa = PBXBuildFile; fileRef = E76DA58891B2795226080060927F9B4C /* Util.swift */; };
+		9469DF81ECB494E84675969B5E13374C /* Alamofire-umbrella.h in Headers */ = {isa = PBXBuildFile; fileRef = 1EB2363B0AC4B0F124BCCB2692BC97C0 /* Alamofire-umbrella.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		94EEBAF2DF0DE2EC24022E3BC1B089FB /* RLMObject_Private.h in Headers */ = {isa = PBXBuildFile; fileRef = 306A2A8FAF7D486D1274450278867E99 /* RLMObject_Private.h */; };
+		96304D30C12A50F029EF191E7F4F88B4 /* RLMProperty_Private.h in Copy . Private Headers */ = {isa = PBXBuildFile; fileRef = DCEFB5DFE4D76193F6FD235B405F46FA /* RLMProperty_Private.h */; };
+		964123E91EEDB5950771E0016B7188DF /* RLMObjectStore.h in Headers */ = {isa = PBXBuildFile; fileRef = A1DA88D1D060CF47706351C7EA1F1AAA /* RLMObjectStore.h */; };
+		98D71EC18029ADBDBEE25635C45E6050 /* RLMObjectBase.h in Headers */ = {isa = PBXBuildFile; fileRef = 70D1FEC58F5689359AEBD4A4A39ABD0B /* RLMObjectBase.h */; };
+		991BFD139F6A45C9B654960C2F6A7F09 /* GCDAsyncSocket.m in Sources */ = {isa = PBXBuildFile; fileRef = F3F7962FEBB2F90580D5553BD6A8D641 /* GCDAsyncSocket.m */; settings = {COMPILER_FLAGS = "-DOS_OBJECT_USE_OBJC=0"; }; };
+		9F8CD9D307E64006D81CC09257D9DA81 /* RLMRealmConfiguration_Private.h in Copy . Private Headers */ = {isa = PBXBuildFile; fileRef = 3067C49420C8EE5231BC380EC5423C3B /* RLMRealmConfiguration_Private.h */; };
+		9FE77037B1C299EFD4F0BB8F4215D68F /* RLMResults_Private.h in Headers */ = {isa = PBXBuildFile; fileRef = A27E57EF66172A47F951A951279641EB /* RLMResults_Private.h */; };
+		A30F2D22FB320D680BD1641405F091BF /* Cocoa.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = EF2CEACC97C084704B8C47B4AEF30B95 /* Cocoa.framework */; };
+		A4C28B730D4613E2C6362850A894C296 /* RLMObservation.mm in Sources */ = {isa = PBXBuildFile; fileRef = F68D5564A432BBC5047C295C945E6D1B /* RLMObservation.mm */; settings = {COMPILER_FLAGS = "-DREALM_HAVE_CONFIG -DREALM_COCOA_VERSION='@\"1.0.2\"' -D__ASSERTMACROS__"; }; };
+		A78C69124BB4894698D1B74063B4FC34 /* SWXMLHash.swift in Sources */ = {isa = PBXBuildFile; fileRef = 019A7F44D041DF1FB3DA36096BBDA87D /* SWXMLHash.swift */; };
+		A87AAD2E1E24B08747752546032B64BE /* RLMRealm_Private.h in Headers */ = {isa = PBXBuildFile; fileRef = 504CC989D430FE0713751F279FBED3F7 /* RLMRealm_Private.h */; };
+		AA314156AC500125F4078EE968DB14C6 /* Result.swift in Sources */ = {isa = PBXBuildFile; fileRef = 220D2A12585D479CBE8A59A9529EBB36 /* Result.swift */; };
+		AA746F6B181CC898D80359146E08F505 /* RLMResults.h in Headers */ = {isa = PBXBuildFile; fileRef = 19649A3C1F0830CF06B570A783620A8C /* RLMResults.h */; };
+		AB80AA280B511D3C9B6E2A9286B00D0A /* SWXMLHash-dummy.m in Sources */ = {isa = PBXBuildFile; fileRef = 07B73ED369CA7C9866B2931685C7BA34 /* SWXMLHash-dummy.m */; };
+		ABAEE6459688BC4DB405EBA4DB58162F /* RLMOptionalBase.h in Copy . Public Headers */ = {isa = PBXBuildFile; fileRef = 91B7D6B5E8A8B097A92B157F9338B850 /* RLMOptionalBase.h */; };
+		ACBF2B133C9D4B5BCCE6C6EB7AEF4FB7 /* RLMPlatform.h in Headers */ = {isa = PBXBuildFile; fileRef = A6A11EDB1E620C3C59416592096A83F4 /* RLMPlatform.h */; };
+		ACFE60AB34A7FEF697E6EEFB62436A8D /* CocoaAsyncSocket-umbrella.h in Headers */ = {isa = PBXBuildFile; fileRef = C7CCB31E8DBDC7F1C378BE78D0B906AF /* CocoaAsyncSocket-umbrella.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		ADF19C953CE2A7D0B72EC93A81FCCC26 /* Alamofire-dummy.m in Sources */ = {isa = PBXBuildFile; fileRef = 73D908D2560A5E5403334F19E54ECA5E /* Alamofire-dummy.m */; };
+		AE4CF87C02C042DF13ED5B21C4FDC1E0 /* Stream.swift in Sources */ = {isa = PBXBuildFile; fileRef = 12227A36D20361D1BF13D6C8DDA5CD31 /* Stream.swift */; };
+		AFFD2D35CE366A9751FA01AEC1318E94 /* RLMListBase.h in Headers */ = {isa = PBXBuildFile; fileRef = 8AB91E74D4B7B8C9746AC13E026868E5 /* RLMListBase.h */; };
+		B0486015F69DD26839D206E96B6DB877 /* RLMRealmUtil.mm in Sources */ = {isa = PBXBuildFile; fileRef = 8FE2AF3F2938FAD0998D1855D5B63896 /* RLMRealmUtil.mm */; settings = {COMPILER_FLAGS = "-DREALM_HAVE_CONFIG -DREALM_COCOA_VERSION='@\"1.0.2\"' -D__ASSERTMACROS__"; }; };
+		B0C1F5E26DEFDEC831B86855EED8CD3A /* Object.swift in Sources */ = {isa = PBXBuildFile; fileRef = 22571F84B1419EDA2016665A62A59965 /* Object.swift */; };
+		B0E68C1208E2EDA7077E0E280B662032 /* RLMAccessor.h in Headers */ = {isa = PBXBuildFile; fileRef = A3920BF9AAF7A76983FA8FEBE4DD34A9 /* RLMAccessor.h */; };
+		B66E59315C1B9E4D300B8DCE686E59D9 /* RLMObjectBase_Dynamic.h in Headers */ = {isa = PBXBuildFile; fileRef = 993917E3199A0385691960033C7BEE0F /* RLMObjectBase_Dynamic.h */; };
+		B7FD9E07BBADA6155A7D25F51187AA88 /* RLMObjectBase.mm in Sources */ = {isa = PBXBuildFile; fileRef = BAD6352939A2ADFEC3172F4290CCC0C7 /* RLMObjectBase.mm */; settings = {COMPILER_FLAGS = "-DREALM_HAVE_CONFIG -DREALM_COCOA_VERSION='@\"1.0.2\"' -D__ASSERTMACROS__"; }; };
+		BA43FD0CA778F3697C690EB97A66917D /* results.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 6A91D67A5AAF3BC2E182DC333649D89D /* results.cpp */; settings = {COMPILER_FLAGS = "-DREALM_HAVE_CONFIG -DREALM_COCOA_VERSION='@\"1.0.2\"' -D__ASSERTMACROS__"; }; };
+		BDE1DE9BE8EABD319047EEC06AF32374 /* list_notifier.cpp in Sources */ = {isa = PBXBuildFile; fileRef = D1BF227B3F2547B149856D4C11A094ED /* list_notifier.cpp */; settings = {COMPILER_FLAGS = "-DREALM_HAVE_CONFIG -DREALM_COCOA_VERSION='@\"1.0.2\"' -D__ASSERTMACROS__"; }; };
+		BE41196F6A3903E59C3306FE3F8B43FE /* Notifications.swift in Sources */ = {isa = PBXBuildFile; fileRef = 5BE358098F08BC289211ED40D3C47E7A /* Notifications.swift */; };
+		BF5C95AC86C243B197111E3767053EF8 /* Pods-CRMCall092016-umbrella.h in Headers */ = {isa = PBXBuildFile; fileRef = 8204EF2923FBB8554D93693870D0BBBC /* Pods-CRMCall092016-umbrella.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		C032B518D7B1091EAFB62131DE17FFC4 /* Realm.swift in Sources */ = {isa = PBXBuildFile; fileRef = EDCBB647657C2C3D4E631730BD87CBEF /* Realm.swift */; };
+		C0DB70AB368765DC64BFB5FEA75E0696 /* ParameterEncoding.swift in Sources */ = {isa = PBXBuildFile; fileRef = B0CD6C71319EC54F1FF288131BA5DE47 /* ParameterEncoding.swift */; };
+		C17C732B94FA1472BFE1421A5BBA22F8 /* RLMRealm.mm in Sources */ = {isa = PBXBuildFile; fileRef = 0EBC7B2E2E5C37142DAF64C0B9B667F3 /* RLMRealm.mm */; settings = {COMPILER_FLAGS = "-DREALM_HAVE_CONFIG -DREALM_COCOA_VERSION='@\"1.0.2\"' -D__ASSERTMACROS__"; }; };
+		C1C5BDADA3AF45B8705AA5181E7711B1 /* object_store.cpp in Sources */ = {isa = PBXBuildFile; fileRef = BB4070B3352326986D9FE05A940801B5 /* object_store.cpp */; settings = {COMPILER_FLAGS = "-DREALM_HAVE_CONFIG -DREALM_COCOA_VERSION='@\"1.0.2\"' -D__ASSERTMACROS__"; }; };
+		C3ACC08F286DD02F5E1D432B37770EB7 /* RLMArray_Private.h in Headers */ = {isa = PBXBuildFile; fileRef = 603EE85140A9845165857F384CD8FDBE /* RLMArray_Private.h */; };
+		C5C58FEE0A35A9EF7DA80B26B6DF2089 /* CoreServices.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = F6D532FCFDBF982524EC2BB95D905B8C /* CoreServices.framework */; };
+		C7B6DD7C0456C50289A2C381DFE9FA3F /* MultipartFormData.swift in Sources */ = {isa = PBXBuildFile; fileRef = 839748B2274DB324C820B26A9BF56D28 /* MultipartFormData.swift */; };
+		C7F866B4DB3F20C02978C62DC1863006 /* RLMProperty.h in Copy . Public Headers */ = {isa = PBXBuildFile; fileRef = C385F154EFA2280EE2B25A9C8927532E /* RLMProperty.h */; };
+		CA63738F811EC06D63D77F580ADB2768 /* RLMRealmConfiguration_Private.h in Headers */ = {isa = PBXBuildFile; fileRef = 3067C49420C8EE5231BC380EC5423C3B /* RLMRealmConfiguration_Private.h */; };
+		CBFBF2EF919A692ED0E1BA3079E27196 /* RLMOptionalBase.h in Copy . Private Headers */ = {isa = PBXBuildFile; fileRef = 91B7D6B5E8A8B097A92B157F9338B850 /* RLMOptionalBase.h */; };
+		CD4E6002268B7CEF450B1EE1072F4827 /* RLMSchema.h in Copy . Public Headers */ = {isa = PBXBuildFile; fileRef = 759A40E09C374D9FAC2A32B6E6B51BEE /* RLMSchema.h */; };
+		D27443378E2E44F57DAB7FC9C36318E8 /* RLMMigration_Private.h in Copy . Private Headers */ = {isa = PBXBuildFile; fileRef = 6A48695E5A9BBEF17C74EFA848CB156C /* RLMMigration_Private.h */; };
+		D2A5277BF686845A99C13FB36E2F2707 /* RealmConfiguration.swift in Sources */ = {isa = PBXBuildFile; fileRef = D44B5B200051FA5E221B5CE99DB5E9CB /* RealmConfiguration.swift */; };
+		D345036427A2C00DFF2E789E63692167 /* Results.swift in Sources */ = {isa = PBXBuildFile; fileRef = 4D0F76250C7636412ECE540398378BA9 /* Results.swift */; };
+		D37A8588F16E220D8B89E9F55DE7F968 /* RLMArrayLinkView.mm in Sources */ = {isa = PBXBuildFile; fileRef = DF943DEC83B84B5E6F096C7725F9893F /* RLMArrayLinkView.mm */; settings = {COMPILER_FLAGS = "-DREALM_HAVE_CONFIG -DREALM_COCOA_VERSION='@\"1.0.2\"' -D__ASSERTMACROS__"; }; };
+		D5E1B1E437C8A93FF121C3D59F589D53 /* RealmCollectionType.swift in Sources */ = {isa = PBXBuildFile; fileRef = CA2A600578525EC4D358FA4D4D368028 /* RealmCollectionType.swift */; };
+		D8EF233B364DB40E3BD571F03F7EAB10 /* RLMListBase.h in Copy . Public Headers */ = {isa = PBXBuildFile; fileRef = 8AB91E74D4B7B8C9746AC13E026868E5 /* RLMListBase.h */; };
+		D97F1EE5F8ED75E5597B706A04888F5C /* Optional.swift in Sources */ = {isa = PBXBuildFile; fileRef = 02ABDDFF322E9C8072C47A29C4AE9853 /* Optional.swift */; };
+		D9A44696356E299F3C9A4BFF9E57343F /* GCDAsyncUdpSocket.m in Sources */ = {isa = PBXBuildFile; fileRef = 6C1D88914E0D7701C5B3AF31B2FD66E6 /* GCDAsyncUdpSocket.m */; settings = {COMPILER_FLAGS = "-DOS_OBJECT_USE_OBJC=0"; }; };
+		D9F77D96EE6022EB22723BA3FD8B39B8 /* RLMResults.h in Copy . Public Headers */ = {isa = PBXBuildFile; fileRef = 19649A3C1F0830CF06B570A783620A8C /* RLMResults.h */; };
+		DA028A3A24D844BB6303B79384EFDB2A /* Property.swift in Sources */ = {isa = PBXBuildFile; fileRef = DDFAA49E7969E902A28EFCDEAA5D8677 /* Property.swift */; };
+		DD384E19A50B0FCFC19CA30AB0DE98F4 /* RLMRealm_Private.h in Copy . Private Headers */ = {isa = PBXBuildFile; fileRef = 504CC989D430FE0713751F279FBED3F7 /* RLMRealm_Private.h */; };
+		E1B7F0E94AB5DD639E7CF983847E647D /* RLMObject.mm in Sources */ = {isa = PBXBuildFile; fileRef = 71DC7F67FDD0BF9050DFBDC4E8602EA2 /* RLMObject.mm */; settings = {COMPILER_FLAGS = "-DREALM_HAVE_CONFIG -DREALM_COCOA_VERSION='@\"1.0.2\"' -D__ASSERTMACROS__"; }; };
+		E5BCBAE67F225B8737A7A4183F2090BC /* RLMObjectStore.mm in Sources */ = {isa = PBXBuildFile; fileRef = 047DA1C7BF6AB4963466B0445E95F1E4 /* RLMObjectStore.mm */; settings = {COMPILER_FLAGS = "-DREALM_HAVE_CONFIG -DREALM_COCOA_VERSION='@\"1.0.2\"' -D__ASSERTMACROS__"; }; };
+		E7B5CC55D7809667ABA2650CBDCF03AF /* object_schema.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 27BD7C3F641985460BFF98B452F1C55C /* object_schema.cpp */; settings = {COMPILER_FLAGS = "-DREALM_HAVE_CONFIG -DREALM_COCOA_VERSION='@\"1.0.2\"' -D__ASSERTMACROS__"; }; };
+		ECD6AC26B55158C580CEF06277AB5E52 /* RLMObject_Private.h in Copy . Private Headers */ = {isa = PBXBuildFile; fileRef = 306A2A8FAF7D486D1274450278867E99 /* RLMObject_Private.h */; };
+		EDE7EE4076A8D6B35B018EF6484E8836 /* LinkingObjects.swift in Sources */ = {isa = PBXBuildFile; fileRef = 963BC61544C6EDCE6A1B2913BCEF4BC4 /* LinkingObjects.swift */; };
+		EFE92E8D3813DD26E78E93EEAF6D7E7E /* Request.swift in Sources */ = {isa = PBXBuildFile; fileRef = 3E740B8C21AD29F9A3C40D8EFAC837EF /* Request.swift */; };
+		F1E1F04193018B2F037A4786772BE201 /* Realm-dummy.m in Sources */ = {isa = PBXBuildFile; fileRef = 23E05212AFC1DB33676543D337320846 /* Realm-dummy.m */; };
+		F33A08097DD3A8517B968D25C568BCC3 /* RLMRealm_Dynamic.h in Headers */ = {isa = PBXBuildFile; fileRef = B50B323F3ACD65ABC1846D0E12764768 /* RLMRealm_Dynamic.h */; };
+		F3F3FD9096F43B73CBB52EF0E1CCF73E /* Cocoa.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = EF2CEACC97C084704B8C47B4AEF30B95 /* Cocoa.framework */; };
+		F45B40DF0BF596BDCD96B2D85EF848FA /* CocoaAsyncSocket-dummy.m in Sources */ = {isa = PBXBuildFile; fileRef = 0B953CC83AF3FC4665156118600B55E0 /* CocoaAsyncSocket-dummy.m */; };
+		F55C7A6C912F6472B7EC140590B88C7F /* RLMSwiftSupport.m in Sources */ = {isa = PBXBuildFile; fileRef = F6AC9E41AF014702EDCB3051D999ED25 /* RLMSwiftSupport.m */; settings = {COMPILER_FLAGS = "-DREALM_HAVE_CONFIG -DREALM_COCOA_VERSION='@\"1.0.2\"' -D__ASSERTMACROS__"; }; };
+		F5DB30F530F13061C1814ECADF48B9E0 /* RLMProperty.mm in Sources */ = {isa = PBXBuildFile; fileRef = 4BFC9AD553210CB43B52F794D50FB617 /* RLMProperty.mm */; settings = {COMPILER_FLAGS = "-DREALM_HAVE_CONFIG -DREALM_COCOA_VERSION='@\"1.0.2\"' -D__ASSERTMACROS__"; }; };
+		F815410F60914535DE07B90FD72CD130 /* RLMSchema_Private.h in Copy . Private Headers */ = {isa = PBXBuildFile; fileRef = F657C7C18C4DAAE7E00CD69442E14D56 /* RLMSchema_Private.h */; };
+		F8391AEAC14576ACD94F7BD1E0E99705 /* RLMObject.h in Copy . Public Headers */ = {isa = PBXBuildFile; fileRef = 13C423859E6ECC22EF81163F7C76147B /* RLMObject.h */; };
+		F91176BE34C14012D95757168B069E70 /* RLMConstants.h in Copy . Public Headers */ = {isa = PBXBuildFile; fileRef = 05DE259AF15D0F93D3AFD57A59A9495C /* RLMConstants.h */; };
+		FA57743E73DCBE1A1E63E3A96D2599EA /* SWXMLHash-umbrella.h in Headers */ = {isa = PBXBuildFile; fileRef = 4B67F67797D5E226E724CA1C1B188F6C /* SWXMLHash-umbrella.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		FB78A40B714406817637D40C534C6713 /* Aliases.swift in Sources */ = {isa = PBXBuildFile; fileRef = 97A0A04C613BA427FF38246D61BC8845 /* Aliases.swift */; };
+		FBAAC01AA1E2D2601766CA85025C4122 /* RLMCollection.h in Copy . Public Headers */ = {isa = PBXBuildFile; fileRef = EF3EA0BB050ED9B069BACDB1D1C1C942 /* RLMCollection.h */; };
+		FD219F561DF23E11FBD8591ED3364902 /* external_commit_helper.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 73C8592090433CE8AEA5378567BA7813 /* external_commit_helper.cpp */; settings = {COMPILER_FLAGS = "-DREALM_HAVE_CONFIG -DREALM_COCOA_VERSION='@\"1.0.2\"' -D__ASSERTMACROS__"; }; };
 /* End PBXBuildFile section */
 
 /* Begin PBXContainerItemProxy section */
-		1F41FB1990B1F3A39ADE4AEDF3C3DE3A /* PBXContainerItemProxy */ = {
+		02D857942B7F5E741C59720A77401E7C /* PBXContainerItemProxy */ = {
+			isa = PBXContainerItemProxy;
+			containerPortal = D41D8CD98F00B204E9800998ECF8427E /* Project object */;
+			proxyType = 1;
+			remoteGlobalIDString = 6ADBAF7183EDDAB0DE8E8BDEA68D46F1;
+			remoteInfo = RealmSwift;
+		};
+		1F2C9666E955023D1F090B725E81379B /* PBXContainerItemProxy */ = {
 			isa = PBXContainerItemProxy;
 			containerPortal = D41D8CD98F00B204E9800998ECF8427E /* Project object */;
 			proxyType = 1;
 			remoteGlobalIDString = 79C040AFDDCE1BCBF6D8B5EB0B85887F;
 			remoteInfo = Alamofire;
 		};
-		A6ED361CEE1ECD9230711154275A9274 /* PBXContainerItemProxy */ = {
+		3AE0E399596396AF1490D1C1CFB922FD /* PBXContainerItemProxy */ = {
 			isa = PBXContainerItemProxy;
 			containerPortal = D41D8CD98F00B204E9800998ECF8427E /* Project object */;
 			proxyType = 1;
-			remoteGlobalIDString = B37E19CA872A7535725D1E1946E5C271;
-			remoteInfo = CocoaAsyncSocket;
+			remoteGlobalIDString = 4269EA6DE49C90DEABF2DFAEBF5F6BCE;
+			remoteInfo = Realm;
 		};
-		A98B988E365E15D4E2D8C73D59A5F0EE /* PBXContainerItemProxy */ = {
+		72CE3D53E88A74E49F4B5DAAB1C38BC3 /* PBXContainerItemProxy */ = {
 			isa = PBXContainerItemProxy;
 			containerPortal = D41D8CD98F00B204E9800998ECF8427E /* Project object */;
 			proxyType = 1;
-			remoteGlobalIDString = 67C63D588DA997BFF7D3C999DA7A5A23;
+			remoteGlobalIDString = 9A1A088A814206B99346C15F88870371;
 			remoteInfo = SWXMLHash;
 		};
+		87F8D00088978F8CB43250CE34FDC045 /* PBXContainerItemProxy */ = {
+			isa = PBXContainerItemProxy;
+			containerPortal = D41D8CD98F00B204E9800998ECF8427E /* Project object */;
+			proxyType = 1;
+			remoteGlobalIDString = 4269EA6DE49C90DEABF2DFAEBF5F6BCE;
+			remoteInfo = Realm;
+		};
+		96C8A36F7D63CDDE0B5F74F88ED14937 /* PBXContainerItemProxy */ = {
+			isa = PBXContainerItemProxy;
+			containerPortal = D41D8CD98F00B204E9800998ECF8427E /* Project object */;
+			proxyType = 1;
+			remoteGlobalIDString = B37E19CA872A7535725D1E1946E5C271;
+			remoteInfo = CocoaAsyncSocket;
+		};
 /* End PBXContainerItemProxy section */
 
+/* Begin PBXCopyFilesBuildPhase section */
+		6F6F741FF6B9A4ED60C9CC191AF707A7 /* Copy . Public Headers */ = {
+			isa = PBXCopyFilesBuildPhase;
+			buildActionMask = 2147483647;
+			dstPath = "$(PUBLIC_HEADERS_FOLDER_PATH)/.";
+			dstSubfolderSpec = 16;
+			files = (
+				769DD013CC1B7E48E851EE36FA99F14B /* Realm.h in Copy . Public Headers */,
+				411EDA9EFC8CCBEEC90F153061D3EDCE /* RLMArray.h in Copy . Public Headers */,
+				FBAAC01AA1E2D2601766CA85025C4122 /* RLMCollection.h in Copy . Public Headers */,
+				F91176BE34C14012D95757168B069E70 /* RLMConstants.h in Copy . Public Headers */,
+				D8EF233B364DB40E3BD571F03F7EAB10 /* RLMListBase.h in Copy . Public Headers */,
+				51EAF68089AED4910CA5BCD81E9F94F4 /* RLMMigration.h in Copy . Public Headers */,
+				F8391AEAC14576ACD94F7BD1E0E99705 /* RLMObject.h in Copy . Public Headers */,
+				4837DA62EE2625AC429759B824184629 /* RLMObjectBase.h in Copy . Public Headers */,
+				48EAC52A897DAB77931ED70C0B75B4C3 /* RLMObjectBase_Dynamic.h in Copy . Public Headers */,
+				0A93F730B8DF64DB8BBA36ED0DC711F3 /* RLMObjectSchema.h in Copy . Public Headers */,
+				ABAEE6459688BC4DB405EBA4DB58162F /* RLMOptionalBase.h in Copy . Public Headers */,
+				2359969B6D3A4D02AE072B56329D5619 /* RLMPlatform.h in Copy . Public Headers */,
+				C7F866B4DB3F20C02978C62DC1863006 /* RLMProperty.h in Copy . Public Headers */,
+				5FF99131C449A8D9562842C352631433 /* RLMRealm.h in Copy . Public Headers */,
+				784AF43FC80EDF14A9086A58F9297BB9 /* RLMRealm_Dynamic.h in Copy . Public Headers */,
+				250F3A5B3B905BC7586DFC4D46D47649 /* RLMRealmConfiguration.h in Copy . Public Headers */,
+				D9F77D96EE6022EB22723BA3FD8B39B8 /* RLMResults.h in Copy . Public Headers */,
+				CD4E6002268B7CEF450B1EE1072F4827 /* RLMSchema.h in Copy . Public Headers */,
+			);
+			name = "Copy . Public Headers";
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		7C26769C65F69DF5348E56019D4D0121 /* Copy . Private Headers */ = {
+			isa = PBXCopyFilesBuildPhase;
+			buildActionMask = 2147483647;
+			dstPath = "$(PRIVATE_HEADERS_FOLDER_PATH)/.";
+			dstSubfolderSpec = 16;
+			files = (
+				6C0D034D17C2AA00E5268EFA425D2B0A /* RLMAccessor.h in Copy . Private Headers */,
+				54F747D247AA9B7ED59308AFCE991970 /* RLMArray_Private.h in Copy . Private Headers */,
+				5AF429552999C3D472618BA0AB15932A /* RLMListBase.h in Copy . Private Headers */,
+				D27443378E2E44F57DAB7FC9C36318E8 /* RLMMigration_Private.h in Copy . Private Headers */,
+				ECD6AC26B55158C580CEF06277AB5E52 /* RLMObject_Private.h in Copy . Private Headers */,
+				4CD8A056B105609D0DA1C3DBFD17487E /* RLMObjectSchema_Private.h in Copy . Private Headers */,
+				65675FB7D0A68A7894FFCF81BD83A08E /* RLMObjectStore.h in Copy . Private Headers */,
+				CBFBF2EF919A692ED0E1BA3079E27196 /* RLMOptionalBase.h in Copy . Private Headers */,
+				96304D30C12A50F029EF191E7F4F88B4 /* RLMProperty_Private.h in Copy . Private Headers */,
+				DD384E19A50B0FCFC19CA30AB0DE98F4 /* RLMRealm_Private.h in Copy . Private Headers */,
+				9F8CD9D307E64006D81CC09257D9DA81 /* RLMRealmConfiguration_Private.h in Copy . Private Headers */,
+				189AA94B049D92CA32C03B25DAF61BBD /* RLMResults_Private.h in Copy . Private Headers */,
+				F815410F60914535DE07B90FD72CD130 /* RLMSchema_Private.h in Copy . Private Headers */,
+			);
+			name = "Copy . Private Headers";
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXCopyFilesBuildPhase section */
+
 /* Begin PBXFileReference section */
+		000A75DAC6C2B739CD57D66C0B1F02B0 /* Info.plist */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
+		019A7F44D041DF1FB3DA36096BBDA87D /* SWXMLHash.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = SWXMLHash.swift; path = Source/SWXMLHash.swift; sourceTree = "<group>"; };
+		02ABDDFF322E9C8072C47A29C4AE9853 /* Optional.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Optional.swift; path = RealmSwift/Optional.swift; sourceTree = "<group>"; };
+		02D15662DC3CCD413D5966DE91A723AD /* CocoaAsyncSocket.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = CocoaAsyncSocket.framework; sourceTree = BUILT_PRODUCTS_DIR; };
+		047DA1C7BF6AB4963466B0445E95F1E4 /* RLMObjectStore.mm */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.cpp.objcpp; name = RLMObjectStore.mm; path = Realm/RLMObjectStore.mm; sourceTree = "<group>"; };
+		05DE259AF15D0F93D3AFD57A59A9495C /* RLMConstants.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = RLMConstants.h; path = include/RLMConstants.h; sourceTree = "<group>"; };
 		06FB8D033CAD052B54E275B7C0A5F2A4 /* Pods-CRMCall092016-resources.sh */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.script.sh; path = "Pods-CRMCall092016-resources.sh"; sourceTree = "<group>"; };
-		0E50EC0B768D99DF8AA54CEF00DCD620 /* CocoaAsyncSocket-prefix.pch */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; path = "CocoaAsyncSocket-prefix.pch"; sourceTree = "<group>"; };
+		07B73ED369CA7C9866B2931685C7BA34 /* SWXMLHash-dummy.m */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.objc; path = "SWXMLHash-dummy.m"; sourceTree = "<group>"; };
+		08F91D1BF9071E5ADD08774AE07E8753 /* RLMArray.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = RLMArray.h; path = include/RLMArray.h; sourceTree = "<group>"; };
+		092AFAD3D3E246E82EABB3AEE25F0185 /* RLMOptionalBase.mm */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.cpp.objcpp; name = RLMOptionalBase.mm; path = Realm/RLMOptionalBase.mm; sourceTree = "<group>"; };
+		097CF3C9C7046A002A271EAC0EE74AFF /* RLMCollection.mm */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.cpp.objcpp; name = RLMCollection.mm; path = Realm/RLMCollection.mm; sourceTree = "<group>"; };
+		0B953CC83AF3FC4665156118600B55E0 /* CocoaAsyncSocket-dummy.m */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.objc; path = "CocoaAsyncSocket-dummy.m"; sourceTree = "<group>"; };
+		0EBC7B2E2E5C37142DAF64C0B9B667F3 /* RLMRealm.mm */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.cpp.objcpp; name = RLMRealm.mm; path = Realm/RLMRealm.mm; sourceTree = "<group>"; };
+		0EDB157896F85AE259E754C00D3636F7 /* RLMMigration.mm */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.cpp.objcpp; name = RLMMigration.mm; path = Realm/RLMMigration.mm; sourceTree = "<group>"; };
+		0FBA0BF8AE6FB43DD83D8701888C4B27 /* RLMObjectSchema.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = RLMObjectSchema.h; path = include/RLMObjectSchema.h; sourceTree = "<group>"; };
+		10B67EDC27ECC211EF700D8B9B864881 /* Timeline.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Timeline.swift; path = Source/Timeline.swift; sourceTree = "<group>"; };
 		11566DE119910F4F8728001B55582E0A /* Pods-CRMCall092016.debug.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; path = "Pods-CRMCall092016.debug.xcconfig"; sourceTree = "<group>"; };
-		125D17DF5E6A1A7420D1F1A975DD7EB9 /* ParameterEncoding.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = ParameterEncoding.swift; path = Source/ParameterEncoding.swift; sourceTree = "<group>"; };
-		26831C2816B1A793F64FFC713F267BB3 /* Pods_CRMCall092016.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Pods_CRMCall092016.framework; sourceTree = BUILT_PRODUCTS_DIR; };
+		12227A36D20361D1BF13D6C8DDA5CD31 /* Stream.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Stream.swift; path = Source/Stream.swift; sourceTree = "<group>"; };
+		13BC77519ED297D8940D08A13E00DD95 /* List.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = List.swift; path = RealmSwift/List.swift; sourceTree = "<group>"; };
+		13C423859E6ECC22EF81163F7C76147B /* RLMObject.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = RLMObject.h; path = include/RLMObject.h; sourceTree = "<group>"; };
+		1889046CFA08897333E9DC1E4311B3C8 /* Validation.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Validation.swift; path = Source/Validation.swift; sourceTree = "<group>"; };
+		19649A3C1F0830CF06B570A783620A8C /* RLMResults.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = RLMResults.h; path = include/RLMResults.h; sourceTree = "<group>"; };
+		19BD404ABC703393738F3281762396B9 /* RealmSwift.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = RealmSwift.framework; sourceTree = BUILT_PRODUCTS_DIR; };
+		1AF6E060C7054FE55A838D6B0E0E4BD4 /* collection_notifications.cpp */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.cpp.cpp; name = collection_notifications.cpp; path = Realm/ObjectStore/collection_notifications.cpp; sourceTree = "<group>"; };
+		1EB2363B0AC4B0F124BCCB2692BC97C0 /* Alamofire-umbrella.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; path = "Alamofire-umbrella.h"; sourceTree = "<group>"; };
+		220D2A12585D479CBE8A59A9529EBB36 /* Result.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Result.swift; path = Source/Result.swift; sourceTree = "<group>"; };
+		22571F84B1419EDA2016665A62A59965 /* Object.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Object.swift; path = RealmSwift/Object.swift; sourceTree = "<group>"; };
+		23E05212AFC1DB33676543D337320846 /* Realm-dummy.m */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.objc; path = "Realm-dummy.m"; sourceTree = "<group>"; };
 		27183F652B0581A2389A12BA7AFAF98A /* Pods-CRMCall092016-frameworks.sh */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.script.sh; path = "Pods-CRMCall092016-frameworks.sh"; sourceTree = "<group>"; };
-		2AA16A476F2771B1B74FB14947F24E02 /* Download.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Download.swift; path = Source/Download.swift; sourceTree = "<group>"; };
+		27BD7C3F641985460BFF98B452F1C55C /* object_schema.cpp */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.cpp.cpp; name = object_schema.cpp; path = Realm/ObjectStore/object_schema.cpp; sourceTree = "<group>"; };
+		2A0BD6C6A1D8C4DF507292BAFE01A9AF /* collection_notifier.cpp */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.cpp.cpp; name = collection_notifier.cpp; path = Realm/ObjectStore/impl/collection_notifier.cpp; sourceTree = "<group>"; };
+		2A480B78E743AB3E12252457C8FC4737 /* list.cpp */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.cpp.cpp; name = list.cpp; path = Realm/ObjectStore/list.cpp; sourceTree = "<group>"; };
+		2AC63EBBC84F7B64AF720C29432FAD33 /* weak_realm_notifier.cpp */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.cpp.cpp; name = weak_realm_notifier.cpp; path = Realm/ObjectStore/impl/apple/weak_realm_notifier.cpp; sourceTree = "<group>"; };
 		2AE57F75653AE6E263CFF4332F052094 /* Pods-CRMCall092016-dummy.m */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.objc; path = "Pods-CRMCall092016-dummy.m"; sourceTree = "<group>"; };
-		2BDE952759498BFF23C89A0302BD584C /* SWXMLHash-dummy.m */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.objc; path = "SWXMLHash-dummy.m"; sourceTree = "<group>"; };
+		2BCEF6A165FEA12AA3EA4EABBA761CF9 /* RLMUpdateChecker.mm */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.cpp.objcpp; name = RLMUpdateChecker.mm; path = Realm/RLMUpdateChecker.mm; sourceTree = "<group>"; };
+		2BF418666618F7F4C8707584A96D3E15 /* index_set.cpp */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.cpp.cpp; name = index_set.cpp; path = Realm/ObjectStore/index_set.cpp; sourceTree = "<group>"; };
+		2C921E459B087BFEF2796F7087F78F9C /* RLMRealmConfiguration.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = RLMRealmConfiguration.h; path = include/RLMRealmConfiguration.h; sourceTree = "<group>"; };
+		2CC788BB98D1C340FD628F61B02A6A0B /* Download.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Download.swift; path = Source/Download.swift; sourceTree = "<group>"; };
+		3067C49420C8EE5231BC380EC5423C3B /* RLMRealmConfiguration_Private.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = RLMRealmConfiguration_Private.h; path = include/RLMRealmConfiguration_Private.h; sourceTree = "<group>"; };
+		306A2A8FAF7D486D1274450278867E99 /* RLMObject_Private.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = RLMObject_Private.h; path = include/RLMObject_Private.h; sourceTree = "<group>"; };
 		3344C80F9295CA22275F8A0581FF4EAB /* Pods-CRMCall092016.release.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; path = "Pods-CRMCall092016.release.xcconfig"; sourceTree = "<group>"; };
+		3413716D28F08C9D32BACE01C76E0A6A /* GCDAsyncUdpSocket.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = GCDAsyncUdpSocket.h; path = Source/GCD/GCDAsyncUdpSocket.h; sourceTree = "<group>"; };
+		343C51283A351FEFF824D6C9A0F89466 /* Realm.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; path = Realm.xcconfig; sourceTree = "<group>"; };
+		379FAEE80725487D7F3C6891939A7D54 /* Security.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Security.framework; path = Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk/System/Library/Frameworks/Security.framework; sourceTree = DEVELOPER_DIR; };
+		38738ED527609FB98672FBC7A6CA4F90 /* RLMQueryUtil.mm */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.cpp.objcpp; name = RLMQueryUtil.mm; path = Realm/RLMQueryUtil.mm; sourceTree = "<group>"; };
 		38BAD449C799FB480EAEF1177A7D5534 /* Pods-CRMCall092016-acknowledgements.plist */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.plist.xml; path = "Pods-CRMCall092016-acknowledgements.plist"; sourceTree = "<group>"; };
-		3E8CB71BFFC59E2E3BA715D7AEF30B56 /* SWXMLHash.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; path = SWXMLHash.xcconfig; sourceTree = "<group>"; };
-		421DBE2696953979E49FD7BBE38C3847 /* CocoaAsyncSocket.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; path = CocoaAsyncSocket.xcconfig; sourceTree = "<group>"; };
-		428FFE99F83C8F7F2E1E0A88D7622693 /* Alamofire-prefix.pch */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; path = "Alamofire-prefix.pch"; sourceTree = "<group>"; };
-		530C70E607990B234619FFA25EF6C451 /* SWXMLHash-prefix.pch */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; path = "SWXMLHash-prefix.pch"; sourceTree = "<group>"; };
-		5399F7CAF2240783134915CC1CBEF3E5 /* Alamofire-dummy.m */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.objc; path = "Alamofire-dummy.m"; sourceTree = "<group>"; };
-		540A59953BD2C3205CF5F2CE7B7BFC1F /* GCDAsyncUdpSocket.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = GCDAsyncUdpSocket.h; path = Source/GCD/GCDAsyncUdpSocket.h; sourceTree = "<group>"; };
-		588A6F6AFA80EA93ECB5E93B156711EC /* Alamofire-umbrella.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; path = "Alamofire-umbrella.h"; sourceTree = "<group>"; };
-		5B2BB4979BAD0CF7156F74E71CAD3041 /* Stream.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Stream.swift; path = Source/Stream.swift; sourceTree = "<group>"; };
-		5F0B453266F2DE0B098E2B994FE716CD /* SWXMLHash-umbrella.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; path = "SWXMLHash-umbrella.h"; sourceTree = "<group>"; };
+		39EC2928C1CCBC39A921620DDFD96D82 /* RLMObjectSchema_Private.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = RLMObjectSchema_Private.h; path = include/RLMObjectSchema_Private.h; sourceTree = "<group>"; };
+		3A6026079EF2B73B70549DEB46908083 /* Info.plist */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
+		3A6C08B4B95C6657BEA86714D5D87BF0 /* results_notifier.cpp */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.cpp.cpp; name = results_notifier.cpp; path = Realm/ObjectStore/impl/results_notifier.cpp; sourceTree = "<group>"; };
+		3D0184AC2929C1EA7FF747E2E43349EE /* RLMObjectSchema.mm */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.cpp.objcpp; name = RLMObjectSchema.mm; path = Realm/RLMObjectSchema.mm; sourceTree = "<group>"; };
+		3DCB0C38EB20D53EA34F4E4A62FBE439 /* RLMListBase.mm */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.cpp.objcpp; name = RLMListBase.mm; path = Realm/RLMListBase.mm; sourceTree = "<group>"; };
+		3E740B8C21AD29F9A3C40D8EFAC837EF /* Request.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Request.swift; path = Source/Request.swift; sourceTree = "<group>"; };
+		4031E673462ED1173C604881D275DD67 /* shared_realm.cpp */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.cpp.cpp; name = shared_realm.cpp; path = Realm/ObjectStore/shared_realm.cpp; sourceTree = "<group>"; };
+		406B82824C096749C85CFC8F9A440C42 /* Info.plist */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
+		4153ADCADFA2E29B38AAF7DA58B24B9C /* SortDescriptor.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = SortDescriptor.swift; path = RealmSwift/SortDescriptor.swift; sourceTree = "<group>"; };
+		43BBB01E7B94E0969186C664FC16998C /* Schema.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Schema.swift; path = RealmSwift/Schema.swift; sourceTree = "<group>"; };
+		4AA00B0A44C7085915719349ABB3AB96 /* Realm-prefix.pch */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; path = "Realm-prefix.pch"; sourceTree = "<group>"; };
+		4B1A2836B3567ABD34B44D494734C530 /* Manager.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Manager.swift; path = Source/Manager.swift; sourceTree = "<group>"; };
+		4B67F67797D5E226E724CA1C1B188F6C /* SWXMLHash-umbrella.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; path = "SWXMLHash-umbrella.h"; sourceTree = "<group>"; };
+		4BFC9AD553210CB43B52F794D50FB617 /* RLMProperty.mm */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.cpp.objcpp; name = RLMProperty.mm; path = Realm/RLMProperty.mm; sourceTree = "<group>"; };
+		4D0F76250C7636412ECE540398378BA9 /* Results.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Results.swift; path = RealmSwift/Results.swift; sourceTree = "<group>"; };
+		4FCD5E9B89170963F9CB31AE398392B4 /* SWXMLHash+TypeConversion.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = "SWXMLHash+TypeConversion.swift"; path = "Source/SWXMLHash+TypeConversion.swift"; sourceTree = "<group>"; };
+		504CC989D430FE0713751F279FBED3F7 /* RLMRealm_Private.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = RLMRealm_Private.h; path = include/RLMRealm_Private.h; sourceTree = "<group>"; };
+		50FBB3642BCCABB18EA03B909A831827 /* Alamofire.modulemap */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = "sourcecode.module-map"; path = Alamofire.modulemap; sourceTree = "<group>"; };
+		53A5F544C86A60EE30CE30D71CF04329 /* Upload.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Upload.swift; path = Source/Upload.swift; sourceTree = "<group>"; };
+		548C4A5E8A66BE8922AEFC3C49C1834B /* transact_log_handler.cpp */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.cpp.cpp; name = transact_log_handler.cpp; path = Realm/ObjectStore/impl/transact_log_handler.cpp; sourceTree = "<group>"; };
+		57A535882F71C09BBB596024C41B85D6 /* Realm.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Realm.framework; sourceTree = BUILT_PRODUCTS_DIR; };
+		5BE358098F08BC289211ED40D3C47E7A /* Notifications.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Notifications.swift; path = Source/Notifications.swift; sourceTree = "<group>"; };
 		5F10F69CC4AED6A9E8880E0026D1641C /* Pods-CRMCall092016.modulemap */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = "sourcecode.module-map"; path = "Pods-CRMCall092016.modulemap"; sourceTree = "<group>"; };
-		5F955B5F2D78E83D6BA538909B360F55 /* CocoaAsyncSocket-umbrella.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; path = "CocoaAsyncSocket-umbrella.h"; sourceTree = "<group>"; };
-		62073F3761055A46F154B11F061A08AF /* ServerTrustPolicy.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = ServerTrustPolicy.swift; path = Source/ServerTrustPolicy.swift; sourceTree = "<group>"; };
-		64E8485F5FCFC4FDB8D6CE0BFC980C58 /* NetworkReachabilityManager.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = NetworkReachabilityManager.swift; path = Source/NetworkReachabilityManager.swift; sourceTree = "<group>"; };
+		603EE85140A9845165857F384CD8FDBE /* RLMArray_Private.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = RLMArray_Private.h; path = include/RLMArray_Private.h; sourceTree = "<group>"; };
+		62578698CCBAC958046DC385BEF20D2F /* RealmSwift.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; path = RealmSwift.xcconfig; sourceTree = "<group>"; };
+		654F9073F4DB3BDB257921EE989FAA72 /* collection_change_builder.cpp */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.cpp.cpp; name = collection_change_builder.cpp; path = Realm/ObjectStore/impl/collection_change_builder.cpp; sourceTree = "<group>"; };
+		670515BB35AFEF410C80DC0D58E5DFD8 /* NetworkReachabilityManager.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = NetworkReachabilityManager.swift; path = Source/NetworkReachabilityManager.swift; sourceTree = "<group>"; };
 		686F90C995F21EC49B98AEDDD4DFE31A /* Info.plist */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
-		6D0E27C7C865AC6950E934CB59C487B1 /* Alamofire.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; path = Alamofire.xcconfig; sourceTree = "<group>"; };
-		7031D4000017108DC80504B065340368 /* Manager.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Manager.swift; path = Source/Manager.swift; sourceTree = "<group>"; };
-		7201E46C9812098E184043C076154118 /* SWXMLHash.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = SWXMLHash.swift; path = Source/SWXMLHash.swift; sourceTree = "<group>"; };
-		72118B3908192BACF6200F55157D9D71 /* Info.plist */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
-		7911AB14649A75D2129B7AF99D9F284F /* CocoaAsyncSocket.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = CocoaAsyncSocket.framework; sourceTree = BUILT_PRODUCTS_DIR; };
-		7B57FE540E66A44F3A0381EE3E553552 /* Alamofire.modulemap */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = "sourcecode.module-map"; path = Alamofire.modulemap; sourceTree = "<group>"; };
-		7C56649C408E00F4469558EBC9AF1BA3 /* Cocoa.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Cocoa.framework; path = Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk/System/Library/Frameworks/Cocoa.framework; sourceTree = DEVELOPER_DIR; };
-		8028EBFA77CCF460ADEBC79B87525C3D /* CoreServices.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = CoreServices.framework; path = Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk/System/Library/Frameworks/CoreServices.framework; sourceTree = DEVELOPER_DIR; };
+		6966A95E558E0201A53049B6BB5CD2AE /* SWXMLHash-prefix.pch */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; path = "SWXMLHash-prefix.pch"; sourceTree = "<group>"; };
+		6A48695E5A9BBEF17C74EFA848CB156C /* RLMMigration_Private.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = RLMMigration_Private.h; path = include/RLMMigration_Private.h; sourceTree = "<group>"; };
+		6A91D67A5AAF3BC2E182DC333649D89D /* results.cpp */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.cpp.cpp; name = results.cpp; path = Realm/ObjectStore/results.cpp; sourceTree = "<group>"; };
+		6C114501AD56C8B1F8B2932028D038BE /* Response.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Response.swift; path = Source/Response.swift; sourceTree = "<group>"; };
+		6C1D88914E0D7701C5B3AF31B2FD66E6 /* GCDAsyncUdpSocket.m */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.objc; name = GCDAsyncUdpSocket.m; path = Source/GCD/GCDAsyncUdpSocket.m; sourceTree = "<group>"; };
+		6DD9AC2FAD4B64F2D7CC258B71DF2BE1 /* GCDAsyncSocket.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = GCDAsyncSocket.h; path = Source/GCD/GCDAsyncSocket.h; sourceTree = "<group>"; };
+		6EAF315EE8B882259BBB61D457ECDE6B /* RLMAnalytics.mm */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.cpp.objcpp; name = RLMAnalytics.mm; path = Realm/RLMAnalytics.mm; sourceTree = "<group>"; };
+		6FD434DFF34C1B81255CAB7549272388 /* format.cpp */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.cpp.cpp; name = format.cpp; path = Realm/ObjectStore/util/format.cpp; sourceTree = "<group>"; };
+		70D1FEC58F5689359AEBD4A4A39ABD0B /* RLMObjectBase.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = RLMObjectBase.h; path = include/RLMObjectBase.h; sourceTree = "<group>"; };
+		710E8D676393E8E638B681FFE1148A77 /* SwiftVersion.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = SwiftVersion.swift; path = RealmSwift/SwiftVersion.swift; sourceTree = "<group>"; };
+		71DC7F67FDD0BF9050DFBDC4E8602EA2 /* RLMObject.mm */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.cpp.objcpp; name = RLMObject.mm; path = Realm/RLMObject.mm; sourceTree = "<group>"; };
+		721951E8312A8726BE2F5FF553509299 /* RLMPredicateUtil.mm */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.cpp.objcpp; name = RLMPredicateUtil.mm; path = Realm/RLMPredicateUtil.mm; sourceTree = "<group>"; };
+		72911E861245A78B7F5F53946D9CFD39 /* RLMRealm.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = RLMRealm.h; path = include/RLMRealm.h; sourceTree = "<group>"; };
+		73C8592090433CE8AEA5378567BA7813 /* external_commit_helper.cpp */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.cpp.cpp; name = external_commit_helper.cpp; path = Realm/ObjectStore/impl/apple/external_commit_helper.cpp; sourceTree = "<group>"; };
+		73D908D2560A5E5403334F19E54ECA5E /* Alamofire-dummy.m */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.objc; path = "Alamofire-dummy.m"; sourceTree = "<group>"; };
+		759A40E09C374D9FAC2A32B6E6B51BEE /* RLMSchema.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = RLMSchema.h; path = include/RLMSchema.h; sourceTree = "<group>"; };
+		7778BA02000FAE2E38D0B43CB0ADB041 /* Alamofire.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Alamofire.swift; path = Source/Alamofire.swift; sourceTree = "<group>"; };
+		7A6FA0877A6C34660B6749EABACD4143 /* Alamofire-prefix.pch */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; path = "Alamofire-prefix.pch"; sourceTree = "<group>"; };
+		7C7C032A575AE7ECF05272A7332C6DFB /* Migration.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Migration.swift; path = RealmSwift/Migration.swift; sourceTree = "<group>"; };
 		8204EF2923FBB8554D93693870D0BBBC /* Pods-CRMCall092016-umbrella.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; path = "Pods-CRMCall092016-umbrella.h"; sourceTree = "<group>"; };
-		84395B1E623BD8F9DE2F7E16CA43251F /* Validation.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Validation.swift; path = Source/Validation.swift; sourceTree = "<group>"; };
-		875107E5B1CD30A24F90CC34B1452862 /* Info.plist */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
-		8991BF3DBE2A9AD6CB35BF27297CC8FD /* Upload.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Upload.swift; path = Source/Upload.swift; sourceTree = "<group>"; };
-		8D365AF8CA284382154A3FCADC2924CC /* Alamofire.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Alamofire.framework; sourceTree = BUILT_PRODUCTS_DIR; };
+		82BE7BD553333FB342905741BD1287AB /* SWXMLHash.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = SWXMLHash.framework; sourceTree = BUILT_PRODUCTS_DIR; };
+		839748B2274DB324C820B26A9BF56D28 /* MultipartFormData.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = MultipartFormData.swift; path = Source/MultipartFormData.swift; sourceTree = "<group>"; };
+		83D17D99218E43E698EFBBEA8F1E16C1 /* RLMRealmConfiguration.mm */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.cpp.objcpp; name = RLMRealmConfiguration.mm; path = Realm/RLMRealmConfiguration.mm; sourceTree = "<group>"; };
+		8500DBF281DABBC85C75A40EDF5B1A9D /* CocoaAsyncSocket.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; path = CocoaAsyncSocket.xcconfig; sourceTree = "<group>"; };
+		86C1D7A6A276CDE0E92E766763E7CC2A /* RLMArray.mm */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.cpp.objcpp; name = RLMArray.mm; path = Realm/RLMArray.mm; sourceTree = "<group>"; };
+		890EB3A0E1F5BB93320BDE2404719B64 /* Info.plist */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
+		8AB91E74D4B7B8C9746AC13E026868E5 /* RLMListBase.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = RLMListBase.h; path = include/RLMListBase.h; sourceTree = "<group>"; };
+		8CC308D8DF686F792BAE73FC47E930D4 /* Info.plist */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
+		8FE2AF3F2938FAD0998D1855D5B63896 /* RLMRealmUtil.mm */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.cpp.objcpp; name = RLMRealmUtil.mm; path = Realm/RLMRealmUtil.mm; sourceTree = "<group>"; };
+		91B7D6B5E8A8B097A92B157F9338B850 /* RLMOptionalBase.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = RLMOptionalBase.h; path = include/RLMOptionalBase.h; sourceTree = "<group>"; };
 		92BE530B50F95F40971BFC22BF7114AF /* Pods-CRMCall092016-acknowledgements.markdown */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text; path = "Pods-CRMCall092016-acknowledgements.markdown"; sourceTree = "<group>"; };
 		93A4A3777CF96A4AAC1D13BA6DCCEA73 /* Podfile */ = {isa = PBXFileReference; explicitFileType = text.script.ruby; includeInIndex = 1; name = Podfile; path = ../Podfile; sourceTree = SOURCE_ROOT; xcLanguageSpecificationIdentifier = xcode.lang.ruby; };
-		ABC09E1DCC49261B7629CD82626C21FA /* CocoaAsyncSocket-dummy.m */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.objc; path = "CocoaAsyncSocket-dummy.m"; sourceTree = "<group>"; };
-		AF650B57C6596DA153F5900EA61CC5A7 /* MultipartFormData.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = MultipartFormData.swift; path = Source/MultipartFormData.swift; sourceTree = "<group>"; };
-		B7C925E8849659F01450961BB1FFA23D /* ResponseSerialization.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = ResponseSerialization.swift; path = Source/ResponseSerialization.swift; sourceTree = "<group>"; };
-		BC6E9E2C5DCCD36683912082D39D119C /* SWXMLHash.modulemap */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = "sourcecode.module-map"; path = SWXMLHash.modulemap; sourceTree = "<group>"; };
-		C3D72D35EB73312A9630B6441B6D65DC /* Info.plist */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
-		C608DAD3E8D1E316C917482D1150C9E4 /* SWXMLHash.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = SWXMLHash.framework; sourceTree = BUILT_PRODUCTS_DIR; };
-		CE89954F8A8211757E95D5E68308F52F /* SWXMLHash+TypeConversion.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = "SWXMLHash+TypeConversion.swift"; path = "Source/SWXMLHash+TypeConversion.swift"; sourceTree = "<group>"; };
-		D1519185135D5351111F109E89AF0F64 /* GCDAsyncSocket.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = GCDAsyncSocket.h; path = Source/GCD/GCDAsyncSocket.h; sourceTree = "<group>"; };
-		D77E19C3839748928122D0DEAC1BA1F4 /* Timeline.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Timeline.swift; path = Source/Timeline.swift; sourceTree = "<group>"; };
-		DDE49D9DCF93A390B23188C67221ECA8 /* Response.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Response.swift; path = Source/Response.swift; sourceTree = "<group>"; };
-		E01E26D8749A98484E8DD7726148EC20 /* Alamofire.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Alamofire.swift; path = Source/Alamofire.swift; sourceTree = "<group>"; };
-		E0D2633544BCFC90D4DD429B2FE884D7 /* CocoaAsyncSocket.modulemap */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = "sourcecode.module-map"; path = CocoaAsyncSocket.modulemap; sourceTree = "<group>"; };
-		E2A2BD6EE0720A5171EF80B09CFD4224 /* Result.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Result.swift; path = Source/Result.swift; sourceTree = "<group>"; };
-		E35F27DD11D07BB27A6C8CE52CD34061 /* Security.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Security.framework; path = Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk/System/Library/Frameworks/Security.framework; sourceTree = DEVELOPER_DIR; };
-		ECD84F348832D77D5059D066749346A4 /* Notifications.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Notifications.swift; path = Source/Notifications.swift; sourceTree = "<group>"; };
-		ED466E93414A976222AFAF321E9AF11C /* GCDAsyncUdpSocket.m */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.objc; name = GCDAsyncUdpSocket.m; path = Source/GCD/GCDAsyncUdpSocket.m; sourceTree = "<group>"; };
-		EF9B2AFCE03477C50F07C48E33A463FF /* Error.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Error.swift; path = Source/Error.swift; sourceTree = "<group>"; };
-		F14E627DC549703B46315BBCCDD362AE /* Request.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Request.swift; path = Source/Request.swift; sourceTree = "<group>"; };
-		FB4019B4F3DF5D7B015227F280ABBE9C /* GCDAsyncSocket.m */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.objc; name = GCDAsyncSocket.m; path = Source/GCD/GCDAsyncSocket.m; sourceTree = "<group>"; };
+		93C15EEA27225C32D5CD86F6795C07FD /* Realm.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Realm.framework; sourceTree = BUILT_PRODUCTS_DIR; };
+		963BC61544C6EDCE6A1B2913BCEF4BC4 /* LinkingObjects.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = LinkingObjects.swift; path = RealmSwift/LinkingObjects.swift; sourceTree = "<group>"; };
+		97A0A04C613BA427FF38246D61BC8845 /* Aliases.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Aliases.swift; path = RealmSwift/Aliases.swift; sourceTree = "<group>"; };
+		993917E3199A0385691960033C7BEE0F /* RLMObjectBase_Dynamic.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = RLMObjectBase_Dynamic.h; path = include/RLMObjectBase_Dynamic.h; sourceTree = "<group>"; };
+		9E18D43D3F5726FA53402C61C9042E7F /* RLMMigration.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = RLMMigration.h; path = include/RLMMigration.h; sourceTree = "<group>"; };
+		9F42B3D2E5CBDF7867A8A2DB4F9E99BD /* RealmSwift-umbrella.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; path = "RealmSwift-umbrella.h"; sourceTree = "<group>"; };
+		A1DA88D1D060CF47706351C7EA1F1AAA /* RLMObjectStore.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = RLMObjectStore.h; path = include/RLMObjectStore.h; sourceTree = "<group>"; };
+		A27E57EF66172A47F951A951279641EB /* RLMResults_Private.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = RLMResults_Private.h; path = include/RLMResults_Private.h; sourceTree = "<group>"; };
+		A2A54645E8AA3FA9CBEA2A759DF82F29 /* ServerTrustPolicy.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = ServerTrustPolicy.swift; path = Source/ServerTrustPolicy.swift; sourceTree = "<group>"; };
+		A3920BF9AAF7A76983FA8FEBE4DD34A9 /* RLMAccessor.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = RLMAccessor.h; path = include/RLMAccessor.h; sourceTree = "<group>"; };
+		A6A11EDB1E620C3C59416592096A83F4 /* RLMPlatform.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = RLMPlatform.h; path = include/RLMPlatform.h; sourceTree = "<group>"; };
+		ACFB0B2BC281EBF4FB0F22B8EDE34F3F /* Error.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Error.swift; path = RealmSwift/Error.swift; sourceTree = "<group>"; };
+		AF62ADCFE9F1C89C7A1130868151C4A6 /* Pods_CRMCall092016.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Pods_CRMCall092016.framework; sourceTree = BUILT_PRODUCTS_DIR; };
+		B0CD6C71319EC54F1FF288131BA5DE47 /* ParameterEncoding.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = ParameterEncoding.swift; path = Source/ParameterEncoding.swift; sourceTree = "<group>"; };
+		B1049E8532A11B579AFE58F91D5DDF4A /* Realm.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = Realm.h; path = include/Realm.h; sourceTree = "<group>"; };
+		B50B323F3ACD65ABC1846D0E12764768 /* RLMRealm_Dynamic.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = RLMRealm_Dynamic.h; path = include/RLMRealm_Dynamic.h; sourceTree = "<group>"; };
+		BA702A928A3EDB738041CEE543786650 /* ResponseSerialization.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = ResponseSerialization.swift; path = Source/ResponseSerialization.swift; sourceTree = "<group>"; };
+		BABC0F59B38A48FA1B1487176D304E57 /* RLMAccessor.mm */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.cpp.objcpp; name = RLMAccessor.mm; path = Realm/RLMAccessor.mm; sourceTree = "<group>"; };
+		BAD6352939A2ADFEC3172F4290CCC0C7 /* RLMObjectBase.mm */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.cpp.objcpp; name = RLMObjectBase.mm; path = Realm/RLMObjectBase.mm; sourceTree = "<group>"; };
+		BB4070B3352326986D9FE05A940801B5 /* object_store.cpp */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.cpp.cpp; name = object_store.cpp; path = Realm/ObjectStore/object_store.cpp; sourceTree = "<group>"; };
+		BF370B72BAFFAC185AAF8B5F858617F6 /* librealm-macosx.a */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = archive.ar; name = "librealm-macosx.a"; path = "core/librealm-macosx.a"; sourceTree = "<group>"; };
+		C13BD87EFD0BE9D46ED6430E37CE0373 /* CocoaAsyncSocket-prefix.pch */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; path = "CocoaAsyncSocket-prefix.pch"; sourceTree = "<group>"; };
+		C231809D6172C447734FABEDB09AD9FE /* RealmSwift-dummy.m */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.objc; path = "RealmSwift-dummy.m"; sourceTree = "<group>"; };
+		C385F154EFA2280EE2B25A9C8927532E /* RLMProperty.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = RLMProperty.h; path = include/RLMProperty.h; sourceTree = "<group>"; };
+		C4B1167C159C1C277164C1CD2AE12196 /* RealmSwift.modulemap */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = "sourcecode.module-map"; path = RealmSwift.modulemap; sourceTree = "<group>"; };
+		C63CABFAC66CBD384E95B91088CD77AE /* ObjectSchema.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = ObjectSchema.swift; path = RealmSwift/ObjectSchema.swift; sourceTree = "<group>"; };
+		C7CCB31E8DBDC7F1C378BE78D0B906AF /* CocoaAsyncSocket-umbrella.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; path = "CocoaAsyncSocket-umbrella.h"; sourceTree = "<group>"; };
+		C7F86DCD7EEB622090BF3C05875A07C3 /* RealmSwift-prefix.pch */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; path = "RealmSwift-prefix.pch"; sourceTree = "<group>"; };
+		CA2A600578525EC4D358FA4D4D368028 /* RealmCollectionType.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = RealmCollectionType.swift; path = RealmSwift/RealmCollectionType.swift; sourceTree = "<group>"; };
+		CD23BAABFCE35DD804DAC4C92A8D46BB /* SWXMLHash.modulemap */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = "sourcecode.module-map"; path = SWXMLHash.modulemap; sourceTree = "<group>"; };
+		D1BF227B3F2547B149856D4C11A094ED /* list_notifier.cpp */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.cpp.cpp; name = list_notifier.cpp; path = Realm/ObjectStore/impl/list_notifier.cpp; sourceTree = "<group>"; };
+		D35CBC6F3793C679EA6A7642369CB558 /* Realm.modulemap */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = "sourcecode.module-map"; path = Realm.modulemap; sourceTree = "<group>"; };
+		D44B5B200051FA5E221B5CE99DB5E9CB /* RealmConfiguration.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = RealmConfiguration.swift; path = RealmSwift/RealmConfiguration.swift; sourceTree = "<group>"; };
+		DCEFB5DFE4D76193F6FD235B405F46FA /* RLMProperty_Private.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = RLMProperty_Private.h; path = include/RLMProperty_Private.h; sourceTree = "<group>"; };
+		DD11F05494F36665158CAA5C69C4CCDC /* Error.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Error.swift; path = Source/Error.swift; sourceTree = "<group>"; };
+		DDFAA49E7969E902A28EFCDEAA5D8677 /* Property.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Property.swift; path = RealmSwift/Property.swift; sourceTree = "<group>"; };
+		DE4DAE53005DB209CAC0601F2A3872FE /* RLMSchema.mm */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.cpp.objcpp; name = RLMSchema.mm; path = Realm/RLMSchema.mm; sourceTree = "<group>"; };
+		DF943DEC83B84B5E6F096C7725F9893F /* RLMArrayLinkView.mm */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.cpp.objcpp; name = RLMArrayLinkView.mm; path = Realm/RLMArrayLinkView.mm; sourceTree = "<group>"; };
+		E07ADF045C902C4670716DA2B348504E /* Alamofire.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Alamofire.framework; sourceTree = BUILT_PRODUCTS_DIR; };
+		E20874320351EC32784CC1743B614A6B /* RLMResults.mm */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.cpp.objcpp; name = RLMResults.mm; path = Realm/RLMResults.mm; sourceTree = "<group>"; };
+		E2C94AAF5D146D3A82104EFD186BC1D5 /* CocoaAsyncSocket.modulemap */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = "sourcecode.module-map"; path = CocoaAsyncSocket.modulemap; sourceTree = "<group>"; };
+		E76DA58891B2795226080060927F9B4C /* Util.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Util.swift; path = RealmSwift/Util.swift; sourceTree = "<group>"; };
+		E7CAF6E8B1C938AF00BC311BB3EF2BF2 /* realm_coordinator.cpp */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.cpp.cpp; name = realm_coordinator.cpp; path = Realm/ObjectStore/impl/realm_coordinator.cpp; sourceTree = "<group>"; };
+		EB1192D650447A0ED6CF4A8DB8C5C9FB /* schema.cpp */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.cpp.cpp; name = schema.cpp; path = Realm/ObjectStore/schema.cpp; sourceTree = "<group>"; };
+		EDA85ABCB3E420CAEAB7C823C712734B /* Alamofire.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; path = Alamofire.xcconfig; sourceTree = "<group>"; };
+		EDCBB647657C2C3D4E631730BD87CBEF /* Realm.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Realm.swift; path = RealmSwift/Realm.swift; sourceTree = "<group>"; };
+		EF2CEACC97C084704B8C47B4AEF30B95 /* Cocoa.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Cocoa.framework; path = Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk/System/Library/Frameworks/Cocoa.framework; sourceTree = DEVELOPER_DIR; };
+		EF3EA0BB050ED9B069BACDB1D1C1C942 /* RLMCollection.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = RLMCollection.h; path = include/RLMCollection.h; sourceTree = "<group>"; };
+		F3B62BC2FEA22E8FB707DF6086ECBC5C /* RLMConstants.m */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.objc; name = RLMConstants.m; path = Realm/RLMConstants.m; sourceTree = "<group>"; };
+		F3F7962FEBB2F90580D5553BD6A8D641 /* GCDAsyncSocket.m */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.objc; name = GCDAsyncSocket.m; path = Source/GCD/GCDAsyncSocket.m; sourceTree = "<group>"; };
+		F657C7C18C4DAAE7E00CD69442E14D56 /* RLMSchema_Private.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = RLMSchema_Private.h; path = include/RLMSchema_Private.h; sourceTree = "<group>"; };
+		F68D5564A432BBC5047C295C945E6D1B /* RLMObservation.mm */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.cpp.objcpp; name = RLMObservation.mm; path = Realm/RLMObservation.mm; sourceTree = "<group>"; };
+		F6AC9E41AF014702EDCB3051D999ED25 /* RLMSwiftSupport.m */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.objc; name = RLMSwiftSupport.m; path = Realm/RLMSwiftSupport.m; sourceTree = "<group>"; };
+		F6D532FCFDBF982524EC2BB95D905B8C /* CoreServices.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = CoreServices.framework; path = Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk/System/Library/Frameworks/CoreServices.framework; sourceTree = DEVELOPER_DIR; };
+		FCFF3DCB53CDB598EAC5ABE9AF1F2393 /* RLMUtil.mm */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.cpp.objcpp; name = RLMUtil.mm; path = Realm/RLMUtil.mm; sourceTree = "<group>"; };
+		FF1CFFC779096B143668A58B2DBDCB71 /* SWXMLHash.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; path = SWXMLHash.xcconfig; sourceTree = "<group>"; };
 /* End PBXFileReference section */
 
 /* Begin PBXFrameworksBuildPhase section */
-		057374DBF94AB4C711C95D3C81644697 /* Frameworks */ = {
+		35A18F92B1DC81FA5EA9FC8939282B1E /* Frameworks */ = {
 			isa = PBXFrameworksBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
-				B93BDD4D746BA45D62DC63CA9E5BF338 /* Cocoa.framework in Frameworks */,
+				A30F2D22FB320D680BD1641405F091BF /* Cocoa.framework in Frameworks */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
-		86631BCDD6995CFD2A8A7716F3673282 /* Frameworks */ = {
+		5FFB924D5E3612B3ED86A3BF1250B1FF /* Frameworks */ = {
 			isa = PBXFrameworksBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
-				F3F3FD9096F43B73CBB52EF0E1CCF73E /* Cocoa.framework in Frameworks */,
+				2B3992908CEEE412C9273EE8C7B6D8EE /* Cocoa.framework in Frameworks */,
+				85084F8B7E7D814B9807B7E5F57BE855 /* Realm.framework in Frameworks */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		7FDF5B60EBBB6E41B5F0558985F5FF3E /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				1FC39133E8B68A14A0F2F2C2AA315136 /* Cocoa.framework in Frameworks */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
-		88126D8EF116B657E2FD26AB2C7D7C76 /* Frameworks */ = {
+		86631BCDD6995CFD2A8A7716F3673282 /* Frameworks */ = {
 			isa = PBXFrameworksBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
-				5CEBE5DA1F9A37F09EE1389B645FD1B4 /* Cocoa.framework in Frameworks */,
+				F3F3FD9096F43B73CBB52EF0E1CCF73E /* Cocoa.framework in Frameworks */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -167,52 +479,94 @@
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
+		F5526DD334E760CEEB7074181CB16D6C /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				3B076C87960E8A67433E76C0CA2273B7 /* Cocoa.framework in Frameworks */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
 /* End PBXFrameworksBuildPhase section */
 
 /* Begin PBXGroup section */
-		01B95DBFE667B00CC6977BD31CE4F3B2 /* Support Files */ = {
+		406F9CB8B321E5C34310C1A65681CEB4 /* Alamofire */ = {
 			isa = PBXGroup;
 			children = (
-				7B57FE540E66A44F3A0381EE3E553552 /* Alamofire.modulemap */,
-				6D0E27C7C865AC6950E934CB59C487B1 /* Alamofire.xcconfig */,
-				5399F7CAF2240783134915CC1CBEF3E5 /* Alamofire-dummy.m */,
-				428FFE99F83C8F7F2E1E0A88D7622693 /* Alamofire-prefix.pch */,
-				588A6F6AFA80EA93ECB5E93B156711EC /* Alamofire-umbrella.h */,
-				72118B3908192BACF6200F55157D9D71 /* Info.plist */,
+				7778BA02000FAE2E38D0B43CB0ADB041 /* Alamofire.swift */,
+				2CC788BB98D1C340FD628F61B02A6A0B /* Download.swift */,
+				DD11F05494F36665158CAA5C69C4CCDC /* Error.swift */,
+				4B1A2836B3567ABD34B44D494734C530 /* Manager.swift */,
+				839748B2274DB324C820B26A9BF56D28 /* MultipartFormData.swift */,
+				670515BB35AFEF410C80DC0D58E5DFD8 /* NetworkReachabilityManager.swift */,
+				5BE358098F08BC289211ED40D3C47E7A /* Notifications.swift */,
+				B0CD6C71319EC54F1FF288131BA5DE47 /* ParameterEncoding.swift */,
+				3E740B8C21AD29F9A3C40D8EFAC837EF /* Request.swift */,
+				6C114501AD56C8B1F8B2932028D038BE /* Response.swift */,
+				BA702A928A3EDB738041CEE543786650 /* ResponseSerialization.swift */,
+				220D2A12585D479CBE8A59A9529EBB36 /* Result.swift */,
+				A2A54645E8AA3FA9CBEA2A759DF82F29 /* ServerTrustPolicy.swift */,
+				12227A36D20361D1BF13D6C8DDA5CD31 /* Stream.swift */,
+				10B67EDC27ECC211EF700D8B9B864881 /* Timeline.swift */,
+				53A5F544C86A60EE30CE30D71CF04329 /* Upload.swift */,
+				1889046CFA08897333E9DC1E4311B3C8 /* Validation.swift */,
+				F1C2C23A35A00E0E0B6A7E08BAAD9864 /* Support Files */,
 			);
-			name = "Support Files";
-			path = "../Target Support Files/Alamofire";
+			path = Alamofire;
 			sourceTree = "<group>";
 		};
-		0D755FC3415F3E7464CA4F3CD0BEF91A /* Pods */ = {
+		453D1BFB01CEC16B25F94E8D06B9098C /* CocoaAsyncSocket */ = {
 			isa = PBXGroup;
 			children = (
-				71982584ECA5E3C8D7B92572F29AA8DA /* Alamofire */,
-				FF778D1838A3F60CF9CF2403E182E955 /* CocoaAsyncSocket */,
-				E7FACF9BF4BA24608BB789AF7D8A102F /* SWXMLHash */,
+				9D75BD5C7AA7BE49C231B74207CDA654 /* GCD */,
+				7D496B3AE9679F1B9474E6388FFF326C /* Support Files */,
 			);
-			name = Pods;
+			path = CocoaAsyncSocket;
 			sourceTree = "<group>";
 		};
-		125C76EFFE45A468598601061FFD20C1 /* OS X */ = {
+		48C40F8232A3A02010CC2022397A6E79 /* Frameworks */ = {
 			isa = PBXGroup;
 			children = (
-				7C56649C408E00F4469558EBC9AF1BA3 /* Cocoa.framework */,
-				8028EBFA77CCF460ADEBC79B87525C3D /* CoreServices.framework */,
-				E35F27DD11D07BB27A6C8CE52CD34061 /* Security.framework */,
+				93C15EEA27225C32D5CD86F6795C07FD /* Realm.framework */,
+				DC10F2559A5B486440F522314D9BBF75 /* OS X */,
 			);
-			name = "OS X";
+			name = Frameworks;
 			sourceTree = "<group>";
 		};
-		6B7D6DAD89010B625FD7D6631AB356FF /* Products */ = {
+		558E462257E713EEC76CD502D42A662F /* Support Files */ = {
 			isa = PBXGroup;
 			children = (
-				8D365AF8CA284382154A3FCADC2924CC /* Alamofire.framework */,
-				7911AB14649A75D2129B7AF99D9F284F /* CocoaAsyncSocket.framework */,
-				26831C2816B1A793F64FFC713F267BB3 /* Pods_CRMCall092016.framework */,
-				C608DAD3E8D1E316C917482D1150C9E4 /* SWXMLHash.framework */,
+				406B82824C096749C85CFC8F9A440C42 /* Info.plist */,
+				D35CBC6F3793C679EA6A7642369CB558 /* Realm.modulemap */,
+				343C51283A351FEFF824D6C9A0F89466 /* Realm.xcconfig */,
+				23E05212AFC1DB33676543D337320846 /* Realm-dummy.m */,
+				4AA00B0A44C7085915719349ABB3AB96 /* Realm-prefix.pch */,
 			);
-			name = Products;
+			name = "Support Files";
+			path = "../Target Support Files/Realm";
+			sourceTree = "<group>";
+		};
+		5B30533922B284E691572896B1ED27AB /* Headers */ = {
+			isa = PBXGroup;
+			children = (
+				B1049E8532A11B579AFE58F91D5DDF4A /* Realm.h */,
+				08F91D1BF9071E5ADD08774AE07E8753 /* RLMArray.h */,
+				EF3EA0BB050ED9B069BACDB1D1C1C942 /* RLMCollection.h */,
+				05DE259AF15D0F93D3AFD57A59A9495C /* RLMConstants.h */,
+				9E18D43D3F5726FA53402C61C9042E7F /* RLMMigration.h */,
+				13C423859E6ECC22EF81163F7C76147B /* RLMObject.h */,
+				70D1FEC58F5689359AEBD4A4A39ABD0B /* RLMObjectBase.h */,
+				993917E3199A0385691960033C7BEE0F /* RLMObjectBase_Dynamic.h */,
+				0FBA0BF8AE6FB43DD83D8701888C4B27 /* RLMObjectSchema.h */,
+				A6A11EDB1E620C3C59416592096A83F4 /* RLMPlatform.h */,
+				C385F154EFA2280EE2B25A9C8927532E /* RLMProperty.h */,
+				72911E861245A78B7F5F53946D9CFD39 /* RLMRealm.h */,
+				B50B323F3ACD65ABC1846D0E12764768 /* RLMRealm_Dynamic.h */,
+				2C921E459B087BFEF2796F7087F78F9C /* RLMRealmConfiguration.h */,
+				19649A3C1F0830CF06B570A783620A8C /* RLMResults.h */,
+				759A40E09C374D9FAC2A32B6E6B51BEE /* RLMSchema.h */,
+			);
+			name = Headers;
 			sourceTree = "<group>";
 		};
 		6BAE03FB7B81BD8D4DD2F62159D790F2 /* Targets Support Files */ = {
@@ -223,75 +577,181 @@
 			name = "Targets Support Files";
 			sourceTree = "<group>";
 		};
-		71982584ECA5E3C8D7B92572F29AA8DA /* Alamofire */ = {
+		7967B6732F3CF4400D836B1C98C7894F /* Products */ = {
 			isa = PBXGroup;
 			children = (
-				E01E26D8749A98484E8DD7726148EC20 /* Alamofire.swift */,
-				2AA16A476F2771B1B74FB14947F24E02 /* Download.swift */,
-				EF9B2AFCE03477C50F07C48E33A463FF /* Error.swift */,
-				7031D4000017108DC80504B065340368 /* Manager.swift */,
-				AF650B57C6596DA153F5900EA61CC5A7 /* MultipartFormData.swift */,
-				64E8485F5FCFC4FDB8D6CE0BFC980C58 /* NetworkReachabilityManager.swift */,
-				ECD84F348832D77D5059D066749346A4 /* Notifications.swift */,
-				125D17DF5E6A1A7420D1F1A975DD7EB9 /* ParameterEncoding.swift */,
-				F14E627DC549703B46315BBCCDD362AE /* Request.swift */,
-				DDE49D9DCF93A390B23188C67221ECA8 /* Response.swift */,
-				B7C925E8849659F01450961BB1FFA23D /* ResponseSerialization.swift */,
-				E2A2BD6EE0720A5171EF80B09CFD4224 /* Result.swift */,
-				62073F3761055A46F154B11F061A08AF /* ServerTrustPolicy.swift */,
-				5B2BB4979BAD0CF7156F74E71CAD3041 /* Stream.swift */,
-				D77E19C3839748928122D0DEAC1BA1F4 /* Timeline.swift */,
-				8991BF3DBE2A9AD6CB35BF27297CC8FD /* Upload.swift */,
-				84395B1E623BD8F9DE2F7E16CA43251F /* Validation.swift */,
-				01B95DBFE667B00CC6977BD31CE4F3B2 /* Support Files */,
+				E07ADF045C902C4670716DA2B348504E /* Alamofire.framework */,
+				02D15662DC3CCD413D5966DE91A723AD /* CocoaAsyncSocket.framework */,
+				AF62ADCFE9F1C89C7A1130868151C4A6 /* Pods_CRMCall092016.framework */,
+				57A535882F71C09BBB596024C41B85D6 /* Realm.framework */,
+				19BD404ABC703393738F3281762396B9 /* RealmSwift.framework */,
+				82BE7BD553333FB342905741BD1287AB /* SWXMLHash.framework */,
 			);
-			path = Alamofire;
+			name = Products;
+			sourceTree = "<group>";
+		};
+		7D496B3AE9679F1B9474E6388FFF326C /* Support Files */ = {
+			isa = PBXGroup;
+			children = (
+				E2C94AAF5D146D3A82104EFD186BC1D5 /* CocoaAsyncSocket.modulemap */,
+				8500DBF281DABBC85C75A40EDF5B1A9D /* CocoaAsyncSocket.xcconfig */,
+				0B953CC83AF3FC4665156118600B55E0 /* CocoaAsyncSocket-dummy.m */,
+				C13BD87EFD0BE9D46ED6430E37CE0373 /* CocoaAsyncSocket-prefix.pch */,
+				C7CCB31E8DBDC7F1C378BE78D0B906AF /* CocoaAsyncSocket-umbrella.h */,
+				3A6026079EF2B73B70549DEB46908083 /* Info.plist */,
+			);
+			name = "Support Files";
+			path = "../Target Support Files/CocoaAsyncSocket";
 			sourceTree = "<group>";
 		};
 		7DB346D0F39D3F0E887471402A8071AB = {
 			isa = PBXGroup;
 			children = (
 				93A4A3777CF96A4AAC1D13BA6DCCEA73 /* Podfile */,
-				96D996393384F21972E2DD81788EE22C /* Frameworks */,
-				0D755FC3415F3E7464CA4F3CD0BEF91A /* Pods */,
-				6B7D6DAD89010B625FD7D6631AB356FF /* Products */,
+				48C40F8232A3A02010CC2022397A6E79 /* Frameworks */,
+				B2483CAD037CB0E8C78109791A325FF3 /* Pods */,
+				7967B6732F3CF4400D836B1C98C7894F /* Products */,
 				6BAE03FB7B81BD8D4DD2F62159D790F2 /* Targets Support Files */,
 			);
 			sourceTree = "<group>";
 		};
-		93A0D837347BC14B6101239D93030AC4 /* Support Files */ = {
+		87A28EF3EE3DC936C0A3623C1665E144 /* Support Files */ = {
 			isa = PBXGroup;
 			children = (
-				E0D2633544BCFC90D4DD429B2FE884D7 /* CocoaAsyncSocket.modulemap */,
-				421DBE2696953979E49FD7BBE38C3847 /* CocoaAsyncSocket.xcconfig */,
-				ABC09E1DCC49261B7629CD82626C21FA /* CocoaAsyncSocket-dummy.m */,
-				0E50EC0B768D99DF8AA54CEF00DCD620 /* CocoaAsyncSocket-prefix.pch */,
-				5F955B5F2D78E83D6BA538909B360F55 /* CocoaAsyncSocket-umbrella.h */,
-				875107E5B1CD30A24F90CC34B1452862 /* Info.plist */,
+				000A75DAC6C2B739CD57D66C0B1F02B0 /* Info.plist */,
+				CD23BAABFCE35DD804DAC4C92A8D46BB /* SWXMLHash.modulemap */,
+				FF1CFFC779096B143668A58B2DBDCB71 /* SWXMLHash.xcconfig */,
+				07B73ED369CA7C9866B2931685C7BA34 /* SWXMLHash-dummy.m */,
+				6966A95E558E0201A53049B6BB5CD2AE /* SWXMLHash-prefix.pch */,
+				4B67F67797D5E226E724CA1C1B188F6C /* SWXMLHash-umbrella.h */,
 			);
 			name = "Support Files";
-			path = "../Target Support Files/CocoaAsyncSocket";
+			path = "../Target Support Files/SWXMLHash";
 			sourceTree = "<group>";
 		};
-		96D996393384F21972E2DD81788EE22C /* Frameworks */ = {
+		87DCD4EC610525DF57A0E8F107884E73 /* SWXMLHash */ = {
 			isa = PBXGroup;
 			children = (
-				125C76EFFE45A468598601061FFD20C1 /* OS X */,
+				019A7F44D041DF1FB3DA36096BBDA87D /* SWXMLHash.swift */,
+				4FCD5E9B89170963F9CB31AE398392B4 /* SWXMLHash+TypeConversion.swift */,
+				87A28EF3EE3DC936C0A3623C1665E144 /* Support Files */,
 			);
-			name = Frameworks;
+			path = SWXMLHash;
 			sourceTree = "<group>";
 		};
-		B4AEF557D0B20590FFF106A8AB52A7AE /* GCD */ = {
+		915B6F65F1AC905723EFB8C9BAFF3022 /* Realm */ = {
 			isa = PBXGroup;
 			children = (
-				D1519185135D5351111F109E89AF0F64 /* GCDAsyncSocket.h */,
-				FB4019B4F3DF5D7B015227F280ABBE9C /* GCDAsyncSocket.m */,
-				540A59953BD2C3205CF5F2CE7B7BFC1F /* GCDAsyncUdpSocket.h */,
-				ED466E93414A976222AFAF321E9AF11C /* GCDAsyncUdpSocket.m */,
+				654F9073F4DB3BDB257921EE989FAA72 /* collection_change_builder.cpp */,
+				1AF6E060C7054FE55A838D6B0E0E4BD4 /* collection_notifications.cpp */,
+				2A0BD6C6A1D8C4DF507292BAFE01A9AF /* collection_notifier.cpp */,
+				73C8592090433CE8AEA5378567BA7813 /* external_commit_helper.cpp */,
+				6FD434DFF34C1B81255CAB7549272388 /* format.cpp */,
+				2BF418666618F7F4C8707584A96D3E15 /* index_set.cpp */,
+				2A480B78E743AB3E12252457C8FC4737 /* list.cpp */,
+				D1BF227B3F2547B149856D4C11A094ED /* list_notifier.cpp */,
+				27BD7C3F641985460BFF98B452F1C55C /* object_schema.cpp */,
+				BB4070B3352326986D9FE05A940801B5 /* object_store.cpp */,
+				E7CAF6E8B1C938AF00BC311BB3EF2BF2 /* realm_coordinator.cpp */,
+				6A91D67A5AAF3BC2E182DC333649D89D /* results.cpp */,
+				3A6C08B4B95C6657BEA86714D5D87BF0 /* results_notifier.cpp */,
+				A3920BF9AAF7A76983FA8FEBE4DD34A9 /* RLMAccessor.h */,
+				BABC0F59B38A48FA1B1487176D304E57 /* RLMAccessor.mm */,
+				6EAF315EE8B882259BBB61D457ECDE6B /* RLMAnalytics.mm */,
+				86C1D7A6A276CDE0E92E766763E7CC2A /* RLMArray.mm */,
+				603EE85140A9845165857F384CD8FDBE /* RLMArray_Private.h */,
+				DF943DEC83B84B5E6F096C7725F9893F /* RLMArrayLinkView.mm */,
+				097CF3C9C7046A002A271EAC0EE74AFF /* RLMCollection.mm */,
+				F3B62BC2FEA22E8FB707DF6086ECBC5C /* RLMConstants.m */,
+				8AB91E74D4B7B8C9746AC13E026868E5 /* RLMListBase.h */,
+				3DCB0C38EB20D53EA34F4E4A62FBE439 /* RLMListBase.mm */,
+				0EDB157896F85AE259E754C00D3636F7 /* RLMMigration.mm */,
+				6A48695E5A9BBEF17C74EFA848CB156C /* RLMMigration_Private.h */,
+				71DC7F67FDD0BF9050DFBDC4E8602EA2 /* RLMObject.mm */,
+				306A2A8FAF7D486D1274450278867E99 /* RLMObject_Private.h */,
+				BAD6352939A2ADFEC3172F4290CCC0C7 /* RLMObjectBase.mm */,
+				3D0184AC2929C1EA7FF747E2E43349EE /* RLMObjectSchema.mm */,
+				39EC2928C1CCBC39A921620DDFD96D82 /* RLMObjectSchema_Private.h */,
+				A1DA88D1D060CF47706351C7EA1F1AAA /* RLMObjectStore.h */,
+				047DA1C7BF6AB4963466B0445E95F1E4 /* RLMObjectStore.mm */,
+				F68D5564A432BBC5047C295C945E6D1B /* RLMObservation.mm */,
+				91B7D6B5E8A8B097A92B157F9338B850 /* RLMOptionalBase.h */,
+				092AFAD3D3E246E82EABB3AEE25F0185 /* RLMOptionalBase.mm */,
+				721951E8312A8726BE2F5FF553509299 /* RLMPredicateUtil.mm */,
+				4BFC9AD553210CB43B52F794D50FB617 /* RLMProperty.mm */,
+				DCEFB5DFE4D76193F6FD235B405F46FA /* RLMProperty_Private.h */,
+				38738ED527609FB98672FBC7A6CA4F90 /* RLMQueryUtil.mm */,
+				0EBC7B2E2E5C37142DAF64C0B9B667F3 /* RLMRealm.mm */,
+				504CC989D430FE0713751F279FBED3F7 /* RLMRealm_Private.h */,
+				83D17D99218E43E698EFBBEA8F1E16C1 /* RLMRealmConfiguration.mm */,
+				3067C49420C8EE5231BC380EC5423C3B /* RLMRealmConfiguration_Private.h */,
+				8FE2AF3F2938FAD0998D1855D5B63896 /* RLMRealmUtil.mm */,
+				E20874320351EC32784CC1743B614A6B /* RLMResults.mm */,
+				A27E57EF66172A47F951A951279641EB /* RLMResults_Private.h */,
+				DE4DAE53005DB209CAC0601F2A3872FE /* RLMSchema.mm */,
+				F657C7C18C4DAAE7E00CD69442E14D56 /* RLMSchema_Private.h */,
+				F6AC9E41AF014702EDCB3051D999ED25 /* RLMSwiftSupport.m */,
+				2BCEF6A165FEA12AA3EA4EABBA761CF9 /* RLMUpdateChecker.mm */,
+				FCFF3DCB53CDB598EAC5ABE9AF1F2393 /* RLMUtil.mm */,
+				EB1192D650447A0ED6CF4A8DB8C5C9FB /* schema.cpp */,
+				4031E673462ED1173C604881D275DD67 /* shared_realm.cpp */,
+				548C4A5E8A66BE8922AEFC3C49C1834B /* transact_log_handler.cpp */,
+				2AC63EBBC84F7B64AF720C29432FAD33 /* weak_realm_notifier.cpp */,
+				F8FA16BE373744F2D84267571B835FE0 /* Frameworks */,
+				5B30533922B284E691572896B1ED27AB /* Headers */,
+				558E462257E713EEC76CD502D42A662F /* Support Files */,
+			);
+			path = Realm;
+			sourceTree = "<group>";
+		};
+		9D75BD5C7AA7BE49C231B74207CDA654 /* GCD */ = {
+			isa = PBXGroup;
+			children = (
+				6DD9AC2FAD4B64F2D7CC258B71DF2BE1 /* GCDAsyncSocket.h */,
+				F3F7962FEBB2F90580D5553BD6A8D641 /* GCDAsyncSocket.m */,
+				3413716D28F08C9D32BACE01C76E0A6A /* GCDAsyncUdpSocket.h */,
+				6C1D88914E0D7701C5B3AF31B2FD66E6 /* GCDAsyncUdpSocket.m */,
 			);
 			name = GCD;
 			sourceTree = "<group>";
 		};
+		A54806877F8209D2452FD4F6221FC9BE /* RealmSwift */ = {
+			isa = PBXGroup;
+			children = (
+				97A0A04C613BA427FF38246D61BC8845 /* Aliases.swift */,
+				ACFB0B2BC281EBF4FB0F22B8EDE34F3F /* Error.swift */,
+				963BC61544C6EDCE6A1B2913BCEF4BC4 /* LinkingObjects.swift */,
+				13BC77519ED297D8940D08A13E00DD95 /* List.swift */,
+				7C7C032A575AE7ECF05272A7332C6DFB /* Migration.swift */,
+				22571F84B1419EDA2016665A62A59965 /* Object.swift */,
+				C63CABFAC66CBD384E95B91088CD77AE /* ObjectSchema.swift */,
+				02ABDDFF322E9C8072C47A29C4AE9853 /* Optional.swift */,
+				DDFAA49E7969E902A28EFCDEAA5D8677 /* Property.swift */,
+				EDCBB647657C2C3D4E631730BD87CBEF /* Realm.swift */,
+				CA2A600578525EC4D358FA4D4D368028 /* RealmCollectionType.swift */,
+				D44B5B200051FA5E221B5CE99DB5E9CB /* RealmConfiguration.swift */,
+				4D0F76250C7636412ECE540398378BA9 /* Results.swift */,
+				43BBB01E7B94E0969186C664FC16998C /* Schema.swift */,
+				4153ADCADFA2E29B38AAF7DA58B24B9C /* SortDescriptor.swift */,
+				710E8D676393E8E638B681FFE1148A77 /* SwiftVersion.swift */,
+				E76DA58891B2795226080060927F9B4C /* Util.swift */,
+				F868971A469D8A938E0A904DDD755356 /* Support Files */,
+			);
+			path = RealmSwift;
+			sourceTree = "<group>";
+		};
+		B2483CAD037CB0E8C78109791A325FF3 /* Pods */ = {
+			isa = PBXGroup;
+			children = (
+				406F9CB8B321E5C34310C1A65681CEB4 /* Alamofire */,
+				453D1BFB01CEC16B25F94E8D06B9098C /* CocoaAsyncSocket */,
+				915B6F65F1AC905723EFB8C9BAFF3022 /* Realm */,
+				A54806877F8209D2452FD4F6221FC9BE /* RealmSwift */,
+				87DCD4EC610525DF57A0E8F107884E73 /* SWXMLHash */,
+			);
+			name = Pods;
+			sourceTree = "<group>";
+		};
 		B8A9724351936E298AF17D9B38E4AA57 /* Pods-CRMCall092016 */ = {
 			isa = PBXGroup;
 			children = (
@@ -310,57 +770,86 @@
 			path = "Target Support Files/Pods-CRMCall092016";
 			sourceTree = "<group>";
 		};
-		DE3FD61F7CCDAC4566744964D80318A9 /* Support Files */ = {
+		DC10F2559A5B486440F522314D9BBF75 /* OS X */ = {
+			isa = PBXGroup;
+			children = (
+				EF2CEACC97C084704B8C47B4AEF30B95 /* Cocoa.framework */,
+				F6D532FCFDBF982524EC2BB95D905B8C /* CoreServices.framework */,
+				379FAEE80725487D7F3C6891939A7D54 /* Security.framework */,
+			);
+			name = "OS X";
+			sourceTree = "<group>";
+		};
+		F1C2C23A35A00E0E0B6A7E08BAAD9864 /* Support Files */ = {
 			isa = PBXGroup;
 			children = (
-				C3D72D35EB73312A9630B6441B6D65DC /* Info.plist */,
-				BC6E9E2C5DCCD36683912082D39D119C /* SWXMLHash.modulemap */,
-				3E8CB71BFFC59E2E3BA715D7AEF30B56 /* SWXMLHash.xcconfig */,
-				2BDE952759498BFF23C89A0302BD584C /* SWXMLHash-dummy.m */,
-				530C70E607990B234619FFA25EF6C451 /* SWXMLHash-prefix.pch */,
-				5F0B453266F2DE0B098E2B994FE716CD /* SWXMLHash-umbrella.h */,
+				50FBB3642BCCABB18EA03B909A831827 /* Alamofire.modulemap */,
+				EDA85ABCB3E420CAEAB7C823C712734B /* Alamofire.xcconfig */,
+				73D908D2560A5E5403334F19E54ECA5E /* Alamofire-dummy.m */,
+				7A6FA0877A6C34660B6749EABACD4143 /* Alamofire-prefix.pch */,
+				1EB2363B0AC4B0F124BCCB2692BC97C0 /* Alamofire-umbrella.h */,
+				890EB3A0E1F5BB93320BDE2404719B64 /* Info.plist */,
 			);
 			name = "Support Files";
-			path = "../Target Support Files/SWXMLHash";
+			path = "../Target Support Files/Alamofire";
 			sourceTree = "<group>";
 		};
-		E7FACF9BF4BA24608BB789AF7D8A102F /* SWXMLHash */ = {
+		F868971A469D8A938E0A904DDD755356 /* Support Files */ = {
 			isa = PBXGroup;
 			children = (
-				7201E46C9812098E184043C076154118 /* SWXMLHash.swift */,
-				CE89954F8A8211757E95D5E68308F52F /* SWXMLHash+TypeConversion.swift */,
-				DE3FD61F7CCDAC4566744964D80318A9 /* Support Files */,
+				8CC308D8DF686F792BAE73FC47E930D4 /* Info.plist */,
+				C4B1167C159C1C277164C1CD2AE12196 /* RealmSwift.modulemap */,
+				62578698CCBAC958046DC385BEF20D2F /* RealmSwift.xcconfig */,
+				C231809D6172C447734FABEDB09AD9FE /* RealmSwift-dummy.m */,
+				C7F86DCD7EEB622090BF3C05875A07C3 /* RealmSwift-prefix.pch */,
+				9F42B3D2E5CBDF7867A8A2DB4F9E99BD /* RealmSwift-umbrella.h */,
 			);
-			path = SWXMLHash;
+			name = "Support Files";
+			path = "../Target Support Files/RealmSwift";
 			sourceTree = "<group>";
 		};
-		FF778D1838A3F60CF9CF2403E182E955 /* CocoaAsyncSocket */ = {
+		F8FA16BE373744F2D84267571B835FE0 /* Frameworks */ = {
 			isa = PBXGroup;
 			children = (
-				B4AEF557D0B20590FFF106A8AB52A7AE /* GCD */,
-				93A0D837347BC14B6101239D93030AC4 /* Support Files */,
+				BF370B72BAFFAC185AAF8B5F858617F6 /* librealm-macosx.a */,
 			);
-			path = CocoaAsyncSocket;
+			name = Frameworks;
 			sourceTree = "<group>";
 		};
 /* End PBXGroup section */
 
 /* Begin PBXHeadersBuildPhase section */
-		41F6279547BA8C6095CA882FB1059614 /* Headers */ = {
+		245EA919DF39A4E91060EB55CE816167 /* Headers */ = {
 			isa = PBXHeadersBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
-				ACFE60AB34A7FEF697E6EEFB62436A8D /* CocoaAsyncSocket-umbrella.h in Headers */,
-				6AAFA2F344A6B58F728AF958F3FE6D89 /* GCDAsyncSocket.h in Headers */,
-				92AED971B91C640191A5ABA1567FE358 /* GCDAsyncUdpSocket.h in Headers */,
+				BF5C95AC86C243B197111E3767053EF8 /* Pods-CRMCall092016-umbrella.h in Headers */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		2C52EF2B424B1730D5F7D212C751D067 /* Headers */ = {
+			isa = PBXHeadersBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				FA57743E73DCBE1A1E63E3A96D2599EA /* SWXMLHash-umbrella.h in Headers */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		373D0D8E5FCCE9C3A2A63A8251EE4AFC /* Headers */ = {
+			isa = PBXHeadersBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				01C9290916D2BF94E65D61E762062511 /* RealmSwift-umbrella.h in Headers */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
-		97EF195315ED04EDCCAC31D70A583B2E /* Headers */ = {
+		41F6279547BA8C6095CA882FB1059614 /* Headers */ = {
 			isa = PBXHeadersBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
-				1E5602BF3A87A7353DA77A2EE51EED93 /* SWXMLHash-umbrella.h in Headers */,
+				ACFE60AB34A7FEF697E6EEFB62436A8D /* CocoaAsyncSocket-umbrella.h in Headers */,
+				6AAFA2F344A6B58F728AF958F3FE6D89 /* GCDAsyncSocket.h in Headers */,
+				92AED971B91C640191A5ABA1567FE358 /* GCDAsyncUdpSocket.h in Headers */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -372,52 +861,80 @@
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
-		FA82F97F3394B160E11E80A19D26FB84 /* Headers */ = {
+		F9BC988B7C25F84F6F4A35CD097F9920 /* Headers */ = {
 			isa = PBXHeadersBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
-				A2BFC3BB72F0CAF82F3CEF224DE6752D /* Pods-CRMCall092016-umbrella.h in Headers */,
+				134290289BEE62256C3E6CEEB2ED72BF /* Realm.h in Headers */,
+				B0E68C1208E2EDA7077E0E280B662032 /* RLMAccessor.h in Headers */,
+				4C0637B12574F5D1EB1F68E2F061E161 /* RLMArray.h in Headers */,
+				C3ACC08F286DD02F5E1D432B37770EB7 /* RLMArray_Private.h in Headers */,
+				8479807F7974205B3D692E79AD0CCAA6 /* RLMCollection.h in Headers */,
+				8F560AF2BE8DCFA8613D1975DB75A13A /* RLMConstants.h in Headers */,
+				AFFD2D35CE366A9751FA01AEC1318E94 /* RLMListBase.h in Headers */,
+				18718707EFB4C8F78980EC2DC2A67CBB /* RLMMigration.h in Headers */,
+				8612106CD85D4711E58535EF91BF622E /* RLMMigration_Private.h in Headers */,
+				0B7E94EC25F925306BBCB3586134367E /* RLMObject.h in Headers */,
+				94EEBAF2DF0DE2EC24022E3BC1B089FB /* RLMObject_Private.h in Headers */,
+				98D71EC18029ADBDBEE25635C45E6050 /* RLMObjectBase.h in Headers */,
+				B66E59315C1B9E4D300B8DCE686E59D9 /* RLMObjectBase_Dynamic.h in Headers */,
+				23200FC18EFD73BE2BE05D99847DE59A /* RLMObjectSchema.h in Headers */,
+				8453DBF3BB462903D8BC6E32A8DC96AA /* RLMObjectSchema_Private.h in Headers */,
+				964123E91EEDB5950771E0016B7188DF /* RLMObjectStore.h in Headers */,
+				76A088C8DC1E6B9ECFDEF27BFBE0BE01 /* RLMOptionalBase.h in Headers */,
+				ACBF2B133C9D4B5BCCE6C6EB7AEF4FB7 /* RLMPlatform.h in Headers */,
+				4A78382491949627B30DD86C9E520AD9 /* RLMProperty.h in Headers */,
+				5265ADE0A6269A478DEEA37FBC4B80E0 /* RLMProperty_Private.h in Headers */,
+				546EF4BD6447190C973348CE5851C952 /* RLMRealm.h in Headers */,
+				F33A08097DD3A8517B968D25C568BCC3 /* RLMRealm_Dynamic.h in Headers */,
+				A87AAD2E1E24B08747752546032B64BE /* RLMRealm_Private.h in Headers */,
+				382A6FC3FD572FF3CED84F4171EC2FA8 /* RLMRealmConfiguration.h in Headers */,
+				CA63738F811EC06D63D77F580ADB2768 /* RLMRealmConfiguration_Private.h in Headers */,
+				AA746F6B181CC898D80359146E08F505 /* RLMResults.h in Headers */,
+				9FE77037B1C299EFD4F0BB8F4215D68F /* RLMResults_Private.h in Headers */,
+				6B867F5EE4FD3E4A50A0C37316B51F0D /* RLMSchema.h in Headers */,
+				534A9A7E425A0B4F41A0269093685234 /* RLMSchema_Private.h in Headers */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
 /* End PBXHeadersBuildPhase section */
 
 /* Begin PBXNativeTarget section */
-		67C63D588DA997BFF7D3C999DA7A5A23 /* SWXMLHash */ = {
+		4269EA6DE49C90DEABF2DFAEBF5F6BCE /* Realm */ = {
 			isa = PBXNativeTarget;
-			buildConfigurationList = 659D84DB6B9CFB1996FB238A044A68A1 /* Build configuration list for PBXNativeTarget "SWXMLHash" */;
+			buildConfigurationList = 90FEF63F3CFCD098DFDC84F953A89D53 /* Build configuration list for PBXNativeTarget "Realm" */;
 			buildPhases = (
-				6266862713B40A60E6D5BC64F94F70F7 /* Sources */,
-				057374DBF94AB4C711C95D3C81644697 /* Frameworks */,
-				97EF195315ED04EDCCAC31D70A583B2E /* Headers */,
+				C46775C28515D08BC52BE6CD9B8E076C /* Sources */,
+				F5526DD334E760CEEB7074181CB16D6C /* Frameworks */,
+				F9BC988B7C25F84F6F4A35CD097F9920 /* Headers */,
+				7C26769C65F69DF5348E56019D4D0121 /* Copy . Private Headers */,
+				6F6F741FF6B9A4ED60C9CC191AF707A7 /* Copy . Public Headers */,
 			);
 			buildRules = (
 			);
 			dependencies = (
 			);
-			name = SWXMLHash;
-			productName = SWXMLHash;
-			productReference = C608DAD3E8D1E316C917482D1150C9E4 /* SWXMLHash.framework */;
+			name = Realm;
+			productName = Realm;
+			productReference = 57A535882F71C09BBB596024C41B85D6 /* Realm.framework */;
 			productType = "com.apple.product-type.framework";
 		};
-		6A0818B9C68C8B9F82A2B6E85576006B /* Pods-CRMCall092016 */ = {
+		6ADBAF7183EDDAB0DE8E8BDEA68D46F1 /* RealmSwift */ = {
 			isa = PBXNativeTarget;
-			buildConfigurationList = 238EE128C1BFD4365A9742EBAD4D8641 /* Build configuration list for PBXNativeTarget "Pods-CRMCall092016" */;
+			buildConfigurationList = 2E23E16710BB0FE81623A6495BE3092D /* Build configuration list for PBXNativeTarget "RealmSwift" */;
 			buildPhases = (
-				32B5968CACDE4124ECD593156BE64DF2 /* Sources */,
-				88126D8EF116B657E2FD26AB2C7D7C76 /* Frameworks */,
-				FA82F97F3394B160E11E80A19D26FB84 /* Headers */,
+				7D942779ECE2DB97704E50A4FB559970 /* Sources */,
+				5FFB924D5E3612B3ED86A3BF1250B1FF /* Frameworks */,
+				373D0D8E5FCCE9C3A2A63A8251EE4AFC /* Headers */,
 			);
 			buildRules = (
 			);
 			dependencies = (
-				71045A2931E715998C8E89599499B57E /* PBXTargetDependency */,
-				868B73927BF599C3CA77C6C45D6DD6E1 /* PBXTargetDependency */,
-				0DC5F42F629BD17706FF7A44455C12F4 /* PBXTargetDependency */,
+				E59A87FA5ECF2BFB5156080ECD315D43 /* PBXTargetDependency */,
 			);
-			name = "Pods-CRMCall092016";
-			productName = "Pods-CRMCall092016";
-			productReference = 26831C2816B1A793F64FFC713F267BB3 /* Pods_CRMCall092016.framework */;
+			name = RealmSwift;
+			productName = RealmSwift;
+			productReference = 19BD404ABC703393738F3281762396B9 /* RealmSwift.framework */;
 			productType = "com.apple.product-type.framework";
 		};
 		79C040AFDDCE1BCBF6D8B5EB0B85887F /* Alamofire */ = {
@@ -434,7 +951,24 @@
 			);
 			name = Alamofire;
 			productName = Alamofire;
-			productReference = 8D365AF8CA284382154A3FCADC2924CC /* Alamofire.framework */;
+			productReference = E07ADF045C902C4670716DA2B348504E /* Alamofire.framework */;
+			productType = "com.apple.product-type.framework";
+		};
+		9A1A088A814206B99346C15F88870371 /* SWXMLHash */ = {
+			isa = PBXNativeTarget;
+			buildConfigurationList = AE9D66C1043456792E49A4B07D48F4A8 /* Build configuration list for PBXNativeTarget "SWXMLHash" */;
+			buildPhases = (
+				753F2311162D234DA05177E127B6CAFC /* Sources */,
+				7FDF5B60EBBB6E41B5F0558985F5FF3E /* Frameworks */,
+				2C52EF2B424B1730D5F7D212C751D067 /* Headers */,
+			);
+			buildRules = (
+			);
+			dependencies = (
+			);
+			name = SWXMLHash;
+			productName = SWXMLHash;
+			productReference = 82BE7BD553333FB342905741BD1287AB /* SWXMLHash.framework */;
 			productType = "com.apple.product-type.framework";
 		};
 		B37E19CA872A7535725D1E1946E5C271 /* CocoaAsyncSocket */ = {
@@ -451,7 +985,29 @@
 			);
 			name = CocoaAsyncSocket;
 			productName = CocoaAsyncSocket;
-			productReference = 7911AB14649A75D2129B7AF99D9F284F /* CocoaAsyncSocket.framework */;
+			productReference = 02D15662DC3CCD413D5966DE91A723AD /* CocoaAsyncSocket.framework */;
+			productType = "com.apple.product-type.framework";
+		};
+		D5093CA88C13657E0DD6DE84E1F2C951 /* Pods-CRMCall092016 */ = {
+			isa = PBXNativeTarget;
+			buildConfigurationList = CEDFCCC18F1AFA8BDE68876A3F1A70B6 /* Build configuration list for PBXNativeTarget "Pods-CRMCall092016" */;
+			buildPhases = (
+				4B62467FC826AD1791454853B4EC3778 /* Sources */,
+				35A18F92B1DC81FA5EA9FC8939282B1E /* Frameworks */,
+				245EA919DF39A4E91060EB55CE816167 /* Headers */,
+			);
+			buildRules = (
+			);
+			dependencies = (
+				6AB5147B1BA5F142CA3C3C3EAE2AB785 /* PBXTargetDependency */,
+				BC07B7642BAD315DEDD0D1B044949733 /* PBXTargetDependency */,
+				7708FAC2B2DC3A56248E2860808C5427 /* PBXTargetDependency */,
+				CC44E3FE2A65D35727921023CC11EE17 /* PBXTargetDependency */,
+				11DE0F0FB97A9C93F6FC19C366C1D81E /* PBXTargetDependency */,
+			);
+			name = "Pods-CRMCall092016";
+			productName = "Pods-CRMCall092016";
+			productReference = AF62ADCFE9F1C89C7A1130868151C4A6 /* Pods_CRMCall092016.framework */;
 			productType = "com.apple.product-type.framework";
 		};
 /* End PBXNativeTarget section */
@@ -471,14 +1027,16 @@
 				en,
 			);
 			mainGroup = 7DB346D0F39D3F0E887471402A8071AB;
-			productRefGroup = 6B7D6DAD89010B625FD7D6631AB356FF /* Products */;
+			productRefGroup = 7967B6732F3CF4400D836B1C98C7894F /* Products */;
 			projectDirPath = "";
 			projectRoot = "";
 			targets = (
 				79C040AFDDCE1BCBF6D8B5EB0B85887F /* Alamofire */,
 				B37E19CA872A7535725D1E1946E5C271 /* CocoaAsyncSocket */,
-				6A0818B9C68C8B9F82A2B6E85576006B /* Pods-CRMCall092016 */,
-				67C63D588DA997BFF7D3C999DA7A5A23 /* SWXMLHash */,
+				D5093CA88C13657E0DD6DE84E1F2C951 /* Pods-CRMCall092016 */,
+				4269EA6DE49C90DEABF2DFAEBF5F6BCE /* Realm */,
+				6ADBAF7183EDDAB0DE8E8BDEA68D46F1 /* RealmSwift */,
+				9A1A088A814206B99346C15F88870371 /* SWXMLHash */,
 			);
 		};
 /* End PBXProject section */
@@ -494,21 +1052,46 @@
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
-		32B5968CACDE4124ECD593156BE64DF2 /* Sources */ = {
+		4B62467FC826AD1791454853B4EC3778 /* Sources */ = {
 			isa = PBXSourcesBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
-				515FD66E0570F0E6B6D6F6B4AE427CC2 /* Pods-CRMCall092016-dummy.m in Sources */,
+				408F2A71695E49C72B6E69F72F6CCE36 /* Pods-CRMCall092016-dummy.m in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
-		6266862713B40A60E6D5BC64F94F70F7 /* Sources */ = {
+		753F2311162D234DA05177E127B6CAFC /* Sources */ = {
 			isa = PBXSourcesBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
-				723E6C875E842A6DA996001BDFAF520E /* SWXMLHash+TypeConversion.swift in Sources */,
-				7560CA92AA1E62C1C39BBA309960C36A /* SWXMLHash-dummy.m in Sources */,
-				72504A8A3AD0249F8A37515A72C2DF98 /* SWXMLHash.swift in Sources */,
+				4B6745C20956AC18A47CEAAF92C08E57 /* SWXMLHash+TypeConversion.swift in Sources */,
+				AB80AA280B511D3C9B6E2A9286B00D0A /* SWXMLHash-dummy.m in Sources */,
+				A78C69124BB4894698D1B74063B4FC34 /* SWXMLHash.swift in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		7D942779ECE2DB97704E50A4FB559970 /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				FB78A40B714406817637D40C534C6713 /* Aliases.swift in Sources */,
+				5864975709B7FE2025D430DBE809B29F /* Error.swift in Sources */,
+				EDE7EE4076A8D6B35B018EF6484E8836 /* LinkingObjects.swift in Sources */,
+				287433D3503B6F50768F3F01289DEAA8 /* List.swift in Sources */,
+				31BC73C4AE794BE4D97A2B46F8728F02 /* Migration.swift in Sources */,
+				B0C1F5E26DEFDEC831B86855EED8CD3A /* Object.swift in Sources */,
+				73F64F78AE5F4B9EE6137FA0BA7583CC /* ObjectSchema.swift in Sources */,
+				D97F1EE5F8ED75E5597B706A04888F5C /* Optional.swift in Sources */,
+				DA028A3A24D844BB6303B79384EFDB2A /* Property.swift in Sources */,
+				C032B518D7B1091EAFB62131DE17FFC4 /* Realm.swift in Sources */,
+				D5E1B1E437C8A93FF121C3D59F589D53 /* RealmCollectionType.swift in Sources */,
+				D2A5277BF686845A99C13FB36E2F2707 /* RealmConfiguration.swift in Sources */,
+				194052101382F3A145C81DA3E2D0D29F /* RealmSwift-dummy.m in Sources */,
+				D345036427A2C00DFF2E789E63692167 /* Results.swift in Sources */,
+				5B4F95459073D3BC9AB05C31D06F56A9 /* Schema.swift in Sources */,
+				5B9064296FBD8EA3F90B6AB2E1B5F580 /* SortDescriptor.swift in Sources */,
+				23EEA68F3EBF83EFA81EEDFB04249FCD /* SwiftVersion.swift in Sources */,
+				93A0B7C8CF9835D0E08D253E7A2D429A /* Util.swift in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -537,26 +1120,94 @@
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
+		C46775C28515D08BC52BE6CD9B8E076C /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				17E53ACC2AFFA773DEBA79D04AC24F58 /* collection_change_builder.cpp in Sources */,
+				305701DF6434F6D155D0ED68F70DA4FD /* collection_notifications.cpp in Sources */,
+				8FDF3EC6EB8508A8FF522475AD4D5258 /* collection_notifier.cpp in Sources */,
+				FD219F561DF23E11FBD8591ED3364902 /* external_commit_helper.cpp in Sources */,
+				0388B2389A6E19ABB505118BF5000B88 /* format.cpp in Sources */,
+				6E8D7745A9285374922AE1FBFC46B063 /* index_set.cpp in Sources */,
+				12F531E295FCC0CEB2BFB467774737E0 /* list.cpp in Sources */,
+				BDE1DE9BE8EABD319047EEC06AF32374 /* list_notifier.cpp in Sources */,
+				E7B5CC55D7809667ABA2650CBDCF03AF /* object_schema.cpp in Sources */,
+				C1C5BDADA3AF45B8705AA5181E7711B1 /* object_store.cpp in Sources */,
+				F1E1F04193018B2F037A4786772BE201 /* Realm-dummy.m in Sources */,
+				14C7DFDD75F71FF6E49CC04730292D2F /* realm_coordinator.cpp in Sources */,
+				BA43FD0CA778F3697C690EB97A66917D /* results.cpp in Sources */,
+				25C84942AA159EFB1292D34782A8F355 /* results_notifier.cpp in Sources */,
+				66F5250FFDFF3477A6E6F9058826D67B /* RLMAccessor.mm in Sources */,
+				7F55BED9532AD711C390EDE26E347138 /* RLMAnalytics.mm in Sources */,
+				4391880309D66B4EFE6A78B48B1C4727 /* RLMArray.mm in Sources */,
+				D37A8588F16E220D8B89E9F55DE7F968 /* RLMArrayLinkView.mm in Sources */,
+				053931D45EC4C80CA9DCF5F919120019 /* RLMCollection.mm in Sources */,
+				6E5F9CE6D9BAFA6183B3D3A9AB698BB0 /* RLMConstants.m in Sources */,
+				64AF480BC9EE1907089B3B38C95E63CC /* RLMListBase.mm in Sources */,
+				68510367955CA4AD73A6AF6E230779DE /* RLMMigration.mm in Sources */,
+				E1B7F0E94AB5DD639E7CF983847E647D /* RLMObject.mm in Sources */,
+				B7FD9E07BBADA6155A7D25F51187AA88 /* RLMObjectBase.mm in Sources */,
+				36AB6C9E06467598CC30D6EA37241D52 /* RLMObjectSchema.mm in Sources */,
+				E5BCBAE67F225B8737A7A4183F2090BC /* RLMObjectStore.mm in Sources */,
+				A4C28B730D4613E2C6362850A894C296 /* RLMObservation.mm in Sources */,
+				657E5700E7FD31482F35761CA328D886 /* RLMOptionalBase.mm in Sources */,
+				38B0B068A2F027A036046A5A469ACCF4 /* RLMPredicateUtil.mm in Sources */,
+				F5DB30F530F13061C1814ECADF48B9E0 /* RLMProperty.mm in Sources */,
+				5A6C5E9420C798FDA1764A183A04EF48 /* RLMQueryUtil.mm in Sources */,
+				C17C732B94FA1472BFE1421A5BBA22F8 /* RLMRealm.mm in Sources */,
+				217B27984D97349329F798EF6956E722 /* RLMRealmConfiguration.mm in Sources */,
+				B0486015F69DD26839D206E96B6DB877 /* RLMRealmUtil.mm in Sources */,
+				118DC01176373579D7511ECDC4956060 /* RLMResults.mm in Sources */,
+				2E6C91DE00AD3F2D62C42008533197D4 /* RLMSchema.mm in Sources */,
+				F55C7A6C912F6472B7EC140590B88C7F /* RLMSwiftSupport.m in Sources */,
+				3F7E80E44B8AB2AC9BC0B7B8AB451E62 /* RLMUpdateChecker.mm in Sources */,
+				10FF6E7C34C062AE6FE7E0845560CE5C /* RLMUtil.mm in Sources */,
+				3A932F700B91F43CAE1F531EA7B7EB17 /* schema.cpp in Sources */,
+				1E0D0285F2684B3B8570735C107EADF0 /* shared_realm.cpp in Sources */,
+				37A32603349C7A575815A76C9387D758 /* transact_log_handler.cpp in Sources */,
+				5FEC38C12278DD40237061B2540CD07B /* weak_realm_notifier.cpp in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
 /* End PBXSourcesBuildPhase section */
 
 /* Begin PBXTargetDependency section */
-		0DC5F42F629BD17706FF7A44455C12F4 /* PBXTargetDependency */ = {
+		11DE0F0FB97A9C93F6FC19C366C1D81E /* PBXTargetDependency */ = {
 			isa = PBXTargetDependency;
 			name = SWXMLHash;
-			target = 67C63D588DA997BFF7D3C999DA7A5A23 /* SWXMLHash */;
-			targetProxy = A98B988E365E15D4E2D8C73D59A5F0EE /* PBXContainerItemProxy */;
+			target = 9A1A088A814206B99346C15F88870371 /* SWXMLHash */;
+			targetProxy = 72CE3D53E88A74E49F4B5DAAB1C38BC3 /* PBXContainerItemProxy */;
 		};
-		71045A2931E715998C8E89599499B57E /* PBXTargetDependency */ = {
+		6AB5147B1BA5F142CA3C3C3EAE2AB785 /* PBXTargetDependency */ = {
 			isa = PBXTargetDependency;
 			name = Alamofire;
 			target = 79C040AFDDCE1BCBF6D8B5EB0B85887F /* Alamofire */;
-			targetProxy = 1F41FB1990B1F3A39ADE4AEDF3C3DE3A /* PBXContainerItemProxy */;
+			targetProxy = 1F2C9666E955023D1F090B725E81379B /* PBXContainerItemProxy */;
+		};
+		7708FAC2B2DC3A56248E2860808C5427 /* PBXTargetDependency */ = {
+			isa = PBXTargetDependency;
+			name = Realm;
+			target = 4269EA6DE49C90DEABF2DFAEBF5F6BCE /* Realm */;
+			targetProxy = 3AE0E399596396AF1490D1C1CFB922FD /* PBXContainerItemProxy */;
 		};
-		868B73927BF599C3CA77C6C45D6DD6E1 /* PBXTargetDependency */ = {
+		BC07B7642BAD315DEDD0D1B044949733 /* PBXTargetDependency */ = {
 			isa = PBXTargetDependency;
 			name = CocoaAsyncSocket;
 			target = B37E19CA872A7535725D1E1946E5C271 /* CocoaAsyncSocket */;
-			targetProxy = A6ED361CEE1ECD9230711154275A9274 /* PBXContainerItemProxy */;
+			targetProxy = 96C8A36F7D63CDDE0B5F74F88ED14937 /* PBXContainerItemProxy */;
+		};
+		CC44E3FE2A65D35727921023CC11EE17 /* PBXTargetDependency */ = {
+			isa = PBXTargetDependency;
+			name = RealmSwift;
+			target = 6ADBAF7183EDDAB0DE8E8BDEA68D46F1 /* RealmSwift */;
+			targetProxy = 02D857942B7F5E741C59720A77401E7C /* PBXContainerItemProxy */;
+		};
+		E59A87FA5ECF2BFB5156080ECD315D43 /* PBXTargetDependency */ = {
+			isa = PBXTargetDependency;
+			name = Realm;
+			target = 4269EA6DE49C90DEABF2DFAEBF5F6BCE /* Realm */;
+			targetProxy = 87F8D00088978F8CB43250CE34FDC045 /* PBXContainerItemProxy */;
 		};
 /* End PBXTargetDependency section */
 
@@ -605,7 +1256,7 @@
 		};
 		22E1B933B435A6CDC7F2DDEA5826ADB0 /* Release */ = {
 			isa = XCBuildConfiguration;
-			baseConfigurationReference = 421DBE2696953979E49FD7BBE38C3847 /* CocoaAsyncSocket.xcconfig */;
+			baseConfigurationReference = 8500DBF281DABBC85C75A40EDF5B1A9D /* CocoaAsyncSocket.xcconfig */;
 			buildSettings = {
 				CODE_SIGN_IDENTITY = "-";
 				COMBINE_HIDPI_IMAGES = YES;
@@ -633,6 +1284,72 @@
 			};
 			name = Release;
 		};
+		3F30D0F66C0D0E35BD4ED14E5AA0B834 /* Debug */ = {
+			isa = XCBuildConfiguration;
+			baseConfigurationReference = FF1CFFC779096B143668A58B2DBDCB71 /* SWXMLHash.xcconfig */;
+			buildSettings = {
+				CODE_SIGN_IDENTITY = "-";
+				COMBINE_HIDPI_IMAGES = YES;
+				CURRENT_PROJECT_VERSION = 1;
+				DEBUG_INFORMATION_FORMAT = dwarf;
+				DEFINES_MODULE = YES;
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				DYLIB_INSTALL_NAME_BASE = "@rpath";
+				ENABLE_STRICT_OBJC_MSGSEND = YES;
+				FRAMEWORK_VERSION = A;
+				GCC_NO_COMMON_BLOCKS = YES;
+				GCC_PREFIX_HEADER = "Target Support Files/SWXMLHash/SWXMLHash-prefix.pch";
+				INFOPLIST_FILE = "Target Support Files/SWXMLHash/Info.plist";
+				INSTALL_PATH = "$(LOCAL_LIBRARY_DIR)/Frameworks";
+				LD_RUNPATH_SEARCH_PATHS = "$(inherited) @executable_path/../Frameworks @loader_path/Frameworks";
+				MACOSX_DEPLOYMENT_TARGET = 10.9;
+				MODULEMAP_FILE = "Target Support Files/SWXMLHash/SWXMLHash.modulemap";
+				MTL_ENABLE_DEBUG_INFO = YES;
+				PRODUCT_NAME = SWXMLHash;
+				SDKROOT = macosx;
+				SKIP_INSTALL = YES;
+				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
+				VERSIONING_SYSTEM = "apple-generic";
+				VERSION_INFO_PREFIX = "";
+			};
+			name = Debug;
+		};
+		505167C53E8ACEB374B2DC8EAE7F464A /* Debug */ = {
+			isa = XCBuildConfiguration;
+			baseConfigurationReference = 11566DE119910F4F8728001B55582E0A /* Pods-CRMCall092016.debug.xcconfig */;
+			buildSettings = {
+				CODE_SIGN_IDENTITY = "-";
+				COMBINE_HIDPI_IMAGES = YES;
+				CURRENT_PROJECT_VERSION = 1;
+				DEBUG_INFORMATION_FORMAT = dwarf;
+				DEFINES_MODULE = YES;
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				DYLIB_INSTALL_NAME_BASE = "@rpath";
+				ENABLE_STRICT_OBJC_MSGSEND = YES;
+				FRAMEWORK_VERSION = A;
+				GCC_NO_COMMON_BLOCKS = YES;
+				INFOPLIST_FILE = "Target Support Files/Pods-CRMCall092016/Info.plist";
+				INSTALL_PATH = "$(LOCAL_LIBRARY_DIR)/Frameworks";
+				LD_RUNPATH_SEARCH_PATHS = "$(inherited) @executable_path/../Frameworks @loader_path/Frameworks";
+				MACH_O_TYPE = staticlib;
+				MACOSX_DEPLOYMENT_TARGET = 10.11;
+				MODULEMAP_FILE = "Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016.modulemap";
+				MTL_ENABLE_DEBUG_INFO = YES;
+				OTHER_LDFLAGS = "";
+				OTHER_LIBTOOLFLAGS = "";
+				PODS_ROOT = "$(SRCROOT)";
+				PRODUCT_BUNDLE_IDENTIFIER = "org.cocoapods.${PRODUCT_NAME:rfc1034identifier}";
+				PRODUCT_NAME = Pods_CRMCall092016;
+				SDKROOT = macosx;
+				SKIP_INSTALL = YES;
+				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
+				VERSIONING_SYSTEM = "apple-generic";
+				VERSION_INFO_PREFIX = "";
+			};
+			name = Debug;
+		};
 		578820E498FFD85CA5D93A33D365FBED /* Release */ = {
 			isa = XCBuildConfiguration;
 			buildSettings = {
@@ -671,9 +1388,9 @@
 			};
 			name = Release;
 		};
-		6CE0C113B81940025E3A2FB05117B621 /* Release */ = {
+		5BE814104826BBFA03706516475BC87B /* Release */ = {
 			isa = XCBuildConfiguration;
-			baseConfigurationReference = 3E8CB71BFFC59E2E3BA715D7AEF30B56 /* SWXMLHash.xcconfig */;
+			baseConfigurationReference = 3344C80F9295CA22275F8A0581FF4EAB /* Pods-CRMCall092016.release.xcconfig */;
 			buildSettings = {
 				CODE_SIGN_IDENTITY = "-";
 				COMBINE_HIDPI_IMAGES = YES;
@@ -686,14 +1403,18 @@
 				ENABLE_STRICT_OBJC_MSGSEND = YES;
 				FRAMEWORK_VERSION = A;
 				GCC_NO_COMMON_BLOCKS = YES;
-				GCC_PREFIX_HEADER = "Target Support Files/SWXMLHash/SWXMLHash-prefix.pch";
-				INFOPLIST_FILE = "Target Support Files/SWXMLHash/Info.plist";
+				INFOPLIST_FILE = "Target Support Files/Pods-CRMCall092016/Info.plist";
 				INSTALL_PATH = "$(LOCAL_LIBRARY_DIR)/Frameworks";
 				LD_RUNPATH_SEARCH_PATHS = "$(inherited) @executable_path/../Frameworks @loader_path/Frameworks";
-				MACOSX_DEPLOYMENT_TARGET = 10.9;
-				MODULEMAP_FILE = "Target Support Files/SWXMLHash/SWXMLHash.modulemap";
+				MACH_O_TYPE = staticlib;
+				MACOSX_DEPLOYMENT_TARGET = 10.11;
+				MODULEMAP_FILE = "Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016.modulemap";
 				MTL_ENABLE_DEBUG_INFO = NO;
-				PRODUCT_NAME = SWXMLHash;
+				OTHER_LDFLAGS = "";
+				OTHER_LIBTOOLFLAGS = "";
+				PODS_ROOT = "$(SRCROOT)";
+				PRODUCT_BUNDLE_IDENTIFIER = "org.cocoapods.${PRODUCT_NAME:rfc1034identifier}";
+				PRODUCT_NAME = Pods_CRMCall092016;
 				SDKROOT = macosx;
 				SKIP_INSTALL = YES;
 				VERSIONING_SYSTEM = "apple-generic";
@@ -701,9 +1422,39 @@
 			};
 			name = Release;
 		};
+		5CFF49C4E23737EF4C8594C894B85777 /* Debug */ = {
+			isa = XCBuildConfiguration;
+			baseConfigurationReference = 343C51283A351FEFF824D6C9A0F89466 /* Realm.xcconfig */;
+			buildSettings = {
+				CODE_SIGN_IDENTITY = "-";
+				COMBINE_HIDPI_IMAGES = YES;
+				CURRENT_PROJECT_VERSION = 1;
+				DEBUG_INFORMATION_FORMAT = dwarf;
+				DEFINES_MODULE = YES;
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				DYLIB_INSTALL_NAME_BASE = "@rpath";
+				ENABLE_STRICT_OBJC_MSGSEND = YES;
+				FRAMEWORK_VERSION = A;
+				GCC_NO_COMMON_BLOCKS = YES;
+				GCC_PREFIX_HEADER = "Target Support Files/Realm/Realm-prefix.pch";
+				INFOPLIST_FILE = "Target Support Files/Realm/Info.plist";
+				INSTALL_PATH = "$(LOCAL_LIBRARY_DIR)/Frameworks";
+				LD_RUNPATH_SEARCH_PATHS = "$(inherited) @executable_path/../Frameworks @loader_path/Frameworks";
+				MACOSX_DEPLOYMENT_TARGET = 10.9;
+				MODULEMAP_FILE = "Target Support Files/Realm/Realm.modulemap";
+				MTL_ENABLE_DEBUG_INFO = YES;
+				PRODUCT_NAME = Realm;
+				SDKROOT = macosx;
+				SKIP_INSTALL = YES;
+				VERSIONING_SYSTEM = "apple-generic";
+				VERSION_INFO_PREFIX = "";
+			};
+			name = Debug;
+		};
 		81B3096945D568104AC14EE4F805950B /* Release */ = {
 			isa = XCBuildConfiguration;
-			baseConfigurationReference = 6D0E27C7C865AC6950E934CB59C487B1 /* Alamofire.xcconfig */;
+			baseConfigurationReference = EDA85ABCB3E420CAEAB7C823C712734B /* Alamofire.xcconfig */;
 			buildSettings = {
 				CODE_SIGN_IDENTITY = "-";
 				COMBINE_HIDPI_IMAGES = YES;
@@ -733,7 +1484,7 @@
 		};
 		82B1EC5E8815E78991717D970C44B8D8 /* Debug */ = {
 			isa = XCBuildConfiguration;
-			baseConfigurationReference = 6D0E27C7C865AC6950E934CB59C487B1 /* Alamofire.xcconfig */;
+			baseConfigurationReference = EDA85ABCB3E420CAEAB7C823C712734B /* Alamofire.xcconfig */;
 			buildSettings = {
 				CODE_SIGN_IDENTITY = "-";
 				COMBINE_HIDPI_IMAGES = YES;
@@ -762,14 +1513,14 @@
 			};
 			name = Debug;
 		};
-		ABD52582A0CA0880395B592CF2D53A8C /* Debug */ = {
+		A0DD187F1B4163F439891FF4169A86F8 /* Release */ = {
 			isa = XCBuildConfiguration;
-			baseConfigurationReference = 11566DE119910F4F8728001B55582E0A /* Pods-CRMCall092016.debug.xcconfig */;
+			baseConfigurationReference = FF1CFFC779096B143668A58B2DBDCB71 /* SWXMLHash.xcconfig */;
 			buildSettings = {
 				CODE_SIGN_IDENTITY = "-";
 				COMBINE_HIDPI_IMAGES = YES;
 				CURRENT_PROJECT_VERSION = 1;
-				DEBUG_INFORMATION_FORMAT = dwarf;
+				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
 				DEFINES_MODULE = YES;
 				DYLIB_COMPATIBILITY_VERSION = 1;
 				DYLIB_CURRENT_VERSION = 1;
@@ -777,29 +1528,24 @@
 				ENABLE_STRICT_OBJC_MSGSEND = YES;
 				FRAMEWORK_VERSION = A;
 				GCC_NO_COMMON_BLOCKS = YES;
-				INFOPLIST_FILE = "Target Support Files/Pods-CRMCall092016/Info.plist";
+				GCC_PREFIX_HEADER = "Target Support Files/SWXMLHash/SWXMLHash-prefix.pch";
+				INFOPLIST_FILE = "Target Support Files/SWXMLHash/Info.plist";
 				INSTALL_PATH = "$(LOCAL_LIBRARY_DIR)/Frameworks";
 				LD_RUNPATH_SEARCH_PATHS = "$(inherited) @executable_path/../Frameworks @loader_path/Frameworks";
-				MACH_O_TYPE = staticlib;
-				MACOSX_DEPLOYMENT_TARGET = 10.11;
-				MODULEMAP_FILE = "Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016.modulemap";
-				MTL_ENABLE_DEBUG_INFO = YES;
-				OTHER_LDFLAGS = "";
-				OTHER_LIBTOOLFLAGS = "";
-				PODS_ROOT = "$(SRCROOT)";
-				PRODUCT_BUNDLE_IDENTIFIER = "org.cocoapods.${PRODUCT_NAME:rfc1034identifier}";
-				PRODUCT_NAME = Pods_CRMCall092016;
+				MACOSX_DEPLOYMENT_TARGET = 10.9;
+				MODULEMAP_FILE = "Target Support Files/SWXMLHash/SWXMLHash.modulemap";
+				MTL_ENABLE_DEBUG_INFO = NO;
+				PRODUCT_NAME = SWXMLHash;
 				SDKROOT = macosx;
 				SKIP_INSTALL = YES;
-				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
 				VERSIONING_SYSTEM = "apple-generic";
 				VERSION_INFO_PREFIX = "";
 			};
-			name = Debug;
+			name = Release;
 		};
 		AC06A033185F3EDFA2433C8F90A0A7F2 /* Debug */ = {
 			isa = XCBuildConfiguration;
-			baseConfigurationReference = 421DBE2696953979E49FD7BBE38C3847 /* CocoaAsyncSocket.xcconfig */;
+			baseConfigurationReference = 8500DBF281DABBC85C75A40EDF5B1A9D /* CocoaAsyncSocket.xcconfig */;
 			buildSettings = {
 				CODE_SIGN_IDENTITY = "-";
 				COMBINE_HIDPI_IMAGES = YES;
@@ -827,14 +1573,14 @@
 			};
 			name = Debug;
 		};
-		AC82647F4C2BE5E8CCF859C6D6F8141E /* Debug */ = {
+		B92B5B733C8EB57F3C77DB2EFC2B81B1 /* Release */ = {
 			isa = XCBuildConfiguration;
-			baseConfigurationReference = 3E8CB71BFFC59E2E3BA715D7AEF30B56 /* SWXMLHash.xcconfig */;
+			baseConfigurationReference = 343C51283A351FEFF824D6C9A0F89466 /* Realm.xcconfig */;
 			buildSettings = {
 				CODE_SIGN_IDENTITY = "-";
 				COMBINE_HIDPI_IMAGES = YES;
 				CURRENT_PROJECT_VERSION = 1;
-				DEBUG_INFORMATION_FORMAT = dwarf;
+				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
 				DEFINES_MODULE = YES;
 				DYLIB_COMPATIBILITY_VERSION = 1;
 				DYLIB_CURRENT_VERSION = 1;
@@ -842,25 +1588,24 @@
 				ENABLE_STRICT_OBJC_MSGSEND = YES;
 				FRAMEWORK_VERSION = A;
 				GCC_NO_COMMON_BLOCKS = YES;
-				GCC_PREFIX_HEADER = "Target Support Files/SWXMLHash/SWXMLHash-prefix.pch";
-				INFOPLIST_FILE = "Target Support Files/SWXMLHash/Info.plist";
+				GCC_PREFIX_HEADER = "Target Support Files/Realm/Realm-prefix.pch";
+				INFOPLIST_FILE = "Target Support Files/Realm/Info.plist";
 				INSTALL_PATH = "$(LOCAL_LIBRARY_DIR)/Frameworks";
 				LD_RUNPATH_SEARCH_PATHS = "$(inherited) @executable_path/../Frameworks @loader_path/Frameworks";
 				MACOSX_DEPLOYMENT_TARGET = 10.9;
-				MODULEMAP_FILE = "Target Support Files/SWXMLHash/SWXMLHash.modulemap";
-				MTL_ENABLE_DEBUG_INFO = YES;
-				PRODUCT_NAME = SWXMLHash;
+				MODULEMAP_FILE = "Target Support Files/Realm/Realm.modulemap";
+				MTL_ENABLE_DEBUG_INFO = NO;
+				PRODUCT_NAME = Realm;
 				SDKROOT = macosx;
 				SKIP_INSTALL = YES;
-				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
 				VERSIONING_SYSTEM = "apple-generic";
 				VERSION_INFO_PREFIX = "";
 			};
-			name = Debug;
+			name = Release;
 		};
-		D1217757FF60B0DDC6ED1BAE3F3421A4 /* Release */ = {
+		C5FD960CB283EA4A31183A5AC5A9ED9A /* Release */ = {
 			isa = XCBuildConfiguration;
-			baseConfigurationReference = 3344C80F9295CA22275F8A0581FF4EAB /* Pods-CRMCall092016.release.xcconfig */;
+			baseConfigurationReference = 62578698CCBAC958046DC385BEF20D2F /* RealmSwift.xcconfig */;
 			buildSettings = {
 				CODE_SIGN_IDENTITY = "-";
 				COMBINE_HIDPI_IMAGES = YES;
@@ -873,18 +1618,14 @@
 				ENABLE_STRICT_OBJC_MSGSEND = YES;
 				FRAMEWORK_VERSION = A;
 				GCC_NO_COMMON_BLOCKS = YES;
-				INFOPLIST_FILE = "Target Support Files/Pods-CRMCall092016/Info.plist";
+				GCC_PREFIX_HEADER = "Target Support Files/RealmSwift/RealmSwift-prefix.pch";
+				INFOPLIST_FILE = "Target Support Files/RealmSwift/Info.plist";
 				INSTALL_PATH = "$(LOCAL_LIBRARY_DIR)/Frameworks";
 				LD_RUNPATH_SEARCH_PATHS = "$(inherited) @executable_path/../Frameworks @loader_path/Frameworks";
-				MACH_O_TYPE = staticlib;
-				MACOSX_DEPLOYMENT_TARGET = 10.11;
-				MODULEMAP_FILE = "Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016.modulemap";
+				MACOSX_DEPLOYMENT_TARGET = 10.9;
+				MODULEMAP_FILE = "Target Support Files/RealmSwift/RealmSwift.modulemap";
 				MTL_ENABLE_DEBUG_INFO = NO;
-				OTHER_LDFLAGS = "";
-				OTHER_LIBTOOLFLAGS = "";
-				PODS_ROOT = "$(SRCROOT)";
-				PRODUCT_BUNDLE_IDENTIFIER = "org.cocoapods.${PRODUCT_NAME:rfc1034identifier}";
-				PRODUCT_NAME = Pods_CRMCall092016;
+				PRODUCT_NAME = RealmSwift;
 				SDKROOT = macosx;
 				SKIP_INSTALL = YES;
 				VERSIONING_SYSTEM = "apple-generic";
@@ -892,23 +1633,54 @@
 			};
 			name = Release;
 		};
+		DC4F0440B8FB7E873E6B1F7966723420 /* Debug */ = {
+			isa = XCBuildConfiguration;
+			baseConfigurationReference = 62578698CCBAC958046DC385BEF20D2F /* RealmSwift.xcconfig */;
+			buildSettings = {
+				CODE_SIGN_IDENTITY = "-";
+				COMBINE_HIDPI_IMAGES = YES;
+				CURRENT_PROJECT_VERSION = 1;
+				DEBUG_INFORMATION_FORMAT = dwarf;
+				DEFINES_MODULE = YES;
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				DYLIB_INSTALL_NAME_BASE = "@rpath";
+				ENABLE_STRICT_OBJC_MSGSEND = YES;
+				FRAMEWORK_VERSION = A;
+				GCC_NO_COMMON_BLOCKS = YES;
+				GCC_PREFIX_HEADER = "Target Support Files/RealmSwift/RealmSwift-prefix.pch";
+				INFOPLIST_FILE = "Target Support Files/RealmSwift/Info.plist";
+				INSTALL_PATH = "$(LOCAL_LIBRARY_DIR)/Frameworks";
+				LD_RUNPATH_SEARCH_PATHS = "$(inherited) @executable_path/../Frameworks @loader_path/Frameworks";
+				MACOSX_DEPLOYMENT_TARGET = 10.9;
+				MODULEMAP_FILE = "Target Support Files/RealmSwift/RealmSwift.modulemap";
+				MTL_ENABLE_DEBUG_INFO = YES;
+				PRODUCT_NAME = RealmSwift;
+				SDKROOT = macosx;
+				SKIP_INSTALL = YES;
+				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
+				VERSIONING_SYSTEM = "apple-generic";
+				VERSION_INFO_PREFIX = "";
+			};
+			name = Debug;
+		};
 /* End XCBuildConfiguration section */
 
 /* Begin XCConfigurationList section */
-		238EE128C1BFD4365A9742EBAD4D8641 /* Build configuration list for PBXNativeTarget "Pods-CRMCall092016" */ = {
+		2D8E8EC45A3A1A1D94AE762CB5028504 /* Build configuration list for PBXProject "Pods" */ = {
 			isa = XCConfigurationList;
 			buildConfigurations = (
-				ABD52582A0CA0880395B592CF2D53A8C /* Debug */,
-				D1217757FF60B0DDC6ED1BAE3F3421A4 /* Release */,
+				0577E960F68FF02722D75DA2D211E3A8 /* Debug */,
+				578820E498FFD85CA5D93A33D365FBED /* Release */,
 			);
 			defaultConfigurationIsVisible = 0;
 			defaultConfigurationName = Release;
 		};
-		2D8E8EC45A3A1A1D94AE762CB5028504 /* Build configuration list for PBXProject "Pods" */ = {
+		2E23E16710BB0FE81623A6495BE3092D /* Build configuration list for PBXNativeTarget "RealmSwift" */ = {
 			isa = XCConfigurationList;
 			buildConfigurations = (
-				0577E960F68FF02722D75DA2D211E3A8 /* Debug */,
-				578820E498FFD85CA5D93A33D365FBED /* Release */,
+				DC4F0440B8FB7E873E6B1F7966723420 /* Debug */,
+				C5FD960CB283EA4A31183A5AC5A9ED9A /* Release */,
 			);
 			defaultConfigurationIsVisible = 0;
 			defaultConfigurationName = Release;
@@ -931,11 +1703,29 @@
 			defaultConfigurationIsVisible = 0;
 			defaultConfigurationName = Release;
 		};
-		659D84DB6B9CFB1996FB238A044A68A1 /* Build configuration list for PBXNativeTarget "SWXMLHash" */ = {
+		90FEF63F3CFCD098DFDC84F953A89D53 /* Build configuration list for PBXNativeTarget "Realm" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				5CFF49C4E23737EF4C8594C894B85777 /* Debug */,
+				B92B5B733C8EB57F3C77DB2EFC2B81B1 /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+		AE9D66C1043456792E49A4B07D48F4A8 /* Build configuration list for PBXNativeTarget "SWXMLHash" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				3F30D0F66C0D0E35BD4ED14E5AA0B834 /* Debug */,
+				A0DD187F1B4163F439891FF4169A86F8 /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+		CEDFCCC18F1AFA8BDE68876A3F1A70B6 /* Build configuration list for PBXNativeTarget "Pods-CRMCall092016" */ = {
 			isa = XCConfigurationList;
 			buildConfigurations = (
-				AC82647F4C2BE5E8CCF859C6D6F8141E /* Debug */,
-				6CE0C113B81940025E3A2FB05117B621 /* Release */,
+				505167C53E8ACEB374B2DC8EAE7F464A /* Debug */,
+				5BE814104826BBFA03706516475BC87B /* Release */,
 			);
 			defaultConfigurationIsVisible = 0;
 			defaultConfigurationName = Release;
diff --git a/Pods/Pods.xcodeproj/xcuserdata/.xcuserdatad/xcschemes/Pods-CRMCall092016.xcscheme b/Pods/Pods.xcodeproj/xcuserdata/.xcuserdatad/xcschemes/Pods-CRMCall092016.xcscheme
index 9e1ec01..9cdd8f0 100644
--- a/Pods/Pods.xcodeproj/xcuserdata/.xcuserdatad/xcschemes/Pods-CRMCall092016.xcscheme
+++ b/Pods/Pods.xcodeproj/xcuserdata/.xcuserdatad/xcschemes/Pods-CRMCall092016.xcscheme
@@ -14,7 +14,7 @@
             buildForArchiving = "YES">
             <BuildableReference
                BuildableIdentifier = 'primary'
-               BlueprintIdentifier = '6A0818B9C68C8B9F82A2B6E85576006B'
+               BlueprintIdentifier = 'D5093CA88C13657E0DD6DE84E1F2C951'
                BlueprintName = 'Pods-CRMCall092016'
                ReferencedContainer = 'container:Pods.xcodeproj'
                BuildableName = 'Pods-CRMCall092016.framework'>
diff --git a/Pods/Pods.xcodeproj/xcuserdata/.xcuserdatad/xcschemes/Realm.xcscheme b/Pods/Pods.xcodeproj/xcuserdata/.xcuserdatad/xcschemes/Realm.xcscheme
new file mode 100644
index 0000000..546fa49
--- /dev/null
+++ b/Pods/Pods.xcodeproj/xcuserdata/.xcuserdatad/xcschemes/Realm.xcscheme
@@ -0,0 +1,60 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<Scheme
+   LastUpgradeVersion = "0700"
+   version = "1.3">
+   <BuildAction
+      parallelizeBuildables = "YES"
+      buildImplicitDependencies = "YES">
+      <BuildActionEntries>
+         <BuildActionEntry
+            buildForAnalyzing = "YES"
+            buildForTesting = "YES"
+            buildForRunning = "YES"
+            buildForProfiling = "YES"
+            buildForArchiving = "YES">
+            <BuildableReference
+               BuildableIdentifier = 'primary'
+               BlueprintIdentifier = '4269EA6DE49C90DEABF2DFAEBF5F6BCE'
+               BlueprintName = 'Realm'
+               ReferencedContainer = 'container:Pods.xcodeproj'
+               BuildableName = 'Realm.framework'>
+            </BuildableReference>
+         </BuildActionEntry>
+      </BuildActionEntries>
+   </BuildAction>
+   <TestAction
+      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
+      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
+      shouldUseLaunchSchemeArgsEnv = "YES"
+      buildConfiguration = "Debug">
+      <AdditionalOptions>
+      </AdditionalOptions>
+   </TestAction>
+   <LaunchAction
+      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
+      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
+      launchStyle = "0"
+      useCustomWorkingDirectory = "NO"
+      ignoresPersistentStateOnLaunch = "NO"
+      debugDocumentVersioning = "YES"
+      debugServiceExtension = "internal"
+      buildConfiguration = "Debug"
+      allowLocationSimulation = "YES">
+      <AdditionalOptions>
+      </AdditionalOptions>
+   </LaunchAction>
+   <ProfileAction
+      savedToolIdentifier = ""
+      useCustomWorkingDirectory = "NO"
+      debugDocumentVersioning = "YES"
+      buildConfiguration = "Release"
+      shouldUseLaunchSchemeArgsEnv = "YES">
+   </ProfileAction>
+   <AnalyzeAction
+      buildConfiguration = "Debug">
+   </AnalyzeAction>
+   <ArchiveAction
+      buildConfiguration = "Release"
+      revealArchiveInOrganizer = "YES">
+   </ArchiveAction>
+</Scheme>
diff --git a/Pods/Pods.xcodeproj/xcuserdata/.xcuserdatad/xcschemes/RealmSwift.xcscheme b/Pods/Pods.xcodeproj/xcuserdata/.xcuserdatad/xcschemes/RealmSwift.xcscheme
new file mode 100644
index 0000000..b45415e
--- /dev/null
+++ b/Pods/Pods.xcodeproj/xcuserdata/.xcuserdatad/xcschemes/RealmSwift.xcscheme
@@ -0,0 +1,60 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<Scheme
+   LastUpgradeVersion = "0700"
+   version = "1.3">
+   <BuildAction
+      parallelizeBuildables = "YES"
+      buildImplicitDependencies = "YES">
+      <BuildActionEntries>
+         <BuildActionEntry
+            buildForAnalyzing = "YES"
+            buildForTesting = "YES"
+            buildForRunning = "YES"
+            buildForProfiling = "YES"
+            buildForArchiving = "YES">
+            <BuildableReference
+               BuildableIdentifier = 'primary'
+               BlueprintIdentifier = '6ADBAF7183EDDAB0DE8E8BDEA68D46F1'
+               BlueprintName = 'RealmSwift'
+               ReferencedContainer = 'container:Pods.xcodeproj'
+               BuildableName = 'RealmSwift.framework'>
+            </BuildableReference>
+         </BuildActionEntry>
+      </BuildActionEntries>
+   </BuildAction>
+   <TestAction
+      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
+      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
+      shouldUseLaunchSchemeArgsEnv = "YES"
+      buildConfiguration = "Debug">
+      <AdditionalOptions>
+      </AdditionalOptions>
+   </TestAction>
+   <LaunchAction
+      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
+      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
+      launchStyle = "0"
+      useCustomWorkingDirectory = "NO"
+      ignoresPersistentStateOnLaunch = "NO"
+      debugDocumentVersioning = "YES"
+      debugServiceExtension = "internal"
+      buildConfiguration = "Debug"
+      allowLocationSimulation = "YES">
+      <AdditionalOptions>
+      </AdditionalOptions>
+   </LaunchAction>
+   <ProfileAction
+      savedToolIdentifier = ""
+      useCustomWorkingDirectory = "NO"
+      debugDocumentVersioning = "YES"
+      buildConfiguration = "Release"
+      shouldUseLaunchSchemeArgsEnv = "YES">
+   </ProfileAction>
+   <AnalyzeAction
+      buildConfiguration = "Debug">
+   </AnalyzeAction>
+   <ArchiveAction
+      buildConfiguration = "Release"
+      revealArchiveInOrganizer = "YES">
+   </ArchiveAction>
+</Scheme>
diff --git a/Pods/Pods.xcodeproj/xcuserdata/.xcuserdatad/xcschemes/SWXMLHash.xcscheme b/Pods/Pods.xcodeproj/xcuserdata/.xcuserdatad/xcschemes/SWXMLHash.xcscheme
index ef70ff0..8fd8ee0 100644
--- a/Pods/Pods.xcodeproj/xcuserdata/.xcuserdatad/xcschemes/SWXMLHash.xcscheme
+++ b/Pods/Pods.xcodeproj/xcuserdata/.xcuserdatad/xcschemes/SWXMLHash.xcscheme
@@ -14,7 +14,7 @@
             buildForArchiving = "YES">
             <BuildableReference
                BuildableIdentifier = 'primary'
-               BlueprintIdentifier = '67C63D588DA997BFF7D3C999DA7A5A23'
+               BlueprintIdentifier = '9A1A088A814206B99346C15F88870371'
                BlueprintName = 'SWXMLHash'
                ReferencedContainer = 'container:Pods.xcodeproj'
                BuildableName = 'SWXMLHash.framework'>
diff --git a/Pods/Pods.xcodeproj/xcuserdata/.xcuserdatad/xcschemes/xcschememanagement.plist b/Pods/Pods.xcodeproj/xcuserdata/.xcuserdatad/xcschemes/xcschememanagement.plist
index 015401b..db31b4f 100644
--- a/Pods/Pods.xcodeproj/xcuserdata/.xcuserdatad/xcschemes/xcschememanagement.plist
+++ b/Pods/Pods.xcodeproj/xcuserdata/.xcuserdatad/xcschemes/xcschememanagement.plist
@@ -19,6 +19,16 @@
 			<key>isShown</key>
 			<false/>
 		</dict>
+		<key>Realm.xcscheme</key>
+		<dict>
+			<key>isShown</key>
+			<false/>
+		</dict>
+		<key>RealmSwift.xcscheme</key>
+		<dict>
+			<key>isShown</key>
+			<false/>
+		</dict>
 		<key>SWXMLHash.xcscheme</key>
 		<dict>
 			<key>isShown</key>
diff --git a/Pods/Pods.xcodeproj/xcuserdata/hanbiro.xcuserdatad/xcschemes/Realm.xcscheme b/Pods/Pods.xcodeproj/xcuserdata/hanbiro.xcuserdatad/xcschemes/Realm.xcscheme
new file mode 100644
index 0000000..8f1a795
--- /dev/null
+++ b/Pods/Pods.xcodeproj/xcuserdata/hanbiro.xcuserdatad/xcschemes/Realm.xcscheme
@@ -0,0 +1,80 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<Scheme
+   LastUpgradeVersion = "0730"
+   version = "1.3">
+   <BuildAction
+      parallelizeBuildables = "YES"
+      buildImplicitDependencies = "YES">
+      <BuildActionEntries>
+         <BuildActionEntry
+            buildForTesting = "YES"
+            buildForRunning = "YES"
+            buildForProfiling = "YES"
+            buildForArchiving = "YES"
+            buildForAnalyzing = "YES">
+            <BuildableReference
+               BuildableIdentifier = "primary"
+               BlueprintIdentifier = "4269EA6DE49C90DEABF2DFAEBF5F6BCE"
+               BuildableName = "Realm.framework"
+               BlueprintName = "Realm"
+               ReferencedContainer = "container:Pods.xcodeproj">
+            </BuildableReference>
+         </BuildActionEntry>
+      </BuildActionEntries>
+   </BuildAction>
+   <TestAction
+      buildConfiguration = "Debug"
+      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
+      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
+      shouldUseLaunchSchemeArgsEnv = "YES">
+      <Testables>
+      </Testables>
+      <AdditionalOptions>
+      </AdditionalOptions>
+   </TestAction>
+   <LaunchAction
+      buildConfiguration = "Debug"
+      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
+      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
+      launchStyle = "0"
+      useCustomWorkingDirectory = "NO"
+      ignoresPersistentStateOnLaunch = "NO"
+      debugDocumentVersioning = "YES"
+      debugServiceExtension = "internal"
+      allowLocationSimulation = "YES">
+      <MacroExpansion>
+         <BuildableReference
+            BuildableIdentifier = "primary"
+            BlueprintIdentifier = "4269EA6DE49C90DEABF2DFAEBF5F6BCE"
+            BuildableName = "Realm.framework"
+            BlueprintName = "Realm"
+            ReferencedContainer = "container:Pods.xcodeproj">
+         </BuildableReference>
+      </MacroExpansion>
+      <AdditionalOptions>
+      </AdditionalOptions>
+   </LaunchAction>
+   <ProfileAction
+      buildConfiguration = "Release"
+      shouldUseLaunchSchemeArgsEnv = "YES"
+      savedToolIdentifier = ""
+      useCustomWorkingDirectory = "NO"
+      debugDocumentVersioning = "YES">
+      <MacroExpansion>
+         <BuildableReference
+            BuildableIdentifier = "primary"
+            BlueprintIdentifier = "4269EA6DE49C90DEABF2DFAEBF5F6BCE"
+            BuildableName = "Realm.framework"
+            BlueprintName = "Realm"
+            ReferencedContainer = "container:Pods.xcodeproj">
+         </BuildableReference>
+      </MacroExpansion>
+   </ProfileAction>
+   <AnalyzeAction
+      buildConfiguration = "Debug">
+   </AnalyzeAction>
+   <ArchiveAction
+      buildConfiguration = "Release"
+      revealArchiveInOrganizer = "YES">
+   </ArchiveAction>
+</Scheme>
diff --git a/Pods/Pods.xcodeproj/xcuserdata/hanbiro.xcuserdatad/xcschemes/RealmSwift.xcscheme b/Pods/Pods.xcodeproj/xcuserdata/hanbiro.xcuserdatad/xcschemes/RealmSwift.xcscheme
new file mode 100644
index 0000000..835d3da
--- /dev/null
+++ b/Pods/Pods.xcodeproj/xcuserdata/hanbiro.xcuserdatad/xcschemes/RealmSwift.xcscheme
@@ -0,0 +1,80 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<Scheme
+   LastUpgradeVersion = "0730"
+   version = "1.3">
+   <BuildAction
+      parallelizeBuildables = "YES"
+      buildImplicitDependencies = "YES">
+      <BuildActionEntries>
+         <BuildActionEntry
+            buildForTesting = "YES"
+            buildForRunning = "YES"
+            buildForProfiling = "YES"
+            buildForArchiving = "YES"
+            buildForAnalyzing = "YES">
+            <BuildableReference
+               BuildableIdentifier = "primary"
+               BlueprintIdentifier = "6ADBAF7183EDDAB0DE8E8BDEA68D46F1"
+               BuildableName = "RealmSwift.framework"
+               BlueprintName = "RealmSwift"
+               ReferencedContainer = "container:Pods.xcodeproj">
+            </BuildableReference>
+         </BuildActionEntry>
+      </BuildActionEntries>
+   </BuildAction>
+   <TestAction
+      buildConfiguration = "Debug"
+      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
+      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
+      shouldUseLaunchSchemeArgsEnv = "YES">
+      <Testables>
+      </Testables>
+      <AdditionalOptions>
+      </AdditionalOptions>
+   </TestAction>
+   <LaunchAction
+      buildConfiguration = "Debug"
+      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
+      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
+      launchStyle = "0"
+      useCustomWorkingDirectory = "NO"
+      ignoresPersistentStateOnLaunch = "NO"
+      debugDocumentVersioning = "YES"
+      debugServiceExtension = "internal"
+      allowLocationSimulation = "YES">
+      <MacroExpansion>
+         <BuildableReference
+            BuildableIdentifier = "primary"
+            BlueprintIdentifier = "6ADBAF7183EDDAB0DE8E8BDEA68D46F1"
+            BuildableName = "RealmSwift.framework"
+            BlueprintName = "RealmSwift"
+            ReferencedContainer = "container:Pods.xcodeproj">
+         </BuildableReference>
+      </MacroExpansion>
+      <AdditionalOptions>
+      </AdditionalOptions>
+   </LaunchAction>
+   <ProfileAction
+      buildConfiguration = "Release"
+      shouldUseLaunchSchemeArgsEnv = "YES"
+      savedToolIdentifier = ""
+      useCustomWorkingDirectory = "NO"
+      debugDocumentVersioning = "YES">
+      <MacroExpansion>
+         <BuildableReference
+            BuildableIdentifier = "primary"
+            BlueprintIdentifier = "6ADBAF7183EDDAB0DE8E8BDEA68D46F1"
+            BuildableName = "RealmSwift.framework"
+            BlueprintName = "RealmSwift"
+            ReferencedContainer = "container:Pods.xcodeproj">
+         </BuildableReference>
+      </MacroExpansion>
+   </ProfileAction>
+   <AnalyzeAction
+      buildConfiguration = "Debug">
+   </AnalyzeAction>
+   <ArchiveAction
+      buildConfiguration = "Release"
+      revealArchiveInOrganizer = "YES">
+   </ArchiveAction>
+</Scheme>
diff --git a/Pods/Pods.xcodeproj/xcuserdata/hanbiro.xcuserdatad/xcschemes/xcschememanagement.plist b/Pods/Pods.xcodeproj/xcuserdata/hanbiro.xcuserdatad/xcschemes/xcschememanagement.plist
index 18f8564..4dd1d02 100644
--- a/Pods/Pods.xcodeproj/xcuserdata/hanbiro.xcuserdatad/xcschemes/xcschememanagement.plist
+++ b/Pods/Pods.xcodeproj/xcuserdata/hanbiro.xcuserdatad/xcschemes/xcschememanagement.plist
@@ -19,6 +19,16 @@
 			<key>orderHint</key>
 			<integer>2</integer>
 		</dict>
+		<key>Realm.xcscheme</key>
+		<dict>
+			<key>orderHint</key>
+			<integer>6</integer>
+		</dict>
+		<key>RealmSwift.xcscheme</key>
+		<dict>
+			<key>orderHint</key>
+			<integer>7</integer>
+		</dict>
 		<key>SWXMLHash 2.xcscheme</key>
 		<dict>
 			<key>orderHint</key>
@@ -32,6 +42,11 @@
 	</dict>
 	<key>SuppressBuildableAutocreation</key>
 	<dict>
+		<key>4269EA6DE49C90DEABF2DFAEBF5F6BCE</key>
+		<dict>
+			<key>primary</key>
+			<true/>
+		</dict>
 		<key>67C63D588DA997BFF7D3C999DA7A5A23</key>
 		<dict>
 			<key>primary</key>
@@ -42,6 +57,11 @@
 			<key>primary</key>
 			<true/>
 		</dict>
+		<key>6ADBAF7183EDDAB0DE8E8BDEA68D46F1</key>
+		<dict>
+			<key>primary</key>
+			<true/>
+		</dict>
 		<key>6DC3AF9E2B939DEDE599F677CB6A2DFC</key>
 		<dict>
 			<key>primary</key>
@@ -57,6 +77,11 @@
 			<key>primary</key>
 			<true/>
 		</dict>
+		<key>9A1A088A814206B99346C15F88870371</key>
+		<dict>
+			<key>primary</key>
+			<true/>
+		</dict>
 		<key>B146E7512E9CA5F0BB2EDF3F86841CA4</key>
 		<dict>
 			<key>primary</key>
@@ -67,6 +92,11 @@
 			<key>primary</key>
 			<true/>
 		</dict>
+		<key>D5093CA88C13657E0DD6DE84E1F2C951</key>
+		<dict>
+			<key>primary</key>
+			<true/>
+		</dict>
 		<key>ED9EA20B7A8CD0AA34A09F4F5CB87BEB</key>
 		<dict>
 			<key>primary</key>
diff --git a/Pods/Realm/LICENSE b/Pods/Realm/LICENSE
new file mode 100644
index 0000000..a194346
--- /dev/null
+++ b/Pods/Realm/LICENSE
@@ -0,0 +1,269 @@
+TABLE OF CONTENTS
+
+1. Apache License version 2.0
+2. Realm Components
+3. Export Compliance
+
+-------------------------------------------------------------------------------
+
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "{}"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright {yyyy} {name of copyright owner}
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+
+REALM COMPONENTS
+
+This software contains components with separate copyright and license terms.
+Your use of these components is subject to the terms and conditions of the
+following licenses.
+
+For the Realm Core component
+
+  Realm Core Binary License
+
+  Copyright (c) 2011-2014 Realm Inc All rights reserved
+
+  Redistribution and use in binary form, with or without modification, is
+  permitted provided that the following conditions are met:
+
+  1. You agree not to attempt to decompile, disassemble, reverse engineer or
+  otherwise discover the source code from which the binary code was derived.
+  You may, however, access and obtain a separate license for most of the
+  source code from which this Software was created, at
+  http://realm.io/pricing/.
+
+  2. Redistributions in binary form must reproduce the above copyright notice,
+  this list of conditions and the following disclaimer in the documentation
+  and/or other materials provided with the distribution.
+
+  3. Neither the name of the copyright holder nor the names of its
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+  POSSIBILITY OF SUCH DAMAGE.
+
+EXPORT COMPLIANCE
+
+You understand that the Software may contain cryptographic functions that may be
+subject to export restrictions, and you represent and warrant that you are not
+located in a country that is subject to United States export restriction or embargo,
+including Cuba, Iran, North Korea, Sudan, Syria or the Crimea region, and that you
+are not on the Department of Commerce list of Denied Persons, Unverified Parties,
+or affiliated with a Restricted Entity.
+
+You agree to comply with all export, re-export and import restrictions and
+regulations of the Department of Commerce or other agency or authority of the
+United States or other applicable countries. You also agree not to transfer, or
+authorize the transfer of, directly or indirectly, the Software to any prohibited
+country, including Cuba, Iran, North Korea, Sudan, Syria or the Crimea region,
+or to any person or organization on or affiliated with the Department of
+Commerce lists of Denied Persons, Unverified Parties or Restricted Entities, or
+otherwise in violation of any such restrictions or regulations.
diff --git a/Pods/Realm/README.md b/Pods/Realm/README.md
new file mode 100644
index 0000000..322ac2d
--- /dev/null
+++ b/Pods/Realm/README.md
@@ -0,0 +1,72 @@
+![Realm](https://github.com/realm/realm-cocoa/raw/master/logo.png)
+
+Realm is a mobile database that runs directly inside phones, tablets or wearables.
+This repository holds the source code for the iOS, OS X, watchOS & tvOS versions of Realm Swift & Realm Objective-C.
+
+## Features
+
+* **Mobile-first:** Realm is the first database built from the ground up to run directly inside phones, tablets and wearables.
+* **Simple:** Data is directly [exposed as objects](https://realm.io/docs/objc/latest/#models) and [queryable by code](https://realm.io/docs/objc/latest/#queries), removing the need for ORM's riddled with performance & maintenance issues. Most of our users pick it up intuitively, getting simple apps up & running in minutes.
+* **Modern:** Realm supports relationships, generics, vectorization and even Swift.
+* **Fast:** Realm is faster than even raw SQLite on common operations, while maintaining an extremely rich feature set.
+
+## Getting Started
+
+Please see the detailed instructions in our docs to add [Realm Objective-C](https://realm.io/docs/objc/latest/#installation) _or_ [Realm Swift](https://realm.io/docs/swift/latest/#installation) to your Xcode project.
+
+## Documentation
+
+### Realm Objective-C
+
+The documentation can be found at [realm.io/docs/objc/latest](https://realm.io/docs/objc/latest).  
+The API reference is located at [realm.io/docs/objc/latest/api](https://realm.io/docs/objc/latest/api).
+
+### Realm Swift
+
+The documentation can be found at [realm.io/docs/swift/latest](https://realm.io/docs/swift/latest).  
+The API reference is located at [realm.io/docs/swift/latest/api](https://realm.io/docs/swift/latest/api).
+
+## Getting Help
+
+- **Need help with your code?**: Look for previous questions on the  [#realm tag](https://stackoverflow.com/questions/tagged/realm?sort=newest) — or [ask a new question](https://stackoverflow.com/questions/ask?tags=realm). We actively monitor & answer questions on SO!
+- **Have a bug to report?** [Open an issue](https://github.com/realm/realm-cocoa/issues/new). If possible, include the version of Realm, a full log, the Realm file, and a project that shows the issue.
+- **Have a feature request?** [Open an issue](https://github.com/realm/realm-cocoa/issues/new). Tell us what the feature should do, and why you want the feature.
+- Sign up for our [**Community Newsletter**](http://eepurl.com/VEKCn) to get regular tips, learn about other use-cases and get alerted of blogposts and tutorials about Realm.
+
+## Building Realm
+
+In case you don't want to use the precompiled version, you can build Realm yourself from source.
+
+Prerequisites:
+
+* Building Realm requires Xcode 7.3.
+* Building Realm documentation requires [jazzy](https://github.com/realm/jazzy)
+
+Once you have all the necessary prerequisites, building Realm.framework just takes a single command: `sh build.sh build`. You'll need an internet connection the first time you build Realm to download the core binary.
+
+Run `sh build.sh help` to see all the actions you can perform (build ios/osx, generate docs, test, etc.).
+
+## Contributing
+
+See [CONTRIBUTING.md](CONTRIBUTING.md) for more details!
+
+This project adheres to the [Contributor Covenant Code of Conduct](https://realm.io/conduct).
+By participating, you are expected to uphold this code. Please report
+unacceptable behavior to [info@realm.io](mailto:info@realm.io).
+
+## License
+
+Realm Objective-C & Realm Swift are published under the Apache 2.0 license.  
+The underlying core is available under the [Realm Core Binary License](https://github.com/realm/realm-cocoa/blob/master/LICENSE#L210-L243) while we [work to open-source it under the Apache 2.0 license](https://realm.io/docs/objc/latest/#faq).
+
+**This product is not being made available to any person located in Cuba, Iran,
+North Korea, Sudan, Syria or the Crimea region, or to any other person that is
+not eligible to receive the product under U.S. law.**
+
+## Feedback
+
+**_If you use Realm and are happy with it, all we ask is that you please consider sending out a tweet mentioning [@realm](https://twitter.com/realm) or email [help@realm.io](mailto:help@realm.io) to share your thoughts!_**
+
+**_And if you don't like it, please let us know what you would like improved, so we can fix it!_**
+
+![analytics](https://ga-beacon.appspot.com/UA-50247013-2/realm-cocoa/README?pixel)
diff --git a/Pods/Realm/Realm/ObjectStore/collection_notifications.cpp b/Pods/Realm/Realm/ObjectStore/collection_notifications.cpp
new file mode 100644
index 0000000..12fca83
--- /dev/null
+++ b/Pods/Realm/Realm/ObjectStore/collection_notifications.cpp
@@ -0,0 +1,56 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2016 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#include "collection_notifications.hpp"
+
+#include "impl/collection_notifier.hpp"
+
+using namespace realm;
+using namespace realm::_impl;
+
+NotificationToken::NotificationToken(std::shared_ptr<_impl::CollectionNotifier> notifier, size_t token)
+: m_notifier(std::move(notifier)), m_token(token)
+{
+}
+
+NotificationToken::~NotificationToken()
+{
+    // m_notifier itself (and not just the pointed-to thing) needs to be accessed
+    // atomically to ensure that there are no data races when the token is
+    // destroyed after being modified on a different thread.
+    // This is needed despite the token not being thread-safe in general as
+    // users find it very surprising for obj-c objects to care about what
+    // thread they are deallocated on.
+    if (auto notifier = m_notifier.exchange({})) {
+        notifier->remove_callback(m_token);
+    }
+}
+
+NotificationToken::NotificationToken(NotificationToken&&) = default;
+
+NotificationToken& NotificationToken::operator=(realm::NotificationToken&& rgt)
+{
+    if (this != &rgt) {
+        if (auto notifier = m_notifier.exchange({})) {
+            notifier->remove_callback(m_token);
+        }
+        m_notifier = std::move(rgt.m_notifier);
+        m_token = rgt.m_token;
+    }
+    return *this;
+}
diff --git a/Pods/Realm/Realm/ObjectStore/impl/apple/external_commit_helper.cpp b/Pods/Realm/Realm/ObjectStore/impl/apple/external_commit_helper.cpp
new file mode 100644
index 0000000..5195a3e
--- /dev/null
+++ b/Pods/Realm/Realm/ObjectStore/impl/apple/external_commit_helper.cpp
@@ -0,0 +1,226 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2015 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#include "impl/external_commit_helper.hpp"
+
+#include "impl/realm_coordinator.hpp"
+
+#include <asl.h>
+#include <assert.h>
+#include <fcntl.h>
+#include <sstream>
+#include <sys/event.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <system_error>
+#include <unistd.h>
+
+using namespace realm;
+using namespace realm::_impl;
+
+namespace {
+// Write a byte to a pipe to notify anyone waiting for data on the pipe
+void notify_fd(int fd, int read_fd)
+{
+    while (true) {
+        char c = 0;
+        ssize_t ret = write(fd, &c, 1);
+        if (ret == 1) {
+            break;
+        }
+
+        // If the pipe's buffer is full, we need to read some of the old data in
+        // it to make space. We don't just read in the code waiting for
+        // notifications so that we can notify multiple waiters with a single
+        // write.
+        assert(ret == -1 && errno == EAGAIN);
+        char buff[1024];
+        read(read_fd, buff, sizeof buff);
+    }
+}
+} // anonymous namespace
+
+void ExternalCommitHelper::FdHolder::close()
+{
+    if (m_fd != -1) {
+        ::close(m_fd);
+    }
+    m_fd = -1;
+}
+
+// Inter-thread and inter-process notifications of changes are done using a
+// named pipe in the filesystem next to the Realm file. Everyone who wants to be
+// notified of commits waits for data to become available on the pipe, and anyone
+// who commits a write transaction writes data to the pipe after releasing the
+// write lock. Note that no one ever actually *reads* from the pipe: the data
+// actually written is meaningless, and trying to read from a pipe from multiple
+// processes at once is fraught with race conditions.
+
+// When a RLMRealm instance is created, we add a CFRunLoopSource to the current
+// thread's runloop. On each cycle of the run loop, the run loop checks each of
+// its sources for work to do, which in the case of CFRunLoopSource is just
+// checking if CFRunLoopSourceSignal has been called since the last time it ran,
+// and if so invokes the function pointer supplied when the source is created,
+// which in our case just invokes `[realm handleExternalChange]`.
+
+// Listening for external changes is done using kqueue() on a background thread.
+// kqueue() lets us efficiently wait until the amount of data which can be read
+// from one or more file descriptors has changed, and tells us which of the file
+// descriptors it was that changed. We use this to wait on both the shared named
+// pipe, and a local anonymous pipe. When data is written to the named pipe, we
+// signal the runloop source and wake up the target runloop, and when data is
+// written to the anonymous pipe the background thread removes the runloop
+// source from the runloop and and shuts down.
+ExternalCommitHelper::ExternalCommitHelper(RealmCoordinator& parent)
+: m_parent(parent)
+{
+    m_kq = kqueue();
+    if (m_kq == -1) {
+        throw std::system_error(errno, std::system_category());
+    }
+
+#if !TARGET_OS_TV
+    auto path = parent.get_path() + ".note";
+
+    // Create and open the named pipe
+    int ret = mkfifo(path.c_str(), 0600);
+    if (ret == -1) {
+        int err = errno;
+        if (err == ENOTSUP) {
+            // Filesystem doesn't support named pipes, so try putting it in tmp instead
+            // Hash collisions are okay here because they just result in doing
+            // extra work, as opposed to correctness problems
+            std::ostringstream ss;
+            ss << getenv("TMPDIR");
+            ss << "realm_" << std::hash<std::string>()(path) << ".note";
+            path = ss.str();
+            ret = mkfifo(path.c_str(), 0600);
+            err = errno;
+        }
+        // the fifo already existing isn't an error
+        if (ret == -1 && err != EEXIST) {
+            throw std::system_error(err, std::system_category());
+        }
+    }
+
+    m_notify_fd = open(path.c_str(), O_RDWR);
+    if (m_notify_fd == -1) {
+        throw std::system_error(errno, std::system_category());
+    }
+
+    // Make writing to the pipe return -1 when the pipe's buffer is full
+    // rather than blocking until there's space available
+    ret = fcntl(m_notify_fd, F_SETFL, O_NONBLOCK);
+    if (ret == -1) {
+        throw std::system_error(errno, std::system_category());
+    }
+
+#else // !TARGET_OS_TV
+
+    // tvOS does not support named pipes, so use an anonymous pipe instead
+    int notification_pipe[2];
+    int ret = pipe(notification_pipe);
+    if (ret == -1) {
+        throw std::system_error(errno, std::system_category());
+    }
+
+    m_notify_fd = notification_pipe[0];
+    m_notify_fd_write = notification_pipe[1];
+
+#endif // TARGET_OS_TV
+
+    // Create the anonymous pipe for shutdown notifications
+    int shutdown_pipe[2];
+    ret = pipe(shutdown_pipe);
+    if (ret == -1) {
+        throw std::system_error(errno, std::system_category());
+    }
+
+    m_shutdown_read_fd = shutdown_pipe[0];
+    m_shutdown_write_fd = shutdown_pipe[1];
+
+    m_thread = std::async(std::launch::async, [=] {
+        try {
+            listen();
+        }
+        catch (std::exception const& e) {
+            fprintf(stderr, "uncaught exception in notifier thread: %s: %s\n", typeid(e).name(), e.what());
+            asl_log(nullptr, nullptr, ASL_LEVEL_ERR, "uncaught exception in notifier thread: %s: %s", typeid(e).name(), e.what());
+            throw;
+        }
+        catch (...) {
+            fprintf(stderr,  "uncaught exception in notifier thread\n");
+            asl_log(nullptr, nullptr, ASL_LEVEL_ERR, "uncaught exception in notifier thread");
+            throw;
+        }
+    });
+}
+
+ExternalCommitHelper::~ExternalCommitHelper()
+{
+    notify_fd(m_shutdown_write_fd, m_shutdown_read_fd);
+    m_thread.wait(); // Wait for the thread to exit
+}
+
+void ExternalCommitHelper::listen()
+{
+    pthread_setname_np("RLMRealm notification listener");
+
+    // Set up the kqueue
+    // EVFILT_READ indicates that we care about data being available to read
+    // on the given file descriptor.
+    // EV_CLEAR makes it wait for the amount of data available to be read to
+    // change rather than just returning when there is any data to read.
+    struct kevent ke[2];
+    EV_SET(&ke[0], m_notify_fd, EVFILT_READ, EV_ADD | EV_CLEAR, 0, 0, 0);
+    EV_SET(&ke[1], m_shutdown_read_fd, EVFILT_READ, EV_ADD | EV_CLEAR, 0, 0, 0);
+    int ret = kevent(m_kq, ke, 2, nullptr, 0, nullptr);
+    assert(ret == 0);
+
+    while (true) {
+        struct kevent event;
+        // Wait for data to become on either fd
+        // Return code is number of bytes available or -1 on error
+        ret = kevent(m_kq, nullptr, 0, &event, 1, nullptr);
+        assert(ret >= 0);
+        if (ret == 0) {
+            // Spurious wakeup; just wait again
+            continue;
+        }
+
+        // Check which file descriptor had activity: if it's the shutdown
+        // pipe, then someone called -stop; otherwise it's the named pipe
+        // and someone committed a write transaction
+        if (event.ident == (uint32_t)m_shutdown_read_fd) {
+            return;
+        }
+        assert(event.ident == (uint32_t)m_notify_fd);
+
+        m_parent.on_change();
+    }
+}
+
+void ExternalCommitHelper::notify_others()
+{
+    if (m_notify_fd_write != -1) {
+        notify_fd(m_notify_fd_write, m_notify_fd);
+    }
+    else {
+        notify_fd(m_notify_fd, m_notify_fd);
+    }
+}
diff --git a/Pods/Realm/Realm/ObjectStore/impl/apple/weak_realm_notifier.cpp b/Pods/Realm/Realm/ObjectStore/impl/apple/weak_realm_notifier.cpp
new file mode 100644
index 0000000..930c3fe
--- /dev/null
+++ b/Pods/Realm/Realm/ObjectStore/impl/apple/weak_realm_notifier.cpp
@@ -0,0 +1,103 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2015 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#include "impl/weak_realm_notifier.hpp"
+
+#include "shared_realm.hpp"
+
+#include <atomic>
+
+using namespace realm;
+using namespace realm::_impl;
+
+WeakRealmNotifier::WeakRealmNotifier(const std::shared_ptr<Realm>& realm, bool cache)
+: WeakRealmNotifierBase(realm, cache)
+{
+    struct RefCountedWeakPointer {
+        std::weak_ptr<Realm> realm;
+        std::atomic<size_t> ref_count;
+    };
+
+    CFRunLoopSourceContext ctx{};
+    ctx.info = new RefCountedWeakPointer{realm, {0}};
+    ctx.perform = [](void* info) {
+        if (auto realm = static_cast<RefCountedWeakPointer*>(info)->realm.lock()) {
+            realm->notify();
+        }
+    };
+    ctx.retain = [](const void* info) {
+        static_cast<RefCountedWeakPointer*>(const_cast<void*>(info))->ref_count.fetch_add(1, std::memory_order_relaxed);
+        return info;
+    };
+    ctx.release = [](const void* info) {
+        auto ptr = static_cast<RefCountedWeakPointer*>(const_cast<void*>(info));
+        if (ptr->ref_count.fetch_add(-1, std::memory_order_acq_rel) == 1) {
+            delete ptr;
+        }
+    };
+
+    m_runloop = CFRunLoopGetCurrent();
+    CFRetain(m_runloop);
+    m_signal = CFRunLoopSourceCreate(kCFAllocatorDefault, 0, &ctx);
+    CFRunLoopAddSource(m_runloop, m_signal, kCFRunLoopDefaultMode);
+}
+
+WeakRealmNotifier::WeakRealmNotifier(WeakRealmNotifier&& rgt)
+: WeakRealmNotifierBase(std::move(rgt))
+, m_runloop(rgt.m_runloop)
+, m_signal(rgt.m_signal)
+{
+    rgt.m_runloop = nullptr;
+    rgt.m_signal = nullptr;
+}
+
+WeakRealmNotifier& WeakRealmNotifier::operator=(WeakRealmNotifier&& rgt)
+{
+    WeakRealmNotifierBase::operator=(std::move(rgt));
+
+    invalidate();
+    m_runloop = rgt.m_runloop;
+    m_signal = rgt.m_signal;
+    rgt.m_runloop = nullptr;
+    rgt.m_signal = nullptr;
+
+    return *this;
+}
+
+WeakRealmNotifier::~WeakRealmNotifier()
+{
+    invalidate();
+}
+
+void WeakRealmNotifier::invalidate()
+{
+    if (m_signal) {
+        CFRunLoopSourceInvalidate(m_signal);
+        CFRelease(m_signal);
+        CFRelease(m_runloop);
+    }
+}
+
+void WeakRealmNotifier::notify()
+{
+    CFRunLoopSourceSignal(m_signal);
+    // Signalling the source makes it run the next time the runloop gets
+    // to it, but doesn't make the runloop start if it's currently idle
+    // waiting for events
+    CFRunLoopWakeUp(m_runloop);
+}
diff --git a/Pods/Realm/Realm/ObjectStore/impl/collection_change_builder.cpp b/Pods/Realm/Realm/ObjectStore/impl/collection_change_builder.cpp
new file mode 100644
index 0000000..c413f55
--- /dev/null
+++ b/Pods/Realm/Realm/ObjectStore/impl/collection_change_builder.cpp
@@ -0,0 +1,662 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2016 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#include "impl/collection_change_builder.hpp"
+
+#include <realm/util/assert.hpp>
+#include <algorithm>
+
+#include <algorithm>
+
+using namespace realm;
+using namespace realm::_impl;
+
+CollectionChangeBuilder::CollectionChangeBuilder(IndexSet deletions,
+                                                 IndexSet insertions,
+                                                 IndexSet modifications,
+                                                 std::vector<Move> moves)
+: CollectionChangeSet({std::move(deletions), std::move(insertions), std::move(modifications), std::move(moves)})
+{
+    for (auto&& move : this->moves) {
+        this->deletions.add(move.from);
+        this->insertions.add(move.to);
+    }
+}
+
+void CollectionChangeBuilder::merge(CollectionChangeBuilder&& c)
+{
+    if (c.empty())
+        return;
+    if (empty()) {
+        *this = std::move(c);
+        return;
+    }
+
+    verify();
+    c.verify();
+
+    // First update any old moves
+    if (!c.moves.empty() || !c.deletions.empty() || !c.insertions.empty()) {
+        auto it = std::remove_if(begin(moves), end(moves), [&](auto& old) {
+            // Check if the moved row was moved again, and if so just update the destination
+            auto it = find_if(begin(c.moves), end(c.moves), [&](auto const& m) {
+                return old.to == m.from;
+            });
+            if (it != c.moves.end()) {
+                if (modifications.contains(it->from))
+                    c.modifications.add(it->to);
+                old.to = it->to;
+                *it = c.moves.back();
+                c.moves.pop_back();
+                ++it;
+                return false;
+            }
+
+            // Check if the destination was deleted
+            // Removing the insert for this move will happen later
+            if (c.deletions.contains(old.to))
+                return true;
+
+            // Update the destination to adjust for any new insertions and deletions
+            old.to = c.insertions.shift(c.deletions.unshift(old.to));
+            return false;
+        });
+        moves.erase(it, end(moves));
+    }
+
+    // Ignore new moves of rows which were previously inserted (the implicit
+    // delete from the move will remove the insert)
+    if (!insertions.empty() && !c.moves.empty()) {
+        c.moves.erase(std::remove_if(begin(c.moves), end(c.moves),
+                              [&](auto const& m) { return insertions.contains(m.from); }),
+                    end(c.moves));
+    }
+
+    // Ensure that any previously modified rows which were moved are still modified
+    if (!modifications.empty() && !c.moves.empty()) {
+        for (auto const& move : c.moves) {
+            if (modifications.contains(move.from))
+                c.modifications.add(move.to);
+        }
+    }
+
+    // Update the source position of new moves to compensate for the changes made
+    // in the old changeset
+    if (!deletions.empty() || !insertions.empty()) {
+        for (auto& move : c.moves)
+            move.from = deletions.shift(insertions.unshift(move.from));
+    }
+
+    moves.insert(end(moves), begin(c.moves), end(c.moves));
+
+    // New deletion indices have been shifted by the insertions, so unshift them
+    // before adding
+    deletions.add_shifted_by(insertions, c.deletions);
+
+    // Drop any inserted-then-deleted rows, then merge in new insertions
+    insertions.erase_at(c.deletions);
+    insertions.insert_at(c.insertions);
+
+    clean_up_stale_moves();
+
+    modifications.erase_at(c.deletions);
+    modifications.shift_for_insert_at(c.insertions);
+    modifications.add(c.modifications);
+
+    c = {};
+    verify();
+}
+
+void CollectionChangeBuilder::clean_up_stale_moves()
+{
+    // Look for moves which are now no-ops, and remove them plus the associated
+    // insert+delete. Note that this isn't just checking for from == to due to
+    // that rows can also be shifted by other inserts and deletes
+    moves.erase(std::remove_if(begin(moves), end(moves), [&](auto const& move) {
+        if (move.from - deletions.count(0, move.from) != move.to - insertions.count(0, move.to))
+            return false;
+        deletions.remove(move.from);
+        insertions.remove(move.to);
+        return true;
+    }), end(moves));
+}
+
+void CollectionChangeBuilder::parse_complete()
+{
+    moves.reserve(m_move_mapping.size());
+    for (auto move : m_move_mapping) {
+        REALM_ASSERT_DEBUG(deletions.contains(move.second));
+        REALM_ASSERT_DEBUG(insertions.contains(move.first));
+        moves.push_back({move.second, move.first});
+    }
+    m_move_mapping.clear();
+    std::sort(begin(moves), end(moves),
+              [](auto const& a, auto const& b) { return a.from < b.from; });
+}
+
+void CollectionChangeBuilder::modify(size_t ndx)
+{
+    modifications.add(ndx);
+}
+
+void CollectionChangeBuilder::insert(size_t index, size_t count, bool track_moves)
+{
+    modifications.shift_for_insert_at(index, count);
+    if (!track_moves)
+        return;
+
+    insertions.insert_at(index, count);
+
+    for (auto& move : moves) {
+        if (move.to >= index)
+            ++move.to;
+    }
+}
+
+void CollectionChangeBuilder::erase(size_t index)
+{
+    modifications.erase_at(index);
+    size_t unshifted = insertions.erase_or_unshift(index);
+    if (unshifted != IndexSet::npos)
+        deletions.add_shifted(unshifted);
+
+    for (size_t i = 0; i < moves.size(); ++i) {
+        auto& move = moves[i];
+        if (move.to == index) {
+            moves.erase(moves.begin() + i);
+            --i;
+        }
+        else if (move.to > index)
+            --move.to;
+    }
+}
+
+void CollectionChangeBuilder::clear(size_t old_size)
+{
+    if (old_size != std::numeric_limits<size_t>::max()) {
+        for (auto range : deletions)
+            old_size += range.second - range.first;
+        for (auto range : insertions)
+            old_size -= range.second - range.first;
+    }
+
+    modifications.clear();
+    insertions.clear();
+    moves.clear();
+    m_move_mapping.clear();
+    deletions.set(old_size);
+}
+
+void CollectionChangeBuilder::move(size_t from, size_t to)
+{
+    REALM_ASSERT(from != to);
+
+    bool updated_existing_move = false;
+    for (auto& move : moves) {
+        if (move.to != from) {
+            // Shift other moves if this row is moving from one side of them
+            // to the other
+            if (move.to >= to && move.to < from)
+                ++move.to;
+            else if (move.to <= to && move.to > from)
+                --move.to;
+            continue;
+        }
+        REALM_ASSERT(!updated_existing_move);
+
+        // Collapse A -> B, B -> C into a single A -> C move
+        move.to = to;
+        updated_existing_move = true;
+
+        insertions.erase_at(from);
+        insertions.insert_at(to);
+    }
+
+    if (!updated_existing_move) {
+        auto shifted_from = insertions.erase_or_unshift(from);
+        insertions.insert_at(to);
+
+        // Don't report deletions/moves for newly inserted rows
+        if (shifted_from != IndexSet::npos) {
+            shifted_from = deletions.add_shifted(shifted_from);
+            moves.push_back({shifted_from, to});
+        }
+    }
+
+    bool modified = modifications.contains(from);
+    modifications.erase_at(from);
+
+    if (modified)
+        modifications.insert_at(to);
+    else
+        modifications.shift_for_insert_at(to);
+}
+
+void CollectionChangeBuilder::move_over(size_t row_ndx, size_t last_row, bool track_moves)
+{
+    REALM_ASSERT(row_ndx <= last_row);
+    REALM_ASSERT(insertions.empty() || prev(insertions.end())->second - 1 <= last_row);
+    REALM_ASSERT(modifications.empty() || prev(modifications.end())->second - 1 <= last_row);
+
+    if (row_ndx == last_row) {
+        if (track_moves) {
+            auto shifted_from = insertions.erase_or_unshift(row_ndx);
+            if (shifted_from != IndexSet::npos)
+                deletions.add_shifted(shifted_from);
+            m_move_mapping.erase(row_ndx);
+        }
+        modifications.remove(row_ndx);
+        return;
+    }
+
+    bool modified = modifications.contains(last_row);
+    if (modified) {
+        modifications.remove(last_row);
+        modifications.add(row_ndx);
+    }
+    else
+        modifications.remove(row_ndx);
+
+    if (!track_moves)
+        return;
+
+    bool row_is_insertion = insertions.contains(row_ndx);
+    bool last_is_insertion = !insertions.empty() && prev(insertions.end())->second == last_row + 1;
+    REALM_ASSERT_DEBUG(insertions.empty() || prev(insertions.end())->second <= last_row + 1);
+
+    // Collapse A -> B, B -> C into a single A -> C move
+    bool last_was_already_moved = false;
+    if (last_is_insertion) {
+        auto it = m_move_mapping.find(last_row);
+        if (it != m_move_mapping.end() && it->first == last_row) {
+            m_move_mapping[row_ndx] = it->second;
+            m_move_mapping.erase(it);
+            last_was_already_moved = true;
+        }
+    }
+
+    // Remove moves to the row being deleted
+    if (row_is_insertion && !last_was_already_moved) {
+        auto it = m_move_mapping.find(row_ndx);
+        if (it != m_move_mapping.end() && it->first == row_ndx)
+            m_move_mapping.erase(it);
+    }
+
+    // Don't report deletions/moves if last_row is newly inserted
+    if (last_is_insertion) {
+        insertions.remove(last_row);
+    }
+    // If it was previously moved, the unshifted source row has already been marked as deleted
+    else if (!last_was_already_moved) {
+        auto shifted_last_row = insertions.unshift(last_row);
+        shifted_last_row = deletions.add_shifted(shifted_last_row);
+        m_move_mapping[row_ndx] = shifted_last_row;
+    }
+
+    // Don't mark the moved-over row as deleted if it was a new insertion
+    if (!row_is_insertion) {
+        deletions.add_shifted(insertions.unshift(row_ndx));
+        insertions.add(row_ndx);
+    }
+    verify();
+}
+
+void CollectionChangeBuilder::verify()
+{
+#ifdef REALM_DEBUG
+    for (auto&& move : moves) {
+        REALM_ASSERT(deletions.contains(move.from));
+        REALM_ASSERT(insertions.contains(move.to));
+    }
+#endif
+}
+
+namespace {
+struct RowInfo {
+    size_t row_index;
+    size_t prev_tv_index;
+    size_t tv_index;
+    size_t shifted_tv_index;
+};
+
+void calculate_moves_unsorted(std::vector<RowInfo>& new_rows, IndexSet& removed, CollectionChangeSet& changeset)
+{
+    size_t expected = 0;
+    for (auto& row : new_rows) {
+        // With unsorted queries rows only move due to move_last_over(), which
+        // inherently can only move a row to earlier in the table.
+        REALM_ASSERT(row.shifted_tv_index >= expected);
+        if (row.shifted_tv_index == expected) {
+            ++expected;
+            continue;
+        }
+
+        // This row isn't just the row after the previous one, but it still may
+        // not be a move if there were rows deleted between the two, so next
+        // calcuate what row should be here taking those in to account
+        size_t calc_expected = row.tv_index - changeset.insertions.count(0, row.tv_index) + removed.count(0, row.prev_tv_index);
+        if (row.shifted_tv_index == calc_expected) {
+            expected = calc_expected + 1;
+            continue;
+        }
+
+        // The row still isn't the expected one, so it's a move
+        changeset.moves.push_back({row.prev_tv_index, row.tv_index});
+        changeset.insertions.add(row.tv_index);
+        removed.add(row.prev_tv_index);
+    }
+}
+
+class LongestCommonSubsequenceCalculator {
+public:
+    // A pair of an index in the table and an index in the table view
+    struct Row {
+        size_t row_index;
+        size_t tv_index;
+    };
+
+    struct Match {
+        // The index in `a` at which this match begins
+        size_t i;
+        // The index in `b` at which this match begins
+        size_t j;
+        // The length of this match
+        size_t size;
+        // The number of rows in this block which were modified
+        size_t modified;
+    };
+    std::vector<Match> m_longest_matches;
+
+    LongestCommonSubsequenceCalculator(std::vector<Row>& a, std::vector<Row>& b,
+                                       size_t start_index,
+                                       IndexSet const& modifications)
+    : m_modified(modifications)
+    , a(a), b(b)
+    {
+        find_longest_matches(start_index, a.size(),
+                             start_index, b.size());
+        m_longest_matches.push_back({a.size(), b.size(), 0});
+    }
+
+private:
+    IndexSet const& m_modified;
+
+    // The two arrays of rows being diffed
+    // a is sorted by tv_index, b is sorted by row_index
+    std::vector<Row> &a, &b;
+
+    // Find the longest matching range in (a + begin1, a + end1) and (b + begin2, b + end2)
+    // "Matching" is defined as "has the same row index"; the TV index is just
+    // there to let us turn an index in a/b into an index which can be reported
+    // in the output changeset.
+    //
+    // This is done with the O(N) space variant of the dynamic programming
+    // algorithm for longest common subsequence, where N is the maximum number
+    // of the most common row index (which for everything but linkview-derived
+    // TVs will be 1).
+    Match find_longest_match(size_t begin1, size_t end1, size_t begin2, size_t end2)
+    {
+        struct Length {
+            size_t j, len;
+        };
+        // The length of the matching block for each `j` for the previously checked row
+        std::vector<Length> prev;
+        // The length of the matching block for each `j` for the row currently being checked
+        std::vector<Length> cur;
+
+        // Calculate the length of the matching block *ending* at b[j], which
+        // is 1 if b[j - 1] did not match, and b[j - 1] + 1 otherwise.
+        auto length = [&](size_t j) -> size_t {
+            for (auto const& pair : prev) {
+                if (pair.j + 1 == j)
+                    return pair.len + 1;
+            }
+            return 1;
+        };
+
+        // Iterate over each `j` which has the same row index as a[i] and falls
+        // within the range begin2 <= j < end2
+        auto for_each_b_match = [&](size_t i, auto&& f) {
+            size_t ai = a[i].row_index;
+            // Find the TV indicies at which this row appears in the new results
+            // There should always be at least one (or it would have been
+            // filtered out earlier), but there can be multiple if there are dupes
+            auto it = lower_bound(begin(b), end(b), ai,
+                                  [](auto lft, auto rgt) { return lft.row_index < rgt; });
+            REALM_ASSERT(it != end(b) && it->row_index == ai);
+            for (; it != end(b) && it->row_index == ai; ++it) {
+                size_t j = it->tv_index;
+                if (j < begin2)
+                    continue;
+                if (j >= end2)
+                    break; // b is sorted by tv_index so this can't transition from false to true
+                f(j);
+            }
+        };
+
+        Match best = {begin1, begin2, 0, 0};
+        for (size_t i = begin1; i < end1; ++i) {
+            // prev = std::move(cur), but avoids discarding prev's heap allocation
+            cur.swap(prev);
+            cur.clear();
+
+            for_each_b_match(i, [&](size_t j) {
+                size_t size = length(j);
+
+                cur.push_back({j, size});
+
+                // If the matching block ending at a[i] and b[j] is longer than
+                // the previous one, select it as the best
+                if (size > best.size)
+                    best = {i - size + 1, j - size + 1, size, IndexSet::npos};
+                // Given two equal-length matches, prefer the one with fewer modified rows
+                else if (size == best.size) {
+                    if (best.modified == IndexSet::npos)
+                        best.modified = m_modified.count(best.j - size + 1, best.j + 1);
+                    auto count = m_modified.count(j - size + 1, j + 1);
+                    if (count < best.modified)
+                        best = {i - size + 1, j - size + 1, size, count};
+                }
+
+                // The best block should always fall within the range being searched
+                REALM_ASSERT(best.i >= begin1 && best.i + best.size <= end1);
+                REALM_ASSERT(best.j >= begin2 && best.j + best.size <= end2);
+            });
+        }
+        return best;
+    }
+
+    void find_longest_matches(size_t begin1, size_t end1, size_t begin2, size_t end2)
+    {
+        // FIXME: recursion could get too deep here
+        // recursion depth worst case is currently O(N) and each recursion uses 320 bytes of stack
+        // could reduce worst case to O(sqrt(N)) (and typical case to O(log N))
+        // biasing equal selections towards the middle, but that's still
+        // insufficient for Android's 8 KB stacks
+        auto m = find_longest_match(begin1, end1, begin2, end2);
+        if (!m.size)
+            return;
+        if (m.i > begin1 && m.j > begin2)
+            find_longest_matches(begin1, m.i, begin2, m.j);
+        m_longest_matches.push_back(m);
+        if (m.i + m.size < end2 && m.j + m.size < end2)
+            find_longest_matches(m.i + m.size, end1, m.j + m.size, end2);
+    }
+};
+
+void calculate_moves_sorted(std::vector<RowInfo>& rows, CollectionChangeSet& changeset)
+{
+    // The RowInfo array contains information about the old and new TV indices of
+    // each row, which we need to turn into two sequences of rows, which we'll
+    // then find matches in
+    std::vector<LongestCommonSubsequenceCalculator::Row> a, b;
+
+    a.reserve(rows.size());
+    for (auto& row : rows) {
+        a.push_back({row.row_index, row.prev_tv_index});
+    }
+    std::sort(begin(a), end(a), [](auto lft, auto rgt) {
+        return std::tie(lft.tv_index, lft.row_index) < std::tie(rgt.tv_index, rgt.row_index);
+    });
+
+    // Before constructing `b`, first find the first index in `a` which will
+    // actually differ in `b`, and skip everything else if there aren't any
+    size_t first_difference = IndexSet::npos;
+    for (size_t i = 0; i < a.size(); ++i) {
+        if (a[i].row_index != rows[i].row_index) {
+            first_difference = i;
+            break;
+        }
+    }
+    if (first_difference == IndexSet::npos)
+        return;
+
+    // Note that `b` is sorted by row_index, while `a` is sorted by tv_index
+    b.reserve(rows.size());
+    for (size_t i = 0; i < rows.size(); ++i)
+        b.push_back({rows[i].row_index, i});
+    std::sort(begin(b), end(b), [](auto lft, auto rgt) {
+        return std::tie(lft.row_index, lft.tv_index) < std::tie(rgt.row_index, rgt.tv_index);
+    });
+
+    // Calculate the LCS of the two sequences
+    auto matches = LongestCommonSubsequenceCalculator(a, b, first_difference,
+                                                      changeset.modifications).m_longest_matches;
+
+    // And then insert and delete rows as needed to align them
+    size_t i = first_difference, j = first_difference;
+    for (auto match : matches) {
+        for (; i < match.i; ++i)
+            changeset.deletions.add(a[i].tv_index);
+        for (; j < match.j; ++j)
+            changeset.insertions.add(rows[j].tv_index);
+        i += match.size;
+        j += match.size;
+    }
+}
+
+} // Anonymous namespace
+
+CollectionChangeBuilder CollectionChangeBuilder::calculate(std::vector<size_t> const& prev_rows,
+                                                           std::vector<size_t> const& next_rows,
+                                                           std::function<bool (size_t)> row_did_change,
+                                                           bool rows_are_in_table_order)
+{
+    REALM_ASSERT_DEBUG(!rows_are_in_table_order || std::is_sorted(begin(next_rows), end(next_rows)));
+
+    CollectionChangeBuilder ret;
+
+    size_t deleted = 0;
+    std::vector<RowInfo> old_rows;
+    old_rows.reserve(prev_rows.size());
+    for (size_t i = 0; i < prev_rows.size(); ++i) {
+        if (prev_rows[i] == IndexSet::npos) {
+            ++deleted;
+            ret.deletions.add(i);
+        }
+        else
+            old_rows.push_back({prev_rows[i], IndexSet::npos, i, i - deleted});
+    }
+    std::sort(begin(old_rows), end(old_rows), [](auto& lft, auto& rgt) {
+        return lft.row_index < rgt.row_index;
+    });
+
+    std::vector<RowInfo> new_rows;
+    new_rows.reserve(next_rows.size());
+    for (size_t i = 0; i < next_rows.size(); ++i) {
+        new_rows.push_back({next_rows[i], IndexSet::npos, i, 0});
+    }
+    std::sort(begin(new_rows), end(new_rows), [](auto& lft, auto& rgt) {
+        return lft.row_index < rgt.row_index;
+    });
+
+    // Don't add rows which were modified to not match the query to `deletions`
+    // immediately because the unsorted move logic needs to be able to
+    // distinguish them from rows which were outright deleted
+    IndexSet removed;
+
+    // Now that our old and new sets of rows are sorted by row index, we can
+    // iterate over them and either record old+new TV indices for rows present
+    // in both, or mark them as inserted/deleted if they appear only in one
+    size_t i = 0, j = 0;
+    while (i < old_rows.size() && j < new_rows.size()) {
+        auto old_index = old_rows[i];
+        auto new_index = new_rows[j];
+        if (old_index.row_index == new_index.row_index) {
+            new_rows[j].prev_tv_index = old_rows[i].tv_index;
+            new_rows[j].shifted_tv_index = old_rows[i].shifted_tv_index;
+            ++i;
+            ++j;
+        }
+        else if (old_index.row_index < new_index.row_index) {
+            removed.add(old_index.tv_index);
+            ++i;
+        }
+        else {
+            ret.insertions.add(new_index.tv_index);
+            ++j;
+        }
+    }
+
+    for (; i < old_rows.size(); ++i)
+        removed.add(old_rows[i].tv_index);
+    for (; j < new_rows.size(); ++j)
+        ret.insertions.add(new_rows[j].tv_index);
+
+    // Filter out the new insertions since we don't need them for any of the
+    // further calculations
+    new_rows.erase(std::remove_if(begin(new_rows), end(new_rows),
+                                  [](auto& row) { return row.prev_tv_index == IndexSet::npos; }),
+                   end(new_rows));
+    std::sort(begin(new_rows), end(new_rows),
+              [](auto& lft, auto& rgt) { return lft.tv_index < rgt.tv_index; });
+
+    for (auto& row : new_rows) {
+        if (row_did_change(row.row_index)) {
+            ret.modifications.add(row.tv_index);
+        }
+    }
+
+    if (!rows_are_in_table_order) {
+        calculate_moves_sorted(new_rows, ret);
+    }
+    else {
+        calculate_moves_unsorted(new_rows, removed, ret);
+    }
+    ret.deletions.add(removed);
+    ret.verify();
+
+#ifdef REALM_DEBUG
+    { // Verify that applying the calculated change to prev_rows actually produces next_rows
+        auto rows = prev_rows;
+        auto it = util::make_reverse_iterator(ret.deletions.end());
+        auto end = util::make_reverse_iterator(ret.deletions.begin());
+        for (; it != end; ++it) {
+            rows.erase(rows.begin() + it->first, rows.begin() + it->second);
+        }
+
+        for (auto i : ret.insertions.as_indexes()) {
+            rows.insert(rows.begin() + i, next_rows[i]);
+        }
+
+        REALM_ASSERT(rows == next_rows);
+    }
+#endif
+
+    return ret;
+}
diff --git a/Pods/Realm/Realm/ObjectStore/impl/collection_notifier.cpp b/Pods/Realm/Realm/ObjectStore/impl/collection_notifier.cpp
new file mode 100644
index 0000000..7751c3a
--- /dev/null
+++ b/Pods/Realm/Realm/ObjectStore/impl/collection_notifier.cpp
@@ -0,0 +1,344 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2016 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#include "impl/collection_notifier.hpp"
+
+#include "impl/realm_coordinator.hpp"
+#include "shared_realm.hpp"
+
+#include <realm/link_view.hpp>
+
+using namespace realm;
+using namespace realm::_impl;
+
+std::function<bool (size_t)>
+CollectionNotifier::get_modification_checker(TransactionChangeInfo const& info,
+                                             Table const& root_table)
+{
+    // First check if any of the tables accessible from the root table were
+    // actually modified. This can be false if there were only insertions, or
+    // deletions which were not linked to by any row in the linking table
+    auto table_modified = [&](auto& tbl) {
+        return tbl.table_ndx < info.tables.size()
+            && !info.tables[tbl.table_ndx].modifications.empty();
+    };
+    if (!any_of(begin(m_related_tables), end(m_related_tables), table_modified)) {
+        return [](size_t) { return false; };
+    }
+
+    return DeepChangeChecker(info, root_table, m_related_tables);
+}
+
+void DeepChangeChecker::find_related_tables(std::vector<RelatedTable>& out, Table const& table)
+{
+    auto table_ndx = table.get_index_in_group();
+    if (any_of(begin(out), end(out), [=](auto& tbl) { return tbl.table_ndx == table_ndx; }))
+        return;
+
+    // We need to add this table to `out` before recurring so that the check
+    // above works, but we can't store a pointer to the thing being populated
+    // because the recursive calls may resize `out`, so instead look it up by
+    // index every time
+    size_t out_index = out.size();
+    out.push_back({table_ndx, {}});
+
+    for (size_t i = 0, count = table.get_column_count(); i != count; ++i) {
+        auto type = table.get_column_type(i);
+        if (type == type_Link || type == type_LinkList) {
+            out[out_index].links.push_back({i, type == type_LinkList});
+            find_related_tables(out, *table.get_link_target(i));
+        }
+    }
+}
+
+DeepChangeChecker::DeepChangeChecker(TransactionChangeInfo const& info,
+                                     Table const& root_table,
+                                     std::vector<RelatedTable> const& related_tables)
+: m_info(info)
+, m_root_table(root_table)
+, m_root_table_ndx(root_table.get_index_in_group())
+, m_root_modifications(m_root_table_ndx < info.tables.size() ? &info.tables[m_root_table_ndx].modifications : nullptr)
+, m_related_tables(related_tables)
+{
+}
+
+bool DeepChangeChecker::check_outgoing_links(size_t table_ndx,
+                                             Table const& table,
+                                             size_t row_ndx, size_t depth)
+{
+    auto it = find_if(begin(m_related_tables), end(m_related_tables),
+                      [&](auto&& tbl) { return tbl.table_ndx == table_ndx; });
+    if (it == m_related_tables.end())
+        return false;
+
+    // Check if we're already checking if the destination of the link is
+    // modified, and if not add it to the stack
+    auto already_checking = [&](size_t col) {
+        for (auto p = m_current_path.begin(); p < m_current_path.begin() + depth; ++p) {
+            if (p->table == table_ndx && p->row == row_ndx && p->col == col)
+                return true;
+        }
+        m_current_path[depth] = {table_ndx, row_ndx, col, false};
+        return false;
+    };
+
+    for (auto const& link : it->links) {
+        if (already_checking(link.col_ndx))
+            continue;
+        if (!link.is_list) {
+            if (table.is_null_link(link.col_ndx, row_ndx))
+                continue;
+            auto dst = table.get_link(link.col_ndx, row_ndx);
+            return check_row(*table.get_link_target(link.col_ndx), dst, depth + 1);
+        }
+
+        auto& target = *table.get_link_target(link.col_ndx);
+        auto lvr = table.get_linklist(link.col_ndx, row_ndx);
+        for (size_t j = 0, size = lvr->size(); j < size; ++j) {
+            size_t dst = lvr->get(j).get_index();
+            if (check_row(target, dst, depth + 1))
+                return true;
+        }
+    }
+
+    return false;
+}
+
+bool DeepChangeChecker::check_row(Table const& table, size_t idx, size_t depth)
+{
+    // Arbitrary upper limit on the maximum depth to search
+    if (depth >= m_current_path.size()) {
+        // Don't mark any of the intermediate rows checked along the path as
+        // not modified, as a search starting from them might hit a modification
+        for (size_t i = 1; i < m_current_path.size(); ++i)
+            m_current_path[i].depth_exceeded = true;
+        return false;
+    }
+
+    size_t table_ndx = table.get_index_in_group();
+    if (depth > 0 && table_ndx < m_info.tables.size() && m_info.tables[table_ndx].modifications.contains(idx))
+        return true;
+
+    if (m_not_modified.size() <= table_ndx)
+        m_not_modified.resize(table_ndx + 1);
+    if (m_not_modified[table_ndx].contains(idx))
+        return false;
+
+    bool ret = check_outgoing_links(table_ndx, table, idx, depth);
+    if (!ret && !m_current_path[depth].depth_exceeded)
+        m_not_modified[table_ndx].add(idx);
+    return ret;
+}
+
+bool DeepChangeChecker::operator()(size_t ndx)
+{
+    if (m_root_modifications && m_root_modifications->contains(ndx))
+        return true;
+    return check_row(m_root_table, ndx, 0);
+}
+
+CollectionNotifier::CollectionNotifier(std::shared_ptr<Realm> realm)
+: m_realm(std::move(realm))
+, m_sg_version(Realm::Internal::get_shared_group(*m_realm).get_version_of_current_transaction())
+{
+}
+
+CollectionNotifier::~CollectionNotifier()
+{
+    // Need to do this explicitly to ensure m_realm is destroyed with the mutex
+    // held to avoid potential double-deletion
+    unregister();
+}
+
+size_t CollectionNotifier::add_callback(CollectionChangeCallback callback)
+{
+    m_realm->verify_thread();
+
+    auto next_token = [=] {
+        size_t token = 0;
+        for (auto& callback : m_callbacks) {
+            if (token <= callback.token) {
+                token = callback.token + 1;
+            }
+        }
+        return token;
+    };
+
+    std::lock_guard<std::mutex> lock(m_callback_mutex);
+    auto token = next_token();
+    m_callbacks.push_back({std::move(callback), token, false});
+    if (m_callback_index == npos) { // Don't need to wake up if we're already sending notifications
+        Realm::Internal::get_coordinator(*m_realm).send_commit_notifications();
+        m_have_callbacks = true;
+    }
+    return token;
+}
+
+void CollectionNotifier::remove_callback(size_t token)
+{
+    Callback old;
+    {
+        std::lock_guard<std::mutex> lock(m_callback_mutex);
+        REALM_ASSERT(m_error || m_callbacks.size() > 0);
+
+        auto it = find_if(begin(m_callbacks), end(m_callbacks),
+                          [=](const auto& c) { return c.token == token; });
+        // We should only fail to find the callback if it was removed due to an error
+        REALM_ASSERT(m_error || it != end(m_callbacks));
+        if (it == end(m_callbacks)) {
+            return;
+        }
+
+        size_t idx = distance(begin(m_callbacks), it);
+        if (m_callback_index != npos && m_callback_index >= idx) {
+            --m_callback_index;
+        }
+
+        old = std::move(*it);
+        m_callbacks.erase(it);
+
+        m_have_callbacks = !m_callbacks.empty();
+    }
+}
+
+void CollectionNotifier::unregister() noexcept
+{
+    std::lock_guard<std::mutex> lock(m_realm_mutex);
+    m_realm = nullptr;
+}
+
+bool CollectionNotifier::is_alive() const noexcept
+{
+    std::lock_guard<std::mutex> lock(m_realm_mutex);
+    return m_realm != nullptr;
+}
+
+std::unique_lock<std::mutex> CollectionNotifier::lock_target()
+{
+    return std::unique_lock<std::mutex>{m_realm_mutex};
+}
+
+void CollectionNotifier::set_table(Table const& table)
+{
+    m_related_tables.clear();
+    DeepChangeChecker::find_related_tables(m_related_tables, table);
+}
+
+void CollectionNotifier::add_required_change_info(TransactionChangeInfo& info)
+{
+    if (!do_add_required_change_info(info)) {
+        return;
+    }
+
+    auto max = max_element(begin(m_related_tables), end(m_related_tables),
+                           [](auto&& a, auto&& b) { return a.table_ndx < b.table_ndx; });
+
+    if (max->table_ndx >= info.table_modifications_needed.size())
+        info.table_modifications_needed.resize(max->table_ndx + 1, false);
+    for (auto& tbl : m_related_tables) {
+        info.table_modifications_needed[tbl.table_ndx] = true;
+    }
+}
+
+void CollectionNotifier::prepare_handover()
+{
+    REALM_ASSERT(m_sg);
+    m_sg_version = m_sg->get_version_of_current_transaction();
+    do_prepare_handover(*m_sg);
+}
+
+bool CollectionNotifier::deliver(Realm& realm, SharedGroup& sg, std::exception_ptr err)
+{
+    {
+        std::lock_guard<std::mutex> lock(m_realm_mutex);
+        if (m_realm.get() != &realm) {
+            return false;
+        }
+    }
+
+    if (err) {
+        m_error = err;
+        return have_callbacks();
+    }
+
+    auto realm_sg_version = sg.get_version_of_current_transaction();
+    if (version() != realm_sg_version) {
+        // Realm version can be newer if a commit was made on our thread or the
+        // user manually called refresh(), or older if a commit was made on a
+        // different thread and we ran *really* fast in between the check for
+        // if the shared group has changed and when we pick up async results
+        return false;
+    }
+
+    bool should_call_callbacks = do_deliver(sg);
+    m_changes_to_deliver = std::move(m_accumulated_changes);
+
+    // fixup modifications to be source rows rather than dest rows
+    // FIXME: the actual change calculations should be updated to just calculate
+    // the correct thing instead
+    m_changes_to_deliver.modifications.erase_at(m_changes_to_deliver.insertions);
+    m_changes_to_deliver.modifications.shift_for_insert_at(m_changes_to_deliver.deletions);
+
+    return should_call_callbacks && have_callbacks();
+}
+
+void CollectionNotifier::call_callbacks()
+{
+    while (auto fn = next_callback()) {
+        fn(m_changes_to_deliver, m_error);
+    }
+
+    if (m_error) {
+        // Remove all the callbacks as we never need to call anything ever again
+        // after delivering an error
+        std::lock_guard<std::mutex> callback_lock(m_callback_mutex);
+        m_callbacks.clear();
+    }
+}
+
+CollectionChangeCallback CollectionNotifier::next_callback()
+{
+    std::lock_guard<std::mutex> callback_lock(m_callback_mutex);
+
+    for (++m_callback_index; m_callback_index < m_callbacks.size(); ++m_callback_index) {
+        auto& callback = m_callbacks[m_callback_index];
+        if (!m_error && callback.initial_delivered && m_changes_to_deliver.empty()) {
+            continue;
+        }
+        callback.initial_delivered = true;
+        return callback.fn;
+    }
+
+    m_callback_index = npos;
+    return nullptr;
+}
+
+void CollectionNotifier::attach_to(SharedGroup& sg)
+{
+    REALM_ASSERT(!m_sg);
+
+    m_sg = &sg;
+    do_attach_to(sg);
+}
+
+void CollectionNotifier::detach()
+{
+    REALM_ASSERT(m_sg);
+    do_detach_from(*m_sg);
+    m_sg = nullptr;
+}
diff --git a/Pods/Realm/Realm/ObjectStore/impl/list_notifier.cpp b/Pods/Realm/Realm/ObjectStore/impl/list_notifier.cpp
new file mode 100644
index 0000000..64bf6da
--- /dev/null
+++ b/Pods/Realm/Realm/ObjectStore/impl/list_notifier.cpp
@@ -0,0 +1,122 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2016 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#include "impl/list_notifier.hpp"
+
+#include "shared_realm.hpp"
+
+#include <realm/link_view.hpp>
+
+using namespace realm;
+using namespace realm::_impl;
+
+ListNotifier::ListNotifier(LinkViewRef lv, std::shared_ptr<Realm> realm)
+: CollectionNotifier(std::move(realm))
+, m_prev_size(lv->size())
+{
+    // Find the lv's column, since that isn't tracked directly
+    size_t row_ndx = lv->get_origin_row_index();
+    m_col_ndx = not_found;
+    auto& table = lv->get_origin_table();
+    for (size_t i = 0, count = table.get_column_count(); i != count; ++i) {
+        if (table.get_column_type(i) == type_LinkList && table.get_linklist(i, row_ndx) == lv) {
+            m_col_ndx = i;
+            break;
+        }
+    }
+    REALM_ASSERT(m_col_ndx != not_found);
+
+    set_table(lv->get_target_table());
+
+    auto& sg = Realm::Internal::get_shared_group(*get_realm());
+    m_lv_handover = sg.export_linkview_for_handover(lv);
+}
+
+void ListNotifier::release_data() noexcept
+{
+    m_lv.reset();
+}
+
+void ListNotifier::do_attach_to(SharedGroup& sg)
+{
+    REALM_ASSERT(m_lv_handover);
+    REALM_ASSERT(!m_lv);
+    m_lv = sg.import_linkview_from_handover(std::move(m_lv_handover));
+}
+
+void ListNotifier::do_detach_from(SharedGroup& sg)
+{
+    REALM_ASSERT(!m_lv_handover);
+    if (m_lv) {
+        m_lv_handover = sg.export_linkview_for_handover(m_lv);
+        m_lv = {};
+    }
+}
+
+bool ListNotifier::do_add_required_change_info(TransactionChangeInfo& info)
+{
+    REALM_ASSERT(!m_lv_handover);
+    if (!m_lv || !m_lv->is_attached()) {
+        return false; // origin row was deleted after the notification was added
+    }
+
+    size_t row_ndx = m_lv->get_origin_row_index();
+    auto& table = m_lv->get_origin_table();
+    info.lists.push_back({table.get_index_in_group(), row_ndx, m_col_ndx, &m_change});
+
+    m_info = &info;
+    return true;
+}
+
+void ListNotifier::run()
+{
+    if (!m_lv || !m_lv->is_attached()) {
+        // LV was deleted, so report all of the rows being removed if this is
+        // the first run after that
+        if (m_prev_size) {
+            m_change.deletions.set(m_prev_size);
+            m_prev_size = 0;
+        }
+        else {
+            m_change = {};
+        }
+        return;
+    }
+
+    auto row_did_change = get_modification_checker(*m_info, m_lv->get_target_table());
+    for (size_t i = 0; i < m_lv->size(); ++i) {
+        if (m_change.modifications.contains(i))
+            continue;
+        if (row_did_change(m_lv->get(i).get_index()))
+            m_change.modifications.add(i);
+    }
+
+    for (auto const& move : m_change.moves) {
+        if (m_change.modifications.contains(move.to))
+            continue;
+        if (row_did_change(m_lv->get(move.to).get_index()))
+            m_change.modifications.add(move.to);
+    }
+
+    m_prev_size = m_lv->size();
+}
+
+void ListNotifier::do_prepare_handover(SharedGroup&)
+{
+    add_changes(std::move(m_change));
+}
diff --git a/Pods/Realm/Realm/ObjectStore/impl/realm_coordinator.cpp b/Pods/Realm/Realm/ObjectStore/impl/realm_coordinator.cpp
new file mode 100644
index 0000000..c3f44b1
--- /dev/null
+++ b/Pods/Realm/Realm/ObjectStore/impl/realm_coordinator.cpp
@@ -0,0 +1,600 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2015 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#include "impl/realm_coordinator.hpp"
+
+#include "impl/collection_notifier.hpp"
+#include "impl/external_commit_helper.hpp"
+#include "impl/transact_log_handler.hpp"
+#include "impl/weak_realm_notifier.hpp"
+#include "object_schema.hpp"
+#include "object_store.hpp"
+#include "schema.hpp"
+
+#include <realm/commit_log.hpp>
+#include <realm/group_shared.hpp>
+#include <realm/lang_bind_helper.hpp>
+#include <realm/string_data.hpp>
+
+#include <unordered_map>
+#include <algorithm>
+
+using namespace realm;
+using namespace realm::_impl;
+
+static std::mutex s_coordinator_mutex;
+static std::unordered_map<std::string, std::weak_ptr<RealmCoordinator>> s_coordinators_per_path;
+
+std::shared_ptr<RealmCoordinator> RealmCoordinator::get_coordinator(StringData path)
+{
+    std::lock_guard<std::mutex> lock(s_coordinator_mutex);
+
+    auto& weak_coordinator = s_coordinators_per_path[path];
+    if (auto coordinator = weak_coordinator.lock()) {
+        return coordinator;
+    }
+
+    auto coordinator = std::make_shared<RealmCoordinator>();
+    weak_coordinator = coordinator;
+    return coordinator;
+}
+
+std::shared_ptr<RealmCoordinator> RealmCoordinator::get_existing_coordinator(StringData path)
+{
+    std::lock_guard<std::mutex> lock(s_coordinator_mutex);
+    auto it = s_coordinators_per_path.find(path);
+    return it == s_coordinators_per_path.end() ? nullptr : it->second.lock();
+}
+
+std::shared_ptr<Realm> RealmCoordinator::get_realm(Realm::Config config)
+{
+    std::lock_guard<std::mutex> lock(m_realm_mutex);
+    if ((!m_config.read_only && !m_notifier) || (m_config.read_only && m_weak_realm_notifiers.empty())) {
+        m_config = config;
+        if (!config.read_only && !m_notifier && config.automatic_change_notifications) {
+            try {
+                m_notifier = std::make_unique<ExternalCommitHelper>(*this);
+            }
+            catch (std::system_error const& ex) {
+                throw RealmFileException(RealmFileException::Kind::AccessError, config.path, ex.code().message(), "");
+            }
+        }
+    }
+    else {
+        if (m_config.read_only != config.read_only) {
+            throw MismatchedConfigException("Realm at path '%1' already opened with different read permissions.", config.path);
+        }
+        if (m_config.in_memory != config.in_memory) {
+            throw MismatchedConfigException("Realm at path '%1' already opened with different inMemory settings.", config.path);
+        }
+        if (m_config.encryption_key != config.encryption_key) {
+            throw MismatchedConfigException("Realm at path '%1' already opened with a different encryption key.", config.path);
+        }
+        if (m_config.schema_version != config.schema_version && config.schema_version != ObjectStore::NotVersioned) {
+            throw MismatchedConfigException("Realm at path '%1' already opened with different schema version.", config.path);
+        }
+        // FIXME: verify that schema is compatible
+        // Needs to verify that all tables present in both are identical, and
+        // then updated m_config with any tables present in config but not in
+        // it
+        // Public API currently doesn't make it possible to have non-matching
+        // schemata so it's not a huge issue
+        if ((false) && m_config.schema != config.schema) {
+            throw MismatchedConfigException("Realm at path '%1' already opened with different schema", config.path);
+        }
+    }
+
+    if (config.cache) {
+        for (auto& cachedRealm : m_weak_realm_notifiers) {
+            if (cachedRealm.is_cached_for_current_thread()) {
+                // can be null if we jumped in between ref count hitting zero and
+                // unregister_realm() getting the lock
+                if (auto realm = cachedRealm.realm()) {
+                    return realm;
+                }
+            }
+        }
+    }
+
+    auto realm = std::make_shared<Realm>(std::move(config));
+    realm->init(shared_from_this());
+    m_weak_realm_notifiers.emplace_back(realm, m_config.cache);
+    return realm;
+}
+
+std::shared_ptr<Realm> RealmCoordinator::get_realm()
+{
+    return get_realm(m_config);
+}
+
+const Schema* RealmCoordinator::get_schema() const noexcept
+{
+    return m_weak_realm_notifiers.empty() ? nullptr : m_config.schema.get();
+}
+
+void RealmCoordinator::update_schema(Schema const& schema)
+{
+    // FIXME: this should probably be doing some sort of validation and
+    // notifying all Realm instances of the new schema in some way
+    m_config.schema = std::make_unique<Schema>(schema);
+}
+
+RealmCoordinator::RealmCoordinator() = default;
+
+RealmCoordinator::~RealmCoordinator()
+{
+    std::lock_guard<std::mutex> coordinator_lock(s_coordinator_mutex);
+    for (auto it = s_coordinators_per_path.begin(); it != s_coordinators_per_path.end(); ) {
+        if (it->second.expired()) {
+            it = s_coordinators_per_path.erase(it);
+        }
+        else {
+            ++it;
+        }
+    }
+}
+
+void RealmCoordinator::unregister_realm(Realm* realm)
+{
+    std::lock_guard<std::mutex> lock(m_realm_mutex);
+    auto new_end = remove_if(begin(m_weak_realm_notifiers), end(m_weak_realm_notifiers),
+                             [=](auto& notifier) { return notifier.expired() || notifier.is_for_realm(realm); });
+    m_weak_realm_notifiers.erase(new_end, end(m_weak_realm_notifiers));
+}
+
+void RealmCoordinator::clear_cache()
+{
+    std::vector<WeakRealm> realms_to_close;
+    {
+        std::lock_guard<std::mutex> lock(s_coordinator_mutex);
+
+        for (auto& weak_coordinator : s_coordinators_per_path) {
+            auto coordinator = weak_coordinator.second.lock();
+            if (!coordinator) {
+                continue;
+            }
+
+            coordinator->m_notifier = nullptr;
+
+            // Gather a list of all of the realms which will be removed
+            for (auto& weak_realm_notifier : coordinator->m_weak_realm_notifiers) {
+                if (auto realm = weak_realm_notifier.realm()) {
+                    realms_to_close.push_back(realm);
+                }
+            }
+        }
+
+        s_coordinators_per_path.clear();
+    }
+
+    // Close all of the previously cached Realms. This can't be done while
+    // s_coordinator_mutex is held as it may try to re-lock it.
+    for (auto& weak_realm : realms_to_close) {
+        if (auto realm = weak_realm.lock()) {
+            realm->close();
+        }
+    }
+}
+
+void RealmCoordinator::clear_all_caches()
+{
+    std::vector<std::weak_ptr<RealmCoordinator>> to_clear;
+    {
+        std::lock_guard<std::mutex> lock(s_coordinator_mutex);
+        for (auto iter : s_coordinators_per_path) {
+            to_clear.push_back(iter.second);
+        }
+    }
+    for (auto weak_coordinator : to_clear) {
+        if (auto coordinator = weak_coordinator.lock()) {
+            coordinator->clear_cache();
+        }
+    }
+}
+
+void RealmCoordinator::send_commit_notifications()
+{
+    REALM_ASSERT(!m_config.read_only);
+    if (m_notifier) {
+        m_notifier->notify_others();
+    }
+}
+
+void RealmCoordinator::pin_version(uint_fast64_t version, uint_fast32_t index)
+{
+    if (m_async_error) {
+        return;
+    }
+
+    SharedGroup::VersionID versionid(version, index);
+    if (!m_advancer_sg) {
+        try {
+            std::unique_ptr<Group> read_only_group;
+            Realm::open_with_config(m_config, m_advancer_history, m_advancer_sg, read_only_group);
+            REALM_ASSERT(!read_only_group);
+            m_advancer_sg->begin_read(versionid);
+        }
+        catch (...) {
+            m_async_error = std::current_exception();
+            m_advancer_sg = nullptr;
+            m_advancer_history = nullptr;
+        }
+    }
+    else if (m_new_notifiers.empty()) {
+        // If this is the first notifier then we don't already have a read transaction
+        REALM_ASSERT_3(m_advancer_sg->get_transact_stage(), ==, SharedGroup::transact_Ready);
+        m_advancer_sg->begin_read(versionid);
+    }
+    else {
+        REALM_ASSERT_3(m_advancer_sg->get_transact_stage(), ==, SharedGroup::transact_Reading);
+        if (versionid < m_advancer_sg->get_version_of_current_transaction()) {
+            // Ensure we're holding a readlock on the oldest version we have a
+            // handover object for, as handover objects don't
+            m_advancer_sg->end_read();
+            m_advancer_sg->begin_read(versionid);
+        }
+    }
+}
+
+void RealmCoordinator::register_notifier(std::shared_ptr<CollectionNotifier> notifier)
+{
+    auto version = notifier->version();
+    auto& self = Realm::Internal::get_coordinator(*notifier->get_realm());
+    {
+        std::lock_guard<std::mutex> lock(self.m_notifier_mutex);
+        self.pin_version(version.version, version.index);
+        self.m_new_notifiers.push_back(std::move(notifier));
+    }
+}
+
+void RealmCoordinator::clean_up_dead_notifiers()
+{
+    auto swap_remove = [&](auto& container) {
+        bool did_remove = false;
+        for (size_t i = 0; i < container.size(); ++i) {
+            if (container[i]->is_alive())
+                continue;
+
+            // Ensure the notifier is destroyed here even if there's lingering refs
+            // to the async notifier elsewhere
+            container[i]->release_data();
+
+            if (container.size() > i + 1)
+                container[i] = std::move(container.back());
+            container.pop_back();
+            --i;
+            did_remove = true;
+        }
+        return did_remove;
+    };
+
+    if (swap_remove(m_notifiers)) {
+        // Make sure we aren't holding on to read versions needlessly if there
+        // are no notifiers left, but don't close them entirely as opening shared
+        // groups is expensive
+        if (m_notifiers.empty() && m_notifier_sg) {
+            REALM_ASSERT_3(m_notifier_sg->get_transact_stage(), ==, SharedGroup::transact_Reading);
+            m_notifier_sg->end_read();
+        }
+    }
+    if (swap_remove(m_new_notifiers)) {
+        REALM_ASSERT_3(m_advancer_sg->get_transact_stage(), ==, SharedGroup::transact_Reading);
+        if (m_new_notifiers.empty() && m_advancer_sg) {
+            m_advancer_sg->end_read();
+        }
+    }
+}
+
+void RealmCoordinator::on_change()
+{
+    run_async_notifiers();
+
+    std::lock_guard<std::mutex> lock(m_realm_mutex);
+    for (auto& realm : m_weak_realm_notifiers) {
+        realm.notify();
+    }
+}
+
+namespace {
+class IncrementalChangeInfo {
+public:
+    IncrementalChangeInfo(SharedGroup& sg,
+                          std::vector<std::shared_ptr<_impl::CollectionNotifier>>& notifiers)
+    : m_sg(sg)
+    {
+        if (notifiers.empty())
+            return;
+
+        auto cmp = [&](auto&& lft, auto&& rgt) {
+            return lft->version() < rgt->version();
+        };
+
+        // Sort the notifiers by their source version so that we can pull them
+        // all forward to the latest version in a single pass over the transaction log
+        std::sort(notifiers.begin(), notifiers.end(), cmp);
+
+        // Preallocate the required amount of space in the vector so that we can
+        // safely give out pointers to within the vector
+        size_t count = 1;
+        for (auto it = notifiers.begin(), next = it + 1; next != notifiers.end(); ++it, ++next) {
+            if (cmp(*it, *next))
+                ++count;
+        }
+        m_info.reserve(count);
+        m_info.resize(1);
+        m_current = &m_info[0];
+    }
+
+    TransactionChangeInfo& current() const { return *m_current; }
+
+    bool advance_incremental(SharedGroup::VersionID version)
+    {
+        if (version != m_sg.get_version_of_current_transaction()) {
+            transaction::advance(m_sg, *m_current, version);
+            m_info.push_back({
+                m_current->table_modifications_needed,
+                m_current->table_moves_needed,
+                std::move(m_current->lists)});
+            m_current = &m_info.back();
+            return true;
+        }
+        return false;
+    }
+
+    void advance_to_final(SharedGroup::VersionID version)
+    {
+        if (!m_current) {
+            transaction::advance(m_sg, nullptr, version);
+            return;
+        }
+
+        transaction::advance(m_sg, *m_current, version);
+
+        // We now need to combine the transaction change info objects so that all of
+        // the notifiers see the complete set of changes from their first version to
+        // the most recent one
+        for (size_t i = m_info.size() - 1; i > 0; --i) {
+            auto& cur = m_info[i];
+            if (cur.tables.empty())
+                continue;
+            auto& prev = m_info[i - 1];
+            if (prev.tables.empty()) {
+                prev.tables = cur.tables;
+                continue;
+            }
+
+            for (size_t j = 0; j < prev.tables.size() && j < cur.tables.size(); ++j) {
+                prev.tables[j].merge(CollectionChangeBuilder{cur.tables[j]});
+            }
+            prev.tables.reserve(cur.tables.size());
+            while (prev.tables.size() < cur.tables.size()) {
+                prev.tables.push_back(cur.tables[prev.tables.size()]);
+            }
+        }
+
+        // Copy the list change info if there are multiple LinkViews for the same LinkList
+        auto id = [](auto const& list) { return std::tie(list.table_ndx, list.col_ndx, list.row_ndx); };
+        for (size_t i = 1; i < m_current->lists.size(); ++i) {
+            for (size_t j = i; j > 0; --j) {
+                if (id(m_current->lists[i]) == id(m_current->lists[j - 1])) {
+                    m_current->lists[j - 1].changes->merge(CollectionChangeBuilder{*m_current->lists[i].changes});
+                }
+            }
+        }
+    }
+
+private:
+    std::vector<TransactionChangeInfo> m_info;
+    TransactionChangeInfo* m_current = nullptr;
+    SharedGroup& m_sg;
+};
+} // anonymous namespace
+
+void RealmCoordinator::run_async_notifiers()
+{
+    std::unique_lock<std::mutex> lock(m_notifier_mutex);
+
+    clean_up_dead_notifiers();
+
+    if (m_notifiers.empty() && m_new_notifiers.empty()) {
+        return;
+    }
+
+    if (!m_async_error) {
+        open_helper_shared_group();
+    }
+
+    if (m_async_error) {
+        std::move(m_new_notifiers.begin(), m_new_notifiers.end(), std::back_inserter(m_notifiers));
+        m_new_notifiers.clear();
+        return;
+    }
+
+    SharedGroup::VersionID version;
+
+    // Advance all of the new notifiers to the most recent version, if any
+    auto new_notifiers = std::move(m_new_notifiers);
+    IncrementalChangeInfo new_notifier_change_info(*m_advancer_sg, new_notifiers);
+
+    if (!new_notifiers.empty()) {
+        REALM_ASSERT_3(m_advancer_sg->get_transact_stage(), ==, SharedGroup::transact_Reading);
+        REALM_ASSERT_3(m_advancer_sg->get_version_of_current_transaction().version,
+                       <=, new_notifiers.front()->version().version);
+
+        // The advancer SG can be at an older version than the oldest new notifier
+        // if a notifier was added and then removed before it ever got the chance
+        // to run, as we don't move the pin forward when removing dead notifiers
+        transaction::advance(*m_advancer_sg, nullptr, new_notifiers.front()->version());
+
+        // Advance each of the new notifiers to the latest version, attaching them
+        // to the SG at their handover version. This requires a unique
+        // TransactionChangeInfo for each source version, so that things don't
+        // see changes from before the version they were handed over from.
+        // Each Info has all of the changes between that source version and the
+        // next source version, and they'll be merged together later after
+        // releasing the lock
+        for (auto& notifier : new_notifiers) {
+            new_notifier_change_info.advance_incremental(notifier->version());
+            notifier->attach_to(*m_advancer_sg);
+            notifier->add_required_change_info(new_notifier_change_info.current());
+        }
+        new_notifier_change_info.advance_to_final(SharedGroup::VersionID{});
+
+        for (auto& notifier : new_notifiers) {
+            notifier->detach();
+        }
+        version = m_advancer_sg->get_version_of_current_transaction();
+        m_advancer_sg->end_read();
+    }
+    REALM_ASSERT_3(m_advancer_sg->get_transact_stage(), ==, SharedGroup::transact_Ready);
+
+    // Make a copy of the notifiers vector and then release the lock to avoid
+    // blocking other threads trying to register or unregister notifiers while we run them
+    auto notifiers = m_notifiers;
+    lock.unlock();
+
+    // Advance the non-new notifiers to the same version as we advanced the new
+    // ones to (or the latest if there were no new ones)
+    IncrementalChangeInfo change_info(*m_notifier_sg, notifiers);
+    for (auto& notifier : notifiers) {
+        notifier->add_required_change_info(change_info.current());
+    }
+    change_info.advance_to_final(version);
+
+    // Attach the new notifiers to the main SG and move them to the main list
+    for (auto& notifier : new_notifiers) {
+        notifier->attach_to(*m_notifier_sg);
+    }
+    std::move(new_notifiers.begin(), new_notifiers.end(), std::back_inserter(notifiers));
+
+    // Change info is now all ready, so the notifiers can now perform their
+    // background work
+    for (auto& notifier : notifiers) {
+        notifier->run();
+    }
+
+    // Reacquire the lock while updating the fields that are actually read on
+    // other threads
+    lock.lock();
+    for (auto& notifier : notifiers) {
+        notifier->prepare_handover();
+    }
+    m_notifiers = std::move(notifiers);
+    clean_up_dead_notifiers();
+}
+
+void RealmCoordinator::open_helper_shared_group()
+{
+    if (!m_notifier_sg) {
+        try {
+            std::unique_ptr<Group> read_only_group;
+            Realm::open_with_config(m_config, m_notifier_history, m_notifier_sg, read_only_group);
+            REALM_ASSERT(!read_only_group);
+            m_notifier_sg->begin_read();
+        }
+        catch (...) {
+            // Store the error to be passed to the async notifiers
+            m_async_error = std::current_exception();
+            m_notifier_sg = nullptr;
+            m_notifier_history = nullptr;
+        }
+    }
+    else if (m_notifiers.empty()) {
+        m_notifier_sg->begin_read();
+    }
+}
+
+void RealmCoordinator::advance_to_ready(Realm& realm)
+{
+    decltype(m_notifiers) notifiers;
+
+    auto& sg = Realm::Internal::get_shared_group(realm);
+
+    auto get_notifier_version = [&] {
+        for (auto& notifier : m_notifiers) {
+            auto version = notifier->version();
+            if (version != SharedGroup::VersionID{}) {
+                return version;
+            }
+        }
+        return SharedGroup::VersionID{};
+    };
+
+    SharedGroup::VersionID version;
+    {
+        std::lock_guard<std::mutex> lock(m_notifier_mutex);
+        version = get_notifier_version();
+    }
+
+    // no async notifiers; just advance to latest
+    if (version.version == std::numeric_limits<uint_fast64_t>::max()) {
+        transaction::advance(sg, realm.m_binding_context.get());
+        return;
+    }
+
+    // async results are out of date; ignore
+    if (version < sg.get_version_of_current_transaction()) {
+        return;
+    }
+
+    while (true) {
+        // Advance to the ready version without holding any locks because it
+        // may end up calling user code (in did_change() notifications)
+        transaction::advance(sg, realm.m_binding_context.get(), version);
+
+        // Reacquire the lock and recheck the notifier version, as the notifiers may
+        // have advanced to a later version while we didn't hold the lock. If
+        // so, we need to release the lock and re-advance
+        std::lock_guard<std::mutex> lock(m_notifier_mutex);
+        version = get_notifier_version();
+        if (version.version == std::numeric_limits<uint_fast64_t>::max())
+            return;
+        if (version != sg.get_version_of_current_transaction())
+            continue;
+
+        // Query version now matches the SG version, so we can deliver them
+        for (auto& notifier : m_notifiers) {
+            if (notifier->deliver(realm, sg, m_async_error)) {
+                notifiers.push_back(notifier);
+            }
+        }
+        break;
+    }
+
+    for (auto& notifier : notifiers) {
+        notifier->call_callbacks();
+    }
+}
+
+void RealmCoordinator::process_available_async(Realm& realm)
+{
+    auto& sg = Realm::Internal::get_shared_group(realm);
+    decltype(m_notifiers) notifiers;
+    {
+        std::lock_guard<std::mutex> lock(m_notifier_mutex);
+        for (auto& notifier : m_notifiers) {
+            if (notifier->deliver(realm, sg, m_async_error)) {
+                notifiers.push_back(notifier);
+            }
+        }
+    }
+
+    for (auto& notifier : notifiers) {
+        notifier->call_callbacks();
+    }
+}
diff --git a/Pods/Realm/Realm/ObjectStore/impl/results_notifier.cpp b/Pods/Realm/Realm/ObjectStore/impl/results_notifier.cpp
new file mode 100644
index 0000000..eea290c
--- /dev/null
+++ b/Pods/Realm/Realm/ObjectStore/impl/results_notifier.cpp
@@ -0,0 +1,217 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2015 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#include "impl/results_notifier.hpp"
+
+using namespace realm;
+using namespace realm::_impl;
+
+ResultsNotifier::ResultsNotifier(Results& target)
+: CollectionNotifier(target.get_realm())
+, m_target_results(&target)
+, m_sort(target.get_sort())
+, m_target_is_in_table_order(target.is_in_table_order())
+{
+    Query q = target.get_query();
+    set_table(*q.get_table());
+    m_query_handover = Realm::Internal::get_shared_group(*get_realm()).export_for_handover(q, MutableSourcePayload::Move);
+}
+
+void ResultsNotifier::target_results_moved(Results& old_target, Results& new_target)
+{
+    auto lock = lock_target();
+
+    REALM_ASSERT(m_target_results == &old_target);
+    m_target_results = &new_target;
+}
+
+void ResultsNotifier::release_data() noexcept
+{
+    m_query = nullptr;
+}
+
+// Most of the inter-thread synchronization for run(), prepare_handover(),
+// attach_to(), detach(), release_data() and deliver() is done by
+// RealmCoordinator external to this code, which has some potentially
+// non-obvious results on which members are and are not safe to use without
+// holding a lock.
+//
+// add_required_change_info(), attach_to(), detach(), run(),
+// prepare_handover(), and release_data() are all only ever called on a single
+// background worker thread. call_callbacks() and deliver() are called on the
+// target thread. Calls to prepare_handover() and deliver() are guarded by a
+// lock.
+//
+// In total, this means that the safe data flow is as follows:
+//  - add_Required_change_info(), prepare_handover(), attach_to(), detach() and
+//    release_data() can read members written by each other
+//  - deliver() can read members written to in prepare_handover(), deliver(),
+//    and call_callbacks()
+//  - call_callbacks() and read members written to in deliver()
+//
+// Separately from the handover data flow, m_target_results is guarded by the target lock
+
+bool ResultsNotifier::do_add_required_change_info(TransactionChangeInfo& info)
+{
+    REALM_ASSERT(m_query);
+    m_info = &info;
+
+    auto table_ndx = m_query->get_table()->get_index_in_group();
+    if (info.table_moves_needed.size() <= table_ndx)
+        info.table_moves_needed.resize(table_ndx + 1);
+    info.table_moves_needed[table_ndx] = true;
+
+    return m_initial_run_complete && have_callbacks();
+}
+
+bool ResultsNotifier::need_to_run()
+{
+    REALM_ASSERT(m_info);
+    REALM_ASSERT(!m_tv.is_attached());
+
+    {
+        auto lock = lock_target();
+        // Don't run the query if the results aren't actually going to be used
+        if (!get_realm() || (!have_callbacks() && !m_target_results->wants_background_updates())) {
+            return false;
+        }
+    }
+
+    // If we've run previously, check if we need to rerun
+    if (m_initial_run_complete && m_query->sync_view_if_needed() == m_last_seen_version) {
+        return false;
+    }
+
+    return true;
+}
+
+void ResultsNotifier::calculate_changes()
+{
+    size_t table_ndx = m_query->get_table()->get_index_in_group();
+    if (m_initial_run_complete) {
+        auto changes = table_ndx < m_info->tables.size() ? &m_info->tables[table_ndx] : nullptr;
+
+        std::vector<size_t> next_rows;
+        next_rows.reserve(m_tv.size());
+        for (size_t i = 0; i < m_tv.size(); ++i)
+            next_rows.push_back(m_tv[i].get_index());
+
+        if (changes) {
+            auto const& moves = changes->moves;
+            for (auto& idx : m_previous_rows) {
+                auto it = lower_bound(begin(moves), end(moves), idx,
+                                      [](auto const& a, auto b) { return a.from < b; });
+                if (it != moves.end() && it->from == idx)
+                    idx = it->to;
+                else if (changes->deletions.contains(idx))
+                    idx = npos;
+                else
+                    REALM_ASSERT_DEBUG(!changes->insertions.contains(idx));
+            }
+        }
+
+        m_changes = CollectionChangeBuilder::calculate(m_previous_rows, next_rows,
+                                                       get_modification_checker(*m_info, *m_query->get_table()),
+                                                       m_target_is_in_table_order && !m_sort);
+
+        m_previous_rows = std::move(next_rows);
+    }
+    else {
+        m_previous_rows.resize(m_tv.size());
+        for (size_t i = 0; i < m_tv.size(); ++i)
+            m_previous_rows[i] = m_tv[i].get_index();
+    }
+}
+
+void ResultsNotifier::run()
+{
+    if (!need_to_run())
+        return;
+
+    m_query->sync_view_if_needed();
+    m_tv = m_query->find_all();
+    if (m_sort) {
+        m_tv.sort(m_sort.column_indices, m_sort.ascending);
+    }
+    m_last_seen_version = m_tv.sync_if_needed();
+
+    calculate_changes();
+}
+
+void ResultsNotifier::do_prepare_handover(SharedGroup& sg)
+{
+    if (!m_tv.is_attached()) {
+        return;
+    }
+
+    REALM_ASSERT(m_tv.is_in_sync());
+
+    m_initial_run_complete = true;
+    m_tv_handover = sg.export_for_handover(m_tv, MutableSourcePayload::Move);
+
+    add_changes(std::move(m_changes));
+    REALM_ASSERT(m_changes.empty());
+
+    // detach the TableView as we won't need it again and keeping it around
+    // makes advance_read() much more expensive
+    m_tv = {};
+}
+
+bool ResultsNotifier::do_deliver(SharedGroup& sg)
+{
+    auto lock = lock_target();
+
+    // Target realm being null here indicates that we were unregistered while we
+    // were in the process of advancing the Realm version and preparing for
+    // delivery, i.e. the results was destroyed from the "wrong" thread
+    if (!get_realm()) {
+        return false;
+    }
+
+    // We can get called before the query has actually had the chance to run if
+    // we're added immediately before a different set of async results are
+    // delivered
+    if (!m_initial_run_complete) {
+        return false;
+    }
+
+    REALM_ASSERT(!m_query_handover);
+
+    if (m_tv_handover) {
+        m_tv_handover->version = version();
+        Results::Internal::set_table_view(*m_target_results,
+                                          std::move(*sg.import_from_handover(std::move(m_tv_handover))));
+    }
+    REALM_ASSERT(!m_tv_handover);
+    return true;
+}
+
+void ResultsNotifier::do_attach_to(SharedGroup& sg)
+{
+    REALM_ASSERT(m_query_handover);
+    m_query = sg.import_from_handover(std::move(m_query_handover));
+}
+
+void ResultsNotifier::do_detach_from(SharedGroup& sg)
+{
+    REALM_ASSERT(m_query);
+    REALM_ASSERT(!m_tv.is_attached());
+
+    m_query_handover = sg.export_for_handover(*m_query, MutableSourcePayload::Move);
+    m_query = nullptr;
+}
diff --git a/Pods/Realm/Realm/ObjectStore/impl/transact_log_handler.cpp b/Pods/Realm/Realm/ObjectStore/impl/transact_log_handler.cpp
new file mode 100644
index 0000000..85d44bd
--- /dev/null
+++ b/Pods/Realm/Realm/ObjectStore/impl/transact_log_handler.cpp
@@ -0,0 +1,620 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2015 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#include "impl/transact_log_handler.hpp"
+
+#include "binding_context.hpp"
+#include "impl/collection_notifier.hpp"
+#include "index_set.hpp"
+
+#include <realm/group_shared.hpp>
+#include <realm/lang_bind_helper.hpp>
+#include <algorithm>
+
+using namespace realm;
+
+namespace {
+template<typename Derived>
+struct MarkDirtyMixin  {
+    bool mark_dirty(size_t row, size_t col) { static_cast<Derived *>(this)->mark_dirty(row, col); return true; }
+
+    bool set_int(size_t col, size_t row, int_fast64_t) { return mark_dirty(row, col); }
+    bool set_bool(size_t col, size_t row, bool) { return mark_dirty(row, col); }
+    bool set_float(size_t col, size_t row, float) { return mark_dirty(row, col); }
+    bool set_double(size_t col, size_t row, double) { return mark_dirty(row, col); }
+    bool set_string(size_t col, size_t row, StringData) { return mark_dirty(row, col); }
+    bool set_binary(size_t col, size_t row, BinaryData) { return mark_dirty(row, col); }
+    bool set_olddatetime(size_t col, size_t row, OldDateTime) { return mark_dirty(row, col); }
+    bool set_timestamp(size_t col, size_t row, Timestamp) { return mark_dirty(row, col); }
+    bool set_table(size_t col, size_t row) { return mark_dirty(row, col); }
+    bool set_mixed(size_t col, size_t row, const Mixed&) { return mark_dirty(row, col); }
+    bool set_link(size_t col, size_t row, size_t, size_t) { return mark_dirty(row, col); }
+    bool set_null(size_t col, size_t row) { return mark_dirty(row, col); }
+    bool nullify_link(size_t col, size_t row, size_t) { return mark_dirty(row, col); }
+    bool set_int_unique(size_t col, size_t row, size_t, int_fast64_t) { return mark_dirty(row, col); }
+    bool set_string_unique(size_t col, size_t row, size_t, StringData) { return mark_dirty(row, col); }
+    bool insert_substring(size_t col, size_t row, size_t, StringData) { return mark_dirty(row, col); }
+    bool erase_substring(size_t col, size_t row, size_t, size_t) { return mark_dirty(row, col); }
+};
+
+class TransactLogValidationMixin {
+    // Index of currently selected table
+    size_t m_current_table = 0;
+
+    // Tables which were created during the transaction being processed, which
+    // can have columns inserted without a schema version bump
+    std::vector<size_t> m_new_tables;
+
+    REALM_NORETURN
+    REALM_NOINLINE
+    void schema_error()
+    {
+        throw std::runtime_error("Schema mismatch detected: another process has modified the Realm file's schema in an incompatible way");
+    }
+
+    // Throw an exception if the currently modified table already existed before
+    // the current set of modifications
+    bool schema_error_unless_new_table()
+    {
+        if (std::find(begin(m_new_tables), end(m_new_tables), m_current_table) == end(m_new_tables)) {
+            schema_error();
+        }
+        return true;
+    }
+
+protected:
+    size_t current_table() const noexcept { return m_current_table; }
+
+public:
+    // Schema changes which don't involve a change in the schema version are
+    // allowed
+    bool add_search_index(size_t) { return true; }
+    bool remove_search_index(size_t) { return true; }
+
+    // Creating entirely new tables without a schema version bump is allowed, so
+    // we need to track if new columns are being added to a new table or an
+    // existing one
+    bool insert_group_level_table(size_t table_ndx, size_t, StringData)
+    {
+        // Shift any previously added tables after the new one
+        for (auto& table : m_new_tables) {
+            if (table >= table_ndx)
+                ++table;
+        }
+        m_new_tables.push_back(table_ndx);
+        return true;
+    }
+    bool insert_column(size_t, DataType, StringData, bool) { return schema_error_unless_new_table(); }
+    bool insert_link_column(size_t, DataType, StringData, size_t, size_t) { return schema_error_unless_new_table(); }
+    bool set_link_type(size_t, LinkType) { return schema_error_unless_new_table(); }
+
+    // Removing or renaming things while a Realm is open is never supported
+    bool erase_group_level_table(size_t, size_t) { schema_error(); }
+    bool rename_group_level_table(size_t, StringData) { schema_error(); }
+    bool erase_column(size_t) { schema_error(); }
+    bool erase_link_column(size_t, size_t, size_t) { schema_error(); }
+    bool rename_column(size_t, StringData) { schema_error(); }
+    bool move_column(size_t, size_t) { schema_error(); }
+    bool move_group_level_table(size_t, size_t) { schema_error(); }
+
+    bool select_descriptor(int levels, const size_t*)
+    {
+        // subtables not supported
+        return levels == 0;
+    }
+
+    bool select_table(size_t group_level_ndx, int, const size_t*) noexcept
+    {
+        m_current_table = group_level_ndx;
+        return true;
+    }
+
+    bool select_link_list(size_t, size_t, size_t) { return true; }
+
+    // Non-schema changes are all allowed
+    void parse_complete() { }
+    bool insert_empty_rows(size_t, size_t, size_t, bool) { return true; }
+    bool erase_rows(size_t, size_t, size_t, bool) { return true; }
+    bool swap_rows(size_t, size_t) { return true; }
+    bool clear_table() noexcept { return true; }
+    bool link_list_set(size_t, size_t) { return true; }
+    bool link_list_insert(size_t, size_t) { return true; }
+    bool link_list_erase(size_t) { return true; }
+    bool link_list_nullify(size_t) { return true; }
+    bool link_list_clear(size_t) { return true; }
+    bool link_list_move(size_t, size_t) { return true; }
+    bool link_list_swap(size_t, size_t) { return true; }
+    bool change_link_targets(size_t, size_t) { return true; }
+    bool optimize_table() { return true; }
+};
+
+
+// A transaction log handler that just validates that all operations made are
+// ones supported by the object store
+struct TransactLogValidator : public TransactLogValidationMixin, public MarkDirtyMixin<TransactLogValidator> {
+    void mark_dirty(size_t, size_t) { }
+};
+
+// Extends TransactLogValidator to also track changes and report it to the
+// binding context if any properties are being observed
+class TransactLogObserver : public TransactLogValidationMixin, public MarkDirtyMixin<TransactLogObserver> {
+    using ColumnInfo = BindingContext::ColumnInfo;
+    using ObserverState = BindingContext::ObserverState;
+
+    // Observed table rows which need change information
+    std::vector<ObserverState> m_observers;
+    // Userdata pointers for rows which have been deleted
+    std::vector<void *> invalidated;
+    // Delegate to send change information to
+    BindingContext* m_context;
+
+    // Change information for the currently selected LinkList, if any
+    ColumnInfo* m_active_linklist = nullptr;
+
+    // Tables which were created during the transaction being processed, which
+    // can have columns inserted without a schema version bump
+    std::vector<size_t> m_new_tables;
+
+    // Get the change info for the given column, creating it if needed
+    static ColumnInfo& get_change(ObserverState& state, size_t i)
+    {
+        if (state.changes.size() <= i) {
+            state.changes.resize(std::max(state.changes.size() * 2, i + 1));
+        }
+        return state.changes[i];
+    }
+
+    // Loop over the columns which were changed in an observer state
+    template<typename Func>
+    static void for_each(ObserverState& state, Func&& f)
+    {
+        for (size_t i = 0; i < state.changes.size(); ++i) {
+            auto const& change = state.changes[i];
+            if (change.changed) {
+                f(i, change);
+            }
+        }
+    }
+
+    // Remove the given observer from the list of observed objects and add it
+    // to the listed of invalidated objects
+    void invalidate(ObserverState *o)
+    {
+        invalidated.push_back(o->info);
+        m_observers.erase(m_observers.begin() + (o - &m_observers[0]));
+    }
+
+public:
+    template<typename Func>
+    TransactLogObserver(BindingContext* context, SharedGroup& sg, Func&& func, bool validate_schema_changes)
+    : m_context(context)
+    {
+        if (!context) {
+            if (validate_schema_changes) {
+                func(TransactLogValidator());
+            }
+            else {
+                func();
+            }
+            return;
+        }
+
+        m_observers = context->get_observed_rows();
+        if (m_observers.empty()) {
+            auto old_version = sg.get_version_of_current_transaction();
+            if (validate_schema_changes) {
+                func(TransactLogValidator());
+            }
+            else {
+                func();
+            }
+            if (old_version != sg.get_version_of_current_transaction()) {
+                context->did_change({}, {});
+            }
+            return;
+        }
+
+        func(*this);
+        context->did_change(m_observers, invalidated);
+    }
+
+    // Mark the given row/col as needing notifications sent
+    void mark_dirty(size_t row_ndx, size_t col_ndx)
+    {
+        auto it = lower_bound(begin(m_observers), end(m_observers), ObserverState{current_table(), row_ndx, nullptr});
+        if (it != end(m_observers) && it->table_ndx == current_table() && it->row_ndx == row_ndx) {
+            get_change(*it, col_ndx).changed = true;
+        }
+    }
+
+    // Called at the end of the transaction log immediately before the version
+    // is advanced
+    void parse_complete()
+    {
+        m_context->will_change(m_observers, invalidated);
+    }
+
+    bool insert_group_level_table(size_t table_ndx, size_t prior_size, StringData name)
+    {
+        for (auto& observer : m_observers) {
+            if (observer.table_ndx >= table_ndx)
+                ++observer.table_ndx;
+        }
+        TransactLogValidationMixin::insert_group_level_table(table_ndx, prior_size, name);
+        return true;
+    }
+
+    bool insert_empty_rows(size_t, size_t, size_t, bool)
+    {
+        // rows are only inserted at the end, so no need to do anything
+        return true;
+    }
+
+    bool erase_rows(size_t row_ndx, size_t, size_t last_row_ndx, bool unordered)
+    {
+        for (size_t i = 0; i < m_observers.size(); ++i) {
+            auto& o = m_observers[i];
+            if (o.table_ndx == current_table()) {
+                if (o.row_ndx == row_ndx) {
+                    invalidate(&o);
+                    --i;
+                }
+                else if (unordered && o.row_ndx == last_row_ndx) {
+                    o.row_ndx = row_ndx;
+                }
+                else if (!unordered && o.row_ndx > row_ndx) {
+                    o.row_ndx -= 1;
+                }
+            }
+        }
+        return true;
+    }
+
+    bool clear_table()
+    {
+        for (size_t i = 0; i < m_observers.size(); ) {
+            auto& o = m_observers[i];
+            if (o.table_ndx == current_table()) {
+                invalidate(&o);
+            }
+            else {
+                ++i;
+            }
+        }
+        return true;
+    }
+
+    bool select_link_list(size_t col, size_t row, size_t)
+    {
+        m_active_linklist = nullptr;
+        for (auto& o : m_observers) {
+            if (o.table_ndx == current_table() && o.row_ndx == row) {
+                m_active_linklist = &get_change(o, col);
+                break;
+            }
+        }
+        return true;
+    }
+
+    void append_link_list_change(ColumnInfo::Kind kind, size_t index) {
+        ColumnInfo *o = m_active_linklist;
+        if (!o || o->kind == ColumnInfo::Kind::SetAll) {
+            // Active LinkList isn't observed or already has multiple kinds of changes
+            return;
+        }
+
+        if (o->kind == ColumnInfo::Kind::None) {
+            o->kind = kind;
+            o->changed = true;
+            o->indices.add(index);
+        }
+        else if (o->kind == kind) {
+            if (kind == ColumnInfo::Kind::Remove) {
+                o->indices.add_shifted(index);
+            }
+            else if (kind == ColumnInfo::Kind::Insert) {
+                o->indices.insert_at(index);
+            }
+            else {
+                o->indices.add(index);
+            }
+        }
+        else {
+            // Array KVO can only send a single kind of change at a time, so
+            // if there are multiple just give up and send "Set"
+            o->indices.set(0);
+            o->kind = ColumnInfo::Kind::SetAll;
+        }
+    }
+
+    bool link_list_set(size_t index, size_t)
+    {
+        append_link_list_change(ColumnInfo::Kind::Set, index);
+        return true;
+    }
+
+    bool link_list_insert(size_t index, size_t)
+    {
+        append_link_list_change(ColumnInfo::Kind::Insert, index);
+        return true;
+    }
+
+    bool link_list_erase(size_t index)
+    {
+        append_link_list_change(ColumnInfo::Kind::Remove, index);
+        return true;
+    }
+
+    bool link_list_nullify(size_t index)
+    {
+        append_link_list_change(ColumnInfo::Kind::Remove, index);
+        return true;
+    }
+
+    bool link_list_swap(size_t index1, size_t index2)
+    {
+        append_link_list_change(ColumnInfo::Kind::Set, index1);
+        append_link_list_change(ColumnInfo::Kind::Set, index2);
+        return true;
+    }
+
+    bool link_list_clear(size_t old_size)
+    {
+        ColumnInfo *o = m_active_linklist;
+        if (!o || o->kind == ColumnInfo::Kind::SetAll) {
+            return true;
+        }
+
+        if (o->kind == ColumnInfo::Kind::Remove)
+            old_size += o->indices.count();
+        else if (o->kind == ColumnInfo::Kind::Insert)
+            old_size -= o->indices.count();
+
+        o->indices.set(old_size);
+
+        o->kind = ColumnInfo::Kind::Remove;
+        o->changed = true;
+        return true;
+    }
+
+    bool link_list_move(size_t from, size_t to)
+    {
+        ColumnInfo *o = m_active_linklist;
+        if (!o || o->kind == ColumnInfo::Kind::SetAll) {
+            return true;
+        }
+        if (from > to) {
+            std::swap(from, to);
+        }
+
+        if (o->kind == ColumnInfo::Kind::None) {
+            o->kind = ColumnInfo::Kind::Set;
+            o->changed = true;
+        }
+        if (o->kind == ColumnInfo::Kind::Set) {
+            for (size_t i = from; i <= to; ++i)
+                o->indices.add(i);
+        }
+        else {
+            o->indices.set(0);
+            o->kind = ColumnInfo::Kind::SetAll;
+        }
+        return true;
+    }
+};
+
+// Extends TransactLogValidator to track changes made to LinkViews
+class LinkViewObserver : public TransactLogValidationMixin, public MarkDirtyMixin<LinkViewObserver> {
+    _impl::TransactionChangeInfo& m_info;
+    _impl::CollectionChangeBuilder* m_active = nullptr;
+
+    _impl::CollectionChangeBuilder* get_change()
+    {
+        auto tbl_ndx = current_table();
+        if (tbl_ndx >= m_info.table_modifications_needed.size() || !m_info.table_modifications_needed[tbl_ndx])
+            return nullptr;
+        if (m_info.tables.size() <= tbl_ndx) {
+            m_info.tables.resize(std::max(m_info.tables.size() * 2, tbl_ndx + 1));
+        }
+        return &m_info.tables[tbl_ndx];
+    }
+
+    bool need_move_info() const
+    {
+        auto tbl_ndx = current_table();
+        return tbl_ndx < m_info.table_moves_needed.size() && m_info.table_moves_needed[tbl_ndx];
+    }
+
+public:
+    LinkViewObserver(_impl::TransactionChangeInfo& info)
+    : m_info(info) { }
+
+    void mark_dirty(size_t row, __unused size_t col)
+    {
+        if (auto change = get_change())
+            change->modify(row);
+    }
+
+    void parse_complete()
+    {
+        for (auto& table : m_info.tables) {
+            table.parse_complete();
+        }
+        for (auto& list : m_info.lists) {
+            list.changes->clean_up_stale_moves();
+        }
+    }
+
+    bool select_link_list(size_t col, size_t row, size_t)
+    {
+        mark_dirty(row, col);
+
+        m_active = nullptr;
+        // When there are multiple source versions there could be multiple
+        // change objects for a single LinkView, in which case we need to use
+        // the last one
+        for (auto it = m_info.lists.rbegin(), end = m_info.lists.rend(); it != end; ++it) {
+            if (it->table_ndx == current_table() && it->row_ndx == row && it->col_ndx == col) {
+                m_active = it->changes;
+                break;
+            }
+        }
+        return true;
+    }
+
+    bool link_list_set(size_t index, size_t)
+    {
+        if (m_active)
+            m_active->modify(index);
+        return true;
+    }
+
+    bool link_list_insert(size_t index, size_t)
+    {
+        if (m_active)
+            m_active->insert(index);
+        return true;
+    }
+
+    bool link_list_erase(size_t index)
+    {
+        if (m_active)
+            m_active->erase(index);
+        return true;
+    }
+
+    bool link_list_nullify(size_t index)
+    {
+        return link_list_erase(index);
+    }
+
+    bool link_list_swap(size_t index1, size_t index2)
+    {
+        link_list_set(index1, 0);
+        link_list_set(index2, 0);
+        return true;
+    }
+
+    bool link_list_clear(size_t old_size)
+    {
+        if (m_active)
+            m_active->clear(old_size);
+        return true;
+    }
+
+    bool link_list_move(size_t from, size_t to)
+    {
+        if (m_active)
+            m_active->move(from, to);
+        return true;
+    }
+
+    bool insert_empty_rows(size_t row_ndx, size_t num_rows_to_insert, size_t, bool unordered)
+    {
+        REALM_ASSERT(!unordered);
+        if (auto change = get_change())
+            change->insert(row_ndx, num_rows_to_insert, need_move_info());
+
+        return true;
+    }
+
+    bool erase_rows(size_t row_ndx, size_t, size_t prior_num_rows, bool unordered)
+    {
+        REALM_ASSERT(unordered);
+        size_t last_row = prior_num_rows - 1;
+
+        for (auto it = begin(m_info.lists); it != end(m_info.lists); ) {
+            if (it->table_ndx == current_table()) {
+                if (it->row_ndx == row_ndx) {
+                    *it = std::move(m_info.lists.back());
+                    m_info.lists.pop_back();
+                    continue;
+                }
+                if (it->row_ndx == last_row - 1)
+                    it->row_ndx = row_ndx;
+            }
+            ++it;
+        }
+
+        if (auto change = get_change())
+            change->move_over(row_ndx, last_row, need_move_info());
+        return true;
+    }
+
+    bool clear_table()
+    {
+        auto tbl_ndx = current_table();
+        auto it = remove_if(begin(m_info.lists), end(m_info.lists),
+                            [&](auto const& lv) { return lv.table_ndx == tbl_ndx; });
+        m_info.lists.erase(it, end(m_info.lists));
+        if (auto change = get_change())
+            change->clear(std::numeric_limits<size_t>::max());
+        return true;
+    }
+};
+} // anonymous namespace
+
+namespace realm {
+namespace _impl {
+namespace transaction {
+void advance(SharedGroup& sg, BindingContext* context, SharedGroup::VersionID version)
+{
+    TransactLogObserver(context, sg, [&](auto&&... args) {
+        LangBindHelper::advance_read(sg, std::move(args)..., version);
+    }, true);
+}
+
+void begin(SharedGroup& sg, BindingContext* context, bool validate_schema_changes)
+{
+    TransactLogObserver(context, sg, [&](auto&&... args) {
+        LangBindHelper::promote_to_write(sg, std::move(args)...);
+    }, validate_schema_changes);
+}
+
+void commit(SharedGroup& sg, BindingContext* context)
+{
+    LangBindHelper::commit_and_continue_as_read(sg);
+
+    if (context) {
+        context->did_change({}, {});
+    }
+}
+
+void cancel(SharedGroup& sg, BindingContext* context)
+{
+    TransactLogObserver(context, sg, [&](auto&&... args) {
+        LangBindHelper::rollback_and_continue_as_read(sg, std::move(args)...);
+    }, false);
+}
+
+void advance(SharedGroup& sg,
+             TransactionChangeInfo& info,
+             SharedGroup::VersionID version)
+{
+    if (info.table_modifications_needed.empty() && info.lists.empty()) {
+        LangBindHelper::advance_read(sg, version);
+    }
+    else {
+        LangBindHelper::advance_read(sg, LinkViewObserver(info), version);
+    }
+
+}
+
+} // namespace transaction
+} // namespace _impl
+} // namespace realm
diff --git a/Pods/Realm/Realm/ObjectStore/index_set.cpp b/Pods/Realm/Realm/ObjectStore/index_set.cpp
new file mode 100644
index 0000000..a5c30c2
--- /dev/null
+++ b/Pods/Realm/Realm/ObjectStore/index_set.cpp
@@ -0,0 +1,707 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2015 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#include "index_set.hpp"
+
+#include <realm/util/assert.hpp>
+
+#include <algorithm>
+
+using namespace realm;
+using namespace realm::_impl;
+
+const size_t IndexSet::npos;
+
+template<typename T>
+void MutableChunkedRangeVectorIterator<T>::set(size_t front, size_t back)
+{
+    this->m_outer->count -= this->m_inner->second - this->m_inner->first;
+    if (this->offset() == 0) {
+        this->m_outer->begin = front;
+    }
+    if (this->m_inner == &this->m_outer->data.back()) {
+        this->m_outer->end = back;
+    }
+    this->m_outer->count += back - front;
+    this->m_inner->first = front;
+    this->m_inner->second = back;
+}
+
+template<typename T>
+void MutableChunkedRangeVectorIterator<T>::adjust(ptrdiff_t front, ptrdiff_t back)
+{
+    if (this->offset() == 0) {
+        this->m_outer->begin += front;
+    }
+    if (this->m_inner == &this->m_outer->data.back()) {
+        this->m_outer->end += back;
+    }
+    this->m_outer->count += -front + back;
+    this->m_inner->first += front;
+    this->m_inner->second += back;
+}
+
+template<typename T>
+void MutableChunkedRangeVectorIterator<T>::shift(ptrdiff_t distance)
+{
+    if (this->offset() == 0) {
+        this->m_outer->begin += distance;
+    }
+    if (this->m_inner == &this->m_outer->data.back()) {
+        this->m_outer->end += distance;
+    }
+    this->m_inner->first += distance;
+    this->m_inner->second += distance;
+}
+
+void ChunkedRangeVector::push_back(value_type value)
+{
+    if (!empty() && m_data.back().data.size() < max_size) {
+        auto& range = m_data.back();
+        REALM_ASSERT(range.end <= value.first);
+
+        range.data.push_back(value);
+        range.count += value.second - value.first;
+        range.end = value.second;
+    }
+    else {
+        m_data.push_back({{std::move(value)}, value.first, value.second, value.second - value.first});
+    }
+    verify();
+}
+
+ChunkedRangeVector::iterator ChunkedRangeVector::insert(iterator pos, value_type value)
+{
+    if (pos.m_outer == m_data.end()) {
+        push_back(std::move(value));
+        return std::prev(end());
+    }
+
+    pos = ensure_space(pos);
+    auto& chunk = *pos.m_outer;
+    pos.m_inner = &*chunk.data.insert(pos.m_outer->data.begin() + pos.offset(), value);
+    chunk.count += value.second - value.first;
+    chunk.begin = std::min(chunk.begin, value.first);
+    chunk.end = std::max(chunk.end, value.second);
+
+    verify();
+    return pos;
+}
+
+ChunkedRangeVector::iterator ChunkedRangeVector::ensure_space(iterator pos)
+{
+    if (pos.m_outer->data.size() + 1 <= max_size)
+        return pos;
+
+    auto offset = pos.offset();
+
+    // Split the chunk in half to make space for the new insertion
+    auto new_pos = m_data.insert(pos.m_outer + 1, Chunk{});
+    auto prev = new_pos - 1;
+    auto to_move = max_size / 2;
+    new_pos->data.reserve(to_move);
+    new_pos->data.assign(prev->data.end() - to_move, prev->data.end());
+    prev->data.resize(prev->data.size() - to_move);
+
+    size_t moved_count = 0;
+    for (auto range : new_pos->data)
+        moved_count += range.second - range.first;
+
+    prev->end = prev->data.back().second;
+    prev->count -= moved_count;
+    new_pos->begin = new_pos->data.front().first;
+    new_pos->end = new_pos->data.back().second;
+    new_pos->count = moved_count;
+
+    if (offset >= to_move) {
+        pos.m_outer = new_pos;
+        offset -= to_move;
+    }
+    else {
+        pos.m_outer = prev;
+    }
+    pos.m_end = m_data.end();
+    pos.m_inner = &pos.m_outer->data[offset];
+    verify();
+    return pos;
+}
+
+ChunkedRangeVector::iterator ChunkedRangeVector::erase(iterator pos)
+{
+    auto offset = pos.offset();
+    auto& chunk = *pos.m_outer;
+    chunk.count -= pos->second - pos->first;
+    chunk.data.erase(chunk.data.begin() + offset);
+
+    if (chunk.data.size() == 0) {
+        pos.m_outer = m_data.erase(pos.m_outer);
+        pos.m_end = m_data.end();
+        pos.m_inner = pos.m_outer == m_data.end() ? nullptr : &pos.m_outer->data.front();
+        verify();
+        return pos;
+    }
+
+    chunk.begin = chunk.data.front().first;
+    chunk.end = chunk.data.back().second;
+    if (offset < chunk.data.size())
+        pos.m_inner = &chunk.data[offset];
+    else {
+        ++pos.m_outer;
+        pos.m_inner = pos.m_outer == pos.m_end ? nullptr : &pos.m_outer->data.front();
+    }
+
+    verify();
+    return pos;
+}
+
+void ChunkedRangeVector::verify() const noexcept
+{
+#ifdef REALM_DEBUG
+    size_t prev_end = -1;
+    for (auto range : *this) {
+        REALM_ASSERT(range.first < range.second);
+        REALM_ASSERT(prev_end == size_t(-1) || range.first > prev_end);
+        prev_end = range.second;
+    }
+
+    for (auto& chunk : m_data) {
+        REALM_ASSERT(!chunk.data.empty());
+        REALM_ASSERT(chunk.data.front().first == chunk.begin);
+        REALM_ASSERT(chunk.data.back().second == chunk.end);
+        REALM_ASSERT(chunk.count <= chunk.end - chunk.begin);
+        size_t count = 0;
+        for (auto range : chunk.data)
+            count += range.second - range.first;
+        REALM_ASSERT(count == chunk.count);
+    }
+#endif
+}
+
+namespace {
+class ChunkedRangeVectorBuilder {
+public:
+    using value_type = std::pair<size_t, size_t>;
+
+    ChunkedRangeVectorBuilder(ChunkedRangeVector const& expected);
+    void push_back(size_t index);
+    void push_back(std::pair<size_t, size_t> range);
+    std::vector<ChunkedRangeVector::Chunk> finalize();
+private:
+    std::vector<ChunkedRangeVector::Chunk> m_data;
+    size_t m_outer_pos = 0;
+};
+
+ChunkedRangeVectorBuilder::ChunkedRangeVectorBuilder(ChunkedRangeVector const& expected)
+{
+    size_t size = 0;
+    for (auto const& chunk : expected.m_data)
+        size += chunk.data.size();
+    m_data.resize(size / ChunkedRangeVector::max_size + 1);
+    for (size_t i = 0; i < m_data.size() - 1; ++i)
+        m_data[i].data.reserve(ChunkedRangeVector::max_size);
+}
+
+void ChunkedRangeVectorBuilder::push_back(size_t index)
+{
+    push_back({index, index + 1});
+}
+
+void ChunkedRangeVectorBuilder::push_back(std::pair<size_t, size_t> range)
+{
+    auto& chunk = m_data[m_outer_pos];
+    if (chunk.data.empty()) {
+        chunk.data.push_back(range);
+        chunk.count = range.second - range.first;
+        chunk.begin = range.first;
+    }
+    else if (range.first == chunk.data.back().second) {
+        chunk.data.back().second = range.second;
+        chunk.count += range.second - range.first;
+    }
+    else if (chunk.data.size() < ChunkedRangeVector::max_size) {
+        chunk.data.push_back(range);
+        chunk.count += range.second - range.first;
+    }
+    else {
+        chunk.end = chunk.data.back().second;
+        ++m_outer_pos;
+        if (m_outer_pos >= m_data.size())
+            m_data.push_back({{range}, range.first, 0, 1});
+        else {
+            auto& chunk = m_data[m_outer_pos];
+            chunk.data.push_back(range);
+            chunk.begin = range.first;
+            chunk.count = range.second - range.first;
+        }
+    }
+}
+
+std::vector<ChunkedRangeVector::Chunk> ChunkedRangeVectorBuilder::finalize()
+{
+    if (!m_data.empty()) {
+        m_data.resize(m_outer_pos + 1);
+        if (m_data.back().data.empty())
+            m_data.pop_back();
+        else
+            m_data.back().end = m_data.back().data.back().second;
+    }
+    return std::move(m_data);
+}
+}
+
+IndexSet::IndexSet(std::initializer_list<size_t> values)
+{
+    for (size_t v : values)
+        add(v);
+}
+
+bool IndexSet::contains(size_t index) const
+{
+    auto it = const_cast<IndexSet*>(this)->find(index);
+    return it != end() && it->first <= index;
+}
+
+size_t IndexSet::count(size_t start_index, size_t end_index) const
+{
+    auto it = const_cast<IndexSet*>(this)->find(start_index);
+    const auto end = this->end();
+    if (it == end || it->first >= end_index) {
+        return 0;
+    }
+    if (it->second >= end_index)
+        return std::min(it->second, end_index) - std::max(it->first, start_index);
+
+    size_t ret = 0;
+
+    if (start_index > it->first || it.offset() != 0) {
+        // Start index is in the middle of a chunk, so start by counting the
+        // rest of that chunk
+        ret = it->second - std::max(it->first, start_index);
+        for (++it; it != end && it->second < end_index && it.offset() != 0; ++it) {
+            ret += it->second - it->first;
+        }
+        if (it != end && it->first < end_index && it.offset() != 0)
+            ret += end_index - it->first;
+        if (it == end || it->second >= end_index)
+            return ret;
+    }
+
+    // Now count all complete chunks that fall within the range
+    while (it != end && it.outer()->end <= end_index) {
+        REALM_ASSERT_DEBUG(it.offset() == 0);
+        ret += it.outer()->count;
+        it.next_chunk();
+    }
+
+    // Cound all complete ranges within the last chunk
+    while (it != end && it->second <= end_index) {
+        ret += it->second - it->first;
+        ++it;
+    }
+
+    // And finally add in the partial last range
+    if (it != end && it->first < end_index)
+        ret += end_index - it->first;
+    return ret;
+}
+
+IndexSet::iterator IndexSet::find(size_t index)
+{
+    return find(index, begin());
+}
+
+IndexSet::iterator IndexSet::find(size_t index, iterator begin)
+{
+    auto it = std::find_if(begin.outer(), m_data.end(),
+                           [&](auto const& lft) { return lft.end > index; });
+    if (it == m_data.end())
+        return end();
+    if (index < it->begin)
+        return iterator(it, m_data.end(), &it->data[0]);
+    auto inner_begin = it->data.begin();
+    if (it == begin.outer())
+        inner_begin += begin.offset();
+    auto inner = std::lower_bound(inner_begin, it->data.end(), index,
+                                  [&](auto const& lft, auto) { return lft.second <= index; });
+    REALM_ASSERT_DEBUG(inner != it->data.end());
+
+    return iterator(it, m_data.end(), &*inner);
+}
+
+void IndexSet::add(size_t index)
+{
+    do_add(find(index), index);
+}
+
+void IndexSet::add(IndexSet const& other)
+{
+    auto it = begin();
+    for (size_t index : other.as_indexes()) {
+        it = do_add(find(index, it), index);
+    }
+}
+
+size_t IndexSet::add_shifted(size_t index)
+{
+    iterator it = begin(), end = this->end();
+
+    // Shift for any complete chunks before the target
+    for (; it != end && it.outer()->end <= index; it.next_chunk())
+        index += it.outer()->count;
+
+    // And any ranges within the last partial chunk
+    for (; it != end && it->first <= index; ++it)
+        index += it->second - it->first;
+
+    do_add(it, index);
+    return index;
+}
+
+void IndexSet::add_shifted_by(IndexSet const& shifted_by, IndexSet const& values)
+{
+    if (values.empty())
+        return;
+
+#ifdef REALM_DEBUG
+    size_t expected = std::distance(as_indexes().begin(), as_indexes().end());
+    for (auto index : values.as_indexes()) {
+        if (!shifted_by.contains(index))
+            ++expected;
+    }
+#endif
+
+    ChunkedRangeVectorBuilder builder(*this);
+
+    auto old_it = cbegin(), old_end = cend();
+    auto shift_it = shifted_by.cbegin(), shift_end = shifted_by.cend();
+
+    size_t skip_until = 0;
+    size_t old_shift = 0;
+    size_t new_shift = 0;
+    for (size_t index : values.as_indexes()) {
+        for (; shift_it != shift_end && shift_it->first <= index; ++shift_it) {
+            new_shift += shift_it->second - shift_it->first;
+            skip_until = shift_it->second;
+        }
+        if (index < skip_until)
+            continue;
+
+        for (; old_it != old_end && old_it->first <= index - new_shift + old_shift; ++old_it) {
+            for (size_t i = old_it->first; i < old_it->second; ++i)
+                builder.push_back(i);
+            old_shift += old_it->second - old_it->first;
+        }
+
+        REALM_ASSERT(index >= new_shift);
+        builder.push_back(index - new_shift + old_shift);
+    }
+
+    copy(old_it, old_end, std::back_inserter(builder));
+    m_data = builder.finalize();
+
+#ifdef REALM_DEBUG
+    REALM_ASSERT((size_t)std::distance(as_indexes().begin(), as_indexes().end()) == expected);
+#endif
+}
+
+void IndexSet::set(size_t len)
+{
+    clear();
+    if (len) {
+        push_back({0, len});
+    }
+}
+
+void IndexSet::insert_at(size_t index, size_t count)
+{
+    REALM_ASSERT(count > 0);
+
+    auto pos = find(index);
+    auto end = this->end();
+    bool in_existing = false;
+    if (pos != end) {
+        if (pos->first <= index) {
+            in_existing = true;
+            pos.adjust(0, count);
+        }
+        else {
+            pos.shift(count);
+        }
+        for (auto it = std::next(pos); it != end; ++it)
+            it.shift(count);
+    }
+    if (!in_existing) {
+        for (size_t i = 0; i < count; ++i)
+            pos = std::next(do_add(pos, index + i));
+    }
+
+    verify();
+}
+
+void IndexSet::insert_at(IndexSet const& positions)
+{
+    if (positions.empty())
+        return;
+    if (empty()) {
+        *this = positions;
+        return;
+    }
+
+    IndexIterator begin1 = cbegin(), begin2 = positions.cbegin();
+    IndexIterator end1 = cend(), end2 = positions.cend();
+
+    ChunkedRangeVectorBuilder builder(*this);
+    size_t shift = 0;
+    while (begin1 != end1 && begin2 != end2) {
+        if (*begin1 + shift < *begin2) {
+            builder.push_back(*begin1++ + shift);
+        }
+        else {
+            ++shift;
+            builder.push_back(*begin2++);
+        }
+    }
+    for (; begin1 != end1; ++begin1)
+        builder.push_back(*begin1 + shift);
+    for (; begin2 != end2; ++begin2)
+        builder.push_back(*begin2);
+
+    m_data = builder.finalize();
+}
+
+void IndexSet::shift_for_insert_at(size_t index, size_t count)
+{
+    REALM_ASSERT(count > 0);
+
+    auto it = find(index);
+    if (it == end())
+        return;
+
+    for (auto pos = it, end = this->end(); pos != end; ++pos)
+        pos.shift(count);
+
+    // If the range contained the insertion point, split the range and move
+    // the part of it before the insertion point back
+    if (it->first < index + count) {
+        auto old_second = it->second;
+        it.set(it->first - count, index);
+        insert(std::next(it), {index + count, old_second});
+    }
+    verify();
+}
+
+void IndexSet::shift_for_insert_at(realm::IndexSet const& values)
+{
+    if (empty() || values.empty())
+        return;
+    if (values.m_data.front().begin >= m_data.back().end)
+        return;
+
+    IndexIterator begin1 = cbegin(), begin2 = values.cbegin();
+    IndexIterator end1 = cend(), end2 = values.cend();
+
+    ChunkedRangeVectorBuilder builder(*this);
+    size_t shift = 0;
+    while (begin1 != end1 && begin2 != end2) {
+        if (*begin1 + shift < *begin2) {
+            builder.push_back(*begin1++ + shift);
+        }
+        else {
+            ++shift;
+            begin2++;
+        }
+    }
+    for (; begin1 != end1; ++begin1)
+        builder.push_back(*begin1 + shift);
+
+    m_data = builder.finalize();
+}
+
+void IndexSet::erase_at(size_t index)
+{
+    auto it = find(index);
+    if (it != end())
+        do_erase(it, index);
+}
+
+void IndexSet::erase_at(IndexSet const& positions)
+{
+    if (empty() || positions.empty())
+        return;
+
+    ChunkedRangeVectorBuilder builder(*this);
+
+    IndexIterator begin1 = cbegin(), begin2 = positions.cbegin();
+    IndexIterator end1 = cend(), end2 = positions.cend();
+
+    size_t shift = 0;
+    while (begin1 != end1 && begin2 != end2) {
+        if (*begin1 < *begin2) {
+            builder.push_back(*begin1++ - shift);
+        }
+        else if (*begin1 == *begin2) {
+            ++shift;
+            ++begin1;
+            ++begin2;
+        }
+        else {
+            ++shift;
+            ++begin2;
+        }
+    }
+    for (; begin1 != end1; ++begin1)
+        builder.push_back(*begin1 - shift);
+
+    m_data = builder.finalize();
+}
+
+size_t IndexSet::erase_or_unshift(size_t index)
+{
+    auto shifted = index;
+    iterator it = begin(), end = this->end();
+
+    // Shift for any complete chunks before the target
+    for (; it != end && it.outer()->end <= index; it.next_chunk())
+        shifted -= it.outer()->count;
+
+    // And any ranges within the last partial chunk
+    for (; it != end && it->second <= index; ++it)
+        shifted -= it->second - it->first;
+
+    if (it == end)
+        return shifted;
+
+    if (it->first <= index)
+        shifted = npos;
+
+    do_erase(it, index);
+
+    return shifted;
+}
+
+void IndexSet::do_erase(iterator it, size_t index)
+{
+    if (it->first <= index) {
+        if (it->first + 1 == it->second) {
+            it = erase(it);
+        }
+        else {
+            it.adjust(0, -1);
+            ++it;
+        }
+    }
+    else if (it != begin() && std::prev(it)->second + 1 == it->first) {
+        std::prev(it).adjust(0, it->second - it->first);
+        it = erase(it);
+    }
+
+    for (; it != end(); ++it)
+        it.shift(-1);
+}
+
+IndexSet::iterator IndexSet::do_remove(iterator it, size_t begin, size_t end)
+{
+    for (it = find(begin, it); it != this->end() && it->first < end; it = find(begin, it)) {
+        // Trim off any part of the range to remove that's before the matching range
+        begin = std::max(it->first, begin);
+
+        // If the matching range extends to both sides of the range to remove,
+        // split it on the range to remove
+        if (it->first < begin && it->second > end) {
+            auto old_second = it->second;
+            it.set(it->first, begin);
+            it = std::prev(insert(std::next(it), {end, old_second}));
+        }
+        // Range to delete now coverages (at least) one end of the matching range
+        else if (begin == it->first && end >= it->second)
+            it = erase(it);
+        else if (begin == it->first)
+            it.set(end, it->second);
+        else
+            it.set(it->first, begin);
+    }
+    return it;
+}
+
+void IndexSet::remove(size_t index, size_t count)
+{
+    do_remove(find(index), index, index + count);
+}
+
+void IndexSet::remove(realm::IndexSet const& values)
+{
+    auto it = begin();
+    for (auto range : values) {
+        it = do_remove(it, range.first, range.second);
+        if (it == end())
+            return;
+    }
+}
+
+size_t IndexSet::shift(size_t index) const
+{
+    // FIXME: optimize
+    for (auto range : *this) {
+        if (range.first > index)
+            break;
+        index += range.second - range.first;
+    }
+    return index;
+}
+
+size_t IndexSet::unshift(size_t index) const
+{
+    REALM_ASSERT_DEBUG(!contains(index));
+    return index - count(0, index);
+}
+
+void IndexSet::clear()
+{
+    m_data.clear();
+}
+
+IndexSet::iterator IndexSet::do_add(iterator it, size_t index)
+{
+    verify();
+    bool more_before = it != begin(), valid = it != end();
+    REALM_ASSERT(!more_before || index >= std::prev(it)->second);
+    if (valid && it->first <= index && it->second > index) {
+        // index is already in set
+        return it;
+    }
+    if (more_before && std::prev(it)->second == index) {
+        auto prev = std::prev(it);
+        // index is immediately after an existing range
+        prev.adjust(0, 1);
+
+        if (valid && prev->second == it->first) {
+            // index joins two existing ranges
+            prev.adjust(0, it->second - it->first);
+            return std::prev(erase(it));
+        }
+        return prev;
+    }
+    if (valid && it->first == index + 1) {
+        // index is immediately before an existing range
+        it.adjust(-1, 0);
+        return it;
+    }
+
+    // index is not next to an existing range
+    return insert(it, {index, index + 1});
+}
diff --git a/Pods/Realm/Realm/ObjectStore/list.cpp b/Pods/Realm/Realm/ObjectStore/list.cpp
new file mode 100644
index 0000000..3bf840c
--- /dev/null
+++ b/Pods/Realm/Realm/ObjectStore/list.cpp
@@ -0,0 +1,208 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2015 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#include "list.hpp"
+
+#include "impl/list_notifier.hpp"
+#include "impl/realm_coordinator.hpp"
+#include "results.hpp"
+#include "shared_realm.hpp"
+#include "util/format.hpp"
+
+#include <realm/link_view.hpp>
+
+using namespace realm;
+using namespace realm::_impl;
+
+List::List() noexcept = default;
+List::~List() = default;
+
+List::List(const List&) = default;
+List& List::operator=(const List&) = default;
+List::List(List&&) = default;
+List& List::operator=(List&&) = default;
+
+List::List(std::shared_ptr<Realm> r, LinkViewRef l) noexcept
+: m_realm(std::move(r))
+, m_link_view(std::move(l))
+{
+}
+
+Query List::get_query() const
+{
+    verify_attached();
+    return m_link_view->get_target_table().where(m_link_view);
+}
+
+size_t List::get_origin_row_index() const
+{
+    verify_attached();
+    return m_link_view->get_origin_row_index();
+}
+
+void List::verify_valid_row(size_t row_ndx, bool insertion) const
+{
+    size_t size = m_link_view->size();
+    if (row_ndx > size || (!insertion && row_ndx == size)) {
+        throw OutOfBoundsIndexException{row_ndx, size + insertion};
+    }
+}
+
+bool List::is_valid() const
+{
+    m_realm->verify_thread();
+    return m_link_view && m_link_view->is_attached();
+}
+
+void List::verify_attached() const
+{
+    if (!is_valid()) {
+        throw InvalidatedException{};
+    }
+}
+
+void List::verify_in_transaction() const
+{
+    verify_attached();
+    if (!m_realm->is_in_transaction()) {
+        throw InvalidTransactionException("Must be in a write transaction");
+    }
+}
+
+size_t List::size() const
+{
+    verify_attached();
+    return m_link_view->size();
+}
+
+RowExpr List::get(size_t row_ndx) const
+{
+    verify_attached();
+    verify_valid_row(row_ndx);
+    return m_link_view->get(row_ndx);
+}
+
+size_t List::get_unchecked(size_t row_ndx) const noexcept
+{
+    return m_link_view->get(row_ndx).get_index();
+}
+
+size_t List::find(ConstRow const& row) const
+{
+    verify_attached();
+
+    if (!row.is_attached() || row.get_table() != &m_link_view->get_target_table()) {
+        return not_found;
+    }
+
+    return m_link_view->find(row.get_index());
+}
+
+void List::add(size_t target_row_ndx)
+{
+    verify_in_transaction();
+    m_link_view->add(target_row_ndx);
+}
+
+void List::insert(size_t row_ndx, size_t target_row_ndx)
+{
+    verify_in_transaction();
+    verify_valid_row(row_ndx, true);
+    m_link_view->insert(row_ndx, target_row_ndx);
+}
+
+void List::move(size_t source_ndx, size_t dest_ndx)
+{
+    verify_in_transaction();
+    verify_valid_row(source_ndx);
+    verify_valid_row(dest_ndx); // Can't be one past end due to removing one earlier
+    m_link_view->move(source_ndx, dest_ndx);
+}
+
+void List::remove(size_t row_ndx)
+{
+    verify_in_transaction();
+    verify_valid_row(row_ndx);
+    m_link_view->remove(row_ndx);
+}
+
+void List::remove_all()
+{
+    verify_in_transaction();
+    m_link_view->clear();
+}
+
+void List::set(size_t row_ndx, size_t target_row_ndx)
+{
+    verify_in_transaction();
+    verify_valid_row(row_ndx);
+    m_link_view->set(row_ndx, target_row_ndx);
+}
+
+void List::swap(size_t ndx1, size_t ndx2)
+{
+    verify_in_transaction();
+    verify_valid_row(ndx1);
+    verify_valid_row(ndx2);
+    m_link_view->swap(ndx1, ndx2);
+}
+
+void List::delete_all()
+{
+    verify_in_transaction();
+    m_link_view->remove_all_target_rows();
+}
+
+Results List::sort(SortOrder order)
+{
+    verify_attached();
+    return Results(m_realm, m_link_view, util::none, std::move(order));
+}
+
+Results List::filter(Query q)
+{
+    verify_attached();
+    return Results(m_realm, m_link_view, get_query().and_query(std::move(q)));
+}
+
+// These definitions rely on that LinkViews are interned by core
+bool List::operator==(List const& rgt) const noexcept
+{
+    return m_link_view.get() == rgt.m_link_view.get();
+}
+
+namespace std {
+size_t hash<realm::List>::operator()(realm::List const& list) const
+{
+    return std::hash<void*>()(list.m_link_view.get());
+}
+}
+
+NotificationToken List::add_notification_callback(CollectionChangeCallback cb)
+{
+    verify_attached();
+    if (!m_notifier) {
+        m_notifier = std::make_shared<ListNotifier>(m_link_view, m_realm);
+        RealmCoordinator::register_notifier(m_notifier);
+    }
+    return {m_notifier, m_notifier->add_callback(std::move(cb))};
+}
+
+List::OutOfBoundsIndexException::OutOfBoundsIndexException(size_t r, size_t c)
+: std::out_of_range(util::format("Requested index %1 greater than max %2", r, c))
+, requested(r), valid_count(c) {}
diff --git a/Pods/Realm/Realm/ObjectStore/object_schema.cpp b/Pods/Realm/Realm/ObjectStore/object_schema.cpp
new file mode 100644
index 0000000..6eb819d
--- /dev/null
+++ b/Pods/Realm/Realm/ObjectStore/object_schema.cpp
@@ -0,0 +1,106 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2015 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#include "object_schema.hpp"
+
+#include "object_store.hpp"
+#include "property.hpp"
+
+#include <realm/data_type.hpp>
+#include <realm/table.hpp>
+
+using namespace realm;
+
+#define ASSERT_PROPERTY_TYPE_VALUE(property, type) \
+    static_assert(static_cast<int>(PropertyType::property) == type_##type, \
+                  "PropertyType and DataType must have the same values")
+
+ASSERT_PROPERTY_TYPE_VALUE(Int, Int);
+ASSERT_PROPERTY_TYPE_VALUE(Bool, Bool);
+ASSERT_PROPERTY_TYPE_VALUE(Float, Float);
+ASSERT_PROPERTY_TYPE_VALUE(Double, Double);
+ASSERT_PROPERTY_TYPE_VALUE(Data, Binary);
+ASSERT_PROPERTY_TYPE_VALUE(Date, Timestamp);
+ASSERT_PROPERTY_TYPE_VALUE(Any, Mixed);
+ASSERT_PROPERTY_TYPE_VALUE(Object, Link);
+ASSERT_PROPERTY_TYPE_VALUE(Array, LinkList);
+
+ObjectSchema::ObjectSchema() = default;
+ObjectSchema::~ObjectSchema() = default;
+
+ObjectSchema::ObjectSchema(std::string name, std::string primary_key, std::initializer_list<Property> persisted_properties)
+: name(std::move(name))
+, persisted_properties(persisted_properties)
+, primary_key(std::move(primary_key))
+{
+    set_primary_key_property();
+}
+
+ObjectSchema::ObjectSchema(const Group *group, const std::string &name) : name(name) {
+    ConstTableRef table = ObjectStore::table_for_object_type(group, name);
+
+    size_t count = table->get_column_count();
+    persisted_properties.reserve(count);
+    for (size_t col = 0; col < count; col++) {
+        Property property;
+        property.name = table->get_column_name(col).data();
+        property.type = (PropertyType)table->get_column_type(col);
+        property.is_indexed = table->has_search_index(col);
+        property.is_primary = false;
+        property.is_nullable = table->is_nullable(col) || property.type == PropertyType::Object;
+        property.table_column = col;
+        if (property.type == PropertyType::Object || property.type == PropertyType::Array) {
+            // set link type for objects and arrays
+            ConstTableRef linkTable = table->get_link_target(col);
+            property.object_type = ObjectStore::object_type_for_table_name(linkTable->get_name().data());
+        }
+        persisted_properties.push_back(std::move(property));
+    }
+
+    primary_key = realm::ObjectStore::get_primary_key_for_object(group, name);
+    set_primary_key_property();
+}
+
+Property *ObjectSchema::property_for_name(StringData name) {
+    for (auto& prop : persisted_properties) {
+        if (StringData(prop.name) == name) {
+            return &prop;
+        }
+    }
+    for (auto& prop : computed_properties) {
+        if (StringData(prop.name) == name) {
+            return &prop;
+        }
+    }
+    return nullptr;
+}
+
+const Property *ObjectSchema::property_for_name(StringData name) const {
+    return const_cast<ObjectSchema *>(this)->property_for_name(name);
+}
+
+void ObjectSchema::set_primary_key_property()
+{
+    if (primary_key.length()) {
+        auto primary_key_prop = primary_key_property();
+        if (!primary_key_prop) {
+            throw InvalidPrimaryKeyException(name, primary_key);
+        }
+        primary_key_prop->is_primary = true;
+    }
+}
diff --git a/Pods/Realm/Realm/ObjectStore/object_store.cpp b/Pods/Realm/Realm/ObjectStore/object_store.cpp
new file mode 100644
index 0000000..079eb02
--- /dev/null
+++ b/Pods/Realm/Realm/ObjectStore/object_store.cpp
@@ -0,0 +1,814 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2015 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#include "object_store.hpp"
+
+#include "object_schema.hpp"
+#include "schema.hpp"
+#include "util/format.hpp"
+
+#include <realm/group.hpp>
+#include <realm/table.hpp>
+#include <realm/table_view.hpp>
+#include <realm/util/assert.hpp>
+
+#include <string.h>
+
+using namespace realm;
+
+namespace {
+const char * const c_metadataTableName = "metadata";
+const char * const c_versionColumnName = "version";
+const size_t c_versionColumnIndex = 0;
+
+const char * const c_primaryKeyTableName = "pk";
+const char * const c_primaryKeyObjectClassColumnName = "pk_table";
+const size_t c_primaryKeyObjectClassColumnIndex =  0;
+const char * const c_primaryKeyPropertyNameColumnName = "pk_property";
+const size_t c_primaryKeyPropertyNameColumnIndex =  1;
+
+const size_t c_zeroRowIndex = 0;
+
+const char c_object_table_prefix[] = "class_";
+}
+
+const uint64_t ObjectStore::NotVersioned = std::numeric_limits<uint64_t>::max();
+
+bool ObjectStore::has_metadata_tables(const Group *group) {
+    return group->get_table(c_primaryKeyTableName) && group->get_table(c_metadataTableName);
+}
+
+void ObjectStore::create_metadata_tables(Group *group) {
+    TableRef table = group->get_or_add_table(c_primaryKeyTableName);
+    if (table->get_column_count() == 0) {
+        table->add_column(type_String, c_primaryKeyObjectClassColumnName);
+        table->add_column(type_String, c_primaryKeyPropertyNameColumnName);
+    }
+
+    table = group->get_or_add_table(c_metadataTableName);
+    if (table->get_column_count() == 0) {
+        table->add_column(type_Int, c_versionColumnName);
+
+        // set initial version
+        table->add_empty_row();
+        table->set_int(c_versionColumnIndex, c_zeroRowIndex, ObjectStore::NotVersioned);
+    }
+}
+
+uint64_t ObjectStore::get_schema_version(const Group *group) {
+    ConstTableRef table = group->get_table(c_metadataTableName);
+    if (!table || table->get_column_count() == 0) {
+        return ObjectStore::NotVersioned;
+    }
+    return table->get_int(c_versionColumnIndex, c_zeroRowIndex);
+}
+
+void ObjectStore::set_schema_version(Group *group, uint64_t version) {
+    TableRef table = group->get_or_add_table(c_metadataTableName);
+    table->set_int(c_versionColumnIndex, c_zeroRowIndex, version);
+}
+
+StringData ObjectStore::get_primary_key_for_object(const Group *group, StringData object_type) {
+    ConstTableRef table = group->get_table(c_primaryKeyTableName);
+    if (!table) {
+        return "";
+    }
+    size_t row = table->find_first_string(c_primaryKeyObjectClassColumnIndex, object_type);
+    if (row == not_found) {
+        return "";
+    }
+    return table->get_string(c_primaryKeyPropertyNameColumnIndex, row);
+}
+
+void ObjectStore::set_primary_key_for_object(Group *group, StringData object_type, StringData primary_key) {
+    TableRef table = group->get_table(c_primaryKeyTableName);
+
+    // get row or create if new object and populate
+    size_t row = table->find_first_string(c_primaryKeyObjectClassColumnIndex, object_type);
+    if (row == not_found && primary_key.size()) {
+        row = table->add_empty_row();
+        table->set_string(c_primaryKeyObjectClassColumnIndex, row, object_type);
+    }
+
+    // set if changing, or remove if setting to nil
+    if (primary_key.size() == 0) {
+        if (row != not_found) {
+            table->remove(row);
+        }
+    }
+    else {
+        table->set_string(c_primaryKeyPropertyNameColumnIndex, row, primary_key);
+    }
+}
+
+StringData ObjectStore::object_type_for_table_name(StringData table_name) {
+    if (table_name.begins_with(c_object_table_prefix)) {
+        return table_name.substr(sizeof(c_object_table_prefix) - 1);
+    }
+    return StringData();
+}
+
+std::string ObjectStore::table_name_for_object_type(StringData object_type) {
+    return std::string(c_object_table_prefix) + object_type.data();
+}
+
+TableRef ObjectStore::table_for_object_type(Group *group, StringData object_type) {
+    auto name = table_name_for_object_type(object_type);
+    return group->get_table(name);
+}
+
+ConstTableRef ObjectStore::table_for_object_type(const Group *group, StringData object_type) {
+    auto name = table_name_for_object_type(object_type);
+    return group->get_table(name);
+}
+
+TableRef ObjectStore::table_for_object_type_create_if_needed(Group *group, StringData object_type, bool &created) {
+    auto name = table_name_for_object_type(object_type);
+    return group->get_or_add_table(name, &created);
+}
+
+static inline bool property_has_changed(Property const& p1, Property const& p2) {
+    return p1.type != p2.type
+        || p1.name != p2.name
+        || p1.object_type != p2.object_type
+        || p1.is_nullable != p2.is_nullable;
+}
+
+static inline bool property_can_be_migrated_to_nullable(const Property& old_property, const Property& new_property) {
+    return old_property.type == new_property.type
+        && !old_property.is_nullable
+        && new_property.is_nullable
+        && new_property.name == old_property.name;
+}
+
+void ObjectStore::verify_missing_renamed_properties(Schema const& actual_schema, Schema& target_schema) {
+    for (auto &object_schema : target_schema) {
+        auto matching_schema = actual_schema.find(object_schema);
+        for (auto& target_prop : matching_schema->persisted_properties) {
+            if (!object_schema.property_for_name(target_prop.name)) {
+                throw PropertyRenameMissingNewPropertyException(target_prop.name);
+            }
+        }
+    }
+}
+
+void ObjectStore::verify_schema(Schema const& actual_schema, Schema& target_schema, bool allow_missing_tables) {
+    std::vector<ObjectSchemaValidationException> errors;
+    for (auto &object_schema : target_schema) {
+        auto matching_schema = actual_schema.find(object_schema);
+        if (matching_schema == actual_schema.end()) {
+            if (!allow_missing_tables) {
+                errors.emplace_back(object_schema.name,
+                                    util::format("Missing table for object type '%1'.", object_schema.name));
+            }
+            continue;
+        }
+
+        auto more_errors = verify_object_schema(*matching_schema, object_schema);
+        errors.insert(errors.end(), more_errors.begin(), more_errors.end());
+    }
+    if (errors.size()) {
+        throw SchemaMismatchException(errors);
+    }
+}
+
+std::vector<ObjectSchemaValidationException> ObjectStore::verify_object_schema(ObjectSchema const& table_schema,
+                                                                               ObjectSchema& target_schema) {
+    std::vector<ObjectSchemaValidationException> exceptions;
+
+    // check to see if properties are the same
+    for (auto& current_prop : table_schema.persisted_properties) {
+        auto target_prop = target_schema.property_for_name(current_prop.name);
+
+        if (!target_prop) {
+            exceptions.emplace_back(MissingPropertyException(table_schema.name, current_prop));
+            continue;
+        }
+        if (property_has_changed(current_prop, *target_prop)) {
+            exceptions.emplace_back(MismatchedPropertiesException(table_schema.name, current_prop, *target_prop));
+            continue;
+        }
+
+        // create new property with aligned column
+        target_prop->table_column = current_prop.table_column;
+    }
+
+    // check for change to primary key
+    if (table_schema.primary_key != target_schema.primary_key) {
+        exceptions.emplace_back(ChangedPrimaryKeyException(table_schema.name, table_schema.primary_key, target_schema.primary_key));
+    }
+
+    // check for new missing properties
+    for (auto& target_prop : target_schema.persisted_properties) {
+        if (!table_schema.property_for_name(target_prop.name)) {
+            exceptions.emplace_back(ExtraPropertyException(table_schema.name, target_prop));
+        }
+    }
+
+    return exceptions;
+}
+
+template <typename T>
+static void copy_property_values(const Property& old_property, const Property& new_property, Table& table,
+                                 T (Table::*getter)(std::size_t, std::size_t) const noexcept,
+                                 void (Table::*setter)(std::size_t, std::size_t, T)) {
+    size_t old_column = old_property.table_column, new_column = new_property.table_column;
+    size_t count = table.size();
+    for (size_t i = 0; i < count; i++) {
+        (table.*setter)(new_column, i, (table.*getter)(old_column, i));
+    }
+}
+
+static void copy_property_values(const Property& source, const Property& destination, Table& table) {
+    switch (destination.type) {
+        case PropertyType::Int:
+            copy_property_values(source, destination, table, &Table::get_int, &Table::set_int);
+            break;
+        case PropertyType::Bool:
+            copy_property_values(source, destination, table, &Table::get_bool, &Table::set_bool);
+            break;
+        case PropertyType::Float:
+            copy_property_values(source, destination, table, &Table::get_float, &Table::set_float);
+            break;
+        case PropertyType::Double:
+            copy_property_values(source, destination, table, &Table::get_double, &Table::set_double);
+            break;
+        case PropertyType::String:
+            copy_property_values(source, destination, table, &Table::get_string, &Table::set_string);
+            break;
+        case PropertyType::Data:
+            copy_property_values(source, destination, table, &Table::get_binary, &Table::set_binary);
+            break;
+        case PropertyType::Date:
+            copy_property_values(source, destination, table, &Table::get_timestamp, &Table::set_timestamp);
+            break;
+        default:
+            break;
+    }
+}
+
+// set references to tables on targetSchema and create/update any missing or out-of-date tables
+// if update existing is true, updates existing tables, otherwise validates existing tables
+// NOTE: must be called from within write transaction
+std::vector<std::pair<std::string, Property>> ObjectStore::create_tables(Group *group, Schema &target_schema, bool update_existing) {
+    // properties to delete
+    std::vector<std::pair<std::string,Property>> to_delete;
+
+    // first pass to create missing tables
+    std::vector<ObjectSchema *> to_update;
+    for (auto& object_schema : target_schema) {
+        bool created = false;
+        ObjectStore::table_for_object_type_create_if_needed(group, object_schema.name, created);
+
+        // we will modify tables for any new objectSchema (table was created) or for all if update_existing is true
+        if (update_existing || created) {
+            to_update.push_back(&object_schema);
+        }
+    }
+
+    // second pass adds/removes columns for out of date tables
+    for (auto& target_object_schema : to_update) {
+        TableRef table = table_for_object_type(group, target_object_schema->name);
+        ObjectSchema current_schema(group, target_object_schema->name);
+        std::vector<Property> &target_props = target_object_schema->persisted_properties;
+
+        // handle columns changing from required to optional
+        for (auto& current_prop : current_schema.persisted_properties) {
+            auto target_prop = target_object_schema->property_for_name(current_prop.name);
+            if (!target_prop || !property_can_be_migrated_to_nullable(current_prop, *target_prop))
+                continue;
+
+            target_prop->table_column = current_prop.table_column;
+            current_prop.table_column = current_prop.table_column + 1;
+
+            table->insert_column(target_prop->table_column, DataType(target_prop->type), target_prop->name, target_prop->is_nullable);
+            copy_property_values(current_prop, *target_prop, *table);
+            table->remove_column(current_prop.table_column);
+
+            current_prop.table_column = target_prop->table_column;
+        }
+
+        bool inserted_placeholder_column = false;
+
+        // remove extra columns
+        size_t deleted = 0;
+        for (auto& current_prop : current_schema.persisted_properties) {
+            current_prop.table_column -= deleted;
+
+            auto target_prop = target_object_schema->property_for_name(current_prop.name);
+            // mark object name & property pairs for deletion
+            if (!target_prop) {
+                to_delete.push_back(std::make_pair(current_schema.name, current_prop));
+            }
+            else if ((property_has_changed(current_prop, *target_prop) &&
+                      !property_can_be_migrated_to_nullable(current_prop, *target_prop))) {
+                if (deleted == current_schema.persisted_properties.size() - 1) {
+                    // We're about to remove the last column from the table. Insert a placeholder column to preserve
+                    // the number of rows in the table for the addition of new columns below.
+                    table->add_column(type_Bool, "placeholder");
+                    inserted_placeholder_column = true;
+                }
+
+                table->remove_column(current_prop.table_column);
+                ++deleted;
+                current_prop.table_column = npos;
+            }
+        }
+
+        // add missing columns
+        for (auto& target_prop : target_props) {
+            auto current_prop = current_schema.property_for_name(target_prop.name);
+
+            // add any new properties (no old column or old column was removed due to not matching)
+            if (!current_prop || current_prop->table_column == npos) {
+                switch (target_prop.type) {
+                        // for objects and arrays, we have to specify target table
+                    case PropertyType::Object:
+                    case PropertyType::Array: {
+                        TableRef link_table = ObjectStore::table_for_object_type(group, target_prop.object_type);
+                        REALM_ASSERT(link_table);
+                        target_prop.table_column = table->add_column_link(DataType(target_prop.type), target_prop.name, *link_table);
+                        break;
+                    }
+                    default:
+                        target_prop.table_column = table->add_column(DataType(target_prop.type),
+                                                                     target_prop.name,
+                                                                     target_prop.is_nullable);
+                        break;
+                }
+            }
+            else {
+                target_prop.table_column = current_prop->table_column;
+            }
+        }
+
+        if (inserted_placeholder_column) {
+            // We inserted a placeholder due to removing all columns from the table. Remove it, and update the indices
+            // of any columns that we inserted after it.
+            table->remove_column(0);
+            for (auto& target_prop : target_props) {
+                target_prop.table_column--;
+            }
+        }
+
+        // update table metadata
+        if (target_object_schema->primary_key.length()) {
+            // if there is a primary key set, check if it is the same as the old key
+            if (current_schema.primary_key != target_object_schema->primary_key) {
+                set_primary_key_for_object(group, target_object_schema->name, target_object_schema->primary_key);
+            }
+        }
+        else if (current_schema.primary_key.length()) {
+            // there is no primary key, so if there was one nil out
+            set_primary_key_for_object(group, target_object_schema->name, "");
+        }
+    }
+    return to_delete;
+}
+
+void ObjectStore::remove_properties(Group *group, Schema &target_schema, std::vector<std::pair<std::string, Property>> to_delete) {
+    for (auto& target_object_schema : target_schema) {
+        TableRef table = table_for_object_type(group, target_object_schema.name);
+        ObjectSchema current_schema(group, target_object_schema.name);
+        size_t deleted = 0;
+        for (auto& current_prop : current_schema.persisted_properties) {
+            current_prop.table_column -= deleted;
+            for (auto& single_to_delete : to_delete) {
+                if (target_object_schema.name == single_to_delete.first &&
+                    current_prop.name == single_to_delete.second.name &&
+                    current_prop.object_type == single_to_delete.second.object_type) {
+                    table->remove_column(current_prop.table_column);
+                    ++deleted;
+                    current_prop.table_column = npos;
+                }
+            }
+        }
+    }
+}
+
+bool ObjectStore::is_schema_at_version(const Group *group, uint64_t version) {
+    uint64_t old_version = get_schema_version(group);
+    if (old_version > version && old_version != NotVersioned) {
+        throw InvalidSchemaVersionException(old_version, version);
+    }
+    return old_version == version;
+}
+
+bool ObjectStore::needs_update(Schema const& old_schema, Schema const& schema) {
+    for (auto const& target_schema : schema) {
+        auto matching_schema = old_schema.find(target_schema);
+        if (matching_schema == end(old_schema)) {
+            // Table doesn't exist
+            return true;
+        }
+
+        if (matching_schema->persisted_properties.size() != target_schema.persisted_properties.size()) {
+            // If the number of properties don't match then a migration is required
+            return false;
+        }
+
+        // Check that all of the property indexes are up to date
+        for (size_t i = 0, count = target_schema.persisted_properties.size(); i < count; ++i) {
+            if (target_schema.persisted_properties[i].is_indexed != matching_schema->persisted_properties[i].is_indexed) {
+                return true;
+            }
+        }
+    }
+
+    return false;
+}
+
+void ObjectStore::update_realm_with_schema(Group *group, Schema const& old_schema,
+                                           uint64_t version, Schema &schema,
+                                           MigrationFunction migration) {
+    // Recheck the schema version after beginning the write transaction as
+    // another process may have done the migration after we opened the read
+    // transaction
+    bool migrating = !is_schema_at_version(group, version);
+
+    // create tables
+    create_metadata_tables(group);
+    auto to_delete = create_tables(group, schema, migrating);
+
+    if (!migrating) {
+        // If we aren't migrating, then verify that all of the tables which
+        // were already present are valid (newly created ones always are)
+        verify_schema(old_schema, schema, true);
+    }
+
+    update_indexes(group, schema);
+
+    if (!migrating) {
+        return;
+    }
+
+    // apply the migration block if provided and there's any old data
+    if (get_schema_version(group) != ObjectStore::NotVersioned) {
+        migration(group, schema);
+        remove_properties(group, schema, std::move(to_delete));
+
+        Schema group_schema = schema_from_group(group);
+        verify_missing_renamed_properties(group_schema, schema);
+        verify_schema(group_schema, schema);
+        validate_primary_column_uniqueness(group, schema);
+    }
+
+    set_schema_version(group, version);
+}
+
+Schema ObjectStore::schema_from_group(const Group *group) {
+    std::vector<ObjectSchema> schema;
+    for (size_t i = 0; i < group->size(); i++) {
+        std::string object_type = object_type_for_table_name(group->get_table_name(i));
+        if (object_type.length()) {
+            schema.emplace_back(group, object_type);
+        }
+    }
+    return schema;
+}
+
+bool ObjectStore::update_indexes(Group *group, Schema &schema) {
+    bool changed = false;
+    for (auto& object_schema : schema) {
+        TableRef table = table_for_object_type(group, object_schema.name);
+        if (!table) {
+            continue;
+        }
+
+        for (auto& property : object_schema.persisted_properties) {
+            if (property.requires_index() == table->has_search_index(property.table_column)) {
+                continue;
+            }
+
+            changed = true;
+            if (property.requires_index()) {
+                try {
+                    table->add_search_index(property.table_column);
+                }
+                catch (LogicError const&) {
+                    throw PropertyTypeNotIndexableException(object_schema.name, property);
+                }
+            }
+            else {
+                table->remove_search_index(property.table_column);
+            }
+        }
+    }
+    return changed;
+}
+
+void ObjectStore::validate_primary_column_uniqueness(const Group *group, Schema const& schema) {
+    for (auto& object_schema : schema) {
+        auto primary_prop = object_schema.primary_key_property();
+        if (!primary_prop) {
+            continue;
+        }
+
+        ConstTableRef table = table_for_object_type(group, object_schema.name);
+        if (table->get_distinct_view(primary_prop->table_column).size() != table->size()) {
+            throw DuplicatePrimaryKeyValueException(object_schema.name, *primary_prop);
+        }
+    }
+}
+
+void ObjectStore::delete_data_for_object(Group *group, StringData object_type) {
+    TableRef table = table_for_object_type(group, object_type);
+    if (table) {
+        group->remove_table(table->get_index_in_group());
+        set_primary_key_for_object(group, object_type, "");
+    }
+}
+
+void ObjectStore::rename_property(Group *group, Schema& passed_schema, StringData object_type, StringData old_name, StringData new_name) {
+    TableRef table = table_for_object_type(group, object_type);
+    if (!table) {
+        throw PropertyRenameMissingNewObjectTypeException(object_type);
+    }
+    ObjectSchema matching_schema(group, object_type);
+    Property *old_property = matching_schema.property_for_name(old_name);
+    if (old_property == nullptr) {
+        throw PropertyRenameMissingOldPropertyException(old_name, new_name);
+    }
+    auto passed_object_schema = passed_schema.find(object_type);
+    if (passed_object_schema == passed_schema.end()) {
+        throw PropertyRenameMissingNewObjectTypeException(object_type);
+    }
+    Property *new_property = matching_schema.property_for_name(new_name);
+    if (new_property == nullptr) {
+        // new property not in new schema, which means we're probably renaming
+        // to an intermediate property in a multi-version migration.
+        // this is safe because the migration will fail schema validation unless
+        // this property is renamed again.
+        new_property = matching_schema.property_for_name(old_name);
+        new_property->name = new_name;
+        table->rename_column(old_property->table_column, new_name);
+        return;
+    }
+    if (old_property->type != new_property->type ||
+        old_property->object_type != new_property->object_type) {
+        throw PropertyRenameTypeMismatchException(*old_property, *new_property);
+    }
+    if (passed_object_schema->property_for_name(old_name) != nullptr) {
+        throw PropertyRenameOldStillExistsException(old_name, new_name);
+    }
+    size_t column_to_remove = new_property->table_column;
+    table->rename_column(old_property->table_column, new_name);
+    table->remove_column(column_to_remove);
+    // update table_column for each property since it may have shifted
+    for (auto& current_prop : passed_object_schema->persisted_properties) {
+        auto target_prop = matching_schema.property_for_name(current_prop.name);
+        current_prop.table_column = target_prop->table_column;
+    }
+    // update index for new column
+    if (new_property->requires_index() && !old_property->requires_index()) {
+        table->add_search_index(old_property->table_column);
+    } else if (!new_property->requires_index() && old_property->requires_index()) {
+        table->remove_search_index(old_property->table_column);
+    }
+    old_property->name = new_name;
+    // update nullability for column
+    if (property_can_be_migrated_to_nullable(*old_property, *new_property)) {
+        new_property->table_column = old_property->table_column;
+        old_property->table_column = old_property->table_column + 1;
+
+        table->insert_column(new_property->table_column, DataType(new_property->type), new_property->name, new_property->is_nullable);
+        copy_property_values(*old_property, *new_property, *table);
+        table->remove_column(old_property->table_column);
+
+        old_property->table_column = new_property->table_column;
+    }
+}
+
+bool ObjectStore::is_empty(const Group *group) {
+    for (size_t i = 0; i < group->size(); i++) {
+        ConstTableRef table = group->get_table(i);
+        std::string object_type = object_type_for_table_name(table->get_name());
+        if (!object_type.length()) {
+            continue;
+        }
+        if (!table->is_empty()) {
+            return false;
+        }
+    }
+    return true;
+}
+
+PropertyRenameException::PropertyRenameException(std::string old_property_name, std::string new_property_name) :
+    m_old_property_name(old_property_name), m_new_property_name(new_property_name)
+{
+    m_what = util::format("Old property '%1' cannot be renamed to property '%2'.",
+                          old_property_name, new_property_name);
+}
+
+PropertyRenameMissingObjectTypeException::PropertyRenameMissingObjectTypeException(std::string object_type) :
+    m_object_type(object_type)
+{
+    m_what = util::format("Cannot rename properties on type '%1'.", object_type);
+}
+
+PropertyRenameMissingOldObjectTypeException::PropertyRenameMissingOldObjectTypeException(std::string object_type) :
+    PropertyRenameMissingObjectTypeException(object_type)
+{
+    m_what = util::format("Cannot rename properties on type '%1' because it is missing from the Realm file.",
+                          object_type);
+}
+
+PropertyRenameMissingNewObjectTypeException::PropertyRenameMissingNewObjectTypeException(std::string object_type) :
+    PropertyRenameMissingObjectTypeException(object_type)
+{
+    m_what = util::format("Cannot rename properties on type '%1' because it is missing from the specified schema.",
+                          object_type);
+}
+
+PropertyRenameMissingOldPropertyException::PropertyRenameMissingOldPropertyException(std::string old_property_name, std::string new_property_name) :
+    PropertyRenameException(old_property_name, new_property_name)
+{
+    m_what = util::format("Old property '%1' is missing from the Realm file so it cannot be renamed to '%2'.",
+                          old_property_name, new_property_name);
+}
+
+PropertyRenameMissingNewPropertyException::PropertyRenameMissingNewPropertyException(std::string new_property_name) :
+    m_new_property_name(new_property_name)
+{
+    m_what = util::format("Renamed property '%1' is not in the latest model.", new_property_name);
+}
+
+PropertyRenameOldStillExistsException::PropertyRenameOldStillExistsException(std::string old_property_name, std::string new_property_name) :
+    PropertyRenameException(old_property_name, new_property_name)
+{
+    m_what = util::format("Old property '%1' cannot be renamed to '%2' because the old property is still present "
+                          "in the specified schema.", old_property_name, new_property_name);
+}
+
+PropertyRenameTypeMismatchException::PropertyRenameTypeMismatchException(Property const& old_property, Property const& new_property) :
+    m_old_property(old_property), m_new_property(new_property)
+{
+    m_what = util::format("Old property '%1' of type '%2' cannot be renamed to property '%3' of type '%4'.",
+                          old_property.name, old_property.type_string(),
+                          new_property.name, new_property.type_string());
+}
+
+InvalidSchemaVersionException::InvalidSchemaVersionException(uint64_t old_version, uint64_t new_version) :
+    m_old_version(old_version), m_new_version(new_version)
+{
+    m_what = util::format("Provided schema version %1 is less than last set version %2.", new_version, old_version);
+}
+
+DuplicatePrimaryKeyValueException::DuplicatePrimaryKeyValueException(std::string const& object_type, Property const& property) :
+    m_object_type(object_type), m_property(property)
+{
+    m_what = util::format("Primary key property '%1' has duplicate values after migration.", property.name);
+}
+
+SchemaValidationException::SchemaValidationException(std::vector<ObjectSchemaValidationException> const& errors)
+: m_validation_errors(errors)
+{
+    m_what = "Schema validation failed due to the following errors:";
+    for (auto const& error : errors) {
+        m_what += std::string("\n- ") + error.what();
+    }
+}
+
+SchemaMismatchException::SchemaMismatchException(std::vector<ObjectSchemaValidationException> const& errors) :
+    m_validation_errors(errors)
+{
+    m_what = "Migration is required due to the following errors:";
+    for (auto const& error : errors) {
+        m_what += std::string("\n- ") + error.what();
+    }
+}
+
+PropertyTypeNotIndexableException::PropertyTypeNotIndexableException(std::string const& object_type,
+                                                                     Property const& property)
+: ObjectSchemaPropertyException(object_type, property)
+{
+    m_what = util::format("Can't index property %1.%2: indexing a property of type '%3' is currently not supported.",
+                          object_type, property.name, string_for_property_type(property.type));
+}
+
+ExtraPropertyException::ExtraPropertyException(std::string const& object_type, Property const& property) :
+    ObjectSchemaPropertyException(object_type, property)
+{
+    m_what = util::format("Property '%1' has been added to latest object model.", property.name);
+}
+
+MissingPropertyException::MissingPropertyException(std::string const& object_type, Property const& property) :
+    ObjectSchemaPropertyException(object_type, property)
+{
+    m_what = util::format("Property '%1' is missing from latest object model.", property.name);
+}
+
+InvalidNullabilityException::InvalidNullabilityException(std::string const& object_type, Property const& property) :
+    ObjectSchemaPropertyException(object_type, property)
+{
+    switch (property.type) {
+        case PropertyType::Object:
+            m_what = util::format("'Object' property '%1' must be nullable.", property.name);
+            break;
+        case PropertyType::Any:
+        case PropertyType::Array:
+        case PropertyType::LinkingObjects:
+            m_what = util::format("Property '%1' of type '%2' cannot be nullable.",
+                                  property.name, string_for_property_type(property.type));
+            break;
+        case PropertyType::Int:
+        case PropertyType::Bool:
+        case PropertyType::Data:
+        case PropertyType::Date:
+        case PropertyType::Float:
+        case PropertyType::Double:
+        case PropertyType::String:
+            REALM_ASSERT(false);
+    }
+}
+
+MissingObjectTypeException::MissingObjectTypeException(std::string const& object_type, Property const& property)
+: ObjectSchemaPropertyException(object_type, property)
+{
+    m_what = util::format("Target type '%1' doesn't exist for property '%2'.",
+                          property.object_type, property.name);
+}
+
+MismatchedPropertiesException::MismatchedPropertiesException(std::string const& object_type,
+                                                             Property const& old_property,
+                                                             Property const& new_property) :
+    ObjectSchemaValidationException(object_type), m_old_property(old_property), m_new_property(new_property)
+{
+    if (new_property.type != old_property.type) {
+        m_what = util::format("Property types for '%1' property do not match. Old type '%2', new type '%3'.",
+                              old_property.name,
+                              string_for_property_type(old_property.type),
+                              string_for_property_type(new_property.type));
+    }
+    else if (new_property.object_type != old_property.object_type) {
+        m_what = util::format("Target object type for property '%1' do not match. Old type '%2', new type '%3'.",
+                              old_property.name, old_property.object_type, new_property.object_type);
+    }
+    else if (new_property.is_nullable != old_property.is_nullable) {
+        m_what = util::format("Nullability for property '%1' has been changed from %2 to %3.",
+                              old_property.name,
+                              old_property.is_nullable, new_property.is_nullable);
+    }
+}
+
+ChangedPrimaryKeyException::ChangedPrimaryKeyException(std::string const& object_type,
+                                                       std::string const& old_primary,
+                                                       std::string const& new_primary)
+: ObjectSchemaValidationException(object_type), m_old_primary(old_primary), m_new_primary(new_primary)
+{
+    if (old_primary.size()) {
+        m_what = util::format("Property '%1' is no longer a primary key.", old_primary);
+    }
+    else {
+        m_what = util::format("Property '%1' has been made a primary key.", new_primary);
+    }
+}
+
+InvalidPrimaryKeyException::InvalidPrimaryKeyException(std::string const& object_type, std::string const& primary) :
+    ObjectSchemaValidationException(object_type), m_primary_key(primary)
+{
+    m_what = util::format("Specified primary key property '%1' does not exist.", primary);
+}
+
+DuplicatePrimaryKeysException::DuplicatePrimaryKeysException(std::string const& object_type)
+: ObjectSchemaValidationException(object_type)
+{
+    m_what = util::format("Duplicate primary keys for object '%1'.", object_type);
+}
+
+InvalidLinkingObjectsPropertyException::InvalidLinkingObjectsPropertyException(Type error_type, std::string const& object_type, Property const& property)
+: ObjectSchemaPropertyException(object_type, property)
+{
+    switch (error_type) {
+        case Type::OriginPropertyDoesNotExist:
+            m_what = util::format("Property '%1.%2' declared as origin of linking objects property '%3.%4' does not exist.",
+                                  property.object_type, property.link_origin_property_name,
+                                  object_type, property.name);
+            break;
+        case Type::OriginPropertyIsNotALink:
+            m_what = util::format("Property '%1.%2' declared as origin of linking objects property '%3.%4' is not a link.",
+                                  property.object_type, property.link_origin_property_name,
+                                  object_type, property.name);
+            break;
+        case Type::OriginPropertyInvalidLinkTarget:
+            m_what = util::format("Property '%1.%2' declared as origin of linking objects property '%3.%4' links to a different class.",
+                                  property.object_type, property.link_origin_property_name,
+                                  object_type, property.name);
+            break;
+    }
+}
diff --git a/Pods/Realm/Realm/ObjectStore/results.cpp b/Pods/Realm/Realm/ObjectStore/results.cpp
new file mode 100644
index 0000000..6ac0466
--- /dev/null
+++ b/Pods/Realm/Realm/ObjectStore/results.cpp
@@ -0,0 +1,550 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2015 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#include "results.hpp"
+
+#include "impl/realm_coordinator.hpp"
+#include "impl/results_notifier.hpp"
+#include "object_store.hpp"
+#include "util/format.hpp"
+
+#include <stdexcept>
+
+using namespace realm;
+
+#ifdef __has_cpp_attribute
+#define REALM_HAS_CCP_ATTRIBUTE(attr) __has_cpp_attribute(attr)
+#else
+#define REALM_HAS_CCP_ATTRIBUTE(attr) 0
+#endif
+
+#if REALM_HAS_CCP_ATTRIBUTE(clang::fallthrough)
+#define REALM_FALLTHROUGH [[clang::fallthrough]]
+#else
+#define REALM_FALLTHROUGH
+#endif
+
+Results::Results() = default;
+Results::~Results() = default;
+
+Results::Results(SharedRealm r, Query q, SortOrder s)
+: m_realm(std::move(r))
+, m_query(std::move(q))
+, m_table(m_query.get_table().get())
+, m_sort(std::move(s))
+, m_mode(Mode::Query)
+{
+    REALM_ASSERT(m_sort.column_indices.size() == m_sort.ascending.size());
+}
+
+Results::Results(SharedRealm r, Table& table)
+: m_realm(std::move(r))
+, m_table(&table)
+, m_mode(Mode::Table)
+{
+}
+
+Results::Results(SharedRealm r, LinkViewRef lv, util::Optional<Query> q, SortOrder s)
+: m_realm(std::move(r))
+, m_link_view(lv)
+, m_table(&lv->get_target_table())
+, m_sort(std::move(s))
+, m_mode(Mode::LinkView)
+{
+    REALM_ASSERT(m_sort.column_indices.size() == m_sort.ascending.size());
+    if (q) {
+        m_query = std::move(*q);
+        m_mode = Mode::Query;
+    }
+}
+
+Results::Results(SharedRealm r, SortOrder s, TableView tv)
+: m_realm(std::move(r))
+, m_table_view(std::move(tv))
+, m_table(&m_table_view.get_parent())
+, m_sort(std::move(s))
+, m_mode(Mode::TableView)
+{
+    REALM_ASSERT(m_sort.column_indices.size() == m_sort.ascending.size());
+}
+
+Results::Results(const Results&) = default;
+
+// Cannot be defaulted as TableViewBase::operator= is missing from the core static library.
+// Delegate to the copy constructor and move-assignment operators instead.
+Results& Results::operator=(const Results& other)
+{
+    if (this != &other) {
+        *this = Results(other);
+    }
+
+    return *this;
+}
+
+Results::Results(Results&& other)
+: m_realm(std::move(other.m_realm))
+, m_query(std::move(other.m_query))
+, m_table_view(std::move(other.m_table_view))
+, m_link_view(std::move(other.m_link_view))
+, m_table(other.m_table)
+, m_sort(std::move(other.m_sort))
+, m_notifier(std::move(other.m_notifier))
+, m_mode(other.m_mode)
+, m_has_used_table_view(other.m_has_used_table_view)
+, m_wants_background_updates(other.m_wants_background_updates)
+{
+    if (m_notifier) {
+        m_notifier->target_results_moved(other, *this);
+    }
+}
+
+Results& Results::operator=(Results&& other)
+{
+    this->~Results();
+    new (this) Results(std::move(other));
+    return *this;
+}
+
+bool Results::is_valid() const
+{
+    if (m_realm)
+        m_realm->verify_thread();
+
+    if (m_table && !m_table->is_attached())
+        return false;
+
+    return true;
+}
+
+void Results::validate_read() const
+{
+    // is_valid ensures that we're on the correct thread.
+    if (!is_valid())
+        throw InvalidatedException();
+}
+
+void Results::validate_write() const
+{
+    validate_read();
+    if (!m_realm || !m_realm->is_in_transaction())
+        throw InvalidTransactionException("Must be in a write transaction");
+}
+
+size_t Results::size()
+{
+    validate_read();
+    switch (m_mode) {
+        case Mode::Empty:    return 0;
+        case Mode::Table:    return m_table->size();
+        case Mode::LinkView: return m_link_view->size();
+        case Mode::Query:
+            m_query.sync_view_if_needed();
+            return m_query.count();
+        case Mode::TableView:
+            update_tableview();
+            return m_table_view.size();
+    }
+    REALM_UNREACHABLE();
+}
+
+RowExpr Results::get(size_t row_ndx)
+{
+    validate_read();
+    switch (m_mode) {
+        case Mode::Empty: break;
+        case Mode::Table:
+            if (row_ndx < m_table->size())
+                return m_table->get(row_ndx);
+            break;
+        case Mode::LinkView:
+            if (update_linkview()) {
+                if (row_ndx < m_link_view->size())
+                    return m_link_view->get(row_ndx);
+                break;
+            }
+            REALM_FALLTHROUGH;
+        case Mode::Query:
+        case Mode::TableView:
+            update_tableview();
+            if (row_ndx < m_table_view.size())
+                return m_table_view.get(row_ndx);
+            break;
+    }
+
+    throw OutOfBoundsIndexException{row_ndx, size()};
+}
+
+util::Optional<RowExpr> Results::first()
+{
+    validate_read();
+    switch (m_mode) {
+        case Mode::Empty:
+            return none;
+        case Mode::Table:
+            return m_table->size() == 0 ? util::none : util::make_optional(m_table->front());
+        case Mode::LinkView:
+            if (update_linkview())
+                return m_link_view->size() == 0 ? util::none : util::make_optional(m_link_view->get(0));
+            REALM_FALLTHROUGH;
+        case Mode::Query:
+        case Mode::TableView:
+            update_tableview();
+            return m_table_view.size() == 0 ? util::none : util::make_optional(m_table_view.front());
+    }
+    REALM_UNREACHABLE();
+}
+
+util::Optional<RowExpr> Results::last()
+{
+    validate_read();
+    switch (m_mode) {
+        case Mode::Empty:
+            return none;
+        case Mode::Table:
+            return m_table->size() == 0 ? util::none : util::make_optional(m_table->back());
+        case Mode::LinkView:
+            if (update_linkview())
+                return m_link_view->size() == 0 ? util::none : util::make_optional(m_link_view->get(m_link_view->size() - 1));
+            REALM_FALLTHROUGH;
+        case Mode::Query:
+        case Mode::TableView:
+            update_tableview();
+            return m_table_view.size() == 0 ? util::none : util::make_optional(m_table_view.back());
+    }
+    REALM_UNREACHABLE();
+}
+
+bool Results::update_linkview()
+{
+    if (m_sort) {
+        m_query = get_query();
+        m_mode = Mode::Query;
+        update_tableview();
+        return false;
+    }
+    return true;
+}
+
+void Results::update_tableview()
+{
+    validate_read();
+    switch (m_mode) {
+        case Mode::Empty:
+        case Mode::Table:
+        case Mode::LinkView:
+            return;
+        case Mode::Query:
+            m_query.sync_view_if_needed();
+            m_table_view = m_query.find_all();
+            if (m_sort) {
+                m_table_view.sort(m_sort.column_indices, m_sort.ascending);
+            }
+            m_mode = Mode::TableView;
+            break;
+        case Mode::TableView:
+            if (!m_notifier && !m_realm->is_in_transaction() && m_realm->can_deliver_notifications()) {
+                m_notifier = std::make_shared<_impl::ResultsNotifier>(*this);
+                _impl::RealmCoordinator::register_notifier(m_notifier);
+            }
+            m_has_used_table_view = true;
+            m_table_view.sync_if_needed();
+            break;
+    }
+}
+
+size_t Results::index_of(Row const& row)
+{
+    validate_read();
+    if (!row) {
+        throw DetatchedAccessorException{};
+    }
+    if (m_table && row.get_table() != m_table) {
+        throw IncorrectTableException{
+            ObjectStore::object_type_for_table_name(m_table->get_name()),
+            ObjectStore::object_type_for_table_name(row.get_table()->get_name()),
+            "Attempting to get the index of a Row of the wrong type"
+        };
+    }
+    return index_of(row.get_index());
+}
+
+size_t Results::index_of(size_t row_ndx)
+{
+    validate_read();
+    switch (m_mode) {
+        case Mode::Empty:
+            return not_found;
+        case Mode::Table:
+            return row_ndx;
+        case Mode::LinkView:
+            if (update_linkview())
+                return m_link_view->find(row_ndx);
+            REALM_FALLTHROUGH;
+        case Mode::Query:
+        case Mode::TableView:
+            update_tableview();
+            return m_table_view.find_by_source_ndx(row_ndx);
+    }
+    REALM_UNREACHABLE();
+}
+
+template<typename Int, typename Float, typename Double, typename Timestamp>
+util::Optional<Mixed> Results::aggregate(size_t column, bool return_none_for_empty,
+                                         const char* name,
+                                         Int agg_int, Float agg_float,
+                                         Double agg_double, Timestamp agg_timestamp)
+{
+    validate_read();
+    if (!m_table)
+        return none;
+    if (column > m_table->get_column_count())
+        throw OutOfBoundsIndexException{column, m_table->get_column_count()};
+
+    auto do_agg = [&](auto const& getter) -> util::Optional<Mixed> {
+        switch (m_mode) {
+            case Mode::Empty:
+                return none;
+            case Mode::Table:
+                if (return_none_for_empty && m_table->size() == 0)
+                    return none;
+                return util::Optional<Mixed>(getter(*m_table));
+            case Mode::LinkView:
+                m_query = this->get_query();
+                m_mode = Mode::Query;
+                REALM_FALLTHROUGH;
+            case Mode::Query:
+            case Mode::TableView:
+                this->update_tableview();
+                if (return_none_for_empty && m_table_view.size() == 0)
+                    return none;
+                return util::Optional<Mixed>(getter(m_table_view));
+        }
+        REALM_UNREACHABLE();
+    };
+
+    switch (m_table->get_column_type(column))
+    {
+        case type_Timestamp: return do_agg(agg_timestamp);
+        case type_Double: return do_agg(agg_double);
+        case type_Float: return do_agg(agg_float);
+        case type_Int: return do_agg(agg_int);
+        default:
+            throw UnsupportedColumnTypeException{column, m_table, name};
+    }
+}
+
+util::Optional<Mixed> Results::max(size_t column)
+{
+    return aggregate(column, true, "max",
+                     [=](auto const& table) { return table.maximum_int(column); },
+                     [=](auto const& table) { return table.maximum_float(column); },
+                     [=](auto const& table) { return table.maximum_double(column); },
+                     [=](auto const& table) { return table.maximum_timestamp(column); });
+}
+
+util::Optional<Mixed> Results::min(size_t column)
+{
+    return aggregate(column, true, "min",
+                     [=](auto const& table) { return table.minimum_int(column); },
+                     [=](auto const& table) { return table.minimum_float(column); },
+                     [=](auto const& table) { return table.minimum_double(column); },
+                     [=](auto const& table) { return table.minimum_timestamp(column); });
+}
+
+util::Optional<Mixed> Results::sum(size_t column)
+{
+    return aggregate(column, false, "sum",
+                     [=](auto const& table) { return table.sum_int(column); },
+                     [=](auto const& table) { return table.sum_float(column); },
+                     [=](auto const& table) { return table.sum_double(column); },
+                     [=](auto const&) -> util::None { throw UnsupportedColumnTypeException{column, m_table, "sum"}; });
+}
+
+util::Optional<Mixed> Results::average(size_t column)
+{
+    return aggregate(column, true, "average",
+                     [=](auto const& table) { return table.average_int(column); },
+                     [=](auto const& table) { return table.average_float(column); },
+                     [=](auto const& table) { return table.average_double(column); },
+                     [=](auto const&) -> util::None { throw UnsupportedColumnTypeException{column, m_table, "average"}; });
+}
+
+void Results::clear()
+{
+    switch (m_mode) {
+        case Mode::Empty:
+            return;
+        case Mode::Table:
+            validate_write();
+            m_table->clear();
+            break;
+        case Mode::Query:
+            // Not using Query:remove() because building the tableview and
+            // clearing it is actually significantly faster
+        case Mode::TableView:
+            validate_write();
+            update_tableview();
+            m_table_view.clear(RemoveMode::unordered);
+            break;
+        case Mode::LinkView:
+            validate_write();
+            m_link_view->remove_all_target_rows();
+            break;
+    }
+}
+
+Query Results::get_query() const
+{
+    validate_read();
+    switch (m_mode) {
+        case Mode::Empty:
+        case Mode::Query:
+            return m_query;
+        case Mode::TableView: {
+            // A TableView has an associated Query if it was produced by Query::find_all. This is indicated
+            // by TableView::get_query returning a Query with a non-null table.
+            Query query = m_table_view.get_query();
+            if (query.get_table()) {
+                return query;
+            }
+
+            // The TableView has no associated query so create one with no conditions that is restricted
+            // to the rows in the TableView.
+            m_table_view.sync_if_needed();
+            return Query(*m_table, std::unique_ptr<TableViewBase>(new TableView(m_table_view)));
+        }
+        case Mode::LinkView:
+            return m_table->where(m_link_view);
+        case Mode::Table:
+            return m_table->where();
+    }
+    REALM_UNREACHABLE();
+}
+
+TableView Results::get_tableview()
+{
+    validate_read();
+    switch (m_mode) {
+        case Mode::Empty:
+            return {};
+        case Mode::LinkView:
+            if (update_linkview())
+                return m_table->where(m_link_view).find_all();
+            REALM_FALLTHROUGH;
+        case Mode::Query:
+        case Mode::TableView:
+            update_tableview();
+            return m_table_view;
+        case Mode::Table:
+            return m_table->where().find_all();
+    }
+    REALM_UNREACHABLE();
+}
+
+StringData Results::get_object_type() const noexcept
+{
+    if (!m_table) {
+        return StringData();
+    }
+
+    return ObjectStore::object_type_for_table_name(m_table->get_name());
+}
+
+Results Results::sort(realm::SortOrder&& sort) const
+{
+    return Results(m_realm, get_query(), std::move(sort));
+}
+
+Results Results::filter(Query&& q) const
+{
+    return Results(m_realm, get_query().and_query(std::move(q)), m_sort);
+}
+
+void Results::prepare_async()
+{
+    if (m_realm->config().read_only) {
+        throw InvalidTransactionException("Cannot create asynchronous query for read-only Realms");
+    }
+    if (m_realm->is_in_transaction()) {
+        throw InvalidTransactionException("Cannot create asynchronous query while in a write transaction");
+    }
+
+    if (!m_notifier) {
+        m_wants_background_updates = true;
+        m_notifier = std::make_shared<_impl::ResultsNotifier>(*this);
+        _impl::RealmCoordinator::register_notifier(m_notifier);
+    }
+}
+
+NotificationToken Results::async(std::function<void (std::exception_ptr)> target)
+{
+    prepare_async();
+    auto wrap = [=](CollectionChangeSet, std::exception_ptr e) { target(e); };
+    return {m_notifier, m_notifier->add_callback(wrap)};
+}
+
+NotificationToken Results::add_notification_callback(CollectionChangeCallback cb)
+{
+    prepare_async();
+    return {m_notifier, m_notifier->add_callback(std::move(cb))};
+}
+
+bool Results::is_in_table_order() const
+{
+    switch (m_mode) {
+        case Mode::Empty:
+        case Mode::Table:
+            return true;
+        case Mode::LinkView:
+            return false;
+        case Mode::Query:
+            return m_query.produces_results_in_table_order() && !m_sort;
+        case Mode::TableView:
+            return m_table_view.is_in_table_order();
+    }
+    REALM_UNREACHABLE(); // keep gcc happy
+}
+
+void Results::Internal::set_table_view(Results& results, realm::TableView &&tv)
+{
+    // If the previous TableView was never actually used, then stop generating
+    // new ones until the user actually uses the Results object again
+    if (results.m_mode == Mode::TableView) {
+        results.m_wants_background_updates = results.m_has_used_table_view;
+    }
+
+    results.m_table_view = std::move(tv);
+    results.m_mode = Mode::TableView;
+    results.m_has_used_table_view = false;
+    REALM_ASSERT(results.m_table_view.is_in_sync());
+    REALM_ASSERT(results.m_table_view.is_attached());
+}
+
+Results::OutOfBoundsIndexException::OutOfBoundsIndexException(size_t r, size_t c)
+: std::out_of_range(util::format("Requested index %1 greater than max %2", r, c))
+, requested(r), valid_count(c) {}
+
+Results::UnsupportedColumnTypeException::UnsupportedColumnTypeException(size_t column, const Table* table, const char* operation)
+: std::runtime_error(util::format("Cannot %1 property '%2': operation not supported for '%3' properties",
+                                  operation, table->get_column_name(column),
+                                  string_for_property_type(static_cast<PropertyType>(table->get_column_type(column)))))
+, column_index(column)
+, column_name(table->get_column_name(column))
+, column_type(table->get_column_type(column))
+{
+}
diff --git a/Pods/Realm/Realm/ObjectStore/schema.cpp b/Pods/Realm/Realm/ObjectStore/schema.cpp
new file mode 100644
index 0000000..cee9b7c
--- /dev/null
+++ b/Pods/Realm/Realm/ObjectStore/schema.cpp
@@ -0,0 +1,131 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2015 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#include "schema.hpp"
+
+#include "object_schema.hpp"
+#include "object_store.hpp"
+#include "property.hpp"
+
+#include <algorithm>
+
+using namespace realm;
+
+static bool compare_by_name(ObjectSchema const& lft, ObjectSchema const& rgt) {
+    return lft.name < rgt.name;
+}
+
+Schema::Schema(std::initializer_list<ObjectSchema> types) : Schema(base(types)) { }
+
+Schema::Schema(base types) : base(std::move(types)) {
+    std::sort(begin(), end(), compare_by_name);
+}
+
+Schema::iterator Schema::find(std::string const& name)
+{
+    ObjectSchema cmp;
+    cmp.name = name;
+    return find(cmp);
+}
+
+Schema::const_iterator Schema::find(std::string const& name) const
+{
+    return const_cast<Schema *>(this)->find(name);
+}
+
+Schema::iterator Schema::find(ObjectSchema const& object) noexcept
+{
+    auto it = std::lower_bound(begin(), end(), object, compare_by_name);
+    if (it != end() && it->name != object.name) {
+        it = end();
+    }
+    return it;
+}
+
+Schema::const_iterator Schema::find(ObjectSchema const& object) const noexcept
+{
+    return const_cast<Schema *>(this)->find(object);
+}
+
+void Schema::validate() const
+{
+    std::vector<ObjectSchemaValidationException> exceptions;
+    for (auto const& object : *this) {
+        const Property *primary = nullptr;
+
+        std::vector<Property> all_properties = object.persisted_properties;
+        all_properties.insert(all_properties.end(), object.computed_properties.begin(), object.computed_properties.end());
+
+        for (auto const& prop : all_properties) {
+            // check object_type existence
+            if (!prop.object_type.empty()) {
+                auto it = find(prop.object_type);
+                if (it == end()) {
+                    exceptions.emplace_back(MissingObjectTypeException(object.name, prop));
+                }
+                // validate linking objects property.
+                else if (!prop.link_origin_property_name.empty()) {
+                    using ErrorType = InvalidLinkingObjectsPropertyException::Type;
+                    util::Optional<ErrorType> error;
+
+                    const Property *origin_property = it->property_for_name(prop.link_origin_property_name);
+                    if (!origin_property) {
+                        error = ErrorType::OriginPropertyDoesNotExist;
+                    }
+                    else if (origin_property->type != PropertyType::Object && origin_property->type != PropertyType::Array) {
+                        error = ErrorType::OriginPropertyIsNotALink;
+                    }
+                    else if (origin_property->object_type != object.name) {
+                        error = ErrorType::OriginPropertyInvalidLinkTarget;
+                    }
+
+                    if (error) {
+                        exceptions.emplace_back(InvalidLinkingObjectsPropertyException(*error, object.name, prop));
+                    }
+                }
+            }
+
+            // check nullablity
+            if (prop.is_nullable) {
+                if (prop.type == PropertyType::Array || prop.type == PropertyType::Any || prop.type == PropertyType::LinkingObjects) {
+                    exceptions.emplace_back(InvalidNullabilityException(object.name, prop));
+                }
+            }
+            else if (prop.type == PropertyType::Object) {
+                exceptions.emplace_back(InvalidNullabilityException(object.name, prop));
+            }
+
+            // check primary keys
+            if (prop.is_primary) {
+                if (primary) {
+                    exceptions.emplace_back(DuplicatePrimaryKeysException(object.name));
+                }
+                primary = &prop;
+            }
+
+            // check indexable
+            if (prop.is_indexed && !prop.is_indexable()) {
+                exceptions.emplace_back(PropertyTypeNotIndexableException(object.name, prop));
+            }
+        }
+    }
+
+    if (exceptions.size()) {
+        throw SchemaValidationException(exceptions);
+    }
+}
diff --git a/Pods/Realm/Realm/ObjectStore/shared_realm.cpp b/Pods/Realm/Realm/ObjectStore/shared_realm.cpp
new file mode 100644
index 0000000..c85b2a7
--- /dev/null
+++ b/Pods/Realm/Realm/ObjectStore/shared_realm.cpp
@@ -0,0 +1,522 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2015 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#include "shared_realm.hpp"
+
+#include "binding_context.hpp"
+#include "impl/realm_coordinator.hpp"
+#include "impl/transact_log_handler.hpp"
+#include "object_schema.hpp"
+#include "object_store.hpp"
+#include "schema.hpp"
+#include "util/format.hpp"
+
+#include <realm/commit_log.hpp>
+#include <realm/group_shared.hpp>
+
+using namespace realm;
+using namespace realm::_impl;
+
+Realm::Config::Config(const Config& c)
+: path(c.path)
+, encryption_key(c.encryption_key)
+, schema_version(c.schema_version)
+, migration_function(c.migration_function)
+, delete_realm_if_migration_needed(c.delete_realm_if_migration_needed)
+, read_only(c.read_only)
+, in_memory(c.in_memory)
+, cache(c.cache)
+, disable_format_upgrade(c.disable_format_upgrade)
+, automatic_change_notifications(c.automatic_change_notifications)
+{
+    if (c.schema) {
+        schema = std::make_unique<Schema>(*c.schema);
+    }
+}
+
+Realm::Config::Config() : schema_version(ObjectStore::NotVersioned) { }
+Realm::Config::Config(Config&&) = default;
+Realm::Config::~Config() = default;
+
+Realm::Config& Realm::Config::operator=(realm::Realm::Config const& c)
+{
+    if (&c != this) {
+        *this = Config(c);
+    }
+    return *this;
+}
+
+Realm::Realm(Config config)
+: m_config(std::move(config))
+{
+    open_with_config(m_config, m_history, m_shared_group, m_read_only_group, this);
+
+    if (m_read_only_group) {
+        m_group = m_read_only_group.get();
+    }
+}
+
+REALM_NOINLINE static void translate_file_exception(StringData path, bool read_only=false)
+{
+    try {
+        throw;
+    }
+    catch (util::File::PermissionDenied const& ex) {
+        throw RealmFileException(RealmFileException::Kind::PermissionDenied, ex.get_path(),
+                                 util::format("Unable to open a realm at path '%1'. Please use a path where your app has %2 permissions.",
+                                              ex.get_path(), read_only ? "read" : "read-write"),
+                                 ex.what());
+    }
+    catch (util::File::Exists const& ex) {
+        throw RealmFileException(RealmFileException::Kind::Exists, ex.get_path(),
+                                 util::format("File at path '%1' already exists.", ex.get_path()),
+                                 ex.what());
+    }
+    catch (util::File::NotFound const& ex) {
+        throw RealmFileException(RealmFileException::Kind::NotFound, ex.get_path(),
+                                 util::format("Directory at path '%1' does not exist.", ex.get_path()), ex.what());
+    }
+    catch (util::File::AccessError const& ex) {
+        // Errors for `open()` include the path, but other errors don't. We
+        // don't want two copies of the path in the error, so strip it out if it
+        // appears, and then include it in our prefix.
+        std::string underlying = ex.what();
+        auto pos = underlying.find(ex.get_path());
+        if (pos != std::string::npos && pos > 0) {
+            // One extra char at each end for the quotes
+            underlying.replace(pos - 1, ex.get_path().size() + 2, "");
+        }
+        throw RealmFileException(RealmFileException::Kind::AccessError, ex.get_path(),
+                                 util::format("Unable to open a realm at path '%1': %2.", ex.get_path(), underlying), ex.what());
+    }
+    catch (IncompatibleLockFile const& ex) {
+        throw RealmFileException(RealmFileException::Kind::IncompatibleLockFile, path,
+                                 "Realm file is currently open in another process "
+                                 "which cannot share access with this process. "
+                                 "All processes sharing a single file must be the same architecture.",
+                                 ex.what());
+    }
+    catch (FileFormatUpgradeRequired const& ex) {
+        throw RealmFileException(RealmFileException::Kind::FormatUpgradeRequired, path,
+                                 "The Realm file format must be allowed to be upgraded "
+                                 "in order to proceed.",
+                                 ex.what());
+    }
+}
+
+void Realm::open_with_config(const Config& config,
+                             std::unique_ptr<Replication>& history,
+                             std::unique_ptr<SharedGroup>& shared_group,
+                             std::unique_ptr<Group>& read_only_group,
+                             Realm *realm)
+{
+    if (config.encryption_key.data() && config.encryption_key.size() != 64) {
+        throw InvalidEncryptionKeyException();
+    }
+    try {
+        if (config.read_only) {
+            read_only_group = std::make_unique<Group>(config.path, config.encryption_key.data(), Group::mode_ReadOnly);
+        }
+        else {
+            history = realm::make_client_history(config.path, config.encryption_key.data());
+            SharedGroup::DurabilityLevel durability = config.in_memory ? SharedGroup::durability_MemOnly :
+                                                                           SharedGroup::durability_Full;
+            shared_group = std::make_unique<SharedGroup>(*history, durability, config.encryption_key.data(), !config.disable_format_upgrade,
+                                                         [&](int from_version, int to_version) {
+                if (realm) {
+                    realm->upgrade_initial_version = from_version;
+                    realm->upgrade_final_version = to_version;
+                }
+            });
+        }
+    }
+    catch (...) {
+        translate_file_exception(config.path, config.read_only);
+    }
+}
+
+void Realm::init(std::shared_ptr<RealmCoordinator> coordinator)
+{
+    m_coordinator = std::move(coordinator);
+
+    // if there is an existing realm at the current path steal its schema/column mapping
+    if (auto existing = m_coordinator->get_schema()) {
+        m_config.schema = std::make_unique<Schema>(*existing);
+        return;
+    }
+
+    try {
+        // otherwise get the schema from the group
+        auto target_schema = std::move(m_config.schema);
+        auto target_schema_version = m_config.schema_version;
+        m_config.schema_version = ObjectStore::get_schema_version(read_group());
+        m_config.schema = std::make_unique<Schema>(ObjectStore::schema_from_group(read_group()));
+
+        // if a target schema is supplied, verify that it matches or migrate to
+        // it, as neeeded
+        if (target_schema) {
+            if (m_config.read_only) {
+                if (m_config.schema_version == ObjectStore::NotVersioned) {
+                    throw UninitializedRealmException("Can't open an un-initialized Realm without a Schema");
+                }
+                target_schema->validate();
+                ObjectStore::verify_schema(*m_config.schema, *target_schema, true);
+                m_config.schema = std::move(target_schema);
+            }
+            else {
+                update_schema(std::move(target_schema), target_schema_version);
+            }
+
+            if (!m_config.read_only) {
+                // End the read transaction created to validation/update the
+                // schema to avoid pinning the version even if the user never
+                // actually reads data
+                invalidate();
+            }
+        }
+    }
+    catch (...) {
+        // Trying to unregister from the coordinator before we finish
+        // construction will result in a deadlock
+        m_coordinator = nullptr;
+        throw;
+    }
+}
+
+Realm::~Realm()
+{
+    if (m_coordinator) {
+        m_coordinator->unregister_realm(this);
+    }
+}
+
+Group *Realm::read_group()
+{
+    if (!m_group) {
+        m_group = &const_cast<Group&>(m_shared_group->begin_read());
+    }
+    return m_group;
+}
+
+SharedRealm Realm::get_shared_realm(Config config)
+{
+    auto coordinator = RealmCoordinator::get_coordinator(config.path);
+    return coordinator->get_realm(std::move(config));
+}
+
+void Realm::update_schema(std::unique_ptr<Schema> schema, uint64_t version)
+{
+    schema->validate();
+
+    auto needs_update = [&] {
+        // If the schema version matches, just verify that the schema itself also matches
+        bool needs_write = !m_config.read_only && (m_config.schema_version != version || ObjectStore::needs_update(*m_config.schema, *schema));
+        if (needs_write) {
+            return true;
+        }
+
+        ObjectStore::verify_schema(*m_config.schema, *schema, m_config.read_only);
+        m_config.schema = std::move(schema);
+        m_config.schema_version = version;
+        m_coordinator->update_schema(*m_config.schema);
+        return false;
+    };
+
+    if (!needs_update()) {
+        return;
+    }
+
+    read_group();
+    transaction::begin(*m_shared_group, m_binding_context.get(),
+                       /* error on schema changes */ false);
+
+    struct WriteTransactionGuard {
+        Realm& realm;
+        ~WriteTransactionGuard() {
+            if (realm.is_in_transaction()) {
+                realm.cancel_transaction();
+            }
+        }
+    } write_transaction_guard{*this};
+
+    // Recheck the schema version after beginning the write transaction
+    // If it changed then someone else initialized the schema and we need to
+    // recheck everything
+    auto current_schema_version = ObjectStore::get_schema_version(read_group());
+    if (current_schema_version != m_config.schema_version) {
+        m_config.schema_version = current_schema_version;
+        *m_config.schema = ObjectStore::schema_from_group(read_group());
+
+        if (!needs_update()) {
+            cancel_transaction();
+            return;
+        }
+    }
+    else if (m_config.delete_realm_if_migration_needed && current_schema_version != ObjectStore::NotVersioned) {
+        // Delete realm rather than run migration if delete_realm_if_migration_needed is set and the Realm file exists.
+        // FIXME: not a schema mismatch exception, but this is the exception used to signal the Realm file deletion.
+        throw SchemaMismatchException(std::vector<ObjectSchemaValidationException>());
+    }
+
+    Config old_config(m_config);
+    auto migration_function = [&](Group*,  Schema&) {
+        SharedRealm old_realm(new Realm(old_config));
+        // Need to open in read-write mode so that it uses a SharedGroup, but
+        // users shouldn't actually be able to write via the old realm
+        old_realm->m_config.read_only = true;
+
+        if (m_config.migration_function) {
+            m_config.migration_function(old_realm, shared_from_this());
+        }
+        m_config.migration_function = nullptr;
+    };
+
+    try {
+        m_config.schema = std::move(schema);
+        m_config.schema_version = version;
+
+        ObjectStore::update_realm_with_schema(read_group(), *old_config.schema,
+                                              version, *m_config.schema,
+                                              migration_function);
+        commit_transaction();
+    }
+    catch (...) {
+        m_config.schema = std::move(old_config.schema);
+        m_config.schema_version = old_config.schema_version;
+        throw;
+    }
+
+    m_coordinator->update_schema(*m_config.schema);
+}
+
+static void check_read_write(Realm *realm)
+{
+    if (realm->config().read_only) {
+        throw InvalidTransactionException("Can't perform transactions on read-only Realms.");
+    }
+}
+
+void Realm::verify_thread() const
+{
+    if (m_thread_id != std::this_thread::get_id()) {
+        throw IncorrectThreadException();
+    }
+}
+
+void Realm::verify_in_write() const
+{
+    if (!is_in_transaction()) {
+        throw InvalidTransactionException("Cannot modify managed objects outside of a write transaction.");
+    }
+}
+
+bool Realm::is_in_transaction() const noexcept
+{
+    if (!m_shared_group) {
+        return false;
+    }
+    return m_shared_group->get_transact_stage() == SharedGroup::transact_Writing;
+}
+
+void Realm::begin_transaction()
+{
+    check_read_write(this);
+    verify_thread();
+
+    if (is_in_transaction()) {
+        throw InvalidTransactionException("The Realm is already in a write transaction");
+    }
+
+    // make sure we have a read transaction
+    read_group();
+
+    transaction::begin(*m_shared_group, m_binding_context.get());
+}
+
+void Realm::commit_transaction()
+{
+    check_read_write(this);
+    verify_thread();
+
+    if (!is_in_transaction()) {
+        throw InvalidTransactionException("Can't commit a non-existing write transaction");
+    }
+
+    transaction::commit(*m_shared_group, m_binding_context.get());
+    m_coordinator->send_commit_notifications();
+}
+
+void Realm::cancel_transaction()
+{
+    check_read_write(this);
+    verify_thread();
+
+    if (!is_in_transaction()) {
+        throw InvalidTransactionException("Can't cancel a non-existing write transaction");
+    }
+
+    transaction::cancel(*m_shared_group, m_binding_context.get());
+}
+
+void Realm::invalidate()
+{
+    verify_thread();
+    check_read_write(this);
+
+    if (is_in_transaction()) {
+        cancel_transaction();
+    }
+    if (!m_group) {
+        return;
+    }
+
+    m_shared_group->end_read();
+    m_group = nullptr;
+}
+
+bool Realm::compact()
+{
+    verify_thread();
+
+    if (m_config.read_only) {
+        throw InvalidTransactionException("Can't compact a read-only Realm");
+    }
+    if (is_in_transaction()) {
+        throw InvalidTransactionException("Can't compact a Realm within a write transaction");
+    }
+
+    Group* group = read_group();
+    for (auto &object_schema : *m_config.schema) {
+        ObjectStore::table_for_object_type(group, object_schema.name)->optimize();
+    }
+    m_shared_group->end_read();
+    m_group = nullptr;
+
+    return m_shared_group->compact();
+}
+
+void Realm::write_copy(StringData path, BinaryData key)
+{
+    REALM_ASSERT(!key.data() || key.size() == 64);
+    verify_thread();
+    try {
+        read_group()->write(path, key.data());
+    }
+    catch (...) {
+        translate_file_exception(path);
+    }
+}
+
+void Realm::notify()
+{
+    verify_thread();
+
+    if (m_shared_group->has_changed()) { // Throws
+        if (m_binding_context) {
+            m_binding_context->changes_available();
+        }
+        if (m_auto_refresh) {
+            if (m_group) {
+                m_coordinator->advance_to_ready(*this);
+            }
+            else if (m_binding_context) {
+                m_binding_context->did_change({}, {});
+            }
+        }
+    }
+    else {
+        m_coordinator->process_available_async(*this);
+    }
+}
+
+bool Realm::refresh()
+{
+    verify_thread();
+    check_read_write(this);
+
+    // can't be any new changes if we're in a write transaction
+    if (is_in_transaction()) {
+        return false;
+    }
+
+    // advance transaction if database has changed
+    if (!m_shared_group->has_changed()) { // Throws
+        return false;
+    }
+
+    if (m_group) {
+        transaction::advance(*m_shared_group, m_binding_context.get());
+        m_coordinator->process_available_async(*this);
+    }
+    else {
+        // Create the read transaction
+        read_group();
+    }
+
+    return true;
+}
+
+bool Realm::can_deliver_notifications() const noexcept
+{
+    if (m_config.read_only) {
+        return false;
+    }
+
+    if (m_binding_context && !m_binding_context->can_deliver_notifications()) {
+        return false;
+    }
+
+    return true;
+}
+
+uint64_t Realm::get_schema_version(const realm::Realm::Config &config)
+{
+    auto coordinator = RealmCoordinator::get_existing_coordinator(config.path);
+    if (coordinator) {
+        return coordinator->get_schema_version();
+    }
+
+    return ObjectStore::get_schema_version(Realm(config).read_group());
+}
+
+void Realm::close()
+{
+    invalidate();
+
+    if (m_coordinator) {
+        m_coordinator->unregister_realm(this);
+    }
+
+    m_group = nullptr;
+    m_shared_group = nullptr;
+    m_history = nullptr;
+    m_read_only_group = nullptr;
+    m_binding_context = nullptr;
+    m_coordinator = nullptr;
+}
+
+util::Optional<int> Realm::file_format_upgraded_from_version() const
+{
+    if (upgrade_initial_version != upgrade_final_version) {
+        return upgrade_initial_version;
+    }
+    return util::Optional<int>();
+}
+
+MismatchedConfigException::MismatchedConfigException(StringData message, StringData path)
+: std::runtime_error(util::format(message.data(), path)) { }
diff --git a/Pods/Realm/Realm/ObjectStore/util/format.cpp b/Pods/Realm/Realm/ObjectStore/util/format.cpp
new file mode 100644
index 0000000..4103c8d
--- /dev/null
+++ b/Pods/Realm/Realm/ObjectStore/util/format.cpp
@@ -0,0 +1,82 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2016 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#include "util/format.hpp"
+
+#include <sstream>
+
+#include <realm/string_data.hpp>
+#include <realm/util/assert.hpp>
+
+namespace realm { namespace _impl {
+Printable::Printable(StringData value) : m_type(Type::String), m_string(value.data()) { }
+
+void Printable::print(std::ostream& out) const
+{
+    switch (m_type) {
+        case Printable::Type::Bool:
+            out << (m_uint ? "true" : "false");
+            break;
+        case Printable::Type::Uint:
+            out << m_uint;
+            break;
+        case Printable::Type::Int:
+            out << m_int;
+            break;
+        case Printable::Type::String:
+            out << m_string;
+            break;
+    }
+}
+
+std::string format(const char* fmt, std::initializer_list<Printable> values)
+{
+    std::stringstream ss;
+    while (*fmt) {
+        auto next = strchr(fmt, '%');
+
+        // emit the rest of the format string if there are no more percents
+        if (!next) {
+            ss << fmt;
+            break;
+        }
+
+        // emit everything up to the next percent
+        ss.write(fmt, next - fmt);
+        ++next;
+        REALM_ASSERT(*next);
+
+        // %% produces a single escaped %
+        if (*next == '%') {
+            ss << '%';
+            fmt = next + 1;
+            continue;
+        }
+        REALM_ASSERT(isdigit(*next));
+
+        // The const_cast is safe because stroul does not actually modify
+        // the pointed-to string, but it lacks a const overload
+        auto index = strtoul(next, const_cast<char**>(&fmt), 10) - 1;
+        REALM_ASSERT(index < values.size());
+        (values.begin() + index)->print(ss);
+    }
+    return ss.str();
+}
+
+} // namespace _impl
+} // namespace realm
diff --git a/Pods/Realm/Realm/RLMAccessor.mm b/Pods/Realm/Realm/RLMAccessor.mm
new file mode 100644
index 0000000..ca378ba
--- /dev/null
+++ b/Pods/Realm/Realm/RLMAccessor.mm
@@ -0,0 +1,903 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import "RLMAccessor.h"
+
+#import "RLMArray_Private.hpp"
+#import "RLMObservation.hpp"
+#import "RLMObjectSchema_Private.hpp"
+#import "RLMObjectStore.h"
+#import "RLMObject_Private.hpp"
+#import "RLMProperty_Private.h"
+#import "RLMRealm_Private.hpp"
+#import "RLMResults_Private.h"
+#import "RLMSchema_Private.h"
+#import "RLMUtil.hpp"
+#import "results.hpp"
+
+#import <objc/runtime.h>
+#import <realm/descriptor.hpp>
+
+typedef NS_ENUM(char, RLMAccessorCode) {
+    RLMAccessorCodeByte,
+    RLMAccessorCodeShort,
+    RLMAccessorCodeInt,
+    RLMAccessorCodeLong,
+    RLMAccessorCodeLongLong,
+    RLMAccessorCodeFloat,
+    RLMAccessorCodeDouble,
+    RLMAccessorCodeBool,
+    RLMAccessorCodeString,
+    RLMAccessorCodeDate,
+    RLMAccessorCodeData,
+    RLMAccessorCodeLink,
+    RLMAccessorCodeArray,
+    RLMAccessorCodeLinkingObjects,
+    RLMAccessorCodeAny,
+
+    RLMAccessorCodeIntObject,
+    RLMAccessorCodeFloatObject,
+    RLMAccessorCodeDoubleObject,
+    RLMAccessorCodeBoolObject,
+};
+
+// long getter/setter
+static inline long long RLMGetLong(__unsafe_unretained RLMObjectBase *const obj, NSUInteger colIndex) {
+    RLMVerifyAttached(obj);
+    return obj->_row.get_int(colIndex);
+}
+static inline void RLMSetValue(__unsafe_unretained RLMObjectBase *const obj, NSUInteger colIndex, long long val) {
+    RLMVerifyInWriteTransaction(obj);
+    obj->_row.set_int(colIndex, val);
+}
+static inline void RLMSetValueUnique(__unsafe_unretained RLMObjectBase *const obj, NSUInteger colIndex, NSString *propName, long long val) {
+    RLMVerifyInWriteTransaction(obj);
+    size_t row = obj->_row.get_table()->find_first_int(colIndex, val);
+    if (row == obj->_row.get_index()) {
+        return;
+    }
+    if (row != realm::not_found) {
+        @throw RLMException(@"Can't set primary key property '%@' to existing value '%lld'.", propName, val);
+    }
+    obj->_row.set_int(colIndex, val);
+}
+
+// float getter/setter
+static inline float RLMGetFloat(__unsafe_unretained RLMObjectBase *const obj, NSUInteger colIndex) {
+    RLMVerifyAttached(obj);
+    return obj->_row.get_float(colIndex);
+}
+static inline void RLMSetValue(__unsafe_unretained RLMObjectBase *const obj, NSUInteger colIndex, float val) {
+    RLMVerifyInWriteTransaction(obj);
+    obj->_row.set_float(colIndex, val);
+}
+
+// double getter/setter
+static inline double RLMGetDouble(__unsafe_unretained RLMObjectBase *const obj, NSUInteger colIndex) {
+    RLMVerifyAttached(obj);
+    return obj->_row.get_double(colIndex);
+}
+static inline void RLMSetValue(__unsafe_unretained RLMObjectBase *const obj, NSUInteger colIndex, double val) {
+    RLMVerifyInWriteTransaction(obj);
+    obj->_row.set_double(colIndex, val);
+}
+
+// bool getter/setter
+static inline bool RLMGetBool(__unsafe_unretained RLMObjectBase *const obj, NSUInteger colIndex) {
+    RLMVerifyAttached(obj);
+    return obj->_row.get_bool(colIndex);
+}
+static inline void RLMSetValue(__unsafe_unretained RLMObjectBase *const obj, NSUInteger colIndex, BOOL val) {
+    RLMVerifyInWriteTransaction(obj);
+    obj->_row.set_bool(colIndex, val);
+}
+
+// string getter/setter
+static inline NSString *RLMGetString(__unsafe_unretained RLMObjectBase *const obj, NSUInteger colIndex) {
+    RLMVerifyAttached(obj);
+    return RLMStringDataToNSString(obj->_row.get_string(colIndex));
+}
+static inline void RLMSetValue(__unsafe_unretained RLMObjectBase *const obj, NSUInteger colIndex, __unsafe_unretained NSString *const val) {
+    RLMVerifyInWriteTransaction(obj);
+    try {
+        obj->_row.set_string(colIndex, RLMStringDataWithNSString(val));
+    }
+    catch (std::exception const& e) {
+        @throw RLMException(e);
+    }
+}
+static inline void RLMSetValueUnique(__unsafe_unretained RLMObjectBase *const obj, NSUInteger colIndex, NSString *propName,
+                                     __unsafe_unretained NSString *const val) {
+    RLMVerifyInWriteTransaction(obj);
+    realm::StringData str = RLMStringDataWithNSString(val);
+    size_t row = obj->_row.get_table()->find_first_string(colIndex, str);
+    if (row == obj->_row.get_index()) {
+        return;
+    }
+    if (row != realm::not_found) {
+        @throw RLMException(@"Can't set primary key property '%@' to existing value '%@'.", propName, val);
+    }
+    try {
+        obj->_row.set_string(colIndex, str);
+    }
+    catch (std::exception const& e) {
+        @throw RLMException(e);
+    }
+}
+
+// date getter/setter
+static inline NSDate *RLMGetDate(__unsafe_unretained RLMObjectBase *const obj, NSUInteger colIndex) {
+    RLMVerifyAttached(obj);
+    return RLMTimestampToNSDate(obj->_row.get_timestamp(colIndex));
+}
+static inline void RLMSetValue(__unsafe_unretained RLMObjectBase *const obj, NSUInteger colIndex, __unsafe_unretained NSDate *const date) {
+    RLMVerifyInWriteTransaction(obj);
+    if (date) {
+        obj->_row.set_timestamp(colIndex, RLMTimestampForNSDate(date));
+    }
+    else {
+        obj->_row.set_null(colIndex);
+    }
+}
+
+// data getter/setter
+static inline NSData *RLMGetData(__unsafe_unretained RLMObjectBase *const obj, NSUInteger colIndex) {
+    RLMVerifyAttached(obj);
+    realm::BinaryData data = obj->_row.get_binary(colIndex);
+    return RLMBinaryDataToNSData(data);
+}
+static inline void RLMSetValue(__unsafe_unretained RLMObjectBase *const obj, NSUInteger colIndex, __unsafe_unretained NSData *const data) {
+    RLMVerifyInWriteTransaction(obj);
+
+    try {
+        obj->_row.set_binary(colIndex, RLMBinaryDataForNSData(data));
+    }
+    catch (std::exception const& e) {
+        @throw RLMException(e);
+    }
+}
+
+static inline RLMObjectBase *RLMGetLinkedObjectForValue(__unsafe_unretained RLMRealm *const realm,
+                                                        __unsafe_unretained NSString *const className,
+                                                        __unsafe_unretained id const value,
+                                                        RLMCreationOptions creationOptions) NS_RETURNS_RETAINED;
+static inline RLMObjectBase *RLMGetLinkedObjectForValue(__unsafe_unretained RLMRealm *const realm,
+                                                        __unsafe_unretained NSString *const className,
+                                                        __unsafe_unretained id const value,
+                                                        RLMCreationOptions creationOptions) {
+    RLMObjectBase *link = RLMDynamicCast<RLMObjectBase>(value);
+    if (!link || ![link->_objectSchema.className isEqualToString:className]) {
+        // create from non-rlmobject
+        return RLMCreateObjectInRealmWithValue(realm, className, value, creationOptions & RLMCreationOptionsCreateOrUpdate);
+    }
+
+    if (link.isInvalidated) {
+        @throw RLMException(@"Adding a deleted or invalidated object to a Realm is not permitted");
+    }
+
+    if (link->_realm == realm) {
+        return link;
+    }
+
+    if (creationOptions & RLMCreationOptionsPromoteUnmanaged) {
+        if (!link->_realm) {
+            RLMAddObjectToRealm(link, realm, creationOptions & RLMCreationOptionsCreateOrUpdate);
+            return link;
+        }
+        @throw RLMException(@"Can not add objects from a different Realm");
+    }
+
+    // copy from another realm or copy from unmanaged
+    return RLMCreateObjectInRealmWithValue(realm, className, link, creationOptions & RLMCreationOptionsCreateOrUpdate);
+}
+
+// link getter/setter
+static inline RLMObjectBase *RLMGetLink(__unsafe_unretained RLMObjectBase *const obj, NSUInteger colIndex, __unsafe_unretained NSString *const objectClassName) {
+    RLMVerifyAttached(obj);
+
+    if (obj->_row.is_null_link(colIndex)) {
+        return nil;
+    }
+    NSUInteger index = obj->_row.get_link(colIndex);
+    return RLMCreateObjectAccessor(obj->_realm, obj->_realm.schema[objectClassName], index);
+}
+
+static inline void RLMSetValue(__unsafe_unretained RLMObjectBase *const obj, NSUInteger colIndex,
+                               __unsafe_unretained RLMObjectBase *const val) {
+    RLMVerifyInWriteTransaction(obj);
+
+    if (!val) {
+        obj->_row.nullify_link(colIndex);
+    }
+    else {
+        // make sure it is the correct type
+        RLMObjectSchema *valSchema = val->_objectSchema;
+        RLMObjectSchema *objSchema = obj->_objectSchema;
+        if (![[objSchema propertyForTableColumn:colIndex].objectClassName isEqualToString:valSchema.className]) {
+            @throw RLMException(@"Can't set object of type '%@' to property of type '%@'",
+                                valSchema.className, [objSchema propertyForTableColumn:colIndex].objectClassName);
+        }
+        RLMObjectBase *link = RLMGetLinkedObjectForValue(obj->_realm, valSchema.className, val, RLMCreationOptionsPromoteUnmanaged);
+        obj->_row.set_link(colIndex, link->_row.get_index());
+    }
+}
+
+// array getter/setter
+static inline RLMArray *RLMGetArray(__unsafe_unretained RLMObjectBase *const obj,
+                                    NSUInteger colIndex,
+                                    __unsafe_unretained NSString *const objectClassName,
+                                    __unsafe_unretained NSString *const propName) {
+    RLMVerifyAttached(obj);
+
+    realm::LinkViewRef linkView = obj->_row.get_linklist(colIndex);
+    return [RLMArrayLinkView arrayWithObjectClassName:objectClassName
+                                                 view:linkView
+                                                realm:obj->_realm
+                                                  key:propName
+                                         parentSchema:obj->_objectSchema];
+}
+
+static inline void RLMSetValue(__unsafe_unretained RLMObjectBase *const obj, NSUInteger colIndex,
+                               __unsafe_unretained id<NSFastEnumeration> const array) {
+    RLMVerifyInWriteTransaction(obj);
+
+    realm::LinkViewRef linkView = obj->_row.get_linklist(colIndex);
+    // remove all old
+    // FIXME: make sure delete rules don't purge objects
+    linkView->clear();
+    for (RLMObjectBase *link in array) {
+        RLMObjectBase * addedLink = RLMGetLinkedObjectForValue(obj->_realm, link->_objectSchema.className, link, RLMCreationOptionsPromoteUnmanaged);
+        linkView->add(addedLink->_row.get_index());
+    }
+}
+
+static inline NSNumber<RLMInt> *RLMGetIntObject(__unsafe_unretained RLMObjectBase *const obj, NSUInteger colIndex) {
+    RLMVerifyAttached(obj);
+
+    if (obj->_row.is_null(colIndex)) {
+        return nil;
+    }
+    return @(obj->_row.get_int(colIndex));
+}
+static inline void RLMSetValue(__unsafe_unretained RLMObjectBase *const obj, NSUInteger colIndex,
+                               __unsafe_unretained NSNumber<RLMInt> *const intObject) {
+    RLMVerifyInWriteTransaction(obj);
+
+    if (intObject) {
+        obj->_row.set_int(colIndex, intObject.longLongValue);
+    }
+    else {
+        obj->_row.set_null(colIndex);
+    }
+}
+static inline void RLMSetValueUnique(__unsafe_unretained RLMObjectBase *const obj, NSUInteger colIndex, NSString *propName,
+                                     __unsafe_unretained NSNumber<RLMInt> *const intObject) {
+    RLMVerifyInWriteTransaction(obj);
+
+    long long longLongValue = 0;
+    size_t row;
+    if (intObject) {
+        longLongValue = intObject.longLongValue;
+        row = obj->_row.get_table()->find_first_int(colIndex, longLongValue);
+    }
+    else {
+        row = obj->_row.get_table()->find_first_null(colIndex);
+    }
+
+    if (row == obj->_row.get_index()) {
+        return;
+    }
+    if (row != realm::not_found) {
+        @throw RLMException(@"Can't set primary key property '%@' to existing value '%@'.", propName, intObject);
+    }
+
+    if (intObject) {
+        obj->_row.set_int(colIndex, longLongValue);
+    }
+    else {
+        obj->_row.set_null(colIndex);
+    }
+}
+
+static inline NSNumber<RLMFloat> *RLMGetFloatObject(__unsafe_unretained RLMObjectBase *const obj, NSUInteger colIndex) {
+    RLMVerifyAttached(obj);
+
+    if (obj->_row.is_null(colIndex)) {
+        return nil;
+    }
+    return @(obj->_row.get_float(colIndex));
+}
+static inline void RLMSetValue(__unsafe_unretained RLMObjectBase *const obj, NSUInteger colIndex,
+                               __unsafe_unretained NSNumber<RLMFloat> *const floatObject) {
+    RLMVerifyInWriteTransaction(obj);
+
+    if (floatObject) {
+        obj->_row.set_float(colIndex, floatObject.floatValue);
+    }
+    else {
+        obj->_row.set_null(colIndex);
+    }
+}
+
+static inline NSNumber<RLMDouble> *RLMGetDoubleObject(__unsafe_unretained RLMObjectBase *const obj, NSUInteger colIndex) {
+    RLMVerifyAttached(obj);
+
+    if (obj->_row.is_null(colIndex)) {
+        return nil;
+    }
+    return @(obj->_row.get_double(colIndex));
+}
+static inline void RLMSetValue(__unsafe_unretained RLMObjectBase *const obj, NSUInteger colIndex,
+                               __unsafe_unretained NSNumber<RLMDouble> *const doubleObject) {
+    RLMVerifyInWriteTransaction(obj);
+
+    if (doubleObject) {
+        obj->_row.set_double(colIndex, doubleObject.doubleValue);
+    }
+    else {
+        obj->_row.set_null(colIndex);
+    }
+}
+
+static inline NSNumber<RLMBool> *RLMGetBoolObject(__unsafe_unretained RLMObjectBase *const obj, NSUInteger colIndex) {
+    RLMVerifyAttached(obj);
+
+    if (obj->_row.is_null(colIndex)) {
+        return nil;
+    }
+    return @(obj->_row.get_bool(colIndex));
+}
+static inline void RLMSetValue(__unsafe_unretained RLMObjectBase *const obj, NSUInteger colIndex,
+                               __unsafe_unretained NSNumber<RLMBool> *const boolObject) {
+    RLMVerifyInWriteTransaction(obj);
+
+    if (boolObject) {
+        obj->_row.set_bool(colIndex, boolObject.boolValue);
+    }
+    else {
+        obj->_row.set_null(colIndex);
+    }
+}
+
+static inline RLMLinkingObjects *RLMGetLinkingObjects(__unsafe_unretained RLMObjectBase *const obj, __unsafe_unretained RLMProperty *const property) {
+    RLMObjectSchema *objectSchema = obj->_realm.schema[property.objectClassName];
+    RLMProperty *linkingProperty = objectSchema[property.linkOriginPropertyName];
+    auto backlinkView = obj->_row.get_table()->get_backlink_view(obj->_row.get_index(), objectSchema.table, linkingProperty.column);
+    realm::Results results(obj->_realm->_realm, {}, std::move(backlinkView));
+    return [RLMLinkingObjects resultsWithObjectSchema:objectSchema results:std::move(results)];
+}
+
+// any getter/setter
+static inline id RLMGetAnyProperty(__unsafe_unretained RLMObjectBase *const obj, NSUInteger col_ndx) {
+    RLMVerifyAttached(obj);
+    return RLMMixedToObjc(obj->_row.get_mixed(col_ndx));
+}
+static inline void RLMSetValue(__unsafe_unretained RLMObjectBase *const obj, NSUInteger, __unsafe_unretained id) {
+    RLMVerifyInWriteTransaction(obj);
+    @throw RLMException(@"Modifying Mixed properties is not supported");
+}
+
+// dynamic getter with column closure
+static IMP RLMAccessorGetter(RLMProperty *prop, RLMAccessorCode accessorCode) {
+    NSUInteger colIndex = prop.column;
+    NSString *name = prop.name;
+    NSString *objectClassName = prop.objectClassName;
+    switch (accessorCode) {
+        case RLMAccessorCodeByte:
+            return imp_implementationWithBlock(^(__unsafe_unretained RLMObjectBase *const obj) {
+                return (char)RLMGetLong(obj, colIndex);
+            });
+        case RLMAccessorCodeShort:
+            return imp_implementationWithBlock(^(__unsafe_unretained RLMObjectBase *const obj) {
+                return (short)RLMGetLong(obj, colIndex);
+            });
+        case RLMAccessorCodeInt:
+            return imp_implementationWithBlock(^(__unsafe_unretained RLMObjectBase *const obj) {
+                return (int)RLMGetLong(obj, colIndex);
+            });
+        case RLMAccessorCodeLongLong:
+            return imp_implementationWithBlock(^(__unsafe_unretained RLMObjectBase *const obj) {
+                return RLMGetLong(obj, colIndex);
+            });
+        case RLMAccessorCodeLong:
+            return imp_implementationWithBlock(^(__unsafe_unretained RLMObjectBase *const obj) {
+                return (long)RLMGetLong(obj, colIndex);
+            });
+        case RLMAccessorCodeFloat:
+            return imp_implementationWithBlock(^(__unsafe_unretained RLMObjectBase *const obj) {
+                return RLMGetFloat(obj, colIndex);
+            });
+        case RLMAccessorCodeDouble:
+            return imp_implementationWithBlock(^(__unsafe_unretained RLMObjectBase *const obj) {
+                return RLMGetDouble(obj, colIndex);
+            });
+        case RLMAccessorCodeBool:
+            return imp_implementationWithBlock(^(__unsafe_unretained RLMObjectBase *const obj) {
+                return RLMGetBool(obj, colIndex);
+            });
+        case RLMAccessorCodeString:
+            return imp_implementationWithBlock(^(__unsafe_unretained RLMObjectBase *const obj) {
+                return RLMGetString(obj, colIndex);
+            });
+        case RLMAccessorCodeDate:
+            return imp_implementationWithBlock(^(__unsafe_unretained RLMObjectBase *const obj) {
+                return RLMGetDate(obj, colIndex);
+            });
+        case RLMAccessorCodeData:
+            return imp_implementationWithBlock(^(__unsafe_unretained RLMObjectBase *const obj) {
+                return RLMGetData(obj, colIndex);
+            });
+        case RLMAccessorCodeLink:
+            return imp_implementationWithBlock(^id(__unsafe_unretained RLMObjectBase *const obj) {
+                return RLMGetLink(obj, colIndex, objectClassName);
+            });
+        case RLMAccessorCodeArray:
+            return imp_implementationWithBlock(^(__unsafe_unretained RLMObjectBase *const obj) {
+                return RLMGetArray(obj, colIndex, objectClassName, name);
+            });
+        case RLMAccessorCodeAny:
+            @throw RLMException(@"Cannot create accessor class for schema with Mixed properties");
+        case RLMAccessorCodeIntObject:
+            return imp_implementationWithBlock(^(__unsafe_unretained RLMObjectBase *const obj) {
+                return RLMGetIntObject(obj, colIndex);
+            });
+        case RLMAccessorCodeFloatObject:
+            return imp_implementationWithBlock(^(__unsafe_unretained RLMObjectBase *const obj) {
+                return RLMGetFloatObject(obj, colIndex);
+            });
+        case RLMAccessorCodeDoubleObject:
+            return imp_implementationWithBlock(^(__unsafe_unretained RLMObjectBase *const obj) {
+                return RLMGetDoubleObject(obj, colIndex);
+            });
+        case RLMAccessorCodeBoolObject:
+            return imp_implementationWithBlock(^(__unsafe_unretained RLMObjectBase *const obj) {
+                return RLMGetBoolObject(obj, colIndex);
+            });
+        case RLMAccessorCodeLinkingObjects:
+            return imp_implementationWithBlock(^(__unsafe_unretained RLMObjectBase *const obj) {
+                return RLMGetLinkingObjects(obj, prop);
+            });
+    }
+}
+
+template<typename Function>
+static void RLMWrapSetter(__unsafe_unretained RLMObjectBase *const obj, __unsafe_unretained NSString *const name, Function&& f) {
+    if (RLMObservationInfo *info = RLMGetObservationInfo(obj->_observationInfo, obj->_row.get_index(), obj->_objectSchema)) {
+        info->willChange(name);
+        f();
+        info->didChange(name);
+    }
+    else {
+        f();
+    }
+}
+
+template<typename ArgType, typename StorageType=ArgType>
+static IMP RLMMakeSetter(RLMProperty *prop) {
+    NSUInteger colIndex = prop.column;
+    NSString *name = prop.name;
+    if (prop.isPrimary) {
+        return imp_implementationWithBlock(^(__unused RLMObjectBase *obj, __unused ArgType val) {
+            @throw RLMException(@"Primary key can't be changed after an object is inserted.");
+        });
+    }
+    return imp_implementationWithBlock(^(__unsafe_unretained RLMObjectBase *const obj, ArgType val) {
+        RLMWrapSetter(obj, name, [&] {
+            RLMSetValue(obj, colIndex, static_cast<StorageType>(val));
+        });
+    });
+}
+
+// dynamic setter with column closure
+static IMP RLMAccessorSetter(RLMProperty *prop, RLMAccessorCode accessorCode) {
+    switch (accessorCode) {
+        case RLMAccessorCodeByte:         return RLMMakeSetter<char, long long>(prop);
+        case RLMAccessorCodeShort:        return RLMMakeSetter<short, long long>(prop);
+        case RLMAccessorCodeInt:          return RLMMakeSetter<int, long long>(prop);
+        case RLMAccessorCodeLong:         return RLMMakeSetter<long, long long>(prop);
+        case RLMAccessorCodeLongLong:     return RLMMakeSetter<long long>(prop);
+        case RLMAccessorCodeFloat:        return RLMMakeSetter<float>(prop);
+        case RLMAccessorCodeDouble:       return RLMMakeSetter<double>(prop);
+        case RLMAccessorCodeBool:         return RLMMakeSetter<BOOL>(prop);
+        case RLMAccessorCodeString:       return RLMMakeSetter<NSString *>(prop);
+        case RLMAccessorCodeDate:         return RLMMakeSetter<NSDate *>(prop);
+        case RLMAccessorCodeData:         return RLMMakeSetter<NSData *>(prop);
+        case RLMAccessorCodeLink:         return RLMMakeSetter<RLMObjectBase *>(prop);
+        case RLMAccessorCodeArray:        return RLMMakeSetter<RLMArray *>(prop);
+        case RLMAccessorCodeAny:          return RLMMakeSetter<id>(prop);
+        case RLMAccessorCodeIntObject:    return RLMMakeSetter<NSNumber<RLMInt> *>(prop);
+        case RLMAccessorCodeFloatObject:  return RLMMakeSetter<NSNumber<RLMFloat> *>(prop);
+        case RLMAccessorCodeDoubleObject: return RLMMakeSetter<NSNumber<RLMDouble> *>(prop);
+        case RLMAccessorCodeBoolObject:   return RLMMakeSetter<NSNumber<RLMBool> *>(prop);
+        case RLMAccessorCodeLinkingObjects: return nil;
+    }
+}
+
+// call getter for superclass for property at colIndex
+static id RLMSuperGet(RLMObjectBase *obj, NSString *propName) {
+    typedef id (*getter_type)(RLMObjectBase *, SEL);
+    RLMProperty *prop = obj->_objectSchema[propName];
+    Class superClass = class_getSuperclass(obj.class);
+    getter_type superGetter = (getter_type)[superClass instanceMethodForSelector:prop.getterSel];
+    return superGetter(obj, prop.getterSel);
+}
+
+// call setter for superclass for property at colIndex
+static void RLMSuperSet(RLMObjectBase *obj, NSString *propName, id val) {
+    typedef void (*setter_type)(RLMObjectBase *, SEL, RLMArray *ar);
+    RLMProperty *prop = obj->_objectSchema[propName];
+    Class superClass = class_getSuperclass(obj.class);
+    setter_type superSetter = (setter_type)[superClass instanceMethodForSelector:prop.setterSel];
+    superSetter(obj, prop.setterSel, val);
+}
+
+// getter/setter for unmanaged object
+static IMP RLMAccessorUnmanagedGetter(RLMProperty *prop, RLMAccessorCode accessorCode) {
+    // only override getters for RLMArray and linking objects properties
+    if (accessorCode == RLMAccessorCodeArray) {
+        NSString *objectClassName = prop.objectClassName;
+        NSString *propName = prop.name;
+
+        return imp_implementationWithBlock(^(RLMObjectBase *obj) {
+            id val = RLMSuperGet(obj, propName);
+            if (!val) {
+                val = [[RLMArray alloc] initWithObjectClassName:objectClassName];
+                RLMSuperSet(obj, propName, val);
+            }
+            return val;
+        });
+    }
+    else if (accessorCode == RLMAccessorCodeLinkingObjects) {
+        return imp_implementationWithBlock(^(RLMObjectBase *){
+            return [RLMResults emptyDetachedResults];
+        });
+    }
+    return nil;
+}
+static IMP RLMAccessorUnmanagedSetter(RLMProperty *prop, RLMAccessorCode accessorCode) {
+    // only override getters for RLMArray and linking objects properties
+    if (accessorCode == RLMAccessorCodeArray) {
+        NSString *propName = prop.name;
+        NSString *objectClassName = prop.objectClassName;
+        return imp_implementationWithBlock(^(RLMObjectBase *obj, id<NSFastEnumeration> ar) {
+            // make copy when setting (as is the case for all other variants)
+            RLMArray *unmanagedAr = [[RLMArray alloc] initWithObjectClassName:objectClassName];
+            [unmanagedAr addObjects:ar];
+            RLMSuperSet(obj, propName, unmanagedAr);
+        });
+    }
+    return nil;
+}
+
+// macros/helpers to generate objc type strings for registering methods
+#define GETTER_TYPES(C) C "@:"
+#define SETTER_TYPES(C) "v@:" C
+
+// getter type strings
+// NOTE: this typecode is really the the first charachter of the objc/runtime.h type
+//       the @ type maps to multiple core types (string, date, array, mixed, any which are id in objc)
+static const char *getterTypeStringForObjcCode(char code) {
+    switch (code) {
+        case 's': return GETTER_TYPES("s");
+        case 'i': return GETTER_TYPES("i");
+        case 'l': return GETTER_TYPES("l");
+        case 'q': return GETTER_TYPES("q");
+        case 'f': return GETTER_TYPES("f");
+        case 'd': return GETTER_TYPES("d");
+        case 'B': return GETTER_TYPES("B");
+        case 'c': return GETTER_TYPES("c");
+        case '@': return GETTER_TYPES("@");
+        default: @throw RLMException(@"Invalid accessor code");
+    }
+}
+
+// setter type strings
+// NOTE: this typecode is really the the first charachter of the objc/runtime.h type
+//       the @ type maps to multiple core types (string, date, array, mixed, any which are id in objc)
+static const char *setterTypeStringForObjcCode(char code) {
+    switch (code) {
+        case 's': return SETTER_TYPES("s");
+        case 'i': return SETTER_TYPES("i");
+        case 'l': return SETTER_TYPES("l");
+        case 'q': return SETTER_TYPES("q");
+        case 'f': return SETTER_TYPES("f");
+        case 'd': return SETTER_TYPES("d");
+        case 'B': return SETTER_TYPES("B");
+        case 'c': return SETTER_TYPES("c");
+        case '@': return SETTER_TYPES("@");
+        default: @throw RLMException(@"Invalid accessor code");
+    }
+}
+
+// get accessor lookup code based on objc type and rlm type
+static RLMAccessorCode accessorCodeForType(char objcTypeCode, RLMPropertyType rlmType) {
+    switch (objcTypeCode) {
+        case 't': return RLMAccessorCodeArray;
+        case '@':               // custom accessors for strings and subtables
+            switch (rlmType) {  // custom accessor codes for types that map to objc objects
+                case RLMPropertyTypeObject: return RLMAccessorCodeLink;
+                case RLMPropertyTypeString: return RLMAccessorCodeString;
+                case RLMPropertyTypeArray: return RLMAccessorCodeArray;
+                case RLMPropertyTypeDate: return RLMAccessorCodeDate;
+                case RLMPropertyTypeData: return RLMAccessorCodeData;
+                case RLMPropertyTypeAny: return RLMAccessorCodeAny;
+
+                case RLMPropertyTypeBool: return RLMAccessorCodeBoolObject;
+                case RLMPropertyTypeDouble: return RLMAccessorCodeDoubleObject;
+                case RLMPropertyTypeFloat: return RLMAccessorCodeFloatObject;
+                case RLMPropertyTypeInt: return RLMAccessorCodeIntObject;
+
+                case RLMPropertyTypeLinkingObjects: return RLMAccessorCodeLinkingObjects;
+            }
+        case 'c':
+            switch (rlmType) {
+                case RLMPropertyTypeInt: return RLMAccessorCodeByte;
+                case RLMPropertyTypeBool: return RLMAccessorCodeBool;
+                default:
+                    @throw RLMException(@"Unexpected property type for Objective-C type code");
+            }
+        case 'B': return RLMAccessorCodeBool;
+        case 's': return RLMAccessorCodeShort;
+        case 'i': return RLMAccessorCodeInt;
+        case 'l': return RLMAccessorCodeLong;
+        case 'q': return RLMAccessorCodeLongLong;
+        case 'f': return RLMAccessorCodeFloat;
+        case 'd': return RLMAccessorCodeDouble;
+        default:
+            @throw RLMException(@"Invalid type for objc typecode");
+    }
+}
+
+// implement the class method className on accessors to return the className of the
+// base object
+void RLMReplaceClassNameMethod(Class accessorClass, NSString *className) {
+    Class metaClass = object_getClass(accessorClass);
+    IMP imp = imp_implementationWithBlock(^(Class){ return className; });
+    class_addMethod(metaClass, @selector(className), imp, "@@:");
+}
+
+// implement the shared schema method
+void RLMReplaceSharedSchemaMethod(Class accessorClass, RLMObjectSchema *schema) {
+    Class metaClass = object_getClass(accessorClass);
+    IMP imp = imp_implementationWithBlock(^(Class cls) {
+        if (cls == accessorClass) {
+            return schema;
+        }
+
+        // If we aren't being called directly on the class this was overriden
+        // for, the class is either a subclass which we haven't initialized yet,
+        // or it's a runtime-generated class which should use the parent's
+        // schema. We check for the latter by checking if the immediate
+        // descendent of the desired class is a class generated by us (there
+        // may be further subclasses not generated by us for things like KVO).
+        Class parent = class_getSuperclass(cls);
+        while (parent != accessorClass) {
+            cls = parent;
+            parent = class_getSuperclass(cls);
+        }
+        if (RLMIsGeneratedClass(cls)) {
+            return schema;
+        }
+
+        return [RLMSchema sharedSchemaForClass:cls];
+    });
+    class_addMethod(metaClass, @selector(sharedSchema), imp, "@@:");
+}
+
+static NSMutableSet *s_generatedClasses = [NSMutableSet new];
+static void RLMMarkClassAsGenerated(Class cls) {
+    @synchronized (s_generatedClasses) {
+        [s_generatedClasses addObject:cls];
+    }
+}
+
+bool RLMIsGeneratedClass(Class cls) {
+    @synchronized (s_generatedClasses) {
+        return [s_generatedClasses containsObject:cls];
+    }
+}
+
+static Class RLMCreateAccessorClass(Class objectClass,
+                                    RLMObjectSchema *schema,
+                                    NSString *accessorClassPrefix,
+                                    IMP (*getterGetter)(RLMProperty *, RLMAccessorCode),
+                                    IMP (*setterGetter)(RLMProperty *, RLMAccessorCode)) {
+    // throw if no schema, prefix, or object class
+    if (!objectClass || !schema || !accessorClassPrefix) {
+        @throw RLMException(@"Missing arguments");
+    }
+    if (!RLMIsObjectOrSubclass(objectClass)) {
+        @throw RLMException(@"objectClass must derive from RLMObject or Object");
+    }
+
+    // create and register proxy class which derives from object class
+    NSString *accessorClassName = [accessorClassPrefix stringByAppendingString:schema.className];
+    Class accClass = objc_getClass(accessorClassName.UTF8String);
+    if (!accClass) {
+        accClass = objc_allocateClassPair(objectClass, accessorClassName.UTF8String, 0);
+        objc_registerClassPair(accClass);
+    }
+
+    // override getters/setters for each propery
+    NSArray *allProperties = [schema.properties arrayByAddingObjectsFromArray:schema.computedProperties];
+    for (RLMProperty *prop in allProperties) {
+        RLMAccessorCode accessorCode = accessorCodeForType(prop.objcType, prop.type);
+        if (prop.getterSel && getterGetter) {
+            IMP getterImp = getterGetter(prop, accessorCode);
+            if (getterImp) {
+                class_replaceMethod(accClass, prop.getterSel, getterImp, getterTypeStringForObjcCode(prop.objcType));
+            }
+        }
+        if (prop.setterSel && setterGetter) {
+            IMP setterImp = setterGetter(prop, accessorCode);
+            if (setterImp) {
+                class_replaceMethod(accClass, prop.setterSel, setterImp, setterTypeStringForObjcCode(prop.objcType));
+            }
+        }
+    }
+
+    RLMMarkClassAsGenerated(accClass);
+
+    return accClass;
+}
+
+Class RLMAccessorClassForObjectClass(Class objectClass, RLMObjectSchema *schema, NSString *prefix) {
+    return RLMCreateAccessorClass(objectClass, schema, prefix, RLMAccessorGetter, RLMAccessorSetter);
+}
+
+Class RLMUnmanagedAccessorClassForObjectClass(Class objectClass, RLMObjectSchema *schema) {
+    return RLMCreateAccessorClass(objectClass, schema, @"RLMUnmanaged_",
+                                  RLMAccessorUnmanagedGetter, RLMAccessorUnmanagedSetter);
+}
+
+void RLMDynamicValidatedSet(RLMObjectBase *obj, NSString *propName, id val) {
+    RLMObjectSchema *schema = obj->_objectSchema;
+    RLMProperty *prop = schema[propName];
+    if (!prop) {
+        @throw RLMException(@"Invalid property name `%@` for class `%@`.", propName, obj->_objectSchema.className);
+    }
+    if (prop.isPrimary) {
+        @throw RLMException(@"Primary key can't be changed to '%@' after an object is inserted.", val);
+    }
+    if (!RLMIsObjectValidForProperty(val, prop)) {
+        @throw RLMException(@"Invalid property value `%@` for property `%@` of class `%@`", val, propName, obj->_objectSchema.className);
+    }
+
+    RLMDynamicSet(obj, prop, RLMCoerceToNil(val), RLMCreationOptionsPromoteUnmanaged);
+}
+
+void RLMDynamicSet(__unsafe_unretained RLMObjectBase *const obj, __unsafe_unretained RLMProperty *const prop,
+                   __unsafe_unretained id const val, RLMCreationOptions creationOptions) {
+    NSUInteger col = prop.column;
+    RLMWrapSetter(obj, prop.name, [&] {
+        switch (accessorCodeForType(prop.objcType, prop.type)) {
+            case RLMAccessorCodeByte:
+            case RLMAccessorCodeShort:
+            case RLMAccessorCodeInt:
+            case RLMAccessorCodeLong:
+            case RLMAccessorCodeLongLong:
+                if (prop.isPrimary) {
+                    RLMSetValueUnique(obj, col, prop.name, [val longLongValue]);
+                }
+                else {
+                    RLMSetValue(obj, col, [val longLongValue]);
+                }
+                break;
+            case RLMAccessorCodeFloat:
+                RLMSetValue(obj, col, [val floatValue]);
+                break;
+            case RLMAccessorCodeDouble:
+                RLMSetValue(obj, col, [val doubleValue]);
+                break;
+            case RLMAccessorCodeBool:
+                RLMSetValue(obj, col, [val boolValue]);
+                break;
+            case RLMAccessorCodeIntObject:
+                if (prop.isPrimary) {
+                    RLMSetValueUnique(obj, col, prop.name, (NSNumber<RLMInt> *)val);
+                }
+                else {
+                    RLMSetValue(obj, col, (NSNumber<RLMInt> *)val);
+                }
+                break;
+            case RLMAccessorCodeFloatObject:
+                RLMSetValue(obj, col, (NSNumber<RLMFloat> *)val);
+                break;
+            case RLMAccessorCodeDoubleObject:
+                RLMSetValue(obj, col, (NSNumber<RLMDouble> *)val);
+                break;
+            case RLMAccessorCodeBoolObject:
+                RLMSetValue(obj, col, (NSNumber<RLMBool> *)val);
+                break;
+            case RLMAccessorCodeString:
+                if (prop.isPrimary) {
+                    RLMSetValueUnique(obj, col, prop.name, (NSString *)val);
+                }
+                else {
+                    RLMSetValue(obj, col, (NSString *)val);
+                }
+                break;
+            case RLMAccessorCodeDate:
+                RLMSetValue(obj, col, (NSDate *)val);
+                break;
+            case RLMAccessorCodeData:
+                RLMSetValue(obj, col, (NSData *)val);
+                break;
+            case RLMAccessorCodeLink: {
+                if (!val || val == NSNull.null) {
+                    RLMSetValue(obj, col, (RLMObjectBase *)nil);
+                }
+                else {
+                    RLMSetValue(obj, col, RLMGetLinkedObjectForValue(obj->_realm, prop.objectClassName, val, creationOptions));
+                }
+                break;
+            }
+            case RLMAccessorCodeArray:
+                if (!val || val == NSNull.null) {
+                    RLMSetValue(obj, col, (id<NSFastEnumeration>)nil);
+                }
+                else {
+                    id<NSFastEnumeration> rawLinks = val;
+                    NSMutableArray *links = [NSMutableArray array];
+                    for (id rawLink in rawLinks) {
+                        [links addObject:RLMGetLinkedObjectForValue(obj->_realm, prop.objectClassName, rawLink, creationOptions)];
+                    }
+                    RLMSetValue(obj, col, links);
+                }
+                break;
+            case RLMAccessorCodeAny:
+                RLMSetValue(obj, col, val);
+                break;
+            case RLMAccessorCodeLinkingObjects:
+                @throw RLMException(@"Linking objects properties are read-only");
+        }
+    });
+}
+
+RLMProperty *RLMValidatedGetProperty(__unsafe_unretained RLMObjectBase *const obj, __unsafe_unretained NSString *const propName) {
+    RLMProperty *prop = obj->_objectSchema[propName];
+    if (!prop) {
+        @throw RLMException(@"Invalid property name `%@` for class `%@`.", propName, obj->_objectSchema.className);
+    }
+    return prop;
+}
+
+id RLMDynamicGet(__unsafe_unretained RLMObjectBase *obj, __unsafe_unretained RLMProperty *prop) {
+    NSUInteger col = prop.column;
+    switch (accessorCodeForType(prop.objcType, prop.type)) {
+        case RLMAccessorCodeByte:         return @((char)RLMGetLong(obj, col));
+        case RLMAccessorCodeShort:        return @((short)RLMGetLong(obj, col));
+        case RLMAccessorCodeInt:          return @((int)RLMGetLong(obj, col));
+        case RLMAccessorCodeLong:         return @((long)RLMGetLong(obj, col));
+        case RLMAccessorCodeLongLong:     return @(RLMGetLong(obj, col));
+        case RLMAccessorCodeFloat:        return @(RLMGetFloat(obj, col));
+        case RLMAccessorCodeDouble:       return @(RLMGetDouble(obj, col));
+        case RLMAccessorCodeBool:         return @(RLMGetBool(obj, col));
+        case RLMAccessorCodeString:       return RLMGetString(obj, col);
+        case RLMAccessorCodeDate:         return RLMGetDate(obj, col);
+        case RLMAccessorCodeData:         return RLMGetData(obj, col);
+        case RLMAccessorCodeLink:         return RLMGetLink(obj, col, prop.objectClassName);
+        case RLMAccessorCodeArray:        return RLMGetArray(obj, col, prop.objectClassName, prop.name);
+        case RLMAccessorCodeAny:          return RLMGetAnyProperty(obj, col);
+        case RLMAccessorCodeIntObject:    return RLMGetIntObject(obj, col);
+        case RLMAccessorCodeFloatObject:  return RLMGetFloatObject(obj, col);
+        case RLMAccessorCodeDoubleObject: return RLMGetDoubleObject(obj, col);
+        case RLMAccessorCodeBoolObject:   return RLMGetBoolObject(obj, col);
+        case RLMAccessorCodeLinkingObjects: return RLMGetLinkingObjects(obj, prop);
+    }
+}
diff --git a/Pods/Realm/Realm/RLMAnalytics.mm b/Pods/Realm/Realm/RLMAnalytics.mm
new file mode 100644
index 0000000..13aa0c3
--- /dev/null
+++ b/Pods/Realm/Realm/RLMAnalytics.mm
@@ -0,0 +1,240 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2015 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+// Asynchronously submits build information to Realm if running in an iOS
+// simulator or on OS X if a debugger is attached. Does nothing if running on an
+// iOS / watchOS device or if a debugger is *not* attached.
+//
+// To be clear: this does *not* run when your app is in production or on
+// your end-user’s devices; it will only run in the simulator or when a debugger
+// is attached.
+//
+// Why are we doing this? In short, because it helps us build a better product
+// for you. None of the data personally identifies you, your employer or your
+// app, but it *will* help us understand what language you use, what iOS
+// versions you target, etc. Having this info will help prioritizing our time,
+// adding new features and deprecating old features. Collecting an anonymized
+// bundle & anonymized MAC is the only way for us to count actual usage of the
+// other metrics accurately. If we don’t have a way to deduplicate the info
+// reported, it will be useless, as a single developer building their Swift app
+// 10 times would report 10 times more than a single Objective-C developer that
+// only builds once, making the data all but useless.
+// No one likes sharing data unless it’s necessary, we get it, and we’ve
+// debated adding this for a long long time. Since Realm is a free product
+// without an email signup, we feel this is a necessary step so we can collect
+// relevant data to build a better product for you. If you truly, absolutely
+// feel compelled to not send this data back to Realm, then you can set an env
+// variable named REALM_DISABLE_ANALYTICS. Since Realm is free we believe
+// letting these analytics run is a small price to pay for the product & support
+// we give you.
+//
+// Currently the following information is reported:
+// - What version of Realm is being used, and from which language (obj-c or Swift).
+// - What version of OS X it's running on (in case Xcode aggressively drops
+//   support for older versions again, we need to know what we need to support).
+// - The minimum iOS/OS X version that the application is targeting (again, to
+//   help us decide what versions we need to support). 
+// - An anonymous MAC address and bundle ID to aggregate the other information on.
+// - What version of Swift is being used (if applicable).
+
+#import "RLMAnalytics.hpp"
+
+#import <Foundation/Foundation.h>
+
+#if TARGET_IPHONE_SIMULATOR || TARGET_OS_MAC || (TARGET_OS_WATCH && TARGET_OS_SIMULATOR) || (TARGET_OS_TV && TARGET_OS_SIMULATOR)
+#import "RLMRealm.h"
+#import "RLMUtil.hpp"
+
+#import <array>
+#import <sys/socket.h>
+#import <sys/sysctl.h>
+#import <net/if.h>
+#import <net/if_dl.h>
+
+#import <CommonCrypto/CommonDigest.h>
+
+#ifndef REALM_COCOA_VERSION
+#import "RLMVersion.h"
+#endif
+
+// Declared for RealmSwiftObjectUtil
+@interface NSObject (SwiftVersion)
++ (NSString *)swiftVersion;
+@end
+
+// Wrapper for sysctl() that handles the memory management stuff
+static auto RLMSysCtl(int *mib, u_int mibSize, size_t *bufferSize) {
+    std::unique_ptr<void, decltype(&free)> buffer(nullptr, &free);
+
+    int ret = sysctl(mib, mibSize, nullptr, bufferSize, nullptr, 0);
+    if (ret != 0) {
+        return buffer;
+    }
+
+    buffer.reset(malloc(*bufferSize));
+    if (!buffer) {
+        return buffer;
+    }
+
+    ret = sysctl(mib, mibSize, buffer.get(), bufferSize, nullptr, 0);
+    if (ret != 0) {
+        buffer.reset();
+    }
+
+    return buffer;
+}
+
+// Get the version of OS X we're running on (even in the simulator this gives
+// the OS X version and not the simulated iOS version)
+static NSString *RLMOSVersion() {
+    std::array<int, 2> mib = {CTL_KERN, KERN_OSRELEASE};
+    size_t bufferSize;
+    auto buffer = RLMSysCtl(&mib[0], mib.size(), &bufferSize);
+    if (!buffer) {
+        return nil;
+    }
+
+    return [[NSString alloc] initWithBytesNoCopy:buffer.release()
+                                          length:bufferSize - 1
+                                        encoding:NSUTF8StringEncoding
+                                    freeWhenDone:YES];
+}
+
+// Hash the data in the given buffer and convert it to a hex-format string
+static NSString *RLMHashData(const void *bytes, size_t length) {
+    unsigned char buffer[CC_SHA256_DIGEST_LENGTH];
+    CC_SHA256(bytes, static_cast<CC_LONG>(length), buffer);
+
+    char formatted[CC_SHA256_DIGEST_LENGTH * 2 + 1];
+    for (int i = 0; i < CC_SHA256_DIGEST_LENGTH; ++i) {
+        sprintf(formatted + i * 2, "%02x", buffer[i]);
+    }
+
+    return [[NSString alloc] initWithBytes:formatted
+                                    length:CC_SHA256_DIGEST_LENGTH * 2
+                                  encoding:NSUTF8StringEncoding];
+}
+
+// Returns the hash of the MAC address of the first network adaptor since the
+// vendorIdentifier isn't constant between iOS simulators.
+static NSString *RLMMACAddress() {
+    int en0 = static_cast<int>(if_nametoindex("en0"));
+    if (!en0) {
+        return nil;
+    }
+
+    std::array<int, 6> mib = {CTL_NET, PF_ROUTE, 0, AF_LINK, NET_RT_IFLIST, en0};
+    size_t bufferSize;
+    auto buffer = RLMSysCtl(&mib[0], mib.size(), &bufferSize);
+    if (!buffer) {
+        return nil;
+    }
+
+    // sockaddr_dl struct is immediately after the if_msghdr struct in the buffer
+    auto sockaddr = reinterpret_cast<sockaddr_dl *>(static_cast<if_msghdr *>(buffer.get()) + 1);
+    auto mac = reinterpret_cast<const unsigned char *>(sockaddr->sdl_data + sockaddr->sdl_nlen);
+
+    return RLMHashData(mac, 6);
+}
+
+static NSDictionary *RLMAnalyticsPayload() {
+    NSBundle *appBundle = NSBundle.mainBundle;
+    NSString *hashedBundleID = appBundle.bundleIdentifier;
+
+    // Main bundle isn't always the one of interest (e.g. when running tests
+    // it's xctest rather than the app's bundle), so look for one with a bundle ID
+    if (!hashedBundleID) {
+        for (NSBundle *bundle in NSBundle.allBundles) {
+            if ((hashedBundleID = bundle.bundleIdentifier)) {
+                appBundle = bundle;
+                break;
+            }
+        }
+    }
+
+    // If we found a bundle ID anywhere, hash it as it could contain sensitive
+    // information (e.g. the name of an unnanounced product)
+    if (hashedBundleID) {
+        NSData *data = [hashedBundleID dataUsingEncoding:NSUTF8StringEncoding];
+        hashedBundleID = RLMHashData(data.bytes, data.length);
+    }
+
+    NSString *osVersionString = [[NSProcessInfo processInfo] operatingSystemVersionString];
+    Class swiftObjectUtilClass = NSClassFromString(@"RealmSwiftObjectUtil");
+    BOOL isSwift = swiftObjectUtilClass != nil;
+    NSString *swiftVersion = isSwift ? [swiftObjectUtilClass swiftVersion] : @"N/A";
+
+    static NSString *kUnknownString = @"unknown";
+    NSString *hashedMACAddress = RLMMACAddress() ?: kUnknownString;
+
+    return @{
+             @"event": @"Run",
+             @"properties": @{
+                     // MixPanel properties
+                     @"token": @"ce0fac19508f6c8f20066d345d360fd0",
+
+                     // Anonymous identifiers to deduplicate events
+                     @"distinct_id": hashedMACAddress,
+                     @"Anonymized MAC Address": hashedMACAddress,
+                     @"Anonymized Bundle ID": hashedBundleID ?: kUnknownString,
+
+                     // Which version of Realm is being used
+                     @"Binding": @"cocoa",
+                     @"Language": isSwift ? @"swift" : @"objc",
+                     @"Realm Version": REALM_COCOA_VERSION,
+#if TARGET_OS_WATCH
+                     @"Target OS Type": @"watchos",
+#elif TARGET_OS_TV
+                     @"Target OS Type": @"tvos",
+#elif TARGET_OS_IPHONE
+                     @"Target OS Type": @"ios",
+#else
+                     @"Target OS Type": @"osx",
+#endif
+                     @"Swift Version": swiftVersion,
+                     // Current OS version the app is targetting
+                     @"Target OS Version": osVersionString,
+                     // Minimum OS version the app is targetting
+                     @"Target OS Minimum Version": appBundle.infoDictionary[@"MinimumOSVersion"] ?: kUnknownString,
+
+                     // Host OS version being built on
+                     @"Host OS Type": @"osx",
+                     @"Host OS Version": RLMOSVersion() ?: kUnknownString,
+                 }
+          };
+}
+
+void RLMSendAnalytics() {
+    if (getenv("REALM_DISABLE_ANALYTICS") || !RLMIsDebuggerAttached() || RLMIsRunningInPlayground()) {
+        return;
+    }
+
+
+    NSData *payload = [NSJSONSerialization dataWithJSONObject:RLMAnalyticsPayload() options:0 error:nil];
+    NSString *url = [NSString stringWithFormat:@"https://api.mixpanel.com/track/?data=%@&ip=1", [payload base64EncodedStringWithOptions:0]];
+
+    // No error handling or anything because logging errors annoyed people for no
+    // real benefit, and it's not clear what else we could do
+    [[NSURLSession.sharedSession dataTaskWithURL:[NSURL URLWithString:url]] resume];
+}
+
+#else
+
+void RLMSendAnalytics() {}
+
+#endif
diff --git a/Pods/Realm/Realm/RLMArray.mm b/Pods/Realm/Realm/RLMArray.mm
new file mode 100644
index 0000000..938964d
--- /dev/null
+++ b/Pods/Realm/Realm/RLMArray.mm
@@ -0,0 +1,438 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import "RLMArray_Private.hpp"
+
+#import "RLMObject_Private.h"
+#import "RLMObjectStore.h"
+#import "RLMObjectSchema.h"
+#import "RLMQueryUtil.hpp"
+#import "RLMSwiftSupport.h"
+#import "RLMUtil.hpp"
+
+#import <realm/link_view.hpp>
+
+// See -countByEnumeratingWithState:objects:count
+@interface RLMArrayHolder : NSObject {
+@public
+    std::unique_ptr<id[]> items;
+}
+@end
+@implementation RLMArrayHolder
+@end
+
+@implementation RLMArray {
+@public
+    // Backing array when this instance is unmanaged
+    NSMutableArray *_backingArray;
+}
+
+template<typename IndexSetFactory>
+static void changeArray(__unsafe_unretained RLMArray *const ar,
+                        NSKeyValueChange kind, dispatch_block_t f, IndexSetFactory&& is) {
+    if (!ar->_backingArray) {
+        ar->_backingArray = [NSMutableArray new];
+    }
+
+    if (RLMObjectBase *parent = ar->_parentObject) {
+        NSIndexSet *indexes = is();
+        [parent willChange:kind valuesAtIndexes:indexes forKey:ar->_key];
+        f();
+        [parent didChange:kind valuesAtIndexes:indexes forKey:ar->_key];
+    }
+    else {
+        f();
+    }
+}
+
+static void changeArray(__unsafe_unretained RLMArray *const ar, NSKeyValueChange kind, NSUInteger index, dispatch_block_t f) {
+    changeArray(ar, kind, f, [=] { return [NSIndexSet indexSetWithIndex:index]; });
+}
+
+static void changeArray(__unsafe_unretained RLMArray *const ar, NSKeyValueChange kind, NSRange range, dispatch_block_t f) {
+    changeArray(ar, kind, f, [=] { return [NSIndexSet indexSetWithIndexesInRange:range]; });
+}
+
+static void changeArray(__unsafe_unretained RLMArray *const ar, NSKeyValueChange kind, NSIndexSet *is, dispatch_block_t f) {
+    changeArray(ar, kind, f, [=] { return is; });
+}
+
+- (instancetype)initWithObjectClassName:(NSString *)objectClassName {
+    self = [super init];
+    if (self) {
+        _objectClassName = objectClassName;
+    }
+    return self;
+}
+
+- (RLMRealm *)realm {
+    return nil;
+}
+
+//
+// Generic implementations for all RLMArray variants
+//
+
+- (id)firstObject {
+    if (self.count) {
+        return [self objectAtIndex:0];
+    }
+    return nil;
+}
+
+- (id)lastObject {
+    NSUInteger count = self.count;
+    if (count) {
+        return [self objectAtIndex:count-1];
+    }
+    return nil;
+}
+
+- (void)addObjects:(id<NSFastEnumeration>)objects {
+    for (id obj in objects) {
+        [self addObject:obj];
+    }
+}
+
+- (void)addObject:(RLMObject *)object {
+    [self insertObject:object atIndex:self.count];
+}
+
+- (void)removeLastObject {
+    NSUInteger count = self.count;
+    if (count) {
+        [self removeObjectAtIndex:count-1];
+    }
+}
+
+- (id)objectAtIndexedSubscript:(NSUInteger)index {
+    return [self objectAtIndex:index];
+}
+
+- (void)setObject:(id)newValue atIndexedSubscript:(NSUInteger)index {
+    [self replaceObjectAtIndex:index withObject:newValue];
+}
+
+//
+// Unmanaged RLMArray implementation
+//
+
+static void RLMValidateMatchingObjectType(RLMArray *array, RLMObject *object) {
+    if (!object) {
+        @throw RLMException(@"Object must not be nil");
+    }
+    if (!object->_objectSchema) {
+        @throw RLMException(@"Object cannot be inserted unless the schema is initialized. "
+                            "This can happen if you try to insert objects into a RLMArray / List from a default value or from an overriden unmanaged initializer (`init()`).");
+    }
+    if (![array->_objectClassName isEqualToString:object->_objectSchema.className]) {
+        @throw RLMException(@"Object type '%@' does not match RLMArray type '%@'.", object->_objectSchema.className, array->_objectClassName);
+    }
+}
+
+static void RLMValidateArrayBounds(__unsafe_unretained RLMArray *const ar,
+                                   NSUInteger index, bool allowOnePastEnd=false) {
+    NSUInteger max = ar->_backingArray.count + allowOnePastEnd;
+    if (index >= max) {
+        @throw RLMException(@"Index %llu is out of bounds (must be less than %llu).",
+                            (unsigned long long)index, (unsigned long long)max);
+    }
+}
+
+- (id)objectAtIndex:(NSUInteger)index {
+    RLMValidateArrayBounds(self, index);
+    if (!_backingArray) {
+        _backingArray = [NSMutableArray new];
+    }
+    return [_backingArray objectAtIndex:index];
+}
+
+- (NSUInteger)count {
+    return _backingArray.count;
+}
+
+- (BOOL)isInvalidated {
+    return NO;
+}
+
+- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(__unused __unsafe_unretained id [])buffer count:(__unused NSUInteger)len {
+    if (state->state != 0) {
+        return 0;
+    }
+
+    // We need to enumerate a copy of the backing array so that it doesn't
+    // reflect changes made during enumeration. This copy has to be autoreleased
+    // (since there's nowhere for us to store a strong reference), and uses
+    // RLMArrayHolder rather than an NSArray because NSArray doesn't guarantee
+    // that it'll use a single contiguous block of memory, and if it doesn't
+    // we'd need to forward multiple calls to this method to the same NSArray,
+    // which would require holding a reference to it somewhere.
+    __autoreleasing RLMArrayHolder *copy = [[RLMArrayHolder alloc] init];
+    copy->items = std::make_unique<id[]>(self.count);
+
+    NSUInteger i = 0;
+    for (id object in _backingArray) {
+        copy->items[i++] = object;
+    }
+
+    state->itemsPtr = (__unsafe_unretained id *)(void *)copy->items.get();
+    // needs to point to something valid, but the whole point of this is so
+    // that it can't be changed
+    state->mutationsPtr = state->extra;
+    state->state = i;
+
+    return i;
+}
+
+- (void)addObjectsFromArray:(NSArray *)array {
+    for (id obj in array) {
+        RLMValidateMatchingObjectType(self, obj);
+    }
+    changeArray(self, NSKeyValueChangeInsertion, NSMakeRange(_backingArray.count, array.count), ^{
+        [_backingArray addObjectsFromArray:array];
+    });
+}
+
+- (void)insertObject:(RLMObject *)anObject atIndex:(NSUInteger)index {
+    RLMValidateMatchingObjectType(self, anObject);
+    RLMValidateArrayBounds(self, index, true);
+    changeArray(self, NSKeyValueChangeInsertion, index, ^{
+        [_backingArray insertObject:anObject atIndex:index];
+    });
+}
+
+- (void)insertObjects:(id<NSFastEnumeration>)objects atIndexes:(NSIndexSet *)indexes {
+    changeArray(self, NSKeyValueChangeInsertion, indexes, ^{
+        NSUInteger currentIndex = [indexes firstIndex];
+        for (RLMObject *obj in objects) {
+            RLMValidateMatchingObjectType(self, obj);
+            [_backingArray insertObject:obj atIndex:currentIndex];
+            currentIndex = [indexes indexGreaterThanIndex:currentIndex];
+        }
+    });
+}
+
+- (void)removeObjectAtIndex:(NSUInteger)index {
+    RLMValidateArrayBounds(self, index);
+    changeArray(self, NSKeyValueChangeRemoval, index, ^{
+        [_backingArray removeObjectAtIndex:index];
+    });
+}
+
+- (void)removeObjectsAtIndexes:(NSIndexSet *)indexes {
+    changeArray(self, NSKeyValueChangeRemoval, indexes, ^{
+        [_backingArray removeObjectsAtIndexes:indexes];
+    });
+}
+
+- (void)replaceObjectAtIndex:(NSUInteger)index withObject:(id)anObject {
+    RLMValidateMatchingObjectType(self, anObject);
+    RLMValidateArrayBounds(self, index);
+    changeArray(self, NSKeyValueChangeReplacement, index, ^{
+        [_backingArray replaceObjectAtIndex:index withObject:anObject];
+    });
+}
+
+- (void)moveObjectAtIndex:(NSUInteger)sourceIndex toIndex:(NSUInteger)destinationIndex {
+    RLMValidateArrayBounds(self, sourceIndex);
+    RLMValidateArrayBounds(self, destinationIndex);
+    RLMObjectBase *original = _backingArray[sourceIndex];
+
+    auto start = std::min(sourceIndex, destinationIndex);
+    auto len = std::max(sourceIndex, destinationIndex) - start + 1;
+    changeArray(self, NSKeyValueChangeReplacement, {start, len}, ^{
+        [_backingArray removeObjectAtIndex:sourceIndex];
+        [_backingArray insertObject:original atIndex:destinationIndex];
+    });
+}
+
+- (void)exchangeObjectAtIndex:(NSUInteger)index1 withObjectAtIndex:(NSUInteger)index2 {
+    RLMValidateArrayBounds(self, index1);
+    RLMValidateArrayBounds(self, index2);
+
+    changeArray(self, NSKeyValueChangeReplacement, ^{
+        [_backingArray exchangeObjectAtIndex:index1 withObjectAtIndex:index2];
+    }, [=] {
+        NSMutableIndexSet *set = [[NSMutableIndexSet alloc] initWithIndex:index1];
+        [set addIndex:index2];
+        return set;
+    });
+}
+
+- (NSUInteger)indexOfObject:(RLMObject *)object {
+    RLMValidateMatchingObjectType(self, object);
+    NSUInteger index = 0;
+    for (RLMObject *cmp in _backingArray) {
+        if (RLMObjectBaseAreEqual(object, cmp)) {
+            return index;
+        }
+        index++;
+    }
+    return NSNotFound;
+}
+
+- (void)removeAllObjects {
+    changeArray(self, NSKeyValueChangeRemoval, NSMakeRange(0, _backingArray.count), ^{
+        [_backingArray removeAllObjects];
+    });
+}
+
+- (RLMResults *)objectsWhere:(NSString *)predicateFormat, ...
+{
+    va_list args;
+    va_start(args, predicateFormat);
+    RLMResults *results = [self objectsWhere:predicateFormat args:args];
+    va_end(args);
+    return results;
+}
+
+- (RLMResults *)objectsWhere:(NSString *)predicateFormat args:(va_list)args
+{
+    return [self objectsWithPredicate:[NSPredicate predicateWithFormat:predicateFormat arguments:args]];
+}
+
+- (id)valueForKeyPath:(NSString *)keyPath {
+    if (!_backingArray) {
+        return [super valueForKeyPath:keyPath];
+    }
+    // Although delegating to valueForKeyPath: here would allow to support
+    // nested key paths as well, limiting functionality gives consistency
+    // between unmanaged and managed arrays.
+    if ([keyPath characterAtIndex:0] == '@') {
+        NSRange operatorRange = [keyPath rangeOfString:@"." options:NSLiteralSearch];
+        if (operatorRange.location != NSNotFound) {
+            NSString *operatorKeyPath = [keyPath substringFromIndex:operatorRange.location + 1];
+            if ([operatorKeyPath rangeOfString:@"."].location != NSNotFound) {
+                @throw RLMException(@"Nested key paths are not supported yet for KVC collection operators.");
+            }
+        }
+    }
+    return [_backingArray valueForKeyPath:keyPath];
+}
+
+- (id)valueForKey:(NSString *)key {
+    if ([key isEqualToString:RLMInvalidatedKey]) {
+        return @NO; // Unmanaged arrays are never invalidated
+    }
+    if (!_backingArray) {
+        return @[];
+    }
+    return [_backingArray valueForKey:key];
+}
+
+- (void)setValue:(id)value forKey:(NSString *)key {
+    [_backingArray setValue:value forKey:key];
+}
+
+- (NSUInteger)indexOfObjectWithPredicate:(NSPredicate *)predicate {
+    if (!_backingArray) {
+        return NSNotFound;
+    }
+    return [_backingArray indexOfObjectPassingTest:^BOOL(id obj, NSUInteger, BOOL *) {
+        return [predicate evaluateWithObject:obj];
+    }];
+}
+
+- (NSArray *)objectsAtIndexes:(NSIndexSet *)indexes {
+    if (!_backingArray) {
+        _backingArray = [NSMutableArray new];
+    }
+    return [_backingArray objectsAtIndexes:indexes];
+}
+
+- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(void *)context {
+    RLMValidateArrayObservationKey(keyPath, self);
+    [super addObserver:observer forKeyPath:keyPath options:options context:context];
+}
+
+//
+// Methods unsupported on unmanaged RLMArray instances
+//
+
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wunused-parameter"
+
+- (RLMResults *)objectsWithPredicate:(NSPredicate *)predicate
+{
+    @throw RLMException(@"This method may only be called on RLMArray instances retrieved from an RLMRealm");
+}
+
+- (RLMResults *)sortedResultsUsingProperty:(NSString *)property ascending:(BOOL)ascending
+{
+    return [self sortedResultsUsingDescriptors:@[[RLMSortDescriptor sortDescriptorWithProperty:property ascending:ascending]]];
+}
+
+- (RLMResults *)sortedResultsUsingDescriptors:(NSArray *)properties
+{
+    @throw RLMException(@"This method may only be called on RLMArray instances retrieved from an RLMRealm");
+}
+
+// The compiler complains about the method's argument type not matching due to
+// it not having the generic type attached, but it doesn't seem to be possible
+// to actually include the generic type
+// http://www.openradar.me/radar?id=6135653276319744
+#pragma clang diagnostic ignored "-Wmismatched-parameter-types"
+- (RLMNotificationToken *)addNotificationBlock:(void (^)(RLMArray *, RLMCollectionChange *, NSError *))block {
+    @throw RLMException(@"This method may only be called on RLMArray instances retrieved from an RLMRealm");
+}
+#pragma clang diagnostic pop
+
+- (NSUInteger)indexOfObjectWhere:(NSString *)predicateFormat, ...
+{
+    va_list args;
+    va_start(args, predicateFormat);
+    NSUInteger index = [self indexOfObjectWhere:predicateFormat args:args];
+    va_end(args);
+    return index;
+}
+
+- (NSUInteger)indexOfObjectWhere:(NSString *)predicateFormat args:(va_list)args
+{
+    return [self indexOfObjectWithPredicate:[NSPredicate predicateWithFormat:predicateFormat
+                                                                   arguments:args]];
+}
+
+#pragma mark - Superclass Overrides
+
+- (NSString *)description {
+    return [self descriptionWithMaxDepth:RLMDescriptionMaxDepth];
+}
+
+- (NSString *)descriptionWithMaxDepth:(NSUInteger)depth {
+    return RLMDescriptionWithMaxDepth(@"RLMArray", self, depth);
+}
+@end
+
+@interface RLMSortDescriptor ()
+@property (nonatomic, strong) NSString *property;
+@property (nonatomic, assign) BOOL ascending;
+@end
+
+@implementation RLMSortDescriptor
++ (instancetype)sortDescriptorWithProperty:(NSString *)propertyName ascending:(BOOL)ascending {
+    RLMSortDescriptor *desc = [[RLMSortDescriptor alloc] init];
+    desc->_property = propertyName;
+    desc->_ascending = ascending;
+    return desc;
+}
+
+- (instancetype)reversedSortDescriptor {
+    return [self.class sortDescriptorWithProperty:_property ascending:!_ascending];
+}
+
+@end
diff --git a/Pods/Realm/Realm/RLMArrayLinkView.mm b/Pods/Realm/Realm/RLMArrayLinkView.mm
new file mode 100644
index 0000000..dd1930c
--- /dev/null
+++ b/Pods/Realm/Realm/RLMArrayLinkView.mm
@@ -0,0 +1,411 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import "RLMArray_Private.hpp"
+
+#import "RLMObjectSchema_Private.hpp"
+#import "RLMObjectStore.h"
+#import "RLMObject_Private.hpp"
+#import "RLMObservation.hpp"
+#import "RLMProperty_Private.h"
+#import "RLMQueryUtil.hpp"
+#import "RLMRealm_Private.hpp"
+#import "RLMSchema.h"
+#import "RLMUtil.hpp"
+
+#import "list.hpp"
+#import "results.hpp"
+
+#import <realm/table_view.hpp>
+#import <objc/runtime.h>
+
+//
+// RLMArray implementation
+//
+@implementation RLMArrayLinkView {
+@public
+    realm::List _backingList;
+    RLMRealm *_realm;
+    __unsafe_unretained RLMObjectSchema *_containingObjectSchema;
+    std::unique_ptr<RLMObservationInfo> _observationInfo;
+}
+
++ (RLMArrayLinkView *)arrayWithObjectClassName:(NSString *)objectClassName
+                                          view:(realm::LinkViewRef)view
+                                         realm:(RLMRealm *)realm
+                                           key:(NSString *)key
+                                  parentSchema:(RLMObjectSchema *)parentSchema {
+    RLMArrayLinkView *ar = [[RLMArrayLinkView alloc] initWithObjectClassName:objectClassName];
+    ar->_backingList = realm::List(realm->_realm, view);
+    ar->_realm = realm;
+    ar->_objectSchema = ar->_realm.schema[objectClassName];
+    ar->_containingObjectSchema = parentSchema;
+    ar->_key = key;
+    return ar;
+}
+
+void RLMValidateArrayObservationKey(__unsafe_unretained NSString *const keyPath,
+                                    __unsafe_unretained RLMArray *const array) {
+    if (![keyPath isEqualToString:RLMInvalidatedKey]) {
+        @throw RLMException(@"[<%@ %p> addObserver:forKeyPath:options:context:] is not supported. Key path: %@",
+                            [array class], array, keyPath);
+    }
+}
+
+void RLMEnsureArrayObservationInfo(std::unique_ptr<RLMObservationInfo>& info,
+                                   __unsafe_unretained NSString *const keyPath,
+                                   __unsafe_unretained RLMArray *const array,
+                                   __unsafe_unretained id const observed) {
+    RLMValidateArrayObservationKey(keyPath, array);
+    if (!info && array.class == [RLMArrayLinkView class]) {
+        RLMArrayLinkView *lv = static_cast<RLMArrayLinkView *>(array);
+        info = std::make_unique<RLMObservationInfo>(lv->_containingObjectSchema,
+                                                    lv->_backingList.get_origin_row_index(),
+                                                    observed);
+    }
+}
+
+//
+// validation helpers
+//
+[[gnu::noinline]]
+[[noreturn]]
+static void throwError() {
+    try {
+        throw;
+    }
+    catch (realm::InvalidTransactionException const&) {
+        @throw RLMException(@"Cannot modify managed RLMArray outside of a write transaction");
+    }
+    catch (realm::IncorrectThreadException const&) {
+        @throw RLMException(@"Realm accessed from incorrect thread");
+    }
+    catch (realm::List::InvalidatedException const&) {
+        @throw RLMException(@"RLMArray has been invalidated or the containing object has been deleted");
+    }
+    catch (realm::List::OutOfBoundsIndexException const& e) {
+        @throw RLMException(@"Index %zu is out of bounds (must be less than %zu)",
+                            e.requested, e.valid_count);
+    }
+}
+
+template<typename Function>
+static auto translateErrors(Function&& f) {
+    try {
+        return f();
+    }
+    catch (...) {
+        throwError();
+    }
+}
+
+static void validateObjectToAdd(__unsafe_unretained RLMArrayLinkView *const ar,
+                                __unsafe_unretained RLMObject *const obj) {
+    if (!obj) {
+        @throw RLMException(@"Cannot add `nil` to RLMArray<%@>", ar->_objectClassName);
+    }
+
+    NSString *objectClassName = obj->_objectSchema.className;
+    if (![objectClassName isEqualToString:ar->_objectClassName]) {
+        @throw RLMException(@"Cannot add object of type '%@' to RLMArray<%@>",
+                            objectClassName, ar->_objectClassName);
+    }
+
+    if (obj->_realm != ar.realm) {
+        [ar.realm addObject:obj];
+    }
+    else if (obj->_realm && !obj->_row.is_attached()) {
+        @throw RLMException(@"Object has been deleted or invalidated.");
+    }
+}
+
+template<typename IndexSetFactory>
+static void changeArray(__unsafe_unretained RLMArrayLinkView *const ar,
+                        NSKeyValueChange kind, dispatch_block_t f, IndexSetFactory&& is) {
+    translateErrors([&] { ar->_backingList.verify_in_transaction(); });
+    RLMObservationInfo *info = RLMGetObservationInfo(ar->_observationInfo.get(),
+                                                     ar->_backingList.get_origin_row_index(),
+                                                     ar->_containingObjectSchema);
+    if (info) {
+        NSIndexSet *indexes = is();
+        info->willChange(ar->_key, kind, indexes);
+        try {
+            f();
+        }
+        catch (...) {
+            info->didChange(ar->_key, kind, indexes);
+            throwError();
+        }
+        info->didChange(ar->_key, kind, indexes);
+    }
+    else {
+        translateErrors([&] { f(); });
+    }
+}
+
+static void changeArray(__unsafe_unretained RLMArrayLinkView *const ar, NSKeyValueChange kind, NSUInteger index, dispatch_block_t f) {
+    changeArray(ar, kind, f, [=] { return [NSIndexSet indexSetWithIndex:index]; });
+}
+
+static void changeArray(__unsafe_unretained RLMArrayLinkView *const ar, NSKeyValueChange kind, NSRange range, dispatch_block_t f) {
+    changeArray(ar, kind, f, [=] { return [NSIndexSet indexSetWithIndexesInRange:range]; });
+}
+
+static void changeArray(__unsafe_unretained RLMArrayLinkView *const ar, NSKeyValueChange kind, NSIndexSet *is, dispatch_block_t f) {
+    changeArray(ar, kind, f, [=] { return is; });
+}
+
+//
+// public method implementations
+//
+- (RLMRealm *)realm {
+    return _realm;
+}
+
+- (NSUInteger)count {
+    return translateErrors([&] { return _backingList.size(); });
+}
+
+- (BOOL)isInvalidated {
+    return translateErrors([&] { return !_backingList.is_valid(); });
+}
+
+- (BOOL)isEqual:(id)object {
+    if (RLMArrayLinkView *linkView = RLMDynamicCast<RLMArrayLinkView>(object)) {
+        return linkView->_backingList == _backingList;
+    }
+    return NO;
+}
+
+- (NSUInteger)hash {
+    return std::hash<realm::List>()(_backingList);
+}
+
+- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state
+                                  objects:(__unused __unsafe_unretained id [])buffer
+                                    count:(NSUInteger)len {
+    __autoreleasing RLMFastEnumerator *enumerator;
+    if (state->state == 0) {
+        translateErrors([&] { _backingList.verify_attached(); });
+
+        enumerator = [[RLMFastEnumerator alloc] initWithCollection:self objectSchema:_objectSchema];
+        state->extra[0] = (long)enumerator;
+        state->extra[1] = self.count;
+    }
+    else {
+        enumerator = (__bridge id)(void *)state->extra[0];
+    }
+
+    return [enumerator countByEnumeratingWithState:state count:len];
+}
+
+- (id)objectAtIndex:(NSUInteger)index {
+    return RLMCreateObjectAccessor(_realm, _objectSchema,
+                                   translateErrors([&] { return _backingList.get(index).get_index(); }));
+}
+
+static void RLMInsertObject(RLMArrayLinkView *ar, RLMObject *object, NSUInteger index) {
+    if (index == NSUIntegerMax) {
+        index = translateErrors([&] { return ar->_backingList.size(); });
+    }
+
+    validateObjectToAdd(ar, object);
+    changeArray(ar, NSKeyValueChangeInsertion, index, ^{
+        ar->_backingList.insert(index, object->_row.get_index());
+    });
+}
+
+- (void)addObject:(RLMObject *)object {
+    RLMInsertObject(self, object, NSUIntegerMax);
+}
+
+- (void)insertObject:(RLMObject *)object atIndex:(NSUInteger)index {
+    RLMInsertObject(self, object, index);
+}
+
+- (void)insertObjects:(id<NSFastEnumeration>)objects atIndexes:(NSIndexSet *)indexes {
+    changeArray(self, NSKeyValueChangeInsertion, indexes, ^{
+        NSUInteger index = [indexes firstIndex];
+        for (RLMObject *obj in objects) {
+            validateObjectToAdd(self, obj);
+            _backingList.insert(index, obj->_row.get_index());
+            index = [indexes indexGreaterThanIndex:index];
+        }
+    });
+}
+
+
+- (void)removeObjectAtIndex:(NSUInteger)index {
+    changeArray(self, NSKeyValueChangeRemoval, index, ^{
+        _backingList.remove(index);
+    });
+}
+
+- (void)removeObjectsAtIndexes:(NSIndexSet *)indexes {
+    changeArray(self, NSKeyValueChangeRemoval, indexes, ^{
+        [indexes enumerateIndexesWithOptions:NSEnumerationReverse usingBlock:^(NSUInteger idx, BOOL *) {
+            _backingList.remove(idx);
+        }];
+    });
+}
+
+- (void)addObjectsFromArray:(NSArray *)array {
+    changeArray(self, NSKeyValueChangeInsertion, NSMakeRange(self.count, array.count), ^{
+        for (RLMObject *obj in array) {
+            validateObjectToAdd(self, obj);
+            _backingList.add(obj->_row.get_index());
+        }
+    });
+}
+
+- (void)removeAllObjects {
+    changeArray(self, NSKeyValueChangeRemoval, NSMakeRange(0, self.count), ^{
+        _backingList.remove_all();
+    });
+}
+
+- (void)replaceObjectAtIndex:(NSUInteger)index withObject:(RLMObject *)object {
+    validateObjectToAdd(self, object);
+    changeArray(self, NSKeyValueChangeReplacement, index, ^{
+        _backingList.set(index, object->_row.get_index());
+    });
+}
+
+- (void)moveObjectAtIndex:(NSUInteger)sourceIndex toIndex:(NSUInteger)destinationIndex {
+    auto start = std::min(sourceIndex, destinationIndex);
+    auto len = std::max(sourceIndex, destinationIndex) - start + 1;
+    changeArray(self, NSKeyValueChangeReplacement, {start, len}, ^{
+        _backingList.move(sourceIndex, destinationIndex);
+    });
+}
+
+- (void)exchangeObjectAtIndex:(NSUInteger)index1 withObjectAtIndex:(NSUInteger)index2 {
+    changeArray(self, NSKeyValueChangeReplacement, ^{
+        _backingList.swap(index1, index2);
+    }, [=] {
+        NSMutableIndexSet *set = [[NSMutableIndexSet alloc] initWithIndex:index1];
+        [set addIndex:index2];
+        return set;
+    });
+}
+
+- (NSUInteger)indexOfObject:(RLMObject *)object {
+    if (object.invalidated) {
+        @throw RLMException(@"Object has been deleted or invalidated");
+    }
+
+    // check that object types align
+    if (![_objectClassName isEqualToString:object->_objectSchema.className]) {
+        @throw RLMException(@"Object of type (%@) does not match RLMArray type (%@)",
+                            object->_objectSchema.className, _objectClassName);
+    }
+
+    return translateErrors([&] { return RLMConvertNotFound(_backingList.find(object->_row)); });
+}
+
+- (id)valueForKeyPath:(NSString *)keyPath {
+    if ([keyPath hasPrefix:@"@"]) {
+        // Delegate KVC collection operators to RLMResults
+        auto query = translateErrors([&] { return _backingList.get_query(); });
+        RLMResults *results = [RLMResults resultsWithObjectSchema:_objectSchema
+                                                          results:realm::Results(_realm->_realm, std::move(query))];
+        return [results valueForKeyPath:keyPath];
+    }
+    return [super valueForKeyPath:keyPath];
+}
+
+- (id)valueForKey:(NSString *)key {
+    // Ideally we'd use "@invalidated" for this so that "invalidated" would use
+    // normal array KVC semantics, but observing @things works very oddly (when
+    // it's part of a key path, it's triggered automatically when array index
+    // changes occur, and can't be sent explicitly, but works normally when it's
+    // the entire key path), and an RLMArrayLinkView *can't* have objects where
+    // invalidated is true, so we're not losing much.
+    if ([key isEqualToString:RLMInvalidatedKey]) {
+        return @(!_backingList.is_valid());
+    }
+
+    translateErrors([&] { _backingList.verify_attached(); });
+    return RLMCollectionValueForKey(self, key);
+}
+
+- (void)setValue:(id)value forKey:(NSString *)key {
+    translateErrors([&] { _backingList.verify_in_transaction(); });
+    RLMCollectionSetValueForKey(self, key, value);
+}
+
+- (void)deleteObjectsFromRealm {
+    // delete all target rows from the realm
+    RLMTrackDeletions(_realm, ^{
+        translateErrors([&] { _backingList.delete_all(); });
+    });
+}
+
+- (RLMResults *)sortedResultsUsingDescriptors:(NSArray *)properties {
+    auto order = RLMSortOrderFromDescriptors(*_objectSchema.table, properties);
+    auto results = translateErrors([&] { return _backingList.sort(std::move(order)); });
+    return [RLMResults resultsWithObjectSchema:_objectSchema results:std::move(results)];
+}
+
+- (RLMResults *)objectsWithPredicate:(NSPredicate *)predicate {
+    auto query = RLMPredicateToQuery(predicate, _objectSchema, _realm.schema, *_realm.group);
+    auto results = translateErrors([&] { return _backingList.filter(std::move(query)); });
+    return [RLMResults resultsWithObjectSchema:_objectSchema results:std::move(results)];
+}
+
+- (NSUInteger)indexOfObjectWithPredicate:(NSPredicate *)predicate {
+    auto query = translateErrors([&] { return _backingList.get_query(); });
+    query.and_query(RLMPredicateToQuery(predicate, _objectSchema, _realm.schema, *_realm.group));
+    return RLMConvertNotFound(query.find());
+}
+
+- (NSArray *)objectsAtIndexes:(__unused NSIndexSet *)indexes {
+    // FIXME: this is called by KVO when array changes are made. It's not clear
+    // why, and returning nil seems to work fine.
+    return nil;
+}
+
+- (void)addObserver:(id)observer
+         forKeyPath:(NSString *)keyPath
+            options:(NSKeyValueObservingOptions)options
+            context:(void *)context {
+    RLMEnsureArrayObservationInfo(_observationInfo, keyPath, self, self);
+    [super addObserver:observer forKeyPath:keyPath options:options context:context];
+}
+
+- (NSUInteger)indexInSource:(NSUInteger)index {
+    return _backingList.get_unchecked(index);
+}
+
+- (realm::TableView)tableView {
+    return translateErrors([&] { return _backingList.get_query(); }).find_all();
+}
+
+// The compiler complains about the method's argument type not matching due to
+// it not having the generic type attached, but it doesn't seem to be possible
+// to actually include the generic type
+// http://www.openradar.me/radar?id=6135653276319744
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wmismatched-parameter-types"
+- (RLMNotificationToken *)addNotificationBlock:(void (^)(RLMArray *, RLMCollectionChange *, NSError *))block {
+    [_realm verifyNotificationsAreSupported];
+    return RLMAddNotificationBlock(self, _backingList, block);
+}
+#pragma clang diagnostic pop
+
+@end
diff --git a/Pods/Realm/Realm/RLMCollection.mm b/Pods/Realm/Realm/RLMCollection.mm
new file mode 100644
index 0000000..bb9c304
--- /dev/null
+++ b/Pods/Realm/Realm/RLMCollection.mm
@@ -0,0 +1,344 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2016 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import "RLMCollection_Private.hpp"
+
+#import "RLMArray_Private.h"
+#import "RLMObjectSchema_Private.hpp"
+#import "RLMObjectStore.h"
+#import "RLMObject_Private.h"
+
+#import "collection_notifications.hpp"
+#import "list.hpp"
+#import "results.hpp"
+
+#import <realm/table_view.hpp>
+
+static const int RLMEnumerationBufferSize = 16;
+
+@implementation RLMFastEnumerator {
+    // The buffer supplied by fast enumeration does not retain the objects given
+    // to it, but because we create objects on-demand and don't want them
+    // autoreleased (a table can have more rows than the device has memory for
+    // accessor objects) we need a thing to retain them.
+    id _strongBuffer[RLMEnumerationBufferSize];
+
+    RLMRealm *_realm;
+    RLMObjectSchema *_objectSchema;
+
+    // Collection being enumerated. Only one of these two will be valid: when
+    // possible we enumerate the collection directly, but when in a write
+    // transaction we instead create a frozen TableView and enumerate that
+    // instead so that mutating the collection during enumeration works.
+    id<RLMFastEnumerable> _collection;
+    realm::TableView _tableView;
+}
+
+- (instancetype)initWithCollection:(id<RLMFastEnumerable>)collection objectSchema:(RLMObjectSchema *)objectSchema {
+    self = [super init];
+    if (self) {
+        _realm = collection.realm;
+        _objectSchema = objectSchema;
+
+        if (_realm.inWriteTransaction) {
+            _tableView = [collection tableView];
+        }
+        else {
+            _collection = collection;
+            [_realm registerEnumerator:self];
+        }
+    }
+    return self;
+}
+
+- (void)dealloc {
+    if (_collection) {
+        [_realm unregisterEnumerator:self];
+    }
+}
+
+- (void)detach {
+    _tableView = [_collection tableView];
+    _collection = nil;
+}
+
+- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state
+                                    count:(NSUInteger)len {
+    [_realm verifyThread];
+    if (!_tableView.is_attached() && !_collection) {
+        @throw RLMException(@"Collection is no longer valid");
+    }
+    // The fast enumeration buffer size is currently a hardcoded number in the
+    // compiler so this can't actually happen, but just in case it changes in
+    // the future...
+    if (len > RLMEnumerationBufferSize) {
+        len = RLMEnumerationBufferSize;
+    }
+
+    NSUInteger batchCount = 0, count = state->extra[1];
+
+    Class accessorClass = _objectSchema.accessorClass;
+    for (NSUInteger index = state->state; index < count && batchCount < len; ++index) {
+        RLMObject *accessor = [[accessorClass alloc] initWithRealm:_realm schema:_objectSchema];
+        if (_collection) {
+            accessor->_row = (*_objectSchema.table)[[_collection indexInSource:index]];
+        }
+        else if (_tableView.is_row_attached(index)) {
+            accessor->_row = (*_objectSchema.table)[_tableView.get_source_ndx(index)];
+        }
+        RLMInitializeSwiftAccessorGenerics(accessor);
+        _strongBuffer[batchCount] = accessor;
+        batchCount++;
+    }
+
+    for (NSUInteger i = batchCount; i < len; ++i) {
+        _strongBuffer[i] = nil;
+    }
+
+    if (batchCount == 0) {
+        // Release our data if we're done, as we're autoreleased and so may
+        // stick around for a while
+        _collection = nil;
+        if (_tableView.is_attached()) {
+            _tableView = {};
+        }
+        else {
+            [_realm unregisterEnumerator:self];
+        }
+    }
+
+    state->itemsPtr = (__unsafe_unretained id *)(void *)_strongBuffer;
+    state->state += batchCount;
+    state->mutationsPtr = state->extra+1;
+
+    return batchCount;
+}
+@end
+
+
+NSArray *RLMCollectionValueForKey(id<RLMFastEnumerable> collection, NSString *key) {
+    size_t count = collection.count;
+    if (count == 0) {
+        return @[];
+    }
+
+    RLMRealm *realm = collection.realm;
+    RLMObjectSchema *objectSchema = collection.objectSchema;
+
+    NSMutableArray *results = [NSMutableArray arrayWithCapacity:count];
+    if ([key isEqualToString:@"self"]) {
+        for (size_t i = 0; i < count; i++) {
+            size_t rowIndex = [collection indexInSource:i];
+            [results addObject:RLMCreateObjectAccessor(realm, objectSchema, rowIndex) ?: NSNull.null];
+        }
+        return results;
+    }
+
+    RLMObjectBase *accessor = [[objectSchema.accessorClass alloc] initWithRealm:realm schema:objectSchema];
+    realm::Table *table = objectSchema.table;
+    for (size_t i = 0; i < count; i++) {
+        size_t rowIndex = [collection indexInSource:i];
+        accessor->_row = (*table)[rowIndex];
+        RLMInitializeSwiftAccessorGenerics(accessor);
+        [results addObject:[accessor valueForKey:key] ?: NSNull.null];
+    }
+
+    return results;
+}
+
+void RLMCollectionSetValueForKey(id<RLMFastEnumerable> collection, NSString *key, id value) {
+    realm::TableView tv = [collection tableView];
+    if (tv.size() == 0) {
+        return;
+    }
+
+    RLMRealm *realm = collection.realm;
+    RLMObjectSchema *objectSchema = collection.objectSchema;
+    RLMObjectBase *accessor = [[objectSchema.accessorClass alloc] initWithRealm:realm schema:objectSchema];
+    for (size_t i = 0; i < tv.size(); i++) {
+        accessor->_row = tv[i];
+        RLMInitializeSwiftAccessorGenerics(accessor);
+        [accessor setValue:value forKey:key];
+    }
+}
+
+NSString *RLMDescriptionWithMaxDepth(NSString *name,
+                                     id<RLMCollection> collection,
+                                     NSUInteger depth) {
+    if (depth == 0) {
+        return @"<Maximum depth exceeded>";
+    }
+
+    const NSUInteger maxObjects = 100;
+    auto str = [NSMutableString stringWithFormat:@"%@ <%p> (\n", name, (void *)collection];
+    size_t index = 0, skipped = 0;
+    for (id obj in collection) {
+        NSString *sub;
+        if ([obj respondsToSelector:@selector(descriptionWithMaxDepth:)]) {
+            sub = [obj descriptionWithMaxDepth:depth - 1];
+        }
+        else {
+            sub = [obj description];
+        }
+
+        // Indent child objects
+        NSString *objDescription = [sub stringByReplacingOccurrencesOfString:@"\n"
+                                                                  withString:@"\n\t"];
+        [str appendFormat:@"\t[%zu] %@,\n", index++, objDescription];
+        if (index >= maxObjects) {
+            skipped = collection.count - maxObjects;
+            break;
+        }
+    }
+
+    // Remove last comma and newline characters
+    if (collection.count > 0) {
+        [str deleteCharactersInRange:NSMakeRange(str.length-2, 2)];
+    }
+    if (skipped) {
+        [str appendFormat:@"\n\t... %zu objects skipped.", skipped];
+    }
+    [str appendFormat:@"\n)"];
+    return str;
+}
+
+@implementation RLMCancellationToken {
+    realm::NotificationToken _token;
+}
+- (instancetype)initWithToken:(realm::NotificationToken)token {
+    self = [super init];
+    if (self) {
+        _token = std::move(token);
+    }
+    return self;
+}
+
+- (void)stop {
+    _token = {};
+}
+
+@end
+
+@implementation RLMCollectionChange {
+    realm::CollectionChangeSet _indices;
+}
+
+- (instancetype)initWithChanges:(realm::CollectionChangeSet)indices {
+    self = [super init];
+    if (self) {
+        _indices = std::move(indices);
+    }
+    return self;
+}
+
+static NSArray *toArray(realm::IndexSet const& set) {
+    NSMutableArray *ret = [NSMutableArray new];
+    for (auto index : set.as_indexes()) {
+        [ret addObject:@(index)];
+    }
+    return ret;
+}
+
+- (NSArray *)insertions {
+    return toArray(_indices.insertions);
+}
+
+- (NSArray *)deletions {
+    return toArray(_indices.deletions);
+}
+
+- (NSArray *)modifications {
+    return toArray(_indices.modifications);
+}
+
+static NSArray *toIndexPathArray(realm::IndexSet const& set, NSUInteger section) {
+    NSMutableArray *ret = [NSMutableArray new];
+    NSUInteger path[2] = {section, 0};
+    for (auto index : set.as_indexes()) {
+        path[1] = index;
+        [ret addObject:[NSIndexPath indexPathWithIndexes:path length:2]];
+    }
+    return ret;
+}
+
+- (NSArray<NSIndexPath *> *)deletionsInSection:(NSUInteger)section {
+    return toIndexPathArray(_indices.deletions, section);
+}
+
+- (NSArray<NSIndexPath *> *)insertionsInSection:(NSUInteger)section {
+    return toIndexPathArray(_indices.insertions, section);
+
+}
+
+- (NSArray<NSIndexPath *> *)modificationsInSection:(NSUInteger)section {
+    return toIndexPathArray(_indices.modifications, section);
+
+}
+@end
+
+template<typename Collection>
+RLMNotificationToken *RLMAddNotificationBlock(id objcCollection,
+                                              Collection& collection,
+                                              void (^block)(id, RLMCollectionChange *, NSError *),
+                                              bool suppressInitialChange) {
+    struct IsValid {
+        static bool call(realm::List const& list) {
+            return list.is_valid();
+        }
+        static bool call(realm::Results const&) {
+            return true;
+        }
+    };
+
+    auto skip = suppressInitialChange ? std::make_shared<bool>(true) : nullptr;
+    auto cb = [=, &collection](realm::CollectionChangeSet const& changes,
+                               std::exception_ptr err) {
+        if (err) {
+            try {
+                rethrow_exception(err);
+            }
+            catch (...) {
+                NSError *error = nil;
+                RLMRealmTranslateException(&error);
+                block(nil, nil, error);
+                return;
+            }
+        }
+
+        if (!IsValid::call(collection)) {
+            return;
+        }
+
+        if (skip && *skip) {
+            *skip = false;
+            block(objcCollection, nil, nil);
+        }
+        else if (changes.empty()) {
+            block(objcCollection, nil, nil);
+        }
+        else {
+            block(objcCollection, [[RLMCollectionChange alloc] initWithChanges:changes], nil);
+        }
+    };
+
+    return [[RLMCancellationToken alloc] initWithToken:collection.add_notification_callback(cb)];
+}
+
+// Explicitly instantiate the templated function for the two types we'll use it on
+template RLMNotificationToken *RLMAddNotificationBlock<realm::List>(id, realm::List&, void (^)(id, RLMCollectionChange *, NSError *), bool);
+template RLMNotificationToken *RLMAddNotificationBlock<realm::Results>(id, realm::Results&, void (^)(id, RLMCollectionChange *, NSError *), bool);
diff --git a/Pods/Realm/Realm/RLMConstants.m b/Pods/Realm/Realm/RLMConstants.m
new file mode 100644
index 0000000..7136127
--- /dev/null
+++ b/Pods/Realm/Realm/RLMConstants.m
@@ -0,0 +1,34 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import <Realm/RLMConstants.h>
+
+RLMNotification const RLMRealmRefreshRequiredNotification = @"RLMRealmRefreshRequiredNotification";
+RLMNotification const RLMRealmDidChangeNotification = @"RLMRealmDidChangeNotification";
+
+NSString * const RLMErrorDomain = @"io.realm";
+
+NSString * const RLMUnknownSystemErrorDomain = @"io.realm.unknown";
+
+NSString * const RLMExceptionName = @"RLMException";
+
+NSString * const RLMRealmVersionKey = @"RLMRealmVersion";
+
+NSString * const RLMRealmCoreVersionKey = @"RLMRealmCoreVersion";
+
+NSString * const RLMInvalidatedKey = @"invalidated";
diff --git a/Pods/Realm/Realm/RLMListBase.mm b/Pods/Realm/Realm/RLMListBase.mm
new file mode 100644
index 0000000..78cf91a
--- /dev/null
+++ b/Pods/Realm/Realm/RLMListBase.mm
@@ -0,0 +1,60 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2015 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import "RLMListBase.h"
+
+#import "RLMArray_Private.hpp"
+#import "RLMObservation.hpp"
+
+@interface RLMArray (KVO)
+- (NSArray *)objectsAtIndexes:(__unused NSIndexSet *)indexes;
+@end
+
+@implementation RLMListBase {
+    std::unique_ptr<RLMObservationInfo> _observationInfo;
+}
+
+- (instancetype)initWithArray:(RLMArray *)array {
+    self = [super init];
+    if (self) {
+        __rlmArray = array;
+    }
+    return self;
+}
+
+- (id)valueForKey:(NSString *)key {
+    return [__rlmArray valueForKey:key];
+}
+
+- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(id __unsafe_unretained [])buffer count:(NSUInteger)len {
+    return [__rlmArray countByEnumeratingWithState:state objects:buffer count:len];
+}
+
+- (NSArray *)objectsAtIndexes:(NSIndexSet *)indexes {
+    return [__rlmArray objectsAtIndexes:indexes];
+}
+
+- (void)addObserver:(id)observer
+         forKeyPath:(NSString *)keyPath
+            options:(NSKeyValueObservingOptions)options
+            context:(void *)context {
+    RLMEnsureArrayObservationInfo(_observationInfo, keyPath, __rlmArray, self);
+    [super addObserver:observer forKeyPath:keyPath options:options context:context];
+}
+
+@end
diff --git a/Pods/Realm/Realm/RLMMigration.mm b/Pods/Realm/Realm/RLMMigration.mm
new file mode 100644
index 0000000..c0be80c
--- /dev/null
+++ b/Pods/Realm/Realm/RLMMigration.mm
@@ -0,0 +1,164 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import "RLMMigration_Private.h"
+
+#import "RLMAccessor.h"
+#import "RLMObject.h"
+#import "RLMObjectSchema_Private.hpp"
+#import "RLMObjectStore.h"
+#import "RLMProperty_Private.h"
+#import "RLMRealm_Dynamic.h"
+#import "RLMRealm_Private.hpp"
+#import "RLMResults_Private.h"
+#import "RLMSchema_Private.hpp"
+
+#import "object_store.hpp"
+#import "shared_realm.hpp"
+#import "schema.hpp"
+
+using namespace realm;
+
+// The source realm for a migration has to use a SharedGroup to be able to share
+// the file with the destination realm, but we don't want to let the user call
+// beginWriteTransaction on it as that would make no sense.
+@interface RLMMigrationRealm : RLMRealm
+@end
+
+@implementation RLMMigrationRealm
+- (BOOL)readonly {
+    return YES;
+}
+
+- (void)beginWriteTransaction {
+    @throw RLMException(@"Cannot modify the source Realm in a migration");
+}
+@end
+
+@implementation RLMMigration
+
+- (instancetype)initWithRealm:(RLMRealm *)realm oldRealm:(RLMRealm *)oldRealm {
+    self = [super init];
+    if (self) {
+        // create rw realm to migrate with current on disk table
+        _realm = realm;
+        _oldRealm = oldRealm;
+        object_setClass(_oldRealm, RLMMigrationRealm.class);
+    }
+    return self;
+}
+
+- (RLMSchema *)oldSchema {
+    return self.oldRealm.schema;
+}
+
+- (RLMSchema *)newSchema {
+    return self.realm.schema;
+}
+
+- (void)enumerateObjects:(NSString *)className block:(RLMObjectMigrationBlock)block {
+    // get all objects
+    RLMResults *objects = [_realm.schema schemaForClassName:className] ? [_realm allObjects:className] : nil;
+    RLMResults *oldObjects = [_oldRealm.schema schemaForClassName:className] ? [_oldRealm allObjects:className] : nil;
+
+    if (objects && oldObjects) {
+        for (long i = oldObjects.count - 1; i >= 0; i--) {
+            @autoreleasepool {
+                block(oldObjects[i], objects[i]);
+            }
+        }
+    }
+    else if (objects) {
+        for (long i = objects.count - 1; i >= 0; i--) {
+            @autoreleasepool {
+                block(nil, objects[i]);
+            }
+        }
+    }
+    else if (oldObjects) {
+        for (long i = oldObjects.count - 1; i >= 0; i--) {
+            @autoreleasepool {
+                block(oldObjects[i], nil);
+            }
+        }
+    }
+}
+
+- (void)execute:(RLMMigrationBlock)block {
+    @autoreleasepool {
+        // disable all primary keys for migration
+        for (RLMObjectSchema *objectSchema in _realm.schema.objectSchema) {
+            objectSchema.primaryKeyProperty.isPrimary = NO;
+        }
+
+        // apply block and set new schema version
+        uint64_t oldVersion = _oldRealm->_realm->config().schema_version;
+        block(self, oldVersion);
+
+        _oldRealm = nil;
+        _realm = nil;
+    }
+}
+
+- (RLMObject *)createObject:(NSString *)className withValue:(id)value {
+    return [_realm createObject:className withValue:value];
+}
+
+- (RLMObject *)createObject:(NSString *)className withObject:(id)object {
+    return [self createObject:className withValue:object];
+}
+
+- (void)deleteObject:(RLMObject *)object {
+    [_realm deleteObject:object];
+}
+
+- (BOOL)deleteDataForClassName:(NSString *)name {
+    if (!name) {
+        return false;
+    }
+
+    TableRef table = ObjectStore::table_for_object_type(_realm.group, name.UTF8String);
+    if (!table) {
+        return false;
+    }
+
+    if ([_realm.schema schemaForClassName:name]) {
+        table->clear();
+    }
+    else {
+        realm::ObjectStore::delete_data_for_object(_realm.group, name.UTF8String);
+    }
+
+    return true;
+}
+
+- (void)renamePropertyForClass:(NSString *)className oldName:(NSString *)oldName newName:(NSString *)newName {
+    realm::ObjectStore::rename_property(_realm.group, *_realm->_realm->config().schema, className.UTF8String, oldName.UTF8String, newName.UTF8String);
+    ObjectSchema objectStoreSchema(_realm.group, className.UTF8String);
+    RLMObjectSchema *objectSchema = [RLMObjectSchema objectSchemaForObjectStoreSchema:objectStoreSchema];
+    NSMutableArray *mutableObjectSchemas = [NSMutableArray arrayWithArray:_realm.schema.objectSchema];
+    [mutableObjectSchemas replaceObjectAtIndex:[mutableObjectSchemas indexOfObject:_realm.schema[className]]
+                                    withObject:objectSchema];
+    objectSchema.realm = _realm;
+    _realm.schema.objectSchema = [mutableObjectSchemas copy];
+    for (RLMProperty *property in objectSchema.properties) {
+        property.column = objectStoreSchema.property_for_name(property.name.UTF8String)->table_column;
+    }
+}
+
+@end
diff --git a/Pods/Realm/Realm/RLMObject.mm b/Pods/Realm/Realm/RLMObject.mm
new file mode 100644
index 0000000..dc9bb03
--- /dev/null
+++ b/Pods/Realm/Realm/RLMObject.mm
@@ -0,0 +1,225 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import "RLMAccessor.h"
+#import "RLMObject_Private.h"
+#import "RLMObjectSchema_Private.hpp"
+#import "RLMObjectStore.h"
+#import "RLMSchema_Private.h"
+#import "RLMRealm_Private.hpp"
+#import "RLMQueryUtil.hpp"
+
+// We declare things in RLMObject which are actually implemented in RLMObjectBase
+// for documentation's sake, which leads to -Wunimplemented-method warnings.
+// Other alternatives to this would be to disable -Wunimplemented-method for this
+// file (but then we could miss legitimately missing things), or declaring the
+// inherited things in a category (but they currently aren't nicely grouped for
+// that).
+@implementation RLMObject
+
+// synthesized in RLMObjectBase
+@dynamic invalidated, realm, objectSchema;
+
+#pragma mark - Designated Initializers
+
+- (instancetype)init {
+    return [super init];
+}
+
+- (instancetype)initWithValue:(id)value schema:(RLMSchema *)schema {
+    return [super initWithValue:value schema:schema];
+}
+
+- (instancetype)initWithRealm:(__unsafe_unretained RLMRealm *const)realm
+                       schema:(__unsafe_unretained RLMObjectSchema *const)schema {
+    return [super initWithRealm:realm schema:schema];
+}
+
+#pragma mark - Convenience Initializers
+
+- (instancetype)initWithValue:(id)value {
+    [self.class sharedSchema]; // ensure this class' objectSchema is loaded in the partialSharedSchema
+    RLMSchema *schema = RLMSchema.partialSharedSchema;
+    return [super initWithValue:value schema:schema];
+}
+
+#pragma mark - Class-based Object Creation
+
++ (instancetype)createInDefaultRealmWithValue:(id)value {
+    return (RLMObject *)RLMCreateObjectInRealmWithValue([RLMRealm defaultRealm], [self className], value, false);
+}
+
++ (instancetype)createInRealm:(RLMRealm *)realm withValue:(id)value {
+    return (RLMObject *)RLMCreateObjectInRealmWithValue(realm, [self className], value, false);
+}
+
++ (instancetype)createOrUpdateInDefaultRealmWithValue:(id)value {
+    return [self createOrUpdateInRealm:[RLMRealm defaultRealm] withValue:value];
+}
+
++ (instancetype)createOrUpdateInRealm:(RLMRealm *)realm withValue:(id)value {
+    // verify primary key
+    RLMObjectSchema *schema = [self sharedSchema];
+    if (!schema.primaryKeyProperty) {
+        NSString *reason = [NSString stringWithFormat:@"'%@' does not have a primary key and can not be updated", schema.className];
+        @throw [NSException exceptionWithName:@"RLMExecption" reason:reason userInfo:nil];
+    }
+    return (RLMObject *)RLMCreateObjectInRealmWithValue(realm, [self className], value, true);
+}
+
+#pragma mark - Subscripting
+
+- (id)objectForKeyedSubscript:(NSString *)key {
+    return RLMObjectBaseObjectForKeyedSubscript(self, key);
+}
+
+- (void)setObject:(id)obj forKeyedSubscript:(NSString *)key {
+    RLMObjectBaseSetObjectForKeyedSubscript(self, key, obj);
+}
+
+#pragma mark - Getting & Querying
+
++ (RLMResults *)allObjects {
+    return RLMGetObjects(RLMRealm.defaultRealm, self.className, nil);
+}
+
++ (RLMResults *)allObjectsInRealm:(RLMRealm *)realm {
+    return RLMGetObjects(realm, self.className, nil);
+}
+
++ (RLMResults *)objectsWhere:(NSString *)predicateFormat, ... {
+    va_list args;
+    va_start(args, predicateFormat);
+    RLMResults *results = [self objectsWhere:predicateFormat args:args];
+    va_end(args);
+    return results;
+}
+
++ (RLMResults *)objectsWhere:(NSString *)predicateFormat args:(va_list)args {
+    return [self objectsWithPredicate:[NSPredicate predicateWithFormat:predicateFormat arguments:args]];
+}
+
++ (RLMResults *)objectsInRealm:(RLMRealm *)realm where:(NSString *)predicateFormat, ... {
+    va_list args;
+    va_start(args, predicateFormat);
+    RLMResults *results = [self objectsInRealm:realm where:predicateFormat args:args];
+    va_end(args);
+    return results;
+}
+
++ (RLMResults *)objectsInRealm:(RLMRealm *)realm where:(NSString *)predicateFormat args:(va_list)args {
+    return [self objectsInRealm:realm withPredicate:[NSPredicate predicateWithFormat:predicateFormat arguments:args]];
+}
+
++ (RLMResults *)objectsWithPredicate:(NSPredicate *)predicate {
+    return RLMGetObjects(RLMRealm.defaultRealm, self.className, predicate);
+}
+
++ (RLMResults *)objectsInRealm:(RLMRealm *)realm withPredicate:(NSPredicate *)predicate {
+    return RLMGetObjects(realm, self.className, predicate);
+}
+
++ (instancetype)objectForPrimaryKey:(id)primaryKey {
+    return RLMGetObject(RLMRealm.defaultRealm, self.className, primaryKey);
+}
+
++ (instancetype)objectInRealm:(RLMRealm *)realm forPrimaryKey:(id)primaryKey {
+    return RLMGetObject(realm, self.className, primaryKey);
+}
+
+#pragma mark - Other Instance Methods
+
+- (BOOL)isEqualToObject:(RLMObject *)object {
+    return [object isKindOfClass:RLMObject.class] && RLMObjectBaseAreEqual(self, object);
+}
+
++ (NSString *)className {
+    return [super className];
+}
+
+#pragma mark - Default values for schema definition
+
++ (NSArray *)indexedProperties {
+    return @[];
+}
+
++ (NSDictionary *)linkingObjectsProperties {
+    return @{};
+}
+
++ (NSDictionary *)defaultPropertyValues {
+    return nil;
+}
+
++ (NSString *)primaryKey {
+    return nil;
+}
+
++ (NSArray *)ignoredProperties {
+    return nil;
+}
+
++ (NSArray *)requiredProperties {
+    return @[];
+}
+
+@end
+
+@implementation RLMDynamicObject
+
++ (BOOL)shouldIncludeInDefaultSchema {
+    return NO;
+}
+
+- (id)valueForUndefinedKey:(NSString *)key {
+    return RLMDynamicGet(self, RLMValidatedGetProperty(self, key));
+}
+
+- (void)setValue:(id)value forUndefinedKey:(NSString *)key {
+    RLMDynamicValidatedSet(self, key, value);
+}
+
+@end
+
+@implementation RLMWeakObjectHandle {
+    realm::Row _row;
+    RLMRealm *_realm;
+    RLMObjectSchema *_objectSchema;
+    Class _objectClass;
+}
+
+- (instancetype)initWithObject:(RLMObjectBase *)object {
+    if (!(self = [super init])) {
+        return nil;
+    }
+
+    _row = object->_row;
+    _realm = object->_realm;
+    _objectSchema = object->_objectSchema;
+    _objectClass = object.class;
+
+    return self;
+}
+
+- (RLMObjectBase *)object {
+    RLMObjectBase *object = [[_objectClass alloc] initWithRealm:_realm schema:_objectSchema];
+    object->_row = std::move(_row);
+    return object;
+}
+
+@end
diff --git a/Pods/Realm/Realm/RLMObjectBase.mm b/Pods/Realm/Realm/RLMObjectBase.mm
new file mode 100644
index 0000000..1c0f586
--- /dev/null
+++ b/Pods/Realm/Realm/RLMObjectBase.mm
@@ -0,0 +1,447 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import "RLMObject_Private.hpp"
+
+#import "RLMAccessor.h"
+#import "RLMArray_Private.hpp"
+#import "RLMListBase.h"
+#import "RLMObjectSchema_Private.hpp"
+#import "RLMObjectStore.h"
+#import "RLMObservation.hpp"
+#import "RLMOptionalBase.h"
+#import "RLMProperty_Private.h"
+#import "RLMRealm_Private.hpp"
+#import "RLMSchema_Private.h"
+#import "RLMSwiftSupport.h"
+#import "RLMUtil.hpp"
+
+using namespace realm;
+
+const NSUInteger RLMDescriptionMaxDepth = 5;
+
+static bool RLMInitializedObjectSchema(RLMObjectBase *obj) {
+    obj->_objectSchema = [obj.class sharedSchema];
+    if (!obj->_objectSchema) {
+        return false;
+    }
+
+    // set default values
+    if (!obj->_objectSchema.isSwiftClass) {
+        NSDictionary *dict = RLMDefaultValuesForObjectSchema(obj->_objectSchema);
+        for (NSString *key in dict) {
+            [obj setValue:dict[key] forKey:key];
+        }
+    }
+
+    // set unmanaged accessor class
+    object_setClass(obj, obj->_objectSchema.unmanagedClass);
+    return true;
+}
+
+@implementation RLMObjectBase
+// unmanaged init
+- (instancetype)init {
+    self = [super init];
+    if (self) {
+        RLMInitializedObjectSchema(self);
+    }
+    return self;
+}
+
+- (void)dealloc {
+    // This can't be a unique_ptr because associated objects are removed
+    // *after* c++ members are destroyed and dealloc is called, and we need it
+    // to be in a validish state when that happens
+    delete _observationInfo;
+    _observationInfo = nullptr;
+}
+
+static id RLMValidatedObjectForProperty(id obj, RLMProperty *prop, RLMSchema *schema) {
+    if (RLMIsObjectValidForProperty(obj, prop)) {
+        return obj;
+    }
+
+    // check for object or array of properties
+    if (prop.type == RLMPropertyTypeObject) {
+        // for object create and try to initialize with obj
+        RLMObjectSchema *objSchema = schema[prop.objectClassName];
+        return [[objSchema.objectClass alloc] initWithValue:obj schema:schema];
+    }
+    else if (prop.type == RLMPropertyTypeArray && [obj conformsToProtocol:@protocol(NSFastEnumeration)]) {
+        // for arrays, create objects for each element and return new array
+        RLMObjectSchema *objSchema = schema[prop.objectClassName];
+        RLMArray *objects = [[RLMArray alloc] initWithObjectClassName:objSchema.className];
+        for (id el in obj) {
+            [objects addObject:[[objSchema.objectClass alloc] initWithValue:el schema:schema]];
+        }
+        return objects;
+    }
+
+    // if not convertible to prop throw
+    @throw RLMException(@"Invalid value '%@' for property '%@'", obj, prop.name);
+}
+
+- (instancetype)initWithValue:(id)value schema:(RLMSchema *)schema {
+    if (!(self = [super init])) {
+        return self;
+    }
+
+    if (!RLMInitializedObjectSchema(self)) {
+        // Don't populate fields from the passed-in object if we're called
+        // during schema init
+        return self;
+    }
+
+    NSArray *properties = _objectSchema.properties;
+    if (NSArray *array = RLMDynamicCast<NSArray>(value)) {
+        if (array.count != properties.count) {
+            @throw RLMException(@"Invalid array input. Number of array elements does not match number of properties.");
+        }
+        for (NSUInteger i = 0; i < array.count; i++) {
+            id propertyValue = RLMValidatedObjectForProperty(array[i], properties[i], schema);
+            [self setValue:RLMCoerceToNil(propertyValue) forKeyPath:[properties[i] name]];
+        }
+    }
+    else {
+        // assume our object is an NSDictionary or an object with kvc properties
+        NSDictionary *defaultValues = nil;
+        for (RLMProperty *prop in properties) {
+            id obj = RLMValidatedValueForProperty(value, prop.name, _objectSchema.className);
+
+            // get default for nil object
+            if (!obj) {
+                if (!defaultValues) {
+                    defaultValues = RLMDefaultValuesForObjectSchema(_objectSchema);
+                }
+                obj = defaultValues[prop.name];
+            }
+
+            obj = RLMValidatedObjectForProperty(obj, prop, schema);
+            [self setValue:RLMCoerceToNil(obj) forKeyPath:prop.name];
+        }
+    }
+
+    return self;
+}
+
+- (instancetype)initWithRealm:(__unsafe_unretained RLMRealm *const)realm
+                       schema:(__unsafe_unretained RLMObjectSchema *const)schema {
+    self = [super init];
+    if (self) {
+        _realm = realm;
+        _objectSchema = schema;
+    }
+    return self;
+}
+
+- (id)valueForKey:(NSString *)key {
+    if (_observationInfo) {
+        return _observationInfo->valueForKey(key);
+    }
+    return [super valueForKey:key];
+}
+
+// Generic Swift properties can't be dynamic, so KVO doesn't work for them by default
+- (id)valueForUndefinedKey:(NSString *)key {
+    if (Ivar ivar = _objectSchema[key].swiftIvar) {
+        return RLMCoerceToNil(object_getIvar(self, ivar));
+    }
+    return [super valueForUndefinedKey:key];
+}
+
+- (void)setValue:(id)value forUndefinedKey:(NSString *)key {
+    RLMProperty *property = _objectSchema[key];
+    if (Ivar ivar = property.swiftIvar) {
+        if (property.type == RLMPropertyTypeArray && [value conformsToProtocol:@protocol(NSFastEnumeration)]) {
+            RLMArray *array = [object_getIvar(self, ivar) _rlmArray];
+            [array removeAllObjects];
+            [array addObjects:value];
+        }
+        else if (property.optional) {
+            RLMOptionalBase *optional = object_getIvar(self, ivar);
+            optional.underlyingValue = value;
+        }
+        return;
+    }
+    [super setValue:value forUndefinedKey:key];
+}
+
+// overridden at runtime per-class for performance
++ (NSString *)className {
+    NSString *className = NSStringFromClass(self);
+    if ([RLMSwiftSupport isSwiftClassName:className]) {
+        className = [RLMSwiftSupport demangleClassName:className];
+    }
+    return className;
+}
+
+// overridden at runtime per-class for performance
++ (RLMObjectSchema *)sharedSchema {
+    return [RLMSchema sharedSchemaForClass:self.class];
+}
+
++ (Class)objectUtilClass:(BOOL)isSwift {
+    return RLMObjectUtilClass(isSwift);
+}
+
+- (NSString *)description
+{
+    if (self.isInvalidated) {
+        return @"[invalid object]";
+    }
+
+    return [self descriptionWithMaxDepth:RLMDescriptionMaxDepth];
+}
+
+- (NSString *)descriptionWithMaxDepth:(NSUInteger)depth {
+    if (depth == 0) {
+        return @"<Maximum depth exceeded>";
+    }
+
+    NSString *baseClassName = _objectSchema.className;
+    NSMutableString *mString = [NSMutableString stringWithFormat:@"%@ {\n", baseClassName];
+
+    for (RLMProperty *property in _objectSchema.properties) {
+        id object = RLMObjectBaseObjectForKeyedSubscript(self, property.name);
+        NSString *sub;
+        if ([object respondsToSelector:@selector(descriptionWithMaxDepth:)]) {
+            sub = [object descriptionWithMaxDepth:depth - 1];
+        }
+        else if (property.type == RLMPropertyTypeData) {
+            static NSUInteger maxPrintedDataLength = 24;
+            NSData *data = object;
+            NSUInteger length = data.length;
+            if (length > maxPrintedDataLength) {
+                data = [NSData dataWithBytes:data.bytes length:maxPrintedDataLength];
+            }
+            NSString *dataDescription = [data description];
+            sub = [NSString stringWithFormat:@"<%@ — %lu total bytes>", [dataDescription substringWithRange:NSMakeRange(1, dataDescription.length - 2)], (unsigned long)length];
+        }
+        else {
+            sub = [object description];
+        }
+        [mString appendFormat:@"\t%@ = %@;\n", property.name, [sub stringByReplacingOccurrencesOfString:@"\n" withString:@"\n\t"]];
+    }
+    [mString appendString:@"}"];
+
+    return [NSString stringWithString:mString];
+}
+
+- (RLMRealm *)realm {
+    return _realm;
+}
+
+- (RLMObjectSchema *)objectSchema {
+    return _objectSchema;
+}
+
+- (BOOL)isInvalidated {
+    // if not unmanaged and our accessor has been detached, we have been deleted
+    return self.class == _objectSchema.accessorClass && !_row.is_attached();
+}
+
+- (BOOL)isEqual:(id)object {
+    if (RLMObjectBase *other = RLMDynamicCast<RLMObjectBase>(object)) {
+        if (_objectSchema.primaryKeyProperty) {
+            return RLMObjectBaseAreEqual(self, other);
+        }
+    }
+    return [super isEqual:object];
+}
+
+- (NSUInteger)hash {
+    if (_objectSchema.primaryKeyProperty) {
+        id primaryProperty = [self valueForKey:_objectSchema.primaryKeyProperty.name];
+
+        // modify the hash of our primary key value to avoid potential (although unlikely) collisions
+        return [primaryProperty hash] ^ 1;
+    }
+    else {
+        return [super hash];
+    }
+}
+
++ (BOOL)shouldIncludeInDefaultSchema {
+    return RLMIsObjectSubclass(self);
+}
+
+- (id)mutableArrayValueForKey:(NSString *)key {
+    id obj = [self valueForKey:key];
+    if ([obj isKindOfClass:[RLMArray class]]) {
+        return obj;
+    }
+    return [super mutableArrayValueForKey:key];
+}
+
+- (void)addObserver:(id)observer
+         forKeyPath:(NSString *)keyPath
+            options:(NSKeyValueObservingOptions)options
+            context:(void *)context {
+    if (!_observationInfo) {
+        _observationInfo = new RLMObservationInfo(self);
+    }
+    _observationInfo->recordObserver(_row, _objectSchema, keyPath);
+
+    [super addObserver:observer forKeyPath:keyPath options:options context:context];
+}
+
+- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath {
+    [super removeObserver:observer forKeyPath:keyPath];
+    if (_observationInfo)
+        _observationInfo->removeObserver();
+}
+
++ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key {
+    const char *className = class_getName(self);
+    const char accessorClassPrefix[] = "RLMAccessor_";
+    if (!strncmp(className, accessorClassPrefix, sizeof(accessorClassPrefix) - 1)) {
+        if (self.sharedSchema[key]) {
+            return NO;
+        }
+    }
+
+    return [super automaticallyNotifiesObserversForKey:key];
+}
+
+@end
+
+RLMRealm *RLMObjectBaseRealm(__unsafe_unretained RLMObjectBase *object) {
+    return object ? object->_realm : nil;
+}
+
+RLMObjectSchema *RLMObjectBaseObjectSchema(__unsafe_unretained RLMObjectBase *object) {
+    return object ? object->_objectSchema : nil;
+}
+
+id RLMObjectBaseObjectForKeyedSubscript(RLMObjectBase *object, NSString *key) {
+    if (!object) {
+        return nil;
+    }
+
+    if (object->_realm) {
+        return RLMDynamicGet(object, RLMValidatedGetProperty(object, key));
+    }
+    else {
+        return [object valueForKey:key];
+    }
+}
+
+void RLMObjectBaseSetObjectForKeyedSubscript(RLMObjectBase *object, NSString *key, id obj) {
+    if (!object) {
+        return;
+    }
+
+    if (object->_realm) {
+        RLMDynamicValidatedSet(object, key, obj);
+    }
+    else {
+        [object setValue:obj forKey:key];
+    }
+}
+
+
+BOOL RLMObjectBaseAreEqual(RLMObjectBase *o1, RLMObjectBase *o2) {
+    // if not the correct types throw
+    if ((o1 && ![o1 isKindOfClass:RLMObjectBase.class]) || (o2 && ![o2 isKindOfClass:RLMObjectBase.class])) {
+        @throw RLMException(@"Can only compare objects of class RLMObjectBase");
+    }
+    // if identical object (or both are nil)
+    if (o1 == o2) {
+        return YES;
+    }
+    // if one is nil
+    if (o1 == nil || o2 == nil) {
+        return NO;
+    }
+    // if not in realm or differing realms
+    if (o1->_realm == nil || o1->_realm != o2->_realm) {
+        return NO;
+    }
+    // if either are detached
+    if (!o1->_row.is_attached() || !o2->_row.is_attached()) {
+        return NO;
+    }
+    // if table and index are the same
+    return o1->_row.get_table() == o2->_row.get_table()
+        && o1->_row.get_index() == o2->_row.get_index();
+}
+
+id RLMValidatedValueForProperty(id object, NSString *key, NSString *className) {
+    @try {
+        return [object valueForKey:key];
+    }
+    @catch (NSException *e) {
+        if ([e.name isEqualToString:NSUndefinedKeyException]) {
+            @throw RLMException(@"Invalid value '%@' to initialize object of type '%@': missing key '%@'",
+                                object, className, key);
+        }
+        @throw;
+    }
+}
+
+Class RLMObjectUtilClass(BOOL isSwift) {
+    static Class objectUtilObjc = [RLMObjectUtil class];
+    static Class objectUtilSwift = NSClassFromString(@"RealmSwiftObjectUtil");
+    return isSwift && objectUtilSwift ? objectUtilSwift : objectUtilObjc;
+}
+
+@implementation RLMObjectUtil
+
++ (NSArray *)ignoredPropertiesForClass:(Class)cls {
+    return [cls ignoredProperties];
+}
+
++ (NSArray *)indexedPropertiesForClass:(Class)cls {
+    return [cls indexedProperties];
+}
+
++ (NSDictionary *)linkingObjectsPropertiesForClass:(Class)cls {
+    return [cls linkingObjectsProperties];
+}
+
++ (NSDictionary *)linkingObjectProperties:(__unused id)object {
+    return nil;
+}
+
++ (NSArray *)getGenericListPropertyNames:(__unused id)obj {
+    return nil;
+}
+
++ (NSDictionary *)getLinkingObjectsProperties:(__unused id)obj {
+    return nil;
+}
+
++ (void)initializeListProperty:(__unused RLMObjectBase *)object property:(__unused RLMProperty *)property array:(__unused RLMArray *)array {
+}
+
++ (void)initializeOptionalProperty:(__unused RLMObjectBase *)object property:(__unused RLMProperty *)property {
+}
+
++ (void)initializeLinkingObjectsProperty:(__unused RLMObjectBase *)object property:(__unused RLMProperty *)property {
+}
+
++ (NSDictionary *)getOptionalProperties:(__unused id)obj {
+    return nil;
+}
+
++ (NSArray *)requiredPropertiesForClass:(Class)cls {
+    return [cls requiredProperties];
+}
+
+@end
diff --git a/Pods/Realm/Realm/RLMObjectSchema.mm b/Pods/Realm/Realm/RLMObjectSchema.mm
new file mode 100644
index 0000000..1024fe5
--- /dev/null
+++ b/Pods/Realm/Realm/RLMObjectSchema.mm
@@ -0,0 +1,490 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import "RLMObjectSchema_Private.hpp"
+
+#import "RLMArray.h"
+#import "RLMListBase.h"
+#import "RLMObject_Private.h"
+#import "RLMProperty_Private.hpp"
+#import "RLMRealm_Dynamic.h"
+#import "RLMRealm_Private.hpp"
+#import "RLMSchema_Private.h"
+#import "RLMSwiftSupport.h"
+#import "RLMUtil.hpp"
+
+#import "object_store.hpp"
+
+using namespace realm;
+
+// private properties
+@interface RLMObjectSchema ()
+@property (nonatomic, readwrite) NSDictionary<id, RLMProperty *> *allPropertiesByName;
+@property (nonatomic, readwrite) NSString *className;
+@end
+
+@implementation RLMObjectSchema {
+    // table accessor optimization
+    realm::TableRef _table;
+    NSArray *_swiftGenericProperties;
+    std::vector<RLMProperty *> _propertiesInTableOrder;
+}
+
+- (instancetype)initWithClassName:(NSString *)objectClassName objectClass:(Class)objectClass properties:(NSArray *)properties {
+    self = [super init];
+    self.className = objectClassName;
+    self.properties = properties;
+    self.objectClass = objectClass;
+    self.accessorClass = objectClass;
+    self.unmanagedClass = objectClass;
+    return self;
+}
+
+// return properties by name
+-(RLMProperty *)objectForKeyedSubscript:(id <NSCopying>)key {
+    return _allPropertiesByName[key];
+}
+
+// create property map when setting property array
+-(void)setProperties:(NSArray *)properties {
+    _properties = properties;
+    _propertiesInTableOrder.clear();
+    [self _propertiesDidChange];
+}
+
+- (void)setComputedProperties:(NSArray *)computedProperties {
+    _computedProperties = computedProperties;
+    [self _propertiesDidChange];
+}
+
+- (void)_propertiesDidChange {
+    NSMutableDictionary *map = [NSMutableDictionary dictionaryWithCapacity:_properties.count + _computedProperties.count];
+    for (RLMProperty *prop in _properties) {
+        map[prop.name] = prop;
+        if (prop.isPrimary) {
+            self.primaryKeyProperty = prop;
+        }
+    }
+    for (RLMProperty *prop in _computedProperties) {
+        map[prop.name] = prop;
+    }
+    _allPropertiesByName = map;
+}
+
+
+- (void)setPrimaryKeyProperty:(RLMProperty *)primaryKeyProperty {
+    _primaryKeyProperty.isPrimary = NO;
+    primaryKeyProperty.isPrimary = YES;
+    _primaryKeyProperty = primaryKeyProperty;
+}
+
++ (instancetype)schemaForObjectClass:(Class)objectClass {
+    RLMObjectSchema *schema = [RLMObjectSchema new];
+
+    // determine classname from objectclass as className method has not yet been updated
+    NSString *className = NSStringFromClass(objectClass);
+    bool isSwift = [RLMSwiftSupport isSwiftClassName:className];
+    if (isSwift) {
+        className = [RLMSwiftSupport demangleClassName:className];
+    }
+    schema.className = className;
+    schema.objectClass = objectClass;
+    schema.accessorClass = RLMDynamicObject.class;
+    schema.isSwiftClass = isSwift;
+
+    // create array of RLMProperties, inserting properties of superclasses first
+    Class cls = objectClass;
+    Class superClass = class_getSuperclass(cls);
+    NSArray *allProperties = @[];
+    while (superClass && superClass != RLMObjectBase.class) {
+        allProperties = [[RLMObjectSchema propertiesForClass:cls isSwift:isSwift] arrayByAddingObjectsFromArray:allProperties];
+        cls = superClass;
+        superClass = class_getSuperclass(superClass);
+    }
+    NSArray *persistedProperties = [allProperties filteredArrayUsingPredicate:[NSPredicate predicateWithBlock:^BOOL(RLMProperty *property, NSDictionary *) {
+        return !RLMPropertyTypeIsComputed(property.type);
+    }]];
+    schema.properties = persistedProperties;
+
+    NSArray *computedProperties = [allProperties filteredArrayUsingPredicate:[NSPredicate predicateWithBlock:^BOOL(RLMProperty *property, NSDictionary *) {
+        return RLMPropertyTypeIsComputed(property.type);
+    }]];
+    schema.computedProperties = computedProperties;
+
+    // verify that we didn't add any properties twice due to inheritance
+    if (allProperties.count != [NSSet setWithArray:[allProperties valueForKey:@"name"]].count) {
+        NSCountedSet *countedPropertyNames = [NSCountedSet setWithArray:[allProperties valueForKey:@"name"]];
+        NSSet *duplicatePropertyNames = [countedPropertyNames filteredSetUsingPredicate:[NSPredicate predicateWithBlock:^BOOL(id object, NSDictionary *) {
+            return [countedPropertyNames countForObject:object] > 1;
+        }]];
+
+        if (duplicatePropertyNames.count == 1) {
+            @throw RLMException(@"Property '%@' is declared multiple times in the class hierarchy of '%@'", duplicatePropertyNames.allObjects.firstObject, className);
+        } else {
+            @throw RLMException(@"Object '%@' has properties that are declared multiple times in its class hierarchy: '%@'", className, [duplicatePropertyNames.allObjects componentsJoinedByString:@"', '"]);
+        }
+    }
+
+    if (NSString *primaryKey = [objectClass primaryKey]) {
+        for (RLMProperty *prop in schema.properties) {
+            if ([primaryKey isEqualToString:prop.name]) {
+                prop.indexed = YES;
+                schema.primaryKeyProperty = prop;
+                break;
+            }
+        }
+
+        if (!schema.primaryKeyProperty) {
+            @throw RLMException(@"Primary key property '%@' does not exist on object '%@'", primaryKey, className);
+        }
+        if (schema.primaryKeyProperty.type != RLMPropertyTypeInt && schema.primaryKeyProperty.type != RLMPropertyTypeString) {
+            @throw RLMException(@"Only 'string' and 'int' properties can be designated the primary key");
+        }
+    }
+
+    for (RLMProperty *prop in schema.properties) {
+        if (prop.optional && !RLMPropertyTypeIsNullable(prop.type)) {
+            @throw RLMException(@"Only 'string', 'binary', and 'object' properties can be made optional, and property '%@' is of type '%@'.",
+                                prop.name, RLMTypeToString(prop.type));
+        }
+    }
+
+    return schema;
+}
+
++ (nullable NSString *)baseNameForLazySwiftProperty:(NSString *)propertyName {
+    // A Swift lazy var shows up as two separate children on the reflection tree: one named 'x', and another that is
+    // optional and is named 'x.storage'. Note that '.' is illegal in either a Swift or Objective-C property name.
+    NSString *const storageSuffix = @".storage";
+    if ([propertyName hasSuffix:storageSuffix]) {
+        return [propertyName substringToIndex:propertyName.length - storageSuffix.length];
+    }
+    return nil;
+}
+
++ (NSArray *)propertiesForClass:(Class)objectClass isSwift:(bool)isSwiftClass {
+    Class objectUtil = [objectClass objectUtilClass:isSwiftClass];
+    NSArray *ignoredProperties = [objectUtil ignoredPropertiesForClass:objectClass];
+    NSDictionary *linkingObjectsProperties = [objectUtil linkingObjectsPropertiesForClass:objectClass];
+
+    // For Swift classes we need an instance of the object when parsing properties
+    id swiftObjectInstance = isSwiftClass ? [[objectClass alloc] init] : nil;
+
+    unsigned int count;
+    objc_property_t *props = class_copyPropertyList(objectClass, &count);
+    NSMutableArray *propArray = [NSMutableArray arrayWithCapacity:count];
+    NSSet *indexed = [[NSSet alloc] initWithArray:[objectUtil indexedPropertiesForClass:objectClass]];
+    for (unsigned int i = 0; i < count; i++) {
+        NSString *propertyName = @(property_getName(props[i]));
+        if ([ignoredProperties containsObject:propertyName]) {
+            continue;
+        }
+
+        RLMProperty *prop = nil;
+        if (isSwiftClass) {
+            prop = [[RLMProperty alloc] initSwiftPropertyWithName:propertyName
+                                                          indexed:[indexed containsObject:propertyName]
+                                           linkPropertyDescriptor:linkingObjectsProperties[propertyName]
+                                                         property:props[i]
+                                                         instance:swiftObjectInstance];
+        }
+        else {
+            prop = [[RLMProperty alloc] initWithName:propertyName
+                                             indexed:[indexed containsObject:propertyName]
+                              linkPropertyDescriptor:linkingObjectsProperties[propertyName]
+                                            property:props[i]];
+        }
+
+        if (prop) {
+            [propArray addObject:prop];
+         }
+    }
+    free(props);
+
+    if (isSwiftClass) {
+        // List<> properties don't show up as objective-C properties due to
+        // being generic, so use Swift reflection to get a list of them, and
+        // then access their ivars directly
+        for (NSString *propName in [objectUtil getGenericListPropertyNames:swiftObjectInstance]) {
+            Ivar ivar = class_getInstanceVariable(objectClass, propName.UTF8String);
+            id value = object_getIvar(swiftObjectInstance, ivar);
+            NSString *className = [value _rlmArray].objectClassName;
+            NSUInteger existing = [propArray indexOfObjectPassingTest:^BOOL(RLMProperty *obj, __unused NSUInteger idx, __unused BOOL *stop) {
+                return [obj.name isEqualToString:propName];
+            }];
+            if (existing != NSNotFound) {
+                [propArray removeObjectAtIndex:existing];
+            }
+            [propArray addObject:[[RLMProperty alloc] initSwiftListPropertyWithName:propName
+                                                                               ivar:ivar
+                                                                    objectClassName:className]];
+        }
+
+        // Ditto for LinkingObjects<> properties.
+        NSDictionary *linkingObjectsProperties = [objectUtil getLinkingObjectsProperties:swiftObjectInstance];
+        for (NSString *propName in linkingObjectsProperties) {
+            NSDictionary *info = linkingObjectsProperties[propName];
+            Ivar ivar = class_getInstanceVariable(objectClass, propName.UTF8String);
+
+            NSUInteger existing = [propArray indexOfObjectPassingTest:^BOOL(RLMProperty *obj, __unused NSUInteger idx, __unused BOOL *stop) {
+                return [obj.name isEqualToString:propName];
+            }];
+            if (existing != NSNotFound) {
+                [propArray removeObjectAtIndex:existing];
+            }
+
+            [propArray addObject:[[RLMProperty alloc] initSwiftLinkingObjectsPropertyWithName:propName
+                                                                                         ivar:ivar
+                                                                              objectClassName:info[@"class"]
+                                                                       linkOriginPropertyName:info[@"property"]]];
+        }
+    }
+
+    if (auto optionalProperties = [objectUtil getOptionalProperties:swiftObjectInstance]) {
+        for (RLMProperty *property in propArray) {
+            property.optional = false;
+        }
+        [optionalProperties enumerateKeysAndObjectsUsingBlock:^(NSString *propertyName, NSNumber *propertyType, __unused BOOL *stop) {
+            if ([ignoredProperties containsObject:propertyName]) {
+                return;
+            }
+            NSUInteger existing = [propArray indexOfObjectPassingTest:^BOOL(RLMProperty *obj, __unused NSUInteger idx, __unused BOOL *stop) {
+                return [obj.name isEqualToString:propertyName];
+            }];
+            RLMProperty *property;
+            if (existing != NSNotFound) {
+                property = propArray[existing];
+                property.optional = true;
+            }
+            if (auto type = RLMCoerceToNil(propertyType)) {
+                if (existing == NSNotFound) {
+                    // Check to see if this optional property is an underlying storage property for a Swift lazy var.
+                    // Managed lazy vars are't allowed.
+                    // NOTE: Revisit this once property behaviors are implemented in Swift.
+                    if (NSString *lazyPropertyBaseName = [self baseNameForLazySwiftProperty:propertyName]) {
+                        if ([ignoredProperties containsObject:lazyPropertyBaseName]) {
+                            // This property is the storage property for a ignored lazy Swift property. Just continue.
+                            return;
+                        } else {
+                            @throw RLMException(@"Lazy managed property '%@' is not allowed on a Realm Swift object class. Either add the property to the ignored properties list or make it non-lazy.", lazyPropertyBaseName);
+                        }
+                    }
+                    // The current property isn't a storage property for a lazy Swift property.
+                    property = [[RLMProperty alloc] initSwiftOptionalPropertyWithName:propertyName
+                                                                              indexed:[indexed containsObject:propertyName]
+                                                                                 ivar:class_getInstanceVariable(objectClass, propertyName.UTF8String)
+                                                                         propertyType:RLMPropertyType(type.intValue)];
+                    [propArray addObject:property];
+                }
+                else {
+                    property.type = RLMPropertyType(type.intValue);
+                }
+            }
+        }];
+    }
+    if (auto requiredProperties = [objectUtil requiredPropertiesForClass:objectClass]) {
+        for (RLMProperty *property in propArray) {
+            bool required = [requiredProperties containsObject:property.name];
+            if (required && property.type == RLMPropertyTypeObject) {
+                @throw RLMException(@"Object properties cannot be made required, "
+                                    "but '+[%@ requiredProperties]' included '%@'", objectClass, property.name);
+            }
+            property.optional &= !required;
+        }
+    }
+
+    for (RLMProperty *property in propArray) {
+        if (!property.optional && property.type == RLMPropertyTypeObject) { // remove if/when core supports required link columns
+            @throw RLMException(@"The `%@.%@` property must be marked as being optional.", [objectClass className], property.name);
+        }
+    }
+
+    return propArray;
+}
+
+- (id)copyWithZone:(NSZone *)zone {
+    RLMObjectSchema *schema = [[RLMObjectSchema allocWithZone:zone] init];
+    schema->_objectClass = _objectClass;
+    schema->_className = _className;
+    schema->_objectClass = _objectClass;
+    schema->_accessorClass = _accessorClass;
+    schema->_unmanagedClass = _unmanagedClass;
+    schema->_isSwiftClass = _isSwiftClass;
+
+    // call property setter to reset map and primary key
+    schema.properties = [[NSArray allocWithZone:zone] initWithArray:_properties copyItems:YES];
+    schema.computedProperties = [[NSArray allocWithZone:zone] initWithArray:_computedProperties copyItems:YES];
+
+    // _table not copied as it's realm::Group-specific
+    return schema;
+}
+
+- (instancetype)shallowCopy {
+    RLMObjectSchema *schema = [[RLMObjectSchema alloc] init];
+    schema->_objectClass = _objectClass;
+    schema->_className = _className;
+    schema->_objectClass = _objectClass;
+    schema->_accessorClass = _accessorClass;
+    schema->_unmanagedClass = _unmanagedClass;
+    schema->_isSwiftClass = _isSwiftClass;
+
+    // reuse property array, map, and primary key instnaces
+    schema->_properties = _properties;
+    schema->_computedProperties = _computedProperties;
+    schema->_allPropertiesByName = _allPropertiesByName;
+    schema->_primaryKeyProperty = _primaryKeyProperty;
+    schema->_swiftGenericProperties = _swiftGenericProperties;
+    schema->_propertiesInTableOrder = _propertiesInTableOrder;
+
+    // _table not copied as it's realm::Group-specific
+    return schema;
+}
+
+- (BOOL)isEqualToObjectSchema:(RLMObjectSchema *)objectSchema {
+    if (objectSchema.properties.count != _properties.count) {
+        return NO;
+    }
+
+    if (![_properties isEqualToArray:objectSchema.properties]) {
+        return NO;
+    }
+    if (![_computedProperties isEqualToArray:objectSchema.computedProperties]) {
+        return NO;
+    }
+
+    return YES;
+}
+
+- (NSString *)description {
+    NSMutableString *propertiesString = [NSMutableString string];
+    for (RLMProperty *property in self.properties) {
+        [propertiesString appendFormat:@"\t%@\n", [property.description stringByReplacingOccurrencesOfString:@"\n" withString:@"\n\t"]];
+    }
+    for (RLMProperty *property in self.computedProperties) {
+        [propertiesString appendFormat:@"\t%@\n", [property.description stringByReplacingOccurrencesOfString:@"\n" withString:@"\n\t"]];
+    }
+    return [NSString stringWithFormat:@"%@ {\n%@}", self.className, propertiesString];
+}
+
+- (realm::Table *)table {
+    if (!_table) {
+        _table = ObjectStore::table_for_object_type(_realm.group, _className.UTF8String);
+    }
+    return _table.get();
+}
+
+- (void)setTable:(realm::Table *)table {
+    _table.reset(table);
+}
+
+- (realm::ObjectSchema)objectStoreCopy {
+    ObjectSchema objectSchema;
+    objectSchema.name = _className.UTF8String;
+    objectSchema.primary_key = _primaryKeyProperty ? _primaryKeyProperty.name.UTF8String : "";
+    for (RLMProperty *prop in _properties) {
+        Property p = [prop objectStoreCopy];
+        p.is_primary = (prop == _primaryKeyProperty);
+        objectSchema.persisted_properties.push_back(std::move(p));
+    }
+    for (RLMProperty *prop in _computedProperties) {
+        objectSchema.computed_properties.push_back([prop objectStoreCopy]);
+    }
+    return objectSchema;
+}
+
++ (instancetype)objectSchemaForObjectStoreSchema:(realm::ObjectSchema &)objectSchema {
+    RLMObjectSchema *schema = [RLMObjectSchema new];
+    schema.className = @(objectSchema.name.c_str());
+
+    // create array of RLMProperties
+    NSMutableArray *properties = [NSMutableArray arrayWithCapacity:objectSchema.persisted_properties.size()];
+    for (const Property &prop : objectSchema.persisted_properties) {
+        RLMProperty *property = [RLMProperty propertyForObjectStoreProperty:prop];
+        property.isPrimary = (prop.name == objectSchema.primary_key);
+        [properties addObject:property];
+    }
+    schema.properties = properties;
+
+    NSMutableArray *computedProperties = [NSMutableArray arrayWithCapacity:objectSchema.computed_properties.size()];
+    for (const Property &prop : objectSchema.computed_properties) {
+        [computedProperties addObject:[RLMProperty propertyForObjectStoreProperty:prop]];
+    }
+    schema.computedProperties = computedProperties;
+
+    // get primary key from realm metadata
+    if (objectSchema.primary_key.length()) {
+        NSString *primaryKeyString = [NSString stringWithUTF8String:objectSchema.primary_key.c_str()];
+        schema.primaryKeyProperty = schema[primaryKeyString];
+        if (!schema.primaryKeyProperty) {
+            @throw RLMException(@"No property matching primary key '%@'", primaryKeyString);
+        }
+    }
+
+    // for dynamic schema use vanilla RLMDynamicObject accessor classes
+    schema.objectClass = RLMObject.class;
+    schema.accessorClass = RLMDynamicObject.class;
+    schema.unmanagedClass = RLMObject.class;
+    
+    return schema;
+}
+
+- (RLMProperty *)propertyForTableColumn:(size_t)tableCol {
+    if (_propertiesInTableOrder.empty()) {
+        _propertiesInTableOrder.resize(_properties.count, nil);
+        for (RLMProperty *property in _properties) {
+            auto col = property.column;
+            if (col >= _propertiesInTableOrder.size()) {
+                _propertiesInTableOrder.resize(col + 1, nil);
+            }
+            _propertiesInTableOrder[col] = property;
+        }
+    }
+
+    return tableCol < _propertiesInTableOrder.size() ? _propertiesInTableOrder[tableCol] : nil;
+}
+
+- (NSArray *)swiftGenericProperties {
+    if (_swiftGenericProperties) {
+        return _swiftGenericProperties;
+    }
+
+    // This check isn't semantically required, but avoiding accessing the local
+    // static helps perf in the obj-c case
+    if (!_isSwiftClass) {
+        return _swiftGenericProperties = @[];
+    }
+
+    // Check if it's a swift class using the obj-c API
+    static Class s_swiftObjectClass = NSClassFromString(@"RealmSwiftObject");
+    if (![_accessorClass isSubclassOfClass:s_swiftObjectClass]) {
+        return _swiftGenericProperties = @[];
+    }
+
+    NSMutableArray *genericProperties = [NSMutableArray new];
+    for (RLMProperty *prop in _properties) {
+        if (prop->_swiftIvar || prop->_type == RLMPropertyTypeArray) {
+            [genericProperties addObject:prop];
+        }
+    }
+    // Currently all computed properties are Swift generics
+    [genericProperties addObjectsFromArray:_computedProperties];
+
+    return _swiftGenericProperties = genericProperties;
+}
+
+@end
diff --git a/Pods/Realm/Realm/RLMObjectStore.mm b/Pods/Realm/Realm/RLMObjectStore.mm
new file mode 100644
index 0000000..01cd23a
--- /dev/null
+++ b/Pods/Realm/Realm/RLMObjectStore.mm
@@ -0,0 +1,467 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import "RLMObjectStore.h"
+
+#import "RLMAccessor.h"
+#import "RLMArray_Private.hpp"
+#import "RLMListBase.h"
+#import "RLMObservation.hpp"
+#import "RLMObject_Private.hpp"
+#import "RLMObjectSchema_Private.hpp"
+#import "RLMOptionalBase.h"
+#import "RLMProperty_Private.h"
+#import "RLMQueryUtil.hpp"
+#import "RLMRealm_Private.hpp"
+#import "RLMSchema_Private.h"
+#import "RLMSwiftSupport.h"
+#import "RLMUtil.hpp"
+
+#import "object_store.hpp"
+#import "results.hpp"
+#import "shared_realm.hpp"
+
+#import <objc/message.h>
+
+using namespace realm;
+
+// Schema used to created generated accessors
+static NSMutableArray * const s_accessorSchema = [NSMutableArray new];
+
+void RLMRealmCreateAccessors(RLMSchema *schema) {
+    // create accessors for non-dynamic realms
+    RLMSchema *matchingSchema = nil;
+    for (RLMSchema *accessorSchema in s_accessorSchema) {
+        if ([schema isEqualToSchema:accessorSchema]) {
+            matchingSchema = accessorSchema;
+            break;
+        }
+    }
+
+    if (matchingSchema) {
+        // reuse accessors
+        for (RLMObjectSchema *objectSchema in schema.objectSchema) {
+            objectSchema.accessorClass = matchingSchema[objectSchema.className].accessorClass;
+        }
+    }
+    else {
+        // create accessors and cache in s_accessorSchema
+        for (RLMObjectSchema *objectSchema in schema.objectSchema) {
+            if (objectSchema.table) {
+                NSString *prefix = [NSString stringWithFormat:@"RLMAccessor_v%lu_",
+                                    (unsigned long)s_accessorSchema.count];
+                objectSchema.accessorClass = RLMAccessorClassForObjectClass(objectSchema.objectClass, objectSchema, prefix);
+            }
+        }
+        [s_accessorSchema addObject:schema];
+    }
+}
+
+void RLMClearAccessorCache() {
+    [s_accessorSchema removeAllObjects];
+}
+
+static inline void RLMVerifyRealmRead(__unsafe_unretained RLMRealm *const realm) {
+    if (!realm) {
+        @throw RLMException(@"Realm must not be nil");
+    }
+    [realm verifyThread];
+}
+
+static inline void RLMVerifyInWriteTransaction(__unsafe_unretained RLMRealm *const realm) {
+    RLMVerifyRealmRead(realm);
+    // if realm is not writable throw
+    if (!realm.inWriteTransaction) {
+        @throw RLMException(@"Can only add, remove, or create objects in a Realm in a write transaction - call beginWriteTransaction on an RLMRealm instance first.");
+    }
+}
+
+void RLMInitializeSwiftAccessorGenerics(__unsafe_unretained RLMObjectBase *const object) {
+    if (!object || !object->_row || !object->_objectSchema->_isSwiftClass) {
+        return;
+    }
+
+    for (RLMProperty *prop in object->_objectSchema.swiftGenericProperties) {
+        if (prop->_type == RLMPropertyTypeArray) {
+            RLMArray *array = [RLMArrayLinkView arrayWithObjectClassName:prop.objectClassName
+                                                                    view:object->_row.get_linklist(prop.column)
+                                                                   realm:object->_realm
+                                                                     key:prop.name
+                                                            parentSchema:object->_objectSchema];
+            [RLMObjectUtilClass(YES) initializeListProperty:object property:prop array:array];
+        }
+        else if (prop.type == RLMPropertyTypeLinkingObjects) {
+            [RLMObjectUtilClass(YES) initializeLinkingObjectsProperty:object property:prop];
+        }
+        else {
+            [RLMObjectUtilClass(YES) initializeOptionalProperty:object property:prop];
+        }
+    }
+}
+
+template<typename F>
+static inline NSUInteger RLMCreateOrGetRowForObject(__unsafe_unretained RLMObjectSchema *const schema, F primaryValueGetter, bool createOrUpdate, bool &created) {
+    // try to get existing row if updating
+    size_t rowIndex = realm::not_found;
+    realm::Table &table = *schema.table;
+    RLMProperty *primaryProperty = schema.primaryKeyProperty;
+    if (createOrUpdate && primaryProperty) {
+        // get primary value
+        id primaryValue = primaryValueGetter(primaryProperty);
+        if (primaryValue == NSNull.null) {
+            primaryValue = nil;
+        }
+        
+        // search for existing object based on primary key type
+        if (primaryProperty.type == RLMPropertyTypeString) {
+            rowIndex = table.find_first_string(primaryProperty.column, RLMStringDataWithNSString(primaryValue));
+        }
+        else {
+            rowIndex = table.find_first_int(primaryProperty.column, [primaryValue longLongValue]);
+        }
+    }
+
+    // if no existing, create row
+    created = NO;
+    if (rowIndex == realm::not_found) {
+        try {
+            rowIndex = table.add_empty_row();
+        }
+        catch (std::exception const& e) {
+            @throw RLMException(e);
+        }
+        created = YES;
+    }
+
+    // get accessor
+    return rowIndex;
+}
+
+void RLMAddObjectToRealm(__unsafe_unretained RLMObjectBase *const object,
+                         __unsafe_unretained RLMRealm *const realm, 
+                         bool createOrUpdate) {
+    RLMVerifyInWriteTransaction(realm);
+
+    // verify that object is unmanaged
+    if (object.invalidated) {
+        @throw RLMException(@"Adding a deleted or invalidated object to a Realm is not permitted");
+    }
+    if (object->_realm) {
+        if (object->_realm == realm) {
+            // no-op
+            return;
+        }
+        // for differing realms users must explicitly create the object in the second realm
+        @throw RLMException(@"Object is already managed by another Realm");
+    }
+    if (object->_observationInfo && object->_observationInfo->hasObservers()) {
+        @throw RLMException(@"Cannot add an object with observers to a Realm");
+    }
+
+    // set the realm and schema
+    NSString *objectClassName = object->_objectSchema.className;
+    RLMObjectSchema *schema = [realm.schema schemaForClassName:objectClassName];
+    if (!schema) {
+        @throw RLMException(@"Object type '%@' is not managed by the Realm. "
+                            @"If using a custom `objectClasses` / `objectTypes` array in your configuration, "
+                            @"add `%@` to the list of `objectClasses` / `objectTypes`.",
+                            objectClassName, objectClassName);
+    }
+    object->_objectSchema = schema;
+    object->_realm = realm;
+
+    // get or create row
+    bool created;
+    auto primaryGetter = [=](__unsafe_unretained RLMProperty *const p) { return [object valueForKey:p.name]; };
+    object->_row = (*schema.table)[RLMCreateOrGetRowForObject(schema, primaryGetter, createOrUpdate, created)];
+
+    RLMCreationOptions creationOptions = RLMCreationOptionsPromoteUnmanaged;
+    if (createOrUpdate) {
+        creationOptions |= RLMCreationOptionsCreateOrUpdate;
+    }
+
+    // populate all properties
+    for (RLMProperty *prop in schema.properties) {
+        // get object from ivar using key value coding
+        id value = nil;
+        if (prop.swiftIvar) {
+            if (prop.type == RLMPropertyTypeArray) {
+                value = static_cast<RLMListBase *>(object_getIvar(object, prop.swiftIvar))._rlmArray;
+            }
+            else { // optional
+                value = static_cast<RLMOptionalBase *>(object_getIvar(object, prop.swiftIvar)).underlyingValue;
+            }
+        }
+        else if ([object respondsToSelector:prop.getterSel]) {
+            value = [object valueForKey:prop.getterName];
+        }
+
+        if (!value && !prop.optional) {
+            @throw RLMException(@"No value or default value specified for property '%@' in '%@'",
+                                prop.name, schema.className);
+        }
+
+        // set in table with out validation
+        // skip primary key when updating since it doesn't change
+        if (created || !prop.isPrimary) {
+            RLMDynamicSet(object, prop, RLMCoerceToNil(value), creationOptions);
+        }
+
+        // set the ivars for object and array properties to nil as otherwise the
+        // accessors retain objects that are no longer accessible via the properties
+        // this is mainly an issue when the object graph being added has cycles,
+        // as it's not obvious that the user has to set the *ivars* to nil to
+        // avoid leaking memory
+        if (prop.type == RLMPropertyTypeObject || prop.type == RLMPropertyTypeArray) {
+            if (!prop.swiftIvar) {
+                ((void(*)(id, SEL, id))objc_msgSend)(object, prop.setterSel, nil);
+            }
+        }
+    }
+
+    // set to proper accessor class
+    object_setClass(object, schema.accessorClass);
+
+    RLMInitializeSwiftAccessorGenerics(object);
+}
+
+static void RLMValidateValueForProperty(__unsafe_unretained id const obj,
+                                        __unsafe_unretained RLMProperty *const prop) {
+    switch (prop.type) {
+        case RLMPropertyTypeString:
+        case RLMPropertyTypeBool:
+        case RLMPropertyTypeDate:
+        case RLMPropertyTypeInt:
+        case RLMPropertyTypeFloat:
+        case RLMPropertyTypeDouble:
+        case RLMPropertyTypeData:
+            if (!RLMIsObjectValidForProperty(obj, prop)) {
+                @throw RLMException(@"Invalid value '%@' for property '%@'", obj, prop.name);
+            }
+            break;
+        case RLMPropertyTypeObject:
+            break;
+        case RLMPropertyTypeArray: {
+            if (obj != nil && obj != NSNull.null) {
+                if (![obj conformsToProtocol:@protocol(NSFastEnumeration)]) {
+                    @throw RLMException(@"Array property value (%@) is not enumerable.", obj);
+                }
+            }
+            break;
+        }
+        case RLMPropertyTypeAny:
+        case RLMPropertyTypeLinkingObjects:
+            @throw RLMException(@"Invalid value '%@' for property '%@'", obj, prop.name);
+    }
+}
+
+RLMObjectBase *RLMCreateObjectInRealmWithValue(RLMRealm *realm, NSString *className, id value, bool createOrUpdate = false) {
+    if (createOrUpdate && RLMIsObjectSubclass([value class])) {
+        RLMObjectBase *obj = value;
+        if ([obj->_objectSchema.className isEqualToString:className] && obj->_realm == realm) {
+            // This is a no-op if value is an RLMObject of the same type already backed by the target realm.
+            return value;
+        }
+    }
+
+    // verify writable
+    RLMVerifyInWriteTransaction(realm);
+
+    // create the object
+    RLMObjectSchema *objectSchema = [realm.schema schemaForClassName:className];
+    if (!objectSchema) {
+        @throw RLMException(@"Object type '%@' is not managed by the Realm. "
+                             @"If using a custom `objectClasses` / `objectTypes` array in your configuration, "
+                             @"add `%@` to the list of `objectClasses` / `objectTypes`.",
+                             className, className);
+    }
+    RLMObjectBase *object = [[objectSchema.accessorClass alloc] initWithRealm:realm schema:objectSchema];
+
+    RLMCreationOptions creationOptions = createOrUpdate ? RLMCreationOptionsCreateOrUpdate : RLMCreationOptionsNone;
+
+    // create row, and populate
+    if (NSArray *array = RLMDynamicCast<NSArray>(value)) {
+        // get or create our accessor
+        bool created;
+        NSArray *props = objectSchema.properties;
+        auto primaryGetter = [=](__unsafe_unretained RLMProperty *const p) {
+            return array[[props indexOfObject:p]];
+        };
+        object->_row = (*objectSchema.table)[RLMCreateOrGetRowForObject(objectSchema, primaryGetter, createOrUpdate, created)];
+
+        // populate
+        for (NSUInteger i = 0; i < array.count; i++) {
+            RLMProperty *prop = props[i];
+            // skip primary key when updating since it doesn't change
+            if (created || !prop.isPrimary) {
+                id val = array[i];
+                RLMValidateValueForProperty(val, prop);
+                RLMDynamicSet(object, prop, RLMCoerceToNil(val), creationOptions);
+            }
+        }
+    }
+    else {
+        // get or create our accessor
+        bool created;
+        auto primaryGetter = [=](RLMProperty *p) { return [value valueForKey:p.name]; };
+        object->_row = (*objectSchema.table)[RLMCreateOrGetRowForObject(objectSchema, primaryGetter, createOrUpdate, created)];
+
+        // populate
+        NSDictionary *defaultValues = nil;
+        for (RLMProperty *prop in objectSchema.properties) {
+            id propValue = RLMValidatedValueForProperty(value, prop.name, objectSchema.className);
+
+            if (!propValue && created) {
+                if (!defaultValues) {
+                    defaultValues = RLMDefaultValuesForObjectSchema(objectSchema);
+                }
+                propValue = defaultValues[prop.name];
+                if (!propValue && (prop.type == RLMPropertyTypeObject || prop.type == RLMPropertyTypeArray)) {
+                    propValue = NSNull.null;
+                }
+            }
+
+            if (propValue) {
+                if (created || !prop.isPrimary) {
+                    // skip missing properties and primary key when updating since it doesn't change
+                    RLMValidateValueForProperty(propValue, prop);
+                    RLMDynamicSet(object, prop, RLMCoerceToNil(propValue), creationOptions);
+                }
+            }
+            else if (created && !prop.optional) {
+                @throw RLMException(@"Property '%@' of object of type '%@' cannot be nil.", prop.name, objectSchema.className);
+            }
+        }
+    }
+
+    RLMInitializeSwiftAccessorGenerics(object);
+    return object;
+}
+
+void RLMDeleteObjectFromRealm(__unsafe_unretained RLMObjectBase *const object,
+                              __unsafe_unretained RLMRealm *const realm) {
+    if (realm != object->_realm) {
+        @throw RLMException(@"Can only delete an object from the Realm it belongs to.");
+    }
+
+    RLMVerifyInWriteTransaction(object->_realm);
+
+    // move last row to row we are deleting
+    if (object->_row.is_attached()) {
+        RLMTrackDeletions(realm, ^{
+            object->_row.get_table()->move_last_over(object->_row.get_index());
+        });
+    }
+
+    // set realm to nil
+    object->_realm = nil;
+}
+
+void RLMDeleteAllObjectsFromRealm(RLMRealm *realm) {
+    RLMVerifyInWriteTransaction(realm);
+
+    // clear table for each object schema
+    for (RLMObjectSchema *objectSchema in realm.schema.objectSchema) {
+        RLMClearTable(objectSchema);
+    }
+}
+
+RLMResults *RLMGetObjects(RLMRealm *realm, NSString *objectClassName, NSPredicate *predicate) {
+    RLMVerifyRealmRead(realm);
+
+    // create view from table and predicate
+    RLMObjectSchema *objectSchema = realm.schema[objectClassName];
+    if (!objectSchema.table) {
+        // read-only realms may be missing tables since we can't add any
+        // missing ones on init
+        return [RLMResults resultsWithObjectSchema:objectSchema results:{}];
+    }
+
+    if (predicate) {
+        realm::Query query = RLMPredicateToQuery(predicate, objectSchema, realm.schema, *realm.group);
+        return [RLMResults resultsWithObjectSchema:objectSchema
+                                           results:realm::Results(realm->_realm, std::move(query))];
+    }
+
+    return [RLMResults resultsWithObjectSchema:objectSchema
+                                       results:realm::Results(realm->_realm, *objectSchema.table)];
+}
+
+id RLMGetObject(RLMRealm *realm, NSString *objectClassName, id key) {
+    RLMVerifyRealmRead(realm);
+
+    RLMObjectSchema *objectSchema = realm.schema[objectClassName];
+
+    RLMProperty *primaryProperty = objectSchema.primaryKeyProperty;
+    if (!primaryProperty) {
+        @throw RLMException(@"%@ does not have a primary key", objectClassName);
+    }
+
+    if (!objectSchema.table) {
+        // read-only realms may be missing tables since we can't add any
+        // missing ones on init
+        return nil;
+    }
+
+    key = RLMCoerceToNil(key);
+
+    size_t row = realm::not_found;
+    if (primaryProperty.type == RLMPropertyTypeString) {
+        NSString *str = RLMDynamicCast<NSString>(key);
+        if (str || (!key && primaryProperty.optional)) {
+            row = objectSchema.table->find_first_string(primaryProperty.column, RLMStringDataWithNSString(str));
+        }
+        else {
+            @throw RLMException(@"Invalid value '%@' for primary key", key);
+        }
+    }
+    else {
+        NSNumber *number = RLMDynamicCast<NSNumber>(key);
+        if (number) {
+            row = objectSchema.table->find_first_int(primaryProperty.column, number.longLongValue);
+        }
+        else if (!key && primaryProperty.optional) {
+            row = objectSchema.table->find_first_null(primaryProperty.column);
+        }
+        else {
+            @throw RLMException(@"Invalid value '%@' for primary key", key);
+        }
+    }
+
+    if (row == realm::not_found) {
+        return nil;
+    }
+
+    return RLMCreateObjectAccessor(realm, objectSchema, row);
+}
+
+RLMObjectBase *RLMCreateObjectAccessor(__unsafe_unretained RLMRealm *const realm,
+                                       __unsafe_unretained RLMObjectSchema *const objectSchema,
+                                       NSUInteger index) {
+    return RLMCreateObjectAccessor(realm, objectSchema, (*objectSchema.table)[index]);
+}
+
+// Create accessor and register with realm
+RLMObjectBase *RLMCreateObjectAccessor(__unsafe_unretained RLMRealm *const realm,
+                                       __unsafe_unretained RLMObjectSchema *const objectSchema,
+                                       realm::RowExpr row) {
+    RLMObjectBase *accessor = [[objectSchema.accessorClass alloc] initWithRealm:realm schema:objectSchema];
+    accessor->_row = row;
+    RLMInitializeSwiftAccessorGenerics(accessor);
+    return accessor;
+}
diff --git a/Pods/Realm/Realm/RLMObservation.mm b/Pods/Realm/Realm/RLMObservation.mm
new file mode 100644
index 0000000..839946b
--- /dev/null
+++ b/Pods/Realm/Realm/RLMObservation.mm
@@ -0,0 +1,494 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2015 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import "RLMObservation.hpp"
+
+#import "RLMAccessor.h"
+#import "RLMArray_Private.hpp"
+#import "RLMListBase.h"
+#import "RLMObjectSchema_Private.hpp"
+#import "RLMProperty_Private.h"
+#import "RLMRealm_Private.hpp"
+#import "RLMSchema.h"
+
+#import <realm/lang_bind_helper.hpp>
+
+using namespace realm;
+
+namespace {
+    template<typename Iterator>
+    struct IteratorPair {
+        Iterator first;
+        Iterator second;
+    };
+    template<typename Iterator>
+    Iterator begin(IteratorPair<Iterator> const& p) {
+        return p.first;
+    }
+    template<typename Iterator>
+    Iterator end(IteratorPair<Iterator> const& p) {
+        return p.second;
+    }
+
+    template<typename Container>
+    auto reverse(Container const& c) {
+        return IteratorPair<typename Container::const_reverse_iterator>{c.rbegin(), c.rend()};
+    }
+}
+
+RLMObservationInfo::RLMObservationInfo(RLMObjectSchema *objectSchema, std::size_t row, id object)
+: object(object)
+, objectSchema(objectSchema)
+{
+    REALM_ASSERT_DEBUG(objectSchema);
+    setRow(*objectSchema.table, row);
+}
+
+RLMObservationInfo::RLMObservationInfo(id object)
+: object(object)
+{
+}
+
+RLMObservationInfo::~RLMObservationInfo() {
+    if (prev) {
+        // Not the head of the linked list, so just detach from the list
+        REALM_ASSERT_DEBUG(prev->next == this);
+        prev->next = next;
+        if (next) {
+            REALM_ASSERT_DEBUG(next->prev == this);
+            next->prev = prev;
+        }
+    }
+    else if (objectSchema) {
+        // The head of the list, so remove self from the object schema's array
+        // of observation info, either replacing self with the next info or
+        // removing entirely if there is no next
+        auto end = objectSchema->_observedObjects.end();
+        auto it = find(objectSchema->_observedObjects.begin(), end, this);
+        if (it != end) {
+            if (next) {
+                *it = next;
+                next->prev = nullptr;
+            }
+            else {
+                iter_swap(it, std::prev(end));
+                objectSchema->_observedObjects.pop_back();
+            }
+        }
+    }
+    // Otherwise the observed object was unmanaged, so nothing to do
+
+#ifdef DEBUG
+    // ensure that incorrect cleanup fails noisily
+    object = (__bridge id)(void *)-1;
+    prev = (RLMObservationInfo *)-1;
+    next = (RLMObservationInfo *)-1;
+#endif
+}
+
+void RLMObservationInfo::willChange(NSString *key, NSKeyValueChange kind, NSIndexSet *indexes) const {
+    if (indexes) {
+        forEach([=](__unsafe_unretained auto o) {
+            [o willChange:kind valuesAtIndexes:indexes forKey:key];
+        });
+    }
+    else {
+        forEach([=](__unsafe_unretained auto o) {
+            [o willChangeValueForKey:key];
+        });
+    }
+}
+
+void RLMObservationInfo::didChange(NSString *key, NSKeyValueChange kind, NSIndexSet *indexes) const {
+    if (indexes) {
+        forEach([=](__unsafe_unretained auto o) {
+            [o didChange:kind valuesAtIndexes:indexes forKey:key];
+        });
+    }
+    else {
+        forEach([=](__unsafe_unretained auto o) {
+            [o didChangeValueForKey:key];
+        });
+    }
+}
+
+void RLMObservationInfo::prepareForInvalidation() {
+    REALM_ASSERT_DEBUG(objectSchema);
+    REALM_ASSERT_DEBUG(!prev);
+    for (auto info = this; info; info = info->next)
+        info->invalidated = true;
+}
+
+void RLMObservationInfo::setRow(realm::Table &table, size_t newRow) {
+    REALM_ASSERT_DEBUG(!row);
+    REALM_ASSERT_DEBUG(objectSchema);
+    row = table[newRow];
+    for (auto info : objectSchema->_observedObjects) {
+        if (info->row && info->row.get_index() == row.get_index()) {
+            prev = info;
+            next = info->next;
+            if (next)
+                next->prev = this;
+            info->next = this;
+            return;
+        }
+    }
+    objectSchema->_observedObjects.push_back(this);
+}
+
+void RLMObservationInfo::recordObserver(realm::Row& objectRow,
+                                        __unsafe_unretained RLMObjectSchema *const objectSchema,
+                                        __unsafe_unretained NSString *const keyPath) {
+    ++observerCount;
+
+    // add ourselves to the list of observed objects if this is the first time
+    // an observer is being added to a managed object
+    if (objectRow && !row) {
+        this->objectSchema = objectSchema;
+        setRow(*objectRow.get_table(), objectRow.get_index());
+    }
+
+    if (!row) {
+        // Arrays need a reference to their containing object to avoid having to
+        // go through the awful proxy object from mutableArrayValueForKey.
+        // For managed objects we do this when the object is added or created
+        // (and have to to support notifications from modifying an object which
+        // was never observed), but for Swift classes (both RealmSwift and
+        // RLMObject) we can't do it then because we don't know what the parent
+        // object is.
+
+        NSUInteger sep = [keyPath rangeOfString:@"."].location;
+        NSString *key = sep == NSNotFound ? keyPath : [keyPath substringToIndex:sep];
+        RLMProperty *prop = objectSchema[key];
+        if (prop && prop.type == RLMPropertyTypeArray) {
+            id value = valueForKey(key);
+            RLMArray *array = [value isKindOfClass:[RLMListBase class]] ? [value _rlmArray] : value;
+            array->_key = key;
+            array->_parentObject = object;
+        }
+        else if (auto swiftIvar = prop.swiftIvar) {
+            if (auto optional = RLMDynamicCast<RLMOptionalBase>(object_getIvar(object, swiftIvar))) {
+                optional.property = prop;
+                optional.object = object;
+            }
+        }
+    }
+}
+
+void RLMObservationInfo::removeObserver() {
+    --observerCount;
+}
+
+id RLMObservationInfo::valueForKey(NSString *key) {
+    if (invalidated) {
+        if ([key isEqualToString:RLMInvalidatedKey]) {
+            return @YES;
+        }
+        return cachedObjects[key];
+    }
+
+    if (key != lastKey) {
+        lastKey = key;
+        lastProp = objectSchema[key];
+    }
+
+    static auto superValueForKey = reinterpret_cast<id(*)(id, SEL, NSString *)>([NSObject methodForSelector:@selector(valueForKey:)]);
+    if (!lastProp) {
+        return RLMCoerceToNil(superValueForKey(object, @selector(valueForKey:), key));
+    }
+
+    auto getSuper = [&] {
+        return row ? RLMDynamicGet(object, lastProp) : RLMCoerceToNil(superValueForKey(object, @selector(valueForKey:), key));
+    };
+
+    // We need to return the same object each time for observing over keypaths to work
+    if (lastProp.type == RLMPropertyTypeArray) {
+        RLMArray *value = cachedObjects[key];
+        if (!value) {
+            value = getSuper();
+            if (!cachedObjects) {
+                cachedObjects = [NSMutableDictionary new];
+            }
+            cachedObjects[key] = value;
+        }
+        return value;
+    }
+
+    if (lastProp.type == RLMPropertyTypeObject) {
+        if (row.is_null_link(lastProp.column)) {
+            [cachedObjects removeObjectForKey:key];
+            return nil;
+        }
+
+        RLMObjectBase *value = cachedObjects[key];
+        if (value && value->_row.get_index() == row.get_link(lastProp.column)) {
+            return value;
+        }
+        value = getSuper();
+        if (!cachedObjects) {
+            cachedObjects = [NSMutableDictionary new];
+        }
+        cachedObjects[key] = value;
+        return value;
+    }
+
+    return getSuper();
+}
+
+RLMObservationInfo *RLMGetObservationInfo(RLMObservationInfo *info,
+                                          size_t row,
+                                          __unsafe_unretained RLMObjectSchema *objectSchema) {
+    if (info) {
+        return info;
+    }
+
+    for (RLMObservationInfo *info : objectSchema->_observedObjects) {
+        if (info->isForRow(row)) {
+            return info;
+        }
+    }
+
+    return nullptr;
+}
+
+void RLMClearTable(RLMObjectSchema *objectSchema) {
+    for (auto info : objectSchema->_observedObjects) {
+        info->willChange(RLMInvalidatedKey);
+    }
+
+    RLMTrackDeletions(objectSchema.realm, ^{
+        objectSchema.table->clear();
+
+        for (auto info : objectSchema->_observedObjects) {
+            info->prepareForInvalidation();
+        }
+    });
+
+    for (auto info : reverse(objectSchema->_observedObjects)) {
+        info->didChange(RLMInvalidatedKey);
+    }
+
+    objectSchema->_observedObjects.clear();
+}
+
+void RLMTrackDeletions(__unsafe_unretained RLMRealm *const realm, dispatch_block_t block) {
+    std::vector<std::vector<RLMObservationInfo *> *> observers;
+
+    // Build up an array of observation info arrays which is indexed by table
+    // index (the object schemata may be in an entirely different order)
+    for (RLMObjectSchema *objectSchema in realm.schema.objectSchema) {
+        if (objectSchema->_observedObjects.empty()) {
+            continue;
+        }
+        size_t ndx = objectSchema.table->get_index_in_group();
+        if (ndx >= observers.size()) {
+            observers.resize(std::max(observers.size() * 2, ndx + 1));
+        }
+        observers[ndx] = &objectSchema->_observedObjects;
+    }
+
+    // No need for change tracking if no objects are observed
+    if (observers.empty()) {
+        block();
+        return;
+    }
+
+    struct change {
+        RLMObservationInfo *info;
+        __unsafe_unretained NSString *property;
+        NSMutableIndexSet *indexes;
+    };
+
+    std::vector<change> changes;
+    std::vector<RLMObservationInfo *> invalidated;
+
+    // This callback is called by core with a list of row deletions and
+    // resulting link nullifications immediately before things are deleted and nullified
+    realm.group->set_cascade_notification_handler([&](realm::Group::CascadeNotification const& cs) {
+        for (auto const& link : cs.links) {
+            size_t table_ndx = link.origin_table->get_index_in_group();
+            if (table_ndx >= observers.size() || !observers[table_ndx]) {
+                // The modified table has no observers
+                continue;
+            }
+
+            for (auto observer : *observers[table_ndx]) {
+                if (!observer->isForRow(link.origin_row_ndx)) {
+                    continue;
+                }
+
+                RLMProperty *prop = [observer->getObjectSchema() propertyForTableColumn:link.origin_col_ndx];
+                NSString *name = prop.name;
+                if (prop.type != RLMPropertyTypeArray) {
+                    changes.push_back({observer, name});
+                    continue;
+                }
+
+                auto c = find_if(begin(changes), end(changes), [&](auto const& c) {
+                    return c.info == observer && c.property == name;
+                });
+                if (c == end(changes)) {
+                    changes.push_back({observer, name, [NSMutableIndexSet new]});
+                    c = prev(end(changes));
+                }
+
+                // We know what row index is being removed from the LinkView,
+                // but what we actually want is the indexes in the LinkView that
+                // are going away
+                auto linkview = observer->getRow().get_linklist(prop.column);
+                size_t start = 0, index;
+                while ((index = linkview->find(link.old_target_row_ndx, start)) != realm::not_found) {
+                    [c->indexes addIndex:index];
+                    start = index + 1;
+                }
+            }
+        }
+
+        for (auto const& row : cs.rows) {
+            if (row.table_ndx >= observers.size() || !observers[row.table_ndx]) {
+                // The modified table has no observers
+                continue;
+            }
+
+            for (auto observer : *observers[row.table_ndx]) {
+                if (observer->isForRow(row.row_ndx)) {
+                    invalidated.push_back(observer);
+                    break;
+                }
+            }
+        }
+
+        // The relative order of these loops is very important
+        for (auto info : invalidated) {
+            info->willChange(RLMInvalidatedKey);
+        }
+        for (auto const& change : changes) {
+            change.info->willChange(change.property, NSKeyValueChangeRemoval, change.indexes);
+        }
+        for (auto info : invalidated) {
+            info->prepareForInvalidation();
+        }
+    });
+
+    try {
+        block();
+    }
+    catch (...) {
+        realm.group->set_cascade_notification_handler(nullptr);
+        throw;
+    }
+
+    for (auto const& change : reverse(changes)) {
+        change.info->didChange(change.property, NSKeyValueChangeRemoval, change.indexes);
+    }
+    for (auto info : reverse(invalidated)) {
+        info->didChange(RLMInvalidatedKey);
+    }
+
+    realm.group->set_cascade_notification_handler(nullptr);
+}
+
+namespace {
+template<typename Func>
+void forEach(realm::BindingContext::ObserverState const& state, Func&& func) {
+    for (size_t i = 0, size = state.changes.size(); i < size; ++i) {
+        if (state.changes[i].changed) {
+            func(i, state.changes[i], static_cast<RLMObservationInfo *>(state.info));
+        }
+    }
+}
+}
+
+std::vector<realm::BindingContext::ObserverState> RLMGetObservedRows(NSArray<RLMObjectSchema *> *schema) {
+    std::vector<realm::BindingContext::ObserverState> observers;
+    for (RLMObjectSchema *objectSchema in schema) {
+        for (auto info : objectSchema->_observedObjects) {
+            auto const& row = info->getRow();
+            if (!row.is_attached())
+                continue;
+            observers.push_back({
+                row.get_table()->get_index_in_group(),
+                row.get_index(),
+                info});
+        }
+    }
+    sort(begin(observers), end(observers));
+    return observers;
+}
+
+static NSKeyValueChange convert(realm::BindingContext::ColumnInfo::Kind kind) {
+    switch (kind) {
+        case realm::BindingContext::ColumnInfo::Kind::None:
+        case realm::BindingContext::ColumnInfo::Kind::SetAll:
+            return NSKeyValueChangeSetting;
+        case realm::BindingContext::ColumnInfo::Kind::Set:
+            return NSKeyValueChangeReplacement;
+        case realm::BindingContext::ColumnInfo::Kind::Insert:
+            return NSKeyValueChangeInsertion;
+        case realm::BindingContext::ColumnInfo::Kind::Remove:
+            return NSKeyValueChangeRemoval;
+    }
+}
+
+static NSIndexSet *convert(realm::IndexSet const& in, NSMutableIndexSet *out) {
+    if (in.empty()) {
+        return nil;
+    }
+
+    [out removeAllIndexes];
+    for (auto range : in) {
+        [out addIndexesInRange:{range.first, range.second - range.first}];
+    }
+    return out;
+}
+
+void RLMWillChange(std::vector<realm::BindingContext::ObserverState> const& observed,
+                   std::vector<void *> const& invalidated) {
+    for (auto info : invalidated) {
+        static_cast<RLMObservationInfo *>(info)->willChange(RLMInvalidatedKey);
+    }
+    if (!observed.empty()) {
+        NSMutableIndexSet *indexes = [NSMutableIndexSet new];
+        for (auto const& o : observed) {
+            forEach(o, [&](size_t i, auto const& change, RLMObservationInfo *info) {
+                auto property = [info->getObjectSchema() propertyForTableColumn:i];
+                info->willChange(property.name, convert(change.kind), convert(change.indices, indexes));
+            });
+        }
+    }
+    for (auto info : invalidated) {
+        static_cast<RLMObservationInfo *>(info)->prepareForInvalidation();
+    }
+}
+
+void RLMDidChange(std::vector<realm::BindingContext::ObserverState> const& observed,
+                  std::vector<void *> const& invalidated) {
+    if (!observed.empty()) {
+        // Loop in reverse order to avoid O(N^2) behavior in Foundation
+        NSMutableIndexSet *indexes = [NSMutableIndexSet new];
+        for (auto const& o : reverse(observed)) {
+            forEach(o, [&](size_t i, auto const& change, RLMObservationInfo *info) {
+                auto property = [info->getObjectSchema() propertyForTableColumn:i];
+                info->didChange(property.name, convert(change.kind), convert(change.indices, indexes));
+            });
+        }
+    }
+    for (auto const& info : reverse(invalidated)) {
+        static_cast<RLMObservationInfo *>(info)->didChange(RLMInvalidatedKey);
+    }
+}
diff --git a/Pods/Realm/Realm/RLMOptionalBase.mm b/Pods/Realm/Realm/RLMOptionalBase.mm
new file mode 100644
index 0000000..e6d641a
--- /dev/null
+++ b/Pods/Realm/Realm/RLMOptionalBase.mm
@@ -0,0 +1,86 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2015 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import "RLMAccessor.h"
+#import "RLMOptionalBase.h"
+#import "RLMObject_Private.h"
+#import "RLMObjectStore.h"
+#import "RLMProperty.h"
+#import "RLMUtil.hpp"
+
+#import <objc/runtime.h>
+
+@interface RLMOptionalBase ()
+@property (nonatomic) id unmanagedValue;
+@end
+
+@implementation RLMOptionalBase
+
+- (instancetype)init {
+    return self;
+}
+
+- (id)underlyingValue {
+    if ((_object && _object->_realm) || _object.isInvalidated) {
+        return RLMDynamicGet(_object, _property);
+    }
+    else {
+        return _unmanagedValue;
+    }
+}
+
+- (void)setUnderlyingValue:(id)underlyingValue {
+    if ((_object && _object->_realm) || _object.isInvalidated) {
+        RLMDynamicSet(_object, _property, underlyingValue, RLMCreationOptionsNone);
+    }
+    else {
+        NSString *propertyName = _property.name;
+        [_object willChangeValueForKey:propertyName];
+        _unmanagedValue = underlyingValue;
+        [_object didChangeValueForKey:propertyName];
+    }
+}
+
+- (BOOL)isKindOfClass:(Class)aClass {
+    return [self.underlyingValue isKindOfClass:aClass] || RLMIsKindOfClass(object_getClass(self), aClass);
+}
+
+- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel {
+    return [self.underlyingValue methodSignatureForSelector:sel];
+}
+
+- (void)forwardInvocation:(NSInvocation *)invocation {
+    [invocation invokeWithTarget:self.underlyingValue];
+}
+
+- (id)forwardingTargetForSelector:(__unused SEL)sel {
+    return self.underlyingValue;
+}
+
+- (BOOL)respondsToSelector:(SEL)aSelector {
+    if (id val = self.underlyingValue) {
+        return [val respondsToSelector:aSelector];
+    }
+    return NO;
+}
+
+- (void)doesNotRecognizeSelector:(SEL)aSelector {
+    [self.underlyingValue doesNotRecognizeSelector:aSelector];
+}
+
+@end
diff --git a/Pods/Realm/Realm/RLMPredicateUtil.mm b/Pods/Realm/Realm/RLMPredicateUtil.mm
new file mode 100644
index 0000000..d2f722b
--- /dev/null
+++ b/Pods/Realm/Realm/RLMPredicateUtil.mm
@@ -0,0 +1,118 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2015 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+
+#import "RLMPredicateUtil.hpp"
+
+// NSConditionalExpressionType is new in OS X 10.11 and iOS 9.0
+#if defined(__MAC_OS_X_VERSION_MIN_REQUIRED)
+#define CONDITIONAL_EXPRESSION_DECLARED (__MAC_OS_X_VERSION_MIN_REQUIRED >= 101100)
+#elif defined(__IPHONE_OS_VERSION_MIN_REQUIRED)
+#define CONDITIONAL_EXPRESSION_DECLARED (__IPHONE_OS_VERSION_MIN_REQUIRED >= 90000)
+#else
+#define CONDITIONAL_EXPRESSION_DECLARED 0
+#endif
+
+#if !CONDITIONAL_EXPRESSION_DECLARED
+
+#define NSConditionalExpressionType 20
+
+@interface NSExpression (NewIn1011And90)
++ (NSExpression *)expressionForConditional:(NSPredicate *)predicate trueExpression:(NSExpression *)trueExpression falseExpression:(NSExpression *)falseExpression;
+- (NSExpression *)trueExpression;
+- (NSExpression *)falseExpression;
+@end
+
+#endif
+
+namespace {
+
+struct PredicateExpressionTransformer {
+    PredicateExpressionTransformer(ExpressionVisitor visitor) : m_visitor(visitor) { }
+
+    NSExpression *visit(NSExpression *expression) const;
+    NSPredicate *visit(NSPredicate *predicate) const;
+
+    ExpressionVisitor m_visitor;
+};
+
+NSExpression *PredicateExpressionTransformer::visit(NSExpression *expression) const {
+    expression = m_visitor(expression);
+
+    switch (expression.expressionType) {
+        case NSFunctionExpressionType: {
+            NSMutableArray *arguments = [NSMutableArray array];
+            for (NSExpression *argument in expression.arguments) {
+                [arguments addObject:visit(argument)];
+            }
+            if (expression.operand) {
+                return [NSExpression expressionForFunction:visit(expression.operand) selectorName:expression.function arguments:arguments];
+            } else {
+                return [NSExpression expressionForFunction:expression.function arguments:arguments];
+            }
+        }
+
+        case NSUnionSetExpressionType:
+            return [NSExpression expressionForUnionSet:visit(expression.leftExpression) with:visit(expression.rightExpression)];
+        case NSIntersectSetExpressionType:
+            return [NSExpression expressionForIntersectSet:visit(expression.leftExpression) with:visit(expression.rightExpression)];
+        case NSMinusSetExpressionType:
+            return [NSExpression expressionForMinusSet:visit(expression.leftExpression) with:visit(expression.rightExpression)];
+
+        case NSSubqueryExpressionType:
+            return [NSExpression expressionForSubquery:visit(expression.operand) usingIteratorVariable:expression.variable predicate:visit(expression.predicate)];
+
+        case NSAggregateExpressionType: {
+            NSMutableArray *subexpressions = [NSMutableArray array];
+            for (NSExpression *subexpression in expression.collection) {
+                [subexpressions addObject:visit(subexpression)];
+            }
+            return [NSExpression expressionForAggregate:subexpressions];
+        }
+
+        case NSConditionalExpressionType:
+            return [NSExpression expressionForConditional:visit(expression.predicate) trueExpression:visit(expression.trueExpression) falseExpression:visit(expression.falseExpression)];
+
+        default:
+            // The remaining expression types do not contain nested expressions or predicates.
+            return expression;
+    }
+}
+
+NSPredicate *PredicateExpressionTransformer::visit(NSPredicate *predicate) const {
+    if ([predicate isKindOfClass:[NSCompoundPredicate class]]) {
+        NSCompoundPredicate *compoundPredicate = (NSCompoundPredicate *)predicate;
+        NSMutableArray *subpredicates = [NSMutableArray array];
+        for (NSPredicate *subpredicate in compoundPredicate.subpredicates) {
+            [subpredicates addObject:visit(subpredicate)];
+        }
+        return [[NSCompoundPredicate alloc] initWithType:compoundPredicate.compoundPredicateType subpredicates:subpredicates];
+    }
+    if ([predicate isKindOfClass:[NSComparisonPredicate class]]) {
+        NSComparisonPredicate *comparisonPredicate = (NSComparisonPredicate *)predicate;
+        NSExpression *leftExpression = visit(comparisonPredicate.leftExpression);
+        NSExpression *rightExpression = visit(comparisonPredicate.rightExpression);
+        return [NSComparisonPredicate predicateWithLeftExpression:leftExpression rightExpression:rightExpression modifier:comparisonPredicate.comparisonPredicateModifier type:comparisonPredicate.predicateOperatorType options:comparisonPredicate.options];
+    }
+    return predicate;
+}
+
+} // anonymous namespace
+
+NSPredicate *transformPredicate(NSPredicate *predicate, ExpressionVisitor visitor) {
+    PredicateExpressionTransformer transformer(visitor);
+    return transformer.visit(predicate);
+}
diff --git a/Pods/Realm/Realm/RLMProperty.mm b/Pods/Realm/Realm/RLMProperty.mm
new file mode 100644
index 0000000..cf03489
--- /dev/null
+++ b/Pods/Realm/Realm/RLMProperty.mm
@@ -0,0 +1,572 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import "RLMProperty_Private.hpp"
+
+#import "RLMArray.h"
+#import "RLMListBase.h"
+#import "RLMObject.h"
+#import "RLMObject_Private.h"
+#import "RLMOptionalBase.h"
+#import "RLMSchema_Private.h"
+#import "RLMSwiftSupport.h"
+#import "RLMUtil.hpp"
+
+BOOL RLMPropertyTypeIsNullable(RLMPropertyType propertyType) {
+    return propertyType != RLMPropertyTypeArray && propertyType != RLMPropertyTypeLinkingObjects;
+}
+
+BOOL RLMPropertyTypeIsComputed(RLMPropertyType propertyType) {
+    return propertyType == RLMPropertyTypeLinkingObjects;
+}
+
+static bool rawTypeIsComputedProperty(NSString *rawType) {
+    if ([rawType isEqualToString:@"@\"RLMLinkingObjects\""] || [rawType hasPrefix:@"@\"RLMLinkingObjects<"]) {
+        return true;
+    }
+
+    return false;
+}
+
+@implementation RLMProperty
+
++ (instancetype)propertyForObjectStoreProperty:(const realm::Property &)prop {
+    return [[RLMProperty alloc] initWithName:@(prop.name.c_str())
+                                        type:(RLMPropertyType)prop.type
+                             objectClassName:prop.object_type.length() ? @(prop.object_type.c_str()) : nil
+                      linkOriginPropertyName:prop.link_origin_property_name.length() ? @(prop.link_origin_property_name.c_str()) : nil
+                                     indexed:prop.is_indexed
+                                    optional:prop.is_nullable];
+}
+
+- (instancetype)initWithName:(NSString *)name
+                        type:(RLMPropertyType)type
+             objectClassName:(NSString *)objectClassName
+      linkOriginPropertyName:(NSString *)linkOriginPropertyName
+                     indexed:(BOOL)indexed
+                    optional:(BOOL)optional {
+    self = [super init];
+    if (self) {
+        _name = name;
+        _type = type;
+        _objectClassName = objectClassName;
+        _linkOriginPropertyName = linkOriginPropertyName;
+        _indexed = indexed;
+        _optional = optional;
+        [self setObjcCodeFromType];
+        [self updateAccessors];
+    }
+
+    return self;
+}
+
+- (void)setName:(NSString *)name {
+    _name = name;
+    [self updateAccessors];
+}
+
+- (void)updateAccessors {
+    // populate getter/setter names if generic
+    if (!_getterName) {
+        _getterName = _name;
+    }
+    if (!_setterName) {
+        // Objective-C setters only capitalize the first letter of the property name if it falls between 'a' and 'z'
+        int asciiCode = [_name characterAtIndex:0];
+        BOOL shouldUppercase = asciiCode >= 'a' && asciiCode <= 'z';
+        NSString *firstChar = [_name substringToIndex:1];
+        firstChar = shouldUppercase ? firstChar.uppercaseString : firstChar;
+        _setterName = [NSString stringWithFormat:@"set%@%@:", firstChar, [_name substringFromIndex:1]];
+    }
+
+    _getterSel = NSSelectorFromString(_getterName);
+    _setterSel = NSSelectorFromString(_setterName);
+}
+
+-(void)setObjcCodeFromType {
+    if (_optional) {
+        _objcType = '@';
+        return;
+    }
+    switch (_type) {
+        case RLMPropertyTypeInt:
+            _objcType = 'q';
+            break;
+        case RLMPropertyTypeBool:
+            _objcType = 'c';
+            break;
+        case RLMPropertyTypeDouble:
+            _objcType = 'd';
+            break;
+        case RLMPropertyTypeFloat:
+            _objcType = 'f';
+            break;
+        case RLMPropertyTypeAny:
+        case RLMPropertyTypeArray:
+        case RLMPropertyTypeData:
+        case RLMPropertyTypeDate:
+        case RLMPropertyTypeObject:
+        case RLMPropertyTypeString:
+        case RLMPropertyTypeLinkingObjects:
+            _objcType = '@';
+            break;
+    }
+}
+
+// determine RLMPropertyType from objc code - returns true if valid type was found/set
+- (BOOL)setTypeFromRawType {
+    const char *code = _objcRawType.UTF8String;
+    _objcType = *code;    // first char of type attr
+
+    // map to RLMPropertyType
+    switch (self.objcType) {
+        case 's':   // short
+        case 'i':   // int
+        case 'l':   // long
+        case 'q':   // long long
+            _type = RLMPropertyTypeInt;
+            return YES;
+        case 'f':
+            _type = RLMPropertyTypeFloat;
+            return YES;
+        case 'd':
+            _type = RLMPropertyTypeDouble;
+            return YES;
+        case 'c':   // BOOL is stored as char - since rlm has no char type this is ok
+        case 'B':
+            _type = RLMPropertyTypeBool;
+            return YES;
+        case '@': {
+            _optional = true;
+            static const char arrayPrefix[] = "@\"RLMArray<";
+            static const int arrayPrefixLen = sizeof(arrayPrefix) - 1;
+
+            static const char numberPrefix[] = "@\"NSNumber<";
+            static const int numberPrefixLen = sizeof(numberPrefix) - 1;
+
+            static const char linkingObjectsPrefix[] = "@\"RLMLinkingObjects";
+            static const int linkingObjectsPrefixLen = sizeof(linkingObjectsPrefix) - 1;
+
+            if (strcmp(code, "@\"NSString\"") == 0) {
+                _type = RLMPropertyTypeString;
+            }
+            else if (strcmp(code, "@\"NSDate\"") == 0) {
+                _type = RLMPropertyTypeDate;
+            }
+            else if (strcmp(code, "@\"NSData\"") == 0) {
+                _type = RLMPropertyTypeData;
+            }
+            else if (strncmp(code, arrayPrefix, arrayPrefixLen) == 0) {
+                _optional = false;
+                // get object class from type string - @"RLMArray<objectClassName>"
+                _type = RLMPropertyTypeArray;
+                _objectClassName = [[NSString alloc] initWithBytes:code + arrayPrefixLen
+                                                            length:strlen(code + arrayPrefixLen) - 2 // drop trailing >"
+                                                          encoding:NSUTF8StringEncoding];
+
+                Class cls = [RLMSchema classForString:_objectClassName];
+                if (!cls) {
+                    @throw RLMException(@"Property '%@' is of type 'RLMArray<%@>' which is not a supported RLMArray object type. "
+                                        @"RLMArrays can only contain instances of RLMObject subclasses. "
+                                        @"See https://realm.io/docs/objc/latest/#to-many for more information.", _name, _objectClassName);
+                }
+            }
+            else if (strncmp(code, numberPrefix, numberPrefixLen) == 0) {
+                // get number type from type string - @"NSNumber<objectClassName>"
+                NSString *numberType = [[NSString alloc] initWithBytes:code + numberPrefixLen
+                                                                length:strlen(code + numberPrefixLen) - 2 // drop trailing >"
+                                                              encoding:NSUTF8StringEncoding];
+
+                if ([numberType isEqualToString:@"RLMInt"]) {
+                    _type = RLMPropertyTypeInt;
+                }
+                else if ([numberType isEqualToString:@"RLMFloat"]) {
+                    _type = RLMPropertyTypeFloat;
+                }
+                else if ([numberType isEqualToString:@"RLMDouble"]) {
+                    _type = RLMPropertyTypeDouble;
+                }
+                else if ([numberType isEqualToString:@"RLMBool"]) {
+                    _type = RLMPropertyTypeBool;
+                }
+                else {
+                    @throw RLMException(@"Property '%@' is of type 'NSNumber<%@>' which is not a supported NSNumber object type. "
+                                        @"NSNumbers can only be RLMInt, RLMFloat, RLMDouble, and RLMBool at the moment. "
+                                        @"See https://realm.io/docs/objc/latest for more information.", _name, numberType);
+                }
+            }
+            else if (strncmp(code, linkingObjectsPrefix, linkingObjectsPrefixLen) == 0 &&
+                     (code[linkingObjectsPrefixLen] == '"' || code[linkingObjectsPrefixLen] == '<')) {
+                _type = RLMPropertyTypeLinkingObjects;
+                _optional = false;
+
+                if (!_objectClassName || !_linkOriginPropertyName) {
+                    @throw RLMException(@"Property '%@' is of type RLMLinkingObjects but +linkingObjectsProperties did not specify the class "
+                                        "or property that is the origin of the link.", _name);
+                }
+
+                // If the property was declared with a protocol indicating the contained type, validate that it matches
+                // the class from the dictionary returned by +linkingObjectsProperties.
+                if (code[linkingObjectsPrefixLen] == '<') {
+                    NSString *classNameFromProtocol = [[NSString alloc] initWithBytes:code + linkingObjectsPrefixLen + 1
+                                                                               length:strlen(code + linkingObjectsPrefixLen) - 3 // drop trailing >"
+                                                                             encoding:NSUTF8StringEncoding];
+                    if (![_objectClassName isEqualToString:classNameFromProtocol]) {
+                        @throw RLMException(@"Property '%@' was declared with type RLMLinkingObjects<%@>, but a conflicting "
+                                            "class name of '%@' was returned by +linkingObjectsProperties.", _name,
+                                            classNameFromProtocol, _objectClassName);
+                    }
+                }
+            }
+            else if (strcmp(code, "@\"NSNumber\"") == 0) {
+                @throw RLMException(@"Property '%@' requires a protocol defining the contained type - example: NSNumber<RLMInt>.", _name);
+            }
+            else if (strcmp(code, "@\"RLMArray\"") == 0) {
+                @throw RLMException(@"Property '%@' requires a protocol defining the contained type - example: RLMArray<Person>.", _name);
+            }
+            else {
+                NSString *className;
+                Class cls = nil;
+                if (code[1] == '\0') {
+                    className = @"id";
+                }
+                else {
+                    // for objects strip the quotes and @
+                    className = [_objcRawType substringWithRange:NSMakeRange(2, _objcRawType.length-3)];
+                    cls = [RLMSchema classForString:className];
+                }
+
+                if (!cls) {
+                    @throw RLMException(@"Property '%@' is declared as '%@', which is not a supported RLMObject property type. "
+                                        @"All properties must be primitives, NSString, NSDate, NSData, NSNumber, RLMArray, RLMLinkingObjects, or subclasses of RLMObject. "
+                                        @"See https://realm.io/docs/objc/latest/api/Classes/RLMObject.html for more information.", _name, className);
+                }
+
+                _type = RLMPropertyTypeObject;
+                _optional = true;
+                _objectClassName = [cls className] ?: className;
+            }
+            return YES;
+        }
+        default:
+            return NO;
+    }
+}
+
+- (bool)parseObjcProperty:(objc_property_t)property isSwift:(bool)isSwift {
+    unsigned int count;
+    objc_property_attribute_t *attrs = property_copyAttributeList(property, &count);
+
+    bool isReadOnly = false;
+    for (size_t i = 0; i < count; ++i) {
+        switch (*attrs[i].name) {
+            case 'T':
+                _objcRawType = @(attrs[i].value);
+                break;
+            case 'R':
+                isReadOnly = true;
+                break;
+            case 'N':
+                // nonatomic
+                break;
+            case 'D':
+                // dynamic
+                break;
+            case 'G':
+                _getterName = @(attrs[i].value);
+                break;
+            case 'S':
+                _setterName = @(attrs[i].value);
+                break;
+            case 'V': // backing ivar name
+                if (isSwift) {
+                    _getterName = @(attrs[i].value);
+                }
+                break;
+            default:
+                break;
+        }
+    }
+    free(attrs);
+
+    return isReadOnly;
+}
+
+- (instancetype)initSwiftPropertyWithName:(NSString *)name
+                                  indexed:(BOOL)indexed
+                   linkPropertyDescriptor:(RLMPropertyDescriptor *)linkPropertyDescriptor
+                                 property:(objc_property_t)property
+                                 instance:(RLMObject *)obj {
+    self = [super init];
+    if (!self) {
+        return nil;
+    }
+
+    _name = name;
+    _indexed = indexed;
+
+    if (linkPropertyDescriptor) {
+        _objectClassName = [linkPropertyDescriptor.objectClass className];
+        _linkOriginPropertyName = linkPropertyDescriptor.propertyName;
+    }
+
+    if ([self parseObjcProperty:property isSwift:true]) {
+        return nil;
+    }
+
+    id propertyValue = [obj valueForKey:_name];
+
+    // FIXME: temporarily workaround added since Objective-C generics used in Swift show up as `@`
+    //        * broken starting in Swift 3.0 Xcode 8 b1
+    //        * tested to still be broken in Swift 3.0 Xcode 8 b2
+    //        * if the Realm Objective-C Swift tests pass with this removed, it's been fixed
+    //        * once it has been fixed, remove this entire conditional block (contents included) entirely
+    //        * Bug Report: SR-2031 https://bugs.swift.org/browse/SR-2031
+    if ([_objcRawType isEqualToString:@"@"]) {
+        if (propertyValue) {
+            _objcRawType = [NSString stringWithFormat:@"@\"%@\"", [propertyValue class]];
+        } else if (linkPropertyDescriptor) {
+            // we're going to naively assume that the user used the correct type since we can't check it
+            _objcRawType = @"@\"RLMLinkingObjects\"";
+        }
+    }
+
+    // convert array types to objc variant
+    if ([_objcRawType isEqualToString:@"@\"RLMArray\""]) {
+        _objcRawType = [NSString stringWithFormat:@"@\"RLMArray<%@>\"", [propertyValue objectClassName]];
+    }
+    else if ([_objcRawType isEqualToString:@"@\"NSNumber\""]) {
+        const char *numberType = [propertyValue objCType];
+        switch (*numberType) {
+            case 'i':
+            case 'l':
+            case 'q':
+                _objcRawType = @"@\"NSNumber<RLMInt>\"";
+                break;
+            case 'f':
+                _objcRawType = @"@\"NSNumber<RLMFloat>\"";
+                break;
+            case 'd':
+                _objcRawType = @"@\"NSNumber<RLMDouble>\"";
+                break;
+            case 'B':
+            case 'c':
+                _objcRawType = @"@\"NSNumber<RLMBool>\"";
+                break;
+            default:
+                @throw RLMException(@"Can't persist NSNumber of type '%s': only integers, floats, doubles, and bools are currently supported.", numberType);
+        }
+    }
+
+    auto throwForPropertyName = ^(NSString *propertyName){
+        @throw RLMException(@"Can't persist property '%@' with incompatible type. "
+                            "Add to Object.ignoredProperties() class method to ignore.",
+                            propertyName);
+    };
+
+    if (![self setTypeFromRawType]) {
+        throwForPropertyName(self.name);
+    }
+
+    if (_objcType == 'c') {
+        // Check if it's a BOOL or Int8 by trying to set it to 2 and seeing if
+        // it actually sets it to 1.
+        [obj setValue:@2 forKey:name];
+        NSNumber *value = [obj valueForKey:name];
+        _type = value.intValue == 2 ? RLMPropertyTypeInt : RLMPropertyTypeBool;
+    }
+
+    // update getter/setter names
+    [self updateAccessors];
+
+    return self;
+}
+
+- (instancetype)initWithName:(NSString *)name
+                     indexed:(BOOL)indexed
+      linkPropertyDescriptor:(RLMPropertyDescriptor *)linkPropertyDescriptor
+                    property:(objc_property_t)property
+{
+    self = [super init];
+    if (!self) {
+        return nil;
+    }
+
+    _name = name;
+    _indexed = indexed;
+
+    if (linkPropertyDescriptor) {
+        _objectClassName = [linkPropertyDescriptor.objectClass className];
+        _linkOriginPropertyName = linkPropertyDescriptor.propertyName;
+    }
+
+    bool isReadOnly = [self parseObjcProperty:property isSwift:false];
+    bool isComputedProperty = rawTypeIsComputedProperty(_objcRawType);
+    if (isReadOnly && !isComputedProperty) {
+        return nil;
+    }
+
+    if (![self setTypeFromRawType]) {
+        @throw RLMException(@"Can't persist property '%@' with incompatible type. "
+                             "Add to ignoredPropertyNames: method to ignore.", self.name);
+    }
+
+    if (!isReadOnly && isComputedProperty) {
+        @throw RLMException(@"Property '%@' must be declared as readonly as %@ properties cannot be written to.",
+                            self.name, RLMTypeToString(_type));
+    }
+
+    // update getter/setter names
+    [self updateAccessors];
+
+    return self;
+}
+
+- (instancetype)initSwiftListPropertyWithName:(NSString *)name
+                                         ivar:(Ivar)ivar
+                              objectClassName:(NSString *)objectClassName {
+    self = [super init];
+    if (!self) {
+        return nil;
+    }
+
+    _name = name;
+    _type = RLMPropertyTypeArray;
+    _objectClassName = objectClassName;
+    _objcType = 't';
+    _swiftIvar = ivar;
+
+    // no obj-c property for generic lists, and thus no getter/setter names
+
+    return self;
+}
+
+- (instancetype)initSwiftOptionalPropertyWithName:(NSString *)name
+                                          indexed:(BOOL)indexed
+                                             ivar:(Ivar)ivar
+                                     propertyType:(RLMPropertyType)propertyType {
+    self = [super init];
+    if (!self) {
+        return nil;
+    }
+
+    _name = name;
+    _type = propertyType;
+    _indexed = indexed;
+    _objcType = '@';
+    _swiftIvar = ivar;
+    _optional = true;
+
+    // no obj-c property for generic optionals, and thus no getter/setter names
+
+    return self;
+}
+
+- (instancetype)initSwiftLinkingObjectsPropertyWithName:(NSString *)name
+                                                   ivar:(Ivar)ivar
+                                        objectClassName:(NSString *)objectClassName
+                                 linkOriginPropertyName:(NSString *)linkOriginPropertyName {
+    self = [super init];
+    if (!self) {
+        return nil;
+    }
+
+    _name = name;
+    _type = RLMPropertyTypeLinkingObjects;
+    _objectClassName = objectClassName;
+    _linkOriginPropertyName = linkOriginPropertyName;
+    _objcType = '@';
+    _swiftIvar = ivar;
+
+    // no obj-c property for generic linking objects properties, and thus no getter/setter names
+
+    return self;
+}
+
+- (id)copyWithZone:(NSZone *)zone {
+    RLMProperty *prop = [[RLMProperty allocWithZone:zone] init];
+    prop->_name = _name;
+    prop->_type = _type;
+    prop->_objcType = _objcType;
+    prop->_objectClassName = _objectClassName;
+    prop->_indexed = _indexed;
+    prop->_getterName = _getterName;
+    prop->_setterName = _setterName;
+    prop->_getterSel = _getterSel;
+    prop->_setterSel = _setterSel;
+    prop->_isPrimary = _isPrimary;
+    prop->_swiftIvar = _swiftIvar;
+    prop->_optional = _optional;
+    prop->_linkOriginPropertyName = _linkOriginPropertyName;
+
+    return prop;
+}
+
+- (RLMProperty *)copyWithNewName:(NSString *)name {
+    RLMProperty *prop = [self copy];
+    prop.name = name;
+    return prop;
+}
+
+- (BOOL)isEqual:(id)object {
+    if (![object isKindOfClass:[RLMProperty class]]) {
+        return NO;
+    }
+
+    return [self isEqualToProperty:object];
+}
+
+- (BOOL)isEqualToProperty:(RLMProperty *)property {
+    return _type == property->_type
+        && _column == property->_column
+        && _indexed == property->_indexed
+        && _isPrimary == property->_isPrimary
+        && _optional == property->_optional
+        && [_name isEqualToString:property->_name]
+        && (_objectClassName == property->_objectClassName  || [_objectClassName isEqualToString:property->_objectClassName])
+        && (_linkOriginPropertyName == property->_linkOriginPropertyName  || [_linkOriginPropertyName isEqualToString:property->_linkOriginPropertyName]);
+}
+
+- (NSString *)description {
+    return [NSString stringWithFormat:@"%@ {\n\ttype = %@;\n\tobjectClassName = %@;\n\tlinkOriginPropertyName = %@;\n\tindexed = %@;\n\tisPrimary = %@;\n\toptional = %@;\n}", self.name, RLMTypeToString(self.type), self.objectClassName, self.linkOriginPropertyName, self.indexed ? @"YES" : @"NO", self.isPrimary ? @"YES" : @"NO", self.optional ? @"YES" : @"NO"];
+}
+
+- (realm::Property)objectStoreCopy {
+    realm::Property p;
+    p.name = _name.UTF8String;
+    p.type = (realm::PropertyType)_type;
+    p.object_type = _objectClassName ? _objectClassName.UTF8String : "";
+    p.is_indexed = _indexed;
+    p.is_nullable = _optional;
+    p.link_origin_property_name = _linkOriginPropertyName ? _linkOriginPropertyName.UTF8String : "";
+    return p;
+}
+
+@end
+
+@implementation RLMPropertyDescriptor
+
++ (instancetype)descriptorWithClass:(Class)objectClass propertyName:(NSString *)propertyName
+{
+    RLMPropertyDescriptor *descriptor = [[RLMPropertyDescriptor alloc] init];
+    descriptor->_objectClass = objectClass;
+    descriptor->_propertyName = propertyName;
+    return descriptor;
+}
+
+@end
diff --git a/Pods/Realm/Realm/RLMQueryUtil.mm b/Pods/Realm/Realm/RLMQueryUtil.mm
new file mode 100644
index 0000000..e999926
--- /dev/null
+++ b/Pods/Realm/Realm/RLMQueryUtil.mm
@@ -0,0 +1,1377 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import "RLMQueryUtil.hpp"
+
+#import "RLMArray.h"
+#import "RLMObjectSchema.h"
+#import "RLMObject_Private.hpp"
+#import "RLMPredicateUtil.hpp"
+#import "RLMProperty.h"
+#import "RLMSchema.h"
+#import "RLMUtil.hpp"
+
+#import "object_store.hpp"
+#import "results.hpp"
+
+#include <realm/query_engine.hpp>
+
+using namespace realm;
+
+NSString * const RLMPropertiesComparisonTypeMismatchException = @"RLMPropertiesComparisonTypeMismatchException";
+NSString * const RLMUnsupportedTypesFoundInPropertyComparisonException = @"RLMUnsupportedTypesFoundInPropertyComparisonException";
+
+NSString * const RLMPropertiesComparisonTypeMismatchReason = @"Property type mismatch between %@ and %@";
+NSString * const RLMUnsupportedTypesFoundInPropertyComparisonReason = @"Comparison between %@ and %@";
+
+// small helper to create the many exceptions thrown when parsing predicates
+static NSException *RLMPredicateException(NSString *name, NSString *format, ...) {
+    va_list args;
+    va_start(args, format);
+    NSString *reason = [[NSString alloc] initWithFormat:format arguments:args];
+    va_end(args);
+
+    return [NSException exceptionWithName:name reason:reason userInfo:nil];
+}
+
+// check a precondition and throw an exception if it is not met
+// this should be used iff the condition being false indicates a bug in the caller
+// of the function checking its preconditions
+static void RLMPrecondition(bool condition, NSString *name, NSString *format, ...) {
+    if (__builtin_expect(condition, 1)) {
+        return;
+    }
+
+    va_list args;
+    va_start(args, format);
+    NSString *reason = [[NSString alloc] initWithFormat:format arguments:args];
+    va_end(args);
+
+    @throw [NSException exceptionWithName:name reason:reason userInfo:nil];
+}
+
+// return the property for a validated column name
+RLMProperty *RLMValidatedProperty(RLMObjectSchema *desc, NSString *columnName) {
+    RLMProperty *prop = desc[columnName];
+    RLMPrecondition(prop, @"Invalid property name",
+                    @"Property '%@' not found in object of type '%@'", columnName, desc.className);
+    return prop;
+}
+
+namespace {
+BOOL RLMPropertyTypeIsNumeric(RLMPropertyType propertyType) {
+    switch (propertyType) {
+        case RLMPropertyTypeInt:
+        case RLMPropertyTypeFloat:
+        case RLMPropertyTypeDouble:
+            return YES;
+        default:
+            return NO;
+    }
+}
+
+// FIXME: TrueExpression and FalseExpression should be supported by core in some way
+
+struct TrueExpression : realm::Expression {
+    size_t find_first(size_t start, size_t end) const override
+    {
+        if (start != end)
+            return start;
+
+        return realm::not_found;
+    }
+    void set_base_table(const Table*) override {}
+    const Table* get_base_table() const override { return nullptr; }
+    std::unique_ptr<Expression> clone(QueryNodeHandoverPatches*) const override
+    {
+        return std::unique_ptr<Expression>(new TrueExpression(*this));
+    }
+};
+
+struct FalseExpression : realm::Expression {
+    size_t find_first(size_t, size_t) const override { return realm::not_found; }
+    void set_base_table(const Table*) override {}
+    const Table* get_base_table() const override { return nullptr; }
+    std::unique_ptr<Expression> clone(QueryNodeHandoverPatches*) const override
+    {
+        return std::unique_ptr<Expression>(new FalseExpression(*this));
+    }
+};
+
+NSString *operatorName(NSPredicateOperatorType operatorType)
+{
+    switch (operatorType) {
+        case NSLessThanPredicateOperatorType:
+            return @"<";
+        case NSLessThanOrEqualToPredicateOperatorType:
+            return @"<=";
+        case NSGreaterThanPredicateOperatorType:
+            return @">";
+        case NSGreaterThanOrEqualToPredicateOperatorType:
+            return @">=";
+        case NSEqualToPredicateOperatorType:
+            return @"==";
+        case NSNotEqualToPredicateOperatorType:
+            return @"!=";
+        case NSMatchesPredicateOperatorType:
+            return @"MATCHES";
+        case NSLikePredicateOperatorType:
+            return @"LIKE";
+        case NSBeginsWithPredicateOperatorType:
+            return @"BEGINSWITH";
+        case NSEndsWithPredicateOperatorType:
+            return @"ENDSWITH";
+        case NSInPredicateOperatorType:
+            return @"IN";
+        case NSContainsPredicateOperatorType:
+            return @"CONTAINS";
+        case NSBetweenPredicateOperatorType:
+            return @"BETWEEN";
+        case NSCustomSelectorPredicateOperatorType:
+            return @"custom selector";
+    }
+
+    return [NSString stringWithFormat:@"unknown operator %lu", (unsigned long)operatorType];
+}
+
+Table& get_table(Group& group, RLMObjectSchema *objectSchema)
+{
+    return *ObjectStore::table_for_object_type(&group, objectSchema.className.UTF8String);
+}
+
+// A reference to a column within a query. Can be resolved to a Columns<T> for use in query expressions.
+class ColumnReference {
+public:
+    ColumnReference(Query& query, Group& group, RLMSchema *schema, RLMProperty* property, const std::vector<RLMProperty*>& links = {})
+    : m_links(links), m_property(property), m_schema(schema), m_group(&group), m_query(&query), m_table(query.get_table().get())
+    {
+        auto& table = walk_link_chain([](Table&, size_t, RLMPropertyType) { });
+        m_index = table.get_column_index(m_property.name.UTF8String);
+    }
+
+    template <typename T, typename... SubQuery>
+    auto resolve(SubQuery&&... subquery) const
+    {
+        static_assert(sizeof...(SubQuery) < 2, "resolve() takes at most one subquery");
+        set_link_chain_on_table();
+        if (type() != RLMPropertyTypeLinkingObjects) {
+            return m_table->template column<T>(index(), std::forward<SubQuery>(subquery)...);
+        }
+        else {
+            return resolve_backlink<T>(std::forward<SubQuery>(subquery)...);
+        }
+    }
+
+    RLMProperty *property() const { return m_property; }
+    size_t index() const { return m_index; }
+    RLMPropertyType type() const { return property().type; }
+
+    RLMObjectSchema *link_target_object_schema() const
+    {
+        switch (type()) {
+            case RLMPropertyTypeObject:
+            case RLMPropertyTypeArray:
+            case RLMPropertyTypeLinkingObjects:
+                return m_schema[property().objectClassName];
+            default:
+                REALM_ASSERT(false);
+        }
+    }
+
+    bool has_links() const { return m_links.size(); }
+
+    bool has_any_to_many_links() const {
+        return std::any_of(begin(m_links), end(m_links), [](RLMProperty *property) {
+            return property.type == RLMPropertyTypeArray || property.type == RLMPropertyTypeLinkingObjects;
+        });
+    }
+
+    ColumnReference last_link_column() const {
+        REALM_ASSERT(!m_links.empty());
+        return {*m_query, *m_group, m_schema, m_links.back(), {m_links.begin(), m_links.end() - 1}};
+    }
+
+    ColumnReference column_ignoring_links(Query& query) const {
+        return {query, *m_group, m_schema, m_property};
+    }
+
+private:
+    template <typename T, typename... SubQuery>
+    auto resolve_backlink(SubQuery&&... subquery) const
+    {
+        // We actually just want `if constexpr (std::is_same<T, Link>::value) { ... }`,
+        // so fake it by tag-dispatching on the conditional
+        return do_resolve_backlink<T>(std::is_same<T, Link>(), std::forward<SubQuery>(subquery)...);
+    }
+
+    template <typename T, typename... SubQuery>
+    auto do_resolve_backlink(std::true_type, SubQuery&&... subquery) const
+    {
+        return with_link_origin(m_property, [&](Table& table, size_t col) {
+            return m_table->template column<T>(table, col, std::forward<SubQuery>(subquery)...);
+        });
+    }
+
+    template <typename T, typename... SubQuery>
+    Columns<T> do_resolve_backlink(std::false_type, SubQuery&&...) const
+    {
+        // This can't actually happen as we only call resolve_backlink() if
+        // it's RLMPropertyTypeLinkingObjects
+        __builtin_unreachable();
+    }
+
+    template<typename Func>
+    Table& walk_link_chain(Func&& func) const
+    {
+        auto table = m_query->get_table().get();
+        for (const auto& link : m_links) {
+            if (link.type != RLMPropertyTypeLinkingObjects) {
+                auto index = table->get_column_index(link.name.UTF8String);
+                func(*table, index, link.type);
+                table = table->get_link_target(index).get();
+            }
+            else {
+                with_link_origin(link, [&](Table& link_origin_table, size_t link_origin_column) {
+                    func(link_origin_table, link_origin_column, link.type);
+                    table = &link_origin_table;
+                });
+            }
+        }
+        return *table;
+    }
+
+    template<typename Func>
+    auto with_link_origin(RLMProperty *prop, Func&& func) const
+    {
+        RLMObjectSchema *link_origin_schema = m_schema[prop.objectClassName];
+        Table& link_origin_table = get_table(*m_group, link_origin_schema);
+        size_t link_origin_column = link_origin_table.get_column_index(prop.linkOriginPropertyName.UTF8String);
+        return func(link_origin_table, link_origin_column);
+    }
+
+    void set_link_chain_on_table() const
+    {
+        walk_link_chain([&](Table& current_table, size_t column, RLMPropertyType type) {
+            if (type == RLMPropertyTypeLinkingObjects) {
+                m_table->backlink(current_table, column);
+            }
+            else {
+                m_table->link(column);
+            }
+        });
+    }
+
+    std::vector<RLMProperty*> m_links;
+    RLMProperty *m_property;
+    RLMSchema *m_schema;
+    Group *m_group;
+    Query *m_query;
+    Table *m_table;
+    size_t m_index;
+};
+
+class CollectionOperation {
+public:
+    enum Type {
+        Count,
+        Minimum,
+        Maximum,
+        Sum,
+        Average,
+    };
+
+    CollectionOperation(Type type, ColumnReference link_column, util::Optional<ColumnReference> column)
+        : m_type(type)
+        , m_link_column(std::move(link_column))
+        , m_column(std::move(column))
+    {
+        RLMPrecondition(m_link_column.type() == RLMPropertyTypeArray || m_link_column.type() == RLMPropertyTypeLinkingObjects,
+                        @"Invalid predicate", @"Collection operation can only be applied to a property of type RLMArray.");
+
+        switch (m_type) {
+            case Count:
+                RLMPrecondition(!m_column, @"Invalid predicate", @"Result of @count does not have any properties.");
+                break;
+            case Minimum:
+            case Maximum:
+            case Sum:
+            case Average:
+                RLMPrecondition(m_column && RLMPropertyTypeIsNumeric(m_column->type()), @"Invalid predicate",
+                                @"%@ can only be applied to a numeric property.", name_for_type(m_type));
+                break;
+        }
+    }
+
+    CollectionOperation(NSString *operationName, ColumnReference link_column, util::Optional<ColumnReference> column = util::none)
+        : CollectionOperation(type_for_name(operationName), std::move(link_column), std::move(column))
+    {
+    }
+
+    Type type() const { return m_type; }
+    const ColumnReference& link_column() const { return m_link_column; }
+    const ColumnReference& column() const { return *m_column; }
+
+    void validate_comparison(id value) const {
+        switch (m_type) {
+            case Count:
+            case Average:
+                RLMPrecondition([value isKindOfClass:[NSNumber class]], @"Invalid operand",
+                                @"%@ can only be compared with a numeric value.", name_for_type(m_type));
+                break;
+            case Minimum:
+            case Maximum:
+            case Sum:
+                RLMPrecondition(RLMIsObjectValidForProperty(value, m_column->property()), @"Invalid operand",
+                                @"%@ on a property of type %@ cannot be compared with '%@'",
+                                name_for_type(m_type), RLMTypeToString(m_column->type()), value);
+                break;
+        }
+    }
+
+    void validate_comparison(const ColumnReference& column) const {
+        switch (m_type) {
+            case Count:
+                RLMPrecondition(RLMPropertyTypeIsNumeric(column.type()), @"Invalid operand",
+                                @"%@ can only be compared with a numeric value.", name_for_type(m_type));
+                break;
+            case Average:
+            case Minimum:
+            case Maximum:
+            case Sum:
+                RLMPrecondition(RLMPropertyTypeIsNumeric(column.type()), @"Invalid operand",
+                                @"%@ on a property of type %@ cannot be compared with property of type '%@'",
+                                name_for_type(m_type), RLMTypeToString(m_column->type()), RLMTypeToString(column.type()));
+                break;
+        }
+    }
+
+private:
+    static Type type_for_name(NSString *name) {
+        if ([name isEqualToString:@"@count"]) {
+            return Count;
+        }
+        if ([name isEqualToString:@"@min"]) {
+            return Minimum;
+        }
+        if ([name isEqualToString:@"@max"]) {
+            return Maximum;
+        }
+        if ([name isEqualToString:@"@sum"]) {
+            return Sum;
+        }
+        if ([name isEqualToString:@"@avg"]) {
+            return Average;
+        }
+        @throw RLMPredicateException(@"Invalid predicate", @"Unsupported collection operation '%@'", name);
+    }
+
+    static NSString *name_for_type(Type type) {
+        switch (type) {
+            case Count: return @"@count";
+            case Minimum: return @"@min";
+            case Maximum: return @"@max";
+            case Sum: return @"@sum";
+            case Average: return @"@avg";
+        }
+    }
+
+    Type m_type;
+    ColumnReference m_link_column;
+    util::Optional<ColumnReference> m_column;
+};
+
+class QueryBuilder {
+public:
+    QueryBuilder(Query& query, Group& group, RLMSchema *schema)
+    : m_query(query), m_group(group), m_schema(schema) { }
+
+    void apply_predicate(NSPredicate *predicate, RLMObjectSchema *objectSchema);
+
+
+    void apply_collection_operator_expression(RLMObjectSchema *desc, NSString *keyPath, id value, NSComparisonPredicate *pred);
+    void apply_value_expression(RLMObjectSchema *desc, NSString *keyPath, id value, NSComparisonPredicate *pred);
+    void apply_column_expression(RLMObjectSchema *desc, NSString *leftKeyPath, NSString *rightKeyPath, NSComparisonPredicate *predicate);
+    void apply_subquery_count_expression(RLMObjectSchema *objectSchema, NSExpression *subqueryExpression,
+                                         NSPredicateOperatorType operatorType, NSExpression *right);
+    void apply_function_subquery_expression(RLMObjectSchema *objectSchema, NSExpression *functionExpression,
+                                            NSPredicateOperatorType operatorType, NSExpression *right);
+    void apply_function_expression(RLMObjectSchema *objectSchema, NSExpression *functionExpression,
+                                   NSPredicateOperatorType operatorType, NSExpression *right);
+
+
+    template <typename A, typename B>
+    void add_numeric_constraint(RLMPropertyType datatype,
+                                NSPredicateOperatorType operatorType,
+                                A&& lhs, B&& rhs);
+
+    template <typename A, typename B>
+    void add_bool_constraint(NSPredicateOperatorType operatorType, A lhs, B rhs);
+
+    template <typename T>
+    void add_string_constraint(NSPredicateOperatorType operatorType,
+                               NSComparisonPredicateOptions predicateOptions,
+                               Columns<String> &&column,
+                               T value);
+
+    void add_string_constraint(NSPredicateOperatorType operatorType,
+                               NSComparisonPredicateOptions predicateOptions,
+                               StringData value,
+                               Columns<String>&& column);
+
+    template <typename L, typename R>
+    void add_constraint(RLMPropertyType type,
+                        NSPredicateOperatorType operatorType,
+                        NSComparisonPredicateOptions predicateOptions,
+                        L lhs, R rhs);
+    template <typename... T>
+    void do_add_constraint(RLMPropertyType type, NSPredicateOperatorType operatorType,
+                           NSComparisonPredicateOptions predicateOptions, T... values);
+    void do_add_constraint(RLMPropertyType, NSPredicateOperatorType, NSComparisonPredicateOptions, id, realm::null);
+
+    void add_between_constraint(const ColumnReference& column, id value);
+
+    template<typename T>
+    void add_binary_constraint(NSPredicateOperatorType operatorType, const ColumnReference& column, T value);
+    void add_binary_constraint(NSPredicateOperatorType operatorType, const ColumnReference& column, id value);
+    void add_binary_constraint(NSPredicateOperatorType operatorType, id value, const ColumnReference& column);
+    void add_binary_constraint(NSPredicateOperatorType, const ColumnReference&, const ColumnReference&);
+
+    void add_link_constraint(NSPredicateOperatorType operatorType, const ColumnReference& column, RLMObject *obj);
+    void add_link_constraint(NSPredicateOperatorType operatorType, const ColumnReference& column, realm::null);
+    template<typename T>
+    void add_link_constraint(NSPredicateOperatorType operatorType, T obj, const ColumnReference& column);
+    void add_link_constraint(NSPredicateOperatorType, const ColumnReference&, const ColumnReference&);
+
+    template <CollectionOperation::Type Operation, typename... T>
+    void add_collection_operation_constraint(RLMPropertyType propertyType, NSPredicateOperatorType operatorType, T... values);
+    template <typename... T>
+    void add_collection_operation_constraint(NSPredicateOperatorType operatorType,
+                                             CollectionOperation collectionOperation, T... values);
+
+
+    CollectionOperation collection_operation_from_key_path(RLMObjectSchema *desc, NSString *keyPath);
+    ColumnReference column_reference_from_key_path(RLMObjectSchema *objectSchema, NSString *keyPath, bool isAggregate);
+
+private:
+    Query& m_query;
+    Group& m_group;
+    RLMSchema *m_schema;
+};
+
+// add a clause for numeric constraints based on operator type
+template <typename A, typename B>
+void QueryBuilder::add_numeric_constraint(RLMPropertyType datatype,
+                                          NSPredicateOperatorType operatorType,
+                                          A&& lhs, B&& rhs)
+{
+    switch (operatorType) {
+        case NSLessThanPredicateOperatorType:
+            m_query.and_query(lhs < rhs);
+            break;
+        case NSLessThanOrEqualToPredicateOperatorType:
+            m_query.and_query(lhs <= rhs);
+            break;
+        case NSGreaterThanPredicateOperatorType:
+            m_query.and_query(lhs > rhs);
+            break;
+        case NSGreaterThanOrEqualToPredicateOperatorType:
+            m_query.and_query(lhs >= rhs);
+            break;
+        case NSEqualToPredicateOperatorType:
+            m_query.and_query(lhs == rhs);
+            break;
+        case NSNotEqualToPredicateOperatorType:
+            m_query.and_query(lhs != rhs);
+            break;
+        default:
+            @throw RLMPredicateException(@"Invalid operator type",
+                                         @"Operator '%@' not supported for type %@", operatorName(operatorType), RLMTypeToString(datatype));
+    }
+}
+
+template <typename A, typename B>
+void QueryBuilder::add_bool_constraint(NSPredicateOperatorType operatorType, A lhs, B rhs) {
+    switch (operatorType) {
+        case NSEqualToPredicateOperatorType:
+            m_query.and_query(lhs == rhs);
+            break;
+        case NSNotEqualToPredicateOperatorType:
+            m_query.and_query(lhs != rhs);
+            break;
+        default:
+            @throw RLMPredicateException(@"Invalid operator type",
+                                         @"Operator '%@' not supported for bool type", operatorName(operatorType));
+    }
+}
+
+template <typename T>
+void QueryBuilder::add_string_constraint(NSPredicateOperatorType operatorType,
+                                         NSComparisonPredicateOptions predicateOptions,
+                                         Columns<String> &&column,
+                                         T value) {
+    bool caseSensitive = !(predicateOptions & NSCaseInsensitivePredicateOption);
+    bool diacriticInsensitive = (predicateOptions & NSDiacriticInsensitivePredicateOption);
+    RLMPrecondition(!diacriticInsensitive, @"Invalid predicate option",
+                    @"NSDiacriticInsensitivePredicateOption not supported for string type");
+
+    switch (operatorType) {
+        case NSBeginsWithPredicateOperatorType:
+            m_query.and_query(column.begins_with(value, caseSensitive));
+            break;
+        case NSEndsWithPredicateOperatorType:
+            m_query.and_query(column.ends_with(value, caseSensitive));
+            break;
+        case NSContainsPredicateOperatorType:
+            m_query.and_query(column.contains(value, caseSensitive));
+            break;
+        case NSEqualToPredicateOperatorType:
+            m_query.and_query(column.equal(value, caseSensitive));
+            break;
+        case NSNotEqualToPredicateOperatorType:
+            m_query.and_query(column.not_equal(value, caseSensitive));
+            break;
+        default:
+            @throw RLMPredicateException(@"Invalid operator type",
+                                         @"Operator '%@' not supported for string type", operatorName(operatorType));
+    }
+}
+
+void QueryBuilder::add_string_constraint(NSPredicateOperatorType operatorType,
+                                         NSComparisonPredicateOptions predicateOptions,
+                                         StringData value,
+                                         Columns<String>&& column) {
+    switch (operatorType) {
+        case NSEqualToPredicateOperatorType:
+        case NSNotEqualToPredicateOperatorType:
+            add_string_constraint(operatorType, predicateOptions, std::move(column), value);
+            break;
+        default:
+            @throw RLMPredicateException(@"Invalid operator type",
+                                         @"Operator '%@' is not supported for string type with key path on right side of operator",
+                                         operatorName(operatorType));
+    }
+}
+
+id value_from_constant_expression_or_value(id value) {
+    if (NSExpression *exp = RLMDynamicCast<NSExpression>(value)) {
+        RLMPrecondition(exp.expressionType == NSConstantValueExpressionType,
+                        @"Invalid value",
+                        @"Expressions within predicate aggregates must be constant values");
+        return exp.constantValue;
+    }
+    return value;
+}
+
+void validate_and_extract_between_range(id value, RLMProperty *prop, id *from, id *to) {
+    NSArray *array = RLMDynamicCast<NSArray>(value);
+    RLMPrecondition(array, @"Invalid value", @"object must be of type NSArray for BETWEEN operations");
+    RLMPrecondition(array.count == 2, @"Invalid value", @"NSArray object must contain exactly two objects for BETWEEN operations");
+
+    *from = value_from_constant_expression_or_value(array.firstObject);
+    *to = value_from_constant_expression_or_value(array.lastObject);
+    RLMPrecondition(RLMIsObjectValidForProperty(*from, prop) && RLMIsObjectValidForProperty(*to, prop),
+                    @"Invalid value",
+                    @"NSArray objects must be of type %@ for BETWEEN operations", RLMTypeToString(prop.type));
+}
+
+void QueryBuilder::add_between_constraint(const ColumnReference& column, id value) {
+    if (column.has_any_to_many_links()) {
+        auto link_column = column.last_link_column();
+        Query subquery = get_table(m_group, link_column.link_target_object_schema()).where();
+        QueryBuilder(subquery, m_group, m_schema).add_between_constraint(column.column_ignoring_links(subquery), value);
+
+        m_query.and_query(link_column.resolve<Link>(std::move(subquery)).count() > 0);
+        return;
+    }
+
+    id from, to;
+    validate_and_extract_between_range(value, column.property(), &from, &to);
+
+    RLMPropertyType type = column.type();
+
+    m_query.group();
+    add_constraint(type, NSGreaterThanOrEqualToPredicateOperatorType, 0, column, from);
+    add_constraint(type, NSLessThanOrEqualToPredicateOperatorType, 0, column, to);
+    m_query.end_group();
+}
+
+template<typename T>
+void QueryBuilder::add_binary_constraint(NSPredicateOperatorType operatorType,
+                                         const ColumnReference& column,
+                                         T value) {
+    RLMPrecondition(!column.has_links(), @"Unsupported operator", @"NSData properties cannot be queried over an object link.");
+
+    size_t index = column.index();
+    switch (operatorType) {
+        case NSBeginsWithPredicateOperatorType:
+            m_query.begins_with(index, value);
+            break;
+        case NSEndsWithPredicateOperatorType:
+            m_query.ends_with(index, value);
+            break;
+        case NSContainsPredicateOperatorType:
+            m_query.contains(index, value);
+            break;
+        case NSEqualToPredicateOperatorType:
+            m_query.equal(index, value);
+            break;
+        case NSNotEqualToPredicateOperatorType:
+            m_query.not_equal(index, value);
+            break;
+        default:
+            @throw RLMPredicateException(@"Invalid operator type",
+                                         @"Operator '%@' not supported for binary type", operatorName(operatorType));
+    }
+}
+
+void QueryBuilder::add_binary_constraint(NSPredicateOperatorType operatorType, const ColumnReference& column, id value) {
+    add_binary_constraint(operatorType, column, RLMBinaryDataForNSData(value));
+}
+
+void QueryBuilder::add_binary_constraint(NSPredicateOperatorType operatorType, id value, const ColumnReference& column) {
+    switch (operatorType) {
+        case NSEqualToPredicateOperatorType:
+        case NSNotEqualToPredicateOperatorType:
+            add_binary_constraint(operatorType, column, value);
+            break;
+        default:
+            @throw RLMPredicateException(@"Invalid operator type",
+                                         @"Operator '%@' is not supported for binary type with key path on right side of operator",
+                                         operatorName(operatorType));
+    }
+}
+
+void QueryBuilder::add_binary_constraint(NSPredicateOperatorType, const ColumnReference&, const ColumnReference&) {
+    @throw RLMPredicateException(@"Invalid predicate", @"Comparisons between two NSData properties are not supported");
+}
+
+void QueryBuilder::add_link_constraint(NSPredicateOperatorType operatorType,
+                                       const ColumnReference& column, RLMObject *obj) {
+    RLMPrecondition(operatorType == NSEqualToPredicateOperatorType || operatorType == NSNotEqualToPredicateOperatorType,
+                    @"Invalid operator type", @"Only 'Equal' and 'Not Equal' operators supported for object comparison");
+
+    // NOTE: This precondition assumes that the argument `obj` will be always originating from the
+    // queried table as verified before by `validate_property_value`
+    RLMPrecondition(column.link_target_object_schema() == obj.objectSchema || !obj->_row.is_attached(),
+                    @"Invalid value origin", @"Object must be from the Realm being queried");
+
+    if (operatorType == NSEqualToPredicateOperatorType) {
+        m_query.and_query(column.resolve<Link>() == obj->_row);
+    }
+    else {
+        m_query.and_query(column.resolve<Link>() != obj->_row);
+    }
+}
+
+void QueryBuilder::add_link_constraint(NSPredicateOperatorType operatorType,
+                                       const ColumnReference& column,
+                                       realm::null) {
+    RLMPrecondition(!column.has_links(), @"Unsupported operator", @"Multi-level object equality link queries are not supported.");
+    RLMPrecondition(operatorType == NSEqualToPredicateOperatorType || operatorType == NSNotEqualToPredicateOperatorType,
+                    @"Invalid operator type", @"Only 'Equal' and 'Not Equal' operators supported for object comparison");
+    if (operatorType == NSNotEqualToPredicateOperatorType) {
+        m_query.Not();
+    }
+
+    m_query.and_query(column.resolve<Link>().is_null());
+}
+
+template<typename T>
+void QueryBuilder::add_link_constraint(NSPredicateOperatorType operatorType, T obj, const ColumnReference& column) {
+    // Link constraints only support the equal-to and not-equal-to operators. The order of operands
+    // is not important for those comparisons so we can delegate to the other implementation.
+    add_link_constraint(operatorType, column, obj);
+}
+
+void QueryBuilder::add_link_constraint(NSPredicateOperatorType, const ColumnReference&, const ColumnReference&) {
+    // This is not actually reachable as this case is caught earlier, but this
+    // overload is needed for the code to compile
+    @throw RLMPredicateException(@"Invalid predicate", @"Comparisons between two RLMArray properties are not supported");
+}
+
+
+// iterate over an array of subpredicates, using @func to build a query from each
+// one and ORing them together
+template<typename Func>
+void process_or_group(Query &query, id array, Func&& func) {
+    RLMPrecondition([array conformsToProtocol:@protocol(NSFastEnumeration)],
+                    @"Invalid value", @"IN clause requires an array of items");
+
+    query.group();
+
+    bool first = true;
+    for (id item in array) {
+        if (!first) {
+            query.Or();
+        }
+        first = false;
+
+        func(item);
+    }
+
+    if (first) {
+        // Queries can't be empty, so if there's zero things in the OR group
+        // validation will fail. Work around this by adding an expression which
+        // will never find any rows in a table.
+        query.and_query(std::unique_ptr<Expression>(new FalseExpression));
+    }
+
+    query.end_group();
+}
+
+template <typename RequestedType>
+RequestedType convert(id value);
+
+template <>
+Timestamp convert<Timestamp>(id value) {
+    return RLMTimestampForNSDate(value);
+}
+
+template <>
+bool convert<bool>(id value) {
+    return [value boolValue];
+}
+
+template <>
+Double convert<Double>(id value) {
+    return [value doubleValue];
+}
+
+template <>
+Float convert<Float>(id value) {
+    return [value floatValue];
+}
+
+template <>
+Int convert<Int>(id value) {
+    return [value longLongValue];
+}
+
+template <>
+String convert<String>(id value) {
+    return RLMStringDataWithNSString(value);
+}
+
+template <typename>
+realm::null value_of_type(realm::null) {
+    return realm::null();
+}
+
+template <typename RequestedType>
+auto value_of_type(id value) {
+    return ::convert<RequestedType>(value);
+}
+
+template <typename RequestedType>
+auto value_of_type(const ColumnReference& column) {
+    return column.resolve<RequestedType>();
+}
+
+
+template <typename... T>
+void QueryBuilder::do_add_constraint(RLMPropertyType type, NSPredicateOperatorType operatorType,
+                                     NSComparisonPredicateOptions predicateOptions, T... values)
+{
+    static_assert(sizeof...(T) == 2, "do_add_constraint accepts only two values as arguments");
+
+    switch (type) {
+        case RLMPropertyTypeBool:
+            add_bool_constraint(operatorType, value_of_type<bool>(values)...);
+            break;
+        case RLMPropertyTypeDate:
+            add_numeric_constraint(type, operatorType, value_of_type<realm::Timestamp>(values)...);
+            break;
+        case RLMPropertyTypeDouble:
+            add_numeric_constraint(type, operatorType, value_of_type<Double>(values)...);
+            break;
+        case RLMPropertyTypeFloat:
+            add_numeric_constraint(type, operatorType, value_of_type<Float>(values)...);
+            break;
+        case RLMPropertyTypeInt:
+            add_numeric_constraint(type, operatorType, value_of_type<Int>(values)...);
+            break;
+        case RLMPropertyTypeString:
+            add_string_constraint(operatorType, predicateOptions, value_of_type<String>(values)...);
+            break;
+        case RLMPropertyTypeData:
+            add_binary_constraint(operatorType, values...);
+            break;
+        case RLMPropertyTypeObject:
+        case RLMPropertyTypeArray:
+        case RLMPropertyTypeLinkingObjects:
+            add_link_constraint(operatorType, values...);
+            break;
+        default:
+            @throw RLMPredicateException(@"Unsupported predicate value type",
+                                         @"Object type %@ not supported", RLMTypeToString(type));
+    }
+}
+
+void QueryBuilder::do_add_constraint(RLMPropertyType, NSPredicateOperatorType, NSComparisonPredicateOptions, id, realm::null)
+{
+    // This is not actually reachable as this case is caught earlier, but this
+    // overload is needed for the code to compile
+    @throw RLMPredicateException(@"Invalid predicate expressions",
+                                 @"Predicate expressions must compare a keypath and another keypath or a constant value");
+}
+
+bool is_nsnull(id value) {
+    return !value || value == NSNull.null;
+}
+
+template<typename T>
+bool is_nsnull(T) {
+    return false;
+}
+
+template <typename L, typename R>
+void QueryBuilder::add_constraint(RLMPropertyType type, NSPredicateOperatorType operatorType,
+                                  NSComparisonPredicateOptions predicateOptions, L lhs, R rhs)
+{
+    // The expression operators are only overloaded for realm::null on the rhs
+    RLMPrecondition(!is_nsnull(lhs), @"Unsupported operator",
+                    @"Nil is only supported on the right side of operators");
+
+    if (is_nsnull(rhs)) {
+        do_add_constraint(type, operatorType, predicateOptions, lhs, realm::null());
+    }
+    else {
+        do_add_constraint(type, operatorType, predicateOptions, lhs, rhs);
+    }
+}
+
+ColumnReference QueryBuilder::column_reference_from_key_path(RLMObjectSchema *objectSchema, NSString *keyPath, bool isAggregate)
+{
+    RLMProperty *property;
+    std::vector<RLMProperty *> links;
+
+    bool keyPathContainsToManyRelationship = false;
+
+    NSUInteger start = 0, length = keyPath.length, end = NSNotFound;
+    do {
+        end = [keyPath rangeOfString:@"." options:0 range:{start, length - start}].location;
+        NSString *propertyName = [keyPath substringWithRange:{start, end == NSNotFound ? length - start : end - start}];
+        property = objectSchema[propertyName];
+        RLMPrecondition(property, @"Invalid property name",
+                        @"Property '%@' not found in object of type '%@'", propertyName, objectSchema.className);
+
+        if (property.type == RLMPropertyTypeArray || property.type == RLMPropertyTypeLinkingObjects)
+            keyPathContainsToManyRelationship = true;
+
+        if (end != NSNotFound) {
+            RLMPrecondition(property.type == RLMPropertyTypeObject || property.type == RLMPropertyTypeArray || property.type == RLMPropertyTypeLinkingObjects,
+                            @"Invalid value", @"Property '%@' is not a link in object of type '%@'", propertyName, objectSchema.className);
+
+            links.push_back(property);
+            REALM_ASSERT(property.objectClassName);
+            objectSchema = m_schema[property.objectClassName];
+        }
+
+        start = end + 1;
+    } while (end != NSNotFound);
+
+    if (isAggregate && !keyPathContainsToManyRelationship) {
+        @throw RLMPredicateException(@"Invalid predicate",
+                                     @"Aggregate operations can only be used on key paths that include an array property");
+    } else if (!isAggregate && keyPathContainsToManyRelationship) {
+        @throw RLMPredicateException(@"Invalid predicate",
+                                     @"Key paths that include an array property must use aggregate operations");
+    }
+
+    return ColumnReference(m_query, m_group, m_schema, property, std::move(links));
+}
+
+void validate_property_value(const ColumnReference& column,
+                             __unsafe_unretained id const value,
+                             __unsafe_unretained NSString *const err,
+                             __unsafe_unretained RLMObjectSchema *const objectSchema,
+                             __unsafe_unretained NSString *const keyPath) {
+    RLMProperty *prop = column.property();
+    if (prop.type == RLMPropertyTypeArray) {
+        RLMPrecondition([RLMObjectBaseObjectSchema(RLMDynamicCast<RLMObjectBase>(value)).className isEqualToString:prop.objectClassName],
+                        @"Invalid value", err, prop.objectClassName, keyPath, objectSchema.className, value);
+    }
+    else {
+        RLMPrecondition(RLMIsObjectValidForProperty(value, prop),
+                        @"Invalid value", err, RLMTypeToString(prop.type), keyPath, objectSchema.className, value);
+    }
+}
+
+template <typename RequestedType, CollectionOperation::Type OperationType>
+struct ValueOfTypeWithCollectionOperationHelper;
+
+template <>
+struct ValueOfTypeWithCollectionOperationHelper<Int, CollectionOperation::Count> {
+    static auto convert(const CollectionOperation& operation)
+    {
+        assert(operation.type() == CollectionOperation::Count);
+        return operation.link_column().resolve<Link>().count();
+    }
+};
+
+#define VALUE_OF_TYPE_WITH_COLLECTION_OPERATOR_HELPER(OperationType, function) \
+template <typename T> \
+struct ValueOfTypeWithCollectionOperationHelper<T, OperationType> { \
+    static auto convert(const CollectionOperation& operation) \
+    { \
+        REALM_ASSERT(operation.type() == OperationType); \
+        auto targetColumn = operation.link_column().resolve<Link>().template column<T>(operation.column().index()); \
+        return targetColumn.function(); \
+    } \
+} \
+
+VALUE_OF_TYPE_WITH_COLLECTION_OPERATOR_HELPER(CollectionOperation::Minimum, min);
+VALUE_OF_TYPE_WITH_COLLECTION_OPERATOR_HELPER(CollectionOperation::Maximum, max);
+VALUE_OF_TYPE_WITH_COLLECTION_OPERATOR_HELPER(CollectionOperation::Sum, sum);
+VALUE_OF_TYPE_WITH_COLLECTION_OPERATOR_HELPER(CollectionOperation::Average, average);
+#undef VALUE_OF_TYPE_WITH_COLLECTION_OPERATOR_HELPER
+
+template <typename Requested, CollectionOperation::Type OperationType, typename T>
+auto value_of_type_with_collection_operation(T&& value) {
+    return value_of_type<Requested>(std::forward<T>(value));
+}
+
+template <typename Requested, CollectionOperation::Type OperationType>
+auto value_of_type_with_collection_operation(CollectionOperation operation) {
+    using helper = ValueOfTypeWithCollectionOperationHelper<Requested, OperationType>;
+    return helper::convert(operation);
+}
+
+template <CollectionOperation::Type Operation, typename... T>
+void QueryBuilder::add_collection_operation_constraint(RLMPropertyType propertyType, NSPredicateOperatorType operatorType, T... values)
+{
+    switch (propertyType) {
+        case RLMPropertyTypeInt:
+            add_numeric_constraint(propertyType, operatorType, value_of_type_with_collection_operation<Int, Operation>(values)...);
+            break;
+        case RLMPropertyTypeFloat:
+            add_numeric_constraint(propertyType, operatorType, value_of_type_with_collection_operation<Float, Operation>(values)...);
+            break;
+        case RLMPropertyTypeDouble:
+            add_numeric_constraint(propertyType, operatorType, value_of_type_with_collection_operation<Double, Operation>(values)...);
+            break;
+        default:
+            REALM_ASSERT(false && "Only numeric property types should hit this path.");
+    }
+}
+
+template <typename... T>
+void QueryBuilder::add_collection_operation_constraint(NSPredicateOperatorType operatorType,
+                                                  CollectionOperation collectionOperation, T... values)
+{
+    static_assert(sizeof...(T) == 2, "add_collection_operation_constraint accepts only two values as arguments");
+
+    switch (collectionOperation.type()) {
+        case CollectionOperation::Count:
+            add_numeric_constraint(RLMPropertyTypeInt, operatorType,
+                                   value_of_type_with_collection_operation<Int, CollectionOperation::Count>(values)...);
+            break;
+        case CollectionOperation::Minimum:
+            add_collection_operation_constraint<CollectionOperation::Minimum>(collectionOperation.column().type(), operatorType, values...);
+            break;
+        case CollectionOperation::Maximum:
+            add_collection_operation_constraint<CollectionOperation::Maximum>(collectionOperation.column().type(), operatorType, values...);
+            break;
+        case CollectionOperation::Sum:
+            add_collection_operation_constraint<CollectionOperation::Sum>(collectionOperation.column().type(), operatorType, values...);
+            break;
+        case CollectionOperation::Average:
+            add_collection_operation_constraint<CollectionOperation::Average>(collectionOperation.column().type(), operatorType, values...);
+            break;
+    }
+}
+
+bool key_path_contains_collection_operator(NSString *keyPath) {
+    return [keyPath rangeOfString:@"@"].location != NSNotFound;
+}
+
+NSString *get_collection_operation_name_from_key_path(NSString *keyPath, NSString **leadingKeyPath, NSString **trailingKey) {
+    NSRange at  = [keyPath rangeOfString:@"@"];
+    if (at.location == NSNotFound || at.location >= keyPath.length - 1) {
+        @throw RLMPredicateException(@"Invalid key path", @"'%@' is not a valid key path'", keyPath);
+    }
+
+    if (at.location == 0 || [keyPath characterAtIndex:at.location - 1] != '.') {
+        @throw RLMPredicateException(@"Invalid key path", @"'%@' is not a valid key path'", keyPath);
+    }
+
+    NSRange trailingKeyRange = [keyPath rangeOfString:@"." options:0 range:{at.location, keyPath.length - at.location} locale:nil];
+
+    *leadingKeyPath = [keyPath substringToIndex:at.location - 1];
+    if (trailingKeyRange.location == NSNotFound) {
+        *trailingKey = nil;
+        return [keyPath substringFromIndex:at.location];
+    } else {
+        *trailingKey = [keyPath substringFromIndex:trailingKeyRange.location + 1];
+        return [keyPath substringWithRange:{at.location, trailingKeyRange.location - at.location}];
+    }
+}
+
+CollectionOperation QueryBuilder::collection_operation_from_key_path(RLMObjectSchema *desc, NSString *keyPath) {
+    NSString *leadingKeyPath;
+    NSString *trailingKey;
+    NSString *collectionOperationName = get_collection_operation_name_from_key_path(keyPath, &leadingKeyPath, &trailingKey);
+
+    ColumnReference linkColumn = column_reference_from_key_path(desc, leadingKeyPath, true);
+    util::Optional<ColumnReference> column;
+    if (trailingKey) {
+        RLMPrecondition([trailingKey rangeOfString:@"."].location == NSNotFound, @"Invalid key path",
+                        @"Right side of collection operator may only have a single level key");
+        NSString *fullKeyPath = [leadingKeyPath stringByAppendingFormat:@".%@", trailingKey];
+        column = column_reference_from_key_path(desc, fullKeyPath, true);
+    }
+
+    return {collectionOperationName, std::move(linkColumn), std::move(column)};
+}
+
+void QueryBuilder::apply_collection_operator_expression(RLMObjectSchema *desc,
+                                                        NSString *keyPath, id value,
+                                                        NSComparisonPredicate *pred) {
+    CollectionOperation operation = collection_operation_from_key_path(desc, keyPath);
+    operation.validate_comparison(value);
+
+    if (pred.leftExpression.expressionType == NSKeyPathExpressionType) {
+        add_collection_operation_constraint(pred.predicateOperatorType, operation, operation, value);
+    } else {
+        add_collection_operation_constraint(pred.predicateOperatorType, operation, value, operation);
+    }
+}
+
+void QueryBuilder::apply_value_expression(RLMObjectSchema *desc,
+                                          NSString *keyPath, id value,
+                                          NSComparisonPredicate *pred)
+{
+    if (key_path_contains_collection_operator(keyPath)) {
+        apply_collection_operator_expression(desc, keyPath, value, pred);
+        return;
+    }
+
+    bool isAny = pred.comparisonPredicateModifier == NSAnyPredicateModifier;
+    ColumnReference column = column_reference_from_key_path(desc, keyPath, isAny);
+
+    // check to see if this is a between query
+    if (pred.predicateOperatorType == NSBetweenPredicateOperatorType) {
+        add_between_constraint(std::move(column), value);
+        return;
+    }
+
+    // turn "key.path IN collection" into ored together ==. "collection IN key.path" is handled elsewhere.
+    if (pred.predicateOperatorType == NSInPredicateOperatorType) {
+        process_or_group(m_query, value, [&](id item) {
+            id normalized = value_from_constant_expression_or_value(item);
+            validate_property_value(column, normalized,
+                                    @"Expected object of type %@ in IN clause for property '%@' on object of type '%@', but received: %@", desc, keyPath);
+            add_constraint(column.type(), NSEqualToPredicateOperatorType, pred.options, column, normalized);
+        });
+        return;
+    }
+
+    validate_property_value(column, value, @"Expected object of type %@ for property '%@' on object of type '%@', but received: %@", desc, keyPath);
+    if (pred.leftExpression.expressionType == NSKeyPathExpressionType) {
+        add_constraint(column.type(), pred.predicateOperatorType, pred.options, std::move(column), value);
+    } else {
+        add_constraint(column.type(), pred.predicateOperatorType, pred.options, value, std::move(column));
+    }
+}
+
+void QueryBuilder::apply_column_expression(RLMObjectSchema *desc,
+                                           NSString *leftKeyPath, NSString *rightKeyPath,
+                                           NSComparisonPredicate *predicate)
+{
+    bool left_key_path_contains_collection_operator = key_path_contains_collection_operator(leftKeyPath);
+    bool right_key_path_contains_collection_operator = key_path_contains_collection_operator(rightKeyPath);
+    if (left_key_path_contains_collection_operator && right_key_path_contains_collection_operator) {
+        @throw RLMPredicateException(@"Unsupported predicate", @"Key paths including aggregate operations cannot be compared with other aggregate operations.");
+    }
+
+    if (left_key_path_contains_collection_operator) {
+        CollectionOperation left = collection_operation_from_key_path(desc, leftKeyPath);
+        ColumnReference right = column_reference_from_key_path(desc, rightKeyPath, false);
+        left.validate_comparison(right);
+        add_collection_operation_constraint(predicate.predicateOperatorType, left, left, std::move(right));
+        return;
+    }
+    if (right_key_path_contains_collection_operator) {
+        ColumnReference left = column_reference_from_key_path(desc, leftKeyPath, false);
+        CollectionOperation right = collection_operation_from_key_path(desc, rightKeyPath);
+        right.validate_comparison(left);
+        add_collection_operation_constraint(predicate.predicateOperatorType, right, std::move(left), right);
+        return;
+    }
+
+    bool isAny = false;
+    ColumnReference left = column_reference_from_key_path(desc, leftKeyPath, isAny);
+    ColumnReference right = column_reference_from_key_path(desc, rightKeyPath, isAny);
+
+    // NOTE: It's assumed that column type must match and no automatic type conversion is supported.
+    RLMPrecondition(left.type() == right.type(),
+                    RLMPropertiesComparisonTypeMismatchException,
+                    RLMPropertiesComparisonTypeMismatchReason,
+                    RLMTypeToString(left.type()),
+                    RLMTypeToString(right.type()));
+
+    // TODO: Should we handle special case where left row is the same as right row (tautology)
+    add_constraint(left.type(), predicate.predicateOperatorType, predicate.options,
+                   std::move(left), std::move(right));
+}
+
+// Identify expressions of the form [SELF valueForKeyPath:]
+bool is_self_value_for_key_path_function_expression(NSExpression *expression)
+{
+    if (expression.expressionType != NSFunctionExpressionType)
+        return false;
+
+    if (expression.operand.expressionType != NSEvaluatedObjectExpressionType)
+        return false;
+
+    return [expression.function isEqualToString:@"valueForKeyPath:"];
+}
+
+// -[NSPredicate predicateWithSubtitutionVariables:] results in function expressions of the form [SELF valueForKeyPath:]
+// that apply_predicate cannot handle. Replace such expressions with equivalent NSKeyPathExpressionType expressions.
+NSExpression *simplify_self_value_for_key_path_function_expression(NSExpression *expression) {
+    if (is_self_value_for_key_path_function_expression(expression)) {
+        if (NSString *keyPath = [expression.arguments.firstObject keyPath]) {
+            return [NSExpression expressionForKeyPath:keyPath];
+        }
+    }
+    return expression;
+}
+
+void QueryBuilder::apply_subquery_count_expression(RLMObjectSchema *objectSchema,
+                                                   NSExpression *subqueryExpression, NSPredicateOperatorType operatorType, NSExpression *right) {
+    if (right.expressionType != NSConstantValueExpressionType || ![right.constantValue isKindOfClass:[NSNumber class]]) {
+        @throw RLMPredicateException(@"Invalid predicate expression", @"SUBQUERY(…).@count is only supported when compared with a constant number.");
+    }
+    int64_t value = [right.constantValue integerValue];
+
+    ColumnReference collectionColumn = column_reference_from_key_path(objectSchema, [subqueryExpression.collection keyPath], true);
+    RLMObjectSchema *collectionMemberObjectSchema = m_schema[collectionColumn.property().objectClassName];
+
+    // Eliminate references to the iteration variable in the subquery.
+    NSPredicate *subqueryPredicate = [subqueryExpression.predicate predicateWithSubstitutionVariables:@{ subqueryExpression.variable : [NSExpression expressionForEvaluatedObject] }];
+    subqueryPredicate = transformPredicate(subqueryPredicate, simplify_self_value_for_key_path_function_expression);
+
+    Query subquery = RLMPredicateToQuery(subqueryPredicate, collectionMemberObjectSchema, m_schema, m_group);
+    add_numeric_constraint(RLMPropertyTypeInt, operatorType,
+                           collectionColumn.resolve<LinkList>(std::move(subquery)).count(), value);
+}
+
+void QueryBuilder::apply_function_subquery_expression(RLMObjectSchema *objectSchema, NSExpression *functionExpression,
+                                                      NSPredicateOperatorType operatorType, NSExpression *right) {
+    if (![functionExpression.function isEqualToString:@"valueForKeyPath:"] || functionExpression.arguments.count != 1) {
+        @throw RLMPredicateException(@"Invalid predicate", @"The '%@' function is not supported on the result of a SUBQUERY.", functionExpression.function);
+    }
+
+    NSExpression *keyPathExpression = functionExpression.arguments.firstObject;
+    if ([keyPathExpression.keyPath isEqualToString:@"@count"]) {
+        apply_subquery_count_expression(objectSchema, functionExpression.operand,  operatorType, right);
+    } else {
+        @throw RLMPredicateException(@"Invalid predicate", @"SUBQUERY is only supported when immediately followed by .@count that is compared with a constant number.");
+    }
+}
+
+void QueryBuilder::apply_function_expression(RLMObjectSchema *objectSchema, NSExpression *functionExpression,
+                                             NSPredicateOperatorType operatorType, NSExpression *right) {
+    if (functionExpression.operand.expressionType == NSSubqueryExpressionType) {
+        apply_function_subquery_expression(objectSchema, functionExpression, operatorType, right);
+    } else {
+        @throw RLMPredicateException(@"Invalid predicate", @"The '%@' function is not supported.", functionExpression.function);
+    }
+}
+
+
+void QueryBuilder::apply_predicate(NSPredicate *predicate, RLMObjectSchema *objectSchema)
+{
+    // Compound predicates.
+    if ([predicate isMemberOfClass:[NSCompoundPredicate class]]) {
+        NSCompoundPredicate *comp = (NSCompoundPredicate *)predicate;
+
+        switch ([comp compoundPredicateType]) {
+            case NSAndPredicateType:
+                if (comp.subpredicates.count) {
+                    // Add all of the subpredicates.
+                    m_query.group();
+                    for (NSPredicate *subp in comp.subpredicates) {
+                        apply_predicate(subp, objectSchema);
+                    }
+                    m_query.end_group();
+                } else {
+                    // NSCompoundPredicate's documentation states that an AND predicate with no subpredicates evaluates to TRUE.
+                    m_query.and_query(std::unique_ptr<Expression>(new TrueExpression));
+                }
+                break;
+
+            case NSOrPredicateType: {
+                // Add all of the subpredicates with ors inbetween.
+                process_or_group(m_query, comp.subpredicates, [&](__unsafe_unretained NSPredicate *const subp) {
+                    apply_predicate(subp, objectSchema);
+                });
+                break;
+            }
+
+            case NSNotPredicateType:
+                // Add the negated subpredicate
+                m_query.Not();
+                apply_predicate(comp.subpredicates.firstObject, objectSchema);
+                break;
+
+            default:
+                @throw RLMPredicateException(@"Invalid compound predicate type",
+                                             @"Only support AND, OR and NOT predicate types");
+        }
+    }
+    else if ([predicate isMemberOfClass:[NSComparisonPredicate class]]) {
+        NSComparisonPredicate *compp = (NSComparisonPredicate *)predicate;
+
+        // check modifier
+        RLMPrecondition(compp.comparisonPredicateModifier != NSAllPredicateModifier,
+                        @"Invalid predicate", @"ALL modifier not supported");
+
+        NSExpressionType exp1Type = compp.leftExpression.expressionType;
+        NSExpressionType exp2Type = compp.rightExpression.expressionType;
+
+        if (compp.comparisonPredicateModifier == NSAnyPredicateModifier) {
+            // for ANY queries
+            RLMPrecondition(exp1Type == NSKeyPathExpressionType && exp2Type == NSConstantValueExpressionType,
+                            @"Invalid predicate",
+                            @"Predicate with ANY modifier must compare a KeyPath with RLMArray with a value");
+        }
+
+        if (compp.predicateOperatorType == NSBetweenPredicateOperatorType || compp.predicateOperatorType == NSInPredicateOperatorType) {
+            // Inserting an array via %@ gives NSConstantValueExpressionType, but including it directly gives NSAggregateExpressionType
+            if (exp1Type == NSKeyPathExpressionType && (exp2Type == NSAggregateExpressionType || exp2Type == NSConstantValueExpressionType)) {
+                // "key.path IN %@", "key.path IN {…}", "key.path BETWEEN %@", or "key.path BETWEEN {…}".
+                exp2Type = NSConstantValueExpressionType;
+            }
+            else if (compp.predicateOperatorType == NSInPredicateOperatorType && exp1Type == NSConstantValueExpressionType && exp2Type == NSKeyPathExpressionType) {
+                // "%@ IN key.path" is equivalent to "ANY key.path IN %@". Rewrite the former into the latter.
+                compp = [NSComparisonPredicate predicateWithLeftExpression:compp.rightExpression rightExpression:compp.leftExpression
+                                                                  modifier:NSAnyPredicateModifier type:NSEqualToPredicateOperatorType options:0];
+                exp1Type = NSKeyPathExpressionType;
+                exp2Type = NSConstantValueExpressionType;
+            }
+            else {
+                if (compp.predicateOperatorType == NSBetweenPredicateOperatorType) {
+                    @throw RLMPredicateException(@"Invalid predicate",
+                                                 @"Predicate with BETWEEN operator must compare a KeyPath with an aggregate with two values");
+                }
+                else if (compp.predicateOperatorType == NSInPredicateOperatorType) {
+                    @throw RLMPredicateException(@"Invalid predicate",
+                                                 @"Predicate with IN operator must compare a KeyPath with an aggregate");
+                }
+            }
+        }
+
+        if (exp1Type == NSKeyPathExpressionType && exp2Type == NSKeyPathExpressionType) {
+            // both expression are KeyPaths
+            apply_column_expression(objectSchema, compp.leftExpression.keyPath, compp.rightExpression.keyPath, compp);
+        }
+        else if (exp1Type == NSKeyPathExpressionType && exp2Type == NSConstantValueExpressionType) {
+            // comparing keypath to value
+            apply_value_expression(objectSchema, compp.leftExpression.keyPath, compp.rightExpression.constantValue, compp);
+        }
+        else if (exp1Type == NSConstantValueExpressionType && exp2Type == NSKeyPathExpressionType) {
+            // comparing value to keypath
+            apply_value_expression(objectSchema, compp.rightExpression.keyPath, compp.leftExpression.constantValue, compp);
+        }
+        else if (exp1Type == NSFunctionExpressionType) {
+            apply_function_expression(objectSchema, compp.leftExpression, compp.predicateOperatorType, compp.rightExpression);
+        }
+        else if (exp1Type == NSSubqueryExpressionType) {
+            // The subquery expressions that we support are handled by the NSFunctionExpressionType case above.
+            @throw RLMPredicateException(@"Invalid predicate expression", @"SUBQUERY is only supported when immediately followed by .@count.");
+        }
+        else {
+            @throw RLMPredicateException(@"Invalid predicate expressions",
+                                         @"Predicate expressions must compare a keypath and another keypath or a constant value");
+        }
+    }
+    else if ([predicate isEqual:[NSPredicate predicateWithValue:YES]]) {
+        m_query.and_query(std::unique_ptr<Expression>(new TrueExpression));
+    } else if ([predicate isEqual:[NSPredicate predicateWithValue:NO]]) {
+        m_query.and_query(std::unique_ptr<Expression>(new FalseExpression));
+    }
+    else {
+        // invalid predicate type
+        @throw RLMPredicateException(@"Invalid predicate",
+                                     @"Only support compound, comparison, and constant predicates");
+    }
+}
+
+size_t RLMValidatedColumnForSort(Table& table, NSString *propName) {
+    RLMPrecondition([propName rangeOfString:@"."].location == NSNotFound,
+                    @"Invalid sort property", @"Cannot sort on '%@': sorting on key paths is not supported.", propName);
+    size_t column = table.get_column_index(propName.UTF8String);
+    RLMPrecondition(column != npos, @"Invalid sort property",
+                    @"Cannot sort on property '%@' on object of type '%s': property not found.",
+                    propName, ObjectStore::object_type_for_table_name(table.get_name()).data());
+
+    switch (auto type = static_cast<RLMPropertyType>(table.get_column_type(column))) {
+        case RLMPropertyTypeBool:
+        case RLMPropertyTypeDate:
+        case RLMPropertyTypeDouble:
+        case RLMPropertyTypeFloat:
+        case RLMPropertyTypeInt:
+        case RLMPropertyTypeString:
+            break;
+
+        default:
+            @throw RLMPredicateException(@"Invalid sort property type",
+                                         @"Cannot sort on property '%@' on object of type '%s': sorting is only supported on bool, date, double, float, integer, and string properties, but property is of type %@.",
+                                         propName, ObjectStore::object_type_for_table_name(table.get_name()).data(),
+                                         RLMTypeToString(type));
+    }
+    return column;
+}
+
+} // namespace
+
+realm::Query RLMPredicateToQuery(NSPredicate *predicate, RLMObjectSchema *objectSchema,
+                                 RLMSchema *schema, Group &group)
+{
+    auto query = get_table(group, objectSchema).where();
+
+    // passing a nil predicate is a no-op
+    if (!predicate) {
+        return query;
+    }
+
+    @autoreleasepool {
+        QueryBuilder(query, group, schema).apply_predicate(predicate, objectSchema);
+    }
+
+    // Test the constructed query in core
+    std::string validateMessage = query.validate();
+    RLMPrecondition(validateMessage.empty(), @"Invalid query", @"%.*s",
+                    (int)validateMessage.size(), validateMessage.c_str());
+    return query;
+}
+
+realm::SortOrder RLMSortOrderFromDescriptors(realm::Table& table, NSArray<RLMSortDescriptor *> *descriptors) {
+    realm::SortOrder sort;
+    sort.column_indices.reserve(descriptors.count);
+    sort.ascending.reserve(descriptors.count);
+
+    for (RLMSortDescriptor *descriptor in descriptors) {
+        sort.column_indices.push_back(RLMValidatedColumnForSort(table, descriptor.property));
+        sort.ascending.push_back(descriptor.ascending);
+    }
+
+    return sort;
+}
diff --git a/Pods/Realm/Realm/RLMRealm.mm b/Pods/Realm/Realm/RLMRealm.mm
new file mode 100644
index 0000000..466b5bb
--- /dev/null
+++ b/Pods/Realm/Realm/RLMRealm.mm
@@ -0,0 +1,748 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import "RLMRealm_Private.hpp"
+
+#import "RLMAnalytics.hpp"
+#import "RLMArray_Private.hpp"
+#import "RLMRealmConfiguration_Private.hpp"
+#import "RLMMigration_Private.h"
+#import "RLMObjectSchema_Private.hpp"
+#import "RLMProperty_Private.h"
+#import "RLMObjectStore.h"
+#import "RLMObject_Private.h"
+#import "RLMObject_Private.hpp"
+#import "RLMObservation.hpp"
+#import "RLMProperty.h"
+#import "RLMQueryUtil.hpp"
+#import "RLMRealmUtil.hpp"
+#import "RLMSchema_Private.hpp"
+#import "RLMUpdateChecker.hpp"
+#import "RLMUtil.hpp"
+
+#include "impl/realm_coordinator.hpp"
+#include "object_store.hpp"
+#include "schema.hpp"
+#include "shared_realm.hpp"
+
+#include <realm/commit_log.hpp>
+#include <realm/disable_sync_to_disk.hpp>
+#include <realm/version.hpp>
+
+using namespace realm;
+using util::File;
+
+@interface RLMRealm ()
+@property (nonatomic, strong) NSHashTable *notificationHandlers;
+- (void)sendNotifications:(RLMNotification)notification;
+@end
+
+void RLMDisableSyncToDisk() {
+    realm::disable_sync_to_disk();
+}
+
+// Notification Token
+@interface RLMRealmNotificationToken : RLMNotificationToken
+@property (nonatomic, strong) RLMRealm *realm;
+@property (nonatomic, copy) RLMNotificationBlock block;
+@end
+
+@implementation RLMRealmNotificationToken
+- (void)stop {
+    [_realm verifyThread];
+    [_realm.notificationHandlers removeObject:self];
+    _realm = nil;
+    _block = nil;
+}
+
+- (void)dealloc {
+    if (_realm || _block) {
+        NSLog(@"RLMNotificationToken released without unregistering a notification. You must hold "
+              @"on to the RLMNotificationToken returned from addNotificationBlock and call "
+              @"-[RLMNotificationToken stop] when you no longer wish to receive RLMRealm notifications.");
+    }
+}
+@end
+
+static bool shouldForciblyDisableEncryption() {
+    static bool disableEncryption = getenv("REALM_DISABLE_ENCRYPTION");
+    return disableEncryption;
+}
+
+NSData *RLMRealmValidatedEncryptionKey(NSData *key) {
+    if (shouldForciblyDisableEncryption()) {
+        return nil;
+    }
+
+    if (key) {
+        if (key.length != 64) {
+            @throw RLMException(@"Encryption key must be exactly 64 bytes long");
+        }
+#if TARGET_OS_WATCH
+        @throw RLMException(@"Cannot open an encrypted Realm on watchOS.");
+#endif
+    }
+
+    return key;
+}
+
+@implementation RLMRealm {
+    NSHashTable *_collectionEnumerators;
+}
+
++ (BOOL)isCoreDebug {
+    return realm::Version::has_feature(realm::feature_Debug);
+}
+
++ (void)initialize {
+    static bool initialized;
+    if (initialized) {
+        return;
+    }
+    initialized = true;
+
+    RLMCheckForUpdates();
+    RLMInstallUncaughtExceptionHandler();
+    RLMSendAnalytics();
+}
+
+- (BOOL)isEmpty {
+    return realm::ObjectStore::is_empty(self.group);
+}
+
+- (void)verifyThread {
+    _realm->verify_thread();
+}
+
+- (BOOL)inWriteTransaction {
+    return _realm->is_in_transaction();
+}
+
+- (realm::Group *)group {
+    return _realm->read_group();
+}
+
+- (BOOL)autorefresh {
+    return _realm->auto_refresh();
+}
+
+- (void)setAutorefresh:(BOOL)autorefresh {
+    _realm->set_auto_refresh(autorefresh);
+}
+
++ (NSString *)writeableTemporaryPathForFile:(NSString *)fileName {
+    return [NSTemporaryDirectory() stringByAppendingPathComponent:fileName];
+}
+
++ (instancetype)defaultRealm {
+    return [RLMRealm realmWithConfiguration:[RLMRealmConfiguration rawDefaultConfiguration] error:nil];
+}
+
++ (instancetype)realmWithURL:(NSURL *)fileURL {
+    RLMRealmConfiguration *configuration = [RLMRealmConfiguration defaultConfiguration];
+    configuration.fileURL = fileURL;
+    return [RLMRealm realmWithConfiguration:configuration error:nil];
+}
+// ARC tries to eliminate calls to autorelease when the value is then immediately
+// returned, but this results in significantly different semantics between debug
+// and release builds for RLMRealm, so force it to always autorelease.
+static id RLMAutorelease(id value) {
+    // +1 __bridge_retained, -1 CFAutorelease
+    return value ? (__bridge id)CFAutorelease((__bridge_retained CFTypeRef)value) : nil;
+}
+
+static void RLMCopyColumnMapping(RLMObjectSchema *targetSchema, const ObjectSchema &tableSchema) {
+    REALM_ASSERT_DEBUG(targetSchema.properties.count == tableSchema.persisted_properties.size());
+
+    // copy updated column mapping
+    for (auto const& prop : tableSchema.persisted_properties) {
+        RLMProperty *targetProp = targetSchema[@(prop.name.c_str())];
+        targetProp.column = prop.table_column;
+    }
+}
+
+static void RLMRealmSetSchemaAndAlign(RLMRealm *realm, RLMSchema *targetSchema) {
+    realm.schema = targetSchema;
+    for (auto const& aligned : *realm->_realm->config().schema) {
+        if (RLMObjectSchema *objectSchema = [targetSchema schemaForClassName:@(aligned.name.c_str())]) {
+            objectSchema.realm = realm;
+            RLMCopyColumnMapping(objectSchema, aligned);
+        }
+    }
+}
+
++ (instancetype)realmWithSharedRealm:(SharedRealm)sharedRealm schema:(RLMSchema *)schema {
+    RLMRealm *realm = [RLMRealm new];
+    realm->_realm = sharedRealm;
+    realm->_dynamic = YES;
+    RLMRealmSetSchemaAndAlign(realm, schema);
+    return RLMAutorelease(realm);
+}
+
+REALM_NOINLINE void RLMRealmTranslateException(NSError **error) {
+    try {
+        throw;
+    }
+    catch (RealmFileException const& ex) {
+        switch (ex.kind()) {
+            case RealmFileException::Kind::PermissionDenied:
+                RLMSetErrorOrThrow(RLMMakeError(RLMErrorFilePermissionDenied, ex), error);
+                break;
+            case RealmFileException::Kind::IncompatibleLockFile: {
+                NSString *err = @"Realm file is currently open in another process "
+                                 "which cannot share access with this process. All "
+                                 "processes sharing a single file must be the same "
+                                 "architecture. For sharing files between the Realm "
+                                 "Browser and an iOS simulator, this means that you "
+                                 "must use a 64-bit simulator.";
+                RLMSetErrorOrThrow(RLMMakeError(RLMErrorIncompatibleLockFile,
+                                                File::PermissionDenied(err.UTF8String, ex.path())), error);
+                break;
+            }
+            case RealmFileException::Kind::NotFound:
+                RLMSetErrorOrThrow(RLMMakeError(RLMErrorFileNotFound, ex), error);
+                break;
+            case RealmFileException::Kind::Exists:
+                RLMSetErrorOrThrow(RLMMakeError(RLMErrorFileExists, ex), error);
+                break;
+            case RealmFileException::Kind::AccessError:
+                RLMSetErrorOrThrow(RLMMakeError(RLMErrorFileAccess, ex), error);
+                break;
+            case RealmFileException::Kind::FormatUpgradeRequired:
+                RLMSetErrorOrThrow(RLMMakeError(RLMErrorFileFormatUpgradeRequired, ex), error);
+                break;
+            default:
+                RLMSetErrorOrThrow(RLMMakeError(RLMErrorFail, ex), error);
+                break;
+        }
+    }
+    catch (AddressSpaceExhausted const &ex) {
+        RLMSetErrorOrThrow(RLMMakeError(RLMErrorAddressSpaceExhausted, ex), error);
+    }
+    catch (SchemaMismatchException const& ex) {
+        RLMSetErrorOrThrow(RLMMakeError(RLMErrorSchemaMismatch, ex), error);
+    }
+    catch (std::system_error const& ex) {
+        RLMSetErrorOrThrow(RLMMakeError(ex), error);
+    }
+    catch (const std::exception &exp) {
+        RLMSetErrorOrThrow(RLMMakeError(RLMErrorFail, exp), error);
+    }
+}
+
++ (SharedRealm)openSharedRealm:(Realm::Config const&)config error:(NSError **)outError {
+    try {
+        return Realm::get_shared_realm(config);
+    }
+    catch (...) {
+        if (config.delete_realm_if_migration_needed) {
+            throw;
+        } else {
+            RLMRealmTranslateException(outError);
+        }
+    }
+    return nullptr;
+}
+
++ (instancetype)realmWithConfiguration:(RLMRealmConfiguration *)configuration error:(NSError **)error {
+    bool dynamic = configuration.dynamic;
+    bool readOnly = configuration.readOnly;
+
+    {
+        Realm::Config& config = configuration.config;
+
+        // try to reuse existing realm first
+        if (config.cache || dynamic) {
+            if (RLMRealm *realm = RLMGetThreadLocalCachedRealmForPath(config.path)) {
+                auto const& old_config = realm->_realm->config();
+                if (old_config.read_only != config.read_only) {
+                    @throw RLMException(@"Realm at path '%s' already opened with different read permissions", config.path.c_str());
+                }
+                if (old_config.in_memory != config.in_memory) {
+                    @throw RLMException(@"Realm at path '%s' already opened with different inMemory settings", config.path.c_str());
+                }
+                if (realm->_dynamic != dynamic) {
+                    @throw RLMException(@"Realm at path '%s' already opened with different dynamic settings", config.path.c_str());
+                }
+                if (old_config.encryption_key != config.encryption_key) {
+                    @throw RLMException(@"Realm at path '%s' already opened with different encryption key", config.path.c_str());
+                }
+                return RLMAutorelease(realm);
+            }
+        }
+    }
+
+    configuration = [configuration copy];
+    Realm::Config& config = configuration.config;
+
+    RLMRealm *realm = [RLMRealm new];
+    realm->_dynamic = dynamic;
+
+    auto migrationBlock = configuration.migrationBlock;
+    if (migrationBlock && config.schema_version > 0) {
+        auto customSchema = configuration.customSchema;
+        config.migration_function = [=](SharedRealm old_realm, SharedRealm realm) {
+            RLMSchema *oldSchema = [RLMSchema dynamicSchemaFromObjectStoreSchema:*old_realm->config().schema];
+            RLMRealm *oldRealm = [RLMRealm realmWithSharedRealm:old_realm schema:oldSchema];
+
+            // The destination RLMRealm can't just use the schema from the
+            // SharedRealm because it doesn't have information about whether or
+            // not a class was defined in Swift, which effects how new objects
+            // are created
+            RLMSchema *newSchema = [customSchema ?: RLMSchema.sharedSchema copy];
+            RLMRealm *newRealm = [RLMRealm realmWithSharedRealm:realm schema:newSchema];
+
+            [[[RLMMigration alloc] initWithRealm:newRealm oldRealm:oldRealm] execute:migrationBlock];
+
+            oldRealm->_realm = nullptr;
+            newRealm->_realm = nullptr;
+        };
+    }
+    else {
+        config.migration_function = [](SharedRealm, SharedRealm) { };
+    }
+
+    bool beganReadTransaction = false;
+
+    // protects the realm cache and accessors cache
+    static id initLock = [NSObject new];
+    @synchronized(initLock) {
+        try {
+            realm->_realm = [self openSharedRealm:config error:error];
+        }
+        catch (SchemaMismatchException const& ex) {
+            if (configuration.deleteRealmIfMigrationNeeded) {
+                BOOL success = [[NSFileManager defaultManager] removeItemAtURL:configuration.fileURL error:nil];
+                if (success) {
+                    realm->_realm = [self openSharedRealm:config error:error];
+                } else {
+                    RLMSetErrorOrThrow(RLMMakeError(RLMErrorSchemaMismatch, ex), error);
+                    return nil;
+                }
+            } else {
+                RLMSetErrorOrThrow(RLMMakeError(RLMErrorSchemaMismatch, ex), error);
+                return nil;
+            }
+        }
+        if (!realm->_realm) {
+            return nil;
+        }
+
+        // if we have a cached realm on another thread, copy without a transaction
+        if (RLMRealm *cachedRealm = RLMGetAnyCachedRealmForPath(config.path)) {
+            realm.schema = [cachedRealm.schema shallowCopy];
+            for (RLMObjectSchema *objectSchema in realm.schema.objectSchema) {
+                objectSchema.realm = realm;
+            }
+        }
+        else {
+            beganReadTransaction = !realm->_realm->is_in_read_transaction();
+
+            try {
+                // set/align schema or perform migration if needed
+                RLMSchema *schema = [configuration.customSchema copy];
+                if (!schema) {
+                    if (dynamic) {
+                        schema = [RLMSchema dynamicSchemaFromObjectStoreSchema:*realm->_realm->config().schema];
+                    }
+                    else {
+                        schema = [RLMSchema.sharedSchema copy];
+                        realm->_realm->update_schema(schema.objectStoreCopy, config.schema_version);
+                    }
+                }
+
+                RLMRealmSetSchemaAndAlign(realm, schema);
+            } catch (SchemaMismatchException const& ex) {
+                if (configuration.deleteRealmIfMigrationNeeded) {
+                    BOOL success = [[NSFileManager defaultManager] removeItemAtURL:configuration.fileURL error:nil];
+                    if (success) {
+                        realm->_realm->close();
+                        realm = nil;
+                        return [self realmWithConfiguration:configuration error:error];
+                    }
+                }
+
+                RLMSetErrorOrThrow(RLMMakeError(RLMErrorSchemaMismatch, ex), error);
+                return nil;
+            } catch (std::exception const& exception) {
+                RLMSetErrorOrThrow(RLMMakeError(RLMException(exception)), error);
+                return nil;
+            }
+
+            if (!dynamic || configuration.customSchema) {
+                RLMRealmCreateAccessors(realm.schema);
+            }
+        }
+
+        if (config.cache) {
+            RLMCacheRealm(config.path, realm);
+        }
+    }
+
+    if (!readOnly) {
+        // initializing the schema started a read transaction, so end it
+        if (beganReadTransaction) {
+            [realm invalidate];
+        }
+        realm->_realm->m_binding_context = RLMCreateBindingContext(realm);
+    }
+
+    return RLMAutorelease(realm);
+}
+
++ (void)resetRealmState {
+    RLMClearRealmCache();
+    realm::_impl::RealmCoordinator::clear_cache();
+    [RLMRealmConfiguration resetRealmConfigurationState];
+}
+
+- (void)verifyNotificationsAreSupported {
+    [self verifyThread];
+    if (_realm->config().read_only) {
+        @throw RLMException(@"Read-only Realms do not change and do not have change notifications");
+    }
+    if (!_realm->can_deliver_notifications()) {
+        @throw RLMException(@"Can only add notification blocks from within runloops.");
+    }
+}
+
+- (RLMNotificationToken *)addNotificationBlock:(RLMNotificationBlock)block {
+    if (!block) {
+        @throw RLMException(@"The notification block should not be nil");
+    }
+    [self verifyNotificationsAreSupported];
+
+    _realm->read_group();
+
+    if (!_notificationHandlers) {
+        _notificationHandlers = [NSHashTable hashTableWithOptions:NSPointerFunctionsWeakMemory];
+    }
+
+    RLMRealmNotificationToken *token = [[RLMRealmNotificationToken alloc] init];
+    token.realm = self;
+    token.block = block;
+    [_notificationHandlers addObject:token];
+    return token;
+}
+
+- (void)sendNotifications:(RLMNotification)notification {
+    NSAssert(!_realm->config().read_only, @"Read-only realms do not have notifications");
+
+    NSUInteger count = _notificationHandlers.count;
+    if (count == 0) {
+        return;
+    }
+    // call this realms notification blocks
+    if (count == 1) {
+        if (auto block = [_notificationHandlers.anyObject block]) {
+            block(notification, self);
+        }
+    }
+    else {
+        for (RLMRealmNotificationToken *token in _notificationHandlers.allObjects) {
+            if (auto block = token.block) {
+                block(notification, self);
+            }
+        }
+    }
+}
+
+- (RLMRealmConfiguration *)configuration {
+    RLMRealmConfiguration *configuration = [[RLMRealmConfiguration alloc] init];
+    configuration.config = _realm->config();
+    configuration.dynamic = _dynamic;
+    configuration.customSchema = _schema;
+    return configuration;
+}
+
+- (void)beginWriteTransaction {
+    try {
+        _realm->begin_transaction();
+    }
+    catch (std::exception &ex) {
+        @throw RLMException(ex);
+    }
+}
+
+- (void)commitWriteTransaction {
+    [self commitWriteTransaction:nil];
+}
+
+- (BOOL)commitWriteTransaction:(NSError **)outError {
+    try {
+        _realm->commit_transaction();
+        return YES;
+    }
+    catch (...) {
+        RLMRealmTranslateException(outError);
+        return NO;
+    }
+}
+
+- (void)transactionWithBlock:(void(^)(void))block {
+    [self transactionWithBlock:block error:nil];
+}
+
+- (BOOL)transactionWithBlock:(void(^)(void))block error:(NSError **)outError {
+    [self beginWriteTransaction];
+    block();
+    if (_realm->is_in_transaction()) {
+        return [self commitWriteTransaction:outError];
+    }
+    return YES;
+}
+
+- (void)cancelWriteTransaction {
+    try {
+        _realm->cancel_transaction();
+    }
+    catch (std::exception &ex) {
+        @throw RLMException(ex);
+    }
+}
+
+- (void)invalidate {
+    if (_realm->is_in_transaction()) {
+        NSLog(@"WARNING: An RLMRealm instance was invalidated during a write "
+              "transaction and all pending changes have been rolled back.");
+    }
+
+    [self detachAllEnumerators];
+
+    for (RLMObjectSchema *objectSchema in _schema.objectSchema) {
+        for (RLMObservationInfo *info : objectSchema->_observedObjects) {
+            info->willChange(RLMInvalidatedKey);
+        }
+    }
+
+    _realm->invalidate();
+
+    for (RLMObjectSchema *objectSchema in _schema.objectSchema) {
+        for (RLMObservationInfo *info : objectSchema->_observedObjects) {
+            info->didChange(RLMInvalidatedKey);
+        }
+        objectSchema.table = nullptr;
+    }
+}
+
+/**
+ Replaces all string columns in this Realm with a string enumeration column and compacts the
+ database file.
+ 
+ Cannot be called from a write transaction.
+
+ Compaction will not occur if other `RLMRealm` instances exist.
+ 
+ While compaction is in progress, attempts by other threads or processes to open the database will
+ wait.
+ 
+ Be warned that resource requirements for compaction is proportional to the amount of live data in
+ the database.
+ 
+ Compaction works by writing the database contents to a temporary database file and then replacing
+ the database with the temporary one. The name of the temporary file is formed by appending
+ `.tmp_compaction_space` to the name of the database.
+
+ @return YES if the compaction succeeded.
+ */
+- (BOOL)compact {
+    // compact() automatically ends the read transaction, but we need to clean
+    // up cached state and send invalidated notifications when that happens, so
+    // explicitly end it first unless we're in a write transaction (in which
+    // case compact() will throw an exception)
+    if (!_realm->is_in_transaction()) {
+        [self invalidate];
+    }
+
+    try {
+        return _realm->compact();
+    }
+    catch (std::exception const& ex) {
+        @throw RLMException(ex);
+    }
+}
+
+- (void)dealloc {
+    if (_realm) {
+        if (_realm->is_in_transaction()) {
+            [self cancelWriteTransaction];
+            NSLog(@"WARNING: An RLMRealm instance was deallocated during a write transaction and all "
+                  "pending changes have been rolled back. Make sure to retain a reference to the "
+                  "RLMRealm for the duration of the write transaction.");
+        }
+    }
+}
+
+- (BOOL)refresh {
+    return _realm->refresh();
+}
+
+- (void)addObject:(__unsafe_unretained RLMObject *const)object {
+    RLMAddObjectToRealm(object, self, false);
+}
+
+- (void)addObjects:(id<NSFastEnumeration>)array {
+    for (RLMObject *obj in array) {
+        if (![obj isKindOfClass:[RLMObject class]]) {
+            @throw RLMException(@"Cannot insert objects of type %@ with addObjects:. Only RLMObjects are supported.",
+                                NSStringFromClass(obj.class));
+        }
+        [self addObject:obj];
+    }
+}
+
+- (void)addOrUpdateObject:(RLMObject *)object {
+    // verify primary key
+    if (!object.objectSchema.primaryKeyProperty) {
+        @throw RLMException(@"'%@' does not have a primary key and can not be updated", object.objectSchema.className);
+    }
+
+    RLMAddObjectToRealm(object, self, true);
+}
+
+- (void)addOrUpdateObjectsFromArray:(id)array {
+    for (RLMObject *obj in array) {
+        [self addOrUpdateObject:obj];
+    }
+}
+
+- (void)deleteObject:(RLMObject *)object {
+    RLMDeleteObjectFromRealm(object, self);
+}
+
+- (void)deleteObjects:(id)array {
+    if ([array respondsToSelector:@selector(realm)] && [array respondsToSelector:@selector(deleteObjectsFromRealm)]) {
+        if (self != (RLMRealm *)[array realm]) {
+            @throw RLMException(@"Can only delete objects from the Realm they belong to.");
+        }
+        [array deleteObjectsFromRealm];
+    }
+    else if ([array conformsToProtocol:@protocol(NSFastEnumeration)]) {
+        for (id obj in array) {
+            if ([obj isKindOfClass:RLMObjectBase.class]) {
+                RLMDeleteObjectFromRealm(obj, self);
+            }
+        }
+    }
+    else {
+        @throw RLMException(@"Invalid array type - container must be an RLMArray, RLMArray, or NSArray of RLMObjects");
+    }
+}
+
+- (void)deleteAllObjects {
+    RLMDeleteAllObjectsFromRealm(self);
+}
+
+- (RLMResults *)allObjects:(NSString *)objectClassName {
+    return RLMGetObjects(self, objectClassName, nil);
+}
+
+- (RLMResults *)objects:(NSString *)objectClassName where:(NSString *)predicateFormat, ... {
+    va_list args;
+    va_start(args, predicateFormat);
+    RLMResults *results = [self objects:objectClassName where:predicateFormat args:args];
+    va_end(args);
+    return results;
+}
+
+- (RLMResults *)objects:(NSString *)objectClassName where:(NSString *)predicateFormat args:(va_list)args {
+    return [self objects:objectClassName withPredicate:[NSPredicate predicateWithFormat:predicateFormat arguments:args]];
+}
+
+- (RLMResults *)objects:(NSString *)objectClassName withPredicate:(NSPredicate *)predicate {
+    return RLMGetObjects(self, objectClassName, predicate);
+}
+
+- (RLMObject *)objectWithClassName:(NSString *)className forPrimaryKey:(id)primaryKey {
+    return RLMGetObject(self, className, primaryKey);
+}
+
++ (uint64_t)schemaVersionAtURL:(NSURL *)fileURL encryptionKey:(NSData *)key error:(NSError **)error {
+    try {
+        RLMRealmConfiguration *config = [[RLMRealmConfiguration alloc] init];
+        config.fileURL = fileURL;
+        config.encryptionKey = RLMRealmValidatedEncryptionKey(key);
+
+        uint64_t version = Realm::get_schema_version(config.config);
+        if (version == realm::ObjectStore::NotVersioned) {
+            RLMSetErrorOrThrow([NSError errorWithDomain:RLMErrorDomain code:RLMErrorFail userInfo:@{NSLocalizedDescriptionKey:@"Cannot open an uninitialized realm in read-only mode"}], error);
+        }
+        return version;
+    }
+    catch (std::exception &exp) {
+        RLMSetErrorOrThrow(RLMMakeError(RLMErrorFail, exp), error);
+        return RLMNotVersioned;
+    }
+}
+
++ (NSError *)migrateRealm:(RLMRealmConfiguration *)configuration {
+    if (RLMGetAnyCachedRealmForPath(configuration.config.path)) {
+        @throw RLMException(@"Cannot migrate Realms that are already open.");
+    }
+
+    @autoreleasepool {
+        NSError *error = nil;
+        [RLMRealm realmWithConfiguration:configuration error:&error];
+        return error;
+    }
+}
+
+- (RLMObject *)createObject:(NSString *)className withValue:(id)value {
+    return (RLMObject *)RLMCreateObjectInRealmWithValue(self, className, value, false);
+}
+
+- (BOOL)writeCopyToURL:(NSURL *)fileURL encryptionKey:(NSData *)key error:(NSError **)error {
+    key = RLMRealmValidatedEncryptionKey(key);
+    NSString *path = fileURL.path;
+
+    try {
+        _realm->write_copy(path.UTF8String, {static_cast<const char *>(key.bytes), key.length});
+        return YES;
+    }
+    catch (...) {
+        __autoreleasing NSError *dummyError;
+        if (!error) {
+            error = &dummyError;
+        }
+        RLMRealmTranslateException(error);
+        return NO;
+    }
+
+    return NO;
+}
+
+- (void)registerEnumerator:(RLMFastEnumerator *)enumerator {
+    if (!_collectionEnumerators) {
+        _collectionEnumerators = [NSHashTable hashTableWithOptions:NSPointerFunctionsWeakMemory];
+    }
+    [_collectionEnumerators addObject:enumerator];
+
+}
+
+- (void)unregisterEnumerator:(RLMFastEnumerator *)enumerator {
+    [_collectionEnumerators removeObject:enumerator];
+}
+
+- (void)detachAllEnumerators {
+    for (RLMFastEnumerator *enumerator in _collectionEnumerators) {
+        [enumerator detach];
+    }
+    _collectionEnumerators = nil;
+}
+
+@end
diff --git a/Pods/Realm/Realm/RLMRealmConfiguration.mm b/Pods/Realm/Realm/RLMRealmConfiguration.mm
new file mode 100644
index 0000000..59903e3
--- /dev/null
+++ b/Pods/Realm/Realm/RLMRealmConfiguration.mm
@@ -0,0 +1,278 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2015 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import "RLMRealmConfiguration_Private.h"
+
+#import "RLMObjectSchema_Private.hpp"
+#import "RLMRealm_Private.h"
+#import "RLMSchema_Private.hpp"
+#import "RLMUtil.hpp"
+
+#import "schema.hpp"
+#import "shared_realm.hpp"
+
+static NSString *const c_RLMRealmConfigurationProperties[] = {
+    @"fileURL",
+    @"inMemoryIdentifier",
+    @"encryptionKey",
+    @"readOnly",
+    @"schemaVersion",
+    @"migrationBlock",
+    @"deleteRealmIfMigrationNeeded",
+    @"dynamic",
+    @"customSchema",
+};
+
+static NSString *const c_defaultRealmFileName = @"default.realm";
+RLMRealmConfiguration *s_defaultConfiguration;
+
+static NSString *defaultDirectoryForBundleIdentifier(NSString *bundleIdentifier) {
+#if TARGET_OS_TV
+    (void)bundleIdentifier;
+    // tvOS prohibits writing to the Documents directory, so we use the Library/Caches directory instead.
+    return NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0];
+#elif TARGET_OS_IPHONE
+    (void)bundleIdentifier;
+    // On iOS the Documents directory isn't user-visible, so put files there
+    return NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0];
+#else
+    // On OS X it is, so put files in Application Support. If we aren't running
+    // in a sandbox, put it in a subdirectory based on the bundle identifier
+    // to avoid accidentally sharing files between applications
+    NSString *path = NSSearchPathForDirectoriesInDomains(NSApplicationSupportDirectory, NSUserDomainMask, YES)[0];
+    if (![[NSProcessInfo processInfo] environment][@"APP_SANDBOX_CONTAINER_ID"]) {
+        if (!bundleIdentifier) {
+            bundleIdentifier = [NSBundle mainBundle].bundleIdentifier;
+        }
+        if (!bundleIdentifier) {
+            bundleIdentifier = [NSBundle mainBundle].executablePath.lastPathComponent;
+        }
+
+        path = [path stringByAppendingPathComponent:bundleIdentifier];
+
+        // create directory
+        [[NSFileManager defaultManager] createDirectoryAtPath:path
+                                  withIntermediateDirectories:YES
+                                                   attributes:nil
+                                                        error:nil];
+    }
+    return path;
+#endif
+}
+
+NSString *RLMRealmPathForFileAndBundleIdentifier(NSString *fileName, NSString *bundleIdentifier) {
+    return [defaultDirectoryForBundleIdentifier(bundleIdentifier)
+            stringByAppendingPathComponent:fileName];
+}
+
+NSString *RLMRealmPathForFile(NSString *fileName) {
+    static NSString *directory = defaultDirectoryForBundleIdentifier(nil);
+    return [directory stringByAppendingPathComponent:fileName];
+}
+
+@implementation RLMRealmConfiguration {
+    realm::Realm::Config _config;
+}
+
+- (realm::Realm::Config&)config {
+    return _config;
+}
+
++ (instancetype)defaultConfiguration {
+    return [[self rawDefaultConfiguration] copy];
+}
+
++ (void)setDefaultConfiguration:(RLMRealmConfiguration *)configuration {
+    if (!configuration) {
+        @throw RLMException(@"Cannot set the default configuration to nil.");
+    }
+    @synchronized(c_defaultRealmFileName) {
+        s_defaultConfiguration = [configuration copy];
+    }
+}
+
++ (RLMRealmConfiguration *)rawDefaultConfiguration {
+    @synchronized(c_defaultRealmFileName) {
+        if (!s_defaultConfiguration) {
+            s_defaultConfiguration = [[RLMRealmConfiguration alloc] init];
+        }
+    }
+    return s_defaultConfiguration;
+}
+
++ (void)resetRealmConfigurationState {
+    @synchronized(c_defaultRealmFileName) {
+        s_defaultConfiguration = nil;
+    }
+}
+
+- (instancetype)init {
+    self = [super init];
+    if (self) {
+        static NSURL *defaultRealmURL = [NSURL fileURLWithPath:RLMRealmPathForFile(c_defaultRealmFileName)];
+        self.fileURL = defaultRealmURL;
+        self.schemaVersion = 0;
+    }
+
+    return self;
+}
+
+- (instancetype)copyWithZone:(NSZone *)zone {
+    RLMRealmConfiguration *configuration = [[[self class] allocWithZone:zone] init];
+    configuration->_config = _config;
+    configuration->_dynamic = _dynamic;
+    configuration->_migrationBlock = _migrationBlock;
+    configuration->_customSchema = _customSchema;
+    return configuration;
+}
+
+- (NSString *)description {
+    NSMutableString *string = [NSMutableString stringWithFormat:@"%@ {\n", self.class];
+    for (NSString *key : c_RLMRealmConfigurationProperties) {
+        NSString *description = [[self valueForKey:key] description];
+        description = [description stringByReplacingOccurrencesOfString:@"\n" withString:@"\n\t"];
+
+        [string appendFormat:@"\t%@ = %@;\n", key, description];
+    }
+    return [string stringByAppendingString:@"}"];
+}
+
+static void RLMNSStringToStdString(std::string &out, NSString *in) {
+    out.resize([in maximumLengthOfBytesUsingEncoding:NSUTF8StringEncoding]);
+    if (out.empty()) {
+        return;
+    }
+
+    NSUInteger size = out.size();
+    [in getBytes:&out[0]
+       maxLength:size
+      usedLength:&size
+        encoding:NSUTF8StringEncoding
+         options:0 range:{0, in.length} remainingRange:nullptr];
+    out.resize(size);
+}
+
+- (NSURL *)fileURL {
+    return _config.in_memory ? nil : [NSURL fileURLWithPath:@(_config.path.c_str())];
+}
+
+- (void)setFileURL:(NSURL *)fileURL {
+    NSString *path = fileURL.path;
+    if (path.length == 0) {
+        @throw RLMException(@"Realm path must not be empty");
+    }
+
+    RLMNSStringToStdString(_config.path, path);
+    _config.in_memory = false;
+}
+
+- (NSString *)inMemoryIdentifier {
+    if (!_config.in_memory) {
+        return nil;
+    }
+    return [@(_config.path.c_str()) lastPathComponent];
+}
+
+- (void)setInMemoryIdentifier:(NSString *)inMemoryIdentifier {
+    if (inMemoryIdentifier.length == 0) {
+        @throw RLMException(@"In-memory identifier must not be empty");
+    }
+
+    RLMNSStringToStdString(_config.path, [NSTemporaryDirectory() stringByAppendingPathComponent:inMemoryIdentifier]);
+    _config.in_memory = true;
+}
+
+- (NSData *)encryptionKey {
+    return _config.encryption_key.empty() ? nil : [NSData dataWithBytes:_config.encryption_key.data() length:_config.encryption_key.size()];
+}
+
+- (void)setEncryptionKey:(NSData * __nullable)encryptionKey {
+    if (NSData *key = RLMRealmValidatedEncryptionKey(encryptionKey)) {
+        auto bytes = static_cast<const char *>(key.bytes);
+        _config.encryption_key.assign(bytes, bytes + key.length);
+    }
+    else {
+        _config.encryption_key.clear();
+    }
+}
+
+- (BOOL)readOnly {
+    return _config.read_only;
+}
+
+- (void)setReadOnly:(BOOL)readOnly {
+    _config.read_only = readOnly;
+}
+
+- (uint64_t)schemaVersion {
+    return _config.schema_version;
+}
+
+- (void)setSchemaVersion:(uint64_t)schemaVersion {
+    if (schemaVersion == RLMNotVersioned) {
+        @throw RLMException(@"Cannot set schema version to %llu (RLMNotVersioned)", RLMNotVersioned);
+    }
+    _config.schema_version = schemaVersion;
+}
+
+- (BOOL)deleteRealmIfMigrationNeeded {
+    return _config.delete_realm_if_migration_needed;
+}
+
+- (void)setDeleteRealmIfMigrationNeeded:(BOOL)deleteRealmIfMigrationNeeded {
+    _config.delete_realm_if_migration_needed = deleteRealmIfMigrationNeeded;
+}
+
+- (NSArray *)objectClasses {
+    return [_customSchema.objectSchema valueForKeyPath:@"objectClass"];
+}
+
+- (void)setObjectClasses:(NSArray *)objectClasses {
+    self.customSchema = [RLMSchema schemaWithObjectClasses:objectClasses];
+}
+
+- (void)setDynamic:(bool)dynamic {
+    _dynamic = dynamic;
+    _config.cache = !dynamic;
+}
+
+- (bool)cache {
+    return _config.cache;
+}
+
+- (void)setCache:(bool)cache {
+    _config.cache = cache;
+}
+
+- (void)setCustomSchema:(RLMSchema *)customSchema {
+    _customSchema = customSchema;
+    _config.schema = [_customSchema objectStoreCopy];
+}
+
+- (void)setDisableFormatUpgrade:(bool)disableFormatUpgrade
+{
+    _config.disable_format_upgrade = disableFormatUpgrade;
+}
+
+- (bool)disableFormatUpgrade
+{
+    return _config.disable_format_upgrade;
+}
+
+@end
+
diff --git a/Pods/Realm/Realm/RLMRealmUtil.mm b/Pods/Realm/Realm/RLMRealmUtil.mm
new file mode 100644
index 0000000..205784f
--- /dev/null
+++ b/Pods/Realm/Realm/RLMRealmUtil.mm
@@ -0,0 +1,160 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import "RLMRealmUtil.hpp"
+
+#import "RLMObservation.hpp"
+#import "RLMRealm_Private.h"
+#import "RLMUtil.hpp"
+
+#import <Realm/RLMConstants.h>
+#import <Realm/RLMSchema.h>
+
+#import "binding_context.hpp"
+
+#import <map>
+#import <mutex>
+#import <sys/event.h>
+#import <sys/stat.h>
+#import <sys/time.h>
+#import <unistd.h>
+
+// Global realm state
+static std::mutex s_realmCacheMutex;
+static std::map<std::string, NSMapTable *> s_realmsPerPath;
+
+void RLMCacheRealm(std::string const& path, RLMRealm *realm) {
+    std::lock_guard<std::mutex> lock(s_realmCacheMutex);
+    NSMapTable *realms = s_realmsPerPath[path];
+    if (!realms) {
+        s_realmsPerPath[path] = realms = [NSMapTable mapTableWithKeyOptions:NSPointerFunctionsObjectPersonality
+                                                               valueOptions:NSPointerFunctionsWeakMemory];
+    }
+    [realms setObject:realm forKey:@(pthread_mach_thread_np(pthread_self()))];
+}
+
+RLMRealm *RLMGetAnyCachedRealmForPath(std::string const& path) {
+    std::lock_guard<std::mutex> lock(s_realmCacheMutex);
+    return [s_realmsPerPath[path] objectEnumerator].nextObject;
+}
+
+RLMRealm *RLMGetThreadLocalCachedRealmForPath(std::string const& path) {
+    mach_port_t threadID = pthread_mach_thread_np(pthread_self());
+    std::lock_guard<std::mutex> lock(s_realmCacheMutex);
+    return [s_realmsPerPath[path] objectForKey:@(threadID)];
+}
+
+void RLMClearRealmCache() {
+    std::lock_guard<std::mutex> lock(s_realmCacheMutex);
+    s_realmsPerPath.clear();
+}
+
+void RLMInstallUncaughtExceptionHandler() {
+    static auto previousHandler = NSGetUncaughtExceptionHandler();
+
+    NSSetUncaughtExceptionHandler([](NSException *exception) {
+        NSNumber *threadID = @(pthread_mach_thread_np(pthread_self()));
+        {
+            std::lock_guard<std::mutex> lock(s_realmCacheMutex);
+            for (auto const& realmsPerThread : s_realmsPerPath) {
+                if (RLMRealm *realm = [realmsPerThread.second objectForKey:threadID]) {
+                    if (realm.inWriteTransaction) {
+                        [realm cancelWriteTransaction];
+                    }
+                }
+            }
+        }
+        if (previousHandler) {
+            previousHandler(exception);
+        }
+    });
+}
+
+namespace {
+class RLMNotificationHelper : public realm::BindingContext {
+public:
+    RLMNotificationHelper(RLMRealm *realm) : _realm(realm) { }
+
+    bool can_deliver_notifications() const noexcept override {
+        // The main thread may not be in a run loop yet if we're called from
+        // something like `applicationDidFinishLaunching:`, but it presumably will
+        // be in the future
+        if ([NSThread isMainThread]) {
+            return true;
+        }
+        // Current mode indicates why the current callout from the runloop was made,
+        // and is null if a runloop callout isn't currently being processed
+        if (auto mode = CFRunLoopCopyCurrentMode(CFRunLoopGetCurrent())) {
+            CFRelease(mode);
+            return true;
+        }
+        return false;
+    }
+
+    void changes_available() override {
+        @autoreleasepool {
+            auto realm = _realm;
+            if (realm && !realm.autorefresh) {
+                [realm sendNotifications:RLMRealmRefreshRequiredNotification];
+            }
+        }
+    }
+
+    std::vector<ObserverState> get_observed_rows() override {
+        @autoreleasepool {
+            auto realm = _realm;
+            [realm detachAllEnumerators];
+            return RLMGetObservedRows(realm.schema.objectSchema);
+        }
+    }
+
+    void will_change(std::vector<ObserverState> const& observed, std::vector<void*> const& invalidated) override {
+        @autoreleasepool {
+            RLMWillChange(observed, invalidated);
+        }
+    }
+
+    void did_change(std::vector<ObserverState> const& observed, std::vector<void*> const& invalidated) override {
+        try {
+            @autoreleasepool {
+                RLMDidChange(observed, invalidated);
+                [_realm sendNotifications:RLMRealmDidChangeNotification];
+            }
+        }
+        catch (...) {
+            // This can only be called during a write transaction if it was
+            // called due to the transaction beginning, so cancel it to ensure
+            // exceptions thrown here behave the same as exceptions thrown when
+            // actually beginning the write
+            if (_realm.inWriteTransaction) {
+                [_realm cancelWriteTransaction];
+            }
+            throw;
+        }
+    }
+
+private:
+    // This is owned by the realm, so it needs to not retain the realm
+    __weak RLMRealm *const _realm;
+};
+} // anonymous namespace
+
+
+std::unique_ptr<realm::BindingContext> RLMCreateBindingContext(RLMRealm *realm) {
+    return std::unique_ptr<realm::BindingContext>(new RLMNotificationHelper(realm));
+}
diff --git a/Pods/Realm/Realm/RLMResults.mm b/Pods/Realm/Realm/RLMResults.mm
new file mode 100644
index 0000000..df648fb
--- /dev/null
+++ b/Pods/Realm/Realm/RLMResults.mm
@@ -0,0 +1,424 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import "RLMResults_Private.h"
+
+#import "RLMArray_Private.hpp"
+#import "RLMCollection_Private.hpp"
+#import "RLMObjectSchema_Private.hpp"
+#import "RLMObjectStore.h"
+#import "RLMObject_Private.hpp"
+#import "RLMObservation.hpp"
+#import "RLMProperty_Private.h"
+#import "RLMQueryUtil.hpp"
+#import "RLMRealm_Private.hpp"
+#import "RLMSchema_Private.h"
+#import "RLMUtil.hpp"
+
+#import "results.hpp"
+
+#import <objc/runtime.h>
+#import <objc/message.h>
+#import <realm/table_view.hpp>
+
+using namespace realm;
+
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wincomplete-implementation"
+@implementation RLMNotificationToken
+@end
+#pragma clang diagnostic pop
+
+//
+// RLMResults implementation
+//
+@implementation RLMResults {
+    realm::Results _results;
+    RLMRealm *_realm;
+}
+
+- (instancetype)initPrivate {
+    self = [super init];
+    return self;
+}
+
+static void assertKeyPathIsNotNested(NSString *keyPath) {
+    if ([keyPath rangeOfString:@"."].location != NSNotFound) {
+        @throw RLMException(@"Nested key paths are not supported yet for KVC collection operators.");
+    }
+}
+
+[[gnu::noinline]]
+[[noreturn]]
+static void throwError(NSString *aggregateMethod) {
+    try {
+        throw;
+    }
+    catch (realm::InvalidTransactionException const&) {
+        @throw RLMException(@"Cannot modify Results outside of a write transaction");
+    }
+    catch (realm::IncorrectThreadException const&) {
+        @throw RLMException(@"Realm accessed from incorrect thread");
+    }
+    catch (realm::Results::InvalidatedException const&) {
+        @throw RLMException(@"RLMResults has been invalidated");
+    }
+    catch (realm::Results::DetatchedAccessorException const&) {
+        @throw RLMException(@"Object has been invalidated");
+    }
+    catch (realm::Results::IncorrectTableException const& e) {
+        @throw RLMException(@"Object type '%s' does not match RLMResults type '%s'.",
+                            e.actual.data(), e.expected.data());
+    }
+    catch (realm::Results::OutOfBoundsIndexException const& e) {
+        @throw RLMException(@"Index %zu is out of bounds (must be less than %zu)",
+                            e.requested, e.valid_count);
+    }
+    catch (realm::Results::UnsupportedColumnTypeException const& e) {
+        @throw RLMException(@"%@ is not supported for %@ property '%s'",
+                            aggregateMethod,
+                            RLMTypeToString((RLMPropertyType)e.column_type),
+                            e.column_name.data());
+    }
+}
+
+template<typename Function>
+static auto translateErrors(Function&& f, NSString *aggregateMethod=nil) {
+    try {
+        return f();
+    }
+    catch (...) {
+        throwError(aggregateMethod);
+    }
+}
+
++ (instancetype)resultsWithObjectSchema:(RLMObjectSchema *)objectSchema
+                                results:(realm::Results)results {
+    RLMResults *ar = [[self alloc] initPrivate];
+    ar->_results = std::move(results);
+    ar->_realm = objectSchema.realm;
+    ar->_objectSchema = objectSchema;
+    return ar;
+}
+
++ (instancetype)emptyDetachedResults
+{
+    return [[self alloc] initPrivate];
+}
+
+static inline void RLMResultsValidateInWriteTransaction(__unsafe_unretained RLMResults *const ar) {
+    ar->_realm->_realm->verify_thread();
+    ar->_realm->_realm->verify_in_write();
+}
+
+- (BOOL)isInvalidated {
+    return translateErrors([&] { return !_results.is_valid(); });
+}
+
+- (NSUInteger)count {
+    return translateErrors([&] { return _results.size(); });
+}
+
+- (NSString *)objectClassName {
+    return RLMStringDataToNSString(_results.get_object_type());
+}
+
+- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state
+                                  objects:(__unused __unsafe_unretained id [])buffer
+                                    count:(NSUInteger)len {
+    __autoreleasing RLMFastEnumerator *enumerator;
+    if (state->state == 0) {
+        enumerator = [[RLMFastEnumerator alloc] initWithCollection:self objectSchema:_objectSchema];
+        state->extra[0] = (long)enumerator;
+        state->extra[1] = self.count;
+    }
+    else {
+        enumerator = (__bridge id)(void *)state->extra[0];
+    }
+
+    return [enumerator countByEnumeratingWithState:state count:len];
+}
+
+- (NSUInteger)indexOfObjectWhere:(NSString *)predicateFormat, ... {
+    va_list args;
+    va_start(args, predicateFormat);
+    NSUInteger index = [self indexOfObjectWhere:predicateFormat args:args];
+    va_end(args);
+    return index;
+}
+
+- (NSUInteger)indexOfObjectWhere:(NSString *)predicateFormat args:(va_list)args {
+    return [self indexOfObjectWithPredicate:[NSPredicate predicateWithFormat:predicateFormat
+                                                                   arguments:args]];
+}
+
+- (NSUInteger)indexOfObjectWithPredicate:(NSPredicate *)predicate {
+    if (_results.get_mode() == Results::Mode::Empty) {
+        return NSNotFound;
+    }
+
+    Query query = translateErrors([&] { return _results.get_query(); });
+    query.and_query(RLMPredicateToQuery(predicate, _objectSchema, _realm.schema, *_realm.group));
+
+    query.sync_view_if_needed();
+
+    TableView table_view;
+    if (const auto& sort = _results.get_sort()) {
+        // A sort order is specified so we need to return the first match given that ordering.
+        table_view = query.find_all();
+        table_view.sort(sort.column_indices, sort.ascending);
+    } else {
+        // No sort order is specified so we only need to find a single match.
+        // FIXME: We're only looking for a single object so we'd like to be able to use `Query::find`
+        // for this, but as of core v0.97.1 it gives incorrect results if the query is restricted
+        // to a link view (<https://github.com/realm/realm-core/issues/1565>).
+        table_view = query.find_all(0, -1, 1);
+    }
+    if (!table_view.size()) {
+        return NSNotFound;
+    }
+    return _results.index_of(table_view.get_source_ndx(0));
+}
+
+- (id)objectAtIndex:(NSUInteger)index {
+    return translateErrors([&] {
+        return RLMCreateObjectAccessor(_realm, _objectSchema, _results.get(index));
+    });
+}
+
+- (id)firstObject {
+    auto row = translateErrors([&] { return _results.first(); });
+    return row ? RLMCreateObjectAccessor(_realm, _objectSchema, *row) : nil;
+}
+
+- (id)lastObject {
+    auto row = translateErrors([&] { return _results.last(); });
+    return row ? RLMCreateObjectAccessor(_realm, _objectSchema, *row) : nil;
+}
+
+- (NSUInteger)indexOfObject:(RLMObject *)object {
+    if (!object || (!object->_realm && !object.invalidated)) {
+        return NSNotFound;
+    }
+
+    return translateErrors([&] {
+        return RLMConvertNotFound(_results.index_of(object->_row));
+    });
+}
+
+- (id)valueForKeyPath:(NSString *)keyPath {
+    if ([keyPath characterAtIndex:0] == '@') {
+        if ([keyPath isEqualToString:@"@count"]) {
+            return @(self.count);
+        }
+        NSRange operatorRange = [keyPath rangeOfString:@"." options:NSLiteralSearch];
+        NSUInteger keyPathLength = keyPath.length;
+        NSUInteger separatorIndex = operatorRange.location != NSNotFound ? operatorRange.location : keyPathLength;
+        NSString *operatorName = [keyPath substringWithRange:NSMakeRange(1, separatorIndex - 1)];
+        SEL opSelector = NSSelectorFromString([NSString stringWithFormat:@"_%@ForKeyPath:", operatorName]);
+        BOOL isValidOperator = [self respondsToSelector:opSelector];
+        if (!isValidOperator) {
+            @throw RLMException(@"Unsupported KVC collection operator found in key path '%@'", keyPath);
+        }
+        else if (separatorIndex >= keyPathLength - 1) {
+            @throw RLMException(@"Missing key path for KVC collection operator %@ in key path '%@'", operatorName, keyPath);
+        }
+        NSString *operatorKeyPath = [keyPath substringFromIndex:separatorIndex + 1];
+        if (isValidOperator) {
+            return ((id(*)(id, SEL, id))objc_msgSend)(self, opSelector, operatorKeyPath);
+        }
+    }
+    return [super valueForKeyPath:keyPath];
+}
+
+- (id)valueForKey:(NSString *)key {
+    return translateErrors([&] {
+        return RLMCollectionValueForKey(self, key);
+    });
+}
+
+- (void)setValue:(id)value forKey:(NSString *)key {
+    translateErrors([&] { RLMResultsValidateInWriteTransaction(self); });
+    RLMCollectionSetValueForKey(self, key, value);
+}
+
+- (NSNumber *)_aggregateForKeyPath:(NSString *)keyPath method:(util::Optional<Mixed> (Results::*)(size_t))method methodName:(NSString *)methodName {
+    assertKeyPathIsNotNested(keyPath);
+    return [self aggregate:keyPath method:method methodName:methodName];
+}
+
+- (NSNumber *)_minForKeyPath:(NSString *)keyPath {
+    return [self _aggregateForKeyPath:keyPath method:&Results::min methodName:@"@min"];
+}
+
+- (NSNumber *)_maxForKeyPath:(NSString *)keyPath {
+    return [self _aggregateForKeyPath:keyPath method:&Results::max methodName:@"@max"];
+}
+
+- (NSNumber *)_sumForKeyPath:(NSString *)keyPath {
+    return [self _aggregateForKeyPath:keyPath method:&Results::sum methodName:@"@sum"];
+}
+
+- (NSNumber *)_avgForKeyPath:(NSString *)keyPath {
+    return [self _aggregateForKeyPath:keyPath method:&Results::average methodName:@"@avg"];
+}
+
+- (NSArray *)_unionOfObjectsForKeyPath:(NSString *)keyPath {
+    assertKeyPathIsNotNested(keyPath);
+    return translateErrors([&] {
+        return RLMCollectionValueForKey(self, keyPath);
+    });
+}
+
+- (NSArray *)_distinctUnionOfObjectsForKeyPath:(NSString *)keyPath {
+    return [NSSet setWithArray:[self _unionOfObjectsForKeyPath:keyPath]].allObjects;
+}
+
+- (NSArray *)_unionOfArraysForKeyPath:(NSString *)keyPath {
+    assertKeyPathIsNotNested(keyPath);
+    if ([keyPath isEqualToString:@"self"]) {
+        @throw RLMException(@"self is not a valid key-path for a KVC array collection operator as 'unionOfArrays'.");
+    }
+
+    return translateErrors([&] {
+        NSArray *nestedResults = RLMCollectionValueForKey(self, keyPath);
+        NSMutableArray *flatArray = [NSMutableArray arrayWithCapacity:nestedResults.count];
+        for (id<RLMFastEnumerable> array in nestedResults) {
+            NSArray *nsArray = RLMCollectionValueForKey(array, @"self");
+            [flatArray addObjectsFromArray:nsArray];
+        }
+        return flatArray;
+    });
+}
+
+- (NSArray *)_distinctUnionOfArraysForKeyPath:(__unused NSString *)keyPath {
+    return [NSSet setWithArray:[self _unionOfArraysForKeyPath:keyPath]].allObjects;
+}
+
+- (RLMResults *)objectsWhere:(NSString *)predicateFormat, ... {
+    va_list args;
+    va_start(args, predicateFormat);
+    RLMResults *results = [self objectsWhere:predicateFormat args:args];
+    va_end(args);
+    return results;
+}
+
+- (RLMResults *)objectsWhere:(NSString *)predicateFormat args:(va_list)args {
+    return [self objectsWithPredicate:[NSPredicate predicateWithFormat:predicateFormat arguments:args]];
+}
+
+- (RLMResults *)objectsWithPredicate:(NSPredicate *)predicate {
+    return translateErrors([&] {
+        if (_results.get_mode() == Results::Mode::Empty) {
+            return self;
+        }
+        auto query = RLMPredicateToQuery(predicate, _objectSchema, _realm.schema, *_realm.group);
+        return [RLMResults resultsWithObjectSchema:_objectSchema
+                                           results:_results.filter(std::move(query))];
+    });
+}
+
+- (RLMResults *)sortedResultsUsingProperty:(NSString *)property ascending:(BOOL)ascending {
+    return [self sortedResultsUsingDescriptors:@[[RLMSortDescriptor sortDescriptorWithProperty:property ascending:ascending]]];
+}
+
+- (RLMResults *)sortedResultsUsingDescriptors:(NSArray *)properties {
+    return translateErrors([&] {
+        if (_results.get_mode() == Results::Mode::Empty) {
+            return self;
+        }
+
+        return [RLMResults resultsWithObjectSchema:_objectSchema
+                                           results:_results.sort(RLMSortOrderFromDescriptors(*_objectSchema.table, properties))];
+    });
+}
+
+- (id)objectAtIndexedSubscript:(NSUInteger)index {
+    return [self objectAtIndex:index];
+}
+
+- (id)aggregate:(NSString *)property method:(util::Optional<Mixed> (Results::*)(size_t))method methodName:(NSString *)methodName {
+    size_t column = RLMValidatedProperty(_objectSchema, property).column;
+    auto value = translateErrors([&] { return (_results.*method)(column); }, methodName);
+    if (!value) {
+        return nil;
+    }
+    return RLMMixedToObjc(*value);
+}
+
+- (id)minOfProperty:(NSString *)property {
+    return [self aggregate:property method:&Results::min methodName:@"minOfProperty"];
+}
+
+- (id)maxOfProperty:(NSString *)property {
+    return [self aggregate:property method:&Results::max methodName:@"maxOfProperty"];
+}
+
+- (id)sumOfProperty:(NSString *)property {
+    return [self aggregate:property method:&Results::sum methodName:@"sumOfProperty"];
+}
+
+- (id)averageOfProperty:(NSString *)property {
+    return [self aggregate:property method:&Results::average methodName:@"averageOfProperty"];
+}
+
+- (void)deleteObjectsFromRealm {
+    return translateErrors([&] {
+        if (_results.get_mode() == Results::Mode::Table) {
+            RLMResultsValidateInWriteTransaction(self);
+            RLMClearTable(self.objectSchema);
+        }
+        else {
+            RLMTrackDeletions(_realm, ^{ _results.clear(); });
+        }
+    });
+}
+
+- (NSString *)description {
+    return RLMDescriptionWithMaxDepth(@"RLMResults", self, RLMDescriptionMaxDepth);
+}
+
+- (NSUInteger)indexInSource:(NSUInteger)index {
+    return translateErrors([&] { return _results.get(index).get_index(); });
+}
+
+- (realm::TableView)tableView {
+    return translateErrors([&] { return _results.get_tableview(); });
+}
+
+// The compiler complains about the method's argument type not matching due to
+// it not having the generic type attached, but it doesn't seem to be possible
+// to actually include the generic type
+// http://www.openradar.me/radar?id=6135653276319744
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wmismatched-parameter-types"
+- (RLMNotificationToken *)addNotificationBlock:(void (^)(RLMResults *, RLMCollectionChange *, NSError *))block {
+    [_realm verifyNotificationsAreSupported];
+    return RLMAddNotificationBlock(self, _results, block, true);
+}
+#pragma clang diagnostic pop
+
+- (BOOL)isAttached
+{
+    return !!_realm;
+}
+
+@end
+
+@implementation RLMLinkingObjects
+@end
diff --git a/Pods/Realm/Realm/RLMSchema.mm b/Pods/Realm/Realm/RLMSchema.mm
new file mode 100644
index 0000000..3813c6c
--- /dev/null
+++ b/Pods/Realm/Realm/RLMSchema.mm
@@ -0,0 +1,336 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import "RLMSchema_Private.h"
+
+#import "RLMAccessor.h"
+#import "RLMObject_Private.hpp"
+#import "RLMObjectSchema_Private.hpp"
+#import "RLMProperty_Private.h"
+#import "RLMRealm_Private.hpp"
+#import "RLMSwiftSupport.h"
+#import "RLMUtil.hpp"
+
+#import "object_store.hpp"
+#import "schema.hpp"
+
+#import <realm/group.hpp>
+
+#import <objc/runtime.h>
+#include <mutex>
+
+using namespace realm;
+
+const uint64_t RLMNotVersioned = realm::ObjectStore::NotVersioned;
+
+// RLMSchema private properties
+@interface RLMSchema ()
+@property (nonatomic, readwrite) NSMutableDictionary *objectSchemaByName;
+@end
+
+static RLMSchema *s_sharedSchema = [[RLMSchema alloc] init];
+static NSMutableDictionary *s_localNameToClass = [[NSMutableDictionary alloc] init];
+static NSMutableDictionary *s_privateObjectSubclasses = [[NSMutableDictionary alloc] init];
+
+static enum class SharedSchemaState {
+    Uninitialized,
+    Initializing,
+    Initialized
+} s_sharedSchemaState = SharedSchemaState::Uninitialized;
+
+// Caller must @synchronize on s_localNameToClass
+static RLMObjectSchema *RLMRegisterClass(Class cls) {
+    if (RLMObjectSchema *schema = s_privateObjectSubclasses[[cls className]]) {
+        return schema;
+    }
+
+    auto prevState = s_sharedSchemaState;
+    s_sharedSchemaState = SharedSchemaState::Initializing;
+    RLMObjectSchema *schema = [RLMObjectSchema schemaForObjectClass:cls];
+    s_sharedSchemaState = prevState;
+
+    // set unmanaged class on shared shema for unmanaged object creation
+    schema.unmanagedClass = RLMUnmanagedAccessorClassForObjectClass(schema.objectClass, schema);
+
+    // override sharedSchema class methods for performance
+    RLMReplaceSharedSchemaMethod(cls, schema);
+
+    s_privateObjectSubclasses[schema.className] = schema;
+    if ([cls shouldIncludeInDefaultSchema]) {
+        s_sharedSchema.objectSchemaByName[schema.className] = schema;
+    }
+
+    return schema;
+}
+
+// Caller must @synchronize on s_localNameToClass
+static void RLMRegisterClassLocalNames(Class *classes, NSUInteger count) {
+    for (NSUInteger i = 0; i < count; i++) {
+        Class cls = classes[i];
+
+        if (!RLMIsObjectSubclass(cls) || RLMIsGeneratedClass(cls)) {
+            continue;
+        }
+
+        NSString *className = NSStringFromClass(cls);
+        if ([RLMSwiftSupport isSwiftClassName:className]) {
+            className = [RLMSwiftSupport demangleClassName:className];
+        }
+        // NSStringFromClass demangles the names for top-level Swift classes
+        // but not for nested classes. _T indicates it's a Swift symbol, t
+        // indicates it's a type, and C indicates it's a class.
+        else if ([className hasPrefix:@"_TtC"]) {
+            @throw RLMException(@"RLMObject subclasses cannot be nested within other declarations. Please move %@ to global scope.", className);
+        }
+
+        if (Class existingClass = s_localNameToClass[className]) {
+            if (existingClass != cls) {
+                @throw RLMException(@"RLMObject subclasses with the same name cannot be included twice in the same target. "
+                                    @"Please make sure '%@' is only linked once to your current target.", className);
+            }
+            continue;
+        }
+
+        s_localNameToClass[className] = cls;
+        RLMReplaceClassNameMethod(cls, className);
+    }
+}
+
+@implementation RLMSchema {
+    NSArray *_objectSchema;
+}
+
+- (instancetype)init {
+    self = [super init];
+    if (self) {
+        _objectSchemaByName = [[NSMutableDictionary alloc] init];
+    }
+    return self;
+}
+
+- (NSArray *)objectSchema {
+    if (!_objectSchema) {
+        _objectSchema = [_objectSchemaByName allValues];
+    }
+    return _objectSchema;
+}
+
+- (void)setObjectSchema:(NSArray *)objectSchema {
+    _objectSchema = objectSchema;
+    _objectSchemaByName = [NSMutableDictionary dictionaryWithCapacity:objectSchema.count];
+    for (RLMObjectSchema *object in objectSchema) {
+        [_objectSchemaByName setObject:object forKey:object.className];
+    }
+}
+
+- (RLMObjectSchema *)schemaForClassName:(NSString *)className {
+    return _objectSchemaByName[className];
+}
+
+- (RLMObjectSchema *)objectForKeyedSubscript:(__unsafe_unretained id<NSCopying> const)className {
+    RLMObjectSchema *schema = _objectSchemaByName[className];
+    if (!schema) {
+        @throw RLMException(@"Object type '%@' not managed by the Realm", className);
+    }
+    return schema;
+}
+
++ (instancetype)schemaWithObjectClasses:(NSArray *)classes {
+    NSUInteger count = classes.count;
+    auto classArray = std::make_unique<__unsafe_unretained Class[]>(count);
+    [classes getObjects:classArray.get() range:NSMakeRange(0, count)];
+
+    RLMSchema *schema = [[self alloc] init];
+    @synchronized(s_localNameToClass) {
+        RLMRegisterClassLocalNames(classArray.get(), count);
+
+        schema->_objectSchemaByName = [NSMutableDictionary dictionaryWithCapacity:count];
+        for (Class cls in classes) {
+            if (!RLMIsObjectSubclass(cls)) {
+                @throw RLMException(@"Can't add non-Object type '%@' to a schema.", cls);
+            }
+            schema->_objectSchemaByName[[cls className]] = RLMRegisterClass(cls);
+        }
+    }
+
+    NSMutableArray *errors = [NSMutableArray new];
+    // Verify that all of the targets of links are included in the class list
+    [schema->_objectSchemaByName enumerateKeysAndObjectsUsingBlock:^(id, RLMObjectSchema *objectSchema, BOOL *) {
+        for (RLMProperty *prop in objectSchema.properties) {
+            if (prop.type != RLMPropertyTypeObject && prop.type != RLMPropertyTypeArray) {
+                continue;
+            }
+            if (!schema->_objectSchemaByName[prop.objectClassName]) {
+                [errors addObject:[NSString stringWithFormat:@"- '%@.%@' links to class '%@', which is missing from the list of classes managed by the Realm", objectSchema.className, prop.name, prop.objectClassName]];
+            }
+        }
+    }];
+    if (errors.count) {
+        @throw RLMException(@"Invalid class subset list:\n%@", [errors componentsJoinedByString:@"\n"]);
+    }
+
+    return schema;
+}
+
++ (RLMObjectSchema *)sharedSchemaForClass:(Class)cls {
+    @synchronized(s_localNameToClass) {
+        // We create instances of Swift objects during schema init, and they
+        // obviously need to not also try to initialize the schema
+        if (s_sharedSchemaState == SharedSchemaState::Initializing) {
+            return nil;
+        }
+
+        RLMRegisterClassLocalNames(&cls, 1);
+        return RLMRegisterClass(cls);
+    }
+}
+
++ (instancetype)partialSharedSchema {
+    return s_sharedSchema;
+}
+
+// schema based on runtime objects
++ (instancetype)sharedSchema {
+    @synchronized(s_localNameToClass) {
+        // We replace this method with one which just returns s_sharedSchema
+        // once initialization is complete, but we still need to check if it's
+        // already complete because it may have been done by another thread
+        // while we were waiting for the lock
+        if (s_sharedSchemaState == SharedSchemaState::Initialized) {
+            return s_sharedSchema;
+        }
+
+        if (s_sharedSchemaState == SharedSchemaState::Initializing) {
+            @throw RLMException(@"Illegal recursive call of +[%@ %@]. Note: Properties of Swift `Object` classes must not be prepopulated with queried results from a Realm.", self, NSStringFromSelector(_cmd));
+        }
+
+        s_sharedSchemaState = SharedSchemaState::Initializing;
+        try {
+            // Make sure we've discovered all classes
+            {
+                unsigned int numClasses;
+                using malloc_ptr = std::unique_ptr<__unsafe_unretained Class[], decltype(&free)>;
+                malloc_ptr classes(objc_copyClassList(&numClasses), &free);
+                RLMRegisterClassLocalNames(classes.get(), numClasses);
+            }
+
+            [s_localNameToClass enumerateKeysAndObjectsUsingBlock:^(NSString *, Class cls, BOOL *) {
+                RLMRegisterClass(cls);
+            }];
+        }
+        catch (...) {
+            s_sharedSchemaState = SharedSchemaState::Uninitialized;
+            throw;
+        }
+
+        // Replace this method with one that doesn't need to acquire a lock
+        Class metaClass = objc_getMetaClass(class_getName(self));
+        IMP imp = imp_implementationWithBlock(^{ return s_sharedSchema; });
+        class_replaceMethod(metaClass, @selector(sharedSchema), imp, "@@:");
+
+        s_sharedSchemaState = SharedSchemaState::Initialized;
+    }
+
+    return s_sharedSchema;
+}
+
+// schema based on tables in a realm
++ (instancetype)dynamicSchemaFromObjectStoreSchema:(Schema &)objectStoreSchema {
+    // cache descriptors for all subclasses of RLMObject
+    NSMutableArray *schemaArray = [NSMutableArray arrayWithCapacity:objectStoreSchema.size()];
+    for (auto &objectSchema : objectStoreSchema) {
+        RLMObjectSchema *schema = [RLMObjectSchema objectSchemaForObjectStoreSchema:objectSchema];
+        [schemaArray addObject:schema];
+    }
+
+    // set class array and mapping
+    RLMSchema *schema = [RLMSchema new];
+    schema.objectSchema = schemaArray;
+    return schema;
+}
+
++ (Class)classForString:(NSString *)className {
+    if (Class cls = s_localNameToClass[className]) {
+        return cls;
+    }
+
+    if (Class cls = NSClassFromString(className)) {
+        return RLMIsObjectSubclass(cls) ? cls : nil;
+    }
+
+    // className might be the local name of a Swift class we haven't registered
+    // yet, so scan them all then recheck
+    {
+        unsigned int numClasses;
+        std::unique_ptr<__unsafe_unretained Class[], decltype(&free)> classes(objc_copyClassList(&numClasses), &free);
+        RLMRegisterClassLocalNames(classes.get(), numClasses);
+    }
+
+    return s_localNameToClass[className];
+}
+
+- (id)copyWithZone:(NSZone *)zone {
+    RLMSchema *schema = [[RLMSchema allocWithZone:zone] init];
+    schema->_objectSchemaByName = [[NSMutableDictionary allocWithZone:zone]
+                                   initWithDictionary:_objectSchemaByName copyItems:YES];
+    return schema;
+}
+
+- (instancetype)shallowCopy {
+    RLMSchema *schema = [[RLMSchema alloc] init];
+    schema->_objectSchemaByName = [[NSMutableDictionary alloc] initWithCapacity:_objectSchemaByName.count];
+    [_objectSchemaByName enumerateKeysAndObjectsUsingBlock:^(NSString *name, RLMObjectSchema *objectSchema, BOOL *) {
+        schema->_objectSchemaByName[name] = [objectSchema shallowCopy];
+    }];
+    return schema;
+}
+
+- (BOOL)isEqualToSchema:(RLMSchema *)schema {
+    if (_objectSchemaByName.count != schema->_objectSchemaByName.count) {
+        return NO;
+    }
+    __block BOOL matches = YES;
+    [_objectSchemaByName enumerateKeysAndObjectsUsingBlock:^(NSString *name, RLMObjectSchema *objectSchema, BOOL *stop) {
+        if (![schema->_objectSchemaByName[name] isEqualToObjectSchema:objectSchema]) {
+            *stop = YES;
+            matches = NO;
+        }
+    }];
+    return matches;
+}
+
+- (NSString *)description {
+    NSMutableString *objectSchemaString = [NSMutableString string];
+    NSArray *sort = @[[NSSortDescriptor sortDescriptorWithKey:@"className" ascending:YES]];
+    for (RLMObjectSchema *objectSchema in [self.objectSchema sortedArrayUsingDescriptors:sort]) {
+        [objectSchemaString appendFormat:@"\t%@\n",
+         [objectSchema.description stringByReplacingOccurrencesOfString:@"\n" withString:@"\n\t"]];
+    }
+    return [NSString stringWithFormat:@"Schema {\n%@}", objectSchemaString];
+}
+
+- (std::unique_ptr<Schema>)objectStoreCopy {
+    std::vector<realm::ObjectSchema> schema;
+    schema.reserve(_objectSchemaByName.count);
+    [_objectSchemaByName enumerateKeysAndObjectsUsingBlock:[&](NSString *, RLMObjectSchema *objectSchema, BOOL *) {
+        schema.push_back(objectSchema.objectStoreCopy);
+    }];
+    return std::make_unique<realm::Schema>(std::move(schema));
+}
+
+@end
diff --git a/Pods/Realm/Realm/RLMSwiftSupport.m b/Pods/Realm/Realm/RLMSwiftSupport.m
new file mode 100644
index 0000000..e16c79e
--- /dev/null
+++ b/Pods/Realm/Realm/RLMSwiftSupport.m
@@ -0,0 +1,31 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import "RLMSwiftSupport.h"
+
+@implementation RLMSwiftSupport
+
++ (BOOL)isSwiftClassName:(NSString *)className {
+    return [className rangeOfString:@"."].location != NSNotFound;
+}
+
++ (NSString *)demangleClassName:(NSString *)className {
+    return [className substringFromIndex:[className rangeOfString:@"."].location + 1];
+}
+
+@end
diff --git a/Pods/Realm/Realm/RLMUpdateChecker.mm b/Pods/Realm/Realm/RLMUpdateChecker.mm
new file mode 100644
index 0000000..e282ee8
--- /dev/null
+++ b/Pods/Realm/Realm/RLMUpdateChecker.mm
@@ -0,0 +1,48 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import "RLMUpdateChecker.hpp"
+
+#import "RLMRealm.h"
+#import "RLMUtil.hpp"
+
+#if TARGET_IPHONE_SIMULATOR && !defined(REALM_COCOA_VERSION)
+#import "RLMVersion.h"
+#endif
+
+void RLMCheckForUpdates() {
+#if TARGET_IPHONE_SIMULATOR
+    if (getenv("REALM_DISABLE_UPDATE_CHECKER") || RLMIsRunningInPlayground()) {
+        return;
+    }
+
+    auto handler = ^(NSData *data, NSURLResponse *response, NSError *error) {
+        if (error || ((NSHTTPURLResponse *)response).statusCode != 200) {
+            return;
+        }
+
+        NSString *latestVersion = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
+        if (![REALM_COCOA_VERSION isEqualToString:latestVersion]) {
+            NSLog(@"Version %@ of Realm is now available: https://github.com/realm/realm-cocoa/blob/v%@/CHANGELOG.md", latestVersion, latestVersion);
+        }
+    };
+
+    NSString *url = [NSString stringWithFormat:@"https://static.realm.io/update/cocoa?%@", REALM_COCOA_VERSION];
+    [[NSURLSession.sharedSession dataTaskWithURL:[NSURL URLWithString:url] completionHandler:handler] resume];
+#endif
+}
diff --git a/Pods/Realm/Realm/RLMUtil.mm b/Pods/Realm/Realm/RLMUtil.mm
new file mode 100644
index 0000000..d2fa444
--- /dev/null
+++ b/Pods/Realm/Realm/RLMUtil.mm
@@ -0,0 +1,351 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import "RLMUtil.hpp"
+
+#import "RLMArray_Private.hpp"
+#import "RLMListBase.h"
+#import "RLMObjectSchema_Private.hpp"
+#import "RLMObjectStore.h"
+#import "RLMObject_Private.hpp"
+#import "RLMProperty_Private.h"
+#import "RLMSchema_Private.h"
+#import "RLMSwiftSupport.h"
+
+#import <realm/mixed.hpp>
+#import <realm/table_view.hpp>
+
+#include <sys/sysctl.h>
+#include <sys/types.h>
+
+#if !defined(REALM_COCOA_VERSION)
+#import "RLMVersion.h"
+#endif
+
+static inline bool nsnumber_is_like_integer(__unsafe_unretained NSNumber *const obj)
+{
+    char data_type = [obj objCType][0];
+    return data_type == *@encode(bool) ||
+           data_type == *@encode(char) ||
+           data_type == *@encode(short) ||
+           data_type == *@encode(int) ||
+           data_type == *@encode(long) ||
+           data_type == *@encode(long long) ||
+           data_type == *@encode(unsigned short) ||
+           data_type == *@encode(unsigned int) ||
+           data_type == *@encode(unsigned long) ||
+           data_type == *@encode(unsigned long long);
+}
+
+static inline bool nsnumber_is_like_bool(__unsafe_unretained NSNumber *const obj)
+{
+    // @encode(BOOL) is 'B' on iOS 64 and 'c'
+    // objcType is always 'c'. Therefore compare to "c".
+    if ([obj objCType][0] == 'c') {
+        return true;
+    }
+
+    if (nsnumber_is_like_integer(obj)) {
+        int value = [obj intValue];
+        return value == 0 || value == 1;
+    }
+
+    return false;
+}
+
+static inline bool nsnumber_is_like_float(__unsafe_unretained NSNumber *const obj)
+{
+    char data_type = [obj objCType][0];
+    return data_type == *@encode(float) ||
+           data_type == *@encode(short) ||
+           data_type == *@encode(int) ||
+           data_type == *@encode(long) ||
+           data_type == *@encode(long long) ||
+           data_type == *@encode(unsigned short) ||
+           data_type == *@encode(unsigned int) ||
+           data_type == *@encode(unsigned long) ||
+           data_type == *@encode(unsigned long long) ||
+           // A double is like float if it fits within float bounds
+           (data_type == *@encode(double) && ABS([obj doubleValue]) <= FLT_MAX);
+}
+
+static inline bool nsnumber_is_like_double(__unsafe_unretained NSNumber *const obj)
+{
+    char data_type = [obj objCType][0];
+    return data_type == *@encode(double) ||
+           data_type == *@encode(float) ||
+           data_type == *@encode(short) ||
+           data_type == *@encode(int) ||
+           data_type == *@encode(long) ||
+           data_type == *@encode(long long) ||
+           data_type == *@encode(unsigned short) ||
+           data_type == *@encode(unsigned int) ||
+           data_type == *@encode(unsigned long) ||
+           data_type == *@encode(unsigned long long);
+}
+
+BOOL RLMIsObjectValidForProperty(__unsafe_unretained id const obj,
+                                 __unsafe_unretained RLMProperty *const property) {
+    if (property.optional && !RLMCoerceToNil(obj)) {
+        return YES;
+    }
+
+    switch (property.type) {
+        case RLMPropertyTypeString:
+            return [obj isKindOfClass:[NSString class]];
+        case RLMPropertyTypeBool:
+            if ([obj isKindOfClass:[NSNumber class]]) {
+                return nsnumber_is_like_bool(obj);
+            }
+            return NO;
+        case RLMPropertyTypeDate:
+            return [obj isKindOfClass:[NSDate class]];
+        case RLMPropertyTypeInt:
+            if (NSNumber *number = RLMDynamicCast<NSNumber>(obj)) {
+                return nsnumber_is_like_integer(number);
+            }
+            return NO;
+        case RLMPropertyTypeFloat:
+            if (NSNumber *number = RLMDynamicCast<NSNumber>(obj)) {
+                return nsnumber_is_like_float(number);
+            }
+            return NO;
+        case RLMPropertyTypeDouble:
+            if (NSNumber *number = RLMDynamicCast<NSNumber>(obj)) {
+                return nsnumber_is_like_double(number);
+            }
+            return NO;
+        case RLMPropertyTypeData:
+            return [obj isKindOfClass:[NSData class]];
+        case RLMPropertyTypeAny:
+            return NO;
+        case RLMPropertyTypeObject:
+        case RLMPropertyTypeLinkingObjects: {
+            // only NSNull, nil, or objects which derive from RLMObject and match the given
+            // object class are valid
+            RLMObjectBase *objBase = RLMDynamicCast<RLMObjectBase>(obj);
+            return objBase && [objBase->_objectSchema.className isEqualToString:property.objectClassName];
+        }
+        case RLMPropertyTypeArray: {
+            if (RLMArray *array = RLMDynamicCast<RLMArray>(obj)) {
+                return [array.objectClassName isEqualToString:property.objectClassName];
+            }
+            if (RLMListBase *list = RLMDynamicCast<RLMListBase>(obj)) {
+                return [list._rlmArray.objectClassName isEqualToString:property.objectClassName];
+            }
+            if ([obj conformsToProtocol:@protocol(NSFastEnumeration)]) {
+                // check each element for compliance
+                for (id el in (id<NSFastEnumeration>)obj) {
+                    RLMObjectBase *obj = RLMDynamicCast<RLMObjectBase>(el);
+                    if (!obj || ![obj->_objectSchema.className isEqualToString:property.objectClassName]) {
+                        return NO;
+                    }
+                }
+                return YES;
+            }
+            if (!obj || obj == NSNull.null) {
+                return YES;
+            }
+            return NO;
+        }
+    }
+    @throw RLMException(@"Invalid RLMPropertyType specified");
+}
+
+NSDictionary *RLMDefaultValuesForObjectSchema(__unsafe_unretained RLMObjectSchema *const objectSchema) {
+    if (!objectSchema.isSwiftClass) {
+        return [objectSchema.objectClass defaultPropertyValues];
+    }
+
+    NSMutableDictionary *defaults = nil;
+    if ([objectSchema.objectClass isSubclassOfClass:RLMObject.class]) {
+        defaults = [NSMutableDictionary dictionaryWithDictionary:[objectSchema.objectClass defaultPropertyValues]];
+    }
+    else {
+        defaults = [NSMutableDictionary dictionary];
+    }
+    RLMObject *defaultObject = [[objectSchema.objectClass alloc] init];
+    for (RLMProperty *prop in objectSchema.properties) {
+        if (!defaults[prop.name] && defaultObject[prop.name]) {
+            defaults[prop.name] = defaultObject[prop.name];
+        }
+    }
+    return defaults;
+}
+
+static NSException *RLMException(NSString *reason, NSDictionary *additionalUserInfo) {
+    NSMutableDictionary *userInfo = @{RLMRealmVersionKey: REALM_COCOA_VERSION,
+                                      RLMRealmCoreVersionKey: @REALM_VERSION}.mutableCopy;
+    if (additionalUserInfo != nil) {
+        [userInfo addEntriesFromDictionary:additionalUserInfo];
+    }
+    NSException *e = [NSException exceptionWithName:RLMExceptionName
+                                             reason:reason
+                                           userInfo:userInfo];
+    return e;
+}
+
+NSException *RLMException(NSString *fmt, ...) {
+    va_list args;
+    va_start(args, fmt);
+    NSException *e = RLMException([[NSString alloc] initWithFormat:fmt arguments:args], @{});
+    va_end(args);
+    return e;
+}
+
+NSException *RLMException(std::exception const& exception) {
+    return RLMException(@"%@", @(exception.what()));
+}
+
+NSError *RLMMakeError(RLMError code, std::exception const& exception) {
+    return [NSError errorWithDomain:RLMErrorDomain
+                               code:code
+                           userInfo:@{NSLocalizedDescriptionKey: @(exception.what()),
+                                      @"Error Code": @(code)}];
+}
+
+NSError *RLMMakeError(RLMError code, const realm::util::File::AccessError& exception) {
+    return [NSError errorWithDomain:RLMErrorDomain
+                               code:code
+                           userInfo:@{NSLocalizedDescriptionKey: @(exception.what()),
+                                      NSFilePathErrorKey: @(exception.get_path().c_str()),
+                                      @"Error Code": @(code)}];
+}
+
+NSError *RLMMakeError(RLMError code, const realm::RealmFileException& exception) {
+    NSString *underlying = @(exception.underlying().c_str());
+    return [NSError errorWithDomain:RLMErrorDomain
+                               code:code
+                           userInfo:@{NSLocalizedDescriptionKey: @(exception.what()),
+                                      NSFilePathErrorKey: @(exception.path().c_str()),
+                                      @"Error Code": @(code),
+                                      @"Underlying": underlying.length == 0 ? @"n/a" : underlying}];
+}
+
+NSError *RLMMakeError(std::system_error const& exception) {
+    BOOL isGenericCategoryError = (exception.code().category() == std::generic_category());
+    NSString *category = @(exception.code().category().name());
+    NSString *errorDomain = isGenericCategoryError ? NSPOSIXErrorDomain : RLMUnknownSystemErrorDomain;
+
+    return [NSError errorWithDomain:errorDomain
+                               code:exception.code().value()
+                           userInfo:@{NSLocalizedDescriptionKey: @(exception.what()),
+                                      @"Error Code": @(exception.code().value()),
+                                      @"Category": category}];
+}
+
+NSError *RLMMakeError(NSException *exception) {
+    return [NSError errorWithDomain:RLMErrorDomain
+                               code:0
+                           userInfo:@{NSLocalizedDescriptionKey: exception.reason}];
+}
+
+void RLMSetErrorOrThrow(NSError *error, NSError **outError) {
+    if (outError) {
+        *outError = error;
+    }
+    else {
+        NSString *msg = error.localizedDescription;
+        if (error.userInfo[NSFilePathErrorKey]) {
+            msg = [NSString stringWithFormat:@"%@: %@", error.userInfo[NSFilePathErrorKey], error.localizedDescription];
+        }
+        @throw RLMException(msg, @{NSUnderlyingErrorKey: error});
+    }
+}
+
+// Determines if class1 descends from class2
+static inline BOOL RLMIsSubclass(Class class1, Class class2) {
+    class1 = class_getSuperclass(class1);
+    return RLMIsKindOfClass(class1, class2);
+}
+
+static bool treatFakeObjectAsRLMObject = false;
+
+void RLMSetTreatFakeObjectAsRLMObject(BOOL flag) {
+    treatFakeObjectAsRLMObject = flag;
+}
+
+BOOL RLMIsObjectOrSubclass(Class klass) {
+    if (RLMIsKindOfClass(klass, RLMObjectBase.class)) {
+        return YES;
+    }
+
+    if (treatFakeObjectAsRLMObject) {
+        static Class FakeObjectClass = NSClassFromString(@"FakeObject");
+        return RLMIsKindOfClass(klass, FakeObjectClass);
+    }
+    return NO;
+}
+
+BOOL RLMIsObjectSubclass(Class klass) {
+    if (RLMIsSubclass(class_getSuperclass(klass), RLMObjectBase.class)) {
+        return YES;
+    }
+
+    if (treatFakeObjectAsRLMObject) {
+        static Class FakeObjectClass = NSClassFromString(@"FakeObject");
+        return RLMIsSubclass(klass, FakeObjectClass);
+    }
+    return NO;
+}
+
+BOOL RLMIsDebuggerAttached()
+{
+    int name[] = {
+        CTL_KERN,
+        KERN_PROC,
+        KERN_PROC_PID,
+        getpid()
+    };
+
+    struct kinfo_proc info;
+    size_t info_size = sizeof(info);
+    if (sysctl(name, sizeof(name)/sizeof(name[0]), &info, &info_size, NULL, 0) == -1) {
+        NSLog(@"sysctl() failed: %s", strerror(errno));
+        return false;
+    }
+
+    return (info.kp_proc.p_flag & P_TRACED) != 0;
+}
+
+BOOL RLMIsRunningInPlayground() {
+    return [[NSBundle mainBundle].bundleIdentifier hasPrefix:@"com.apple.dt.playground."];
+}
+
+id RLMMixedToObjc(realm::Mixed const& mixed) {
+    switch (mixed.get_type()) {
+        case realm::type_String:
+            return RLMStringDataToNSString(mixed.get_string());
+        case realm::type_Int:
+            return @(mixed.get_int());
+        case realm::type_Float:
+            return @(mixed.get_float());
+        case realm::type_Double:
+            return @(mixed.get_double());
+        case realm::type_Bool:
+            return @(mixed.get_bool());
+        case realm::type_Timestamp:
+            return RLMTimestampToNSDate(mixed.get_timestamp());
+        case realm::type_Binary:
+            return RLMBinaryDataToNSData(mixed.get_binary());
+        case realm::type_Link:
+        case realm::type_LinkList:
+        default:
+            @throw RLMException(@"Invalid data type for RLMPropertyTypeAny property.");
+    }
+}
diff --git a/Pods/Realm/Realm/module.modulemap b/Pods/Realm/Realm/module.modulemap
new file mode 100644
index 0000000..18b5e2e
--- /dev/null
+++ b/Pods/Realm/Realm/module.modulemap
@@ -0,0 +1,27 @@
+framework module Realm {
+    umbrella header "Realm.h"
+
+    export *
+    module * { export * }
+
+    explicit module Private {
+        header "RLMAccessor.h"
+        header "RLMArray_Private.h"
+        header "RLMListBase.h"
+        header "RLMMigration_Private.h"
+        header "RLMObjectSchema_Private.h"
+        header "RLMObjectStore.h"
+        header "RLMObject_Private.h"
+        header "RLMOptionalBase.h"
+        header "RLMProperty_Private.h"
+        header "RLMRealmConfiguration_Private.h"
+        header "RLMRealm_Private.h"
+        header "RLMResults_Private.h"
+        header "RLMSchema_Private.h"
+    }
+
+    explicit module Dynamic {
+        header "RLMRealm_Dynamic.h"
+        header "RLMObjectBase_Dynamic.h"
+    }
+}
diff --git a/Pods/Realm/build.sh b/Pods/Realm/build.sh
new file mode 100755
index 0000000..d3d7078
--- /dev/null
+++ b/Pods/Realm/build.sh
@@ -0,0 +1,1268 @@
+#!/bin/sh
+
+##################################################################################
+# Custom build tool for Realm Objective-C binding.
+#
+# (C) Copyright 2011-2015 by realm.io.
+##################################################################################
+
+# Warning: pipefail is not a POSIX compatible option, but on OS X it works just fine.
+#          OS X uses a POSIX complain version of bash as /bin/sh, but apparently it does
+#          not strip away this feature. Also, this will fail if somebody forces the script
+#          to be run with zsh.
+set -o pipefail
+set -e
+
+# You can override the version of the core library
+: ${REALM_CORE_VERSION:=1.3.1} # set to "current" to always use the current build
+
+# You can override the xcmode used
+: ${XCMODE:=xcodebuild} # must be one of: xcodebuild (default), xcpretty, xctool
+
+# Provide a fallback value for TMPDIR, relevant for Xcode Bots
+: ${TMPDIR:=$(getconf DARWIN_USER_TEMP_DIR)}
+
+PATH=/usr/libexec:$PATH
+
+if ! [ -z "${JENKINS_HOME}" ]; then
+    XCPRETTY_PARAMS="--no-utf --report junit --output build/reports/junit.xml"
+    CODESIGN_PARAMS="CODE_SIGN_IDENTITY= CODE_SIGNING_REQUIRED=NO"
+fi
+
+export REALM_SKIP_DEBUGGER_CHECKS=YES
+
+usage() {
+cat <<EOF
+Usage: sh $0 command [argument]
+
+command:
+  clean:                clean up/remove all generated files
+  download-core:        downloads core library (binary version)
+  build:                builds all iOS  and OS X frameworks
+  ios-static:           builds fat iOS static framework
+  ios-dynamic:          builds iOS dynamic frameworks
+  ios-swift:            builds RealmSwift frameworks for iOS
+  watchos:              builds watchOS framwork
+  watchos-swift:        builds RealmSwift framework for watchOS
+  tvos:                 builds tvOS framework
+  tvos-swift:           builds RealmSwift framework for tvOS
+  osx:                  builds OS X framework
+  osx-swift:            builds RealmSwift framework for OS X
+  analyze-osx:          analyzes OS X framework
+  test:                 tests all iOS and OS X frameworks
+  test-all:             tests all iOS and OS X frameworks in both Debug and Release configurations
+  test-ios-static:      tests static iOS framework on 32-bit and 64-bit simulators
+  test-ios-dynamic:     tests dynamic iOS framework on 32-bit and 64-bit simulators
+  test-ios-swift:       tests RealmSwift iOS framework on 32-bit and 64-bit simulators
+  test-ios-devices:     tests ObjC & Swift iOS frameworks on all attached iOS devices
+  test-ios-devices-objc:  tests ObjC iOS framework on all attached iOS devices
+  test-ios-devices-swift: tests Swift iOS framework on all attached iOS devices
+  test-tvos:            tests tvOS framework
+  test-tvos-swift:      tests RealmSwift tvOS framework
+  test-tvos-devices:    tests ObjC & Swift tvOS frameworks on all attached tvOS devices
+  test-osx:             tests OS X framework
+  test-osx-swift:       tests RealmSwift OS X framework
+  verify:               verifies docs, osx, osx-swift, ios-static, ios-dynamic, ios-swift, ios-device in both Debug and Release configurations, swiftlint
+  docs:                 builds docs in docs/output
+  examples:             builds all examples
+  examples-ios:         builds all static iOS examples
+  examples-ios-swift:   builds all Swift iOS examples
+  examples-osx:         builds all OS X examples
+  get-version:          get the current version
+  set-version version:  set the version
+  cocoapods-setup:      download realm-core and create a stub RLMPlatform.h file to enable building via CocoaPods
+
+
+argument:
+  version: version in the x.y.z format
+
+environment variables:
+  XCMODE: xcodebuild (default), xcpretty or xctool
+  CONFIGURATION: Debug or Release (default)
+  REALM_CORE_VERSION: version in x.y.z format or "current" to use local build
+  REALM_EXTRA_BUILD_ARGUMENTS: additional arguments to pass to the build tool
+EOF
+}
+
+######################################
+# Xcode Helpers
+######################################
+
+xcode() {
+    mkdir -p build/DerivedData
+    CMD="xcodebuild -IDECustomDerivedDataLocation=build/DerivedData $@ $REALM_EXTRA_BUILD_ARGUMENTS"
+    echo "Building with command:" $CMD
+    eval "$CMD"
+}
+
+xc() {
+    # Logs xcodebuild output in realtime
+    : ${NSUnbufferedIO:=YES}
+    if [[ "$XCMODE" == "xcodebuild" ]]; then
+        xcode "$@"
+    elif [[ "$XCMODE" == "xcpretty" ]]; then
+        mkdir -p build
+        xcode "$@" | tee build/build.log | xcpretty -c ${XCPRETTY_PARAMS} || {
+            echo "The raw xcodebuild output is available in build/build.log"
+            exit 1
+        }
+    elif [[ "$XCMODE" == "xctool" ]]; then
+        xctool "$@"
+    fi
+}
+
+copy_bcsymbolmap() {
+    find "$1" -name '*.bcsymbolmap' -type f -exec cp {} "$2" \;
+}
+
+build_combined() {
+    local scheme="$1"
+    local module_name="$2"
+    local os="$3"
+    local simulator="$4"
+    local scope_suffix="$5"
+    local version_suffix="$6"
+    local config="$CONFIGURATION"
+
+    local destination=""
+    local os_name=""
+    if [[ "$os" == "iphoneos" ]]; then
+        os_name="ios"
+        destination="iPhone 6"
+    elif [[ "$os" == "watchos"  ]]; then
+        os_name="$os"
+        destination="Apple Watch - 42mm"
+    elif [[ "$os" == "appletvos"  ]]; then
+        os_name="tvos"
+        destination="Apple TV 1080p"
+    fi
+
+    # Derive build paths
+    local build_products_path="build/DerivedData/Realm/Build/Products"
+    local product_name="$module_name.framework"
+    local binary_path="$module_name"
+    local os_path="$build_products_path/$config-$os$scope_suffix/$product_name"
+    local simulator_path="$build_products_path/$config-$simulator$scope_suffix/$product_name"
+    local out_path="build/$os_name$scope_suffix$version_suffix"
+
+    # Build for each platform
+    xc "-scheme '$scheme' -configuration $config -sdk $os"
+    xc "-scheme '$scheme' -configuration $config -sdk $simulator -destination 'name=$destination' ONLY_ACTIVE_ARCH=NO"
+
+    # Combine .swiftmodule
+    if [ -d $simulator_path/Modules/$module_name.swiftmodule ]; then
+      cp $simulator_path/Modules/$module_name.swiftmodule/* $os_path/Modules/$module_name.swiftmodule/
+    fi
+
+    # Copy *.bcsymbolmap to .framework for submitting app with bitcode
+    copy_bcsymbolmap "$build_products_path/$config-$os$scope_suffix" "$os_path"
+
+    # Retrieve build products
+    clean_retrieve $os_path $out_path $product_name
+
+    # Combine ar archives
+    LIPO_OUTPUT="$out_path/$product_name/$module_name"
+    xcrun lipo -create "$simulator_path/$binary_path" "$os_path/$binary_path" -output "$LIPO_OUTPUT"
+
+    if [[ "$destination" != "" && "$config" == "Release" ]]; then
+        sh build.sh binary-has-bitcode "$LIPO_OUTPUT"
+    fi
+}
+
+xc_work_around_rdar_23055637() {
+    # xcodebuild times out waiting for the iOS simulator to launch if it takes > 120 seconds for the tests to
+    # build (<http://openradar.appspot.com/23055637>). Work around this by having the test phases intentionally
+    # exit after they finish building the first time, then run the tests for real.
+    ( REALM_EXIT_AFTER_BUILDING_TESTS=YES xc "$1" ) || true
+    # Xcode 7.2.1 fails to run tests in the iOS simulator for unknown reasons. Resetting the simulator here works
+    # around this issue.
+    sh build.sh prelaunch-simulator
+    xc "$1"
+}
+
+clean_retrieve() {
+  mkdir -p "$2"
+  rm -rf "$2/$3"
+  cp -R "$1" "$2"
+}
+
+move_to_clean_dir() {
+    rm -rf "$2"
+    mkdir -p "$2"
+    mv "$1" "$2"
+}
+
+shutdown_simulators() {
+    # Shut down simulators until there's no booted ones left
+    # Only do one at a time because devices sometimes show up multiple times
+    while xcrun simctl list | grep -q Booted; do
+      xcrun simctl list | grep Booted | sed 's/.* (\(.*\)) (Booted)/\1/' | head -n 1 | xargs xcrun simctl shutdown
+    done
+}
+
+######################################
+# Device Test Helper
+######################################
+
+test_devices() {
+    serial_numbers_str=$(system_profiler SPUSBDataType | grep "Serial Number: ")
+    serial_numbers=()
+    while read -r line; do
+        number=${line:15} # Serial number starts at position 15
+        if [[ ${#number} == 40 ]]; then
+            serial_numbers+=("$number")
+        fi
+    done <<< "$serial_numbers_str"
+    if [[ ${#serial_numbers[@]} == 0 ]]; then
+        echo "At least one iOS/tvOS device must be connected to this computer to run device tests"
+        if [ -z "${JENKINS_HOME}" ]; then
+            # Don't fail if running locally and there's no device
+            exit 0
+        fi
+        exit 1
+    fi
+    local sdk="$1"
+    local scheme="$2"
+    local configuration="$3"
+    local failed=0
+    for device in "${serial_numbers[@]}"; do
+        xc "-scheme '$scheme' -configuration $configuration -destination 'id=$device' -sdk $sdk test" || failed=1
+    done
+    return $failed
+}
+
+######################################
+# Docs
+######################################
+
+build_docs() {
+    local language="$1"
+    local version=$(sh build.sh get-version)
+
+    local xcodebuild_arguments="--objc,Realm/Realm.h,--,-x,objective-c,-isysroot,$(xcrun --show-sdk-path),-I,$(pwd)"
+    local module="Realm"
+    local objc="--objc"
+
+    if [[ "$language" == "swift" ]]; then
+        : ${REALM_SWIFT_VERSION:=2.2}
+        sh build.sh set-swift-version
+        xcodebuild_arguments="-scheme,RealmSwift"
+        module="RealmSwift"
+        objc=""
+    fi
+
+    touch Realm/RLMPlatform.h # jazzy will fail if it can't find all public header files
+    jazzy \
+      ${objc} \
+      --swift-version 2.2 \
+      --clean \
+      --author Realm \
+      --author_url https://realm.io \
+      --github_url https://github.com/realm/realm-cocoa \
+      --github-file-prefix https://github.com/realm/realm-cocoa/tree/v${version} \
+      --module-version ${version} \
+      --xcodebuild-arguments ${xcodebuild_arguments} \
+      --module ${module} \
+      --root-url https://realm.io/docs/${language}/${version}/api/ \
+      --output docs/${language}_output \
+      --head "$(cat docs/custom_head.html)"
+
+    rm Realm/RLMPlatform.h
+}
+
+######################################
+# Input Validation
+######################################
+
+if [ "$#" -eq 0 -o "$#" -gt 3 ]; then
+    usage
+    exit 1
+fi
+
+######################################
+# Variables
+######################################
+
+download_core() {
+    echo "Downloading dependency: core ${REALM_CORE_VERSION}"
+    TMP_DIR="$TMPDIR/core_bin"
+    mkdir -p "${TMP_DIR}"
+    CORE_TMP_TAR="${TMP_DIR}/core-${REALM_CORE_VERSION}.tar.xz.tmp"
+    CORE_TAR="${TMP_DIR}/core-${REALM_CORE_VERSION}.tar.xz"
+    if [ ! -f "${CORE_TAR}" ]; then
+        local CORE_URL="https://static.realm.io/downloads/core/realm-core-${REALM_CORE_VERSION}.tar.xz"
+        set +e # temporarily disable immediate exit
+        local ERROR # sweeps the exit code unless declared separately
+        ERROR=$(curl --fail --silent --show-error --location "$CORE_URL" --output "${CORE_TMP_TAR}" 2>&1 >/dev/null)
+        if [[ $? -ne 0 ]]; then
+            echo "Downloading core failed:\n${ERROR}"
+            exit 1
+        fi
+        set -e # re-enable flag
+        mv "${CORE_TMP_TAR}" "${CORE_TAR}"
+    fi
+
+    (
+        cd "${TMP_DIR}"
+        rm -rf core
+        tar xf "${CORE_TAR}" --xz
+        mv core core-${REALM_CORE_VERSION}
+    )
+
+    rm -rf core-${REALM_CORE_VERSION} core
+    mv ${TMP_DIR}/core-${REALM_CORE_VERSION} .
+    ln -s core-${REALM_CORE_VERSION} core
+}
+
+COMMAND="$1"
+
+# Use Debug config if command ends with -debug, otherwise default to Release
+case "$COMMAND" in
+    *-debug)
+        COMMAND="${COMMAND%-debug}"
+        CONFIGURATION="Debug"
+        ;;
+    *) CONFIGURATION=${CONFIGURATION:-Release}
+esac
+export CONFIGURATION
+
+source "$(dirname "$0")/scripts/swift-version.sh"
+
+case "$COMMAND" in
+
+    ######################################
+    # Clean
+    ######################################
+    "clean")
+        find . -type d -name build -exec rm -r "{}" +\;
+        exit 0
+        ;;
+
+    ######################################
+    # Core
+    ######################################
+    "download-core")
+        if [ "$REALM_CORE_VERSION" = "current" ]; then
+            echo "Using version of core already in core/ directory"
+            exit 0
+        fi
+        if [ -d core -a -d ../realm-core -a ! -L core ]; then
+          # Allow newer versions than expected for local builds as testing
+          # with unreleased versions is one of the reasons to use a local build
+          if ! $(grep -i "${REALM_CORE_VERSION} Release notes" core/release_notes.txt >/dev/null); then
+              echo "Local build of core is out of date."
+              exit 1
+          else
+              echo "The core library seems to be up to date."
+          fi
+        elif ! [ -L core ]; then
+            echo "core is not a symlink. Deleting..."
+            rm -rf core
+            download_core
+        # With a prebuilt version we only want to check the first non-empty
+        # line so that checking out an older commit will download the
+        # appropriate version of core if the already-present version is too new
+        elif ! $(grep -m 1 . core/release_notes.txt | grep -i "${REALM_CORE_VERSION} RELEASE NOTES" >/dev/null); then
+            download_core
+        else
+            echo "The core library seems to be up to date."
+        fi
+        exit 0
+        ;;
+
+    ######################################
+    # Object Store
+    ######################################
+    "push-object-store-changes")
+        commit="$2"
+        path="$3"
+        if [ -z "$commit" -o -z "$path" ]; then
+            echo "usage: sh build.sh push-object-store-changes [base commit] [path to objectore repo]"
+            exit 1
+        fi
+
+        # List all commits since $commit which touched the objecstore, generate
+        # patches for each of them, and then apply those patches to the
+        # objectstore repo
+        git rev-list --reverse $commit..HEAD -- Realm/ObjectStore \
+            | xargs -I@ git format-patch --stdout @^! Realm/ObjectStore \
+            | git -C $path am -p 3 --directory src
+        ;;
+
+    "pull-object-store-changes")
+        commit="$2"
+        path="$3"
+        if [ -z "$commit" -o -z "$path" ]; then
+            echo "usage: sh build.sh pull-object-store-changes [base commit] [path to objectore repo]"
+            exit 1
+        fi
+
+        git -C $path format-patch --stdout $commit..HEAD src | git am -p 2 --directory Realm/ObjectStore --exclude='*CMake*' --reject
+        ;;
+
+    ######################################
+    # Swift versioning
+    ######################################
+    "set-swift-version")
+        version="$2"
+        if [[ -z "$version" ]]; then
+            version="$REALM_SWIFT_VERSION"
+        fi
+
+        SWIFT_VERSION_FILE="RealmSwift/SwiftVersion.swift"
+        CONTENTS="let swiftLanguageVersion = \"$version\""
+        if [ ! -f "$SWIFT_VERSION_FILE" ] || ! grep -q "$CONTENTS" "$SWIFT_VERSION_FILE"; then
+            echo "$CONTENTS" > "$SWIFT_VERSION_FILE"
+        fi
+
+        exit 0
+        ;;
+
+    "prelaunch-simulator")
+        sh $(dirname $0)/scripts/reset-simulators.sh
+        ;;
+
+    ######################################
+    # Building
+    ######################################
+    "build")
+        sh build.sh ios-static
+        sh build.sh ios-dynamic
+        sh build.sh ios-swift
+        sh build.sh watchos
+        sh build.sh watchos-swift
+        sh build.sh tvos
+        sh build.sh tvos-swift
+        sh build.sh osx
+        sh build.sh osx-swift
+        exit 0
+        ;;
+
+    "ios-static")
+        build_combined 'Realm iOS static' Realm iphoneos iphonesimulator "-static"
+        exit 0
+        ;;
+
+    "ios-dynamic")
+        build_combined Realm Realm iphoneos iphonesimulator
+        exit 0
+        ;;
+
+    "ios-swift")
+        sh build.sh ios-dynamic
+        build_combined RealmSwift RealmSwift iphoneos iphonesimulator '' "/swift-$REALM_SWIFT_VERSION"
+        cp -R build/ios/Realm.framework build/ios/swift-$REALM_SWIFT_VERSION
+        exit 0
+        ;;
+
+    "watchos")
+        build_combined Realm Realm watchos watchsimulator
+        exit 0
+        ;;
+
+    "watchos-swift")
+        sh build.sh watchos
+        build_combined RealmSwift RealmSwift watchos watchsimulator
+        exit 0
+        ;;
+
+    "tvos")
+        build_combined Realm Realm appletvos appletvsimulator
+        exit 0
+        ;;
+
+    "tvos-swift")
+        sh build.sh tvos
+        build_combined RealmSwift RealmSwift appletvos appletvsimulator
+        exit 0
+        ;;
+
+    "osx")
+        xc "-scheme Realm -configuration $CONFIGURATION"
+        rm -rf build/osx
+        mkdir build/osx
+        cp -R build/DerivedData/Realm/Build/Products/$CONFIGURATION/Realm.framework build/osx
+        exit 0
+        ;;
+
+    "osx-swift")
+        sh build.sh osx
+        xc "-scheme 'RealmSwift' -configuration $CONFIGURATION build"
+        destination="build/osx/swift-$REALM_SWIFT_VERSION"
+        clean_retrieve "build/DerivedData/Realm/Build/Products/$CONFIGURATION/RealmSwift.framework" "$destination" "RealmSwift.framework"
+        cp -R build/osx/Realm.framework "$destination"
+        exit 0
+        ;;
+
+    ######################################
+    # Analysis
+    ######################################
+
+    "analyze-osx")
+        xc "-scheme Realm -configuration $CONFIGURATION analyze"
+        exit 0
+        ;;
+
+    ######################################
+    # Testing
+    ######################################
+    "test")
+        set +e # Run both sets of tests even if the first fails
+        failed=0
+        sh build.sh test-ios-static || failed=1
+        sh build.sh test-ios-dynamic || failed=1
+        sh build.sh test-ios-swift || failed=1
+        sh build.sh test-ios-devices || failed=1
+        sh build.sh test-tvos-devices || failed=1
+        sh build.sh test-osx || failed=1
+        sh build.sh test-osx-swift || failed=1
+        exit $failed
+        ;;
+
+    "test-all")
+        set +e
+        failed=0
+        sh build.sh test || failed=1
+        sh build.sh test-debug || failed=1
+        exit $failed
+        ;;
+
+    "test-ios-static")
+        xc_work_around_rdar_23055637 "-scheme 'Realm iOS static' -configuration $CONFIGURATION -sdk iphonesimulator -destination 'name=iPhone 6' test"
+        shutdown_simulators
+        xc_work_around_rdar_23055637 "-scheme 'Realm iOS static' -configuration $CONFIGURATION -sdk iphonesimulator -destination 'name=iPhone 4s' test"
+        exit 0
+        ;;
+
+    "test-ios7-static")
+        xc_work_around_rdar_23055637 "-scheme 'Realm iOS static' -configuration $CONFIGURATION -sdk iphonesimulator -destination 'name=iPhone 5S,OS=7.1' test"
+        shutdown_simulators
+        xc_work_around_rdar_23055637 "-scheme 'Realm iOS static' -configuration $CONFIGURATION -sdk iphonesimulator -destination 'name=iPhone 4s,OS=7.1' test"
+        exit 0
+        ;;
+
+    "test-ios-dynamic")
+        xc_work_around_rdar_23055637 "-scheme Realm -configuration $CONFIGURATION -sdk iphonesimulator -destination 'name=iPhone 6' test"
+        shutdown_simulators
+        xc_work_around_rdar_23055637 "-scheme Realm -configuration $CONFIGURATION -sdk iphonesimulator -destination 'name=iPhone 4s' test"
+        exit 0
+        ;;
+
+    "test-ios-swift")
+        xc_work_around_rdar_23055637 "-scheme RealmSwift -configuration $CONFIGURATION -sdk iphonesimulator -destination 'name=iPhone 6' build test"
+        shutdown_simulators
+        xc_work_around_rdar_23055637 "-scheme RealmSwift -configuration $CONFIGURATION -sdk iphonesimulator -destination 'name=iPhone 4s' build test"
+        exit 0
+        ;;
+
+    "test-ios-devices")
+        failed=0
+        trap "failed=1" ERR
+        sh build.sh test-ios-devices-objc
+        sh build.sh test-ios-devices-swift
+        exit $failed
+        ;;
+
+    "test-ios-devices-objc")
+        test_devices iphoneos "Realm iOS static" "$CONFIGURATION"
+        exit $?
+        ;;
+
+    "test-ios-devices-swift")
+        test_devices iphoneos "RealmSwift" "$CONFIGURATION"
+        exit $?
+        ;;
+
+    "test-tvos")
+        xc_work_around_rdar_23055637 "-scheme Realm -configuration $CONFIGURATION -sdk appletvsimulator -destination 'name=Apple TV 1080p' test"
+        exit $?
+        ;;
+
+    "test-tvos-swift")
+        xc_work_around_rdar_23055637 "-scheme RealmSwift -configuration $CONFIGURATION -sdk appletvsimulator -destination 'name=Apple TV 1080p' test"
+        exit $?
+        ;;
+
+    "test-tvos-devices")
+        test_devices appletvos TestHost "$CONFIGURATION"
+        ;;
+
+    "test-osx")
+        COVERAGE_PARAMS=""
+        if [[ "$CONFIGURATION" == "Debug" ]]; then
+            COVERAGE_PARAMS="GCC_GENERATE_TEST_COVERAGE_FILES=YES GCC_INSTRUMENT_PROGRAM_FLOW_ARCS=YES"
+        fi
+        xc "-scheme Realm -configuration $CONFIGURATION test $COVERAGE_PARAMS"
+        exit 0
+        ;;
+
+    "test-osx-swift")
+        xc "-scheme RealmSwift -configuration $CONFIGURATION test"
+        exit 0
+        ;;
+
+    ######################################
+    # Full verification
+    ######################################
+    "verify")
+        sh build.sh verify-cocoapods
+        sh build.sh verify-docs
+        sh build.sh verify-osx
+        sh build.sh verify-osx-debug
+        sh build.sh verify-osx-swift
+        sh build.sh verify-osx-swift-debug
+        sh build.sh verify-ios-static
+        sh build.sh verify-ios-static-debug
+        sh build.sh verify-ios7-static
+        sh build.sh verify-ios7-static-debug
+        sh build.sh verify-ios-dynamic
+        sh build.sh verify-ios-dynamic-debug
+        sh build.sh verify-ios-swift
+        sh build.sh verify-ios-swift-debug
+        sh build.sh verify-ios-device-objc
+        sh build.sh verify-ios-device-swift
+        sh build.sh verify-watchos
+        sh build.sh verify-tvos
+        sh build.sh verify-tvos-debug
+        sh build.sh verify-tvos-device
+        sh build.sh verify-swiftlint
+        ;;
+
+    "verify-cocoapods")
+        if [[ -d .git ]]; then
+          # Verify the current branch, unless one was already specified in the sha environment variable.
+          if [[ -z $sha ]]; then
+            export sha=$(git rev-parse --abbrev-ref HEAD)
+          fi
+
+          if [[ $(git log -1 @{push}..) != "" ]] || ! git diff-index --quiet HEAD; then
+            echo "WARNING: verify-cocoapods will test the latest revision of $sha found on GitHub."
+            echo "         Any unpushed local changes will not be tested."
+            echo ""
+            sleep 1
+          fi
+        fi
+
+        cd examples/installation
+        sh build.sh test-ios-objc-cocoapods
+        sh build.sh test-ios-objc-cocoapods-dynamic
+        sh build.sh test-ios-swift-cocoapods
+        sh build.sh test-osx-objc-cocoapods
+        sh build.sh test-osx-swift-cocoapods
+        sh build.sh test-watchos-objc-cocoapods
+        sh build.sh test-watchos-swift-cocoapods
+        ;;
+
+    "verify-osx-encryption")
+        REALM_ENCRYPT_ALL=YES sh build.sh test-osx
+        exit 0
+        ;;
+
+    "verify-osx")
+        sh build.sh test-osx
+        sh build.sh analyze-osx
+        sh build.sh examples-osx
+
+        (
+            cd examples/osx/objc/build/DerivedData/RealmExamples/Build/Products/$CONFIGURATION
+            DYLD_FRAMEWORK_PATH=. ./JSONImport >/dev/null
+        )
+        exit 0
+        ;;
+
+    "verify-osx-swift")
+        sh build.sh test-osx-swift
+        exit 0
+        ;;
+
+    "verify-ios-static")
+        sh build.sh test-ios-static
+        sh build.sh examples-ios
+        ;;
+
+    "verify-ios7-static")
+        sh build.sh test-ios7-static
+        ;;
+
+    "verify-ios-dynamic")
+        sh build.sh test-ios-dynamic
+        ;;
+
+    "verify-ios-swift")
+        sh build.sh test-ios-swift
+        sh build.sh examples-ios-swift
+        ;;
+
+    "verify-ios-device-objc")
+        sh build.sh test-ios-devices-objc
+        exit 0
+        ;;
+
+    "verify-ios-device-swift")
+        sh build.sh test-ios-devices-swift
+        exit 0
+        ;;
+
+    "verify-docs")
+        sh build.sh docs
+        for lang in swift objc; do
+            undocumented="docs/${lang}_output/undocumented.json"
+            if ! cat "$undocumented" | grep '"warnings":\[\]' > /dev/null 2>&1; then
+              echo "Undocumented Realm $lang declarations:"
+              cat "$undocumented"
+              exit 1
+            fi
+        done
+        exit 0
+        ;;
+
+    "verify-watchos")
+        sh build.sh watchos-swift
+        exit 0
+        ;;
+
+    "verify-tvos")
+        sh build.sh test-tvos
+        sh build.sh test-tvos-swift
+        sh build.sh examples-tvos
+        sh build.sh examples-tvos-swift
+        exit 0
+        ;;
+
+    "verify-tvos-device")
+        sh build.sh test-tvos-devices
+        exit 0
+        ;;
+
+    "verify-swiftlint")
+        swiftlint lint --strict
+        exit 0
+        ;;
+
+    ######################################
+    # Docs
+    ######################################
+    "docs")
+        build_docs objc
+        build_docs swift
+        exit 0
+        ;;
+
+    ######################################
+    # Examples
+    ######################################
+    "examples")
+        sh build.sh clean
+        sh build.sh examples-ios
+        sh build.sh examples-ios-swift
+        sh build.sh examples-osx
+        sh build.sh examples-tvos
+        sh build.sh examples-tvos-swift
+        exit 0
+        ;;
+
+    "examples-ios")
+        sh build.sh prelaunch-simulator
+        if [[ -d "examples/ios/objc" ]]; then
+            workspace="examples/ios/objc/RealmExamples.xcworkspace"
+        else
+            workspace="examples/ios/xcode-7/objc/RealmExamples.xcworkspace"
+        fi
+        pod install --project-directory="$workspace/.." --no-repo-update
+        xc "-workspace $workspace -scheme Simple -configuration $CONFIGURATION -destination 'name=iPhone 6' build ${CODESIGN_PARAMS}"
+        xc "-workspace $workspace -scheme TableView -configuration $CONFIGURATION -destination 'name=iPhone 6' build ${CODESIGN_PARAMS}"
+        xc "-workspace $workspace -scheme Migration -configuration $CONFIGURATION -destination 'name=iPhone 6' build ${CODESIGN_PARAMS}"
+        xc "-workspace $workspace -scheme Backlink -configuration $CONFIGURATION -destination 'name=iPhone 6' build ${CODESIGN_PARAMS}"
+        xc "-workspace $workspace -scheme GroupedTableView -configuration $CONFIGURATION -destination 'name=iPhone 6' build ${CODESIGN_PARAMS}"
+        xc "-workspace $workspace -scheme RACTableView -configuration $CONFIGURATION -destination 'name=iPhone 6' build ${CODESIGN_PARAMS}"
+        xc "-workspace $workspace -scheme Encryption -configuration $CONFIGURATION -destination 'name=iPhone 6' build ${CODESIGN_PARAMS}"
+
+        if [ ! -z "${JENKINS_HOME}" ]; then
+            xc "-workspace $workspace -scheme Extension -configuration $CONFIGURATION -destination 'name=iPhone 6' build ${CODESIGN_PARAMS}"
+        fi
+
+        exit 0
+        ;;
+
+    "examples-ios-swift")
+        sh build.sh prelaunch-simulator
+        workspace="examples/ios/swift-$REALM_SWIFT_VERSION/RealmExamples.xcworkspace"
+        pod install --project-directory="$workspace/.." --no-repo-update
+        xc "-workspace $workspace -scheme Simple -configuration $CONFIGURATION -destination 'name=iPhone 6' build ${CODESIGN_PARAMS}"
+        xc "-workspace $workspace -scheme TableView -configuration $CONFIGURATION -destination 'name=iPhone 6' build ${CODESIGN_PARAMS}"
+        xc "-workspace $workspace -scheme Migration -configuration $CONFIGURATION -destination 'name=iPhone 6' build ${CODESIGN_PARAMS}"
+        xc "-workspace $workspace -scheme Encryption -configuration $CONFIGURATION -destination 'name=iPhone 6' build ${CODESIGN_PARAMS}"
+        xc "-workspace $workspace -scheme Backlink -configuration $CONFIGURATION -destination 'name=iPhone 6' build ${CODESIGN_PARAMS}"
+        xc "-workspace $workspace -scheme GroupedTableView -configuration $CONFIGURATION -destination 'name=iPhone 6' build ${CODESIGN_PARAMS}"
+        xc "-workspace $workspace -scheme ReactKitTableView -configuration $CONFIGURATION -destination 'name=iPhone 6' build ${CODESIGN_PARAMS}"
+        exit 0
+        ;;
+
+    "examples-osx")
+        xc "-workspace examples/osx/objc/RealmExamples.xcworkspace -scheme JSONImport -configuration ${CONFIGURATION} build ${CODESIGN_PARAMS}"
+        ;;
+
+    "examples-tvos")
+        workspace="examples/tvos/objc/RealmExamples.xcworkspace"
+        xc "-workspace $workspace -scheme DownloadCache -configuration $CONFIGURATION -destination 'name=Apple TV 1080p' build ${CODESIGN_PARAMS}"
+        xc "-workspace $workspace -scheme PreloadedData -configuration $CONFIGURATION -destination 'name=Apple TV 1080p' build ${CODESIGN_PARAMS}"
+        exit 0
+        ;;
+
+    "examples-tvos-swift")
+        workspace="examples/tvos/swift/RealmExamples.xcworkspace"
+        xc "-workspace $workspace -scheme DownloadCache -configuration $CONFIGURATION -destination 'name=Apple TV 1080p' build ${CODESIGN_PARAMS}"
+        xc "-workspace $workspace -scheme PreloadedData -configuration $CONFIGURATION -destination 'name=Apple TV 1080p' build ${CODESIGN_PARAMS}"
+        exit 0
+        ;;
+
+    ######################################
+    # Versioning
+    ######################################
+    "get-version")
+        version_file="Realm/Realm-Info.plist"
+        echo "$(PlistBuddy -c "Print :CFBundleVersion" "$version_file")"
+        exit 0
+        ;;
+
+    "set-version")
+        realm_version="$2"
+        version_files="Realm/Realm-Info.plist"
+
+        if [ -z "$realm_version" ]; then
+            echo "You must specify a version."
+            exit 1
+        fi
+        for version_file in $version_files; do
+            PlistBuddy -c "Set :CFBundleVersion $realm_version" "$version_file"
+            PlistBuddy -c "Set :CFBundleShortVersionString $realm_version" "$version_file"
+        done
+        exit 0
+        ;;
+
+    ######################################
+    # Bitcode Detection
+    ######################################
+
+    "binary-has-bitcode")
+        BINARY="$2"
+        # Although grep has a '-q' flag to prevent logging to stdout, grep
+        # behaves differently when used, so redirect stdout to /dev/null.
+        if otool -l "$BINARY" | grep "segname __LLVM" > /dev/null 2>&1; then
+            exit 0
+        fi
+        # Work around rdar://21826157 by checking for bitcode in thin binaries
+
+        # Get architectures for binary
+        archs="$(lipo -info "$BINARY" | rev | cut -d ':' -f1 | rev)"
+
+        archs_array=( $archs )
+        if [[ ${#archs_array[@]} < 2 ]]; then
+            exit 1 # Early exit if not a fat binary
+        fi
+
+        TEMPDIR=$(mktemp -d $TMPDIR/realm-bitcode-check.XXXX)
+
+        for arch in $archs; do
+            lipo -thin "$arch" "$BINARY" -output "$TEMPDIR/$arch"
+            if otool -l "$TEMPDIR/$arch" | grep -q "segname __LLVM"; then
+                exit 0
+            fi
+        done
+        exit 1
+        ;;
+
+    ######################################
+    # CocoaPods
+    ######################################
+    "cocoapods-setup")
+        if [ ! -d core ]; then
+          sh build.sh download-core
+          rm core
+          mv core-* core
+        fi
+
+        if [[ "$2" != "swift" ]]; then
+          rm -rf include
+          mkdir -p include
+          mv core/include include/core
+
+          mkdir -p include/impl/apple
+          mkdir -p include/util
+          cp Realm/*.hpp include
+          cp Realm/ObjectStore/*.hpp include
+          cp Realm/ObjectStore/impl/*.hpp include/impl
+          cp Realm/ObjectStore/impl/apple/*.hpp include/impl/apple
+          cp Realm/ObjectStore/util/*.hpp include/util
+
+          touch Realm/RLMPlatform.h
+          if [ -n "$COCOAPODS_VERSION" ]; then
+            # This variable is set for the prepare_command available
+            # from the 1.0 prereleases, which requires a different
+            # header layout within the header_mappings_dir.
+            cp Realm/*.h include
+          else
+            # For CocoaPods < 1.0, we need to scope the headers within
+            # the header_mappings_dir by another subdirectory to avoid
+            # Clang from complaining about non-modular headers.
+            mkdir -p include/Realm
+            cp Realm/*.h include/Realm
+          fi
+        else
+          sh build.sh set-swift-version
+        fi
+        ;;
+
+    ######################################
+    # Continuous Integration
+    ######################################
+
+    "ci-pr")
+        mkdir -p build/reports
+
+        if [ "$target" = "docs" ]; then
+            sh build.sh set-swift-version
+            sh build.sh verify-docs
+        elif [ "$target" = "swiftlint" ]; then
+            sh build.sh verify-swiftlint
+        else
+            export sha=$ghprbSourceBranch
+            export REALM_SWIFT_VERSION=$swift_version
+            export CONFIGURATION=$configuration
+            export REALM_EXTRA_BUILD_ARGUMENTS='GCC_GENERATE_DEBUGGING_SYMBOLS=NO REALM_PREFIX_HEADER=Realm/RLMPrefix.h'
+            sh build.sh prelaunch-simulator
+            # Verify that no Realm files still exist
+            ! find ~/Library/Developer/CoreSimulator/Devices/ -name '*.realm' | grep -q .
+
+            sh build.sh verify-$target | tee build/build.log | xcpretty -r junit -o build/reports/junit.xml || \
+                (echo "\n\n***\nbuild/build.log\n***\n\n" && cat build/build.log && exit 1)
+        fi
+
+        if [ "$target" = "osx" ] && [ "$configuration" = "Debug" ]; then
+          gcovr -r . -f ".*Realm.*" -e ".*Tests.*" -e ".*core.*" --xml > build/reports/coverage-report.xml
+          WS=$(pwd | sed "s/\//\\\\\//g")
+          sed -i ".bak" "s/<source>\./<source>${WS}/" build/reports/coverage-report.xml
+        fi
+        ;;
+
+    ######################################
+    # Release packaging
+    ######################################
+
+    "package-examples")
+        cd tightdb_objc
+        ./scripts/package_examples.rb
+        zip --symlinks -r realm-examples.zip examples -x "examples/installation/*"
+        ;;
+
+    "package-test-examples")
+        if ! VERSION=$(echo realm-objc-*.zip | grep -o '\d*\.\d*\.\d*-[a-z]*'); then
+            VERSION=$(echo realm-objc-*.zip | grep -o '\d*\.\d*\.\d*')
+        fi
+        OBJC="realm-objc-${VERSION}"
+        SWIFT="realm-swift-${VERSION}"
+        unzip ${OBJC}.zip
+
+        cp $0 ${OBJC}
+        cp -r $(dirname $0)/scripts ${OBJC}
+        cd ${OBJC}
+        sh build.sh examples-ios
+        sh build.sh examples-osx
+        cd ..
+        rm -rf ${OBJC}
+
+        unzip ${SWIFT}.zip
+
+        cp $0 ${SWIFT}
+        cp -r $(dirname $0)/scripts ${SWIFT}
+        cd ${SWIFT}
+        sh build.sh examples-ios-swift
+        cd ..
+        rm -rf ${SWIFT}
+        ;;
+
+    "package-ios-static")
+        cd tightdb_objc
+
+        sh build.sh prelaunch-simulator
+        sh build.sh test-ios-static
+        sh build.sh ios-static
+        move_to_clean_dir build/ios-static/Realm.framework xcode-7
+
+        zip --symlinks -r build/ios-static/realm-framework-ios.zip xcode-7
+        ;;
+
+    "package-ios-dynamic")
+        cd tightdb_objc
+
+        sh build.sh prelaunch-simulator
+        sh build.sh ios-dynamic
+        move_to_clean_dir build/ios/Realm.framework xcode-7
+
+        zip --symlinks -r build/ios/realm-dynamic-framework-ios.zip xcode-7
+        ;;
+
+    "package-osx")
+        cd tightdb_objc
+        sh build.sh test-osx
+
+        cd build/DerivedData/Realm/Build/Products/Release
+        zip --symlinks -r realm-framework-osx.zip Realm.framework
+        ;;
+
+    "package-ios-swift")
+        cd tightdb_objc
+        rm -rf build/ios/Realm.framework
+        sh build.sh prelaunch-simulator
+        sh build.sh ios-swift
+
+        cd build/ios
+        zip --symlinks -r realm-swift-framework-ios.zip swift-2.2
+        ;;
+
+    "package-osx-swift")
+        cd tightdb_objc
+        sh build.sh osx-swift
+
+        cd build/osx
+        zip --symlinks -r realm-swift-framework-osx.zip swift-2.2
+        ;;
+
+    "package-watchos")
+        cd tightdb_objc
+        sh build.sh watchos
+
+        cd build/watchos
+        zip --symlinks -r realm-framework-watchos.zip Realm.framework
+        ;;
+
+    "package-watchos-swift")
+        cd tightdb_objc
+        sh build.sh watchos-swift
+
+        cd build/watchos
+        zip --symlinks -r realm-swift-framework-watchos.zip RealmSwift.framework Realm.framework
+        ;;
+
+    "package-tvos")
+        cd tightdb_objc
+        sh build.sh tvos
+
+        cd build/tvos
+        zip --symlinks -r realm-framework-tvos.zip Realm.framework
+        ;;
+
+    "package-tvos-swift")
+        cd tightdb_objc
+        sh build.sh tvos-swift
+
+        cd build/tvos
+        zip --symlinks -r realm-swift-framework-tvos.zip RealmSwift.framework Realm.framework
+        ;;
+
+    "package-release")
+        LANG="$2"
+        TEMPDIR=$(mktemp -d $TMPDIR/realm-release-package-${LANG}.XXXX)
+
+        cd tightdb_objc
+        VERSION=$(sh build.sh get-version)
+        cd ..
+
+        FOLDER=${TEMPDIR}/realm-${LANG}-${VERSION}
+
+        mkdir -p ${FOLDER}/osx ${FOLDER}/ios ${FOLDER}/watchos ${FOLDER}/tvos
+
+        if [[ "${LANG}" == "objc" ]]; then
+            mkdir -p ${FOLDER}/ios/static
+            mkdir -p ${FOLDER}/ios/dynamic
+            mkdir -p ${FOLDER}/Swift
+
+            (
+                cd ${FOLDER}/osx
+                unzip ${WORKSPACE}/realm-framework-osx.zip
+            )
+
+            (
+                cd ${FOLDER}/ios/static
+                unzip ${WORKSPACE}/realm-framework-ios.zip
+            )
+
+            (
+                cd ${FOLDER}/ios/dynamic
+                unzip ${WORKSPACE}/realm-dynamic-framework-ios.zip
+            )
+
+            (
+                cd ${FOLDER}/watchos
+                unzip ${WORKSPACE}/realm-framework-watchos.zip
+            )
+
+            (
+                cd ${FOLDER}/tvos
+                unzip ${WORKSPACE}/realm-framework-tvos.zip
+            )
+        else
+            (
+                cd ${FOLDER}/osx
+                unzip ${WORKSPACE}/realm-swift-framework-osx.zip
+            )
+
+            (
+                cd ${FOLDER}/ios
+                unzip ${WORKSPACE}/realm-swift-framework-ios.zip
+            )
+
+            (
+                cd ${FOLDER}/watchos
+                unzip ${WORKSPACE}/realm-swift-framework-watchos.zip
+            )
+
+            (
+                cd ${FOLDER}/tvos
+                unzip ${WORKSPACE}/realm-swift-framework-tvos.zip
+            )
+        fi
+
+        (
+            cd ${WORKSPACE}/tightdb_objc
+            cp -R plugin ${FOLDER}
+            cp LICENSE ${FOLDER}/LICENSE.txt
+            if [[ "${LANG}" == "objc" ]]; then
+                cp Realm/Swift/RLMSupport.swift ${FOLDER}/Swift/
+            fi
+        )
+
+        (
+            cd ${FOLDER}
+            unzip ${WORKSPACE}/realm-examples.zip
+            cd examples
+            if [[ "${LANG}" == "objc" ]]; then
+                rm -rf ios/swift-2.2
+            else
+                rm -rf ios/objc ios/rubymotion osx
+            fi
+        )
+
+        cat > ${FOLDER}/docs.webloc <<EOF
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+    <key>URL</key>
+    <string>https://realm.io/docs/${LANG}/${VERSION}</string>
+</dict>
+</plist>
+EOF
+
+        (
+          cd ${TEMPDIR}
+          zip --symlinks -r realm-${LANG}-${VERSION}.zip realm-${LANG}-${VERSION}
+          mv realm-${LANG}-${VERSION}.zip ${WORKSPACE}
+        )
+        ;;
+
+    "test-package-release")
+        # Generate a release package locally for testing purposes
+        # Real releases should always be done via Jenkins
+        if [ -z "${WORKSPACE}" ]; then
+            echo 'WORKSPACE must be set to a directory to assemble the release in'
+            exit 1
+        fi
+        if [ -d "${WORKSPACE}" ]; then
+            echo 'WORKSPACE directory should not already exist'
+            exit 1
+        fi
+
+        REALM_SOURCE="$(pwd)"
+        mkdir -p "$WORKSPACE"
+        WORKSPACE="$(cd "$WORKSPACE" && pwd)"
+        export WORKSPACE
+        cd $WORKSPACE
+        git clone $REALM_SOURCE tightdb_objc
+
+        echo 'Packaging iOS static'
+        sh tightdb_objc/build.sh package-ios-static
+        cp tightdb_objc/build/ios-static/realm-framework-ios.zip .
+
+        echo 'Packaging iOS dynamic'
+        sh tightdb_objc/build.sh package-ios-dynamic
+        cp tightdb_objc/build/ios/realm-dynamic-framework-ios.zip .
+
+        echo 'Packaging OS X'
+        sh tightdb_objc/build.sh package-osx
+        cp tightdb_objc/build/DerivedData/Realm/Build/Products/Release/realm-framework-osx.zip .
+
+        echo 'Packaging examples'
+        (
+            cd tightdb_objc/examples
+            git clean -xfd
+        )
+        sh tightdb_objc/build.sh package-examples
+        cp tightdb_objc/realm-examples.zip .
+
+        echo 'Packaging iOS Swift'
+        sh tightdb_objc/build.sh package-ios-swift
+        cp tightdb_objc/build/ios/realm-swift-framework-ios.zip .
+
+        echo 'Packaging OS X Swift'
+        sh tightdb_objc/build.sh package-osx-swift
+        cp tightdb_objc/build/osx/realm-swift-framework-osx.zip .
+
+        echo 'Packaging watchOS'
+        sh tightdb_objc/build.sh package-watchos
+        sh tightdb_objc/build.sh package-watchos-swift
+        cp tightdb_objc/build/watchos/realm-swift-framework-watchos.zip .
+        cp tightdb_objc/build/watchos/realm-framework-watchos.zip .
+
+        echo 'Packaging tvOS'
+        sh tightdb_objc/build.sh package-tvos
+        sh tightdb_objc/build.sh package-tvos-swift
+        cp tightdb_objc/build/tvos/realm-swift-framework-tvos.zip .
+        cp tightdb_objc/build/tvos/realm-framework-tvos.zip .
+
+        echo 'Building final release packages'
+        sh tightdb_objc/build.sh package-release objc
+        sh tightdb_objc/build.sh package-release swift
+
+        echo 'Testing packaged examples'
+        sh tightdb_objc/build.sh package-test-examples
+
+        ;;
+
+    "github-release")
+        if [ -z "${GITHUB_ACCESS_TOKEN}" ]; then
+            echo 'GITHUB_ACCESS_TOKEN must be set to create GitHub releases'
+            exit 1
+        fi
+        ./scripts/github_release.rb
+        ;;
+
+    "add-empty-changelog")
+        empty_section=$(cat <<EOS
+x.x.x Release notes (yyyy-MM-dd)
+=============================================================
+
+### API breaking changes
+
+* None.
+
+### Enhancements
+
+* None.
+
+### Bugfixes
+
+* None.
+EOS)
+        changelog=$(cat CHANGELOG.md)
+        echo "$empty_section" > CHANGELOG.md
+        echo >> CHANGELOG.md
+        echo "$changelog" >> CHANGELOG.md
+        ;;
+
+    *)
+        echo "Unknown command '$COMMAND'"
+        usage
+        exit 1
+        ;;
+esac
diff --git a/Pods/Realm/core/librealm-macosx.a b/Pods/Realm/core/librealm-macosx.a
new file mode 100644
index 0000000..63263e7
Binary files /dev/null and b/Pods/Realm/core/librealm-macosx.a differ
diff --git a/Pods/Realm/include/RLMAccessor.h b/Pods/Realm/include/RLMAccessor.h
new file mode 100644
index 0000000..0ec6677
--- /dev/null
+++ b/Pods/Realm/include/RLMAccessor.h
@@ -0,0 +1,63 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import <Foundation/Foundation.h>
+
+
+@class RLMObjectSchema, RLMProperty, RLMObjectBase, RLMProperty;
+
+#ifdef __cplusplus
+typedef NSUInteger RLMCreationOptions;
+#else
+typedef NS_OPTIONS(NSUInteger, RLMCreationOptions);
+#endif
+
+NS_ASSUME_NONNULL_BEGIN
+
+//
+// Accessors Class Creation/Caching
+//
+
+// get accessor classes for an object class - generates classes if not cached
+Class RLMAccessorClassForObjectClass(Class objectClass, RLMObjectSchema *schema, NSString *prefix);
+Class RLMUnmanagedAccessorClassForObjectClass(Class objectClass, RLMObjectSchema *schema);
+
+// Check if a given class is a generated accessor class
+bool RLMIsGeneratedClass(Class cls);
+
+//
+// Dynamic getters/setters
+//
+FOUNDATION_EXTERN void RLMDynamicValidatedSet(RLMObjectBase *obj, NSString *propName, id __nullable val);
+FOUNDATION_EXTERN RLMProperty *RLMValidatedGetProperty(RLMObjectBase *obj, NSString *propName);
+FOUNDATION_EXTERN id __nullable RLMDynamicGet(RLMObjectBase *obj, RLMProperty *prop);
+
+// by property/column
+FOUNDATION_EXTERN void RLMDynamicSet(RLMObjectBase *obj, RLMProperty *prop, id val, RLMCreationOptions options);
+
+//
+// Class modification
+//
+
+// Replace className method for the given class
+void RLMReplaceClassNameMethod(Class accessorClass, NSString *className);
+
+// Replace sharedSchema method for the given class
+void RLMReplaceSharedSchemaMethod(Class accessorClass, RLMObjectSchema * __nullable schema);
+
+NS_ASSUME_NONNULL_END
diff --git a/Pods/Realm/include/RLMAnalytics.hpp b/Pods/Realm/include/RLMAnalytics.hpp
new file mode 100644
index 0000000..76bc429
--- /dev/null
+++ b/Pods/Realm/include/RLMAnalytics.hpp
@@ -0,0 +1,55 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2015 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+// Asynchronously submits build information to Realm if running in an iOS
+// simulator or on OS X if a debugger is attached. Does nothing if running on an
+// iOS / watchOS device or if a debugger is *not* attached.
+//
+// To be clear: this does *not* run when your app is in production or on
+// your end-user’s devices; it will only run in the simulator or when a debugger
+// is attached.
+//
+// Why are we doing this? In short, because it helps us build a better product
+// for you. None of the data personally identifies you, your employer or your
+// app, but it *will* help us understand what language you use, what iOS
+// versions you target, etc. Having this info will help prioritizing our time,
+// adding new features and deprecating old features. Collecting an anonymized
+// bundle & anonymized MAC is the only way for us to count actual usage of the
+// other metrics accurately. If we don’t have a way to deduplicate the info
+// reported, it will be useless, as a single developer building their Swift app
+// 10 times would report 10 times more than a single Objective-C developer that
+// only builds once, making the data all but useless.
+// No one likes sharing data unless it’s necessary, we get it, and we’ve
+// debated adding this for a long long time. Since Realm is a free product
+// without an email signup, we feel this is a necessary step so we can collect
+// relevant data to build a better product for you. If you truly, absolutely
+// feel compelled to not send this data back to Realm, then you can set an env
+// variable named REALM_DISABLE_ANALYTICS. Since Realm is free we believe
+// letting these analytics run is a small price to pay for the product & support
+// we give you.
+//
+// Currently the following information is reported:
+// - What version of Realm is being used, and from which language (obj-c or Swift).
+// - What version of OS X it's running on (in case Xcode aggressively drops
+//   support for older versions again, we need to know what we need to support).
+// - The minimum iOS/OS X version that the application is targeting (again, to
+//   help us decide what versions we need to support). 
+// - An anonymous MAC address and bundle ID to aggregate the other information on.
+// - What version of Swift is being used (if applicable).
+
+void RLMSendAnalytics();
diff --git a/Pods/Realm/include/RLMArray.h b/Pods/Realm/include/RLMArray.h
new file mode 100644
index 0000000..fc2ef9f
--- /dev/null
+++ b/Pods/Realm/include/RLMArray.h
@@ -0,0 +1,369 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import <Foundation/Foundation.h>
+
+#import <Realm/RLMCollection.h>
+
+NS_ASSUME_NONNULL_BEGIN
+
+@class RLMObject, RLMRealm, RLMResults<RLMObjectType: RLMObject *>, RLMNotificationToken;
+
+/**
+ `RLMArray` is the container type in Realm used to define to-many relationships.
+
+ Unlike an `NSArray`, `RLMArray`s hold a single type, specified by the `objectClassName` property.
+ This is referred to in these docs as the “type” of the array.
+
+ When declaring an `RLMArray` property, the type must be marked as conforming to a
+ protocol by the same name as the objects it should contain (see the
+ `RLM_ARRAY_TYPE` macro). In addition, the property can be declared using Objective-C
+ generics for better compile-time type safety.
+
+     RLM_ARRAY_TYPE(ObjectType)
+     ...
+     @property RLMArray<ObjectType *><ObjectType> *arrayOfObjectTypes;
+
+ `RLMArray`s can be queried with the same predicates as `RLMObject` and `RLMResult`s.
+
+ `RLMArray`s cannot be created directly. `RLMArray` properties on `RLMObject`s are
+ lazily created when accessed, or can be obtained by querying a Realm.
+
+ ### Key-Value Observing
+
+ `RLMArray` supports array key-value observing on `RLMArray` properties on `RLMObject`
+ subclasses, and the `invalidated` property on `RLMArray` instances themselves is
+ key-value observing compliant when the `RLMArray` is attached to a managed
+ `RLMObject` (`RLMArray`s on unmanaged `RLMObject`s will never become invalidated).
+
+ Because `RLMArray`s are attached to the object which they are a property of, they
+ do not require using the mutable collection proxy objects from
+ `-mutableArrayValueForKey:` or KVC-compatible mutation methods on the containing
+ object. Instead, you can call the mutation methods on the `RLMArray` directly.
+ */
+
+@interface RLMArray<RLMObjectType: RLMObject *> : NSObject<RLMCollection, NSFastEnumeration>
+
+#pragma mark - Properties
+
+/**
+ The number of objects in the array.
+ */
+@property (nonatomic, readonly, assign) NSUInteger count;
+
+/**
+ The class name (i.e. type) of the `RLMObject`s contained in the array.
+ */
+@property (nonatomic, readonly, copy) NSString *objectClassName;
+
+/**
+ The Realm which manages the array. Returns `nil` for unmanaged arrays.
+ */
+@property (nonatomic, readonly, nullable) RLMRealm *realm;
+
+/**
+ Indicates if the array can no longer be accessed.
+ */
+@property (nonatomic, readonly, getter = isInvalidated) BOOL invalidated;
+
+#pragma mark - Accessing Objects from an Array
+
+/**
+ Returns the object at the index specified.
+
+ @param index   The index to look up.
+
+ @return An `RLMObject` of the type contained in the array.
+ */
+- (RLMObjectType)objectAtIndex:(NSUInteger)index;
+
+/**
+ Returns the first object in the array.
+
+ Returns `nil` if called on an empty array.
+
+ @return An `RLMObject` of the type contained in the array.
+ */
+- (nullable RLMObjectType)firstObject;
+
+/**
+ Returns the last object in the array.
+
+ Returns `nil` if called on an empty array.
+
+ @return An `RLMObject` of the type contained in the array.
+ */
+- (nullable RLMObjectType)lastObject;
+
+
+
+#pragma mark - Adding, Removing, and Replacing Objects in an Array
+
+/**
+ Adds an object to the end of the array.
+
+ @warning This method may only be called during a write transaction.
+
+ @param object  An `RLMObject` of the type contained in the array.
+ */
+- (void)addObject:(RLMObjectType)object;
+
+/**
+ Adds an array of objects to the end of the array.
+
+ @warning This method may only be called during a write transaction.
+
+ @param objects     An enumerable object such as `NSArray` or `RLMResults` which contains objects of the
+                    same class as the array.
+ */
+- (void)addObjects:(id<NSFastEnumeration>)objects;
+
+/**
+ Inserts an object at the given index.
+
+ Throws an exception if the index exceeds the bounds of the array.
+
+ @warning This method may only be called during a write transaction.
+
+ @param anObject  An `RLMObject` of the type contained in the array.
+ @param index   The index at which to insert the object.
+ */
+- (void)insertObject:(RLMObjectType)anObject atIndex:(NSUInteger)index;
+
+/**
+ Removes an object at the given index.
+
+ Throws an exception if the index exceeds the bounds of the array.
+
+ @warning This method may only be called during a write transaction.
+
+ @param index   The array index identifying the object to be removed.
+ */
+- (void)removeObjectAtIndex:(NSUInteger)index;
+
+/**
+ Removes the last object in the array.
+
+ @warning This method may only be called during a write transaction.
+*/
+- (void)removeLastObject;
+
+/**
+ Removes all objects from the array.
+
+ @warning This method may only be called during a write transaction.
+ */
+- (void)removeAllObjects;
+
+/**
+ Replaces an object at the given index with a new object.
+
+ Throws an exception if the index exceeds the bounds of the array.
+
+ @warning This method may only be called during a write transaction.
+
+ @param index       The index of the object to be replaced.
+ @param anObject    An object (of the same type as returned from the `objectClassName` selector).
+ */
+- (void)replaceObjectAtIndex:(NSUInteger)index withObject:(RLMObjectType)anObject;
+
+/**
+ Moves the object at the given source index to the given destination index.
+
+ Throws an exception if the index exceeds the bounds of the array.
+
+ @warning This method may only be called during a write transaction.
+
+ @param sourceIndex      The index of the object to be moved.
+ @param destinationIndex The index to which the object at `sourceIndex` should be moved.
+ */
+- (void)moveObjectAtIndex:(NSUInteger)sourceIndex toIndex:(NSUInteger)destinationIndex;
+
+/**
+ Exchanges the objects in the array at given indices.
+
+ Throws an exception if either index exceeds the bounds of the array.
+
+ @warning This method may only be called during a write transaction.
+
+ @param index1 The index of the object which should replace the object at index `index2`.
+ @param index2 The index of the object which should replace the object at index `index1`.
+ */
+- (void)exchangeObjectAtIndex:(NSUInteger)index1 withObjectAtIndex:(NSUInteger)index2;
+
+#pragma mark - Querying an Array
+
+/**
+ Returns the index of an object in the array.
+
+ Returns `NSNotFound` if the object is not found in the array.
+
+ @param object  An object (of the same type as returned from the `objectClassName` selector).
+ */
+- (NSUInteger)indexOfObject:(RLMObjectType)object;
+
+/**
+ Returns the index of the first object in the array matching the predicate.
+
+ @param predicateFormat A predicate format string, optionally followed by a variable number of arguments.
+
+ @return    The index of the object, or `NSNotFound` if the object is not found in the array.
+ */
+- (NSUInteger)indexOfObjectWhere:(NSString *)predicateFormat, ...;
+
+/// :nodoc:
+- (NSUInteger)indexOfObjectWhere:(NSString *)predicateFormat args:(va_list)args;
+
+/**
+ Returns the index of the first object in the array matching the predicate.
+
+ @param predicate   The predicate with which to filter the objects.
+
+ @return    The index of the object, or `NSNotFound` if the object is not found in the array.
+ */
+- (NSUInteger)indexOfObjectWithPredicate:(NSPredicate *)predicate;
+
+/**
+ Returns all the objects matching the given predicate in the array.
+
+ @param predicateFormat A predicate format string, optionally followed by a variable number of arguments.
+
+ @return                An `RLMResults` of objects that match the given predicate.
+ */
+- (RLMResults<RLMObjectType> *)objectsWhere:(NSString *)predicateFormat, ...;
+
+/// :nodoc:
+- (RLMResults<RLMObjectType> *)objectsWhere:(NSString *)predicateFormat args:(va_list)args;
+
+/**
+ Returns all the objects matching the given predicate in the array.
+
+ @param predicate   The predicate with which to filter the objects.
+
+ @return            An `RLMResults` of objects that match the given predicate
+ */
+- (RLMResults<RLMObjectType> *)objectsWithPredicate:(NSPredicate *)predicate;
+
+/**
+ Returns a sorted `RLMResults` from the array.
+
+ @param property    The property name to sort by.
+ @param ascending   The direction to sort in.
+
+ @return    An `RLMResults` sorted by the specified property.
+ */
+- (RLMResults<RLMObjectType> *)sortedResultsUsingProperty:(NSString *)property ascending:(BOOL)ascending;
+
+/**
+ Returns a sorted `RLMResults` from the array.
+
+ @param properties  An array of `RLMSortDescriptor`s to sort by.
+
+ @return    An `RLMResults` sorted by the specified properties.
+ */
+- (RLMResults<RLMObjectType> *)sortedResultsUsingDescriptors:(NSArray *)properties;
+
+/// :nodoc:
+- (RLMObjectType)objectAtIndexedSubscript:(NSUInteger)index;
+
+/// :nodoc:
+- (void)setObject:(RLMObjectType)newValue atIndexedSubscript:(NSUInteger)index;
+
+#pragma mark - Notifications
+
+/**
+ Registers a block to be called each time the array changes.
+
+ The block will be asynchronously called with the initial array, and then
+ called again after each write transaction which changes any of the objects in
+ the array, which objects are in the results, or the order of the objects in the
+ array.
+
+ The `changes` parameter will be `nil` the first time the block is called.
+ For each call after that, it will contain information about
+ which rows in the array were added, removed or modified. If a write transaction
+ did not modify any objects in the array, the block is not called at all.
+ See the `RLMCollectionChange` documentation for information on how the changes
+ are reported and an example of updating a `UITableView`.
+
+ If an error occurs the block will be called with `nil` for the results
+ parameter and a non-`nil` error. Currently the only errors that can occur are
+ when opening the Realm on the background worker thread.
+
+ Notifications are delivered via the standard run loop, and so can't be
+ delivered while the run loop is blocked by other activity. When
+ notifications can't be delivered instantly, multiple notifications may be
+ coalesced into a single notification. This can include the notification
+ with the initial results. For example, the following code performs a write
+ transaction immediately after adding the notification block, so there is no
+ opportunity for the initial notification to be delivered first. As a
+ result, the initial notification will reflect the state of the Realm after
+ the write transaction.
+
+     Person *person = [[Person allObjectsInRealm:realm] firstObject];
+     NSLog(@"person.dogs.count: %zu", person.dogs.count); // => 0
+     self.token = [person.dogs addNotificationBlock(RLMArray<Dog *> *dogs,
+                                                    RLMCollectionChange *changes,
+                                                    NSError *error) {
+         // Only fired once for the example
+         NSLog(@"dogs.count: %zu", dogs.count) // => 1
+     }];
+     [realm transactionWithBlock:^{
+         Dog *dog = [[Dog alloc] init];
+         dog.name = @"Rex";
+         [person.dogs addObject:dog];
+     }];
+     // end of run loop execution context
+
+ You must retain the returned token for as long as you want updates to continue
+ to be sent to the block. To stop receiving updates, call `-stop` on the token.
+
+ @warning This method cannot be called during a write transaction, or when the
+          containing Realm is read-only.
+ @warning This method may only be called on a managed array.
+
+ @param block The block to be called each time the array changes.
+ @return A token which must be held for as long as you want updates to be delivered.
+ */
+- (RLMNotificationToken *)addNotificationBlock:(void (^)(RLMArray<RLMObjectType> *__nullable array,
+                                                         RLMCollectionChange *__nullable changes,
+                                                         NSError *__nullable error))block __attribute__((warn_unused_result));
+
+#pragma mark - Unavailable Methods
+
+/**
+ `-[RLMArray init]` is not available because `RLMArray`s cannot be created directly.
+ `RLMArray` properties on `RLMObject`s are lazily created when accessed, or can be obtained by querying a Realm.
+ */
+- (instancetype)init __attribute__((unavailable("RLMArrays cannot be created directly")));
+
+/**
+ `+[RLMArray new]` is not available because `RLMArray`s cannot be created directly.
+ `RLMArray` properties on `RLMObject`s are lazily created when accessed, or can be obtained by querying a Realm.
+ */
++ (instancetype)new __attribute__((unavailable("RLMArrays cannot be created directly")));
+
+@end
+
+/// :nodoc:
+@interface RLMArray (Swift)
+// for use only in Swift class definitions
+- (instancetype)initWithObjectClassName:(NSString *)objectClassName;
+@end
+
+NS_ASSUME_NONNULL_END
diff --git a/Pods/Realm/include/RLMArray_Private.h b/Pods/Realm/include/RLMArray_Private.h
new file mode 100644
index 0000000..592dd57
--- /dev/null
+++ b/Pods/Realm/include/RLMArray_Private.h
@@ -0,0 +1,24 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import <Realm/RLMArray.h>
+
+@interface RLMArray ()
+- (instancetype)initWithObjectClassName:(NSString *)objectClassName;
+- (NSString *)descriptionWithMaxDepth:(NSUInteger)depth;
+@end
diff --git a/Pods/Realm/include/RLMArray_Private.hpp b/Pods/Realm/include/RLMArray_Private.hpp
new file mode 100644
index 0000000..7eb9eb5
--- /dev/null
+++ b/Pods/Realm/include/RLMArray_Private.hpp
@@ -0,0 +1,80 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import "RLMArray_Private.h"
+
+#import "RLMCollection_Private.hpp"
+
+#import <Realm/RLMResults.h>
+
+#import <realm/link_view_fwd.hpp>
+#import <vector>
+
+namespace realm {
+    class LinkView;
+    class Results;
+    class TableView;
+    struct SortOrder;
+}
+
+@class RLMObjectBase;
+@class RLMObjectSchema;
+class RLMObservationInfo;
+
+@interface RLMArray () {
+  @protected
+    NSString *_objectClassName;
+  @public
+    // The name of the property which this RLMArray represents
+    NSString *_key;
+    __weak RLMObjectBase *_parentObject;
+}
+@end
+
+//
+// LinkView backed RLMArray subclass
+//
+@interface RLMArrayLinkView : RLMArray <RLMFastEnumerable>
+@property (nonatomic, unsafe_unretained) RLMObjectSchema *objectSchema;
+
++ (RLMArrayLinkView *)arrayWithObjectClassName:(NSString *)objectClassName
+                                          view:(realm::LinkViewRef)view
+                                         realm:(RLMRealm *)realm
+                                           key:(NSString *)key
+                                  parentSchema:(RLMObjectSchema *)parentSchema;
+
+// deletes all objects in the RLMArray from their containing realms
+- (void)deleteObjectsFromRealm;
+@end
+
+void RLMValidateArrayObservationKey(NSString *keyPath, RLMArray *array);
+
+// Initialize the observation info for an array if needed
+void RLMEnsureArrayObservationInfo(std::unique_ptr<RLMObservationInfo>& info,
+                                   NSString *keyPath, RLMArray *array, id observed);
+
+
+//
+// RLMResults private methods
+//
+@interface RLMResults () <RLMFastEnumerable>
++ (instancetype)resultsWithObjectSchema:(RLMObjectSchema *)objectSchema
+                                   results:(realm::Results)results;
+
+- (void)deleteObjectsFromRealm;
+@end
diff --git a/Pods/Realm/include/RLMCollection.h b/Pods/Realm/include/RLMCollection.h
new file mode 100644
index 0000000..030fcc7
--- /dev/null
+++ b/Pods/Realm/include/RLMCollection.h
@@ -0,0 +1,325 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import <Foundation/Foundation.h>
+
+NS_ASSUME_NONNULL_BEGIN
+
+@class RLMRealm, RLMResults, RLMObject, RLMSortDescriptor, RLMNotificationToken, RLMCollectionChange;
+
+/**
+ A homogenous collection of `RLMObject` instances. Examples of conforming types include `RLMArray`,
+ `RLMResults`, and `RLMLinkingObjects`.
+ */
+@protocol RLMCollection <NSFastEnumeration>
+
+@required
+
+#pragma mark - Properties
+
+/**
+ The number of objects in the collection.
+ */
+@property (nonatomic, readonly, assign) NSUInteger count;
+
+/**
+ The class name (i.e. type) of the `RLMObject`s contained in the collection.
+ */
+@property (nonatomic, readonly, copy) NSString *objectClassName;
+
+/**
+ The Realm which manages the collection, or `nil` for unmanaged collections.
+ */
+@property (nonatomic, readonly) RLMRealm *realm;
+
+#pragma mark - Accessing Objects from a Collection
+
+/**
+ Returns the object at the index specified.
+
+ @param index   The index to look up.
+
+ @return An `RLMObject` of the type contained in the collection.
+ */
+- (id)objectAtIndex:(NSUInteger)index;
+
+/**
+ Returns the first object in the collection.
+
+ Returns `nil` if called on an empty collection.
+
+ @return An `RLMObject` of the type contained in the collection.
+ */
+- (nullable id)firstObject;
+
+/**
+ Returns the last object in the collection.
+
+ Returns `nil` if called on an empty collection.
+
+ @return An `RLMObject` of the type contained in the collection.
+ */
+- (nullable id)lastObject;
+
+#pragma mark - Querying a Collection
+
+/**
+ Returns the index of an object in the collection.
+
+ Returns `NSNotFound` if the object is not found in the collection.
+
+ @param object  An object (of the same type as returned from the `objectClassName` selector).
+ */
+- (NSUInteger)indexOfObject:(RLMObject *)object;
+
+/**
+ Returns the index of the first object in the collection matching the predicate.
+
+ @param predicateFormat A predicate format string, optionally followed by a variable number of arguments.
+
+ @return    The index of the object, or `NSNotFound` if the object is not found in the collection.
+ */
+- (NSUInteger)indexOfObjectWhere:(NSString *)predicateFormat, ...;
+
+/// :nodoc:
+- (NSUInteger)indexOfObjectWhere:(NSString *)predicateFormat args:(va_list)args;
+
+/**
+ Returns the index of the first object in the collection matching the predicate.
+
+ @param predicate   The predicate with which to filter the objects.
+
+ @return    The index of the object, or `NSNotFound` if the object is not found in the collection.
+ */
+- (NSUInteger)indexOfObjectWithPredicate:(NSPredicate *)predicate;
+
+/**
+ Returns all objects matching the given predicate in the collection.
+
+ @param predicateFormat A predicate format string, optionally followed by a variable number of arguments.
+
+ @return    An `RLMResults` containing objects that match the given predicate.
+ */
+- (RLMResults *)objectsWhere:(NSString *)predicateFormat, ...;
+
+/// :nodoc:
+- (RLMResults *)objectsWhere:(NSString *)predicateFormat args:(va_list)args;
+
+/**
+ Returns all objects matching the given predicate in the collection.
+
+ @param predicate   The predicate with which to filter the objects.
+
+ @return            An `RLMResults` containing objects that match the given predicate.
+ */
+- (RLMResults *)objectsWithPredicate:(NSPredicate *)predicate;
+
+/**
+ Returns a sorted `RLMResults` from the collection.
+
+ @param property    The property name to sort by.
+ @param ascending   The direction to sort in.
+
+ @return    An `RLMResults` sorted by the specified property.
+ */
+- (RLMResults *)sortedResultsUsingProperty:(NSString *)property ascending:(BOOL)ascending;
+
+/**
+ Returns a sorted `RLMResults` from the collection.
+
+ @param properties  An array of `RLMSortDescriptor`s to sort by.
+
+ @return    An `RLMResults` sorted by the specified properties.
+ */
+- (RLMResults *)sortedResultsUsingDescriptors:(NSArray<RLMSortDescriptor *> *)properties;
+
+/// :nodoc:
+- (id)objectAtIndexedSubscript:(NSUInteger)index;
+
+/**
+ Returns an `NSArray` containing the results of invoking `valueForKey:` using `key` on each of the collection's objects.
+
+ @param key The name of the property.
+
+ @return An `NSArray` containing results.
+ */
+- (nullable id)valueForKey:(NSString *)key;
+
+/**
+ Invokes `setValue:forKey:` on each of the collection's objects using the specified `value` and `key`.
+
+ @warning This method may only be called during a write transaction.
+
+ @param value The object value.
+ @param key   The name of the property.
+ */
+- (void)setValue:(nullable id)value forKey:(NSString *)key;
+
+#pragma mark - Notifications
+
+/**
+ Registers a block to be called each time the collection changes.
+
+ The block will be asynchronously called with the initial collection, and then
+ called again after each write transaction which changes either any of the
+ objects in the collection, or which objects are in the collection.
+
+ The `change` parameter will be `nil` the first time the block is called.
+ For each call after that, it will contain information about
+ which rows in the collection were added, removed or modified. If a write transaction
+ did not modify any objects in this collection, the block is not called at all.
+ See the `RLMCollectionChange` documentation for information on how the changes
+ are reported and an example of updating a `UITableView`.
+
+ If an error occurs the block will be called with `nil` for the collection
+ parameter and a non-`nil` error. Currently the only errors that can occur are
+ when opening the Realm on the background worker thread.
+
+ At the time when the block is called, the collection object will be fully
+ evaluated and up-to-date, and as long as you do not perform a write transaction
+ on the same thread or explicitly call `-[RLMRealm refresh]`, accessing it will
+ never perform blocking work.
+
+ Notifications are delivered via the standard run loop, and so can't be
+ delivered while the run loop is blocked by other activity. When
+ notifications can't be delivered instantly, multiple notifications may be
+ coalesced into a single notification. This can include the notification
+ with the initial collection. For example, the following code performs a write
+ transaction immediately after adding the notification block, so there is no
+ opportunity for the initial notification to be delivered first. As a
+ result, the initial notification will reflect the state of the Realm after
+ the write transaction.
+
+     id<RLMCollection> collection = [Dog allObjects];
+     NSLog(@"dogs.count: %zu", dogs.count); // => 0
+     self.token = [collection addNotificationBlock:^(id<RLMCollection> dogs,
+                                                  RLMCollectionChange *changes,
+                                                  NSError *error) {
+         // Only fired once for the example
+         NSLog(@"dogs.count: %zu", dogs.count); // => 1
+     }];
+     [realm transactionWithBlock:^{
+         Dog *dog = [[Dog alloc] init];
+         dog.name = @"Rex";
+         [realm addObject:dog];
+     }];
+     // end of run loop execution context
+
+ You must retain the returned token for as long as you want updates to continue
+ to be sent to the block. To stop receiving updates, call `-stop` on the token.
+
+ @warning This method cannot be called during a write transaction, or when the
+          containing Realm is read-only.
+
+ @param block The block to be called each time the collection changes.
+ @return A token which must be held for as long as you want collection notifications to be delivered.
+ */
+- (RLMNotificationToken *)addNotificationBlock:(void (^)(id<RLMCollection> __nullable collection,
+                                                         RLMCollectionChange *__nullable change,
+                                                         NSError *__nullable error))block __attribute__((warn_unused_result));
+
+@end
+
+/**
+ An `RLMSortDescriptor` stores a property name and a sort order for use with
+ `sortedResultsUsingDescriptors:`. It is similar to `NSSortDescriptor`, but supports
+ only the subset of functionality which can be efficiently run by Realm's query
+ engine.
+ 
+ `RLMSortDescriptor` instances are immutable.
+ */
+@interface RLMSortDescriptor : NSObject
+
+#pragma mark - Properties
+
+/**
+ The name of the property which the sort descriptor orders results by.
+ */
+@property (nonatomic, readonly) NSString *property;
+
+/**
+ Whether the descriptor sorts in ascending or descending order.
+ */
+@property (nonatomic, readonly) BOOL ascending;
+
+#pragma mark - Methods
+
+/**
+ Returns a new sort descriptor for the given property name and sort direction.
+ */
++ (instancetype)sortDescriptorWithProperty:(NSString *)propertyName ascending:(BOOL)ascending;
+
+/**
+ Returns a copy of the receiver with the sort direction reversed.
+ */
+- (instancetype)reversedSortDescriptor;
+
+@end
+
+/**
+ A `RLMCollectionChange` object encapsulates information about changes to collections
+ that are reported by Realm notifications.
+
+ `RLMCollectionChange` is passed to the notification blocks registered with
+ `-addNotificationBlock` on `RLMArray` and `RLMResults`, and reports what rows in the
+ collection changed since the last time the notification block was called.
+
+ The change information is available in two formats: a simple array of row
+ indices in the collection for each type of change, and an array of index paths
+ in a requested section suitable for passing directly to `UITableView`'s batch
+ update methods. A complete example of updating a `UITableView` named `tv`:
+
+     [tv beginUpdates];
+     [tv deleteRowsAtIndexPaths:[changes deletionsInSection:0] withRowAnimation:UITableViewRowAnimationAutomatic];
+     [tv insertRowsAtIndexPaths:[changes insertionsInSection:0] withRowAnimation:UITableViewRowAnimationAutomatic];
+     [tv reloadRowsAtIndexPaths:[changes modificationsInSection:0] withRowAnimation:UITableViewRowAnimationAutomatic];
+     [tv endUpdates];
+
+ All of the arrays in an `RLMCollectionChange` are always sorted in ascending order.
+ */
+@interface RLMCollectionChange : NSObject
+/// The indices of objects in the previous version of the collection which have
+/// been removed from this one.
+@property (nonatomic, readonly) NSArray<NSNumber *> *deletions;
+
+/// The indices in the new version of the collection which were newly inserted.
+@property (nonatomic, readonly) NSArray<NSNumber *> *insertions;
+
+/**
+ The indices in the new version of the collection which were modified.
+ 
+ For `RLMResults`, this means that one or more of the properties of the object at
+ that index were modified (or an object linked to by that object was
+ modified).
+ 
+ For `RLMArray`, the array itself being modified to contain a
+ different object at that index will also be reported as a modification.
+ */
+@property (nonatomic, readonly) NSArray<NSNumber *> *modifications;
+
+/// Returns the index paths of the deletion indices in the given section.
+- (NSArray<NSIndexPath *> *)deletionsInSection:(NSUInteger)section;
+
+/// Returns the index paths of the insertion indices in the given section.
+- (NSArray<NSIndexPath *> *)insertionsInSection:(NSUInteger)section;
+
+/// Returns the index paths of the modification indices in the given section.
+- (NSArray<NSIndexPath *> *)modificationsInSection:(NSUInteger)section;
+@end
+
+NS_ASSUME_NONNULL_END
diff --git a/Pods/Realm/include/RLMCollection_Private.hpp b/Pods/Realm/include/RLMCollection_Private.hpp
new file mode 100644
index 0000000..e1df7e9
--- /dev/null
+++ b/Pods/Realm/include/RLMCollection_Private.hpp
@@ -0,0 +1,72 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2016 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import <Realm/RLMCollection.h>
+
+#import <Realm/RLMRealm.h>
+
+namespace realm {
+    class List;
+    class Results;
+    class TableView;
+    struct CollectionChangeSet;
+    struct NotificationToken;
+}
+@class RLMObjectSchema;
+
+@protocol RLMFastEnumerable
+@property (nonatomic, readonly) RLMRealm *realm;
+@property (nonatomic, readonly) RLMObjectSchema *objectSchema;
+@property (nonatomic, readonly) NSUInteger count;
+
+- (NSUInteger)indexInSource:(NSUInteger)index;
+- (realm::TableView)tableView;
+@end
+
+// An object which encapulates the shared logic for fast-enumerating RLMArray
+// and RLMResults, and has a buffer to store strong references to the current
+// set of enumerated items
+@interface RLMFastEnumerator : NSObject
+- (instancetype)initWithCollection:(id<RLMFastEnumerable>)collection
+                      objectSchema:(RLMObjectSchema *)objectSchema;
+
+// Detach this enumerator from the source collection. Must be called before the
+// source collection is changed.
+- (void)detach;
+
+- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state
+                                    count:(NSUInteger)len;
+@end
+
+@interface RLMCancellationToken : RLMNotificationToken
+- (instancetype)initWithToken:(realm::NotificationToken)token;
+@end
+
+@interface RLMCollectionChange ()
+- (instancetype)initWithChanges:(realm::CollectionChangeSet)indices;
+@end
+
+template<typename Collection>
+RLMNotificationToken *RLMAddNotificationBlock(id objcCollection,
+                                              Collection& collection,
+                                              void (^block)(id, RLMCollectionChange *, NSError *),
+                                              bool suppressInitialChange=false);
+
+NSArray *RLMCollectionValueForKey(id<RLMFastEnumerable> collection, NSString *key);
+void RLMCollectionSetValueForKey(id<RLMFastEnumerable> collection, NSString *key, id value);
+NSString *RLMDescriptionWithMaxDepth(NSString *name, id<RLMCollection> collection, NSUInteger depth);
diff --git a/Pods/Realm/include/RLMConstants.h b/Pods/Realm/include/RLMConstants.h
new file mode 100644
index 0000000..716eae0
--- /dev/null
+++ b/Pods/Realm/include/RLMConstants.h
@@ -0,0 +1,189 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import <Foundation/Foundation.h>
+
+// For compatibility with Xcode 7, before extensible string enums were introduced,
+#ifdef NS_EXTENSIBLE_STRING_ENUM
+#define RLM_EXTENSIBLE_STRING_ENUM NS_EXTENSIBLE_STRING_ENUM
+#define RLM_EXTENSIBLE_STRING_ENUM_CASE_SWIFT_NAME(_, extensible_string_enum) NS_SWIFT_NAME(extensible_string_enum)
+#else
+#define RLM_EXTENSIBLE_STRING_ENUM
+#define RLM_EXTENSIBLE_STRING_ENUM_CASE_SWIFT_NAME(fully_qualified, _) NS_SWIFT_NAME(fully_qualified)
+#endif
+
+#pragma mark - Enums
+
+/**
+ `RLMPropertyType` is an enumeration describing all property types supported in Realm models.
+
+ For more information, see [Realm Models](https://realm.io/docs/objc/latest/#models).
+ */
+// Make sure numbers match those in <realm/data_type.hpp>
+typedef NS_ENUM(int32_t, RLMPropertyType) {
+
+#pragma mark - Primitive types
+
+    /** Integers: `NSInteger`, `int`, `long`, `Int` (Swift) */
+    RLMPropertyTypeInt    = 0,
+    /** Booleans: `BOOL`, `bool`, `Bool` (Swift) */
+    RLMPropertyTypeBool   = 1,
+    /** Floating-point numbers: `float`, `Float` (Swift) */
+    RLMPropertyTypeFloat  = 9,
+    /** Double-precision floating-point numbers: `double`, `Double` (Swift) */
+    RLMPropertyTypeDouble = 10,
+
+#pragma mark - Object types
+
+    /** Strings: `NSString`, `String` (Swift) */
+    RLMPropertyTypeString = 2,
+    /** Binary data: `NSData` */
+    RLMPropertyTypeData   = 4,
+    /** 
+     Any object: `id`.
+     
+     This property type is no longer supported for new models. However, old models with any-typed properties are still
+     supported for migration purposes.
+     */
+    RLMPropertyTypeAny    = 6,
+    /** Dates: `NSDate` */
+    RLMPropertyTypeDate   = 8,
+
+#pragma mark - Array/Linked object types
+
+    /** Realm model objects. See [Realm Models](https://realm.io/docs/objc/latest/#models) for more information. */
+    RLMPropertyTypeObject = 12,
+    /** Realm arrays. See [Realm Models](https://realm.io/docs/objc/latest/#models) for more information. */
+    RLMPropertyTypeArray  = 13,
+    /** Realm linking objects. See [Realm Models](https://realm.io/docs/objc/latest/#models) for more information. */
+    RLMPropertyTypeLinkingObjects = 14,
+};
+
+/**
+ `RLMError` is an enumeration representing all recoverable errors. It is associated with the
+ Realm error domain specified in `RLMErrorDomain`.
+ */
+typedef NS_ENUM(NSInteger, RLMError) {
+    /** Denotes a general error that occurred when trying to open a Realm. */
+    RLMErrorFail                  = 1,
+
+    /** Denotes a file I/O error that occurred when trying to open a Realm. */
+    RLMErrorFileAccess            = 2,
+
+    /** 
+     Denotes a file permission error that ocurred when trying to open a Realm.
+     
+     This error can occur if the user does not have permission to open or create
+     the specified file in the specified access mode when opening a Realm.
+     */
+    RLMErrorFilePermissionDenied  = 3,
+
+    /** Denotes an error where a file was to be written to disk, but another file with the same name already exists. */
+    RLMErrorFileExists            = 4,
+
+    /**
+     Denotes an error that occurs if a file could not be found.
+     
+     This error may occur if a Realm file could not be found on disk when trying to open a
+     Realm as read-only, or if the directory part of the specified path was not found when
+     trying to write a copy.
+     */
+    RLMErrorFileNotFound          = 5,
+
+    /** 
+     Denotes an error that occurs if a file format upgrade is required to open the file,
+     but upgrades were explicitly disabled.
+     */
+    RLMErrorFileFormatUpgradeRequired = 6,
+
+    /** 
+     Denotes an error that occurs if the database file is currently open in another
+     process which cannot share with the current process due to an
+     architecture mismatch.
+     
+     This error may occur if trying to share a Realm file between an i386 (32-bit) iOS
+     Simulator and the Realm Browser application. In this case, please use the 64-bit
+     version of the iOS Simulator.
+     */
+    RLMErrorIncompatibleLockFile  = 8,
+
+    /** Denotes an error that occurs when there is insufficient available address space. */
+    RLMErrorAddressSpaceExhausted = 9,
+
+    /** Denotes an error that occurs if there is a schema version mismatch, so that a migration is required. */
+    RLMErrorSchemaMismatch = 10,
+};
+
+#pragma mark - Constants
+
+#pragma mark - Notification Constants
+
+/**
+ A notification indicating that changes were made to a Realm.
+*/
+typedef NSString * RLMNotification RLM_EXTENSIBLE_STRING_ENUM;
+
+/**
+ This notification is posted by a Realm when the data in that Realm has changed.
+
+ More specifically, this notification is posted after a Realm has been refreshed to
+ reflect a write transaction. This can happen when an autorefresh occurs, when
+ `-[RLMRealm refresh]` is called, after an implicit refresh from `-[RLMRealm beginWriteTransaction]`,
+ or after a local write transaction is completed.
+ */
+extern RLMNotification const RLMRealmRefreshRequiredNotification
+RLM_EXTENSIBLE_STRING_ENUM_CASE_SWIFT_NAME(RLMRealmRefreshRequiredNotification, RefreshRequired);
+
+/**
+ This notification is posted by a Realm when a write transaction has been
+ committed to a Realm on a different thread for the same file.
+
+ It is not posted if `-[RLMRealm autorefresh]` is enabled, or if the Realm is
+ refreshed before the notification has a chance to run.
+
+ Realms with autorefresh disabled should normally install a handler for this
+ notification which calls `-[RLMRealm refresh]` after doing some work. Refreshing
+ the Realm is optional, but not refreshing the Realm may lead to large Realm
+ files. This is because Realm must keep an extra copy of the data for the stale
+ Realm.
+ */
+extern RLMNotification const RLMRealmDidChangeNotification
+RLM_EXTENSIBLE_STRING_ENUM_CASE_SWIFT_NAME(RLMRealmDidChangeNotification, DidChange);
+
+#pragma mark - Other Constants
+
+/** The schema version used for uninitialized Realms */
+extern const uint64_t RLMNotVersioned;
+
+/** An error domain identifying Realm-specific errors. */
+extern NSString * const RLMErrorDomain;
+
+/** An error domain identifying non-specific system errors. */
+extern NSString * const RLMUnknownSystemErrorDomain;
+
+/** The corresponding value is the name of an exception thrown by Realm. */
+extern NSString * const RLMExceptionName;
+
+/** The corresponding value is a Realm file version. */
+extern NSString * const RLMRealmVersionKey;
+
+/** The corresponding key is the version of the underlying database engine. */
+extern NSString * const RLMRealmCoreVersionKey;
+
+/** The corresponding key is the Realm invalidated property name. */
+extern NSString * const RLMInvalidatedKey;
diff --git a/Pods/Realm/include/RLMListBase.h b/Pods/Realm/include/RLMListBase.h
new file mode 100644
index 0000000..a8057a6
--- /dev/null
+++ b/Pods/Realm/include/RLMListBase.h
@@ -0,0 +1,29 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import <Foundation/Foundation.h>
+
+@class RLMArray;
+
+// A base class for Swift generic Lists to make it possible to interact with
+// them from obj-c
+@interface RLMListBase : NSObject <NSFastEnumeration>
+@property (nonatomic, strong) RLMArray *_rlmArray;
+
+- (instancetype)initWithArray:(RLMArray *)array;
+@end
diff --git a/Pods/Realm/include/RLMMigration.h b/Pods/Realm/include/RLMMigration.h
new file mode 100644
index 0000000..7aeb9cd
--- /dev/null
+++ b/Pods/Realm/include/RLMMigration.h
@@ -0,0 +1,127 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import <Foundation/Foundation.h>
+
+NS_ASSUME_NONNULL_BEGIN
+
+@class RLMSchema;
+@class RLMArray;
+@class RLMObject;
+
+/**
+ A block type which provides both the old and new versions of an object in the Realm. Object 
+ properties can only be accessed using keyed subscripting.
+ 
+ @see `-[RLMMigration enumerateObjects:block:]`
+ 
+ @param oldObject The object from the original Realm (read-only).
+ @param newObject The object from the migrated Realm (read-write).
+*/
+typedef void (^RLMObjectMigrationBlock)(RLMObject * __nullable oldObject, RLMObject * __nullable newObject);
+
+/**
+ `RLMMigration` instances encapsulate information intended to facilitate a schema migration.
+ 
+ A `RLMMigration` instance is passed into a user-defined `RLMMigrationBlock` block when updating
+ the version of a Realm. This instance provides access to the old and new database schemas, the
+ objects in the Realm, and provides functionality for modifying the Realm during the migration.
+ */
+@interface RLMMigration : NSObject
+
+#pragma mark - Properties
+
+/**
+ Returns the old `RLMSchema`. This is the schema which describes the Realm before the
+ migration is applied.
+ */
+@property (nonatomic, readonly) RLMSchema *oldSchema;
+
+/**
+ Returns the new `RLMSchema`. This is the schema which describes the Realm after the
+ migration is applied.
+ */
+@property (nonatomic, readonly) RLMSchema *newSchema;
+
+
+#pragma mark - Altering Objects during a Migration
+
+/**
+ Enumerates all the objects of a given type in the Realm, providing both the old and new versions
+ of each object. Within the block, object properties can only be accessed using keyed subscripting.
+
+ @param className   The name of the `RLMObject` class to enumerate.
+
+ @warning   All objects returned are of a type specific to the current migration and should not be cast
+            to `className`. Instead, treat them as `RLMObject`s and use keyed subscripting to access
+            properties.
+ */
+- (void)enumerateObjects:(NSString *)className block:(RLMObjectMigrationBlock)block;
+
+/**
+ Creates and returns an `RLMObject` instance of type `className` in the Realm being migrated.
+ 
+ The `value` argument is used to populate the object. It can be a key-value coding compliant object, an array or 
+ dictionary returned from the methods in `NSJSONSerialization`, or an array containing one element for each managed
+ property. An exception will be thrown if any required properties are not present and those properties were not defined
+ with default values.
+
+ When passing in an `NSArray` as the `value` argument, all properties must be present, valid and in the same order as
+ the properties defined in the model.
+
+ @param className   The name of the `RLMObject` class to create.
+ @param value       The value used to populate the object.
+ */
+- (RLMObject *)createObject:(NSString *)className withValue:(id)value;
+
+/**
+ Deletes an object from a Realm during a migration.
+
+ It is permitted to call this method from within the block passed to `-[enumerateObjects:block:]`.
+
+ @param object  Object to be deleted from the Realm being migrated.
+ */
+- (void)deleteObject:(RLMObject *)object;
+
+/**
+ Deletes the data for the class with the given name.
+
+ All objects of the given class will be deleted. If the `RLMObject` subclass no longer exists in your program,
+ any remaining metadata for the class will be removed from the Realm file.
+
+ @param  name The name of the `RLMObject` class to delete.
+
+ @return A Boolean value indicating whether there was any data to delete.
+ */
+- (BOOL)deleteDataForClassName:(NSString *)name;
+
+/**
+ Renames a property of the given class from `oldName` to `newName`.
+
+ @param className The name of the class whose property should be renamed. This class must be present
+                  in both the old and new Realm schemas.
+ @param oldName   The old name for the property to be renamed. There must not be a property with this name in the
+                  class as defined by the new Realm schema.
+ @param newName   The new name for the property to be renamed. There must not be a property with this name in the
+                  class as defined by the old Realm schema.
+ */
+- (void)renamePropertyForClass:(NSString *)className oldName:(NSString *)oldName newName:(NSString *)newName;
+
+@end
+
+NS_ASSUME_NONNULL_END
diff --git a/Pods/Realm/include/RLMMigration_Private.h b/Pods/Realm/include/RLMMigration_Private.h
new file mode 100644
index 0000000..4b54c89
--- /dev/null
+++ b/Pods/Realm/include/RLMMigration_Private.h
@@ -0,0 +1,34 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import <Realm/RLMMigration.h>
+#import <Realm/RLMObjectBase.h>
+#import <Realm/RLMRealm.h>
+
+typedef void (^RLMObjectBaseMigrationBlock)(RLMObjectBase *oldObject, RLMObjectBase *newObject);
+
+@interface RLMMigration ()
+
+@property (nonatomic, strong) RLMRealm *oldRealm;
+@property (nonatomic, strong) RLMRealm *realm;
+
+- (instancetype)initWithRealm:(RLMRealm *)realm oldRealm:(RLMRealm *)oldRealm;
+
+- (void)execute:(RLMMigrationBlock)block;
+
+@end
diff --git a/Pods/Realm/include/RLMObject.h b/Pods/Realm/include/RLMObject.h
new file mode 100644
index 0000000..b0ce0da
--- /dev/null
+++ b/Pods/Realm/include/RLMObject.h
@@ -0,0 +1,445 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import <Foundation/Foundation.h>
+
+#import <Realm/RLMObjectBase.h>
+
+NS_ASSUME_NONNULL_BEGIN
+
+@class RLMPropertyDescriptor;
+@class RLMRealm;
+@class RLMResults;
+@class RLMObjectSchema;
+
+/**
+ `RLMObject` is a base class for model objects representing data stored in Realms.
+
+ Define your model classes by subclassing `RLMObject` and adding properties to be managed.
+ Then instantiate and use your custom subclasses instead of using the `RLMObject` class directly.
+
+     // Dog.h
+     @interface Dog : RLMObject
+     @property NSString *name;
+     @property BOOL      adopted;
+     @end
+ 
+     // Dog.m
+     @implementation Dog
+     @end //none needed
+ 
+ ### Supported property types
+ 
+ - `NSString`
+ - `NSInteger`, `int`, `long`, `float`, and `double`
+ - `BOOL` or `bool`
+ - `NSDate`
+ - `NSData`
+ - `NSNumber<X>`, where `X` is one of `RLMInt`, `RLMFloat`, `RLMDouble` or `RLMBool`, for optional number properties
+ - `RLMObject` subclasses, to model many-to-one relationships.
+ - `RLMArray<X>`, where `X` is an `RLMObject` subclass, to model many-to-many relationships.
+
+ ### Querying
+ 
+ You can initiate queries directly via the class methods: `allObjects`, `objectsWhere:`, and `objectsWithPredicate:`.
+ These methods allow you to easily query a custom subclass for instances of that class in the default Realm.
+ 
+ To search in a Realm other than the default Realm, use the `allObjectsInRealm:`, `objectsInRealm:where:`,
+ and `objectsInRealm:withPredicate:` class methods.
+ 
+ @see `RLMRealm`
+ 
+ ### Relationships
+ 
+ See our [Cocoa guide](https://realm.io/docs/objc/latest#relationships) for more details.
+
+ ### Key-Value Observing
+
+ All `RLMObject` properties (including properties you create in subclasses) are
+ [Key-Value Observing compliant](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html),
+ except for `realm` and `objectSchema`.
+ 
+ Keep the following tips in mind when observing Realm objects:
+
+ 1. Unlike `NSMutableArray` properties, `RLMArray` properties do not require
+    using the proxy object returned from `-mutableArrayValueForKey:`, or defining
+    KVC mutation methods on the containing class. You can simply call methods on
+    the `RLMArray` directly; any changes will be automatically observed by the containing
+    object.
+ 2. Unmanaged `RLMObject` instances cannot be added to a Realm while they have any
+    observed properties.
+ 3. Modifying managed `RLMObject`s within `-observeValueForKeyPath:ofObject:change:context:`
+    is not recommended. Properties may change even when the Realm is not in a write
+    transaction (for example, when `-[RLMRealm refresh]` is called after changes
+    are made on a different thread), and notifications sent prior to the change
+    being applied (when `NSKeyValueObservingOptionPrior` is used) may be sent at
+    times when you *cannot* begin a write transaction.
+ */
+
+@interface RLMObject : RLMObjectBase
+
+#pragma mark - Creating & Initializing Objects
+
+/**
+ Initializes an unmanaged instance of a Realm object.
+
+ Call `addObject:` on an `RLMRealm` instance to add an unmanaged object into that Realm.
+ 
+ @see `[RLMRealm addObject:]`
+ */
+- (instancetype)init NS_DESIGNATED_INITIALIZER;
+
+
+/**
+ Initializes an unmanaged instance of a Realm object.
+ 
+ Pass in an `NSArray` or `NSDictionary` instance to set the values of the object's properties.
+
+ Call `addObject:` on an `RLMRealm` instance to add an unmanaged object into that Realm.
+ 
+ @see `[RLMRealm addObject:]`
+ */
+- (instancetype)initWithValue:(id)value NS_DESIGNATED_INITIALIZER;
+
+
+/**
+ Returns the class name for a Realm object subclass.
+
+ @warning Do not override. Realm relies on this method returning the exact class
+          name.
+ 
+ @return  The class name for the model class.
+ */
++ (NSString *)className;
+
+/**
+ Creates an instance of a Realm object with a given value, and adds it to the default Realm.
+ 
+ If nested objects are included in the argument, `createInDefaultRealmWithValue:` will be recursively called
+ on them.
+ 
+ The `value` argument can be a key-value coding compliant object, an array or dictionary returned from the methods in
+ `NSJSONSerialization`, or an array containing one element for each managed property. An exception will be thrown if
+ any required properties are not present and those properties were not defined with default values.
+
+ When passing in an array as the `value` argument, all properties must be present, valid and in the same order as the
+ properties defined in the model.
+
+ @param value    The value used to populate the object.
+
+ @see   `defaultPropertyValues`
+ */
++ (instancetype)createInDefaultRealmWithValue:(id)value;
+
+/**
+ Creates an instance of a Realm object with a given value, and adds it to the specified Realm.
+ 
+ If nested objects are included in the argument, `createInRealm:withValue:` will be recursively called
+ on them.
+ 
+ The `value` argument can be a key-value coding compliant object, an array or dictionary returned from the methods in
+ `NSJSONSerialization`, or an array containing one element for each managed property. An exception will be thrown if any
+ required properties are not present and those properties were not defined with default values.
+
+ When passing in an array as the `value` argument, all properties must be present, valid and in the same order as the
+ properties defined in the model.
+
+ @param realm    The Realm which should manage the newly-created object.
+ @param value    The value used to populate the object.
+
+ @see   `defaultPropertyValues`
+ */
++ (instancetype)createInRealm:(RLMRealm *)realm withValue:(id)value;
+
+/**
+ Creates or updates a Realm object within the default Realm.
+
+ This method may only be called on Realm object types with a primary key defined. If there is already
+ an object with the same primary key value in the default Realm, its values are updated and the object
+ is returned. Otherwise, this method creates and populates a new instance of the object in the default Realm.
+ 
+ If nested objects are included in the argument, `createOrUpdateInDefaultRealmWithValue:` will be
+ recursively called on them if they have primary keys, `createInDefaultRealmWithValue:` if they do not.
+
+ If the argument is a Realm object already managed by the default Realm, the argument's type is the same
+ as the receiver, and the objects have identical values for their managed properties, this method does nothing.
+ 
+ The `value` argument is used to populate the object. It can be a key-value coding compliant object, an array or
+ dictionary returned from the methods in `NSJSONSerialization`, or an array containing one element for each managed
+ property. An exception will be thrown if any required properties are not present and those properties were not defined
+ with default values.
+
+ When passing in an array as the `value` argument, all properties must be present, valid and in the same order as the
+ properties defined in the model.
+
+ @param value    The value used to populate the object.
+
+ @see   `defaultPropertyValues`, `primaryKey`
+ */
++ (instancetype)createOrUpdateInDefaultRealmWithValue:(id)value;
+
+/**
+ Creates or updates an Realm object within a specified Realm.
+
+ This method may only be called on Realm object types with a primary key defined. If there is already
+ an object with the same primary key value in the given Realm, its values are updated and the object
+ is returned. Otherwise this method creates and populates a new instance of this object in the given Realm.
+ 
+ If nested objects are included in the argument, `createOrUpdateInRealm:withValue:` will be
+ recursively called on them if they have primary keys, `createInRealm:withValue:` if they do not.
+
+ If the argument is a Realm object already managed by the given Realm, the argument's type is the same
+ as the receiver, and the objects have identical values for their managed properties, this method does nothing.
+ 
+ The `value` argument is used to populate the object. It can be a key-value coding compliant object, an array or
+ dictionary returned from the methods in `NSJSONSerialization`, or an array containing one element for each managed
+ property. An exception will be thrown if any required properties are not present and those properties were not defined
+ with default values.
+
+ When passing in an array as the `value` argument, all properties must be present, valid and in the same order as the
+ properties defined in the model.
+
+ @param realm    The Realm which should own the object.
+ @param value    The value used to populate the object.
+
+ @see   `defaultPropertyValues`, `primaryKey`
+ */
++ (instancetype)createOrUpdateInRealm:(RLMRealm *)realm withValue:(id)value;
+
+#pragma mark - Properties
+
+/**
+ The Realm which manages the object, or `nil` if the object is unmanaged.
+ */
+@property (nonatomic, readonly, nullable) RLMRealm *realm;
+
+/**
+ The object schema which lists the managed properties for the object.
+ */
+@property (nonatomic, readonly) RLMObjectSchema *objectSchema;
+
+/**
+ Indicates if the object can no longer be accessed because it is now invalid.
+ 
+ An object can no longer be accessed if the object has been deleted from the Realm that manages it, or
+ if `invalidate` is called on that Realm.
+ */
+@property (nonatomic, readonly, getter = isInvalidated) BOOL invalidated;
+
+
+#pragma mark - Customizing your Objects
+
+/**
+ Returns an array of property names for properties which should be indexed.
+ 
+ Only string, integer, boolean, and `NSDate` properties are supported.
+
+ @return    An array of property names.
+ */
++ (NSArray<NSString *> *)indexedProperties;
+
+/**
+ Override this method to specify the default values to be used for each property.
+ 
+ @return    A dictionary mapping property names to their default values.
+ */
++ (nullable NSDictionary *)defaultPropertyValues;
+
+/**
+ Override this method to specify the name of a property to be used as the primary key.
+ 
+ Only properties of types `RLMPropertyTypeString` and `RLMPropertyTypeInt` can be designated as the primary key.
+ Primary key properties enforce uniqueness for each value whenever the property is set, which incurs minor overhead.
+ Indexes are created automatically for primary key properties.
+
+ @return    The name of the property designated as the primary key.
+ */
++ (nullable NSString *)primaryKey;
+
+/**
+ Override this method to specify the names of properties to ignore. These properties will not be managed by the Realm
+ that manages the object.
+
+ @return    An array of property names to ignore.
+ */
++ (nullable NSArray<NSString *> *)ignoredProperties;
+
+/**
+ Override this method to specify the names of properties that are non-optional (i.e. cannot be assigned a `nil` value).
+
+ By default, all properties of a type whose values can be set to `nil` are considered optional properties.
+ To require that an object in a Realm always store a non-`nil` value for a property,
+ add the name of the property to the array returned from this method.
+ 
+ Properties of `RLMObject` type cannot be non-optional. Array and `NSNumber` properties
+ can be non-optional, but there is no reason to do so: arrays do not support storing nil, and
+ if you want a non-optional number you should instead use the primitive type.
+
+ @return    An array of property names that are required.
+ */
++ (NSArray<NSString *> *)requiredProperties;
+
+/**
+ Override this method to provide information related to properties containing linking objects.
+ 
+ Each property of type `RLMLinkingObjects` must have a key in the dictionary returned by this method consisting
+ of the property name. The corresponding value must be an instance of `RLMPropertyDescriptor` that describes the class
+ and property that the property is linked to.
+
+     return @{ @"owners": [RLMPropertyDescriptor descriptorWithClass:Owner.class propertyName:@"dogs"] };
+
+ @return     A dictionary mapping property names to `RLMPropertyDescriptor` instances.
+ */
++ (NSDictionary<NSString *, RLMPropertyDescriptor *> *)linkingObjectsProperties;
+
+
+#pragma mark - Getting & Querying Objects from the Default Realm
+
+/**
+ Returns all objects of this object type from the default Realm.
+ 
+ @return    An `RLMResults` containing all objects of this type in the default Realm.
+ */
++ (RLMResults *)allObjects;
+
+/**
+ Returns all objects of this object type matching the given predicate from the default Realm.
+ 
+ @param predicateFormat A predicate format string, optionally followed by a variable number of arguments.
+ 
+ @return    An `RLMResults` containing all objects of this type in the default Realm that match the given predicate.
+ */
++ (RLMResults *)objectsWhere:(NSString *)predicateFormat, ...;
+
+/// :nodoc:
++ (RLMResults *)objectsWhere:(NSString *)predicateFormat args:(va_list)args;
+
+
+/**
+ Returns all objects of this object type matching the given predicate from the default Realm.
+
+ @param predicate   The predicate with which to filter the objects.
+
+ @return    An `RLMResults` containing all objects of this type in the default Realm that match the given predicate.
+ */
++ (RLMResults *)objectsWithPredicate:(nullable NSPredicate *)predicate;
+
+/**
+ Retrieves the single instance of this object type with the given primary key from the default Realm.
+
+ Returns the object from the default Realm which has the given primary key, or
+ `nil` if the object does not exist. This is slightly faster than the otherwise
+ equivalent `[[SubclassName objectsWhere:@"primaryKeyPropertyName = %@", key] firstObject]`.
+
+ This method requires that `primaryKey` be overridden on the receiving subclass.
+
+ @return    An object of this object type, or `nil` if an object with the given primary key does not exist.
+ @see       `-primaryKey`
+ */
++ (nullable instancetype)objectForPrimaryKey:(nullable id)primaryKey;
+
+
+#pragma mark - Querying Specific Realms
+
+/**
+ Returns all objects of this object type from the specified Realm.
+
+ @param realm   The Realm to query.
+
+ @return        An `RLMResults` containing all objects of this type in the specified Realm.
+ */
++ (RLMResults *)allObjectsInRealm:(RLMRealm *)realm;
+
+/**
+ Returns all objects of this object type matching the given predicate from the specified Realm.
+
+ @param predicateFormat A predicate format string, optionally followed by a variable number of arguments.
+ @param realm           The Realm to query.
+
+ @return    An `RLMResults` containing all objects of this type in the specified Realm that match the given predicate.
+ */
++ (RLMResults *)objectsInRealm:(RLMRealm *)realm where:(NSString *)predicateFormat, ...;
+
+/// :nodoc:
++ (RLMResults *)objectsInRealm:(RLMRealm *)realm where:(NSString *)predicateFormat args:(va_list)args;
+
+/**
+ Returns all objects of this object type matching the given predicate from the specified Realm.
+
+ @param predicate   A predicate to use to filter the elements.
+ @param realm       The Realm to query.
+
+ @return    An `RLMResults` containing all objects of this type in the specified Realm that match the given predicate.
+ */
++ (RLMResults *)objectsInRealm:(RLMRealm *)realm withPredicate:(nullable NSPredicate *)predicate;
+
+/**
+ Retrieves the single instance of this object type with the given primary key from the specified Realm.
+
+ Returns the object from the specified Realm which has the given primary key, or
+ `nil` if the object does not exist. This is slightly faster than the otherwise
+ equivalent `[[SubclassName objectsInRealm:realm where:@"primaryKeyPropertyName = %@", key] firstObject]`.
+
+ This method requires that `primaryKey` be overridden on the receiving subclass.
+
+ @return    An object of this object type, or `nil` if an object with the given primary key does not exist.
+ @see       `-primaryKey`
+ */
++ (nullable instancetype)objectInRealm:(RLMRealm *)realm forPrimaryKey:(nullable id)primaryKey;
+
+#pragma mark - Other Instance Methods
+
+/**
+ Returns YES if another Realm object instance points to the same object as the receiver in the Realm managing
+ the receiver.
+ 
+ For object types with a primary, key, `isEqual:` is overridden to use this method (along with a corresponding
+ implementation for `hash`).
+
+ @param object  The object to compare the receiver to.
+
+ @return    A Boolean indicating whether the object represents the same object as the receiver.
+ */
+- (BOOL)isEqualToObject:(RLMObject *)object;
+
+#pragma mark - Dynamic Accessors
+
+/// :nodoc:
+- (nullable id)objectForKeyedSubscript:(NSString *)key;
+
+/// :nodoc:
+- (void)setObject:(nullable id)obj forKeyedSubscript:(NSString *)key;
+
+@end
+
+#pragma mark - RLMArray Property Declaration
+
+/**
+ Properties on `RLMObject`s of type `RLMArray` must have an associated type. A type is associated
+ with an `RLMArray` property by defining a protocol for the object type that the array should contain.
+ To define the protocol for an object, you can use the macro RLM_ARRAY_TYPE:
+ 
+     RLM_ARRAY_TYPE(ObjectType)
+     ...
+     @property RLMArray<ObjectType *><ObjectType> *arrayOfObjectTypes;
+  */
+#define RLM_ARRAY_TYPE(RLM_OBJECT_SUBCLASS)\
+@protocol RLM_OBJECT_SUBCLASS <NSObject>   \
+@end
+
+NS_ASSUME_NONNULL_END
diff --git a/Pods/Realm/include/RLMObjectBase.h b/Pods/Realm/include/RLMObjectBase.h
new file mode 100644
index 0000000..1ad1234
--- /dev/null
+++ b/Pods/Realm/include/RLMObjectBase.h
@@ -0,0 +1,41 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import <Foundation/Foundation.h>
+
+NS_ASSUME_NONNULL_BEGIN
+
+@class RLMRealm;
+@class RLMSchema;
+@class RLMObjectSchema;
+
+/// :nodoc:
+@interface RLMObjectBase : NSObject
+
+@property (nonatomic, readonly, getter = isInvalidated) BOOL invalidated;
+
+- (instancetype)init NS_DESIGNATED_INITIALIZER;
+
++ (NSString *)className;
+
+// Returns whether the class is included in the default set of classes managed by a Realm.
++ (BOOL)shouldIncludeInDefaultSchema;
+
+@end
+
+NS_ASSUME_NONNULL_END
diff --git a/Pods/Realm/include/RLMObjectBase_Dynamic.h b/Pods/Realm/include/RLMObjectBase_Dynamic.h
new file mode 100644
index 0000000..2106d58
--- /dev/null
+++ b/Pods/Realm/include/RLMObjectBase_Dynamic.h
@@ -0,0 +1,79 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import <Realm/RLMObject.h>
+
+@class RLMObjectSchema, RLMRealm;
+
+/**
+ Returns the Realm that manages the object, if one exists.
+ 
+ @warning  This function is useful only in specialized circumstances, for example, when building components
+           that integrate with Realm. If you are simply building an app on Realm, it is
+           recommended to retrieve the Realm that manages the object via `RLMObject`.
+
+ @param object	An `RLMObjectBase` obtained via a Swift `Object` or `RLMObject`.
+ 
+ @return The Realm which manages this object. Returns `nil `for unmanaged objects.
+ */
+FOUNDATION_EXTERN RLMRealm *RLMObjectBaseRealm(RLMObjectBase *object);
+
+/**
+ Returns an `RLMObjectSchema` which describes the managed properties of the object.
+ 
+ @warning  This function is useful only in specialized circumstances, for example, when building components
+           that integrate with Realm. If you are simply building an app on Realm, it is
+           recommended to retrieve `objectSchema` via `RLMObject`.
+
+ @param object	An `RLMObjectBase` obtained via a Swift `Object` or `RLMObject`.
+ 
+ @return The object schema which lists the managed properties for the object.
+ */
+FOUNDATION_EXTERN RLMObjectSchema *RLMObjectBaseObjectSchema(RLMObjectBase *object);
+
+/**
+ Returns the object corresponding to a key value.
+
+ @warning  This function is useful only in specialized circumstances, for example, when building components
+           that integrate with Realm. If you are simply building an app on Realm, it is
+           recommended to retrieve key values via `RLMObject`.
+
+ @warning Will throw an `NSUndefinedKeyException` if `key` is not present on the object.
+ 
+ @param object	An `RLMObjectBase` obtained via a Swift `Object` or `RLMObject`.
+ @param key		The name of the property.
+ 
+ @return The object for the property requested.
+ */
+FOUNDATION_EXTERN id RLMObjectBaseObjectForKeyedSubscript(RLMObjectBase *object, NSString *key);
+
+/**
+ Sets a value for a key on the object.
+ 
+ @warning  This function is useful only in specialized circumstances, for example, when building components
+           that integrate with Realm. If you are simply building an app on Realm, it is
+           recommended to set key values via `RLMObject`.
+
+ @warning Will throw an `NSUndefinedKeyException` if `key` is not present on the object.
+ 
+ @param object	An `RLMObjectBase` obtained via a Swift `Object` or `RLMObject`.
+ @param key		The name of the property.
+ @param obj		The object to set as the value of the key.
+ */
+FOUNDATION_EXTERN void RLMObjectBaseSetObjectForKeyedSubscript(RLMObjectBase *object, NSString *key, id obj);
+
diff --git a/Pods/Realm/include/RLMObjectSchema.h b/Pods/Realm/include/RLMObjectSchema.h
new file mode 100644
index 0000000..3068202
--- /dev/null
+++ b/Pods/Realm/include/RLMObjectSchema.h
@@ -0,0 +1,72 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import <Foundation/Foundation.h>
+
+NS_ASSUME_NONNULL_BEGIN
+
+@class RLMProperty;
+
+/**
+ This class represents Realm model object schemas.
+
+ When using Realm, `RLMObjectSchema` instances allow performing migrations and
+ introspecting the database's schema.
+
+ Object schemas map to tables in the core database.
+ */
+@interface RLMObjectSchema : NSObject<NSCopying>
+
+#pragma mark - Properties
+
+/**
+ An array of `RLMProperty` instances representing the managed properties of a class described by the schema.
+ 
+ @see `RLMProperty`
+ */
+@property (nonatomic, readonly, copy) NSArray<RLMProperty *> *properties;
+
+/**
+ The name of the class the schema describes.
+ */
+@property (nonatomic, readonly) NSString *className;
+
+/**
+ The property which serves as the primary key for the class the schema describes, if any.
+ */
+@property (nonatomic, readonly, nullable) RLMProperty *primaryKeyProperty;
+
+#pragma mark - Methods
+
+/**
+ Retrieves an `RLMProperty` object by the property name.
+ 
+ @param propertyName The property's name.
+ 
+ @return An `RLMProperty` object, or `nil` if there is no property with the given name.
+ */
+- (nullable RLMProperty *)objectForKeyedSubscript:(id <NSCopying>)propertyName;
+
+/**
+  Returns a Boolean value that indicates whether two `RLMObjectSchema` instances are equal.
+*/
+- (BOOL)isEqualToObjectSchema:(RLMObjectSchema *)objectSchema;
+
+@end
+
+NS_ASSUME_NONNULL_END
diff --git a/Pods/Realm/include/RLMObjectSchema_Private.h b/Pods/Realm/include/RLMObjectSchema_Private.h
new file mode 100644
index 0000000..0f82087
--- /dev/null
+++ b/Pods/Realm/include/RLMObjectSchema_Private.h
@@ -0,0 +1,73 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import <Realm/RLMObjectSchema.h>
+
+NS_ASSUME_NONNULL_BEGIN
+
+@class RLMRealm;
+
+// RLMObjectSchema private
+@interface RLMObjectSchema () {
+@public
+    bool _isSwiftClass;
+}
+
+// writable redecleration
+@property (nonatomic, readwrite, copy) NSArray<RLMProperty *> *properties;
+@property (nonatomic, readwrite, assign) bool isSwiftClass;
+
+// class used for this object schema
+@property (nonatomic, readwrite, assign) Class objectClass;
+@property (nonatomic, readwrite, assign) Class accessorClass;
+@property (nonatomic, readwrite, assign) Class unmanagedClass;
+
+@property (nonatomic, readwrite, nullable) RLMProperty *primaryKeyProperty;
+
+@property (nonatomic, copy) NSArray<RLMProperty *> *computedProperties;
+@property (nonatomic, readonly) NSArray<RLMProperty *> *swiftGenericProperties;
+
+// The Realm retains its object schemas, so they need to not retain the Realm
+@property (nonatomic, unsafe_unretained, nullable) RLMRealm *realm;
+// returns a cached or new schema for a given object class
++ (instancetype)schemaForObjectClass:(Class)objectClass;
+
+- (RLMProperty *)propertyForTableColumn:(size_t)tableCol;
+
+@end
+
+@interface RLMObjectSchema (Dynamic)
+/**
+ This method is useful only in specialized circumstances, for example, when accessing objects
+ in a Realm produced externally. If you are simply building an app on Realm, it is not recommended
+ to use this method as an [RLMObjectSchema](RLMObjectSchema) is generated automatically for every [RLMObject](RLMObject) subclass.
+ 
+ Initialize an RLMObjectSchema with classname, objectClass, and an array of properties
+ 
+ @warning This method is useful only in specialized circumstances.
+ 
+ @param objectClassName     The name of the class used to refer to objects of this type.
+ @param objectClass         The Objective-C class used when creating instances of this type.
+ @param properties          An array of RLMProperty instances describing the managed properties for this type.
+ 
+ @return    An initialized instance of RLMObjectSchema.
+ */
+- (instancetype)initWithClassName:(NSString *)objectClassName objectClass:(Class)objectClass properties:(NSArray *)properties;
+@end
+
+NS_ASSUME_NONNULL_END
diff --git a/Pods/Realm/include/RLMObjectSchema_Private.hpp b/Pods/Realm/include/RLMObjectSchema_Private.hpp
new file mode 100644
index 0000000..b2d0c57
--- /dev/null
+++ b/Pods/Realm/include/RLMObjectSchema_Private.hpp
@@ -0,0 +1,49 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import "RLMObjectSchema_Private.h"
+
+#import "object_schema.hpp"
+#import "RLMObject_Private.hpp"
+
+#import <realm/row.hpp>
+#import <vector>
+
+namespace realm {
+    class Table;
+}
+
+class RLMObservationInfo;
+
+// RLMObjectSchema private
+@interface RLMObjectSchema () {
+    @public
+    std::vector<RLMObservationInfo *> _observedObjects;
+}
+@property (nonatomic) realm::Table *table;
+
+// shallow copy reusing properties and property map
+- (instancetype)shallowCopy;
+
+// create realm::ObjectSchema copy
+- (realm::ObjectSchema)objectStoreCopy;
+
+// initialize with realm::ObjectSchema
++ (instancetype)objectSchemaForObjectStoreSchema:(realm::ObjectSchema &)objectSchema;
+
+@end
diff --git a/Pods/Realm/include/RLMObjectStore.h b/Pods/Realm/include/RLMObjectStore.h
new file mode 100644
index 0000000..e7dfb67
--- /dev/null
+++ b/Pods/Realm/include/RLMObjectStore.h
@@ -0,0 +1,99 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import <Foundation/Foundation.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+@class RLMRealm, RLMSchema, RLMObjectSchema, RLMObjectBase, RLMResults, RLMProperty;
+
+//
+// Accessor Creation
+//
+
+// create or get cached accessors for the given schema
+void RLMRealmCreateAccessors(RLMSchema *schema);
+
+// Clear the cache of created accessor classes
+void RLMClearAccessorCache();
+
+
+//
+// Options for object creation
+//
+typedef NS_OPTIONS(NSUInteger, RLMCreationOptions) {
+    // Normal object creation
+    RLMCreationOptionsNone = 0,
+    // If the property is a link or array property, upsert the linked objects
+    // if they have a primary key, and insert them otherwise.
+    RLMCreationOptionsCreateOrUpdate = 1 << 0,
+    // Allow unmanaged objects to be promoted to managed objects
+    // if false objects are copied during object creation
+    RLMCreationOptionsPromoteUnmanaged = 1 << 1,
+};
+
+
+//
+// Adding, Removing, Getting Objects
+//
+
+// add an object to the given realm
+void RLMAddObjectToRealm(RLMObjectBase *object, RLMRealm *realm, bool createOrUpdate);
+
+// delete an object from its realm
+void RLMDeleteObjectFromRealm(RLMObjectBase *object, RLMRealm *realm);
+
+// deletes all objects from a realm
+void RLMDeleteAllObjectsFromRealm(RLMRealm *realm);
+
+// get objects of a given class
+RLMResults *RLMGetObjects(RLMRealm *realm, NSString *objectClassName, NSPredicate *predicate) NS_RETURNS_RETAINED;
+
+// get an object with the given primary key
+id RLMGetObject(RLMRealm *realm, NSString *objectClassName, id key) NS_RETURNS_RETAINED;
+
+// create object from array or dictionary
+RLMObjectBase *RLMCreateObjectInRealmWithValue(RLMRealm *realm, NSString *className, id value, bool createOrUpdate) NS_RETURNS_RETAINED;
+    
+
+//
+// Accessor Creation
+//
+
+
+// switch List<> properties from being backed by unmanaged RLMArrays to RLMArrayLinkView
+void RLMInitializeSwiftAccessorGenerics(RLMObjectBase *object);
+
+#ifdef __cplusplus
+}
+
+namespace realm {
+    class Table;
+    template<typename T> class BasicRowExpr;
+    using RowExpr = BasicRowExpr<Table>;
+}
+// Create accessors
+RLMObjectBase *RLMCreateObjectAccessor(RLMRealm *realm,
+                                       RLMObjectSchema *objectSchema,
+                                       NSUInteger index) NS_RETURNS_RETAINED;
+RLMObjectBase *RLMCreateObjectAccessor(RLMRealm *realm,
+                                       RLMObjectSchema *objectSchema,
+                                       realm::RowExpr row) NS_RETURNS_RETAINED;
+#endif
diff --git a/Pods/Realm/include/RLMObject_Private.h b/Pods/Realm/include/RLMObject_Private.h
new file mode 100644
index 0000000..c9d14ff
--- /dev/null
+++ b/Pods/Realm/include/RLMObject_Private.h
@@ -0,0 +1,111 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import <Realm/RLMObject.h>
+
+// RLMObject accessor and read/write realm
+@interface RLMObjectBase () {
+  @public
+    RLMRealm *_realm;
+    // objectSchema is a cached pointer to an object stored in the RLMSchema
+    // owned by _realm, so it's guaranteed to stay alive as long as this object
+    // without retaining it (and retaining it makes iteration slower)
+    __unsafe_unretained RLMObjectSchema *_objectSchema;
+}
+
+// unmanaged initializer
+- (instancetype)initWithValue:(id)value schema:(RLMSchema *)schema NS_DESIGNATED_INITIALIZER;
+
+// live accessor initializer
+- (instancetype)initWithRealm:(__unsafe_unretained RLMRealm *const)realm
+                       schema:(__unsafe_unretained RLMObjectSchema *const)schema NS_DESIGNATED_INITIALIZER;
+
+// shared schema for this class
++ (RLMObjectSchema *)sharedSchema;
+
+// provide injection point for alternative Swift object util class
++ (Class)objectUtilClass:(BOOL)isSwift;
+
+@end
+
+@interface RLMObject ()
+
+// unmanaged initializer
+- (instancetype)initWithValue:(id)value schema:(RLMSchema *)schema NS_DESIGNATED_INITIALIZER;
+
+// live accessor initializer
+- (instancetype)initWithRealm:(__unsafe_unretained RLMRealm *const)realm
+                       schema:(__unsafe_unretained RLMObjectSchema *const)schema NS_DESIGNATED_INITIALIZER;
+
+@end
+
+@interface RLMDynamicObject : RLMObject
+
+@end
+
+// A reference to an object's row that doesn't keep the object accessor alive.
+// Used by some Swift property types, such as LinkingObjects, to avoid retain cycles
+// with their containing object.
+@interface RLMWeakObjectHandle : NSObject
+
+- (instancetype)initWithObject:(RLMObjectBase *)object;
+
+// Consumes the row, so can only usefully be called once.
+@property (nonatomic, readonly) RLMObjectBase *object;
+
+@end
+
+//
+// Getters for RLMObjectBase ivars for realm and objectSchema
+//
+FOUNDATION_EXTERN RLMRealm *RLMObjectBaseRealm(RLMObjectBase *object);
+FOUNDATION_EXTERN RLMObjectSchema *RLMObjectBaseObjectSchema(RLMObjectBase *object);
+
+// Dynamic access to RLMObjectBase properties
+FOUNDATION_EXTERN id RLMObjectBaseObjectForKeyedSubscript(RLMObjectBase *object, NSString *key);
+FOUNDATION_EXTERN void RLMObjectBaseSetObjectForKeyedSubscript(RLMObjectBase *object, NSString *key, id obj);
+
+// Calls valueForKey: and re-raises NSUndefinedKeyExceptions
+FOUNDATION_EXTERN id RLMValidatedValueForProperty(id object, NSString *key, NSString *className);
+
+// Compare two RLObjectBases
+FOUNDATION_EXTERN BOOL RLMObjectBaseAreEqual(RLMObjectBase *o1, RLMObjectBase *o2);
+
+// Get ObjectUil class for objc or swift
+FOUNDATION_EXTERN Class RLMObjectUtilClass(BOOL isSwift);
+
+FOUNDATION_EXTERN const NSUInteger RLMDescriptionMaxDepth;
+
+@class RLMProperty, RLMArray;
+@interface RLMObjectUtil : NSObject
+
++ (NSArray<NSString *> *)ignoredPropertiesForClass:(Class)cls;
++ (NSArray<NSString *> *)indexedPropertiesForClass:(Class)cls;
++ (NSDictionary<NSString *, NSDictionary<NSString *, NSString *> *> *)linkingObjectsPropertiesForClass:(Class)cls;
+
++ (NSArray<NSString *> *)getGenericListPropertyNames:(id)obj;
++ (NSDictionary<NSString *, NSString *> *)getLinkingObjectsProperties:(id)object;
+
++ (void)initializeListProperty:(RLMObjectBase *)object property:(RLMProperty *)property array:(RLMArray *)array;
++ (void)initializeOptionalProperty:(RLMObjectBase *)object property:(RLMProperty *)property;
++ (void)initializeLinkingObjectsProperty:(RLMObjectBase *)object property:(RLMProperty *)property;
+
++ (NSDictionary<NSString *, NSNumber *> *)getOptionalProperties:(id)obj;
++ (NSArray<NSString *> *)requiredPropertiesForClass:(Class)cls;
+
+@end
diff --git a/Pods/Realm/include/RLMObject_Private.hpp b/Pods/Realm/include/RLMObject_Private.hpp
new file mode 100644
index 0000000..d111cd7
--- /dev/null
+++ b/Pods/Realm/include/RLMObject_Private.hpp
@@ -0,0 +1,52 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import "RLMObject_Private.h"
+
+#import "RLMRealm_Private.hpp"
+
+#import <realm/link_view.hpp> // required by row.hpp
+#import <realm/row.hpp>
+
+class RLMObservationInfo;
+
+// RLMObject accessor and read/write realm
+@interface RLMObjectBase () {
+    @public
+    realm::Row _row;
+    RLMObservationInfo *_observationInfo;
+}
+@end
+
+// throw an exception if the object is invalidated or on the wrong thread
+static inline void RLMVerifyAttached(__unsafe_unretained RLMObjectBase *const obj) {
+    if (!obj->_row.is_attached()) {
+        @throw RLMException(@"Object has been deleted or invalidated.");
+    }
+    [obj->_realm verifyThread];
+}
+
+// throw an exception if the object can't be modified for any reason
+static inline void RLMVerifyInWriteTransaction(__unsafe_unretained RLMObjectBase *const obj) {
+    // first verify is attached
+    RLMVerifyAttached(obj);
+
+    if (!obj->_realm.inWriteTransaction) {
+        @throw RLMException(@"Attempting to modify object outside of a write transaction - call beginWriteTransaction on an RLMRealm instance first.");
+    }
+}
diff --git a/Pods/Realm/include/RLMObservation.hpp b/Pods/Realm/include/RLMObservation.hpp
new file mode 100644
index 0000000..d7ecad6
--- /dev/null
+++ b/Pods/Realm/include/RLMObservation.hpp
@@ -0,0 +1,143 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2015 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import <Foundation/Foundation.h>
+
+#import "binding_context.hpp"
+
+
+#import <realm/link_view.hpp> // required by row.hpp
+#import <realm/row.hpp>
+
+@class RLMObjectSchema, RLMObjectBase, RLMRealm, RLMSchema, RLMProperty;
+
+namespace realm {
+    class History;
+    class SharedGroup;
+}
+
+// RLMObservationInfo stores all of the KVO-related data for RLMObjectBase and
+// RLMArray. There is a one-to-one relationship between observed objects and
+// RLMObservationInfo instances, so it could be folded into RLMObjectBase, and
+// is a separate class mostly to avoid making all accessor objects far larger.
+//
+// RLMObjectSchema stores a vector of pointers to the first observation info
+// created for each row. If there are multiple observation infos for a single
+// row (such as if there are multiple observed objects backed by a single row,
+// or if both an object and an array property of that object are observed),
+// they're stored in an intrusive doubly-linked-list in the `next` and `prev`
+// members. This is done primarily to make it simpler and faster to loop over
+// all of the observed objects for a single row, as that needs to be done for
+// every change.
+class RLMObservationInfo {
+public:
+    RLMObservationInfo(id object);
+    RLMObservationInfo(RLMObjectSchema *objectSchema, std::size_t row, id object);
+    ~RLMObservationInfo();
+
+    realm::Row const& getRow() const {
+        return row;
+    }
+
+    RLMObjectSchema *getObjectSchema() const {
+        return objectSchema;
+    }
+
+    // Send willChange/didChange notifications to all observers for this object/row
+    // Sends the array versions if indexes is non-nil, normal versions otherwise
+    void willChange(NSString *key, NSKeyValueChange kind=NSKeyValueChangeSetting, NSIndexSet *indexes=nil) const;
+    void didChange(NSString *key, NSKeyValueChange kind=NSKeyValueChangeSetting, NSIndexSet *indexes=nil) const;
+
+    bool isForRow(size_t ndx) const {
+        return row && row.get_index() == ndx;
+    }
+
+    void recordObserver(realm::Row& row, RLMObjectSchema *objectSchema, NSString *keyPath);
+    void removeObserver();
+    bool hasObservers() const { return observerCount > 0; }
+
+    // valueForKey: on observed object and array properties needs to return the
+    // same object each time for KVO to work at all. Doing this all the time
+    // requires some odd semantics to avoid reference cycles, so instead we do
+    // it only to the extent specifically required by KVO. In addition, we
+    // need to continue to return the same object even if this row is deleted,
+    // or deleting an object with active observers will explode horribly.
+    // Once prepareForInvalidation() is called, valueForKey() will always return
+    // the cached value for object and array properties without checking the
+    // backing row to verify it's up-to-date.
+    //
+    // prepareForInvalidation() must be called on the head of the linked list
+    // (i.e. on the object pointed to directly by the object schema)
+    id valueForKey(NSString *key);
+
+    void prepareForInvalidation();
+
+private:
+    // Doubly-linked-list of observed objects for the same row as this
+    RLMObservationInfo *next = nullptr;
+    RLMObservationInfo *prev = nullptr;
+
+    // Row being observed
+    realm::Row row;
+    RLMObjectSchema *objectSchema;
+
+    // Object doing the observing
+    __unsafe_unretained id object;
+
+    // valueForKey: hack
+    bool invalidated = false;
+    size_t observerCount = 0;
+    NSString *lastKey = nil;
+    __unsafe_unretained RLMProperty *lastProp = nil;
+
+    // objects returned from valueForKey() to keep them alive in case observers
+    // are added and so that they can still be accessed after row is detached
+    NSMutableDictionary *cachedObjects;
+
+    void setRow(realm::Table &table, size_t newRow);
+
+    template<typename F>
+    void forEach(F&& f) const {
+        for (auto info = prev; info; info = info->prev)
+            f(info->object);
+        for (auto info = this; info; info = info->next)
+            f(info->object);
+    }
+
+    // Default move/copy constructors don't work due to the intrusive linked
+    // list and we don't need them
+    RLMObservationInfo(RLMObservationInfo const&) = delete;
+    RLMObservationInfo(RLMObservationInfo&&) = delete;
+    RLMObservationInfo& operator=(RLMObservationInfo const&) = delete;
+    RLMObservationInfo& operator=(RLMObservationInfo&&) = delete;
+};
+
+// Get the the observation info chain for the given row
+// Will simply return info if it's non-null, and will search ojectSchema's array
+// for a matching one otherwise, and return null if there are none
+RLMObservationInfo *RLMGetObservationInfo(RLMObservationInfo *info, size_t row, RLMObjectSchema *objectSchema);
+
+// delete all objects from a single table with change notifications
+void RLMClearTable(RLMObjectSchema *realm);
+
+// invoke the block, sending notifications for cascading deletes/link nullifications
+void RLMTrackDeletions(RLMRealm *realm, dispatch_block_t block);
+
+std::vector<realm::BindingContext::ObserverState> RLMGetObservedRows(NSArray<RLMObjectSchema *> *schema);
+void RLMWillChange(std::vector<realm::BindingContext::ObserverState> const& observed, std::vector<void *> const& invalidated);
+void RLMDidChange(std::vector<realm::BindingContext::ObserverState> const& observed, std::vector<void *> const& invalidated);
diff --git a/Pods/Realm/include/RLMOptionalBase.h b/Pods/Realm/include/RLMOptionalBase.h
new file mode 100644
index 0000000..bab04a5
--- /dev/null
+++ b/Pods/Realm/include/RLMOptionalBase.h
@@ -0,0 +1,34 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2015 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import <Foundation/Foundation.h>
+#import <Realm/RLMConstants.h>
+
+@class RLMObjectBase, RLMProperty;
+
+@interface RLMOptionalBase : NSProxy
+
+- (instancetype)init;
+
+@property (nonatomic, weak) RLMObjectBase *object;
+
+@property (nonatomic, unsafe_unretained) RLMProperty *property;
+
+@property (nonatomic, strong) id underlyingValue;
+
+@end
diff --git a/Pods/Realm/include/RLMPlatform.h b/Pods/Realm/include/RLMPlatform.h
new file mode 100644
index 0000000..e69de29
diff --git a/Pods/Realm/include/RLMPredicateUtil.hpp b/Pods/Realm/include/RLMPredicateUtil.hpp
new file mode 100644
index 0000000..11b8e15
--- /dev/null
+++ b/Pods/Realm/include/RLMPredicateUtil.hpp
@@ -0,0 +1,21 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2015 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+
+#import <Foundation/Foundation.h>
+
+using ExpressionVisitor = NSExpression *(*)(NSExpression *);
+NSPredicate *transformPredicate(NSPredicate *, ExpressionVisitor);
diff --git a/Pods/Realm/include/RLMPrefix.h b/Pods/Realm/include/RLMPrefix.h
new file mode 100644
index 0000000..df08ce9
--- /dev/null
+++ b/Pods/Realm/include/RLMPrefix.h
@@ -0,0 +1,35 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2015 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#ifdef __OBJC__
+#import <Foundation/Foundation.h>
+#endif
+
+#ifdef __cplusplus
+#import <functional>
+#import <map>
+#import <memory>
+#import <string>
+#import <vector>
+
+#import <realm/group.hpp>
+#import <realm/link_view.hpp>
+#import <realm/row.hpp>
+#import <realm/table.hpp>
+#import <realm/table_view.hpp>
+#endif
diff --git a/Pods/Realm/include/RLMProperty.h b/Pods/Realm/include/RLMProperty.h
new file mode 100644
index 0000000..0f21e6f
--- /dev/null
+++ b/Pods/Realm/include/RLMProperty.h
@@ -0,0 +1,121 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import <Foundation/Foundation.h>
+#import <Realm/RLMConstants.h>
+
+NS_ASSUME_NONNULL_BEGIN
+
+/// :nodoc:
+@protocol RLMInt
+@end
+
+/// :nodoc:
+@protocol RLMBool
+@end
+
+/// :nodoc:
+@protocol RLMDouble
+@end
+
+/// :nodoc:
+@protocol RLMFloat
+@end
+
+/// :nodoc:
+@interface NSNumber ()<RLMInt, RLMBool, RLMDouble, RLMFloat>
+@end
+
+/**
+ `RLMProperty` instances represent properties managed by a Realm in the context of an object schema. Such properties may
+ be persisted to a Realm file or computed from other data from the Realm.
+ 
+ When using Realm, `RLMProperty` instances allow performing migrations and introspecting the database's schema.
+ 
+ These property instances map to columns in the core database.
+ */
+@interface RLMProperty : NSObject
+
+#pragma mark - Properties
+
+/**
+ The name of the property.
+ */
+@property (nonatomic, readonly) NSString *name;
+
+/**
+ The type of the property.
+ 
+ @see `RLMPropertyType`
+ */
+@property (nonatomic, readonly) RLMPropertyType type;
+
+/**
+ Indicates whether this property is indexed.
+ 
+ @see `RLMObject`
+ */
+@property (nonatomic, readonly) BOOL indexed;
+
+/**
+ For `RLMObject` and `RLMArray` properties, the name of the class of object stored in the property.
+ */
+@property (nonatomic, readonly, copy, nullable) NSString *objectClassName;
+
+/**
+ For linking objects properties, the property name of the property the linking objects property is linked to.
+ */
+@property (nonatomic, readonly, copy, nullable) NSString *linkOriginPropertyName;
+
+/**
+ Indicates whether this property is optional.
+ */
+@property (nonatomic, readonly) BOOL optional;
+
+#pragma mark - Methods
+
+/**
+ Returns a Boolean value that indicates whether a given property object is equal to the receiver.
+ */
+- (BOOL)isEqualToProperty:(RLMProperty *)property;
+
+@end
+
+
+/**
+ An `RLMPropertyDescriptor` instance represents a specific property on a given class.
+ */
+@interface RLMPropertyDescriptor : NSObject
+
+/**
+ Creates and returns a property descriptor.
+
+ @param objectClass  The class of this property descriptor.
+ @param propertyName The name of this property descriptor.
+ */
++ (instancetype)descriptorWithClass:(Class)objectClass propertyName:(NSString *)propertyName;
+
+/// The class of the property.
+@property (nonatomic, readonly) Class objectClass;
+
+/// The name of the property.
+@property (nonatomic, readonly) NSString *propertyName;
+
+@end
+
+NS_ASSUME_NONNULL_END
diff --git a/Pods/Realm/include/RLMProperty_Private.h b/Pods/Realm/include/RLMProperty_Private.h
new file mode 100644
index 0000000..73cab7b
--- /dev/null
+++ b/Pods/Realm/include/RLMProperty_Private.h
@@ -0,0 +1,108 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import <Realm/RLMProperty.h>
+
+#import <objc/runtime.h>
+
+@class RLMObjectBase;
+
+BOOL RLMPropertyTypeIsNullable(RLMPropertyType propertyType);
+BOOL RLMPropertyTypeIsComputed(RLMPropertyType propertyType);
+
+// private property interface
+@interface RLMProperty () {
+@public
+    RLMPropertyType _type;
+    Ivar _swiftIvar;
+}
+
+- (instancetype)initWithName:(NSString *)name
+                     indexed:(BOOL)indexed
+      linkPropertyDescriptor:(RLMPropertyDescriptor *)linkPropertyDescriptor
+                    property:(objc_property_t)property;
+
+- (instancetype)initSwiftPropertyWithName:(NSString *)name
+                                  indexed:(BOOL)indexed
+                   linkPropertyDescriptor:(RLMPropertyDescriptor *)linkPropertyDescriptor
+                                 property:(objc_property_t)property
+                                 instance:(RLMObjectBase *)objectInstance;
+
+- (instancetype)initSwiftListPropertyWithName:(NSString *)name
+                                         ivar:(Ivar)ivar
+                              objectClassName:(NSString *)objectClassName;
+
+- (instancetype)initSwiftOptionalPropertyWithName:(NSString *)name
+                                          indexed:(BOOL)indexed
+                                             ivar:(Ivar)ivar
+                                     propertyType:(RLMPropertyType)propertyType;
+
+- (instancetype)initSwiftLinkingObjectsPropertyWithName:(NSString *)name
+                                                   ivar:(Ivar)ivar
+                                        objectClassName:(NSString *)objectClassName
+                                 linkOriginPropertyName:(NSString *)linkOriginPropertyName;
+
+// private setters
+@property (nonatomic, assign) NSUInteger column;
+@property (nonatomic, readwrite) NSString *name;
+@property (nonatomic, readwrite, assign) RLMPropertyType type;
+@property (nonatomic, readwrite) BOOL indexed;
+@property (nonatomic, readwrite) BOOL optional;
+@property (nonatomic, copy) NSString *objectClassName;
+
+// private properties
+@property (nonatomic, assign) char objcType;
+@property (nonatomic, copy) NSString *objcRawType;
+@property (nonatomic, assign) BOOL isPrimary;
+@property (nonatomic, assign) Ivar swiftIvar;
+
+// getter and setter names
+@property (nonatomic, copy) NSString *getterName;
+@property (nonatomic, copy) NSString *setterName;
+@property (nonatomic) SEL getterSel;
+@property (nonatomic) SEL setterSel;
+
+- (RLMProperty *)copyWithNewName:(NSString *)name;
+
+@end
+
+@interface RLMProperty (Dynamic)
+/**
+ This method is useful only in specialized circumstances, for example, in conjunction with
+ +[RLMObjectSchema initWithClassName:objectClass:properties:]. If you are simply building an
+ app on Realm, it is not recommened to use this method.
+ 
+ Initialize an RLMProperty
+ 
+ @warning This method is useful only in specialized circumstances.
+ 
+ @param name            The property name.
+ @param type            The property type.
+ @param objectClassName The object type used for Object and Array types.
+ @param linkOriginPropertyName The property name of the origin of a link. Used for linking objects properties.
+
+ @return    An initialized instance of RLMProperty.
+ */
+- (instancetype)initWithName:(NSString *)name
+                        type:(RLMPropertyType)type
+             objectClassName:(NSString *)objectClassName
+      linkOriginPropertyName:(NSString *)linkOriginPropertyName
+                     indexed:(BOOL)indexed
+                    optional:(BOOL)optional;
+@end
+
diff --git a/Pods/Realm/include/RLMProperty_Private.hpp b/Pods/Realm/include/RLMProperty_Private.hpp
new file mode 100644
index 0000000..0e214d5
--- /dev/null
+++ b/Pods/Realm/include/RLMProperty_Private.hpp
@@ -0,0 +1,29 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2016 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import <Realm/RLMProperty_Private.h>
+
+#import "property.hpp"
+
+@interface RLMProperty ()
+
++ (instancetype)propertyForObjectStoreProperty:(const realm::Property&)property;
+
+- (realm::Property)objectStoreCopy;
+
+@end
diff --git a/Pods/Realm/include/RLMQueryUtil.hpp b/Pods/Realm/include/RLMQueryUtil.hpp
new file mode 100644
index 0000000..e82fe34
--- /dev/null
+++ b/Pods/Realm/include/RLMQueryUtil.hpp
@@ -0,0 +1,42 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import <Foundation/Foundation.h>
+
+#import <vector>
+
+namespace realm {
+    class Group;
+    class Query;
+    class Table;
+    struct SortOrder;
+}
+
+@class RLMObjectSchema, RLMProperty, RLMSchema, RLMSortDescriptor;
+
+extern NSString * const RLMPropertiesComparisonTypeMismatchException;
+extern NSString * const RLMUnsupportedTypesFoundInPropertyComparisonException;
+
+realm::Query RLMPredicateToQuery(NSPredicate *predicate, RLMObjectSchema *objectSchema,
+                                 RLMSchema *schema, realm::Group &group);
+
+// return property - throw for invalid column name
+RLMProperty *RLMValidatedProperty(RLMObjectSchema *objectSchema, NSString *columnName);
+
+// validate the array of RLMSortDescriptors and convert it to a realm::SortOrder
+realm::SortOrder RLMSortOrderFromDescriptors(realm::Table& table, NSArray<RLMSortDescriptor *> *descriptors);
diff --git a/Pods/Realm/include/RLMRealm.h b/Pods/Realm/include/RLMRealm.h
new file mode 100644
index 0000000..e6a9ae8
--- /dev/null
+++ b/Pods/Realm/include/RLMRealm.h
@@ -0,0 +1,499 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import <Foundation/Foundation.h>
+#import "RLMConstants.h"
+
+@class RLMRealmConfiguration, RLMObject, RLMSchema, RLMMigration, RLMNotificationToken;
+
+NS_ASSUME_NONNULL_BEGIN
+
+/**
+ An `RLMRealm` instance (also referred to as "a Realm") represents a Realm
+ database.
+
+ Realms can either be stored on disk (see `+[RLMRealm realmWithURL:]`) or in
+ memory (see `RLMRealmConfiguration`).
+
+ `RLMRealm` instances are cached internally, and constructing equivalent `RLMRealm`
+ objects (for example, by using the same path or identifier) multiple times on a single thread
+ within a single iteration of the run loop will normally return the same
+ `RLMRealm` object.
+ 
+ If you specifically want to ensure an `RLMRealm` instance is
+ destroyed (for example, if you wish to open a Realm, check some property, and
+ then possibly delete the Realm file and re-open it), place the code which uses
+ the Realm within an `@autoreleasepool {}` and ensure you have no other
+ strong references to it.
+
+ @warning `RLMRealm` instances are not thread safe and cannot be shared across
+ threads or dispatch queues. Trying to do so will cause an exception to be thrown.
+ You must call this method on each thread you want
+ to interact with the Realm on. For dispatch queues, this means that you must
+ call it in each block which is dispatched, as a queue is not guaranteed to run
+ all of its blocks on the same thread.
+ */
+
+@interface RLMRealm : NSObject
+
+#pragma mark - Creating & Initializing a Realm
+
+/**
+ Obtains an instance of the default Realm.
+
+ The default Realm is used by the `RLMObject` class methods
+ which do not take an `RLMRealm` parameter, but is otherwise not special. The
+ default Realm is persisted as *default.realm* under the *Documents* directory of
+ your Application on iOS, and in your application's *Application Support*
+ directory on OS X.
+ 
+ The default Realm is created using the default `RLMRealmConfiguration`, which
+ can be changed via `+[RLMRealmConfiguration setDefaultConfiguration:]`.
+
+ @return The default `RLMRealm` instance for the current thread.
+ */
++ (instancetype)defaultRealm;
+
+/**
+ Obtains an `RLMRealm` instance with the given configuration.
+
+ @param configuration A configuration object to use when creating the Realm.
+ @param error         If an error occurs, upon return contains an `NSError` object
+                      that describes the problem. If you are not interested in
+                      possible errors, pass in `NULL`.
+
+ @return An `RLMRealm` instance.
+ */
++ (nullable instancetype)realmWithConfiguration:(RLMRealmConfiguration *)configuration error:(NSError **)error;
+
+/**
+ Obtains an `RLMRealm` instance persisted at a specified file URL.
+
+ @param fileURL The local URL of the file the Realm should be saved at.
+
+ @return An `RLMRealm` instance.
+ */
++ (instancetype)realmWithURL:(NSURL *)fileURL;
+
+/**
+ The `RLMSchema` used by the Realm.
+ */
+@property (nonatomic, readonly, null_unspecified) RLMSchema *schema;
+
+/**
+ Indicates if the Realm is currently engaged in a write transaction.
+
+ @warning   Do not simply check this property and then start a write transaction whenever an object needs to be
+            created, updated, or removed. Doing so might cause a large number of write transactions to be created,
+            degrading performance. Instead, always prefer performing multiple updates during a single transaction.
+ */
+@property (nonatomic, readonly) BOOL inWriteTransaction;
+
+/**
+ The `RLMRealmConfiguration` object that was used to create this `RLMRealm` instance.
+ */
+@property (nonatomic, readonly) RLMRealmConfiguration *configuration;
+
+/**
+ Indicates if this Realm contains any objects.
+ */
+@property (nonatomic, readonly) BOOL isEmpty;
+
+#pragma mark - Notifications
+
+/**
+ The type of a block to run whenever the data within the Realm is modified.
+ 
+ @see `-[RLMRealm addNotificationBlock:]`
+ */
+typedef void (^RLMNotificationBlock)(RLMNotification notification, RLMRealm *realm);
+
+#pragma mark - Receiving Notification when a Realm Changes
+
+/**
+ Adds a notification handler for changes in this Realm, and returns a notification token.
+
+ Notification handlers are called after each write transaction is committed,
+ either on the current thread or other threads.
+ 
+ Handler blocks are called on the same thread that they were added on, and may only be added on threads which are
+ currently within a run loop. Unless you are specifically creating and running a run loop on a background thread, this
+ will normally only be the main thread.
+
+ The block has the following definition:
+
+     typedef void(^RLMNotificationBlock)(RLMNotification notification, RLMRealm *realm);
+
+ It receives the following parameters:
+
+ - `NSString` \***notification**:    The name of the incoming notification. See
+                                     `RLMRealmNotification` for information on what
+                                     notifications are sent.
+ - `RLMRealm` \***realm**:           The Realm for which this notification occurred.
+
+ @param block   A block which is called to process Realm notifications.
+
+ @return A token object which must be retained as long as you wish to continue
+         receiving change notifications.
+ */
+- (RLMNotificationToken *)addNotificationBlock:(RLMNotificationBlock)block __attribute__((warn_unused_result));
+
+#pragma mark - Transactions
+
+
+#pragma mark - Writing to a Realm
+
+/**
+ Begins a write transaction on the Realm.
+
+ Only one write transaction can be open at a time. Write transactions cannot be
+ nested, and trying to begin a write transaction on a Realm which is
+ already in a write transaction will throw an exception. Calls to
+ `beginWriteTransaction` from `RLMRealm` instances in other threads will block
+ until the current write transaction completes.
+
+ Before beginning the write transaction, `beginWriteTransaction` updates the
+ `RLMRealm` instance to the latest Realm version, as if `refresh` had been called, and
+ generates notifications if applicable. This has no effect if the Realm
+ was already up to date.
+
+ It is rarely a good idea to have write transactions span multiple cycles of
+ the run loop, but if you do wish to do so you will need to ensure that the
+ Realm participating in the write transaction is kept alive until the write transaction
+ is committed.
+ */
+- (void)beginWriteTransaction;
+
+/**
+ Commits all write operations in the current write transaction, and ends the 
+ transaction.
+
+ @warning This method may only be called during a write transaction.
+ */
+- (void)commitWriteTransaction NS_SWIFT_UNAVAILABLE("");
+
+/**
+ Commits all write operations in the current write transaction, and ends the
+ transaction.
+
+ @warning This method may only be called during a write transaction.
+
+ @param error If an error occurs, upon return contains an `NSError` object
+              that describes the problem. If you are not interested in
+              possible errors, pass in `NULL`.
+
+ @return Whether the transaction succeeded.
+ */
+- (BOOL)commitWriteTransaction:(NSError **)error;
+
+/**
+ Reverts all writes made during the current write transaction and ends the transaction.
+
+ This rolls back all objects in the Realm to the state they were in at the
+ beginning of the write transaction, and then ends the transaction.
+
+ This restores the data for deleted objects, but does not revive invalidated
+ object instances. Any `RLMObject`s which were added to the Realm will be
+ invalidated rather than becoming unmanaged.
+ Given the following code:
+
+     ObjectType *oldObject = [[ObjectType objectsWhere:@"..."] firstObject];
+     ObjectType *newObject = [[ObjectType alloc] init];
+
+     [realm beginWriteTransaction];
+     [realm addObject:newObject];
+     [realm deleteObject:oldObject];
+     [realm cancelWriteTransaction];
+
+ Both `oldObject` and `newObject` will return `YES` for `isInvalidated`,
+ but re-running the query which provided `oldObject` will once again return
+ the valid object.
+
+ @warning This method may only be called during a write transaction.
+ */
+- (void)cancelWriteTransaction;
+
+/**
+ Performs actions contained within the given block inside a write transaction.
+ 
+ @see `[RLMRealm transactionWithBlock:error:]`
+ */
+- (void)transactionWithBlock:(__attribute__((noescape)) void(^)(void))block NS_SWIFT_UNAVAILABLE("");
+
+/**
+ Performs actions contained within the given block inside a write transaction.
+ 
+ Write transactions cannot be nested, and trying to execute a write transaction 
+ on a Realm which is already participating in a write transaction will throw an
+ exception. Calls to `transactionWithBlock:` from `RLMRealm` instances in other 
+ threads will block until the current write transaction completes.
+
+ Before beginning the write transaction, `transactionWithBlock:` updates the
+ `RLMRealm` instance to the latest Realm version, as if `refresh` had been called, and
+ generates notifications if applicable. This has no effect if the Realm
+ was already up to date.
+
+ @param block The block containing actions to perform.
+ @param error If an error occurs, upon return contains an `NSError` object
+              that describes the problem. If you are not interested in
+              possible errors, pass in `NULL`.
+
+ @return Whether the transaction succeeded.
+ */
+- (BOOL)transactionWithBlock:(__attribute__((noescape)) void(^)(void))block error:(NSError **)error;
+
+/**
+ Updates the Realm and outstanding objects managed by the Realm to point to the most recent data.
+
+ @return    Whether there were any updates for the Realm. Note that `YES` may be returned even if no data actually
+            changed.
+ */
+- (BOOL)refresh;
+
+/**
+ Set this property to `YES` to automatically update this Realm when changes happen in other threads.
+
+ If set to `YES` (the default), changes made on other threads will be reflected
+ in this Realm on the next cycle of the run loop after the changes are
+ committed.  If set to `NO`, you must manually call `-refresh` on the Realm to
+ update it to get the latest data.
+
+ Note that by default, background threads do not have an active run loop and you 
+ will need to manually call `-refresh` in order to update to the latest version,
+ even if `autorefresh` is set to `YES`.
+
+ Even with this property enabled, you can still call `-refresh` at any time to update the
+ Realm before the automatic refresh would occur.
+
+ Notifications are sent when a write transaction is committed whether or not
+ automatic refreshing is enabled.
+
+ Disabling `autorefresh` on a Realm without any strong references to it will not
+ have any effect, and `autorefresh` will revert back to `YES` the next time the Realm is created.
+ This is normally irrelevant as it means that there is
+ nothing to refresh (as managed `RLMObject`s, `RLMArray`s, and `RLMResults` have strong
+ references to the Realm that manages them), but it means that setting
+ `RLMRealm.defaultRealm.autorefresh = NO` in
+ `application:didFinishLaunchingWithOptions:` and only later storing Realm
+ objects will not work.
+
+ Defaults to `YES`.
+ */
+@property (nonatomic) BOOL autorefresh;
+
+/**
+ Writes a compacted and optionally encrypted copy of the Realm to the given local URL.
+
+ The destination file cannot already exist.
+
+ Note that if this method is called from within a write transaction, the *current* data is written, not the data from
+ the point when the previous write transaction was committed.
+
+ @param fileURL Local URL to save the Realm to.
+ @param key     Optional 64-byte encryption key to encrypt the new file with.
+ @param error   If an error occurs, upon return contains an `NSError` object
+                that describes the problem. If you are not interested in
+                possible errors, pass in `NULL`.
+
+ @return `YES` if the Realm was successfully written to disk, `NO` if an error occurred.
+*/
+- (BOOL)writeCopyToURL:(NSURL *)fileURL encryptionKey:(nullable NSData *)key error:(NSError **)error;
+
+/**
+ Invalidates all `RLMObject`s, `RLMResults`, `RLMLinkingObjects`, and `RLMArray`s managed by the Realm.
+
+ A Realm holds a read lock on the version of the data accessed by it, so
+ that changes made to the Realm on different threads do not modify or delete the
+ data seen by this Realm. Calling this method releases the read lock,
+ allowing the space used on disk to be reused by later write transactions rather
+ than growing the file. This method should be called before performing long
+ blocking operations on a background thread on which you previously read data
+ from the Realm which you no longer need.
+
+ All `RLMObject`, `RLMResults` and `RLMArray` instances obtained from this
+ `RLMRealm` instance on the current thread are invalidated. `RLMObject`s and `RLMArray`s
+ cannot be used. `RLMResults` will become empty. The Realm itself remains valid,
+ and a new read transaction is implicitly begun the next time data is read from the Realm.
+
+ Calling this method multiple times in a row without reading any data from the
+ Realm, or before ever reading any data from the Realm, is a no-op. This method
+ may not be called on a read-only Realm.
+ */
+- (void)invalidate;
+
+#pragma mark - Accessing Objects
+
+
+#pragma mark - Adding and Removing Objects from a Realm
+
+/**
+ Adds an object to the Realm.
+
+ Once added, this object is considered to be managed by the Realm. It can be retrieved
+ using the `objectsWhere:` selectors on `RLMRealm` and on subclasses of `RLMObject`.
+
+ When added, all child relationships referenced by this object will also be added to 
+ the Realm if they are not already in it.
+ 
+ If the object or any related objects are already being managed by a different Realm
+ an exception will be thrown. Use `-[RLMObject createInRealm:withObject:]` to insert a copy of a managed object
+ into a different Realm.
+
+ The object to be added must be valid and cannot have been previously deleted
+ from a Realm (i.e. `isInvalidated` must be `NO`).
+
+ @warning This method may only be called during a write transaction.
+
+ @param object  The object to be added to this Realm.
+ */
+- (void)addObject:(RLMObject *)object;
+
+/**
+ Adds all the objects in a collection to the Realm.
+
+ This is the equivalent of calling `addObject:` for every object in a collection.
+
+ @warning This method may only be called during a write transaction.
+
+ @param array   An enumerable object such as `NSArray` or `RLMResults` which contains objects to be added to
+                the Realm.
+
+ @see   `addObject:`
+ */
+- (void)addObjects:(id<NSFastEnumeration>)array;
+
+/**
+ Adds or updates an existing object into the Realm.
+ 
+ The object provided must have a designated primary key. If no objects exist in the Realm 
+ with the same primary key value, the object is inserted. Otherwise, the existing object is
+ updated with any changed values.
+
+ As with `addObject:`, the object cannot already be managed by a different
+ Realm. Use `-[RLMObject createOrUpdateInRealm:withValue:]` to copy values to
+ a different Realm.
+
+ @warning This method may only be called during a write transaction.
+
+ @param object  The object to be added or updated.
+ */
+- (void)addOrUpdateObject:(RLMObject *)object;
+
+/**
+ Adds or updates all the objects in a collection into the Realm.
+
+ This is the equivalent of calling `addOrUpdateObject:` for every object in a collection.
+
+ @warning This method may only be called during a write transaction.
+
+ @param array  An `NSArray`, `RLMArray`, or `RLMResults` of `RLMObject`s (or subclasses) to be added to the Realm.
+
+ @see   `addOrUpdateObject:`
+ */
+- (void)addOrUpdateObjectsFromArray:(id)array;
+
+/**
+ Deletes an object from the Realm. Once the object is deleted it is considered invalidated.
+
+ @warning This method may only be called during a write transaction.
+
+ @param object  The object to be deleted.
+ */
+- (void)deleteObject:(RLMObject *)object;
+
+/**
+ Deletes one or more objects from the Realm.
+ 
+ This is the equivalent of calling `deleteObject:` for every object in a collection.
+
+ @warning This method may only be called during a write transaction.
+
+ @param array  An `RLMArray`, `NSArray`, or `RLMResults` of `RLMObject`s (or subclasses) to be deleted.
+ 
+ @see `deleteObject:`
+ */
+- (void)deleteObjects:(id)array;
+
+/**
+ Deletes all objects from the Realm.
+
+ @warning This method may only be called during a write transaction.
+
+ @see `deleteObject:`
+ */
+- (void)deleteAllObjects;
+
+
+#pragma mark - Migrations
+
+/**
+ The type of a migration block used to migrate a Realm.
+
+ @param migration   A `RLMMigration` object used to perform the migration. The
+                    migration object allows you to enumerate and alter any
+                    existing objects which require migration.
+
+ @param oldSchemaVersion    The schema version of the Realm being migrated.
+ */
+typedef void (^RLMMigrationBlock)(RLMMigration *migration, uint64_t oldSchemaVersion);
+
+/**
+ Returns the schema version for a Realm at a given local URL.
+
+ @param fileURL Local URL to a Realm file.
+ @param key     64-byte key used to encrypt the file, or `nil` if it is unencrypted.
+ @param error   If an error occurs, upon return contains an `NSError` object
+                that describes the problem. If you are not interested in
+                possible errors, pass in `NULL`.
+
+ @return The version of the Realm at `fileURL`, or `RLMNotVersioned` if the version cannot be read.
+ */
++ (uint64_t)schemaVersionAtURL:(NSURL *)fileURL encryptionKey:(nullable NSData *)key error:(NSError **)error
+NS_REFINED_FOR_SWIFT;
+
+/**
+ Performs the given Realm configuration's migration block on a Realm at the given path.
+
+ This method is called automatically when opening a Realm for the first time and does
+ not need to be called explicitly. You can choose to call this method to control
+ exactly when and how migrations are performed.
+
+ @param configuration The Realm configuration used to open and migrate the Realm.
+ @return              The error that occurred while applying the migration, if any.
+
+ @see                 RLMMigration
+ */
++ (nullable NSError *)migrateRealm:(RLMRealmConfiguration *)configuration;
+
+@end
+
+/**
+ A token which is returned from methods which subscribe to changes to a Realm.
+
+ Change subscriptions in Realm return an `RLMNotificationToken` instance, 
+ which can be used to unsubscribe from the changes. You must store a strong
+ reference to the token for as long as you want to continue to receive notifications.
+ When you wish to stop, call the `-stop` method. Notifications are also stopped if
+ the token is deallocated.
+ */
+@interface RLMNotificationToken : NSObject
+/// Stops notifications for the change subscription that returned this token.
+- (void)stop;
+@end
+
+NS_ASSUME_NONNULL_END
diff --git a/Pods/Realm/include/RLMRealmConfiguration.h b/Pods/Realm/include/RLMRealmConfiguration.h
new file mode 100644
index 0000000..21e163b
--- /dev/null
+++ b/Pods/Realm/include/RLMRealmConfiguration.h
@@ -0,0 +1,99 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2015 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import <Foundation/Foundation.h>
+#import <Realm/RLMRealm.h>
+
+NS_ASSUME_NONNULL_BEGIN
+
+/**
+ An `RLMRealmConfiguration` instance describes the different options used to
+ create an instance of a Realm.
+
+ `RLMRealmConfiguration` instances are just plain `NSObject`s. Unlike `RLMRealm`s
+ and `RLMObject`s, they can be freely shared between threads as long as you do not
+ mutate them.
+ 
+ Creating configuration objects for class subsets (by setting the
+ `objectClasses` property) can be expensive. Because of this, you will normally want to
+ cache and reuse a single configuration object for each distinct configuration rather than 
+ creating a new object each time you open a Realm.
+ */
+@interface RLMRealmConfiguration : NSObject<NSCopying>
+
+#pragma mark - Default Configuration
+
+/**
+ Returns the default configuration used to create Realms when no other
+ configuration is explicitly specified (i.e. `+[RLMRealm defaultRealm]`).
+
+ @return The default Realm configuration.
+ */
++ (instancetype)defaultConfiguration;
+
+/**
+ Sets the default configuration to the given `RLMRealmConfiguration`.
+
+ @param configuration The new default Realm configuration.
+ */
++ (void)setDefaultConfiguration:(RLMRealmConfiguration *)configuration;
+
+#pragma mark - Properties
+
+/// The local URL of the Realm file. Mutually exclusive with `inMemoryIdentifier`.
+@property (nonatomic, copy, nullable) NSURL *fileURL;
+
+/// A string used to identify a particular in-memory Realm. Mutually exclusive with `fileURL`.
+@property (nonatomic, copy, nullable) NSString *inMemoryIdentifier;
+
+/// A 64-byte key to use to encrypt the data, or `nil` if encryption is not enabled.
+@property (nonatomic, copy, nullable) NSData *encryptionKey;
+
+/// Whether to open the Realm in read-only mode.
+///
+/// This is required to be able to open Realm files which are not writeable or
+/// are in a directory which is not writeable. This should only be used on files
+/// which will not be modified by anyone while they are open, and not just to
+/// get a read-only view of a file which may be written to by another thread or
+/// process. Opening in read-only mode requires disabling Realm's reader/writer
+/// coordination, so committing a write transaction from another process will
+/// result in crashes.
+@property (nonatomic) BOOL readOnly;
+
+/// The current schema version.
+@property (nonatomic) uint64_t schemaVersion;
+
+/// The block which migrates the Realm to the current version.
+@property (nonatomic, copy, nullable) RLMMigrationBlock migrationBlock;
+
+/**
+ Whether to recreate the Realm file with the provided schema if a migration is required.
+ This is the case when the stored schema differs from the provided schema or
+ the stored schema version differs from the version on this configuration.
+ Setting this property to `YES` deletes the file if a migration would otherwise be required or executed.
+
+ @note Setting this property to `YES` doesn't disable file format migrations.
+ */
+@property (nonatomic) BOOL deleteRealmIfMigrationNeeded;
+
+/// The classes managed by the Realm.
+@property (nonatomic, copy, nullable) NSArray *objectClasses;
+
+@end
+
+NS_ASSUME_NONNULL_END
diff --git a/Pods/Realm/include/RLMRealmConfiguration_Private.h b/Pods/Realm/include/RLMRealmConfiguration_Private.h
new file mode 100644
index 0000000..91770a2
--- /dev/null
+++ b/Pods/Realm/include/RLMRealmConfiguration_Private.h
@@ -0,0 +1,38 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2015 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import <Realm/RLMRealmConfiguration.h>
+
+@class RLMSchema;
+
+@interface RLMRealmConfiguration ()
+
+@property (nonatomic, readwrite) bool cache;
+@property (nonatomic, readwrite) bool dynamic;
+@property (nonatomic, readwrite) bool disableFormatUpgrade;
+@property (nonatomic, copy) RLMSchema *customSchema;
+
+// Get the default confiugration without copying it
++ (RLMRealmConfiguration *)rawDefaultConfiguration;
+
++ (void)resetRealmConfigurationState;
+@end
+
+// Get a path in the platform-appropriate documents directory with the given filename
+FOUNDATION_EXTERN NSString *RLMRealmPathForFile(NSString *fileName);
+FOUNDATION_EXTERN NSString *RLMRealmPathForFileAndBundleIdentifier(NSString *fileName, NSString *mainBundleIdentifier);
diff --git a/Pods/Realm/include/RLMRealmConfiguration_Private.hpp b/Pods/Realm/include/RLMRealmConfiguration_Private.hpp
new file mode 100644
index 0000000..ec06f53
--- /dev/null
+++ b/Pods/Realm/include/RLMRealmConfiguration_Private.hpp
@@ -0,0 +1,24 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import "RLMRealmConfiguration_Private.h"
+#import "shared_realm.hpp"
+
+@interface RLMRealmConfiguration ()
+- (realm::Realm::Config&)config;
+@end
diff --git a/Pods/Realm/include/RLMRealmUtil.hpp b/Pods/Realm/include/RLMRealmUtil.hpp
new file mode 100644
index 0000000..b69c727
--- /dev/null
+++ b/Pods/Realm/include/RLMRealmUtil.hpp
@@ -0,0 +1,42 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import <Foundation/Foundation.h>
+#import <memory>
+#import <string>
+
+@class RLMRealm;
+
+namespace realm {
+    class BindingContext;
+}
+
+// Add a Realm to the weak cache
+void RLMCacheRealm(std::string const& path, RLMRealm *realm);
+// Get a Realm for the given path which can be used on the current thread
+RLMRealm *RLMGetThreadLocalCachedRealmForPath(std::string const& path);
+// Get a Realm for the given path
+RLMRealm *RLMGetAnyCachedRealmForPath(std::string const& path);
+// Clear the weak cache of Realms
+void RLMClearRealmCache();
+
+// Install an uncaught exception handler that cancels write transactions
+// for all cached realms on the current thread
+void RLMInstallUncaughtExceptionHandler();
+
+std::unique_ptr<realm::BindingContext> RLMCreateBindingContext(RLMRealm *realm);
diff --git a/Pods/Realm/include/RLMRealm_Dynamic.h b/Pods/Realm/include/RLMRealm_Dynamic.h
new file mode 100644
index 0000000..0eca053
--- /dev/null
+++ b/Pods/Realm/include/RLMRealm_Dynamic.h
@@ -0,0 +1,114 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import <Realm/RLMRealm.h>
+
+#import <Realm/RLMObjectSchema.h>
+#import <Realm/RLMProperty.h>
+
+@class RLMResults;
+
+@interface RLMRealm (Dynamic)
+
+#pragma mark - Getting Objects from a Realm
+
+/**
+ Returns all objects of a given type from the Realm.
+
+ @warning This method is useful only in specialized circumstances, for example, when building components
+          that integrate with Realm. The preferred way to get objects of a single class is to use the class
+          methods on `RLMObject`.
+
+ @param className   The name of the `RLMObject` subclass to retrieve on (e.g. `MyClass.className`).
+
+ @return    An `RLMResults` containing all objects in the Realm of the given type.
+
+ @see       `+[RLMObject allObjects]`
+ */
+- (RLMResults *)allObjects:(NSString *)className;
+
+/**
+ Returns all objects matching the given predicate from the Realm.
+
+ @warning This method is useful only in specialized circumstances, for example, when building components
+          that integrate with Realm. The preferred way to get objects of a single class is to use the class
+          methods on `RLMObject`.
+
+ @param className       The type of objects you are looking for (name of the class).
+ @param predicateFormat A predicate format string, optionally followed by a variable number of arguments.
+
+ @return    An `RLMResults` containing results matching the given predicate.
+
+ @see       `+[RLMObject objectsWhere:]`
+ */
+- (RLMResults *)objects:(NSString *)className where:(NSString *)predicateFormat, ...;
+
+/**
+ Returns all objects matching the given predicate from the Realm.
+
+ @warning This method is useful only in specialized circumstances, for example, when building components
+          that integrate with Realm. The preferred way to get objects of a single class is to use the class
+          methods on `RLMObject`.
+
+ @param className   The type of objects you are looking for (name of the class).
+ @param predicate   The predicate with which to filter the objects.
+
+ @return    An `RLMResults` containing results matching the given predicate.
+
+ @see       `+[RLMObject objectsWhere:]`
+ */
+- (RLMResults *)objects:(NSString *)className withPredicate:(NSPredicate *)predicate;
+
+/**
+ Returns the object of the given type with the given primary key from the Realm.
+
+ @warning This method is useful only in specialized circumstances, for example, when building components 
+          that integrate with Realm. The preferred way to get an object of a single class is to use the class
+          methods on `RLMObject`.
+ 
+ @param className   The class name for the object you are looking for.
+ @param primaryKey  The primary key value for the object you are looking for.
+ 
+ @return    An object, or `nil` if an object with the given primary key does not exist.
+ 
+ @see       `+[RLMObject objectForPrimaryKey:]`
+ */
+- (RLMObject *)objectWithClassName:(NSString *)className forPrimaryKey:(id)primaryKey;
+
+/**
+ Creates an `RLMObject` instance of type `className` in the Realm, and populates it using a given object.
+ 
+ The `value` argument is used to populate the object. It can be a key-value coding compliant object, an array or
+ dictionary returned from the methods in `NSJSONSerialization`, or an array containing one element for each managed
+ property. An exception will be thrown if any required properties are not present and those properties were not defined
+ with default values.
+
+ When passing in an array as the `value` argument, all properties must be present, valid and in the same order as the
+ properties defined in the model.
+
+ @warning This method is useful only in specialized circumstances, for example, when building components
+          that integrate with Realm. If you are simply building an app on Realm, it is recommended to
+          use `[RLMObject createInDefaultRealmWithValue:]`.
+
+ @param value    The value used to populate the object.
+
+ @return    An `RLMObject` instance of type `className`.
+ */
+-(RLMObject *)createObject:(NSString *)className withValue:(id)value;
+
+@end
diff --git a/Pods/Realm/include/RLMRealm_Private.h b/Pods/Realm/include/RLMRealm_Private.h
new file mode 100644
index 0000000..a9ac34a
--- /dev/null
+++ b/Pods/Realm/include/RLMRealm_Private.h
@@ -0,0 +1,50 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import <Realm/RLMRealm.h>
+
+@class RLMFastEnumerator;
+
+// Disable syncing files to disk. Cannot be re-enabled. Use only for tests.
+FOUNDATION_EXTERN void RLMDisableSyncToDisk();
+
+FOUNDATION_EXTERN NSData *RLMRealmValidatedEncryptionKey(NSData *key);
+
+// Translate an in-flight exception resulting from opening a SharedGroup to
+// an NSError or NSException (if error is nil)
+void RLMRealmTranslateException(NSError **error);
+
+// RLMRealm private members
+@interface RLMRealm ()
+
+@property (nonatomic, readonly) BOOL dynamic;
+@property (nonatomic, readwrite) RLMSchema *schema;
+
++ (void)resetRealmState;
+
+- (void)registerEnumerator:(RLMFastEnumerator *)enumerator;
+- (void)unregisterEnumerator:(RLMFastEnumerator *)enumerator;
+- (void)detachAllEnumerators;
+
+- (void)sendNotifications:(RLMNotification)notification;
+- (void)verifyThread;
+- (void)verifyNotificationsAreSupported;
+
++ (NSString *)writeableTemporaryPathForFile:(NSString *)fileName;
+
+@end
diff --git a/Pods/Realm/include/RLMRealm_Private.hpp b/Pods/Realm/include/RLMRealm_Private.hpp
new file mode 100644
index 0000000..3b6c98d
--- /dev/null
+++ b/Pods/Realm/include/RLMRealm_Private.hpp
@@ -0,0 +1,38 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import "RLMRealm_Private.h"
+#import "RLMUtil.hpp"
+#import "shared_realm.hpp"
+
+#import <realm/group.hpp>
+
+namespace realm {
+    class Group;
+    class Realm;
+    typedef std::shared_ptr<realm::Realm> SharedRealm;
+}
+
+@interface RLMRealm () {
+    @public
+    realm::SharedRealm _realm;
+}
+
+// FIXME - group should not be exposed
+@property (nonatomic, readonly) realm::Group *group;
+@end
diff --git a/Pods/Realm/include/RLMResults.h b/Pods/Realm/include/RLMResults.h
new file mode 100644
index 0000000..b0066d6
--- /dev/null
+++ b/Pods/Realm/include/RLMResults.h
@@ -0,0 +1,332 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import <Foundation/Foundation.h>
+#import <Realm/RLMCollection.h>
+
+NS_ASSUME_NONNULL_BEGIN
+
+@class RLMObject, RLMRealm, RLMNotificationToken;
+
+/**
+ `RLMResults` is an auto-updating container type in Realm returned from object
+ queries. It represents the results of the query in the form of a collection of objects.
+
+ `RLMResults` can be queried using the same predicates as `RLMObject` and `RLMArray`,
+ and you can chain queries to further filter results.
+
+ `RLMResults` always reflect the current state of the Realm on the current thread,
+ including during write transactions on the current thread. The one exception to
+ this is when using `for...in` fast enumeration, which will always enumerate
+ over the objects which matched the query when the enumeration is begun, even if
+ some of them are deleted or modified to be excluded by the filter during the
+ enumeration.
+
+ `RLMResults` are lazily evaluated the first time they are accessed; they only
+ run queries when the result of the query is requested. This means that 
+ chaining several temporary `RLMResults` to sort and filter your data does not 
+ perform any extra work processing the intermediate state.
+
+ Once the results have been evaluated or a notification block has been added,
+ the results are eagerly kept up-to-date, with the work done to keep them
+ up-to-date done on a background thread whenever possible.
+
+ `RLMResults` cannot be directly instantiated.
+ */
+@interface RLMResults<RLMObjectType: RLMObject *> : NSObject<RLMCollection, NSFastEnumeration>
+
+#pragma mark - Properties
+
+/**
+ The number of objects in the results collection.
+ */
+@property (nonatomic, readonly, assign) NSUInteger count;
+
+/**
+ The class name (i.e. type) of the `RLMObject`s contained in the results collection.
+ */
+@property (nonatomic, readonly, copy) NSString *objectClassName;
+
+/**
+ The Realm which manages this results collection.
+ */
+@property (nonatomic, readonly) RLMRealm *realm;
+
+/**
+ Indicates if the results collection is no longer valid.
+
+ The results collection becomes invalid if `invalidate` is called on the containing `realm`.
+ An invalidated results collection can be accessed, but will always be empty.
+ */
+@property (nonatomic, readonly, getter = isInvalidated) BOOL invalidated;
+
+#pragma mark - Accessing Objects from an RLMResults
+
+/**
+ Returns the object at the index specified.
+
+ @param index   The index to look up.
+
+ @return An `RLMObject` of the type contained in the results collection.
+ */
+- (RLMObjectType)objectAtIndex:(NSUInteger)index;
+
+/**
+ Returns the first object in the results collection.
+
+ Returns `nil` if called on an empty results collection.
+
+ @return An `RLMObject` of the type contained in the results collection.
+ */
+- (nullable RLMObjectType)firstObject;
+
+/**
+ Returns the last object in the results collection.
+
+ Returns `nil` if called on an empty results collection.
+
+ @return An `RLMObject` of the type contained in the results collection.
+ */
+- (nullable RLMObjectType)lastObject;
+
+#pragma mark - Querying Results
+
+/**
+ Returns the index of an object in the results collection.
+
+ Returns `NSNotFound` if the object is not found in the results collection.
+
+ @param object  An object (of the same type as returned from the `objectClassName` selector).
+ */
+- (NSUInteger)indexOfObject:(RLMObjectType)object;
+
+/**
+ Returns the index of the first object in the results collection matching the predicate.
+
+ @param predicateFormat A predicate format string, optionally followed by a variable number of arguments.
+
+ @return    The index of the object, or `NSNotFound` if the object is not found in the results collection.
+ */
+- (NSUInteger)indexOfObjectWhere:(NSString *)predicateFormat, ...;
+
+/// :nodoc:
+- (NSUInteger)indexOfObjectWhere:(NSString *)predicateFormat args:(va_list)args;
+
+/**
+ Returns the index of the first object in the results collection matching the predicate.
+
+ @param predicate   The predicate with which to filter the objects.
+
+ @return    The index of the object, or `NSNotFound` if the object is not found in the results collection.
+ */
+- (NSUInteger)indexOfObjectWithPredicate:(NSPredicate *)predicate;
+
+/**
+ Returns all the objects matching the given predicate in the results collection.
+
+ @param predicateFormat A predicate format string, optionally followed by a variable number of arguments.
+
+ @return                An `RLMResults` of objects that match the given predicate.
+ */
+- (RLMResults<RLMObjectType> *)objectsWhere:(NSString *)predicateFormat, ...;
+
+/// :nodoc:
+- (RLMResults<RLMObjectType> *)objectsWhere:(NSString *)predicateFormat args:(va_list)args;
+
+/**
+ Returns all the objects matching the given predicate in the results collection.
+
+ @param predicate   The predicate with which to filter the objects.
+
+ @return            An `RLMResults` of objects that match the given predicate.
+ */
+- (RLMResults<RLMObjectType> *)objectsWithPredicate:(NSPredicate *)predicate;
+
+/**
+ Returns a sorted `RLMResults` from an existing results collection.
+
+ @param property    The property name to sort by.
+ @param ascending   The direction to sort in.
+
+ @return    An `RLMResults` sorted by the specified property.
+ */
+- (RLMResults<RLMObjectType> *)sortedResultsUsingProperty:(NSString *)property ascending:(BOOL)ascending;
+
+/**
+ Returns a sorted `RLMResults` from an existing results collection.
+
+ @param properties  An array of `RLMSortDescriptor`s to sort by.
+
+ @return    An `RLMResults` sorted by the specified properties.
+ */
+- (RLMResults<RLMObjectType> *)sortedResultsUsingDescriptors:(NSArray *)properties;
+
+#pragma mark - Notifications
+
+/**
+ Registers a block to be called each time the results collection changes.
+
+ The block will be asynchronously called with the initial results collection,
+ and then called again after each write transaction which changes either any
+ of the objects in the results, or which objects are in the results.
+
+ The `change` parameter will be `nil` the first time the block is called.
+ For each call after that, it will contain information about
+ which rows in the results collection were added, removed or modified. If a
+ write transaction did not modify any objects in the results collection,
+ the block is not called at all. See the `RLMCollectionChange` documentation for
+ information on how the changes are reported and an example of updating a 
+ `UITableView`.
+
+ If an error occurs the block will be called with `nil` for the results
+ parameter and a non-`nil` error. Currently the only errors that can occur are
+ when opening the Realm on the background worker thread.
+
+ At the time when the block is called, the `RLMResults` object will be fully
+ evaluated and up-to-date, and as long as you do not perform a write transaction
+ on the same thread or explicitly call `-[RLMRealm refresh]`, accessing it will
+ never perform blocking work.
+
+ Notifications are delivered via the standard run loop, and so can't be
+ delivered while the run loop is blocked by other activity. When
+ notifications can't be delivered instantly, multiple notifications may be
+ coalesced into a single notification. This can include the notification
+ with the initial results. For example, the following code performs a write
+ transaction immediately after adding the notification block, so there is no
+ opportunity for the initial notification to be delivered first. As a
+ result, the initial notification will reflect the state of the Realm after
+ the write transaction.
+
+     RLMResults<Dog *> *results = [Dog allObjects];
+     NSLog(@"dogs.count: %zu", dogs.count); // => 0
+     self.token = [results addNotificationBlock:^(RLMResults *dogs,
+                                                  RLMCollectionChange *changes,
+                                                  NSError *error) {
+         // Only fired once for the example
+         NSLog(@"dogs.count: %zu", dogs.count); // => 1
+     }];
+     [realm transactionWithBlock:^{
+         Dog *dog = [[Dog alloc] init];
+         dog.name = @"Rex";
+         [realm addObject:dog];
+     }];
+     // end of run loop execution context
+
+ You must retain the returned token for as long as you want updates to continue
+ to be sent to the block. To stop receiving updates, call `-stop` on the token.
+
+ @warning This method cannot be called during a write transaction, or when the
+          containing Realm is read-only.
+
+ @param block The block to be called whenever a change occurs.
+ @return A token which must be held for as long as you want updates to be delivered.
+ */
+- (RLMNotificationToken *)addNotificationBlock:(void (^)(RLMResults<RLMObjectType> *__nullable results,
+                                                         RLMCollectionChange *__nullable change,
+                                                         NSError *__nullable error))block __attribute__((warn_unused_result));
+
+#pragma mark - Aggregating Property Values
+
+/**
+ Returns the minimum (lowest) value of the given property among all the objects
+ represented by the results collection.
+
+     NSNumber *min = [results minOfProperty:@"age"];
+
+ @warning You cannot use this method on `RLMObject`, `RLMArray`, and `NSData` properties.
+
+ @param property The property whose minimum value is desired. Only properties of types `int`, `float`, `double`, and
+                 `NSDate` are supported.
+
+ @return The minimum value of the property.
+ */
+- (nullable id)minOfProperty:(NSString *)property;
+
+/**
+ Returns the maximum (highest) value of the given property among all the objects represented by the results collection.
+
+     NSNumber *max = [results maxOfProperty:@"age"];
+
+ @warning You cannot use this method on `RLMObject`, `RLMArray`, and `NSData` properties.
+
+ @param property The property whose maximum value is desired. Only properties of types `int`, `float`, `double`, and 
+                 `NSDate` are supported.
+
+ @return The maximum value of the property.
+ */
+- (nullable id)maxOfProperty:(NSString *)property;
+
+/**
+ Returns the sum of the values of a given property over all the objects represented by the results collection.
+
+     NSNumber *sum = [results sumOfProperty:@"age"];
+
+ @warning You cannot use this method on `RLMObject`, `RLMArray`, and `NSData` properties.
+
+ @param property The property whose values should be summed. Only properties of types `int`, `float`, and `double` are
+                 supported.
+
+ @return The sum of the given property.
+ */
+- (NSNumber *)sumOfProperty:(NSString *)property;
+
+/**
+ Returns the average value of a given property over the objects represented by the results collection.
+
+     NSNumber *average = [results averageOfProperty:@"age"];
+
+ @warning You cannot use this method on `RLMObject`, `RLMArray`, and `NSData` properties.
+
+ @param property The property whose average value should be calculated. Only properties of types `int`, `float`, and
+                 `double` are supported.
+
+ @return    The average value of the given property. This will be of type `double` for both `float` and `double`
+            properties.
+ */
+- (nullable NSNumber *)averageOfProperty:(NSString *)property;
+
+/// :nodoc:
+- (id)objectAtIndexedSubscript:(NSUInteger)index;
+
+#pragma mark - Unavailable Methods
+
+/**
+ `-[RLMResults init]` is not available because `RLMResults` cannot be created directly.
+ `RLMResults` can be obtained by querying a Realm.
+ */
+- (instancetype)init __attribute__((unavailable("RLMResults cannot be created directly")));
+
+/**
+ `+[RLMResults new]` is not available because `RLMResults` cannot be created directly.
+ `RLMResults` can be obtained by querying a Realm.
+ */
++ (instancetype)new __attribute__((unavailable("RLMResults cannot be created directly")));
+
+@end
+
+/**
+ `RLMLinkingObjects` is an auto-updating container type. It represents a collection of objects that link to its
+ parent object.
+ 
+ For more information, please see the "Inverse Relationships" section in the
+ [documentation](https://realm.io/docs/objc/latest/#relationships).
+ */
+@interface RLMLinkingObjects<RLMObjectType: RLMObject *> : RLMResults
+@end
+
+NS_ASSUME_NONNULL_END
diff --git a/Pods/Realm/include/RLMResults_Private.h b/Pods/Realm/include/RLMResults_Private.h
new file mode 100644
index 0000000..1adaf14
--- /dev/null
+++ b/Pods/Realm/include/RLMResults_Private.h
@@ -0,0 +1,29 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import <Realm/RLMResults.h>
+
+@class RLMObjectSchema;
+
+@interface RLMResults ()
+@property (nonatomic, unsafe_unretained) RLMObjectSchema *objectSchema;
+@property (nonatomic, readonly, getter=isAttached) BOOL attached;
+
++ (instancetype)emptyDetachedResults;
+
+@end
diff --git a/Pods/Realm/include/RLMSchema.h b/Pods/Realm/include/RLMSchema.h
new file mode 100644
index 0000000..169a605
--- /dev/null
+++ b/Pods/Realm/include/RLMSchema.h
@@ -0,0 +1,77 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import <Foundation/Foundation.h>
+
+NS_ASSUME_NONNULL_BEGIN
+
+@class RLMObjectSchema;
+
+/**
+ `RLMSchema` instances represent collections of model object schemas managed by a Realm.
+
+ When using Realm, `RLMSchema` instances allow performing migrations and
+ introspecting the database's schema.
+
+ Schemas map to collections of tables in the core database.
+ */
+@interface RLMSchema : NSObject<NSCopying>
+
+#pragma mark - Properties
+
+/**
+ An `NSArray` containing `RLMObjectSchema`s for all object types in the Realm.
+ 
+ This property is intended to be used during migrations for dynamic introspection.
+
+ @see `RLMObjectSchema`
+ */
+@property (nonatomic, readonly, copy) NSArray<RLMObjectSchema *> *objectSchema;
+
+#pragma mark - Methods
+
+/**
+ Returns an `RLMObjectSchema` for the given class name in the schema.
+
+ @param className   The object class name.
+ @return            An `RLMObjectSchema` for the given class in the schema.
+
+ @see               `RLMObjectSchema`
+ */
+- (nullable RLMObjectSchema *)schemaForClassName:(NSString *)className;
+
+/**
+ Looks up and returns an `RLMObjectSchema` for the given class name in the Realm.
+ 
+ If there is no object of type `className` in the schema, an exception will be thrown.
+
+ @param className   The object class name.
+ @return            An `RLMObjectSchema` for the given class in this Realm.
+
+ @see               `RLMObjectSchema`
+ */
+- (RLMObjectSchema *)objectForKeyedSubscript:(id <NSCopying>)className;
+
+/**
+ Returns a Boolean value that indicates whether two `RLMSchema` instances are equivalent.
+ */
+- (BOOL)isEqualToSchema:(RLMSchema *)schema;
+
+@end
+
+NS_ASSUME_NONNULL_END
diff --git a/Pods/Realm/include/RLMSchema_Private.h b/Pods/Realm/include/RLMSchema_Private.h
new file mode 100644
index 0000000..9051f91
--- /dev/null
+++ b/Pods/Realm/include/RLMSchema_Private.h
@@ -0,0 +1,65 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#import <Realm/RLMSchema.h>
+
+NS_ASSUME_NONNULL_BEGIN
+
+@class RLMRealm;
+
+//
+// RLMSchema private interface
+//
+@interface RLMSchema ()
+
+/**
+ Returns an `RLMSchema` containing only the given `RLMObject` subclasses.
+
+ @param classes The classes to be included in the schema.
+
+ @return An `RLMSchema` containing only the given classes.
+ */
++ (instancetype)schemaWithObjectClasses:(NSArray<Class> *)classes;
+
+@property (nonatomic, readwrite, copy) NSArray<RLMObjectSchema *> *objectSchema;
+
+// schema based on runtime objects
++ (instancetype)sharedSchema;
+
+// schema based upon all currently registered object classes
++ (instancetype)partialSharedSchema;
+
+// class for string
++ (nullable Class)classForString:(NSString *)className;
+
+// shallow copy for reusing schema properties accross the same Realm on multiple threads
+- (instancetype)shallowCopy;
+
++ (nullable RLMObjectSchema *)sharedSchemaForClass:(Class)cls;
+
+@end
+
+NS_ASSUME_NONNULL_END
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/Pods/Realm/include/RLMSchema_Private.hpp b/Pods/Realm/include/RLMSchema_Private.hpp
new file mode 100644
index 0000000..bd9e6d6
--- /dev/null
+++ b/Pods/Realm/include/RLMSchema_Private.hpp
@@ -0,0 +1,31 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2015 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import "RLMSchema_Private.h"
+
+#import <memory>
+
+namespace realm {
+    class Schema;
+    class ObjectSchema;
+}
+
+@interface RLMSchema ()
++ (instancetype)dynamicSchemaFromObjectStoreSchema:(realm::Schema &)objectStoreSchema;
+- (std::unique_ptr<realm::Schema>)objectStoreCopy;
+@end
diff --git a/Pods/Realm/include/RLMSwiftBridgingHeader.h b/Pods/Realm/include/RLMSwiftBridgingHeader.h
new file mode 100644
index 0000000..4758043
--- /dev/null
+++ b/Pods/Realm/include/RLMSwiftBridgingHeader.h
@@ -0,0 +1,49 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import <Realm/RLMArray.h>
+#import <Realm/RLMObject.h>
+
+@interface RLMRealm (Swift)
++ (void)resetRealmState;
+@end
+
+@interface RLMArray (Swift)
+
+- (instancetype)initWithObjectClassName:(NSString *)objectClassName;
+
+- (NSUInteger)indexOfObjectWhere:(NSString *)predicateFormat args:(va_list)args;
+- (RLMResults *)objectsWhere:(NSString *)predicateFormat args:(va_list)args;
+
+@end
+
+@interface RLMResults (Swift)
+
+- (NSUInteger)indexOfObjectWhere:(NSString *)predicateFormat args:(va_list)args;
+- (RLMResults *)objectsWhere:(NSString *)predicateFormat args:(va_list)args;
+
+@end
+
+@interface RLMObjectBase (Swift)
+
+- (instancetype)initWithRealm:(RLMRealm *)realm schema:(RLMObjectSchema *)schema defaultValues:(BOOL)useDefaults;
+
++ (RLMResults *)objectsWhere:(NSString *)predicateFormat args:(va_list)args;
++ (RLMResults *)objectsInRealm:(RLMRealm *)realm where:(NSString *)predicateFormat args:(va_list)args;
+
+@end
diff --git a/Pods/Realm/include/RLMSwiftSupport.h b/Pods/Realm/include/RLMSwiftSupport.h
new file mode 100644
index 0000000..89db57f
--- /dev/null
+++ b/Pods/Realm/include/RLMSwiftSupport.h
@@ -0,0 +1,26 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import <Foundation/Foundation.h>
+
+@interface RLMSwiftSupport : NSObject
+
++ (BOOL)isSwiftClassName:(NSString *)className;
++ (NSString *)demangleClassName:(NSString *)className;
+
+@end
diff --git a/Pods/Realm/include/RLMUpdateChecker.hpp b/Pods/Realm/include/RLMUpdateChecker.hpp
new file mode 100644
index 0000000..7f01ac7
--- /dev/null
+++ b/Pods/Realm/include/RLMUpdateChecker.hpp
@@ -0,0 +1,20 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+// Asynchronously check for updates to Realm if running on a simulator
+void RLMCheckForUpdates();
diff --git a/Pods/Realm/include/RLMUtil.hpp b/Pods/Realm/include/RLMUtil.hpp
new file mode 100644
index 0000000..6e397c1
--- /dev/null
+++ b/Pods/Realm/include/RLMUtil.hpp
@@ -0,0 +1,200 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import <Realm/RLMConstants.h>
+#import <Realm/RLMOptionalBase.h>
+#import <objc/runtime.h>
+
+#import <realm/array.hpp>
+#import <realm/binary_data.hpp>
+#import <realm/string_data.hpp>
+#import <realm/timestamp.hpp>
+#import <realm/util/file.hpp>
+
+namespace realm {
+    class Mixed;
+}
+
+@class RLMObjectSchema;
+@class RLMProperty;
+
+namespace realm {
+    class RealmFileException;
+}
+
+__attribute__((format(NSString, 1, 2)))
+NSException *RLMException(NSString *fmt, ...);
+NSException *RLMException(std::exception const& exception);
+
+NSError *RLMMakeError(RLMError code, std::exception const& exception);
+NSError *RLMMakeError(RLMError code, const realm::util::File::AccessError&);
+NSError *RLMMakeError(RLMError code, const realm::RealmFileException&);
+NSError *RLMMakeError(std::system_error const& exception);
+NSError *RLMMakeError(NSException *exception);
+
+void RLMSetErrorOrThrow(NSError *error, NSError **outError);
+
+// returns if the object can be inserted as the given type
+BOOL RLMIsObjectValidForProperty(id obj, RLMProperty *prop);
+
+// gets default values for the given schema (+defaultPropertyValues)
+// merges with native property defaults if Swift class
+NSDictionary *RLMDefaultValuesForObjectSchema(RLMObjectSchema *objectSchema);
+
+BOOL RLMIsDebuggerAttached();
+BOOL RLMIsRunningInPlayground();
+
+// C version of isKindOfClass
+static inline BOOL RLMIsKindOfClass(Class class1, Class class2) {
+    while (class1) {
+        if (class1 == class2) return YES;
+        class1 = class_getSuperclass(class1);
+    }
+    return NO;
+}
+
+// Returns whether the class is a descendent of RLMObjectBase
+BOOL RLMIsObjectOrSubclass(Class klass);
+
+// Returns whether the class is an indirect descendant of RLMObjectBase
+BOOL RLMIsObjectSubclass(Class klass);
+
+template<typename T>
+static inline T *RLMDynamicCast(__unsafe_unretained id obj) {
+    if ([obj isKindOfClass:[T class]]) {
+        return obj;
+    }
+    return nil;
+}
+
+template<typename T>
+static inline T RLMCoerceToNil(__unsafe_unretained T obj) {
+    if (static_cast<id>(obj) == NSNull.null) {
+        return nil;
+    }
+    else if (__unsafe_unretained auto optional = RLMDynamicCast<RLMOptionalBase>(obj)) {
+        return RLMCoerceToNil(optional.underlyingValue);
+    }
+    return obj;
+}
+
+// Translate an rlmtype to a string representation
+static inline NSString *RLMTypeToString(RLMPropertyType type) {
+    switch (type) {
+        case RLMPropertyTypeString:
+            return @"string";
+        case RLMPropertyTypeInt:
+            return @"int";
+        case RLMPropertyTypeBool:
+            return @"bool";
+        case RLMPropertyTypeDate:
+            return @"date";
+        case RLMPropertyTypeData:
+            return @"data";
+        case RLMPropertyTypeDouble:
+            return @"double";
+        case RLMPropertyTypeFloat:
+            return @"float";
+        case RLMPropertyTypeAny:
+            return @"any";
+        case RLMPropertyTypeObject:
+            return @"object";
+        case RLMPropertyTypeArray:
+            return @"array";
+        case RLMPropertyTypeLinkingObjects:
+            return @"linking objects";
+    }
+    return @"Unknown";
+}
+
+// String conversion utilities
+static inline NSString * RLMStringDataToNSString(realm::StringData stringData) {
+    static_assert(sizeof(NSUInteger) >= sizeof(size_t),
+                  "Need runtime overflow check for size_t to NSUInteger conversion");
+    if (stringData.is_null()) {
+        return nil;
+    }
+    else {
+        return [[NSString alloc] initWithBytes:stringData.data()
+                                        length:stringData.size()
+                                      encoding:NSUTF8StringEncoding];
+    }
+}
+
+static inline realm::StringData RLMStringDataWithNSString(__unsafe_unretained NSString *const string) {
+    static_assert(sizeof(size_t) >= sizeof(NSUInteger),
+                  "Need runtime overflow check for NSUInteger to size_t conversion");
+    return realm::StringData(string.UTF8String,
+                               [string lengthOfBytesUsingEncoding:NSUTF8StringEncoding]);
+}
+
+// Binary convertion utilities
+static inline NSData *RLMBinaryDataToNSData(realm::BinaryData binaryData) {
+    return binaryData ? [NSData dataWithBytes:binaryData.data() length:binaryData.size()] : nil;
+}
+
+static inline realm::BinaryData RLMBinaryDataForNSData(__unsafe_unretained NSData *const data) {
+    // this is necessary to ensure that the empty NSData isn't treated by core as the null realm::BinaryData
+    // because data.bytes == 0 when data.length == 0
+    // the casting bit ensures that we create a data with a non-null pointer
+    auto bytes = static_cast<const char *>(data.bytes) ?: static_cast<char *>((__bridge void *)data);
+    return realm::BinaryData(bytes, data.length);
+}
+
+// Date convertion utilities
+// These use the reference date and shift the seconds rather than just getting
+// the time interval since the epoch directly to avoid losing sub-second precision
+static inline NSDate *RLMTimestampToNSDate(realm::Timestamp ts) {
+    if (ts.is_null())
+        return nil;
+    auto timeInterval = ts.get_seconds() - NSTimeIntervalSince1970 + ts.get_nanoseconds() / 1'000'000'000.0;
+    return [NSDate dateWithTimeIntervalSinceReferenceDate:timeInterval];
+}
+
+static inline realm::Timestamp RLMTimestampForNSDate(__unsafe_unretained NSDate *const date) {
+    auto timeInterval = date.timeIntervalSinceReferenceDate;
+    if (isnan(timeInterval))
+        return {0, 0}; // Arbitrary choice
+
+    // Clamp dates that we can't represent as a Timestamp to the maximum value
+    if (timeInterval >= std::numeric_limits<int64_t>::max() - NSTimeIntervalSince1970)
+        return {std::numeric_limits<int64_t>::max(), 1'000'000'000 - 1};
+    if (timeInterval - NSTimeIntervalSince1970 < std::numeric_limits<int64_t>::min())
+        return {std::numeric_limits<int64_t>::min(), -1'000'000'000 + 1};
+
+    auto seconds = static_cast<int64_t>(timeInterval);
+    auto nanoseconds = static_cast<int32_t>((timeInterval - seconds) * 1'000'000'000.0);
+    seconds += static_cast<int64_t>(NSTimeIntervalSince1970);
+
+    // Seconds and nanoseconds have to have the same sign
+    if (nanoseconds < 0 && seconds > 0) {
+        nanoseconds += 1'000'000'000;
+        --seconds;
+    }
+    return {seconds, nanoseconds};
+}
+
+static inline NSUInteger RLMConvertNotFound(size_t index) {
+    return index == realm::not_found ? NSNotFound : index;
+}
+
+id RLMMixedToObjc(realm::Mixed const& value);
+
+// For unit testing purposes, allow an Objective-C class named FakeObject to also be used
+// as the base class of managed objects. This allows for testing invalid schemas.
+void RLMSetTreatFakeObjectAsRLMObject(BOOL flag);
diff --git a/Pods/Realm/include/Realm.h b/Pods/Realm/include/Realm.h
new file mode 100644
index 0000000..886f19e
--- /dev/null
+++ b/Pods/Realm/include/Realm.h
@@ -0,0 +1,30 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#import <Foundation/Foundation.h>
+
+#import <Realm/RLMArray.h>
+#import <Realm/RLMMigration.h>
+#import <Realm/RLMObject.h>
+#import <Realm/RLMObjectSchema.h>
+#import <Realm/RLMPlatform.h>
+#import <Realm/RLMProperty.h>
+#import <Realm/RLMRealm.h>
+#import <Realm/RLMRealmConfiguration.h>
+#import <Realm/RLMResults.h>
+#import <Realm/RLMSchema.h>
diff --git a/Pods/Realm/include/binding_context.hpp b/Pods/Realm/include/binding_context.hpp
new file mode 100644
index 0000000..d57ce54
--- /dev/null
+++ b/Pods/Realm/include/binding_context.hpp
@@ -0,0 +1,158 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2015 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#ifndef BINDING_CONTEXT_HPP
+#define BINDING_CONTEXT_HPP
+
+#include "index_set.hpp"
+
+#include <tuple>
+#include <vector>
+
+namespace realm {
+// BindingContext is the extension point for adding binding-specific behavior to
+// a SharedRealm. It can be used to store additonal data associated with the
+// Realm which is needed by the binding, and there are several methods which
+// can be overridden to receive notifications of state changes within the Realm.
+//
+// A simple implementation which lets the user register functions to be
+// called on refresh could look like the following:
+//
+// class BindingContextImplementation : public BindingContext {
+// public:
+//     // A token returned from add_notification that can be used to remove the
+//     // notification later
+//     struct token : private std::list<std::function<void ()>>::iterator {
+//         token(std::list<std::function<void ()>>::iterator it) : std::list<std::function<void ()>>::iterator(it) { }
+//         friend class DelegateImplementation;
+//     };
+//
+//     token add_notification(std::function<void ()> func)
+//     {
+//         m_registered_notifications.push_back(std::move(func));
+//         return token(std::prev(m_registered_notifications.end()));
+//     }
+//
+//     void remove_notification(token entry)
+//     {
+//         m_registered_notifications.erase(entry);
+//     }
+//
+//     // Override the did_change method to call each registered notification
+//     void did_change(std::vector<ObserverState> const&, std::vector<void*> const&) override
+//     {
+//         // Loop oddly so that unregistering a notification from within the
+//         // registered function works
+//         for (auto it = m_registered_notifications.begin(); it != m_registered_notifications.end(); ) {
+//             (*it++)();
+//         }
+//     }
+//
+// private:
+//     std::list<std::function<void ()>> m_registered_notifications;
+// };
+class BindingContext {
+public:
+    virtual ~BindingContext() = default;
+
+    // If the user adds a notification handler to the Realm, will it ever
+    // actually be called?
+    virtual bool can_deliver_notifications() const noexcept { return true; }
+
+    // Called by the Realm when a write transaction is committed to the file by
+    // a different Realm instance (possibly in a different process)
+    virtual void changes_available() { }
+
+    struct ObserverState;
+
+    // Override this function if you want to recieve detailed information about
+    // external changes to a specific set of objects.
+    // This is called before each operation which may advance the read
+    // transaction to include
+    // ObserverStates for each row for which detailed change information is
+    // desired.
+    virtual std::vector<ObserverState> get_observed_rows() { return {}; }
+
+    // Called immediately before the read transaction is advanced if detailed
+    // change information was requested (by returning a non-empty array from
+    // get_observed_rows()).
+    // The observers vector is the vector returned by get_observed_row(),
+    // updated with change information. The invalidated vector is a list of the
+    // `info` fields of observed rows which will be deleted.
+    virtual void will_change(std::vector<ObserverState> const& observers,
+                             std::vector<void*> const& invalidated);
+
+    // Called immediately after the read transaction version is advanced. Unlike
+    // will_change(), this is called even if detailed change information was not
+    // requested or if the Realm is not actually in a read transactuib, although
+    // both vectors will be empty in that case.
+    virtual void did_change(std::vector<ObserverState> const& observers,
+                            std::vector<void*> const& invalidated);
+
+    // Change information for a single field of a row
+    struct ColumnInfo {
+        // Did this column change?
+        bool changed = false;
+        // For LinkList columns, what kind of change occurred?
+        // Always None for other column types
+        enum class Kind {
+            None,   // No change
+            Set,    // The entries at `indices` were assigned to
+            Insert, // New values were inserted at each of the indices given
+            Remove, // Values were removed at each of the indices given
+            SetAll  // The entire LinkList has been replaced with a new set of values
+        } kind = Kind::None;
+        // The indices where things happened for Set, Insert and Remove
+        // Not used for None and SetAll
+        IndexSet indices;
+    };
+
+    // Information about an observed row in a table
+    //
+    // Each object which needs detailed change information should have an
+    // ObserverState entry in the vector returned from get_observed_rows(), with
+    // the initial table and row indexes set (and optionally the info field).
+    // The Realm parses the transaction log, and populates the `changes` vector
+    // in each ObserverState with information about what changes were made.
+    struct ObserverState {
+        // Initial table and row which is observed
+        // May be updated by row insertions and removals
+        size_t table_ndx;
+        size_t row_ndx;
+
+        // Opaque userdata for the delegate's use
+        void* info;
+
+        // Populated with information about which columns were changed
+        // May be shorter than the actual number of columns if the later columns
+        // are not modified
+        std::vector<ColumnInfo> changes;
+
+        // Simple lexographic ordering
+        friend bool operator<(ObserverState const& lft, ObserverState const& rgt)
+        {
+            return std::tie(lft.table_ndx, lft.row_ndx) < std::tie(rgt.table_ndx, rgt.row_ndx);
+        }
+    };
+};
+
+inline void BindingContext::will_change(std::vector<ObserverState> const&, std::vector<void*> const&) { }
+inline void BindingContext::did_change(std::vector<ObserverState> const&, std::vector<void*> const&) { }
+} // namespace realm
+
+#endif /* BINDING_CONTEXT_HPP */
diff --git a/Pods/Realm/include/collection_notifications.hpp b/Pods/Realm/include/collection_notifications.hpp
new file mode 100644
index 0000000..ed75c31
--- /dev/null
+++ b/Pods/Realm/include/collection_notifications.hpp
@@ -0,0 +1,71 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2016 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#ifndef REALM_COLLECTION_NOTIFICATIONS_HPP
+#define REALM_COLLECTION_NOTIFICATIONS_HPP
+
+#include "index_set.hpp"
+#include "util/atomic_shared_ptr.hpp"
+
+#include <exception>
+#include <functional>
+#include <memory>
+#include <vector>
+
+namespace realm {
+namespace _impl {
+    class CollectionNotifier;
+}
+
+// A token which keeps an asynchronous query alive
+struct NotificationToken {
+    NotificationToken() = default;
+    NotificationToken(std::shared_ptr<_impl::CollectionNotifier> notifier, size_t token);
+    ~NotificationToken();
+
+    NotificationToken(NotificationToken&&);
+    NotificationToken& operator=(NotificationToken&&);
+
+    NotificationToken(NotificationToken const&) = delete;
+    NotificationToken& operator=(NotificationToken const&) = delete;
+
+private:
+    util::AtomicSharedPtr<_impl::CollectionNotifier> m_notifier;
+    size_t m_token;
+};
+
+struct CollectionChangeSet {
+    struct Move {
+        size_t from;
+        size_t to;
+
+        bool operator==(Move m) const { return from == m.from && to == m.to; }
+    };
+
+    IndexSet deletions;
+    IndexSet insertions;
+    IndexSet modifications;
+    std::vector<Move> moves;
+
+    bool empty() const { return deletions.empty() && insertions.empty() && modifications.empty() && moves.empty(); }
+};
+
+using CollectionChangeCallback = std::function<void (CollectionChangeSet, std::exception_ptr)>;
+} // namespace realm
+
+#endif // REALM_COLLECTION_NOTIFICATIONS_HPP
diff --git a/Pods/Realm/include/core/realm.hpp b/Pods/Realm/include/core/realm.hpp
new file mode 100644
index 0000000..f635be4
--- /dev/null
+++ b/Pods/Realm/include/core/realm.hpp
@@ -0,0 +1,28 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_HPP
+#define REALM_HPP
+
+#include <realm/group_shared.hpp>
+#include <realm/table_macros.hpp>
+#include <realm/descriptor.hpp>
+#include <realm/link_view.hpp>
+
+#endif // REALM_HPP
diff --git a/Pods/Realm/include/core/realm/alloc.hpp b/Pods/Realm/include/core/realm/alloc.hpp
new file mode 100644
index 0000000..c1f96af
--- /dev/null
+++ b/Pods/Realm/include/core/realm/alloc.hpp
@@ -0,0 +1,439 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_ALLOC_HPP
+#define REALM_ALLOC_HPP
+
+#include <stdint.h>
+#include <cstddef>
+
+#include <realm/util/features.h>
+#include <realm/util/terminate.hpp>
+#include <realm/util/assert.hpp>
+#include <realm/util/safe_int_ops.hpp>
+
+namespace realm {
+
+class Allocator;
+
+class Replication;
+
+using ref_type = size_t;
+
+int_fast64_t from_ref(ref_type) noexcept;
+ref_type to_ref(int_fast64_t) noexcept;
+
+class MemRef {
+public:
+
+    MemRef() noexcept;
+    ~MemRef() noexcept;
+
+    MemRef(char* addr, ref_type ref, Allocator& alloc) noexcept;
+    MemRef(ref_type ref, Allocator& alloc) noexcept;
+
+    char* get_addr();
+    ref_type get_ref();
+    void set_ref(ref_type ref);
+    void set_addr(char* addr);
+
+private:
+    char* m_addr;
+    ref_type m_ref;
+#if REALM_ENABLE_MEMDEBUG
+    // Allocator that created m_ref. Used to verify that the ref is valid whenever you call 
+    // get_ref()/get_addr and that it e.g. has not been free'ed
+    const Allocator* m_alloc = nullptr;
+#endif
+};
+
+
+/// The common interface for Realm allocators.
+///
+/// A Realm allocator must associate a 'ref' to each allocated
+/// object and be able to efficiently map any 'ref' to the
+/// corresponding memory address. The 'ref' is an integer and it must
+/// always be divisible by 8. Also, a value of zero is used to
+/// indicate a null-reference, and must therefore never be returned by
+/// Allocator::alloc().
+///
+/// The purpose of the 'refs' is to decouple the memory reference from
+/// the actual address and thereby allowing objects to be relocated in
+/// memory without having to modify stored references.
+///
+/// \sa SlabAlloc
+class Allocator {
+public:
+	static constexpr int CURRENT_FILE_FORMAT_VERSION = 5;
+
+    /// The specified size must be divisible by 8, and must not be
+    /// zero.
+    ///
+    /// \throw std::bad_alloc If insufficient memory was available.
+    MemRef alloc(size_t size);
+
+    /// Calls do_realloc().
+    ///
+    /// Note: The underscore has been added because the name `realloc`
+    /// would conflict with a macro on the Windows platform.
+    MemRef realloc_(ref_type, const char* addr, size_t old_size,
+                    size_t new_size);
+
+    /// Calls do_free().
+    ///
+    /// Note: The underscore has been added because the name `free
+    /// would conflict with a macro on the Windows platform.
+    void free_(ref_type, const char* addr) noexcept;
+
+    /// Shorthand for free_(mem.get_ref(), mem.get_addr()).
+    void free_(MemRef mem) noexcept;
+
+    /// Calls do_translate().
+    char* translate(ref_type ref) const noexcept;
+
+    /// Returns true if, and only if the object at the specified 'ref'
+    /// is in the immutable part of the memory managed by this
+    /// allocator. The method by which some objects become part of the
+    /// immuatble part is entirely up to the class that implements
+    /// this interface.
+    bool is_read_only(ref_type) const noexcept;
+
+    /// Returns a simple allocator that can be used with free-standing
+    /// Realm objects (such as a free-standing table). A
+    /// free-standing object is one that is not part of a Group, and
+    /// therefore, is not part of an actual database.
+    static Allocator& get_default() noexcept;
+
+    virtual ~Allocator() noexcept;
+
+#ifdef REALM_DEBUG
+    virtual void verify() const = 0;
+
+    /// Terminate the program precisely when the specified 'ref' is
+    /// freed (or reallocated). You can use this to detect whether the
+    /// ref is freed (or reallocated), and even to get a stacktrace at
+    /// the point where it happens. Call watch(0) to stop watching
+    /// that ref.
+    void watch(ref_type);
+#endif
+
+    Replication* get_replication() noexcept;
+
+    /// \brief The version of the format of the the node structure (in file or
+    /// in memory) in use by Realm objects associated with this allocator.
+    ///
+    /// Every allocator contains a file format version field, which is returned
+    /// by this function. In some cases (as mentioned below) the file format can
+    /// change.
+    ///
+    /// A value of zero means the the file format is not yet decided. This is
+    /// only possible for empty Realms where top-ref is zero.
+    ///
+    /// For the default allocator (get_default()), the file format version field
+    /// can never change, is never zero, and is set to whatever
+    /// Group::get_target_file_format_version_for_session() would return if the
+    /// original file format version was undecided and the request history type
+    /// was Replication::hist_None.
+    ///
+    /// For the slab allocator (AllocSlab), the file format version field is set
+    /// to the file format version specified by the attached file (or attached
+    /// memory buffer) at the time of attachment. If no file (or buffer) is
+    /// currently attached, the returned value has no meaning. If the Realm file
+    /// format is later upgraded, the file form,at version filed must be updated
+    /// to reflect that fact.
+    ///
+    /// In shared mode (when a Realm file is opened via a SharedGroup instance)
+    /// it can happen that the file format is upgraded asyncronously (via
+    /// another SharedGroup instance), and in that case the file format version
+    /// field of the allocator can get out of date, but only for a short
+    /// while. It is always garanteed to be, and remain up to date after the
+    /// opening process completes (when SharedGroup::do_open() returns).
+    ///
+    /// An empty Realm file (one whose top-ref is zero) may specify a file
+    /// format version of zero to indicate that the format is not yet
+    /// decided. In that case, this function will return zero immediately after
+    /// AllocSlab::attach_file() returns. It shall be guaranteed, however, that
+    /// the zero is changed to a proper file format version before the opening
+    /// process completes (Group::open() or SharedGroup::open()). It is the duty
+    /// of the caller of AllocSlab::attach_file() to ensure this.
+    ///
+    /// File format versions:
+    ///
+    ///   1 Initial file format version
+    ///
+    ///   2 FIXME: Does anybody remember what happened here?
+    ///
+    ///   3 Supporting null on string columns broke the file format in following
+    ///     way: Index appends an 'X' character to all strings except the null
+    ///     string, to be able to distinguish between null and empty
+    ///     string. Bumped to 3 because of null support of String columns and
+    ///     because of new format of index.
+    ///
+    ///   4 Introduction of optional in-Realm history of changes (additional
+    ///     entries in Group::m_top). Since this change is not forward
+    ///     compatible, the file format version had to be bumped. This change is
+    ///     implemented in a way that achieves backwards compatibility with
+    ///     version 3 (and in turn with version 2).
+    ///
+    ///   5 Introduced the new Timestamp column type that replaces DateTime.
+    ///     When opening an older database file, all DateTime columns will be
+    ///     automatically upgraded Timestamp columns.
+    ///
+    /// IMPORTANT: When introducing a new file format version, be sure to review
+    /// the file validity checks in AllocSlab::validate_buffer(), the file
+    /// format selection loginc in
+    /// Group::get_target_file_format_version_for_session(), and the file format
+    /// upgrade logic in Group::upgrade_file_format().
+    int get_file_format_version() const noexcept;
+
+protected:
+    size_t m_baseline = 0; // Separation line between immutable and mutable refs.
+
+    Replication* m_replication;
+
+    /// See get_file_format_version().
+    int m_file_format_version = 0;
+
+#ifdef REALM_DEBUG
+    ref_type m_watch;
+#endif
+
+    /// The specified size must be divisible by 8, and must not be
+    /// zero.
+    ///
+    /// \throw std::bad_alloc If insufficient memory was available.
+    virtual MemRef do_alloc(size_t size) = 0;
+
+    /// The specified size must be divisible by 8, and must not be
+    /// zero.
+    ///
+    /// The default version of this function simply allocates a new
+    /// chunk of memory, copies over the old contents, and then frees
+    /// the old chunk.
+    ///
+    /// \throw std::bad_alloc If insufficient memory was available.
+    virtual MemRef do_realloc(ref_type, const char* addr, size_t old_size,
+                              size_t new_size) = 0;
+
+    /// Release the specified chunk of memory.
+    virtual void do_free(ref_type, const char* addr) noexcept = 0;
+
+    /// Map the specified \a ref to the corresponding memory
+    /// address. Note that if is_read_only(ref) returns true, then the
+    /// referenced object is to be considered immutable, and it is
+    /// then entirely the responsibility of the caller that the memory
+    /// is not modified by way of the returned memory pointer.
+    virtual char* do_translate(ref_type ref) const noexcept = 0;
+
+    Allocator() noexcept;
+
+    // FIXME: This really doesn't belong in an allocator, but it is the best
+    // place for now, because every table has a pointer leading here. It would
+    // be more obvious to place it in Group, but that would add a runtime overhead,
+    // and access is time critical.
+    uint_fast64_t m_table_versioning_counter;
+
+    /// Bump the global version counter. This method should be called when
+    /// version bumping is initiated. Then following calls to should_propagate_version()
+    /// can be used to prune the version bumping.
+    uint_fast64_t bump_global_version() noexcept;
+
+    /// Determine if the "local_version" is out of sync, so that it should
+    /// be updated. In that case: also update it. Called from Table::bump_version
+    /// to control propagation of version updates on tables within the group.
+    bool should_propagate_version(uint_fast64_t& local_version) noexcept;
+
+    friend class Table;
+    friend class Group;
+};
+
+inline uint_fast64_t Allocator::bump_global_version() noexcept
+{
+    ++m_table_versioning_counter;
+    return m_table_versioning_counter;
+}
+
+
+inline bool Allocator::should_propagate_version(uint_fast64_t& local_version) noexcept
+{
+    if (local_version != m_table_versioning_counter) {
+        local_version = m_table_versioning_counter;
+        return true;
+    }
+    else {
+        return false;
+    }
+}
+
+
+
+// Implementation:
+
+inline int_fast64_t from_ref(ref_type v) noexcept
+{
+    // Check that v is divisible by 8 (64-bit aligned).
+    REALM_ASSERT_DEBUG(v % 8 == 0);
+    return util::from_twos_compl<int_fast64_t>(v);
+}
+
+inline ref_type to_ref(int_fast64_t v) noexcept
+{
+    REALM_ASSERT_DEBUG(!util::int_cast_has_overflow<ref_type>(v));
+    // Check that v is divisible by 8 (64-bit aligned).
+    REALM_ASSERT_DEBUG(v % 8 == 0);
+    return ref_type(v);
+}
+
+inline MemRef::MemRef() noexcept:
+    m_addr(nullptr),
+    m_ref(0)
+{
+}
+
+inline MemRef::~MemRef() noexcept
+{
+}
+
+inline MemRef::MemRef(char* addr, ref_type ref, Allocator& alloc) noexcept:
+    m_addr(addr),
+    m_ref(ref)
+{
+    static_cast<void>(alloc);
+#if REALM_ENABLE_MEMDEBUG
+    m_alloc = &alloc;
+#endif
+}
+
+inline MemRef::MemRef(ref_type ref, Allocator& alloc) noexcept:
+    m_addr(alloc.translate(ref)),
+    m_ref(ref)
+{
+    static_cast<void>(alloc);
+#if REALM_ENABLE_MEMDEBUG
+    m_alloc = &alloc;
+#endif
+}
+
+inline char* MemRef::get_addr()
+{
+#if REALM_ENABLE_MEMDEBUG
+    // Asserts if the ref has been freed
+    m_alloc->translate(m_ref);
+#endif
+    return m_addr;
+}
+
+inline ref_type MemRef::get_ref()
+{
+#if REALM_ENABLE_MEMDEBUG
+    // Asserts if the ref has been freed
+    m_alloc->translate(m_ref);
+#endif
+    return m_ref;
+}
+
+inline void MemRef::set_ref(ref_type ref)
+{
+#if REALM_ENABLE_MEMDEBUG
+    // Asserts if the ref has been freed
+    m_alloc->translate(ref);
+#endif
+    m_ref = ref;
+}
+
+inline void MemRef::set_addr(char* addr)
+{
+    m_addr = addr;
+}
+
+inline MemRef Allocator::alloc(size_t size)
+{
+    return do_alloc(size);
+}
+
+inline MemRef Allocator::realloc_(ref_type ref, const char* addr, size_t old_size,
+                                  size_t new_size)
+{
+#ifdef REALM_DEBUG
+    if (ref == m_watch)
+        REALM_TERMINATE("Allocator watch: Ref was reallocated");
+#endif
+    return do_realloc(ref, addr, old_size, new_size);
+}
+
+inline void Allocator::free_(ref_type ref, const char* addr) noexcept
+{
+#ifdef REALM_DEBUG
+    if (ref == m_watch)
+        REALM_TERMINATE("Allocator watch: Ref was freed");
+#endif
+    return do_free(ref, addr);
+}
+
+inline void Allocator::free_(MemRef mem) noexcept
+{
+    free_(mem.get_ref(), mem.get_addr());
+}
+
+inline char* Allocator::translate(ref_type ref) const noexcept
+{
+    return do_translate(ref);
+}
+
+inline bool Allocator::is_read_only(ref_type ref) const noexcept
+{
+    REALM_ASSERT_DEBUG(ref != 0);
+    REALM_ASSERT_DEBUG(m_baseline != 0); // Attached SlabAlloc
+    return ref < m_baseline;
+}
+
+inline Allocator::Allocator() noexcept:
+    m_replication(nullptr)
+{
+#ifdef REALM_DEBUG
+    m_watch = 0;
+#endif
+    m_table_versioning_counter = 0;
+}
+
+inline Allocator::~Allocator() noexcept
+{
+}
+
+inline Replication* Allocator::get_replication() noexcept
+{
+    return m_replication;
+}
+
+#ifdef REALM_DEBUG
+inline void Allocator::watch(ref_type ref)
+{
+    m_watch = ref;
+}
+#endif
+
+inline int Allocator::get_file_format_version() const noexcept
+{
+    return m_file_format_version;
+}
+
+
+} // namespace realm
+
+#endif // REALM_ALLOC_HPP
diff --git a/Pods/Realm/include/core/realm/alloc_slab.hpp b/Pods/Realm/include/core/realm/alloc_slab.hpp
new file mode 100644
index 0000000..2eda804
--- /dev/null
+++ b/Pods/Realm/include/core/realm/alloc_slab.hpp
@@ -0,0 +1,569 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_ALLOC_SLAB_HPP
+#define REALM_ALLOC_SLAB_HPP
+
+#include <stdint.h> // unint8_t etc
+#include <vector>
+#include <string>
+#include <atomic>
+
+#include <realm/util/features.h>
+#include <realm/util/file.hpp>
+#include <realm/alloc.hpp>
+#include <realm/disable_sync_to_disk.hpp>
+
+namespace realm {
+
+// Pre-declarations
+class Group;
+class GroupWriter;
+
+
+/// Thrown by Group and SharedGroup constructors if the specified file
+/// (or memory buffer) does not appear to contain a valid Realm
+/// database.
+struct InvalidDatabase;
+
+
+/// The allocator that is used to manage the memory of a Realm
+/// group, i.e., a Realm database.
+///
+/// Optionally, it can be attached to an pre-existing database (file
+/// or memory buffer) which then becomes an immuatble part of the
+/// managed memory.
+///
+/// To attach a slab allocator to a pre-existing database, call
+/// attach_file() or attach_buffer(). To create a new database
+/// in-memory, call attach_empty().
+///
+/// For efficiency, this allocator manages its mutable memory as a set
+/// of slabs.
+class SlabAlloc: public Allocator {
+public:
+    ~SlabAlloc() noexcept override;
+    SlabAlloc();
+
+    struct Config {
+        bool is_shared = false;
+        bool read_only = false;
+        bool no_create = false;
+        bool skip_validate = false;
+        bool session_initiator = false;
+        bool clear_file = false;
+        const char* encryption_key = nullptr;
+    };
+
+    struct Retry {};
+
+    /// \brief Attach this allocator to the specified file.
+    ///
+    /// It is an error if this function is called at a time where the specified
+    /// Realm file (file system inode) is modified asynchronously.
+    ///
+    /// In non-shared mode (when this function is called on behalf of a
+    /// free-standing Group instance), it is the responsibility of the
+    /// application to ensure that the Realm file is not modified concurrently
+    /// from any other thread or process.
+    ///
+    /// In shared mode (when this function is called on behalf of a SharedGroup
+    /// instance), the caller (SharedGroup::do_open()) must take steps to ensure
+    /// cross-process mutual exclusion.
+    ///
+    /// If the attached file contains an empty Realm (one whose top-ref is
+    /// zero), the file format version may remain undecided upon return from
+    /// this function. The file format is undecided if, and only if
+    /// get_file_format_version() returns zero. The caller is required to check
+    /// for this case, and decide on a file format version. This must happen
+    /// before the Realm opening process completes, and the decided file format
+    /// must be set in the allocator by calling set_file_format_version().
+    ///
+    /// Except for \a path, the parameters are passed in through a
+    /// configuration object.
+    ///
+    /// \param is_shared Must be true if, and only if we are called on
+    /// behalf of SharedGroup.
+    ///
+    /// \param read_only Open the file in read-only mode. This implies
+    /// \a no_create.
+    ///
+    /// \param no_create Fail if the file does not already exist.
+    ///
+    /// \param bool skip_validate Skip validation of file header. In a
+    /// set of overlapping SharedGroups, only the first one (the one
+    /// that creates/initlializes the coordination file) may validate
+    /// the header, otherwise it will result in a race condition.
+    ///
+    /// \param encryption_key 32-byte key to use to encrypt and decrypt
+    /// the backing storage, or nullptr to disable encryption.
+    ///
+    /// \param session_initiator if set, the caller is the session initiator and
+    /// guarantees exclusive access to the file. If attaching in read/write mode,
+    /// the file is modified: files on streaming form is changed to non-streaming
+    /// form, and if needed the file size is adjusted to match mmap boundaries.
+    /// Must be set to false if is_shared is false.
+    ///
+    /// \param clear_file Always initialize the file as if it was a newly
+    /// created file and ignore any pre-existing contents. Requires that
+    /// session_initiator be true as well.
+    ///
+    /// \return The `ref` of the root node, or zero if there is none.
+    ///
+    /// Please note that attach_file can fail to attach to a file due to a collision
+    /// with a writer extending the file. This can only happen if the caller is *not*
+    /// the session initiator. When this happens, attach_file() throws SlabAlloc::Retry,
+    /// and the caller must retry the call. The caller should check if it has become
+    /// the session initiator before retrying. This can happen if the conflicting thread
+    /// (or process) terminates or crashes before the next retry.
+    ///
+    /// \throw util::File::AccessError
+    /// \throw SlabAlloc::Retry
+    ref_type attach_file(const std::string& path, Config& cfg);
+
+    /// Get the attached file. Only valid when called on an allocator with 
+    /// an attached file.
+    util::File& get_file();
+
+    /// Attach this allocator to the specified memory buffer.
+    ///
+    /// If the attached buffer contains an empty Realm (one whose top-ref is
+    /// zero), the file format version may remain undecided upon return from
+    /// this function. The file format is undecided if, and only if
+    /// get_file_format_version() returns zero. The caller is required to check
+    /// for this case, and decide on a file format version. This must happen
+    /// before the Realm opening process completes, and the decided file format
+    /// must be set in the allocator by calling set_file_format_version().
+    ///
+    /// It is an error to call this function on an attached
+    /// allocator. Doing so will result in undefined behavor.
+    ///
+    /// \return The `ref` of the root node, or zero if there is none.
+    ///
+    /// \sa own_buffer()
+    ///
+    /// \throw InvalidDatabase
+    ref_type attach_buffer(char* data, size_t size);
+
+    /// Reads file format from file header. Must be called from within a write
+    /// transaction.
+    int get_committed_file_format_version() const noexcept;
+
+    /// Attach this allocator to an empty buffer.
+    ///
+    /// Upon return from this function, the file format is undecided
+    /// (get_file_format_version() returns zero). The caller is required to
+    /// decide on a file format version. This must happen before the Realm
+    /// opening process completes, and the decided file format must be set in
+    /// the allocator by calling set_file_format_version().
+    ///
+    /// It is an error to call this function on an attached
+    /// allocator. Doing so will result in undefined behavor.
+    void attach_empty();
+
+    /// Detach from a previously attached file or buffer.
+    ///
+    /// This function does not reset free space tracking. To
+    /// completely reset the allocator, you must also call
+    /// reset_free_space_tracking().
+    ///
+    /// This function has no effect if the allocator is already in the
+    /// detached state (idempotency).
+    void detach() noexcept;
+
+    class DetachGuard;
+
+    /// If a memory buffer has been attached using attach_buffer(),
+    /// mark it as owned by this slab allocator. Behaviour is
+    /// undefined if this function is called on a detached allocator,
+    /// one that is not attached using attach_buffer(), or one for
+    /// which this function has already been called during the latest
+    /// attachment.
+    void own_buffer() noexcept;
+
+    /// Returns true if, and only if this allocator is currently
+    /// in the attached state.
+    bool is_attached() const noexcept;
+
+    /// Returns true if, and only if this allocator is currently in
+    /// the attached state and attachment was not established using
+    /// attach_empty().
+    bool nonempty_attachment() const noexcept;
+
+    /// Reserve disk space now to avoid allocation errors at a later
+    /// point in time, and to minimize on-disk fragmentation. In some
+    /// cases, less fragmentation translates into improved
+    /// performance. On flash or SSD-drives this is likely a waste.
+    ///
+    /// Note: File::prealloc() may misbehave under race conditions (see
+    /// documentation of File::prealloc()). For that reason, to avoid race
+    /// conditions, when this allocator is used in a transactional mode, this
+    /// function may be called only when the caller has exclusive write
+    /// access. In non-transactional mode it is the responsibility of the user
+    /// to ensure non-concurrent file mutation.
+    ///
+    /// This function will call File::sync().
+    ///
+    /// It is an error to call this function on an allocator that is not
+    /// attached to a file. Doing so will result in undefined behavior.
+    void resize_file(size_t new_file_size);
+
+    /// Reserve disk space now to avoid allocation errors at a later point in
+    /// time, and to minimize on-disk fragmentation. In some cases, less
+    /// fragmentation translates into improved performance. On SSD-drives
+    /// preallocation is likely a waste.
+    ///
+    /// When supported by the system, a call to this function will make the
+    /// database file at least as big as the specified size, and cause space on
+    /// the target device to be allocated (note that on many systems on-disk
+    /// allocation is done lazily by default). If the file is already bigger
+    /// than the specified size, the size will be unchanged, and on-disk
+    /// allocation will occur only for the initial section that corresponds to
+    /// the specified size. On systems that do not support preallocation, this
+    /// function has no effect. To know whether preallocation is supported by
+    /// Realm on your platform, call util::File::is_prealloc_supported().
+    ///
+    /// This function will call File::sync() if it changes the size of the file.
+    ///
+    /// It is an error to call this function on an allocator that is not
+    /// attached to a file. Doing so will result in undefined behavior.
+    void reserve_disk_space(size_t size_in_bytes);
+
+    /// Get the size of the attached database file or buffer in number
+    /// of bytes. This size is not affected by new allocations. After
+    /// attachment, it can only be modified by a call to remap().
+    ///
+    /// It is an error to call this function on a detached allocator,
+    /// or one that was attached using attach_empty(). Doing so will
+    /// result in undefined behavior.
+    size_t get_baseline() const noexcept;
+
+    /// Get the total amount of managed memory. This is the baseline plus the
+    /// sum of the sizes of the allocated slabs. It includes any free space.
+    ///
+    /// It is an error to call this function on a detached
+    /// allocator. Doing so will result in undefined behavior.
+    size_t get_total_size() const noexcept;
+
+    /// Mark all mutable memory (ref-space outside the attached file) as free
+    /// space.
+    void reset_free_space_tracking();
+
+    /// Remap the attached file such that a prefix of the specified
+    /// size becomes available in memory. If sucessfull,
+    /// get_baseline() will return the specified new file size.
+    ///
+    /// It is an error to call this function on a detached allocator,
+    /// or one that was not attached using attach_file(). Doing so
+    /// will result in undefined behavior.
+    ///
+    /// The file_size argument must be aligned to a *section* boundary:
+    /// The database file is logically split into sections, each section
+    /// guaranteed to be mapped as a contiguous address range. The allocation
+    /// of memory in the file must ensure that no allocation crosses the
+    /// boundary between two sections.
+    void remap(size_t file_size);
+
+    /// Returns true initially, and after a call to reset_free_space_tracking()
+    /// up until the point of the first call to SlabAlloc::alloc(). Note that a
+    /// call to SlabAlloc::alloc() corresponds to a mutation event.
+    bool is_free_space_clean() const noexcept;
+
+    /// \brief Update the file format version field of the allocator.
+    ///
+    /// This must be done during the opening of the Realm if the stored file
+    /// format version is zero (empty Realm), or after the file format is
+    /// upgraded.
+    ///
+    /// Note that this does not modify the attached file, only the "cached"
+    /// value subsequenty returned by get_file_format_version().
+    ///
+    /// \sa get_file_format_version()
+    void set_file_format_version(int) noexcept;
+
+#ifdef REALM_DEBUG
+    void enable_debug(bool enable) { m_debug_out = enable; }
+    void verify() const override;
+    bool is_all_free() const;
+    void print() const;
+#endif
+    struct MappedFile;
+
+protected:
+    MemRef do_alloc(size_t size) override;
+    MemRef do_realloc(ref_type, const char*, size_t old_size,
+                    size_t new_size) override;
+    // FIXME: It would be very nice if we could detect an invalid free operation in debug mode
+    void do_free(ref_type, const char*) noexcept override;
+    char* do_translate(ref_type) const noexcept override;
+    void invalidate_cache() noexcept;
+
+private:
+    enum AttachMode {
+        attach_None,        // Nothing is attached
+        attach_OwnedBuffer, // We own the buffer (m_data = nullptr for empty buffer)
+        attach_UsersBuffer, // We do not own the buffer
+        attach_SharedFile,  // On behalf of SharedGroup
+        attach_UnsharedFile // Not on behalf of SharedGroup
+    };
+
+    // A slab is a dynamically allocated contiguous chunk of memory used to
+    // extend the amount of space available for database node
+    // storage. Inter-node references are represented as file offsets
+    // (a.k.a. "refs"), and each slab creates an apparently seamless extension
+    // of this file offset addressable space. Slabes are stored as rows in the
+    // Slabs table in order of ascending file offsets.
+    struct Slab {
+        ref_type ref_end;
+        char* addr;
+    };
+    struct Chunk {
+        ref_type ref;
+        size_t size;
+    };
+
+    // Values of each used bit in m_flags
+    enum {
+        flags_SelectBit = 1
+    };
+
+    // 24 bytes
+    struct Header {
+        uint64_t m_top_ref[2]; // 2 * 8 bytes
+        // Info-block 8-bytes
+        uint8_t m_mnemonic[4]; // "T-DB"
+        uint8_t m_file_format[2]; // See `library_file_format`
+        uint8_t m_reserved;
+        // bit 0 of m_flags is used to select between the two top refs.
+        uint8_t m_flags;
+    };
+
+    // 16 bytes
+    struct StreamingFooter {
+        uint64_t m_top_ref;
+        uint64_t m_magic_cookie;
+    };
+
+    static_assert(sizeof (Header) == 24, "Bad header size");
+    static_assert(sizeof (StreamingFooter) == 16, "Bad footer size");
+
+    static const Header empty_file_header;
+    static void init_streaming_header(Header*, int file_format_version);
+
+    static const uint_fast64_t footer_magic_cookie = 0x3034125237E526C8ULL;
+
+    // The mappings are shared, if they are from a file
+    std::shared_ptr<MappedFile> m_file_mappings;
+
+    // We are caching local copies of all the additional mappings to allow
+    // for lock-free lookup during ref->address translation (we do not need
+    // to cache the first mapping, because it is immutable) (well, all the
+    // mappings are immutable, but the array holding them is not - it may
+    // have to be relocated)
+    std::unique_ptr<std::shared_ptr<const util::File::Map<char>>[]> m_local_mappings;
+    size_t m_num_local_mappings = 0;
+
+    char* m_data = nullptr;
+    size_t m_initial_chunk_size = 0;
+    size_t m_initial_section_size = 0;
+    int m_section_shifts = 0;
+    std::unique_ptr<size_t[]> m_section_bases;
+    size_t m_num_section_bases = 0;
+    AttachMode m_attach_mode = attach_None;
+    bool m_file_on_streaming_form = false;
+    enum FeeeSpaceState {
+        free_space_Clean,
+        free_space_Dirty,
+        free_space_Invalid
+    };
+
+    /// When set to free_space_Invalid, the free lists are no longer
+    /// up-to-date. This happens if do_free() or
+    /// reset_free_space_tracking() fails, presumably due to
+    /// std::bad_alloc being thrown during updating of the free space
+    /// list. In this this case, alloc(), realloc_(), and
+    /// get_free_read_only() must throw. This member is deliberately
+    /// placed here (after m_attach_mode) in the hope that it leads to
+    /// less padding between members due to alignment requirements.
+    FeeeSpaceState m_free_space_state = free_space_Clean;
+
+    typedef std::vector<Slab> slabs;
+    typedef std::vector<Chunk> chunks;
+    slabs m_slabs;
+    chunks m_free_space;
+    chunks m_free_read_only;
+
+#ifdef REALM_DEBUG
+    bool m_debug_out = false;
+#endif
+    struct hash_entry {
+        ref_type ref = 0;
+        char* addr = nullptr;
+        size_t version = 0;
+    };
+    mutable hash_entry cache[256];
+    mutable size_t version = 1;
+
+    /// Throws if free-lists are no longer valid.
+    const chunks& get_free_read_only() const;
+
+    /// Throws InvalidDatabase if the file is not a Realm file, if the file is
+    /// corrupted, or if the specified encryption key is incorrect. This
+    /// function will not detect all forms of corruption, though.
+    void validate_buffer(const char* data, size_t len, const std::string& path, bool is_shared);
+
+    /// Read the top_ref from the given buffer and set m_file_on_streaming_form
+    /// if the buffer contains a file in streaming form
+    ref_type get_top_ref(const char* data, size_t len);
+
+    class ChunkRefEq;
+    class ChunkRefEndEq;
+    class SlabRefEndEq;
+    static bool ref_less_than_slab_ref_end(ref_type, const Slab&) noexcept;
+
+    Replication* get_replication() const noexcept { return m_replication; }
+    void set_replication(Replication* r) noexcept { m_replication = r; }
+
+    /// Returns the first section boundary *above* the given position.
+    size_t get_upper_section_boundary(size_t start_pos) const noexcept;
+
+    /// Returns the first section boundary *at or below* the given position.
+    size_t get_lower_section_boundary(size_t start_pos) const noexcept;
+
+    /// Returns true if the given position is at a section boundary
+    bool matches_section_boundary(size_t pos) const noexcept;
+
+    /// Returns the index of the section holding a given address.
+    /// The section index is determined solely by the minimal section size,
+    /// and does not necessarily reflect the mapping. A mapping may
+    /// cover multiple sections - the initial mapping often does.
+    size_t get_section_index(size_t pos) const noexcept;
+
+    /// Reverse: get the base offset of a section at a given index. Since the
+    /// computation is very time critical, this method just looks it up in
+    /// a table. The actual computation and setup of that table is done
+    /// during initialization with the help of compute_section_base() below.
+    inline size_t get_section_base(size_t index) const noexcept;
+
+    /// Actually compute the starting offset of a section. Only used to initialize
+    /// a table of predefined results, which are then used by get_section_base().
+    size_t compute_section_base(size_t index) const noexcept;
+
+    /// Find a possible allocation of 'request_size' that will fit into a section
+    /// which is inside the range from 'start_pos' to 'start_pos'+'free_chunk_size'
+    /// If found return the position, if not return 0.
+    size_t find_section_in_range(size_t start_pos, size_t free_chunk_size,
+                                      size_t request_size) const noexcept;
+
+    friend class Group;
+    friend class GroupWriter;
+};
+
+inline void SlabAlloc::invalidate_cache() noexcept { ++version; }
+
+class SlabAlloc::DetachGuard {
+public:
+    DetachGuard(SlabAlloc& alloc) noexcept: m_alloc(&alloc) {}
+    ~DetachGuard() noexcept;
+    SlabAlloc* release() noexcept;
+private:
+    SlabAlloc* m_alloc;
+};
+
+
+
+// Implementation:
+
+struct InvalidDatabase: util::File::AccessError {
+    InvalidDatabase(const std::string& msg, const std::string& path):
+        util::File::AccessError(msg, path)
+    {
+    }
+};
+
+inline void SlabAlloc::own_buffer() noexcept
+{
+    REALM_ASSERT_3(m_attach_mode, ==, attach_UsersBuffer);
+    REALM_ASSERT(m_data);
+    REALM_ASSERT(m_file_mappings == nullptr);
+    m_attach_mode = attach_OwnedBuffer;
+}
+
+inline bool SlabAlloc::is_attached() const noexcept
+{
+    return m_attach_mode != attach_None;
+}
+
+inline bool SlabAlloc::nonempty_attachment() const noexcept
+{
+    return is_attached() && m_data;
+}
+
+inline size_t SlabAlloc::get_baseline() const noexcept
+{
+    REALM_ASSERT_DEBUG(is_attached());
+    return m_baseline;
+}
+
+inline bool SlabAlloc::is_free_space_clean() const noexcept
+{
+    return m_free_space_state == free_space_Clean;
+}
+
+inline SlabAlloc::DetachGuard::~DetachGuard() noexcept
+{
+    if (m_alloc)
+        m_alloc->detach();
+}
+
+inline SlabAlloc* SlabAlloc::DetachGuard::release() noexcept
+{
+    SlabAlloc* alloc = m_alloc;
+    m_alloc = nullptr;
+    return alloc;
+}
+
+inline bool SlabAlloc::ref_less_than_slab_ref_end(ref_type ref, const Slab& slab) noexcept
+{
+    return ref < slab.ref_end;
+}
+
+inline size_t SlabAlloc::get_upper_section_boundary(size_t start_pos) const noexcept
+{
+    return get_section_base(1+get_section_index(start_pos));
+}
+
+inline size_t SlabAlloc::get_lower_section_boundary(size_t start_pos) const noexcept
+{
+    return get_section_base(get_section_index(start_pos));
+}
+
+inline bool SlabAlloc::matches_section_boundary(size_t pos) const noexcept
+{
+    return pos == get_lower_section_boundary(pos);
+}
+
+inline size_t SlabAlloc::get_section_base(size_t index) const noexcept
+{
+    return m_section_bases[index];
+}
+
+} // namespace realm
+
+#endif // REALM_ALLOC_SLAB_HPP
diff --git a/Pods/Realm/include/core/realm/array.hpp b/Pods/Realm/include/core/realm/array.hpp
new file mode 100644
index 0000000..9497043
--- /dev/null
+++ b/Pods/Realm/include/core/realm/array.hpp
@@ -0,0 +1,3538 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+
+/*
+Searching: The main finding function is:
+    template<class cond, Action action, size_t bitwidth, class Callback>
+    void find(int64_t value, size_t start, size_t end, size_t baseindex, QueryState *state, Callback callback) const
+
+    cond:       One of Equal, NotEqual, Greater, etc. classes
+    Action:     One of act_ReturnFirst, act_FindAll, act_Max, act_CallbackIdx, etc, constants
+    Callback:   Optional function to call for each search result. Will be called if action == act_CallbackIdx
+
+    find() will call find_action_pattern() or find_action() that again calls match() for each search result which optionally calls callback():
+
+        find() -> find_action() -------> bool match() -> bool callback()
+             |                            ^
+             +-> find_action_pattern()----+
+
+    If callback() returns false, find() will exit, otherwise it will keep searching remaining items in array.
+*/
+
+#ifndef REALM_ARRAY_HPP
+#define REALM_ARRAY_HPP
+
+#include <cmath>
+#include <cstdlib> // size_t
+#include <algorithm>
+#include <utility>
+#include <vector>
+#include <ostream>
+
+#include <stdint.h> // unint8_t etc
+
+#include <realm/util/meta.hpp>
+#include <realm/util/assert.hpp>
+#include <realm/util/file_mapper.hpp>
+#include <realm/utilities.hpp>
+#include <realm/alloc.hpp>
+#include <realm/string_data.hpp>
+#include <realm/query_conditions.hpp>
+#include <realm/column_fwd.hpp>
+
+/*
+    MMX: mmintrin.h
+    SSE: xmmintrin.h
+    SSE2: emmintrin.h
+    SSE3: pmmintrin.h
+    SSSE3: tmmintrin.h
+    SSE4A: ammintrin.h
+    SSE4.1: smmintrin.h
+    SSE4.2: nmmintrin.h
+*/
+#ifdef REALM_COMPILER_SSE
+#  include <emmintrin.h> // SSE2
+#  include <realm/realm_nmmintrin.h> // SSE42
+#endif
+
+namespace realm {
+
+enum Action {act_ReturnFirst, act_Sum, act_Max, act_Min, act_Count, act_FindAll, act_CallIdx, act_CallbackIdx,
+             act_CallbackVal, act_CallbackNone, act_CallbackBoth, act_Average};
+
+template<class T>
+inline T no0(T v) { return v == 0 ? 1 : v; }
+
+/// Special index value. It has various meanings depending on
+/// context. It is returned by some search functions to indicate 'not
+/// found'. It is similar in function to std::string::npos.
+const size_t npos = size_t(-1);
+
+// Maximum number of bytes that the payload of an array can be
+const size_t max_array_payload = 0x00ffffffL;
+
+/// Alias for realm::npos.
+const size_t not_found = npos;
+
+ /* wid == 16/32 likely when accessing offsets in B tree */
+#define REALM_TEMPEX(fun, wid, arg) \
+    if (wid == 16) {fun<16> arg;} \
+    else if (wid == 32) {fun<32> arg;} \
+    else if (wid == 0) {fun<0> arg;} \
+    else if (wid == 1) {fun<1> arg;} \
+    else if (wid == 2) {fun<2> arg;} \
+    else if (wid == 4) {fun<4> arg;} \
+    else if (wid == 8) {fun<8> arg;} \
+    else if (wid == 64) {fun<64> arg;} \
+    else {REALM_ASSERT_DEBUG(false); fun<0> arg;}
+
+#define REALM_TEMPEX2(fun, targ, wid, arg) \
+    if (wid == 16) {fun<targ, 16> arg;} \
+    else if (wid == 32) {fun<targ, 32> arg;} \
+    else if (wid == 0) {fun<targ, 0> arg;} \
+    else if (wid == 1) {fun<targ, 1> arg;} \
+    else if (wid == 2) {fun<targ, 2> arg;} \
+    else if (wid == 4) {fun<targ, 4> arg;} \
+    else if (wid == 8) {fun<targ, 8> arg;} \
+    else if (wid == 64) {fun<targ, 64> arg;} \
+    else {REALM_ASSERT_DEBUG(false); fun<targ, 0> arg;}
+
+#define REALM_TEMPEX3(fun, targ1, targ2, wid, arg) \
+    if (wid == 16) {fun<targ1, targ2, 16> arg;} \
+    else if (wid == 32) {fun<targ1, targ2, 32> arg;} \
+    else if (wid == 0) {fun<targ1, targ2, 0> arg;} \
+    else if (wid == 1) {fun<targ1, targ2, 1> arg;} \
+    else if (wid == 2) {fun<targ1, targ2, 2> arg;} \
+    else if (wid == 4) {fun<targ1, targ2, 4> arg;} \
+    else if (wid == 8) {fun<targ1, targ2, 8> arg;} \
+    else if (wid == 64) {fun<targ1, targ2, 64> arg;} \
+    else {REALM_ASSERT_DEBUG(false); fun<targ1, targ2, 0> arg;}
+
+#define REALM_TEMPEX4(fun, targ1, targ2, wid, targ3, arg) \
+    if (wid == 16) {fun<targ1, targ2, 16, targ3> arg;} \
+    else if (wid == 32) {fun<targ1, targ2, 32, targ3> arg;} \
+    else if (wid == 0) {fun<targ1, targ2, 0, targ3> arg;} \
+    else if (wid == 1) {fun<targ1, targ2, 1, targ3> arg;} \
+    else if (wid == 2) {fun<targ1, targ2, 2, targ3> arg;} \
+    else if (wid == 4) {fun<targ1, targ2, 4, targ3> arg;} \
+    else if (wid == 8) {fun<targ1, targ2, 8, targ3> arg;} \
+    else if (wid == 64) {fun<targ1, targ2, 64, targ3> arg;} \
+    else {REALM_ASSERT_DEBUG(false); fun<targ1, targ2, 0, targ3> arg;}
+
+#define REALM_TEMPEX5(fun, targ1, targ2, targ3, targ4, wid, arg) \
+    if (wid == 16) {fun<targ1, targ2, targ3, targ4, 16> arg;} \
+    else if (wid == 32) {fun<targ1, targ2, targ3, targ4, 32> arg;} \
+    else if (wid == 0) {fun<targ1, targ2, targ3, targ4, 0> arg;} \
+    else if (wid == 1) {fun<targ1, targ2, targ3, targ4, 1> arg;} \
+    else if (wid == 2) {fun<targ1, targ2, targ3, targ4, 2> arg;} \
+    else if (wid == 4) {fun<targ1, targ2, targ3, targ4, 4> arg;} \
+    else if (wid == 8) {fun<targ1, targ2, targ3, targ4, 8> arg;} \
+    else if (wid == 64) {fun<targ1, targ2, targ3, targ4, 64> arg;} \
+    else {REALM_ASSERT_DEBUG(false); fun<targ1, targ2, targ3, targ4, 0> arg;}
+
+
+// Pre-definitions
+class Array;
+class StringColumn;
+class GroupWriter;
+template<class T>
+class QueryState;
+namespace _impl { class ArrayWriterBase; }
+
+
+#ifdef REALM_DEBUG
+struct MemStats {
+    size_t allocated = 0;
+    size_t used = 0;
+    size_t array_count = 0;
+};
+template<class C, class T>
+std::basic_ostream<C,T>& operator<<(std::basic_ostream<C,T>& out, MemStats stats);
+#endif
+
+
+// Stores a value obtained from Array::get(). It is a ref if the least
+// significant bit is clear, otherwise it is a tagged integer. A tagged interger
+// is obtained from a logical integer value by left shifting by one bit position
+// (multiplying by two), and then setting the least significant bit to
+// one. Clearly, this means that the maximum value that can be stored as a
+// tagged integer is 2**63 - 1.
+class RefOrTagged {
+public:
+    bool is_ref() const noexcept;
+    bool is_tagged() const noexcept;
+    ref_type get_as_ref() const noexcept;
+    uint_fast64_t get_as_int() const noexcept;
+
+    static RefOrTagged make_ref(ref_type) noexcept;
+    static RefOrTagged make_tagged(uint_fast64_t) noexcept;
+
+private:
+    int_fast64_t m_value;
+    RefOrTagged(int_fast64_t) noexcept;
+    friend class Array;
+};
+
+
+class ArrayParent
+{
+public:
+    virtual ~ArrayParent() noexcept {}
+
+protected:
+    virtual void update_child_ref(size_t child_ndx, ref_type new_ref) = 0;
+
+    virtual ref_type get_child_ref(size_t child_ndx) const noexcept = 0;
+
+#ifdef REALM_DEBUG
+    // Used only by Array::to_dot().
+    virtual std::pair<ref_type, size_t> get_to_dot_parent(size_t ndx_in_parent) const = 0;
+#endif
+
+    friend class Array;
+};
+
+
+/// Provides access to individual array nodes of the database.
+///
+/// This class serves purely as an accessor, it assumes no ownership of the
+/// referenced memory.
+///
+/// An array accessor can be in one of two states: attached or unattached. It is
+/// in the attached state if, and only if is_attached() returns true. Most
+/// non-static member functions of this class have undefined behaviour if the
+/// accessor is in the unattached state. The exceptions are: is_attached(),
+/// detach(), create(), init_from_ref(), init_from_mem(), init_from_parent(),
+/// has_parent(), get_parent(), set_parent(), get_ndx_in_parent(),
+/// set_ndx_in_parent(), adjust_ndx_in_parent(), and get_ref_from_parent().
+///
+/// An array accessor contains information about the parent of the referenced
+/// array node. This 'reverse' reference is not explicitely present in the
+/// underlying node hierarchy, but it is needed when modifying an array. A
+/// modification may lead to relocation of the underlying array node, and the
+/// parent must be updated accordingly. Since this applies recursivly all the
+/// way to the root node, it is essential that the entire chain of parent
+/// accessors is constructed and propperly maintained when a particular array is
+/// modified.
+///
+/// The parent reference (`pointer to parent`, `index in parent`) is updated
+/// independently from the state of attachment to an underlying node. In
+/// particular, the parent reference remains valid and is unannfected by changes
+/// in attachment. These two aspects of the state of the accessor is updated
+/// independently, and it is entirely the responsibility of the caller to update
+/// them such that they are consistent with the underlying node hierarchy before
+/// calling any method that modifies the underlying array node.
+///
+/// FIXME: This class currently has fragments of ownership, in particular the
+/// constructors that allocate underlying memory. On the other hand, the
+/// destructor never frees the memory. This is a disastrous situation, because
+/// it so easily becomes an obscure source of leaks. There are three options for
+/// a fix of which the third is most attractive but hardest to implement: (1)
+/// Remove all traces of ownership semantics, that is, remove the constructors
+/// that allocate memory, but keep the trivial copy constructor. For this to
+/// work, it is important that the constness of the accessor has nothing to do
+/// with the constness of the underlying memory, otherwise constness can be
+/// violated simply by copying the accessor. (2) Disallov copying but associate
+/// the constness of the accessor with the constness of the underlying
+/// memory. (3) Provide full ownership semantics like is done for Table
+/// accessors, and provide a proper copy constructor that really produces a copy
+/// of the array. For this to work, the class should assume ownership if, and
+/// only if there is no parent. A copy produced by a copy constructor will not
+/// have a parent. Even if the original was part of a database, the copy will be
+/// free-standing, that is, not be part of any database. For intra, or inter
+/// database copying, one would have to also specify the target allocator.
+class Array: public ArrayParent {
+public:
+
+//    void state_init(int action, QueryState *state);
+//    bool match(int action, size_t index, int64_t value, QueryState *state);
+
+    /// Create an array accessor in the unattached state.
+    explicit Array(Allocator&) noexcept;
+
+    // Fastest way to instantiate an array, if you just want to utilize its
+    // methods
+    struct no_prealloc_tag {};
+    explicit Array(no_prealloc_tag) noexcept;
+
+    ~Array() noexcept override {}
+
+    enum Type {
+        type_Normal,
+
+        /// This array is the main array of an innner node of a B+-tree as used
+        /// in table columns.
+        type_InnerBptreeNode,
+
+        /// This array may contain refs to subarrays. An element whose least
+        /// significant bit is zero, is a ref pointing to a subarray. An element
+        /// whose least significant bit is one, is just a value. It is the
+        /// responsibility of the application to ensure that non-ref values have
+        /// their least significant bit set. This will generally be done by
+        /// shifting the desired vlue to the left by one bit position, and then
+        /// setting the vacated bit to one.
+        type_HasRefs
+    };
+
+    /// Create a new integer array of the specified type and size, and filled
+    /// with the specified value, and attach this accessor to it. This does not
+    /// modify the parent reference information of this accessor.
+    ///
+    /// Note that the caller assumes ownership of the allocated underlying
+    /// node. It is not owned by the accessor.
+    void create(Type, bool context_flag = false, size_t size = 0, int_fast64_t value = 0);
+
+    /// Reinitialize this array accessor to point to the specified new
+    /// underlying memory. This does not modify the parent reference information
+    /// of this accessor.
+    void init_from_ref(ref_type) noexcept;
+
+    /// Same as init_from_ref(ref_type) but avoid the mapping of 'ref' to memory
+    /// pointer.
+    void init_from_mem(MemRef) noexcept;
+
+    /// Same as `init_from_ref(get_ref_from_parent())`.
+    void init_from_parent() noexcept;
+
+    /// Update the parents reference to this child. This requires, of course,
+    /// that the parent information stored in this child is up to date. If the
+    /// parent pointer is set to null, this function has no effect.
+    void update_parent();
+
+    /// Called in the context of Group::commit() to ensure that attached
+    /// accessors stay valid across a commit. Please note that this works only
+    /// for non-transactional commits. Accessors obtained during a transaction
+    /// are always detached when the transaction ends.
+    ///
+    /// Returns true if, and only if the array has changed. If the array has not
+    /// changed, then its children are guaranteed to also not have changed.
+    bool update_from_parent(size_t old_baseline) noexcept;
+
+    /// Change the type of an already attached array node.
+    ///
+    /// The effect of calling this function on an unattached accessor is
+    /// undefined.
+    void set_type(Type);
+
+    /// Construct a complete copy of this array (including its subarrays) using
+    /// the specified target allocator and return just the reference to the
+    /// underlying memory.
+    MemRef clone_deep(Allocator& target_alloc) const;
+
+    void move_assign(Array&) noexcept; // Move semantics for assignment
+
+    /// Construct an empty integer array of the specified type, and return just
+    /// the reference to the underlying memory.
+    static MemRef create_empty_array(Type, bool context_flag, Allocator&);
+
+    /// Construct an integer array of the specified type and size, and return
+    /// just the reference to the underlying memory. All elements will be
+    /// initialized to the specified value.
+    static MemRef create_array(Type, bool context_flag, size_t size,
+                               int_fast64_t value, Allocator&);
+
+    /// Construct a shallow copy of the specified slice of this array using the
+    /// specified target allocator. Subarrays will **not** be cloned. See
+    /// slice_and_clone_children() for an alternative.
+    MemRef slice(size_t offset, size_t slice_size, Allocator& target_alloc) const;
+
+    /// Construct a deep copy of the specified slice of this array using the
+    /// specified target allocator. Subarrays will be cloned.
+    MemRef slice_and_clone_children(size_t offset, size_t slice_size,
+                                    Allocator& target_alloc) const;
+
+    // Parent tracking
+    bool has_parent() const noexcept;
+    ArrayParent* get_parent() const noexcept;
+
+    /// Setting a new parent affects ownership of the attached array node, if
+    /// any. If a non-null parent is specified, and there was no parent
+    /// originally, then the caller passes ownership to the parent, and vice
+    /// versa. This assumes, of course, that the change in parentship reflects a
+    /// corresponding change in the list of children in the affected parents.
+    void set_parent(ArrayParent* parent, size_t ndx_in_parent) noexcept;
+
+    size_t get_ndx_in_parent() const noexcept;
+    void set_ndx_in_parent(size_t) noexcept;
+    void adjust_ndx_in_parent(int diff) noexcept;
+
+    /// Get the ref of this array as known to the parent. The caller must ensure
+    /// that the parent information ('pointer to parent' and 'index in parent')
+    /// is correct before calling this function.
+    ref_type get_ref_from_parent() const noexcept;
+
+    bool is_attached() const noexcept;
+
+    /// Detach from the underlying array node. This method has no effect if the
+    /// accessor is currently unattached (idempotency).
+    void detach() noexcept;
+
+    size_t size() const noexcept;
+    bool is_empty() const noexcept;
+    Type get_type() const noexcept;
+
+    static void add_to_column(IntegerColumn* column, int64_t value);
+
+    void insert(size_t ndx, int_fast64_t value);
+    void add(int_fast64_t value);
+
+    /// This function is guaranteed to not throw if the current width is
+    /// sufficient for the specified value (e.g. if you have called
+    /// ensure_minimum_width(value)) and get_alloc().is_read_only(get_ref())
+    /// returns false (noexcept:array-set). Note that for a value of zero, the
+    /// first criterion is trivially satisfied.
+    void set(size_t ndx, int64_t value);
+
+    void set_as_ref(size_t ndx, ref_type ref);
+
+    template<size_t w>
+    void set(size_t ndx, int64_t value);
+
+    int64_t get(size_t ndx) const noexcept;
+
+    template<size_t w>
+    int64_t get(size_t ndx) const noexcept;
+
+    void get_chunk(size_t ndx, int64_t res[8]) const noexcept;
+
+    template<size_t w>
+    void get_chunk(size_t ndx, int64_t res[8]) const noexcept;
+
+    ref_type get_as_ref(size_t ndx) const noexcept;
+
+    RefOrTagged get_as_ref_or_tagged(size_t ndx) const noexcept;
+    void set(size_t ndx, RefOrTagged);
+    void add(RefOrTagged);
+    void ensure_minimum_width(RefOrTagged);
+
+    int64_t front() const noexcept;
+    int64_t back() const noexcept;
+
+    /// Remove the element at the specified index, and move elements at higher
+    /// indexes to the next lower index.
+    ///
+    /// This function does **not** destroy removed subarrays. That is, if the
+    /// erased element is a 'ref' pointing to a subarray, then that subarray
+    /// will not be destroyed automatically.
+    ///
+    /// This function guarantees that no exceptions will be thrown if
+    /// get_alloc().is_read_only(get_ref()) would return false before the
+    /// call. This is automatically guaranteed if the array is used in a
+    /// non-transactional context, or if the array has already been successfully
+    /// modified within the current write transaction.
+    void erase(size_t ndx);
+
+    /// Same as erase(size_t), but remove all elements in the specified
+    /// range.
+    ///
+    /// Please note that this function does **not** destroy removed subarrays.
+    ///
+    /// This function guarantees that no exceptions will be thrown if
+    /// get_alloc().is_read_only(get_ref()) would return false before the call.
+    void erase(size_t begin, size_t end);
+
+    /// Reduce the size of this array to the specified number of elements. It is
+    /// an error to specify a size that is greater than the current size of this
+    /// array. The effect of doing so is undefined. This is just a shorthand for
+    /// calling the ranged erase() function with appropriate arguments.
+    ///
+    /// Please note that this function does **not** destroy removed
+    /// subarrays. See clear_and_destroy_children() for an alternative.
+    ///
+    /// This function guarantees that no exceptions will be thrown if
+    /// get_alloc().is_read_only(get_ref()) would return false before the call.
+    void truncate(size_t new_size);
+
+    /// Reduce the size of this array to the specified number of elements. It is
+    /// an error to specify a size that is greater than the current size of this
+    /// array. The effect of doing so is undefined. Subarrays will be destroyed
+    /// recursively, as if by a call to `destroy_deep(subarray_ref, alloc)`.
+    ///
+    /// This function is guaranteed not to throw if
+    /// get_alloc().is_read_only(get_ref()) returns false.
+    void truncate_and_destroy_children(size_t new_size);
+
+    /// Remove every element from this array. This is just a shorthand for
+    /// calling truncate(0).
+    ///
+    /// Please note that this function does **not** destroy removed
+    /// subarrays. See clear_and_destroy_children() for an alternative.
+    ///
+    /// This function guarantees that no exceptions will be thrown if
+    /// get_alloc().is_read_only(get_ref()) would return false before the call.
+    void clear();
+
+    /// Remove every element in this array. Subarrays will be destroyed
+    /// recursively, as if by a call to `destroy_deep(subarray_ref,
+    /// alloc)`. This is just a shorthand for calling
+    /// truncate_and_destroy_children(0).
+    ///
+    /// This function guarantees that no exceptions will be thrown if
+    /// get_alloc().is_read_only(get_ref()) would return false before the call.
+    void clear_and_destroy_children();
+
+    /// If neccessary, expand the representation so that it can store the
+    /// specified value.
+    void ensure_minimum_width(int_fast64_t value);
+
+    typedef StringData (*StringGetter)(void*, size_t, char*); // Pre-declare getter function from string index
+    size_t index_string_find_first(StringData value, ColumnBase* column) const;
+    void   index_string_find_all(IntegerColumn& result, StringData value, ColumnBase* column) const;
+    size_t index_string_count(StringData value, ColumnBase* column) const;
+    FindRes index_string_find_all_no_copy(StringData value, size_t& res_ref, ColumnBase* column) const;
+
+    /// This one may change the represenation of the array, so be carefull if
+    /// you call it after ensure_minimum_width().
+    void set_all_to_zero();
+
+    /// Add \a diff to the element at the specified index.
+    void adjust(size_t ndx, int_fast64_t diff);
+
+    /// Add \a diff to all the elements in the specified index range.
+    void adjust(size_t begin, size_t end, int_fast64_t diff);
+
+    /// Add signed \a diff to all elements that are greater than, or equal to \a
+    /// limit.
+    void adjust_ge(int_fast64_t limit, int_fast64_t diff);
+
+    //@{
+    /// These are similar in spirit to std::move() and std::move_backward from
+    /// <algorithm>. \a dest_begin must not be in the range [`begin`,`end`), and
+    /// \a dest_end must not be in the range (`begin`,`end`].
+    ///
+    /// These functions are guaranteed to not throw if
+    /// `get_alloc().is_read_only(get_ref())` returns false.
+    void move(size_t begin, size_t end, size_t dest_begin);
+    void move_backward(size_t begin, size_t end, size_t dest_end);
+    //@}
+
+    /// move_rotate moves one element from \a from to be located at index \a to,
+    /// shifting all elements inbetween by one.
+    ///
+    /// If \a from is larger than \a to, the elements inbetween are shifted down.
+    /// If \a to is larger than \a from, the elements inbetween are shifted up.
+    ///
+    /// This function is guaranteed to not throw if
+    /// `get_alloc().is_read_only(get_ref())` returns false.
+    void move_rotate(size_t from, size_t to, size_t num_elems = 1);
+
+    //@{
+    /// Find the lower/upper bound of the specified value in a sequence of
+    /// integers which must already be sorted ascendingly.
+    ///
+    /// For an integer value '`v`', lower_bound_int(v) returns the index '`l`'
+    /// of the first element such that `get(l) &ge; v`, and upper_bound_int(v)
+    /// returns the index '`u`' of the first element such that `get(u) &gt;
+    /// v`. In both cases, if no such element is found, the returned value is
+    /// the number of elements in the array.
+    ///
+    ///     3 3 3 4 4 4 5 6 7 9 9 9
+    ///     ^     ^     ^     ^     ^
+    ///     |     |     |     |     |
+    ///     |     |     |     |      -- Lower and upper bound of 15
+    ///     |     |     |     |
+    ///     |     |     |      -- Lower and upper bound of 8
+    ///     |     |     |
+    ///     |     |      -- Upper bound of 4
+    ///     |     |
+    ///     |      -- Lower bound of 4
+    ///     |
+    ///      -- Lower and upper bound of 1
+    ///
+    /// These functions are similar to std::lower_bound() and
+    /// std::upper_bound().
+    ///
+    /// We currently use binary search. See for example
+    /// http://www.tbray.org/ongoing/When/200x/2003/03/22/Binary.
+    ///
+    /// FIXME: It may be worth considering if overall efficiency can be improved
+    /// by doing a linear search for short sequences.
+    size_t lower_bound_int(int64_t value) const noexcept;
+    size_t upper_bound_int(int64_t value) const noexcept;
+    //@}
+
+    /// \brief Search the \c Array for a value greater or equal than \a target,
+    /// starting the search at the \a start index. If \a indirection is
+    /// provided, use it as a look-up table to iterate over the \c Array.
+    ///
+    /// If \a indirection is not provided, then the \c Array must be sorted in
+    /// ascending order. If \a indirection is provided, then its values should
+    /// point to indices in this \c Array in such a way that iteration happens
+    /// in ascending order.
+    ///
+    /// Behaviour is undefined if:
+    /// - a value in \a indirection is out of bounds for this \c Array;
+    /// - \a indirection does not contain at least as many elements as this \c
+    ///   Array;
+    /// - sorting conditions are not respected;
+    /// - \a start is greater than the number of elements in this \c Array or
+    ///   \a indirection (if provided).
+    ///
+    /// \param target the smallest value to search for
+    /// \param start the offset at which to start searching in the array
+    /// \param indirection an \c Array containing valid indices of values in
+    ///        this \c Array, sorted in ascending order
+    /// \return the index of the value if found, or realm::not_found otherwise
+    size_t find_gte(const int64_t target, size_t start, Array const* indirection) const;
+    void preset(int64_t min, int64_t max, size_t num_items);
+    void preset(size_t bitwidth, size_t num_items);
+
+    int64_t sum(size_t start = 0, size_t end = size_t(-1)) const;
+    size_t count(int64_t value) const noexcept;
+
+    bool maximum(int64_t& result, size_t start = 0, size_t end = size_t(-1),
+                 size_t* return_ndx = nullptr) const;
+
+    bool minimum(int64_t& result, size_t start = 0, size_t end = size_t(-1),
+                 size_t* return_ndx = nullptr) const;
+
+    /// This information is guaranteed to be cached in the array accessor.
+    bool is_inner_bptree_node() const noexcept;
+
+    /// Returns true if type is either type_HasRefs or type_InnerColumnNode.
+    ///
+    /// This information is guaranteed to be cached in the array accessor.
+    bool has_refs() const noexcept;
+
+    /// This information is guaranteed to be cached in the array accessor.
+    ///
+    /// Columns and indexes can use the context bit to differentiate leaf types.
+    bool get_context_flag() const noexcept;
+    void set_context_flag(bool) noexcept;
+
+    ref_type get_ref() const noexcept;
+    MemRef get_mem() const noexcept;
+
+    /// Destroy only the array that this accessor is attached to, not the
+    /// children of that array. See non-static destroy_deep() for an
+    /// alternative. If this accessor is already in the detached state, this
+    /// function has no effect (idempotency).
+    void destroy() noexcept;
+
+    /// Recursively destroy children (as if calling
+    /// clear_and_destroy_children()), then put this accessor into the detached
+    /// state (as if calling detach()), then free the allocated memory. If this
+    /// accessor is already in the detached state, this function has no effect
+    /// (idempotency).
+    void destroy_deep() noexcept;
+
+    /// Shorthand for `destroy(MemRef(ref, alloc), alloc)`.
+    static void destroy(ref_type ref, Allocator& alloc) noexcept;
+
+    /// Destroy only the specified array node, not its children. See also
+    /// destroy_deep(MemRef, Allocator&).
+    static void destroy(MemRef, Allocator&) noexcept;
+
+    /// Shorthand for `destroy_deep(MemRef(ref, alloc), alloc)`.
+    static void destroy_deep(ref_type ref, Allocator& alloc) noexcept;
+
+    /// Destroy the specified array node and all of its children, recursively.
+    ///
+    /// This is done by freeing the specified array node after calling
+    /// destroy_deep() for every contained 'ref' element.
+    static void destroy_deep(MemRef, Allocator&) noexcept;
+
+    Allocator& get_alloc() const noexcept
+    {
+        return m_alloc;
+    }
+
+    // Serialization
+
+    /// Returns the ref (position in the target stream) of the written copy of
+    /// this array, or the ref of the original array if \a only_if_modified is
+    /// true, and this array is unmodified (Alloc::is_read_only()).
+    ///
+    /// The number of bytes that will be written by a non-recursive invocation
+    /// of this function is exactly the number returned by get_byte_size().
+    ///
+    /// \param deep If true, recursively write out subarrays, but still subject
+    /// to \a only_if_modified.
+    ref_type write(_impl::ArrayWriterBase&, bool deep, bool only_if_modified) const;
+
+    /// Same as non-static write() with `deep` set to true. This is for the
+    /// cases where you do not already have an array accessor available.
+    static ref_type write(ref_type, Allocator&, _impl::ArrayWriterBase&, bool only_if_modified);
+
+    // Main finding function - used for find_first, find_all, sum, max, min, etc.
+    bool find(int cond, Action action, int64_t value, size_t start, size_t end, size_t baseindex,
+              QueryState<int64_t>* state, bool nullable_array = false, bool find_null = false) const;
+
+    // Templated find function to avoid conversion to and from integer represenation of condition
+    template <class cond>
+    bool find(Action action, int64_t value, size_t start, size_t end, size_t baseindex, QueryState<int64_t> *state, bool nullable_array = false, bool find_null = false) const {
+        if (action == act_ReturnFirst) {
+            REALM_TEMPEX3(return find, cond, act_ReturnFirst, m_width, (value, start, end, baseindex, state, CallbackDummy(), nullable_array, find_null))
+        }
+        else if (action == act_Sum) {
+            REALM_TEMPEX3(return find, cond, act_Sum, m_width, (value, start, end, baseindex, state, CallbackDummy(), nullable_array, find_null))
+        }
+        else if (action == act_Min) {
+            REALM_TEMPEX3(return find, cond, act_Min, m_width, (value, start, end, baseindex, state, CallbackDummy(), nullable_array, find_null))
+        }
+        else if (action == act_Max) {
+            REALM_TEMPEX3(return find, cond, act_Max, m_width, (value, start, end, baseindex, state, CallbackDummy(), nullable_array, find_null))
+        }
+        else if (action == act_Count) {
+            REALM_TEMPEX3(return find, cond, act_Count, m_width, (value, start, end, baseindex, state, CallbackDummy(), nullable_array, find_null))
+        }
+        else if (action == act_FindAll) {
+            REALM_TEMPEX3(return find, cond, act_FindAll, m_width, (value, start, end, baseindex, state, CallbackDummy(), nullable_array, find_null))
+        }
+        else if (action == act_CallbackIdx) {
+            REALM_TEMPEX3(return find, cond, act_CallbackIdx, m_width, (value, start, end, baseindex, state, CallbackDummy(), nullable_array, find_null))
+        }
+        REALM_ASSERT_DEBUG(false);
+        return false;
+    }
+
+
+/*
+    bool find(int cond, Action action, null, size_t start, size_t end, size_t baseindex,
+              QueryState<int64_t>* state) const;
+*/
+
+    template<class cond, Action action, size_t bitwidth, class Callback>
+    bool find(int64_t value, size_t start, size_t end, size_t baseindex,
+              QueryState<int64_t>* state, Callback callback, bool nullable_array = false, bool find_null = false) const;
+
+    // This is the one installed into the m_vtable->finder slots.
+    template<class cond, Action action, size_t bitwidth>
+    bool find(int64_t value, size_t start, size_t end, size_t baseindex,
+              QueryState<int64_t>* state) const;
+
+    template<class cond, Action action, class Callback>
+    bool find(int64_t value, size_t start, size_t end, size_t baseindex, QueryState<int64_t>* state,
+                 Callback callback, bool nullable_array = false, bool find_null = false) const;
+
+/*
+    template<class cond, Action action, class Callback>
+    bool find(null, size_t start, size_t end, size_t baseindex,
+              QueryState<int64_t>* state, Callback callback) const;
+*/
+
+    // Optimized implementation for release mode
+    template<class cond, Action action, size_t bitwidth, class Callback>
+    bool find_optimized(int64_t value, size_t start, size_t end, size_t baseindex,
+                        QueryState<int64_t>* state, Callback callback, bool nullable_array = false, bool find_null = false) const;
+
+    // Called for each search result
+    template<Action action, class Callback>
+    bool find_action(size_t index, util::Optional<int64_t> value,
+                     QueryState<int64_t>* state, Callback callback) const;
+
+    template<Action action, class Callback>
+    bool find_action_pattern(size_t index, uint64_t pattern,
+                             QueryState<int64_t>* state, Callback callback) const;
+
+    // Wrappers for backwards compatibility and for simple use without
+    // setting up state initialization etc
+    template<class cond>
+    size_t find_first(int64_t value, size_t start = 0,
+                           size_t end = size_t(-1)) const;
+
+    void find_all(IntegerColumn* result, int64_t value, size_t col_offset = 0,
+                  size_t begin = 0, size_t end = size_t(-1)) const;
+
+    size_t find_first(int64_t value, size_t begin = 0,
+                           size_t end = size_t(-1)) const;
+
+    // Non-SSE find for the four functions Equal/NotEqual/Less/Greater
+    template<class cond, Action action, size_t bitwidth, class Callback>
+    bool compare(int64_t value, size_t start, size_t end, size_t baseindex,
+                 QueryState<int64_t>* state, Callback callback) const;
+
+    // Non-SSE find for Equal/NotEqual
+    template<bool eq, Action action, size_t width, class Callback>
+    inline bool compare_equality(int64_t value, size_t start, size_t end, size_t baseindex,
+                                QueryState<int64_t>* state, Callback callback) const;
+
+    // Non-SSE find for Less/Greater
+    template<bool gt, Action action, size_t bitwidth, class Callback>
+    bool compare_relation(int64_t value, size_t start, size_t end, size_t baseindex,
+                         QueryState<int64_t>* state, Callback callback) const;
+
+    template<class cond, Action action, size_t foreign_width, class Callback, size_t width>
+    bool compare_leafs_4(const Array* foreign, size_t start, size_t end, size_t baseindex,
+                       QueryState<int64_t>* state, Callback callback) const;
+
+    template<class cond, Action action, class Callback, size_t bitwidth, size_t foreign_bitwidth>
+    bool compare_leafs(const Array* foreign, size_t start, size_t end, size_t baseindex,
+                      QueryState<int64_t>* state, Callback callback) const;
+
+    template<class cond, Action action, class Callback>
+    bool compare_leafs(const Array* foreign, size_t start, size_t end, size_t baseindex,
+                      QueryState<int64_t>* state, Callback callback) const;
+
+    template<class cond, Action action, size_t width, class Callback>
+    bool compare_leafs(const Array* foreign, size_t start, size_t end, size_t baseindex,
+                      QueryState<int64_t>* state, Callback callback) const;
+
+    // SSE find for the four functions Equal/NotEqual/Less/Greater
+#ifdef REALM_COMPILER_SSE
+    template<class cond, Action action, size_t width, class Callback>
+    bool find_sse(int64_t value, __m128i *data, size_t items, QueryState<int64_t>* state,
+                 size_t baseindex, Callback callback) const;
+
+    template<class cond, Action action, size_t width, class Callback>
+    REALM_FORCEINLINE bool find_sse_intern(__m128i* action_data, __m128i* data, size_t items,
+                                            QueryState<int64_t>* state, size_t baseindex,
+                                            Callback callback) const;
+
+#endif
+
+    template<size_t width>
+    inline bool test_zero(uint64_t value) const; // Tests value for 0-elements
+
+    template<bool eq, size_t width>
+    size_t find_zero(uint64_t v) const;          // Finds position of 0/non-zero element
+
+    template<size_t width, bool zero>
+    uint64_t cascade(uint64_t a) const;          // Sets lowermost bits of zero or non-zero elements
+
+    template<bool gt, size_t width>
+    int64_t find_gtlt_magic(int64_t v) const;    // Compute magic constant needed for searching for value 'v' using bit hacks
+
+    template<size_t width>
+    inline int64_t lower_bits() const;           // Return chunk with lower bit set in each element
+
+    size_t first_set_bit(unsigned int v) const;
+    size_t first_set_bit64(int64_t v) const;
+
+    template<size_t w>
+    int64_t get_universal(const char* const data, const size_t ndx) const;
+
+    // Find value greater/less in 64-bit chunk - only works for positive values
+    template<bool gt, Action action, size_t width, class Callback>
+    bool find_gtlt_fast(uint64_t chunk, uint64_t magic, QueryState<int64_t>* state, size_t baseindex,
+                        Callback callback) const;
+
+    // Find value greater/less in 64-bit chunk - no constraints
+    template<bool gt, Action action, size_t width, class Callback>
+    bool find_gtlt(int64_t v, uint64_t chunk, QueryState<int64_t>* state, size_t baseindex,
+                   Callback callback) const;
+
+
+    /// Get the number of elements in the B+-tree rooted at this array
+    /// node. The root must not be a leaf.
+    ///
+    /// Please avoid using this function (consider it deprecated). It
+    /// will have to be removed if we choose to get rid of the last
+    /// element of the main array of an inner B+-tree node that stores
+    /// the total number of elements in the subtree. The motivation
+    /// for removing it, is that it will significantly improve the
+    /// efficiency when inserting after, and erasing the last element.
+    size_t get_bptree_size() const noexcept;
+
+    /// The root must not be a leaf.
+    static size_t get_bptree_size_from_header(const char* root_header) noexcept;
+
+
+    /// Find the leaf node corresponding to the specified element
+    /// index index. The specified element index must refer to an
+    /// element that exists in the tree. This function must be called
+    /// on an inner B+-tree node, never a leaf. Note that according to
+    /// invar:bptree-nonempty-inner and invar:bptree-nonempty-leaf, an
+    /// inner B+-tree node can never be empty.
+    ///
+    /// This function is not obliged to instantiate intermediate array
+    /// accessors. For this reason, this function cannot be used for
+    /// operations that modify the tree, as that requires an unbroken
+    /// chain of parent array accessors between the root and the
+    /// leaf. Thus, despite the fact that the returned MemRef object
+    /// appears to allow modification of the referenced memory, the
+    /// caller must handle the memory reference as if it was
+    /// const-qualified.
+    ///
+    /// \return (`leaf_header`, `ndx_in_leaf`) where `leaf_header`
+    /// points to the the header of the located leaf, and
+    /// `ndx_in_leaf` is the local index within that leaf
+    /// corresponding to the specified element index.
+    std::pair<MemRef, size_t> get_bptree_leaf(size_t elem_ndx) const noexcept;
+
+
+    class NodeInfo;
+    class VisitHandler;
+
+    /// Visit leaves of the B+-tree rooted at this inner node,
+    /// starting with the leaf that contains the element at the
+    /// specified element index start offset, and ending when the
+    /// handler returns false. The specified element index offset must
+    /// refer to an element that exists in the tree. This function
+    /// must be called on an inner B+-tree node, never a leaf. Note
+    /// that according to invar:bptree-nonempty-inner and
+    /// invar:bptree-nonempty-leaf, an inner B+-tree node can never be
+    /// empty.
+    ///
+    /// \param elems_in_tree The total number of element in the tree.
+    ///
+    /// \return True if, and only if the handler has returned true for
+    /// all visited leafs.
+    bool visit_bptree_leaves(size_t elem_ndx_offset, size_t elems_in_tree,
+                             VisitHandler&);
+
+
+    class UpdateHandler;
+
+    /// Call the handler for every leaf. This function must be called
+    /// on an inner B+-tree node, never a leaf.
+    void update_bptree_leaves(UpdateHandler&);
+
+    /// Call the handler for the leaf that contains the element at the
+    /// specified index. This function must be called on an inner
+    /// B+-tree node, never a leaf.
+    void update_bptree_elem(size_t elem_ndx, UpdateHandler&);
+
+
+    class EraseHandler;
+
+    /// Erase the element at the specified index in the B+-tree with
+    /// the specified root. When erasing the last element, you must
+    /// pass npos in place of the index. This function must be called
+    /// with a root that is an inner B+-tree node, never a leaf.
+    ///
+    /// This function is guaranteed to succeed (not throw) if the
+    /// specified element was inserted during the current transaction,
+    /// and no other modifying operation has been carried out since
+    /// then (noexcept:bptree-erase-alt).
+    ///
+    /// FIXME: ExceptionSafety: The exception guarantee explained
+    /// above is not as powerfull as we would like it to be. Here is
+    /// what we would like: This function is guaranteed to succeed
+    /// (not throw) if the specified element was inserted during the
+    /// current transaction (noexcept:bptree-erase). This must be true
+    /// even if the element is modified after insertion, and/or if
+    /// other elements are inserted or erased around it. There are two
+    /// aspects of the current design that stand in the way of this
+    /// guarantee: (A) The fact that the node accessor, that is cached
+    /// in the column accessor, has to be reallocated/reinstantiated
+    /// when the root switches between being a leaf and an inner
+    /// node. This problem would go away if we always cached the last
+    /// used leaf accessor in the column accessor instead. (B) The
+    /// fact that replacing one child ref with another can fail,
+    /// because it may require reallocation of memory to expand the
+    /// bit-width. This can be fixed in two ways: Either have the
+    /// inner B+-tree nodes always have a bit-width of 64, or allow
+    /// the root node to be discarded and the column ref to be set to
+    /// zero in Table::m_columns.
+    static void erase_bptree_elem(Array* root, size_t elem_ndx, EraseHandler&);
+
+
+    struct TreeInsertBase {
+        size_t m_split_offset;
+        size_t m_split_size;
+    };
+
+    template<class TreeTraits>
+    struct TreeInsert: TreeInsertBase {
+        typename TreeTraits::value_type m_value;
+        bool m_nullable;
+    };
+
+    /// Same as bptree_insert() but insert after the last element.
+    template<class TreeTraits>
+    ref_type bptree_append(TreeInsert<TreeTraits>& state);
+
+    /// Insert an element into the B+-subtree rooted at this array
+    /// node. The element is inserted before the specified element
+    /// index. This function must be called on an inner B+-tree node,
+    /// never a leaf. If this inner node had to be split, this
+    /// function returns the `ref` of the new sibling.
+    template<class TreeTraits>
+    ref_type bptree_insert(size_t elem_ndx, TreeInsert<TreeTraits>& state);
+
+    ref_type bptree_leaf_insert(size_t ndx, int64_t, TreeInsertBase& state);
+
+    /// Get the specified element without the cost of constructing an
+    /// array instance. If an array instance is already available, or
+    /// you need to get multiple values, then this method will be
+    /// slower.
+    static int_fast64_t get(const char* header, size_t ndx) noexcept;
+
+    /// Like get(const char*, size_t) but gets two consecutive
+    /// elements.
+    static std::pair<int64_t, int64_t> get_two(const char* header,
+                                                           size_t ndx) noexcept;
+
+    static void get_three(const char* data, size_t ndx, ref_type& v0, ref_type& v1, ref_type& v2) noexcept;
+
+    /// The meaning of 'width' depends on the context in which this
+    /// array is used.
+    size_t get_width() const noexcept { return m_width; }
+
+    static char* get_data_from_header(char*) noexcept;
+    static char* get_header_from_data(char*) noexcept;
+    static const char* get_data_from_header(const char*) noexcept;
+
+    enum WidthType {
+        wtype_Bits     = 0,
+        wtype_Multiply = 1,
+        wtype_Ignore   = 2
+    };
+
+    static bool get_is_inner_bptree_node_from_header(const char*) noexcept;
+    static bool get_hasrefs_from_header(const char*) noexcept;
+    static bool get_context_flag_from_header(const char*) noexcept;
+    static WidthType get_wtype_from_header(const char*) noexcept;
+    static uint_least8_t get_width_from_header(const char*) noexcept;
+    static size_t get_size_from_header(const char*) noexcept;
+
+    static Type get_type_from_header(const char*) noexcept;
+
+    /// Get the number of bytes currently in use by this array. This
+    /// includes the array header, but it does not include allocated
+    /// bytes corresponding to excess capacity. The result is
+    /// guaranteed to be a multiple of 8 (i.e., 64-bit aligned).
+    ///
+    /// This number is exactly the number of bytes that will be
+    /// written by a non-recursive invocation of write().
+    size_t get_byte_size() const noexcept;
+
+    /// Get the maximum number of bytes that can be written by a
+    /// non-recursive invocation of write() on an array with the
+    /// specified number of elements, that is, the maximum value that
+    /// can be returned by get_byte_size().
+    static size_t get_max_byte_size(size_t num_elems) noexcept;
+
+    /// FIXME: Belongs in IntegerArray
+    static size_t calc_aligned_byte_size(size_t size, int width);
+
+#ifdef REALM_DEBUG
+    void print() const;
+    void verify() const;
+    typedef size_t (*LeafVerifier)(MemRef, Allocator&);
+    void verify_bptree(LeafVerifier) const;
+    class MemUsageHandler {
+    public:
+        virtual void handle(ref_type ref, size_t allocated, size_t used) = 0;
+    };
+    void report_memory_usage(MemUsageHandler&) const;
+    void stats(MemStats& stats_dest) const;
+    typedef void (*LeafDumper)(MemRef, Allocator&, std::ostream&, int level);
+    void dump_bptree_structure(std::ostream&, int level, LeafDumper) const;
+    void to_dot(std::ostream&, StringData title = StringData()) const;
+    class ToDotHandler {
+    public:
+        virtual void to_dot(MemRef leaf_mem, ArrayParent*, size_t ndx_in_parent,
+                            std::ostream&) = 0;
+        ~ToDotHandler() {}
+    };
+    void bptree_to_dot(std::ostream&, ToDotHandler&) const;
+    void to_dot_parent_edge(std::ostream&) const;
+#endif
+
+    static const int header_size = 8; // Number of bytes used by header
+
+    // The encryption layer relies on headers always fitting within a single page.
+    static_assert(header_size == 8, "Header must always fit in entirely on a page");
+private:
+    Array& operator=(const Array&); // not allowed
+protected:
+    typedef bool(*CallbackDummy)(int64_t);
+
+    /// Insert a new child after original. If the parent has to be
+    /// split, this function returns the `ref` of the new parent node.
+    ref_type insert_bptree_child(Array& offsets, size_t orig_child_ndx,
+                                 ref_type new_sibling_ref, TreeInsertBase& state);
+
+    void ensure_bptree_offsets(Array& offsets);
+    void create_bptree_offsets(Array& offsets, int_fast64_t first_value);
+
+    bool do_erase_bptree_elem(size_t elem_ndx, EraseHandler&);
+
+    template<IndexMethod method, class T>
+    size_t index_string(StringData value, IntegerColumn& result, ref_type& result_ref,
+                             ColumnBase* column) const;
+protected:
+//    void add_positive_local(int64_t value);
+
+    // Includes array header. Not necessarily 8-byte aligned.
+    virtual size_t calc_byte_len(size_t num_items, size_t width) const;
+
+    virtual size_t calc_item_count(size_t bytes, size_t width) const noexcept;
+
+    bool get_is_inner_bptree_node_from_header() const noexcept;
+    bool get_hasrefs_from_header() const noexcept;
+    bool get_context_flag_from_header() const noexcept;
+    WidthType get_wtype_from_header() const noexcept;
+    uint_least8_t get_width_from_header() const noexcept;
+    size_t get_size_from_header() const noexcept;
+
+    // Undefined behavior if m_alloc.is_read_only(m_ref) returns true
+    size_t get_capacity_from_header() const noexcept;
+
+    void set_header_is_inner_bptree_node(bool value) noexcept;
+    void set_header_hasrefs(bool value) noexcept;
+    void set_header_context_flag(bool value) noexcept;
+    void set_header_wtype(WidthType value) noexcept;
+    void set_header_width(int value) noexcept;
+    void set_header_size(size_t value) noexcept;
+    void set_header_capacity(size_t value) noexcept;
+
+    static void set_header_is_inner_bptree_node(bool value, char* header) noexcept;
+    static void set_header_hasrefs(bool value, char* header) noexcept;
+    static void set_header_context_flag(bool value, char* header) noexcept;
+    static void set_header_wtype(WidthType value, char* header) noexcept;
+    static void set_header_width(int value, char* header) noexcept;
+    static void set_header_size(size_t value, char* header) noexcept;
+    static void set_header_capacity(size_t value, char* header) noexcept;
+
+    static void init_header(char* header, bool is_inner_bptree_node, bool has_refs,
+                            bool context_flag, WidthType width_type, int width,
+                            size_t size, size_t capacity) noexcept;
+
+
+    // This returns the minimum value ("lower bound") of the representable values
+    // for the given bit width. Valid widths are 0, 1, 2, 4, 8, 16, 32, and 64.
+    template<size_t width>
+    static int_fast64_t lbound_for_width() noexcept;
+
+    static int_fast64_t lbound_for_width(size_t width) noexcept;
+
+    // This returns the maximum value ("inclusive upper bound") of the representable values
+    // for the given bit width. Valid widths are 0, 1, 2, 4, 8, 16, 32, and 64.
+    template<size_t width>
+    static int_fast64_t ubound_for_width() noexcept;
+
+    static int_fast64_t ubound_for_width(size_t width) noexcept;
+
+    template<size_t width>
+    void set_width() noexcept;
+    void set_width(size_t) noexcept;
+    void alloc(size_t init_size, size_t width);
+    void copy_on_write();
+
+private:
+
+    template<size_t w>
+    int64_t sum(size_t start, size_t end) const;
+
+    template<bool max, size_t w>
+    bool minmax(int64_t& result, size_t start, size_t end, size_t* return_ndx) const;
+
+    template<size_t w>
+    size_t find_gte(const int64_t target, size_t start, Array const* indirection) const;
+
+    template<size_t w>
+    size_t adjust_ge(size_t start, size_t end, int_fast64_t limit, int_fast64_t diff);
+
+protected:
+    /// The total size in bytes (including the header) of a new empty
+    /// array. Must be a multiple of 8 (i.e., 64-bit aligned).
+    static const size_t initial_capacity = 128;
+
+    /// It is an error to specify a non-zero value unless the width
+    /// type is wtype_Bits. It is also an error to specify a non-zero
+    /// size if the width type is wtype_Ignore.
+    static MemRef create(Type, bool context_flag, WidthType, size_t size,
+                         int_fast64_t value, Allocator&);
+
+    static MemRef clone(MemRef header, Allocator& alloc, Allocator& target_alloc);
+
+    /// Get the address of the header of this array.
+    char* get_header() noexcept;
+
+    /// Same as get_byte_size().
+    static size_t get_byte_size_from_header(const char*) noexcept;
+
+    // Undefined behavior if array is in immutable memory
+    static size_t get_capacity_from_header(const char*) noexcept;
+
+    // Overriding method in ArrayParent
+    void update_child_ref(size_t, ref_type) override;
+
+    // Overriding method in ArrayParent
+    ref_type get_child_ref(size_t) const noexcept override;
+
+    void destroy_children(size_t offset = 0) noexcept;
+
+#ifdef REALM_DEBUG
+    std::pair<ref_type, size_t>
+    get_to_dot_parent(size_t ndx_in_parent) const override;
+#endif
+
+protected:
+    // Getters and Setters for adaptive-packed arrays
+    typedef int64_t (Array::*Getter)(size_t) const; // Note: getters must not throw
+    typedef void (Array::*Setter)(size_t, int64_t);
+    typedef bool (Array::*Finder)(int64_t, size_t, size_t, size_t, QueryState<int64_t>*) const;
+    typedef void (Array::*ChunkGetter)(size_t, int64_t res[8]) const; // Note: getters must not throw
+
+    struct VTable {
+        Getter getter;
+        ChunkGetter chunk_getter;
+        Setter setter;
+        Finder finder[cond_VTABLE_FINDER_COUNT]; // one for each active function pointer
+    };
+    template<size_t w>
+    struct VTableForWidth;
+
+protected:
+
+    /// Takes a 64-bit value and returns the minimum number of bits needed
+    /// to fit the value. For alignment this is rounded up to nearest
+    /// log2. Posssible results {0, 1, 2, 4, 8, 16, 32, 64}
+    static size_t bit_width(int64_t value);
+
+#ifdef REALM_DEBUG
+    void report_memory_usage_2(MemUsageHandler&) const;
+#endif
+
+private:
+    Getter m_getter = nullptr; // cached to avoid indirection
+    const VTable* m_vtable = nullptr;
+
+public:
+    // FIXME: Should not be public
+    char* m_data = nullptr; // Points to first byte after header
+
+#if REALM_ENABLE_MEMDEBUG
+    // If m_no_relocation is false, then copy_on_write() will always relocate this array, regardless if it's
+    // required or not. If it's true, then it will never relocate, which is currently only expeted inside 
+    // GroupWriter::write_group() due to a unique chicken/egg problem (see description there).
+    bool m_no_relocation = false;
+#endif
+
+protected:
+    int64_t m_lbound;       // min number that can be stored with current m_width
+    int64_t m_ubound;       // max number that can be stored with current m_width
+
+    size_t m_size = 0;     // Number of elements currently stored.
+    size_t m_capacity = 0; // Number of elements that fit inside the allocated memory.
+
+    Allocator& m_alloc;
+private:
+    size_t m_ref;
+    ArrayParent* m_parent = nullptr;
+    size_t m_ndx_in_parent = 0; // Ignored if m_parent is null.
+
+protected:
+    uint_least8_t m_width = 0;  // Size of an element (meaning depend on type of array).
+    bool m_is_inner_bptree_node; // This array is an inner node of B+-tree.
+    bool m_has_refs;        // Elements whose first bit is zero are refs to subarrays.
+    bool m_context_flag;    // Meaning depends on context.
+
+private:
+    ref_type do_write_shallow(_impl::ArrayWriterBase&) const;
+    ref_type do_write_deep(_impl::ArrayWriterBase&, bool only_if_modified) const;
+    static size_t calc_byte_size(WidthType wtype, size_t size, uint_least8_t width) noexcept;
+
+    friend class SlabAlloc;
+    friend class GroupWriter;
+    friend class StringColumn;
+};
+
+
+class Array::NodeInfo {
+public:
+    MemRef m_mem;
+    Array* m_parent;
+    size_t m_ndx_in_parent;
+    size_t m_offset, m_size;
+};
+
+class Array::VisitHandler {
+public:
+    virtual bool visit(const NodeInfo& leaf_info) = 0;
+    virtual ~VisitHandler() noexcept {}
+};
+
+
+class Array::UpdateHandler {
+public:
+    virtual void update(MemRef, ArrayParent*, size_t leaf_ndx_in_parent,
+                        size_t elem_ndx_in_leaf) = 0;
+    virtual ~UpdateHandler() noexcept {}
+};
+
+
+class Array::EraseHandler {
+public:
+    /// If the specified leaf has more than one element, this function
+    /// must erase the specified element from the leaf and return
+    /// false. Otherwise, when the leaf has a single element, this
+    /// function must return true without modifying the leaf. If \a
+    /// elem_ndx_in_leaf is `npos`, it refers to the last element in
+    /// the leaf. The implementation of this function must be
+    /// exception safe. This function is guaranteed to be called at
+    /// most once during each execution of Array::erase_bptree_elem(),
+    /// and *exactly* once during each *successful* execution of
+    /// Array::erase_bptree_elem().
+    virtual bool erase_leaf_elem(MemRef, ArrayParent*,
+                                 size_t leaf_ndx_in_parent,
+                                 size_t elem_ndx_in_leaf) = 0;
+
+    virtual void destroy_leaf(MemRef leaf_mem) noexcept = 0;
+
+    /// Must replace the current root with the specified leaf. The
+    /// implementation of this function must not destroy the
+    /// underlying root node, or any of its children, as that will be
+    /// done by Array::erase_bptree_elem(). The implementation of this
+    /// function must be exception safe.
+    virtual void replace_root_by_leaf(MemRef leaf_mem) = 0;
+
+    /// Same as replace_root_by_leaf(), but must replace the root with
+    /// an empty leaf. Also, if this function is called during an
+    /// execution of Array::erase_bptree_elem(), it is guaranteed that
+    /// it will be preceeded by a call to erase_leaf_elem().
+    virtual void replace_root_by_empty_leaf() = 0;
+
+    virtual ~EraseHandler() noexcept {}
+};
+
+
+
+
+
+// Implementation:
+
+class QueryStateBase { virtual void dyncast(){} };
+
+template<>
+class QueryState<int64_t>: public QueryStateBase {
+public:
+    int64_t m_state;
+    size_t m_match_count;
+    size_t m_limit;
+    size_t m_minmax_index; // used only for min/max, to save index of current min/max value
+
+    template<Action action>
+    bool uses_val()
+    {
+        if (action == act_Max || action == act_Min || action == act_Sum)
+            return true;
+        else
+            return false;
+    }
+
+    void init(Action action, IntegerColumn* akku, size_t limit)
+    {
+        m_match_count = 0;
+        m_limit = limit;
+        m_minmax_index = not_found;
+
+        if (action == act_Max)
+            m_state = -0x7fffffffffffffffLL - 1LL;
+        else if (action == act_Min)
+            m_state = 0x7fffffffffffffffLL;
+        else if (action == act_ReturnFirst)
+            m_state = not_found;
+        else if (action == act_Sum)
+            m_state = 0;
+        else if (action == act_Count)
+            m_state = 0;
+        else if (action == act_FindAll)
+            m_state = reinterpret_cast<int64_t>(akku);
+        else if (action == act_CallbackIdx) {
+        }
+        else {
+            REALM_ASSERT_DEBUG(false);
+        }
+    }
+
+    template<Action action, bool pattern>
+    inline bool match(size_t index, uint64_t indexpattern, int64_t value)
+    {
+        if (pattern) {
+            if (action == act_Count) {
+                // If we are close to 'limit' argument in query, we cannot count-up a complete chunk. Count up single
+                // elements instead
+                if (m_match_count + 64 >= m_limit)
+                    return false;
+
+                m_state += fast_popcount64(indexpattern);
+                m_match_count = size_t(m_state);
+                return true;
+            }
+            // Other aggregates cannot (yet) use bit pattern for anything. Make Array-finder call with pattern = false instead
+            return false;
+        }
+
+        ++m_match_count;
+
+        if (action == act_Max) {
+            if (value > m_state) {
+                m_state = value;
+                m_minmax_index = index;
+            }
+        }
+        else if (action == act_Min) {
+            if (value < m_state) {
+                m_state = value;
+                m_minmax_index = index;
+            }
+        }
+        else if (action == act_Sum)
+            m_state += value;
+        else if (action == act_Count) {
+            m_state++;
+            m_match_count = size_t(m_state);
+        }
+        else if (action == act_FindAll) {
+            Array::add_to_column(reinterpret_cast<IntegerColumn*>(m_state), index);
+        }
+        else if (action == act_ReturnFirst) {
+            m_state = index;
+            return false;
+        }
+        else {
+            REALM_ASSERT_DEBUG(false);
+        }
+        return (m_limit > m_match_count);
+    }
+
+    template<Action action, bool pattern>
+    inline bool match(size_t index, uint64_t indexpattern, util::Optional<int64_t> value)
+    {
+        // FIXME: This is a temporary hack for nullable integers.
+        if (value) {
+            return match<action, pattern>(index, indexpattern, *value);
+        }
+
+        // If value is null, the only sensible actions are count, find_all, and return first.
+        // Max, min, and sum should all have no effect.
+        if (action == act_Count) {
+            m_state++;
+            m_match_count = size_t(m_state);
+        }
+        else if (action == act_FindAll) {
+            Array::add_to_column(reinterpret_cast<IntegerColumn*>(m_state), index);
+        }
+        else if (action == act_ReturnFirst) {
+            m_match_count++;
+            m_state = index;
+            return false;
+        }
+        return m_limit > m_match_count;
+    }
+};
+
+// Used only for Basic-types: currently float and double
+template<class R>
+class QueryState : public QueryStateBase {
+public:
+    R m_state;
+    size_t m_match_count;
+    size_t m_limit;
+    size_t m_minmax_index; // used only for min/max, to save index of current min/max value
+
+    template<Action action>
+    bool uses_val()
+    {
+        return (action == act_Max || action == act_Min || action == act_Sum || action == act_Count);
+    }
+
+    void init(Action action, Array*, size_t limit)
+    {
+        REALM_ASSERT((std::is_same<R, float>::value ||
+                               std::is_same<R, double>::value));
+        m_match_count = 0;
+        m_limit = limit;
+        m_minmax_index = not_found;
+
+        if (action == act_Max)
+            m_state = -std::numeric_limits<R>::infinity();
+        else if (action == act_Min)
+            m_state = std::numeric_limits<R>::infinity();
+        else if (action == act_Sum)
+            m_state = 0.0;
+        else {
+            REALM_ASSERT_DEBUG(false);
+        }
+    }
+
+    template<Action action, bool pattern, typename resulttype>
+    inline bool match(size_t index, uint64_t /*indexpattern*/, resulttype value)
+    {
+        if (pattern)
+            return false;
+
+        static_assert(action == act_Sum || action == act_Max || action == act_Min || action == act_Count,
+                      "Search action not supported");
+
+        if (action == act_Count) {
+            ++m_match_count;
+        }
+        else if (!null::is_null_float(value)) {
+            ++m_match_count;
+            if (action == act_Max) {
+                if (value > m_state) {
+                    m_state = value;
+                    m_minmax_index = index;
+                }
+            }
+            else if (action == act_Min) {
+                if (value < m_state) {
+                    m_state = value;
+                    m_minmax_index = index;
+                }
+            }
+            else if (action == act_Sum)
+                m_state += value;
+            else {
+                REALM_ASSERT_DEBUG(false);
+            }
+        }
+
+        return (m_limit > m_match_count);
+    }
+};
+
+inline bool RefOrTagged::is_ref() const noexcept
+{
+    return (m_value & 1) == 0;
+}
+
+inline bool RefOrTagged::is_tagged() const noexcept
+{
+    return !is_ref();
+}
+
+inline ref_type RefOrTagged::get_as_ref() const noexcept
+{
+    // to_ref() is defined in <alloc.hpp>
+    return to_ref(m_value);
+}
+
+inline uint_fast64_t RefOrTagged::get_as_int() const noexcept
+{
+    // The bitwise AND is there in case uint_fast64_t is wider than 64 bits.
+    return (uint_fast64_t(m_value) & 0xFFFFFFFFFFFFFFFFULL) >> 1;
+}
+
+inline RefOrTagged RefOrTagged::make_ref(ref_type ref) noexcept
+{
+    // from_ref() is defined in <alloc.hpp>
+    int_fast64_t value = from_ref(ref);
+    return RefOrTagged(value);
+}
+
+inline RefOrTagged RefOrTagged::make_tagged(uint_fast64_t i) noexcept
+{
+    REALM_ASSERT(i < (1ULL << 63));
+    int_fast64_t value = util::from_twos_compl<int_fast64_t>((i << 1) | 1);
+    return RefOrTagged(value);
+}
+
+inline RefOrTagged::RefOrTagged(int_fast64_t value) noexcept:
+    m_value(value)
+{
+}
+
+inline Array::Array(Allocator& allocator) noexcept:
+    m_alloc(allocator)
+{
+}
+
+// Fastest way to instantiate an Array. For use with GetDirect() that only fills out m_width, m_data
+// and a few other basic things needed for read-only access. Or for use if you just want a way to call
+// some methods written in Array.*
+inline Array::Array(no_prealloc_tag) noexcept:
+    m_alloc(*static_cast<Allocator*>(0))
+{
+}
+
+
+inline void Array::create(Type type, bool context_flag, size_t length, int_fast64_t value)
+{
+    MemRef mem = create_array(type, context_flag, length, value, m_alloc); // Throws
+    init_from_mem(mem);
+}
+
+
+inline void Array::init_from_ref(ref_type ref) noexcept
+{
+    REALM_ASSERT_DEBUG(ref);
+    char* header = m_alloc.translate(ref);
+    init_from_mem(MemRef(header, ref, m_alloc));
+}
+
+
+inline void Array::init_from_parent() noexcept
+{
+    ref_type ref = get_ref_from_parent();
+    init_from_ref(ref);
+}
+
+
+inline Array::Type Array::get_type() const noexcept
+{
+    if (m_is_inner_bptree_node) {
+        REALM_ASSERT_DEBUG(m_has_refs);
+        return type_InnerBptreeNode;
+    }
+    if (m_has_refs)
+        return type_HasRefs;
+    return type_Normal;
+}
+
+
+inline void Array::get_chunk(size_t ndx, int64_t res[8]) const noexcept
+{
+    REALM_ASSERT_DEBUG(ndx < m_size);
+    (this->*(m_vtable->chunk_getter))(ndx, res);
+}
+
+
+inline int64_t Array::get(size_t ndx) const noexcept
+{
+    REALM_ASSERT_DEBUG(is_attached());
+    REALM_ASSERT_DEBUG(ndx < m_size);
+    return (this->*m_getter)(ndx);
+
+// Two ideas that are not efficient but may be worth looking into again:
+/*
+    // Assume correct width is found early in REALM_TEMPEX, which is the case for B tree offsets that
+    // are probably either 2^16 long. Turns out to be 25% faster if found immediately, but 50-300% slower
+    // if found later
+    REALM_TEMPEX(return get, (ndx));
+*/
+/*
+    // Slightly slower in both of the if-cases. Also needs an matchcount m_size check too, to avoid
+    // reading beyond array.
+    if (m_width >= 8 && m_size > ndx + 7)
+        return get<64>(ndx >> m_shift) & m_widthmask;
+    else
+        return (this->*(m_vtable->getter))(ndx);
+*/
+}
+
+inline int64_t Array::front() const noexcept
+{
+    return get(0);
+}
+
+inline int64_t Array::back() const noexcept
+{
+    return get(m_size - 1);
+}
+
+inline ref_type Array::get_as_ref(size_t ndx) const noexcept
+{
+    REALM_ASSERT_DEBUG(is_attached());
+    REALM_ASSERT_DEBUG(m_has_refs);
+    int64_t v = get(ndx);
+    return to_ref(v);
+}
+
+inline RefOrTagged Array::get_as_ref_or_tagged(size_t ndx) const noexcept
+{
+    REALM_ASSERT(has_refs());
+    return RefOrTagged(get(ndx));
+}
+
+inline void Array::set(size_t ndx, RefOrTagged ref_or_tagged)
+{
+    REALM_ASSERT(has_refs());
+    set(ndx, ref_or_tagged.m_value); // Throws
+}
+
+inline void Array::add(RefOrTagged ref_or_tagged)
+{
+    REALM_ASSERT(has_refs());
+    add(ref_or_tagged.m_value); // Throws
+}
+
+inline void Array::ensure_minimum_width(RefOrTagged ref_or_tagged)
+{
+    REALM_ASSERT(has_refs());
+    ensure_minimum_width(ref_or_tagged.m_value); // Throws
+}
+
+inline bool Array::is_inner_bptree_node() const noexcept
+{
+    return m_is_inner_bptree_node;
+}
+
+inline bool Array::has_refs() const noexcept
+{
+    return m_has_refs;
+}
+
+inline bool Array::get_context_flag() const noexcept
+{
+    return m_context_flag;
+}
+
+inline void Array::set_context_flag(bool value) noexcept
+{
+    m_context_flag = value;
+    set_header_context_flag(value);
+}
+
+inline ref_type Array::get_ref() const noexcept
+{
+    return m_ref;
+}
+
+inline MemRef Array::get_mem() const noexcept
+{
+    return MemRef(get_header_from_data(m_data), m_ref, m_alloc);
+}
+
+inline void Array::destroy() noexcept
+{
+    if (!is_attached())
+        return;
+    char* header = get_header_from_data(m_data);
+    m_alloc.free_(m_ref, header);
+    m_data = nullptr;
+}
+
+inline void Array::destroy_deep() noexcept
+{
+    if (!is_attached())
+        return;
+
+    if (m_has_refs)
+        destroy_children();
+
+    char* header = get_header_from_data(m_data);
+    m_alloc.free_(m_ref, header);
+    m_data = nullptr;
+}
+
+inline ref_type Array::write(_impl::ArrayWriterBase& out, bool deep, bool only_if_modified) const
+{
+    REALM_ASSERT(is_attached());
+
+    if (only_if_modified && m_alloc.is_read_only(m_ref))
+        return m_ref;
+
+    if (!deep || !m_has_refs)
+        return do_write_shallow(out); // Throws
+
+    return do_write_deep(out, only_if_modified); // Throws
+}
+
+inline ref_type Array::write(ref_type ref, Allocator& alloc, _impl::ArrayWriterBase& out,
+                             bool only_if_modified)
+{
+    if (only_if_modified && alloc.is_read_only(ref))
+        return ref;
+
+    Array array(alloc);
+    array.init_from_ref(ref);
+
+    if (!array.m_has_refs)
+        return array.do_write_shallow(out); // Throws
+
+    return array.do_write_deep(out, only_if_modified); // Throws
+}
+
+inline void Array::add(int_fast64_t value)
+{
+    insert(m_size, value);
+}
+
+inline void Array::erase(size_t ndx)
+{
+    // This can throw, but only if array is currently in read-only
+    // memory.
+    move(ndx+1, size(), ndx);
+
+    // Update size (also in header)
+    --m_size;
+    set_header_size(m_size);
+}
+
+
+inline void Array::erase(size_t begin, size_t end)
+{
+    if (begin != end) {
+        // This can throw, but only if array is currently in read-only memory.
+        move(end, size(), begin); // Throws
+
+        // Update size (also in header)
+        m_size -= end - begin;
+        set_header_size(m_size);
+    }
+}
+
+inline void Array::clear()
+{
+    truncate(0); // Throws
+}
+
+inline void Array::clear_and_destroy_children()
+{
+    truncate_and_destroy_children(0);
+}
+
+inline void Array::destroy(ref_type ref, Allocator& alloc) noexcept
+{
+    destroy(MemRef(ref, alloc), alloc);
+}
+
+inline void Array::destroy(MemRef mem, Allocator& alloc) noexcept
+{
+    alloc.free_(mem);
+}
+
+inline void Array::destroy_deep(ref_type ref, Allocator& alloc) noexcept
+{
+    destroy_deep(MemRef(ref, alloc), alloc);
+}
+
+inline void Array::destroy_deep(MemRef mem, Allocator& alloc) noexcept
+{
+    if (!get_hasrefs_from_header(mem.get_addr())) {
+        alloc.free_(mem);
+        return;
+    }
+    Array array(alloc);
+    array.init_from_mem(mem);
+    array.destroy_deep();
+}
+
+
+inline void Array::adjust(size_t ndx, int_fast64_t diff)
+{
+    // FIXME: Should be optimized
+    REALM_ASSERT_3(ndx, <=, m_size);
+    int_fast64_t v = get(ndx);
+    set(ndx, int64_t(v + diff)); // Throws
+}
+
+inline void Array::adjust(size_t begin, size_t end, int_fast64_t diff)
+{
+    // FIXME: Should be optimized
+    for (size_t i = begin; i != end; ++i)
+        adjust(i, diff); // Throws
+}
+
+
+
+//-------------------------------------------------
+
+inline bool Array::get_is_inner_bptree_node_from_header(const char* header) noexcept
+{
+    typedef unsigned char uchar;
+    const uchar* h = reinterpret_cast<const uchar*>(header);
+    return (int(h[4]) & 0x80) != 0;
+}
+inline bool Array::get_hasrefs_from_header(const char* header) noexcept
+{
+    typedef unsigned char uchar;
+    const uchar* h = reinterpret_cast<const uchar*>(header);
+    return (int(h[4]) & 0x40) != 0;
+}
+inline bool Array::get_context_flag_from_header(const char* header) noexcept
+{
+    typedef unsigned char uchar;
+    const uchar* h = reinterpret_cast<const uchar*>(header);
+    return (int(h[4]) & 0x20) != 0;
+}
+inline Array::WidthType Array::get_wtype_from_header(const char* header) noexcept
+{
+    typedef unsigned char uchar;
+    const uchar* h = reinterpret_cast<const uchar*>(header);
+    return WidthType((int(h[4]) & 0x18) >> 3);
+}
+inline uint_least8_t Array::get_width_from_header(const char* header) noexcept
+{
+    typedef unsigned char uchar;
+    const uchar* h = reinterpret_cast<const uchar*>(header);
+    return uint_least8_t((1 << (int(h[4]) & 0x07)) >> 1);
+}
+inline size_t Array::get_size_from_header(const char* header) noexcept
+{
+    typedef unsigned char uchar;
+    const uchar* h = reinterpret_cast<const uchar*>(header);
+    return (size_t(h[5]) << 16) + (size_t(h[6]) << 8) + h[7];
+}
+inline size_t Array::get_capacity_from_header(const char* header) noexcept
+{
+    typedef unsigned char uchar;
+    const uchar* h = reinterpret_cast<const uchar*>(header);
+    return (size_t(h[0]) << 16) + (size_t(h[1]) << 8) + h[2];
+}
+
+
+inline char* Array::get_data_from_header(char* header) noexcept
+{
+    return header + header_size;
+}
+inline char* Array::get_header_from_data(char* data) noexcept
+{
+    return data - header_size;
+}
+inline const char* Array::get_data_from_header(const char* header) noexcept
+{
+    return get_data_from_header(const_cast<char*>(header));
+}
+
+
+inline bool Array::get_is_inner_bptree_node_from_header() const noexcept
+{
+    return get_is_inner_bptree_node_from_header(get_header_from_data(m_data));
+}
+inline bool Array::get_hasrefs_from_header() const noexcept
+{
+    return get_hasrefs_from_header(get_header_from_data(m_data));
+}
+inline bool Array::get_context_flag_from_header() const noexcept
+{
+    return get_context_flag_from_header(get_header_from_data(m_data));
+}
+inline Array::WidthType Array::get_wtype_from_header() const noexcept
+{
+    return get_wtype_from_header(get_header_from_data(m_data));
+}
+inline uint_least8_t Array::get_width_from_header() const noexcept
+{
+    return get_width_from_header(get_header_from_data(m_data));
+}
+inline size_t Array::get_size_from_header() const noexcept
+{
+    return get_size_from_header(get_header_from_data(m_data));
+}
+inline size_t Array::get_capacity_from_header() const noexcept
+{
+    return get_capacity_from_header(get_header_from_data(m_data));
+}
+
+
+inline void Array::set_header_is_inner_bptree_node(bool value, char* header) noexcept
+{
+    typedef unsigned char uchar;
+    uchar* h = reinterpret_cast<uchar*>(header);
+    h[4] = uchar((int(h[4]) & ~0x80) | int(value) << 7);
+}
+
+inline void Array::set_header_hasrefs(bool value, char* header) noexcept
+{
+    typedef unsigned char uchar;
+    uchar* h = reinterpret_cast<uchar*>(header);
+    h[4] = uchar((int(h[4]) & ~0x40) | int(value) << 6);
+}
+
+inline void Array::set_header_context_flag(bool value, char* header) noexcept
+{
+    typedef unsigned char uchar;
+    uchar* h = reinterpret_cast<uchar*>(header);
+    h[4] = uchar((int(h[4]) & ~0x20) | int(value) << 5);
+}
+
+inline void Array::set_header_wtype(WidthType value, char* header) noexcept
+{
+    // Indicates how to calculate size in bytes based on width
+    // 0: bits      (width/8) * size
+    // 1: multiply  width * size
+    // 2: ignore    1 * size
+    typedef unsigned char uchar;
+    uchar* h = reinterpret_cast<uchar*>(header);
+    h[4] = uchar((int(h[4]) & ~0x18) | int(value) << 3);
+}
+
+inline void Array::set_header_width(int value, char* header) noexcept
+{
+    // Pack width in 3 bits (log2)
+    int w = 0;
+    while (value) {
+        ++w;
+        value >>= 1;
+    }
+    REALM_ASSERT_3(w, <, 8);
+
+    typedef unsigned char uchar;
+    uchar* h = reinterpret_cast<uchar*>(header);
+    h[4] = uchar((int(h[4]) & ~0x7) | w);
+}
+
+inline void Array::set_header_size(size_t value, char* header) noexcept
+{
+    REALM_ASSERT_3(value, <=, max_array_payload);
+    typedef unsigned char uchar;
+    uchar* h = reinterpret_cast<uchar*>(header);
+    h[5] = uchar((value >> 16) & 0x000000FF);
+    h[6] = uchar((value >>  8) & 0x000000FF);
+    h[7] = uchar( value        & 0x000000FF);
+}
+
+// Note: There is a copy of this function is test_alloc.cpp
+inline void Array::set_header_capacity(size_t value, char* header) noexcept
+{
+    REALM_ASSERT_3(value, <=, max_array_payload);
+    typedef unsigned char uchar;
+    uchar* h = reinterpret_cast<uchar*>(header);
+    h[0] = uchar((value >> 16) & 0x000000FF);
+    h[1] = uchar((value >>  8) & 0x000000FF);
+    h[2] = uchar( value        & 0x000000FF);
+}
+
+
+
+inline void Array::set_header_is_inner_bptree_node(bool value) noexcept
+{
+    set_header_is_inner_bptree_node(value, get_header_from_data(m_data));
+}
+inline void Array::set_header_hasrefs(bool value) noexcept
+{
+    set_header_hasrefs(value, get_header_from_data(m_data));
+}
+inline void Array::set_header_context_flag(bool value) noexcept
+{
+    set_header_context_flag(value, get_header_from_data(m_data));
+}
+inline void Array::set_header_wtype(WidthType value) noexcept
+{
+    set_header_wtype(value, get_header_from_data(m_data));
+}
+inline void Array::set_header_width(int value) noexcept
+{
+    set_header_width(value, get_header_from_data(m_data));
+}
+inline void Array::set_header_size(size_t value) noexcept
+{
+    set_header_size(value, get_header_from_data(m_data));
+}
+inline void Array::set_header_capacity(size_t value) noexcept
+{
+    set_header_capacity(value, get_header_from_data(m_data));
+}
+
+
+inline Array::Type Array::get_type_from_header(const char* header) noexcept
+{
+    if (get_is_inner_bptree_node_from_header(header))
+        return type_InnerBptreeNode;
+    if (get_hasrefs_from_header(header))
+        return type_HasRefs;
+    return type_Normal;
+}
+
+
+inline char* Array::get_header() noexcept
+{
+    return get_header_from_data(m_data);
+}
+
+inline size_t Array::calc_byte_size(WidthType wtype, size_t size, uint_least8_t width) noexcept
+{
+    size_t num_bytes = 0;
+    switch (wtype) {
+        case wtype_Bits: {
+            // Current assumption is that size is at most 2^24 and that width is at most 64.
+            // In that case the following will never overflow. (Assuming that size_t is at least 32 bits)
+            REALM_ASSERT_3(size, <, 0x1000000);
+            size_t num_bits = size * width;
+            num_bytes = (num_bits + 7) >> 3;
+            break;
+        }
+        case wtype_Multiply: {
+            num_bytes = size * width;
+            break;
+        }
+        case wtype_Ignore:
+            num_bytes = size;
+            break;
+    }
+
+    // Ensure 8-byte alignment
+    num_bytes = (num_bytes + 7) & ~size_t(7);
+
+    num_bytes += header_size;
+
+    return num_bytes;
+}
+
+inline size_t Array::get_byte_size() const noexcept
+{
+    const char* header = get_header_from_data(m_data);
+    WidthType wtype = get_wtype_from_header(header);
+    size_t num_bytes = calc_byte_size(wtype, m_size, m_width);
+
+    REALM_ASSERT_7(m_alloc.is_read_only(m_ref), ==, true, ||,
+                   num_bytes, <=, get_capacity_from_header(header));
+
+    return num_bytes;
+}
+
+
+inline size_t Array::get_byte_size_from_header(const char* header) noexcept
+{
+    size_t size = get_size_from_header(header);
+    uint_least8_t width = get_width_from_header(header);
+    WidthType wtype = get_wtype_from_header(header);
+    size_t num_bytes = calc_byte_size(wtype, size, width);
+
+    return num_bytes;
+}
+
+
+inline void Array::init_header(char* header, bool is_inner_bptree_node, bool has_refs,
+                               bool context_flag, WidthType width_type, int width,
+                               size_t size, size_t capacity) noexcept
+{
+    // Note: Since the header layout contains unallocated bit and/or
+    // bytes, it is important that we put the entire header into a
+    // well defined state initially.
+    std::fill(header, header + header_size, 0);
+    set_header_is_inner_bptree_node(is_inner_bptree_node, header);
+    set_header_hasrefs(has_refs, header);
+    set_header_context_flag(context_flag, header);
+    set_header_wtype(width_type, header);
+    set_header_width(width, header);
+    set_header_size(size, header);
+    set_header_capacity(capacity, header);
+}
+
+
+//-------------------------------------------------
+
+inline MemRef Array::clone_deep(Allocator& target_alloc) const
+{
+    char* header = get_header_from_data(m_data);
+    return clone(MemRef(header, m_ref, m_alloc), m_alloc, target_alloc); // Throws
+}
+
+inline void Array::move_assign(Array& a) noexcept
+{
+    REALM_ASSERT_3(&get_alloc(), ==, &a.get_alloc());
+    // FIXME: Be carefull with the old parent info here. Should it be
+    // copied?
+
+    // FIXME: It will likely be a lot better for the optimizer if we
+    // did a member-wise copy, rather than recreating the state from
+    // the referenced data. This is important because TableView efficiency, for
+    // example, relies on long chains of moves to be optimized away
+    // completely. This change should be a 'no-brainer'.
+    destroy_deep();
+    init_from_ref(a.get_ref());
+    a.detach();
+}
+
+inline MemRef Array::create_empty_array(Type type, bool context_flag, Allocator& alloc)
+{
+    size_t size = 0;
+    int_fast64_t value = 0;
+    return create_array(type, context_flag, size, value, alloc); // Throws
+}
+
+inline MemRef Array::create_array(Type type, bool context_flag, size_t size, int_fast64_t value,
+                                  Allocator& alloc)
+{
+    return create(type, context_flag, wtype_Bits, size, value, alloc); // Throws
+}
+
+inline bool Array::has_parent() const noexcept
+{
+    return m_parent != nullptr;
+}
+
+inline ArrayParent* Array::get_parent() const noexcept
+{
+    return m_parent;
+}
+
+inline void Array::set_parent(ArrayParent* parent, size_t ndx_in_parent) noexcept
+{
+    m_parent = parent;
+    m_ndx_in_parent = ndx_in_parent;
+}
+
+inline size_t Array::get_ndx_in_parent() const noexcept
+{
+    return m_ndx_in_parent;
+}
+
+inline void Array::set_ndx_in_parent(size_t ndx) noexcept
+{
+    m_ndx_in_parent = ndx;
+}
+
+inline void Array::adjust_ndx_in_parent(int diff) noexcept
+{
+    // Note that `diff` is promoted to an unsigned type, and that
+    // C++03 still guarantees the expected result regardless of the
+    // sizes of `int` and `decltype(m_ndx_in_parent)`.
+    m_ndx_in_parent += diff;
+}
+
+inline ref_type Array::get_ref_from_parent() const noexcept
+{
+    ref_type ref = m_parent->get_child_ref(m_ndx_in_parent);
+    return ref;
+}
+
+inline bool Array::is_attached() const noexcept
+{
+    return m_data != nullptr;
+}
+
+inline void Array::detach() noexcept
+{
+    m_data = nullptr;
+}
+
+inline size_t Array::size() const noexcept
+{
+    REALM_ASSERT_DEBUG(is_attached());
+    return m_size;
+}
+
+inline bool Array::is_empty() const noexcept
+{
+    return size() == 0;
+}
+
+inline size_t Array::get_max_byte_size(size_t num_elems) noexcept
+{
+    int max_bytes_per_elem = 8;
+    return header_size + num_elems * max_bytes_per_elem; // FIXME: Prone to overflow
+}
+
+inline void Array::update_parent()
+{
+    if (m_parent)
+        m_parent->update_child_ref(m_ndx_in_parent, m_ref);
+}
+
+
+inline void Array::update_child_ref(size_t child_ndx, ref_type new_ref)
+{
+    set(child_ndx, new_ref);
+}
+
+inline ref_type Array::get_child_ref(size_t child_ndx) const noexcept
+{
+    return get_as_ref(child_ndx);
+}
+
+inline size_t Array::get_bptree_size() const noexcept
+{
+    REALM_ASSERT_DEBUG(is_inner_bptree_node());
+    int_fast64_t v = back();
+    return size_t(v / 2); // v = 1 + 2*total_elems_in_tree
+}
+
+inline size_t Array::get_bptree_size_from_header(const char* root_header) noexcept
+{
+    REALM_ASSERT_DEBUG(get_is_inner_bptree_node_from_header(root_header));
+    size_t root_size = get_size_from_header(root_header);
+    int_fast64_t v = get(root_header, root_size-1);
+    return size_t(v / 2); // v = 1 + 2*total_elems_in_tree
+}
+
+inline void Array::ensure_bptree_offsets(Array& offsets)
+{
+    int_fast64_t first_value = get(0);
+    if (first_value % 2 == 0) {
+        offsets.init_from_ref(to_ref(first_value));
+    }
+    else {
+        create_bptree_offsets(offsets, first_value); // Throws
+    }
+    offsets.set_parent(this, 0);
+}
+
+
+template<class TreeTraits>
+ref_type Array::bptree_append(TreeInsert<TreeTraits>& state)
+{
+    // FIXME: Consider exception safety. Especially, how can the split
+    // be carried out in an exception safe manner?
+    //
+    // Can split be done as a separate preparation step, such that if
+    // the actual insert fails, the split will still have occured.
+    //
+    // Unfortunately, it requires a rather significant rearrangement
+    // of the insertion flow. Instead of returning the sibling ref
+    // from insert functions, the leaf-insert functions must instead
+    // call the special bptree_insert() function on the parent, which
+    // will then cascade the split towards the root as required.
+    //
+    // At each level where a split is required (starting at the leaf):
+    //
+    //  1. Create the new sibling.
+    //
+    //  2. Copy relevant entries over such that new sibling is in
+    //     its final state.
+    //
+    //  3. Call Array::bptree_insert() on parent with sibling ref.
+    //
+    //  4. Rearrange entries in original sibling and truncate as
+    //     required (must not throw).
+    //
+    // What about the 'offsets' array? It will always be
+    // present. Consider this carefully.
+
+    REALM_ASSERT_DEBUG(size() >= 1 + 1 + 1); // At least one child
+
+    ArrayParent& childs_parent = *this;
+    size_t child_ref_ndx = size() - 2;
+    ref_type child_ref = get_as_ref(child_ref_ndx), new_sibling_ref;
+    char* child_header = static_cast<char*>(m_alloc.translate(child_ref));
+
+    bool child_is_leaf = !get_is_inner_bptree_node_from_header(child_header);
+    if (child_is_leaf) {
+        size_t elem_ndx_in_child = npos; // Append
+        new_sibling_ref =
+            TreeTraits::leaf_insert(MemRef(child_header, child_ref, m_alloc), childs_parent,
+                                    child_ref_ndx, m_alloc, elem_ndx_in_child, state); // Throws
+    }
+    else {
+        Array child(m_alloc);
+        child.init_from_mem(MemRef(child_header, child_ref, m_alloc));
+        child.set_parent(&childs_parent, child_ref_ndx);
+        new_sibling_ref = child.bptree_append(state); // Throws
+    }
+
+    if (REALM_LIKELY(!new_sibling_ref)) {
+        // +2 because stored value is 1 + 2*total_elems_in_subtree
+        adjust(size()-1, +2); // Throws
+        return 0; // Child was not split, so parent was not split either
+    }
+
+    Array offsets(m_alloc);
+    int_fast64_t first_value = get(0);
+    if (first_value % 2 == 0) {
+        // Offsets array is present (general form)
+        offsets.init_from_ref(to_ref(first_value));
+        offsets.set_parent(this, 0);
+    }
+    size_t child_ndx = child_ref_ndx - 1;
+    return insert_bptree_child(offsets, child_ndx, new_sibling_ref, state); // Throws
+}
+
+
+template<class TreeTraits>
+ref_type Array::bptree_insert(size_t elem_ndx, TreeInsert<TreeTraits>& state)
+{
+    REALM_ASSERT_3(size(), >=, 1 + 1 + 1); // At least one child
+
+    // Conversion to general form if in compact form. Since this
+    // conversion will occur from root to leaf, it will maintain
+    // invar:bptree-node-form.
+    Array offsets(m_alloc);
+    ensure_bptree_offsets(offsets); // Throws
+
+    size_t child_ndx, elem_ndx_in_child;
+    if (elem_ndx == 0) {
+        // Optimization for prepend
+        child_ndx = 0;
+        elem_ndx_in_child = 0;
+    }
+    else {
+        // There is a choice to be made when the element is to be
+        // inserted between two subtrees. It can either be appended to
+        // the first subtree, or it can be prepended to the second
+        // one. We currently always append to the first subtree. It is
+        // essentially a matter of using the lower vs. the upper bound
+        // when searching through the offsets array.
+        child_ndx = offsets.lower_bound_int(elem_ndx);
+        REALM_ASSERT_3(child_ndx, <, size() - 2);
+        size_t elem_ndx_offset = child_ndx == 0 ? 0 : to_size_t(offsets.get(child_ndx-1));
+        elem_ndx_in_child = elem_ndx - elem_ndx_offset;
+    }
+
+    ArrayParent& childs_parent = *this;
+    size_t child_ref_ndx = child_ndx + 1;
+    ref_type child_ref = get_as_ref(child_ref_ndx), new_sibling_ref;
+    char* child_header = static_cast<char*>(m_alloc.translate(child_ref));
+    bool child_is_leaf = !get_is_inner_bptree_node_from_header(child_header);
+    if (child_is_leaf) {
+        REALM_ASSERT_3(elem_ndx_in_child, <=, REALM_MAX_BPNODE_SIZE);
+        new_sibling_ref =
+            TreeTraits::leaf_insert(MemRef(child_header, child_ref, m_alloc), childs_parent,
+                                    child_ref_ndx, m_alloc, elem_ndx_in_child, state); // Throws
+    }
+    else {
+        Array child(m_alloc);
+        child.init_from_mem(MemRef(child_header, child_ref, m_alloc));
+        child.set_parent(&childs_parent, child_ref_ndx);
+        new_sibling_ref = child.bptree_insert(elem_ndx_in_child, state); // Throws
+    }
+
+    if (REALM_LIKELY(!new_sibling_ref)) {
+        // +2 because stored value is 1 + 2*total_elems_in_subtree
+        adjust(size()-1, +2); // Throws
+        offsets.adjust(child_ndx, offsets.size(), +1);
+        return 0; // Child was not split, so parent was not split either
+    }
+
+    return insert_bptree_child(offsets, child_ndx, new_sibling_ref, state); // Throws
+}
+
+
+
+//*************************************************************************************
+// Finding code                                                                       *
+//*************************************************************************************
+
+template<size_t w>
+int64_t Array::get(size_t ndx) const noexcept
+{
+    return get_universal<w>(m_data, ndx);
+}
+
+template<size_t w>
+int64_t Array::get_universal(const char* data, size_t ndx) const
+{
+    if (w == 0) {
+        return 0;
+    }
+    else if (w == 1) {
+        size_t offset = ndx >> 3;
+        return (data[offset] >> (ndx & 7)) & 0x01;
+    }
+    else if (w == 2) {
+        size_t offset = ndx >> 2;
+        return (data[offset] >> ((ndx & 3) << 1)) & 0x03;
+    }
+    else if (w == 4) {
+        size_t offset = ndx >> 1;
+        return (data[offset] >> ((ndx & 1) << 2)) & 0x0F;
+    }
+    else if (w == 8) {
+        return *reinterpret_cast<const signed char*>(data + ndx);
+    }
+    else if (w == 16) {
+        size_t offset = ndx * 2;
+        return *reinterpret_cast<const int16_t*>(data + offset);
+    }
+    else if (w == 32) {
+        size_t offset = ndx * 4;
+        return *reinterpret_cast<const int32_t*>(data + offset);
+    }
+    else if (w == 64) {
+        size_t offset = ndx * 8;
+        return *reinterpret_cast<const int64_t*>(data + offset);
+    }
+    else {
+        REALM_ASSERT_DEBUG(false);
+        return int64_t(-1);
+    }
+}
+
+/*
+find() (calls find_optimized()) will call match() for each search result.
+
+If pattern == true:
+    'indexpattern' contains a 64-bit chunk of elements, each of 'width' bits in size where each element indicates a match if its lower bit is set, otherwise
+    it indicates a non-match. 'index' tells the database row index of the first element. You must return true if you chose to 'consume' the chunk or false
+    if not. If not, then Array-finder will afterwards call match() successive times with pattern == false.
+
+If pattern == false:
+    'index' tells the row index of a single match and 'value' tells its value. Return false to make Array-finder break its search or return true to let it continue until
+    'end' or 'limit'.
+
+Array-finder decides itself if - and when - it wants to pass you an indexpattern. It depends on array bit width, match frequency, and whether the arithemetic and
+computations for the given search criteria makes it feasible to construct such a pattern.
+*/
+
+// These wrapper functions only exist to enable a possibility to make the compiler see that 'value' and/or 'index' are unused, such that caller's
+// computation of these values will not be made. Only works if find_action() and find_action_pattern() rewritten as macros. Note: This problem has been fixed in
+// next upcoming array.hpp version
+template<Action action, class Callback>
+bool Array::find_action(size_t index, util::Optional<int64_t> value, QueryState<int64_t>* state, Callback callback) const
+{
+    if (action == act_CallbackIdx)
+        return callback(index);
+    else
+        return state->match<action, false>(index, 0, value);
+}
+template<Action action, class Callback>
+bool Array::find_action_pattern(size_t index, uint64_t pattern, QueryState<int64_t>* state, Callback callback) const
+{
+    static_cast<void>(callback);
+    if (action == act_CallbackIdx) {
+        // Possible future optimization: call callback(index) like in above find_action(), in a loop for each bit set in 'pattern'
+        return false;
+    }
+    return state->match<action, true>(index, pattern, 0);
+}
+
+
+template<size_t width, bool zero>
+uint64_t Array::cascade(uint64_t a) const
+{
+    // Takes a chunk of values as argument and sets the least significant bit for each
+    // element which is zero or non-zero, depending on the template parameter.
+    // Example for zero=true:
+    // width == 4 and a = 0x5fd07a107610f610
+    // will return:       0x0001000100010001
+
+    // static values needed for fast population count
+    const uint64_t m1  = 0x5555555555555555ULL;
+
+    if (width == 1) {
+        return zero ? ~a : a;
+    }
+    else if (width == 2) {
+        // Masks to avoid spillover between segments in cascades
+        const uint64_t c1 = ~0ULL/0x3 * 0x1;
+
+        a |= (a >> 1) & c1; // cascade ones in non-zeroed segments
+        a &= m1;     // isolate single bit in each segment
+        if (zero)
+            a ^= m1; // reverse isolated bits if checking for zeroed segments
+
+        return a;
+    }
+    else if (width == 4) {
+        const uint64_t m  = ~0ULL/0xF * 0x1;
+
+        // Masks to avoid spillover between segments in cascades
+        const uint64_t c1 = ~0ULL/0xF * 0x7;
+        const uint64_t c2 = ~0ULL/0xF * 0x3;
+
+        a |= (a >> 1) & c1; // cascade ones in non-zeroed segments
+        a |= (a >> 2) & c2;
+        a &= m;     // isolate single bit in each segment
+        if (zero)
+            a ^= m; // reverse isolated bits if checking for zeroed segments
+
+        return a;
+    }
+    else if (width == 8) {
+        const uint64_t m  = ~0ULL/0xFF * 0x1;
+
+        // Masks to avoid spillover between segments in cascades
+        const uint64_t c1 = ~0ULL/0xFF * 0x7F;
+        const uint64_t c2 = ~0ULL/0xFF * 0x3F;
+        const uint64_t c3 = ~0ULL/0xFF * 0x0F;
+
+        a |= (a >> 1) & c1; // cascade ones in non-zeroed segments
+        a |= (a >> 2) & c2;
+        a |= (a >> 4) & c3;
+        a &= m;     // isolate single bit in each segment
+        if (zero)
+            a ^= m; // reverse isolated bits if checking for zeroed segments
+
+        return a;
+    }
+    else if (width == 16) {
+        const uint64_t m  = ~0ULL/0xFFFF * 0x1;
+
+        // Masks to avoid spillover between segments in cascades
+        const uint64_t c1 = ~0ULL/0xFFFF * 0x7FFF;
+        const uint64_t c2 = ~0ULL/0xFFFF * 0x3FFF;
+        const uint64_t c3 = ~0ULL/0xFFFF * 0x0FFF;
+        const uint64_t c4 = ~0ULL/0xFFFF * 0x00FF;
+
+        a |= (a >> 1) & c1; // cascade ones in non-zeroed segments
+        a |= (a >> 2) & c2;
+        a |= (a >> 4) & c3;
+        a |= (a >> 8) & c4;
+        a &= m;     // isolate single bit in each segment
+        if (zero)
+            a ^= m; // reverse isolated bits if checking for zeroed segments
+
+        return a;
+    }
+
+    else if (width == 32) {
+        const uint64_t m  = ~0ULL/0xFFFFFFFF * 0x1;
+
+        // Masks to avoid spillover between segments in cascades
+        const uint64_t c1 = ~0ULL/0xFFFFFFFF * 0x7FFFFFFF;
+        const uint64_t c2 = ~0ULL/0xFFFFFFFF * 0x3FFFFFFF;
+        const uint64_t c3 = ~0ULL/0xFFFFFFFF * 0x0FFFFFFF;
+        const uint64_t c4 = ~0ULL/0xFFFFFFFF * 0x00FFFFFF;
+        const uint64_t c5 = ~0ULL/0xFFFFFFFF * 0x0000FFFF;
+
+        a |= (a >> 1) & c1; // cascade ones in non-zeroed segments
+        a |= (a >> 2) & c2;
+        a |= (a >> 4) & c3;
+        a |= (a >> 8) & c4;
+        a |= (a >> 16) & c5;
+        a &= m;     // isolate single bit in each segment
+        if (zero)
+            a ^= m; // reverse isolated bits if checking for zeroed segments
+
+        return a;
+    }
+    else if (width == 64) {
+        return (a == 0) == zero;
+    }
+    else {
+        REALM_ASSERT_DEBUG(false);
+        return uint64_t(-1);
+    }
+}
+
+// This is the main finding function for Array. Other finding functions are just wrappers around this one.
+// Search for 'value' using condition cond (Equal, NotEqual, Less, etc) and call find_action() or find_action_pattern()
+// for each match. Break and return if find_action() returns false or 'end' is reached.
+
+// If nullable_array is set, then find_optimized() will treat the array is being nullable, i.e. it will skip the
+// first entry and compare correctly against null, etc.
+//
+// If find_null is set, it means that we search for a null. In that case, `value` is ignored. If find_null is set,
+// then nullable_array must be set too.
+template<class cond, Action action, size_t bitwidth, class Callback>
+bool Array::find_optimized(int64_t value, size_t start, size_t end, size_t baseindex, QueryState<int64_t>* state, Callback callback, bool nullable_array, bool find_null) const
+{
+    REALM_ASSERT(!(find_null && !nullable_array));
+    REALM_ASSERT_DEBUG(start <= m_size && (end <= m_size || end == size_t(-1)) && start <= end);
+
+    size_t start2 = start;
+    cond c;
+
+    if (end == npos)
+        end = nullable_array ? size() - 1 : size();
+
+    if (nullable_array) {
+        // We were called by find() of a nullable array. So skip first entry, take nulls in count, etc, etc. Fixme:
+        // Huge speed optimizations are possible here! This is a very simple generic method.
+        for (; start2 < end; start2++) {
+            int64_t v = get<bitwidth>(start2 + 1);
+            if (c(v, value, v == get(0), find_null)) {
+                util::Optional<int64_t> v2(v == get(0) ? util::none : util::make_optional(v));
+                if (!find_action<action, Callback>(start2 + baseindex, v2, state, callback))
+                    return false; // tell caller to stop aggregating/search
+            }
+        }
+        return true; // tell caller to continue aggregating/search (on next array leafs)
+    }
+
+
+    // Test first few items with no initial time overhead
+    if (start2 > 0) {
+        if (m_size > start2 && c(get<bitwidth>(start2), value) && start2 < end) {
+            if (!find_action<action, Callback>(start2 + baseindex, get<bitwidth>(start2), state, callback))
+                return false;
+        }
+
+        ++start2;
+
+        if (m_size > start2 && c(get<bitwidth>(start2), value) && start2 < end) {
+            if (!find_action<action, Callback>(start2 + baseindex, get<bitwidth>(start2), state, callback))
+                return false;
+        }
+
+        ++start2;
+
+        if (m_size > start2 && c(get<bitwidth>(start2), value) && start2 < end) {
+            if (!find_action<action, Callback>(start2 + baseindex, get<bitwidth>(start2), state, callback))
+                return false;
+        }
+
+        ++start2;
+
+        if (m_size > start2 && c(get<bitwidth>(start2), value) && start2 < end) {
+            if (!find_action<action, Callback>(start2 + baseindex, get<bitwidth>(start2), state, callback))
+                return false;
+        }
+
+        ++start2;
+    }
+
+    if (!(m_size > start2 && start2 < end))
+        return true;
+
+    if (end == size_t(-1))
+        end = m_size;
+
+    // Return immediately if no items in array can match (such as if cond == Greater && value == 100 && m_ubound == 15)
+    if (!c.can_match(value, m_lbound, m_ubound))
+        return true;
+
+    // optimization if all items are guaranteed to match (such as cond == NotEqual && value == 100 && m_ubound == 15)
+    if (c.will_match(value, m_lbound, m_ubound)) {
+        size_t end2;
+
+        if (action == act_CallbackIdx)
+            end2 = end;
+        else {
+            REALM_ASSERT_DEBUG(state->m_match_count < state->m_limit);
+            size_t process = state->m_limit - state->m_match_count;
+            end2 = end - start2 > process ? start2 + process : end;
+        }
+        if (action == act_Sum || action == act_Max || action == act_Min) {
+            int64_t res;
+            size_t res_ndx = 0;
+            if (action == act_Sum)
+                res = Array::sum(start2, end2);
+            if (action == act_Max)
+                Array::maximum(res, start2, end2, &res_ndx);
+            if (action == act_Min)
+                Array::minimum(res, start2, end2, &res_ndx);
+
+            find_action<action, Callback>(res_ndx + baseindex, res, state, callback);
+            // find_action will increment match count by 1, so we need to `-1` from the number of elements that
+            // we performed the fast Array methods on.
+            state->m_match_count += end2 - start2 - 1;
+
+        }
+        else if (action == act_Count) {
+            state->m_state += end2 - start2;
+        }
+        else {
+            for (; start2 < end2; start2++)
+                if (!find_action<action, Callback>(start2 + baseindex, get<bitwidth>(start2), state, callback))
+                    return false;
+        }
+        return true;
+    }
+
+    // finder cannot handle this bitwidth
+    REALM_ASSERT_3(m_width, !=, 0);
+
+#if defined(REALM_COMPILER_SSE)
+    // Only use SSE if payload is at least one SSE chunk (128 bits) in size. Also note taht SSE doesn't support
+    // Less-than comparison for 64-bit values.
+    if ((!(std::is_same<cond, Less>::value && m_width == 64)) && end - start2 >= sizeof(__m128i) && m_width >= 8 &&
+        (sseavx<42>() || (sseavx<30>() && std::is_same<cond, Equal>::value && m_width < 64))) {
+
+        // find_sse() must start2 at 16-byte boundary, so search area before that using compare_equality()
+        __m128i* const a = reinterpret_cast<__m128i*>(round_up(m_data + start2 * bitwidth / 8, sizeof (__m128i)));
+        __m128i* const b = reinterpret_cast<__m128i*>(round_down(m_data + end * bitwidth / 8, sizeof (__m128i)));
+
+        if (!compare<cond, action, bitwidth, Callback>(value, start2, (reinterpret_cast<char*>(a) - m_data) * 8 / no0(bitwidth), baseindex, state, callback))
+            return false;
+
+        // Search aligned area with SSE
+        if (b > a) {
+            if (sseavx<42>()) {
+                if (!find_sse<cond, action, bitwidth, Callback>(value, a, b - a, state, baseindex + ((reinterpret_cast<char*>(a) - m_data) * 8 / no0(bitwidth)), callback))
+                    return false;
+                }
+                else if (sseavx<30>()) {
+
+                if (!find_sse<Equal, action, bitwidth, Callback>(value, a, b - a, state, baseindex + ((reinterpret_cast<char*>(a) - m_data) * 8 / no0(bitwidth)), callback))
+                    return false;
+                }
+        }
+
+        // Search remainder with compare_equality()
+        if (!compare<cond, action, bitwidth, Callback>(value, (reinterpret_cast<char*>(b) - m_data) * 8 / no0(bitwidth), end, baseindex, state, callback))
+            return false;
+
+        return true;
+    }
+    else {
+        return compare<cond, action, bitwidth, Callback>(value, start2, end, baseindex, state, callback);
+    }
+#else
+return compare<cond, action, bitwidth, Callback>(value, start2, end, baseindex, state, callback);
+#endif
+}
+
+template<size_t width>
+inline int64_t Array::lower_bits() const
+{
+    if (width == 1)
+        return 0xFFFFFFFFFFFFFFFFULL;
+    else if (width == 2)
+        return 0x5555555555555555ULL;
+    else if (width == 4)
+        return 0x1111111111111111ULL;
+    else if (width == 8)
+        return 0x0101010101010101ULL;
+    else if (width == 16)
+        return 0x0001000100010001ULL;
+    else if (width == 32)
+        return 0x0000000100000001ULL;
+    else if (width == 64)
+        return 0x0000000000000001ULL;
+    else {
+        REALM_ASSERT_DEBUG(false);
+        return int64_t(-1);
+    }
+}
+
+// Tests if any chunk in 'value' is 0
+template<size_t width>
+inline bool Array::test_zero(uint64_t value) const
+{
+    uint64_t hasZeroByte;
+    uint64_t lower = lower_bits<width>();
+    uint64_t upper = lower_bits<width>() * 1ULL << (width == 0 ? 0 : (width - 1ULL));
+    hasZeroByte = (value - lower) & ~value & upper;
+    return hasZeroByte != 0;
+}
+
+// Finds first zero (if eq == true) or non-zero (if eq == false) element in v and returns its position.
+// IMPORTANT: This function assumes that at least 1 item matches (test this with test_zero() or other means first)!
+template<bool eq, size_t width>
+size_t Array::find_zero(uint64_t v) const
+{
+    size_t start = 0;
+    uint64_t hasZeroByte;
+    // Warning free way of computing (1ULL << width) - 1
+    uint64_t mask = (width == 64 ? ~0ULL : ((1ULL << (width == 64 ? 0 : width)) - 1ULL));
+
+    if (eq == (((v >> (width * start)) & mask) == 0)) {
+        return 0;
+    }
+
+    // Bisection optimization, speeds up small bitwidths with high match frequency. More partions than 2 do NOT pay
+    // off because the work done by test_zero() is wasted for the cases where the value exists in first half, but
+    // useful if it exists in last half. Sweet spot turns out to be the widths and partitions below.
+    if (width <= 8) {
+        hasZeroByte = test_zero<width>(v | 0xffffffff00000000ULL);
+        if (eq ? !hasZeroByte : (v & 0x00000000ffffffffULL) == 0) {
+            // 00?? -> increasing
+            start += 64 / no0(width) / 2;
+            if (width <= 4) {
+                hasZeroByte = test_zero<width>(v | 0xffff000000000000ULL);
+                if (eq ? !hasZeroByte : (v & 0x0000ffffffffffffULL) == 0) {
+                    // 000?
+                    start += 64 / no0(width) / 4;
+                }
+            }
+        }
+        else {
+            if (width <= 4) {
+                // ??00
+                hasZeroByte = test_zero<width>(v | 0xffffffffffff0000ULL);
+                if (eq ? !hasZeroByte : (v & 0x000000000000ffffULL) == 0) {
+                    // 0?00
+                    start += 64 / no0(width) / 4;
+                }
+            }
+        }
+    }
+
+    while (eq == (((v >> (width * start)) & mask) != 0)) {
+        // You must only call find_zero() if you are sure that at least 1 item matches
+        REALM_ASSERT_3(start, <=, 8 * sizeof(v));
+        start++;
+    }
+
+    return start;
+}
+
+// Generate a magic constant used for later bithacks
+template<bool gt, size_t width>
+int64_t Array::find_gtlt_magic(int64_t v) const
+{
+    uint64_t mask1 = (width == 64 ? ~0ULL : ((1ULL << (width == 64 ? 0 : width)) - 1ULL)); // Warning free way of computing (1ULL << width) - 1
+    uint64_t mask2 = mask1 >> 1;
+    uint64_t magic = gt ? (~0ULL / no0(mask1) * (mask2 - v)) : (~0ULL / no0(mask1) * v);
+    return magic;
+}
+
+template<bool gt, Action action, size_t width, class Callback>
+bool Array::find_gtlt_fast(uint64_t chunk, uint64_t magic, QueryState<int64_t>* state, size_t baseindex, Callback callback) const
+{
+    // Tests if a a chunk of values contains values that are greater (if gt == true) or less (if gt == false) than v.
+    // Fast, but limited to work when all values in the chunk are positive.
+
+    uint64_t mask1 = (width == 64 ? ~0ULL : ((1ULL << (width == 64 ? 0 : width)) - 1ULL)); // Warning free way of computing (1ULL << width) - 1
+    uint64_t mask2 = mask1 >> 1;
+    uint64_t m = gt ? (((chunk + magic) | chunk) & ~0ULL / no0(mask1) * (mask2 + 1)) : ((chunk - magic) & ~chunk&~0ULL/no0(mask1)*(mask2+1));
+    size_t p = 0;
+    while (m) {
+        if (find_action_pattern<action, Callback>(baseindex, m >> (no0(width) - 1), state, callback))
+            break; // consumed, so do not call find_action()
+
+        size_t t = first_set_bit64(m) / no0(width);
+        p += t;
+        if (!find_action<action, Callback>(p + baseindex, (chunk >> (p * width)) & mask1, state, callback))
+            return false;
+
+        if ((t + 1) * width == 64)
+            m = 0;
+        else
+            m >>= (t + 1) * width;
+        p++;
+    }
+
+    return true;
+}
+
+
+template<bool gt, Action action, size_t width, class Callback>
+bool Array::find_gtlt(int64_t v, uint64_t chunk, QueryState<int64_t>* state, size_t baseindex, Callback callback) const
+{
+    // Find items in 'chunk' that are greater (if gt == true) or smaller (if gt == false) than 'v'. Fixme, __forceinline can make it crash in vS2010 - find out why
+    if (width == 1) {
+        for (size_t t = 0; t < 64; t++) {
+            if (gt ? static_cast<int64_t>(chunk & 0x1) > v : static_cast<int64_t>(chunk & 0x1) < v) {if (!find_action<action, Callback>( t + baseindex, static_cast<int64_t>(chunk & 0x1), state, callback)) return false;} chunk >>= 1;
+        }
+    }
+    else if (width == 2) {
+        // Alot (50% +) faster than loop/compiler-unrolled loop
+        if (gt ? static_cast<int64_t>(chunk & 0x3) > v : static_cast<int64_t>(chunk & 0x3) < v) {if (!find_action<action, Callback>( 0 + baseindex, static_cast<int64_t>(chunk & 0x3), state, callback)) return false;} chunk >>= 2;
+        if (gt ? static_cast<int64_t>(chunk & 0x3) > v : static_cast<int64_t>(chunk & 0x3) < v) {if (!find_action<action, Callback>( 1 + baseindex, static_cast<int64_t>(chunk & 0x3), state, callback)) return false;} chunk >>= 2;
+        if (gt ? static_cast<int64_t>(chunk & 0x3) > v : static_cast<int64_t>(chunk & 0x3) < v) {if (!find_action<action, Callback>( 2 + baseindex, static_cast<int64_t>(chunk & 0x3), state, callback)) return false;} chunk >>= 2;
+        if (gt ? static_cast<int64_t>(chunk & 0x3) > v : static_cast<int64_t>(chunk & 0x3) < v) {if (!find_action<action, Callback>( 3 + baseindex, static_cast<int64_t>(chunk & 0x3), state, callback)) return false;} chunk >>= 2;
+        if (gt ? static_cast<int64_t>(chunk & 0x3) > v : static_cast<int64_t>(chunk & 0x3) < v) {if (!find_action<action, Callback>( 4 + baseindex, static_cast<int64_t>(chunk & 0x3), state, callback)) return false;} chunk >>= 2;
+        if (gt ? static_cast<int64_t>(chunk & 0x3) > v : static_cast<int64_t>(chunk & 0x3) < v) {if (!find_action<action, Callback>( 5 + baseindex, static_cast<int64_t>(chunk & 0x3), state, callback)) return false;} chunk >>= 2;
+        if (gt ? static_cast<int64_t>(chunk & 0x3) > v : static_cast<int64_t>(chunk & 0x3) < v) {if (!find_action<action, Callback>( 6 + baseindex, static_cast<int64_t>(chunk & 0x3), state, callback)) return false;} chunk >>= 2;
+        if (gt ? static_cast<int64_t>(chunk & 0x3) > v : static_cast<int64_t>(chunk & 0x3) < v) {if (!find_action<action, Callback>( 7 + baseindex, static_cast<int64_t>(chunk & 0x3), state, callback)) return false;} chunk >>= 2;
+
+        if (gt ? static_cast<int64_t>(chunk & 0x3) > v : static_cast<int64_t>(chunk & 0x3) < v) {if (!find_action<action, Callback>( 8 + baseindex, static_cast<int64_t>(chunk & 0x3), state, callback)) return false;} chunk >>= 2;
+        if (gt ? static_cast<int64_t>(chunk & 0x3) > v : static_cast<int64_t>(chunk & 0x3) < v) {if (!find_action<action, Callback>( 9 + baseindex, static_cast<int64_t>(chunk & 0x3), state, callback)) return false;} chunk >>= 2;
+        if (gt ? static_cast<int64_t>(chunk & 0x3) > v : static_cast<int64_t>(chunk & 0x3) < v) {if (!find_action<action, Callback>( 10 + baseindex, static_cast<int64_t>(chunk & 0x3), state, callback)) return false;} chunk >>= 2;
+        if (gt ? static_cast<int64_t>(chunk & 0x3) > v : static_cast<int64_t>(chunk & 0x3) < v) {if (!find_action<action, Callback>( 11 + baseindex, static_cast<int64_t>(chunk & 0x3), state, callback)) return false;} chunk >>= 2;
+        if (gt ? static_cast<int64_t>(chunk & 0x3) > v : static_cast<int64_t>(chunk & 0x3) < v) {if (!find_action<action, Callback>( 12 + baseindex, static_cast<int64_t>(chunk & 0x3), state, callback)) return false;} chunk >>= 2;
+        if (gt ? static_cast<int64_t>(chunk & 0x3) > v : static_cast<int64_t>(chunk & 0x3) < v) {if (!find_action<action, Callback>( 13 + baseindex, static_cast<int64_t>(chunk & 0x3), state, callback)) return false;} chunk >>= 2;
+        if (gt ? static_cast<int64_t>(chunk & 0x3) > v : static_cast<int64_t>(chunk & 0x3) < v) {if (!find_action<action, Callback>( 14 + baseindex, static_cast<int64_t>(chunk & 0x3), state, callback)) return false;} chunk >>= 2;
+        if (gt ? static_cast<int64_t>(chunk & 0x3) > v : static_cast<int64_t>(chunk & 0x3) < v) {if (!find_action<action, Callback>( 15 + baseindex, static_cast<int64_t>(chunk & 0x3), state, callback)) return false;} chunk >>= 2;
+
+        if (gt ? static_cast<int64_t>(chunk & 0x3) > v : static_cast<int64_t>(chunk & 0x3) < v) {if (!find_action<action, Callback>( 16 + baseindex, static_cast<int64_t>(chunk & 0x3), state, callback)) return false;} chunk >>= 2;
+        if (gt ? static_cast<int64_t>(chunk & 0x3) > v : static_cast<int64_t>(chunk & 0x3) < v) {if (!find_action<action, Callback>( 17 + baseindex, static_cast<int64_t>(chunk & 0x3), state, callback)) return false;} chunk >>= 2;
+        if (gt ? static_cast<int64_t>(chunk & 0x3) > v : static_cast<int64_t>(chunk & 0x3) < v) {if (!find_action<action, Callback>( 18 + baseindex, static_cast<int64_t>(chunk & 0x3), state, callback)) return false;} chunk >>= 2;
+        if (gt ? static_cast<int64_t>(chunk & 0x3) > v : static_cast<int64_t>(chunk & 0x3) < v) {if (!find_action<action, Callback>( 19 + baseindex, static_cast<int64_t>(chunk & 0x3), state, callback)) return false;} chunk >>= 2;
+        if (gt ? static_cast<int64_t>(chunk & 0x3) > v : static_cast<int64_t>(chunk & 0x3) < v) {if (!find_action<action, Callback>( 20 + baseindex, static_cast<int64_t>(chunk & 0x3), state, callback)) return false;} chunk >>= 2;
+        if (gt ? static_cast<int64_t>(chunk & 0x3) > v : static_cast<int64_t>(chunk & 0x3) < v) {if (!find_action<action, Callback>( 21 + baseindex, static_cast<int64_t>(chunk & 0x3), state, callback)) return false;} chunk >>= 2;
+        if (gt ? static_cast<int64_t>(chunk & 0x3) > v : static_cast<int64_t>(chunk & 0x3) < v) {if (!find_action<action, Callback>( 22 + baseindex, static_cast<int64_t>(chunk & 0x3), state, callback)) return false;} chunk >>= 2;
+        if (gt ? static_cast<int64_t>(chunk & 0x3) > v : static_cast<int64_t>(chunk & 0x3) < v) {if (!find_action<action, Callback>( 23 + baseindex, static_cast<int64_t>(chunk & 0x3), state, callback)) return false;} chunk >>= 2;
+
+        if (gt ? static_cast<int64_t>(chunk & 0x3) > v : static_cast<int64_t>(chunk & 0x3) < v) {if (!find_action<action, Callback>( 24 + baseindex, static_cast<int64_t>(chunk & 0x3), state, callback)) return false;} chunk >>= 2;
+        if (gt ? static_cast<int64_t>(chunk & 0x3) > v : static_cast<int64_t>(chunk & 0x3) < v) {if (!find_action<action, Callback>( 25 + baseindex, static_cast<int64_t>(chunk & 0x3), state, callback)) return false;} chunk >>= 2;
+        if (gt ? static_cast<int64_t>(chunk & 0x3) > v : static_cast<int64_t>(chunk & 0x3) < v) {if (!find_action<action, Callback>( 26 + baseindex, static_cast<int64_t>(chunk & 0x3), state, callback)) return false;} chunk >>= 2;
+        if (gt ? static_cast<int64_t>(chunk & 0x3) > v : static_cast<int64_t>(chunk & 0x3) < v) {if (!find_action<action, Callback>( 27 + baseindex, static_cast<int64_t>(chunk & 0x3), state, callback)) return false;} chunk >>= 2;
+        if (gt ? static_cast<int64_t>(chunk & 0x3) > v : static_cast<int64_t>(chunk & 0x3) < v) {if (!find_action<action, Callback>( 28 + baseindex, static_cast<int64_t>(chunk & 0x3), state, callback)) return false;} chunk >>= 2;
+        if (gt ? static_cast<int64_t>(chunk & 0x3) > v : static_cast<int64_t>(chunk & 0x3) < v) {if (!find_action<action, Callback>( 29 + baseindex, static_cast<int64_t>(chunk & 0x3), state, callback)) return false;} chunk >>= 2;
+        if (gt ? static_cast<int64_t>(chunk & 0x3) > v : static_cast<int64_t>(chunk & 0x3) < v) {if (!find_action<action, Callback>( 30 + baseindex, static_cast<int64_t>(chunk & 0x3), state, callback)) return false;} chunk >>= 2;
+        if (gt ? static_cast<int64_t>(chunk & 0x3) > v : static_cast<int64_t>(chunk & 0x3) < v) {if (!find_action<action, Callback>( 31 + baseindex, static_cast<int64_t>(chunk & 0x3), state, callback)) return false;} chunk >>= 2;
+    }
+    else if (width == 4) {
+        // 128 ms:
+        if (gt ? static_cast<int64_t>(chunk & 0xf) > v : static_cast<int64_t>(chunk & 0xf) < v) {if (!find_action<action, Callback>( 0 + baseindex, static_cast<int64_t>(chunk & 0xf), state, callback)) return false;} chunk >>= 4;
+        if (gt ? static_cast<int64_t>(chunk & 0xf) > v : static_cast<int64_t>(chunk & 0xf) < v) {if (!find_action<action, Callback>( 1 + baseindex, static_cast<int64_t>(chunk & 0xf), state, callback)) return false;} chunk >>= 4;
+        if (gt ? static_cast<int64_t>(chunk & 0xf) > v : static_cast<int64_t>(chunk & 0xf) < v) {if (!find_action<action, Callback>( 2 + baseindex, static_cast<int64_t>(chunk & 0xf), state, callback)) return false;} chunk >>= 4;
+        if (gt ? static_cast<int64_t>(chunk & 0xf) > v : static_cast<int64_t>(chunk & 0xf) < v) {if (!find_action<action, Callback>( 3 + baseindex, static_cast<int64_t>(chunk & 0xf), state, callback)) return false;} chunk >>= 4;
+        if (gt ? static_cast<int64_t>(chunk & 0xf) > v : static_cast<int64_t>(chunk & 0xf) < v) {if (!find_action<action, Callback>( 4 + baseindex, static_cast<int64_t>(chunk & 0xf), state, callback)) return false;} chunk >>= 4;
+        if (gt ? static_cast<int64_t>(chunk & 0xf) > v : static_cast<int64_t>(chunk & 0xf) < v) {if (!find_action<action, Callback>( 5 + baseindex, static_cast<int64_t>(chunk & 0xf), state, callback)) return false;} chunk >>= 4;
+        if (gt ? static_cast<int64_t>(chunk & 0xf) > v : static_cast<int64_t>(chunk & 0xf) < v) {if (!find_action<action, Callback>( 6 + baseindex, static_cast<int64_t>(chunk & 0xf), state, callback)) return false;} chunk >>= 4;
+        if (gt ? static_cast<int64_t>(chunk & 0xf) > v : static_cast<int64_t>(chunk & 0xf) < v) {if (!find_action<action, Callback>( 7 + baseindex, static_cast<int64_t>(chunk & 0xf), state, callback)) return false;} chunk >>= 4;
+
+        if (gt ? static_cast<int64_t>(chunk & 0xf) > v : static_cast<int64_t>(chunk & 0xf) < v) {if (!find_action<action, Callback>( 8 + baseindex, static_cast<int64_t>(chunk & 0xf), state, callback)) return false;} chunk >>= 4;
+        if (gt ? static_cast<int64_t>(chunk & 0xf) > v : static_cast<int64_t>(chunk & 0xf) < v) {if (!find_action<action, Callback>( 9 + baseindex, static_cast<int64_t>(chunk & 0xf), state, callback)) return false;} chunk >>= 4;
+        if (gt ? static_cast<int64_t>(chunk & 0xf) > v : static_cast<int64_t>(chunk & 0xf) < v) {if (!find_action<action, Callback>( 10 + baseindex, static_cast<int64_t>(chunk & 0xf), state, callback)) return false;} chunk >>= 4;
+        if (gt ? static_cast<int64_t>(chunk & 0xf) > v : static_cast<int64_t>(chunk & 0xf) < v) {if (!find_action<action, Callback>( 11 + baseindex, static_cast<int64_t>(chunk & 0xf), state, callback)) return false;} chunk >>= 4;
+        if (gt ? static_cast<int64_t>(chunk & 0xf) > v : static_cast<int64_t>(chunk & 0xf) < v) {if (!find_action<action, Callback>( 12 + baseindex, static_cast<int64_t>(chunk & 0xf), state, callback)) return false;} chunk >>= 4;
+        if (gt ? static_cast<int64_t>(chunk & 0xf) > v : static_cast<int64_t>(chunk & 0xf) < v) {if (!find_action<action, Callback>( 13 + baseindex, static_cast<int64_t>(chunk & 0xf), state, callback)) return false;} chunk >>= 4;
+        if (gt ? static_cast<int64_t>(chunk & 0xf) > v : static_cast<int64_t>(chunk & 0xf) < v) {if (!find_action<action, Callback>( 14 + baseindex, static_cast<int64_t>(chunk & 0xf), state, callback)) return false;} chunk >>= 4;
+        if (gt ? static_cast<int64_t>(chunk & 0xf) > v : static_cast<int64_t>(chunk & 0xf) < v) {if (!find_action<action, Callback>( 15 + baseindex, static_cast<int64_t>(chunk & 0xf), state, callback)) return false;} chunk >>= 4;
+
+        // 187 ms:
+        // if (gt ? static_cast<int64_t>(chunk >> 0*4) & 0xf > v : static_cast<int64_t>(chunk >> 0*4) & 0xf < v) return 0;
+    }
+    else if (width == 8) {
+        // 88 ms:
+        if (gt ? static_cast<int8_t>(chunk) > v : static_cast<int8_t>(chunk) < v) {if (!find_action<action, Callback>( 0 + baseindex, static_cast<int8_t>(chunk), state, callback)) return false;} chunk >>= 8;
+        if (gt ? static_cast<int8_t>(chunk) > v : static_cast<int8_t>(chunk) < v) {if (!find_action<action, Callback>( 1 + baseindex, static_cast<int8_t>(chunk), state, callback)) return false;} chunk >>= 8;
+        if (gt ? static_cast<int8_t>(chunk) > v : static_cast<int8_t>(chunk) < v) {if (!find_action<action, Callback>( 2 + baseindex, static_cast<int8_t>(chunk), state, callback)) return false;} chunk >>= 8;
+        if (gt ? static_cast<int8_t>(chunk) > v : static_cast<int8_t>(chunk) < v) {if (!find_action<action, Callback>( 3 + baseindex, static_cast<int8_t>(chunk), state, callback)) return false;} chunk >>= 8;
+        if (gt ? static_cast<int8_t>(chunk) > v : static_cast<int8_t>(chunk) < v) {if (!find_action<action, Callback>( 4 + baseindex, static_cast<int8_t>(chunk), state, callback)) return false;} chunk >>= 8;
+        if (gt ? static_cast<int8_t>(chunk) > v : static_cast<int8_t>(chunk) < v) {if (!find_action<action, Callback>( 5 + baseindex, static_cast<int8_t>(chunk), state, callback)) return false;} chunk >>= 8;
+        if (gt ? static_cast<int8_t>(chunk) > v : static_cast<int8_t>(chunk) < v) {if (!find_action<action, Callback>( 6 + baseindex, static_cast<int8_t>(chunk), state, callback)) return false;} chunk >>= 8;
+        if (gt ? static_cast<int8_t>(chunk) > v : static_cast<int8_t>(chunk) < v) {if (!find_action<action, Callback>( 7 + baseindex, static_cast<int8_t>(chunk), state, callback)) return false;} chunk >>= 8;
+
+        //97 ms ms:
+        // if (gt ? static_cast<int8_t>(chunk >> 0*8) > v : static_cast<int8_t>(chunk >> 0*8) < v) return 0;
+    }
+    else if (width == 16) {
+
+        if (gt ? static_cast<short int>(chunk >> 0*16) > v : static_cast<short int>(chunk >> 0*16) < v) {if (!find_action<action, Callback>( 0 + baseindex, static_cast<short int>(chunk >> 0*16), state, callback)) return false;};
+        if (gt ? static_cast<short int>(chunk >> 1*16) > v : static_cast<short int>(chunk >> 1*16) < v) {if (!find_action<action, Callback>( 1 + baseindex, static_cast<short int>(chunk >> 1*16), state, callback)) return false;};
+        if (gt ? static_cast<short int>(chunk >> 2*16) > v : static_cast<short int>(chunk >> 2*16) < v) {if (!find_action<action, Callback>( 2 + baseindex, static_cast<short int>(chunk >> 2*16), state, callback)) return false;};
+        if (gt ? static_cast<short int>(chunk >> 3*16) > v : static_cast<short int>(chunk >> 3*16) < v) {if (!find_action<action, Callback>( 3 + baseindex, static_cast<short int>(chunk >> 3*16), state, callback)) return false;};
+
+        /*
+        // Faster but disabled due to bug in VC2010 compiler (fixed in 2012 toolchain) where last 'if' is errorneously optimized away
+        if (gt ? static_cast<short int>chunk > v : static_cast<short int>chunk < v) {if (!state->add_positive_local(0 + baseindex); else return 0;} chunk >>= 16;
+        if (gt ? static_cast<short int>chunk > v : static_cast<short int>chunk < v) {if (!state->add_positive_local(1 + baseindex); else return 1;} chunk >>= 16;
+        if (gt ? static_cast<short int>chunk > v : static_cast<short int>chunk < v) {if (!state->add_positive_local(2 + baseindex); else return 2;} chunk >>= 16;
+        if (gt ? static_cast<short int>chunk > v : static_cast<short int>chunk < v) {if (!state->add_positive_local(3 + baseindex); else return 3;} chunk >>= 16;
+
+        // Following illustrates it:
+        #include <stdint.h>
+        #include <stdio.h>
+        #include <stdlib.h>
+
+        size_t bug(int64_t v, uint64_t chunk)
+        {
+            bool gt = true;
+
+            if (gt ? static_cast<short int>chunk > v : static_cast<short int>chunk < v) {return 0;} chunk >>= 16;
+            if (gt ? static_cast<short int>chunk > v : static_cast<short int>chunk < v) {return 1;} chunk >>= 16;
+            if (gt ? static_cast<short int>chunk > v : static_cast<short int>chunk < v) {return 2;} chunk >>= 16;
+            if (gt ? static_cast<short int>chunk > v : static_cast<short int>chunk < v) {return 3;} chunk >>= 16;
+
+            return -1;
+        }
+
+        int main(int argc, char const *const argv[])
+        {
+            int64_t v;
+            FIXME: We cannot use rand() as it is not thread-safe.
+            if (rand()*rand() == 3) {
+                v = rand()*rand()*rand()*rand()*rand();
+                printf("Change '3' to something else and run test again\n");
+            }
+            else {
+                v = 0x2222000000000000ULL;
+            }
+
+            size_t idx;
+
+            idx = bug(200, v);
+            if (idx != 3)
+                printf("Compiler failed: idx == %d (expected idx == 3)\n", idx);
+
+            v = 0x2222000000000000ULL;
+            idx = bug(200, v);
+            if (idx == 3)
+                printf("Touching v made it work\n", idx);
+        }
+        */
+    }
+    else if (width == 32) {
+        if (gt ? static_cast<int>(chunk) > v : static_cast<int>(chunk) < v) {if (!find_action<action, Callback>( 0 + baseindex, static_cast<int>(chunk), state, callback)) return false;} chunk >>= 32;
+        if (gt ? static_cast<int>(chunk) > v : static_cast<int>(chunk) < v) {if (!find_action<action, Callback>( 1 + baseindex, static_cast<int>(chunk), state, callback)) return false;} chunk >>= 32;
+    }
+    else if (width == 64) {
+        if (gt ? static_cast<int64_t>(v) > v : static_cast<int64_t>(v) < v) {if (!find_action<action, Callback>( 0 + baseindex, static_cast<int64_t>(v), state, callback)) return false;};
+    }
+
+    return true;
+}
+
+
+template<bool eq, Action action, size_t width, class Callback>
+inline bool Array::compare_equality(int64_t value, size_t start, size_t end, size_t baseindex, QueryState<int64_t>* state, Callback callback) const
+{
+    // Find items in this Array that are equal (eq == true) or different (eq = false) from 'value'
+
+    REALM_ASSERT_DEBUG(start <= m_size && (end <= m_size || end == size_t(-1)) && start <= end);
+
+    size_t ee = round_up(start, 64 / no0(width));
+    ee = ee > end ? end : ee;
+    for (; start < ee; ++start)
+        if (eq ? (get<width>(start) == value) : (get<width>(start) != value)) {
+            if (!find_action<action, Callback>(start + baseindex, get<width>(start), state, callback))
+                return false;
+        }
+
+    if (start >= end)
+        return true;
+
+    if (width != 32 && width != 64) {
+        const int64_t* p = reinterpret_cast<const int64_t*>(m_data + (start * width / 8));
+        const int64_t* const e = reinterpret_cast<int64_t*>(m_data + (end * width / 8)) - 1;
+        const uint64_t mask = (width == 64 ? ~0ULL : ((1ULL << (width == 64 ? 0 : width)) - 1ULL)); // Warning free way of computing (1ULL << width) - 1
+        const uint64_t valuemask = ~0ULL / no0(mask) * (value & mask); // the "== ? :" is to avoid division by 0 compiler error
+
+        while (p < e) {
+            uint64_t chunk = *p;
+            uint64_t v2 = chunk ^ valuemask;
+            start = (p - reinterpret_cast<int64_t*>(m_data)) * 8 * 8 / no0(width);
+            size_t a = 0;
+
+            while (eq ? test_zero<width>(v2) : v2) {
+
+                if (find_action_pattern<action, Callback>(start + baseindex, cascade<width, eq>(v2), state, callback))
+                    break; // consumed
+
+                size_t t = find_zero<eq, width>(v2);
+                a += t;
+
+                if (a >= 64 / no0(width))
+                    break;
+
+                if (!find_action<action, Callback>(a + start + baseindex, get<width>(start + t), state, callback))
+                    return false;
+                v2 >>= (t + 1) * width;
+                a += 1;
+            }
+
+            ++p;
+        }
+
+        // Loop ended because we are near end or end of array. No need to optimize search in remainder in this case because end of array means that
+        // lots of search work has taken place prior to ending here. So time spent searching remainder is relatively tiny
+        start = (p - reinterpret_cast<int64_t*>(m_data)) * 8 * 8 / no0(width);
+    }
+
+    while (start < end) {
+        if (eq ? get<width>(start) == value : get<width>(start) != value) {
+            if (!find_action<action, Callback>( start + baseindex, get<width>(start), state, callback))
+                return false;
+        }
+        ++start;
+    }
+
+        return true;
+}
+
+// There exists a couple of find() functions that take more or less template arguments. Always call the one that
+// takes as most as possible to get best performance.
+
+// This is the one installed into the m_vtable->finder slots.
+template<class cond, Action action, size_t bitwidth>
+bool Array::find(int64_t value, size_t start, size_t end, size_t baseindex, QueryState<int64_t>* state) const
+{
+    return find<cond, action, bitwidth>(value, start, end, baseindex, state, CallbackDummy());
+}
+
+template<class cond, Action action, class Callback>
+bool Array::find(int64_t value, size_t start, size_t end, size_t baseindex, QueryState<int64_t>* state,
+                 Callback callback, bool nullable_array, bool find_null) const
+{
+    REALM_TEMPEX4(return find, cond, action, m_width, Callback, (value, start, end, baseindex, state, callback, nullable_array, find_null));
+}
+
+template<class cond, Action action, size_t bitwidth, class Callback>
+bool Array::find(int64_t value, size_t start, size_t end, size_t baseindex, QueryState<int64_t>* state,
+                 Callback callback, bool nullable_array, bool find_null) const
+{
+    return find_optimized<cond, action, bitwidth, Callback>(value, start, end, baseindex, state, callback, nullable_array, find_null);
+}
+
+#ifdef REALM_COMPILER_SSE
+// 'items' is the number of 16-byte SSE chunks. Returns index of packed element relative to first integer of first chunk
+template<class cond, Action action, size_t width, class Callback>
+bool Array::find_sse(int64_t value, __m128i *data, size_t items, QueryState<int64_t>* state, size_t baseindex,
+                    Callback callback) const
+{
+    __m128i search = {0};
+
+    // FIXME: Lasse, should these casts not be to int8_t, int16_t, int32_t respecitvely?
+    if (width == 8)
+        search = _mm_set1_epi8(static_cast<char>(value)); // FIXME: Lasse, Should this not be a cast to 'signed char'?
+    else if (width == 16)
+        search = _mm_set1_epi16(static_cast<short int>(value));
+    else if (width == 32)
+        search = _mm_set1_epi32(static_cast<int>(value));
+    else if (width == 64) {
+        if (std::is_same<cond, Less>::value)
+            REALM_ASSERT(false);
+        else
+            search = _mm_set_epi64x(value, value);
+    }
+
+    return find_sse_intern<cond, action, width, Callback>(data, &search, items, state, baseindex, callback);
+}
+
+// Compares packed action_data with packed data (equal, less, etc) and performs aggregate action (max, min, sum,
+// find_all, etc) on value inside action_data for first match, if any
+template<class cond, Action action, size_t width, class Callback>
+REALM_FORCEINLINE bool Array::find_sse_intern(__m128i* action_data, __m128i* data, size_t items,
+                                               QueryState<int64_t>* state, size_t baseindex, Callback callback) const
+{
+    size_t i = 0;
+    __m128i compare_result = {0};
+    unsigned int resmask;
+
+    // Search loop. Unrolling it has been tested to NOT increase performance (apparently mem bound)
+    for (i = 0; i < items; ++i) {
+        // equal / not-equal
+        if (std::is_same<cond, Equal>::value || std::is_same<cond, NotEqual>::value) {
+            if (width == 8)
+                compare_result = _mm_cmpeq_epi8(action_data[i], *data);
+            if (width == 16)
+                compare_result = _mm_cmpeq_epi16(action_data[i], *data);
+            if (width == 32)
+                compare_result = _mm_cmpeq_epi32(action_data[i], *data);
+            if (width == 64) {
+                compare_result = _mm_cmpeq_epi64(action_data[i], *data); // SSE 4.2 only
+            }
+        }
+
+        // greater
+        else if (std::is_same<cond, Greater>::value) {
+            if (width == 8)
+                compare_result = _mm_cmpgt_epi8(action_data[i], *data);
+            if (width == 16)
+                compare_result = _mm_cmpgt_epi16(action_data[i], *data);
+            if (width == 32)
+                compare_result = _mm_cmpgt_epi32(action_data[i], *data);
+            if (width == 64)
+                compare_result = _mm_cmpgt_epi64(action_data[i], *data);
+        }
+        // less
+        else if (std::is_same<cond, Less>::value) {
+            if (width == 8)
+                compare_result = _mm_cmplt_epi8(action_data[i], *data);
+            else if (width == 16)
+                compare_result = _mm_cmplt_epi16(action_data[i], *data);
+            else if (width == 32)
+                compare_result = _mm_cmplt_epi32(action_data[i], *data);
+            else
+                REALM_ASSERT(false);
+        }
+
+        resmask = _mm_movemask_epi8(compare_result);
+
+        if (std::is_same<cond, NotEqual>::value)
+            resmask = ~resmask & 0x0000ffff;
+
+//        if (resmask != 0)
+//            printf("resmask=%d\n", resmask);
+
+        size_t s = i * sizeof (__m128i) * 8 / no0(width);
+
+        while (resmask != 0) {
+
+            uint64_t upper = lower_bits<width / 8>() << (no0(width / 8) - 1);
+            uint64_t pattern = resmask & upper; // fixme, bits at wrong offsets. Only OK because we only use them in 'count' aggregate
+            if (find_action_pattern<action, Callback>(s + baseindex, pattern, state, callback))
+                break;
+
+            size_t idx = first_set_bit(resmask) * 8 / no0(width);
+            s += idx;
+            if (!find_action<action, Callback>( s + baseindex, get_universal<width>(reinterpret_cast<char*>(action_data), s), state, callback))
+                return false;
+            resmask >>= (idx + 1) * no0(width) / 8;
+            ++s;
+        }
+    }
+
+    return true;
+}
+#endif //REALM_COMPILER_SSE
+
+template<class cond, Action action, class Callback>
+bool Array::compare_leafs(const Array* foreign, size_t start, size_t end, size_t baseindex, QueryState<int64_t>* state,
+                         Callback callback) const
+{
+    cond c;
+    REALM_ASSERT_3(start, <=, end);
+    if (start == end)
+        return true;
+
+
+    int64_t v;
+
+    // We can compare first element without checking for out-of-range
+    v = get(start);
+    if (c(v, foreign->get(start))) {
+        if (!find_action<action, Callback>(start + baseindex, v, state, callback))
+            return false;
+    }
+
+    start++;
+
+    if (start + 3 < end) {
+        v = get(start);
+        if (c(v, foreign->get(start)))
+            if (!find_action<action, Callback>(start + baseindex, v, state, callback))
+                return false;
+
+        v = get(start + 1);
+        if (c(v, foreign->get(start + 1)))
+            if (!find_action<action, Callback>(start + 1 + baseindex, v, state, callback))
+                return false;
+
+        v = get(start + 2);
+        if (c(v, foreign->get(start + 2)))
+            if (!find_action<action, Callback>(start + 2 + baseindex, v, state, callback))
+                return false;
+
+        start += 3;
+    }
+    else if (start == end) {
+        return true;
+    }
+
+    bool r;
+    REALM_TEMPEX4(r = compare_leafs, cond, action, m_width, Callback, (foreign, start, end, baseindex, state, callback))
+    return r;
+}
+
+
+template<class cond, Action action, size_t width, class Callback>
+bool Array::compare_leafs(const Array* foreign, size_t start, size_t end, size_t baseindex, QueryState<int64_t>* state, Callback callback) const
+{
+    size_t fw = foreign->m_width;
+    bool r;
+    REALM_TEMPEX5(r = compare_leafs_4, cond, action, width, Callback, fw, (foreign, start, end, baseindex, state, callback))
+    return r;
+}
+
+
+template<class cond, Action action, size_t width, class Callback, size_t foreign_width>
+bool Array::compare_leafs_4(const Array* foreign, size_t start, size_t end, size_t baseindex, QueryState<int64_t>* state,
+                          Callback callback) const
+{
+    cond c;
+    char* foreign_m_data = foreign->m_data;
+
+    if (width == 0 && foreign_width == 0) {
+        if (c(0, 0)) {
+            while (start < end) {
+                if (!find_action<action, Callback>(start + baseindex, 0, state, callback))
+                    return false;
+                start++;
+            }
+        }
+        else {
+            return true;
+        }
+    }
+
+
+#if defined(REALM_COMPILER_SSE)
+    if (sseavx<42>() && width == foreign_width && (width == 8 || width == 16 || width == 32)) {
+        // We can only use SSE if both bitwidths are equal and above 8 bits and all values are signed
+        while (start < end && (((reinterpret_cast<size_t>(m_data) & 0xf) * 8 + start * width) % (128) != 0)) {
+            int64_t v = get_universal<width>(m_data, start);
+            int64_t fv = get_universal<foreign_width>(foreign_m_data, start);
+            if (c(v, fv)) {
+                if (!find_action<action, Callback>(start + baseindex, v, state, callback))
+                    return false;
+            }
+            start++;
+        }
+        if (start == end)
+            return true;
+
+
+        size_t sse_items = (end - start) * width / 128;
+        size_t sse_end = start + sse_items * 128 / no0(width);
+
+        while (start < sse_end) {
+            __m128i* a = reinterpret_cast<__m128i*>(m_data + start * width / 8);
+            __m128i* b = reinterpret_cast<__m128i*>(foreign_m_data + start * width / 8);
+
+            bool continue_search = find_sse_intern<cond, action, width, Callback>(a, b, 1, state, baseindex + start, callback);
+
+            if (!continue_search)
+                return false;
+
+            start += 128 / no0(width);
+        }
+    }
+#endif
+
+
+#if 0 // this method turned out to be 33% slower than a naive loop. Find out why
+
+    // index from which both arrays are 64-bit aligned
+    size_t a = round_up(start, 8 * sizeof (int64_t) / (width < foreign_width ? width : foreign_width));
+
+    while (start < end && start < a) {
+        int64_t v = get_universal<width>(m_data, start);
+        int64_t fv = get_universal<foreign_width>(foreign_m_data, start);
+
+        if (v == fv)
+            r++;
+
+        start++;
+    }
+
+    if (start >= end)
+        return r;
+
+    uint64_t chunk;
+    uint64_t fchunk;
+
+    size_t unroll_outer = (foreign_width > width ? foreign_width : width) / (foreign_width < width ? foreign_width : width);
+    size_t unroll_inner = 64 / (foreign_width > width ? foreign_width : width);
+
+    while (start + unroll_outer * unroll_inner < end) {
+
+        // fetch new most narrow chunk
+        if (foreign_width <= width)
+            fchunk = *reinterpret_cast<int64_t*>(foreign_m_data + start * foreign_width / 8);
+        else
+            chunk = *reinterpret_cast<int64_t*>(m_data + start * width / 8);
+
+        for (size_t uo = 0; uo < unroll_outer; uo++) {
+
+            // fetch new widest chunk
+            if (foreign_width > width)
+                fchunk = *reinterpret_cast<int64_t*>(foreign_m_data + start * foreign_width / 8);
+            else
+                chunk = *reinterpret_cast<int64_t*>(m_data + start * width / 8);
+
+            size_t newstart = start + unroll_inner;
+            while (start < newstart) {
+
+                // Isolate first value from chunk
+                int64_t v = (chunk << (64 - width)) >> (64 - width);
+                int64_t fv = (fchunk << (64 - foreign_width)) >> (64 - foreign_width);
+                chunk >>= width;
+                fchunk >>= foreign_width;
+
+                // Sign extend if required
+                v = (width <= 4) ? v : (width == 8) ? int8_t(v) : (width == 16) ? int16_t(v) : (width == 32) ? int32_t(v) : int64_t(v);
+                fv = (foreign_width <= 4) ? fv : (foreign_width == 8) ? int8_t(fv) : (foreign_width == 16) ? int16_t(fv) : (foreign_width == 32) ? int32_t(fv) : int64_t(fv);
+
+                if (v == fv)
+                    r++;
+
+                start++;
+
+            }
+
+
+        }
+    }
+#endif
+
+
+
+/*
+    // Unrolling helped less than 2% (non-frequent matches). Todo, investigate further
+    while (start + 1 < end) {
+        int64_t v = get_universal<width>(m_data, start);
+        int64_t v2 = get_universal<width>(m_data, start + 1);
+
+        int64_t fv = get_universal<foreign_width>(foreign_m_data, start);
+        int64_t fv2 = get_universal<foreign_width>(foreign_m_data, start + 1);
+
+        if (c(v, fv)) {
+            if (!find_action<action, Callback>(start + baseindex, v, state, callback))
+                return false;
+        }
+
+        if (c(v2, fv2)) {
+            if (!find_action<action, Callback>(start + 1 + baseindex, v2, state, callback))
+                return false;
+        }
+
+        start += 2;
+    }
+ */
+
+    while (start < end) {
+        int64_t v = get_universal<width>(m_data, start);
+        int64_t fv = get_universal<foreign_width>(foreign_m_data, start);
+
+        if (c(v, fv)) {
+            if (!find_action<action, Callback>(start + baseindex, v, state, callback))
+                return false;
+        }
+
+        start++;
+    }
+
+    return true;
+}
+
+
+template<class cond, Action action, size_t bitwidth, class Callback>
+bool Array::compare(int64_t value, size_t start, size_t end, size_t baseindex, QueryState<int64_t>* state,
+                    Callback callback) const
+{
+    bool ret = false;
+
+    if (std::is_same<cond, Equal>::value)
+        ret = compare_equality<true, action, bitwidth, Callback>(value, start, end, baseindex, state, callback);
+    else if (std::is_same<cond, NotEqual>::value)
+        ret = compare_equality<false, action, bitwidth, Callback>(value, start, end, baseindex, state, callback);
+    else if (std::is_same<cond, Greater>::value)
+        ret = compare_relation<true, action, bitwidth, Callback>(value, start, end, baseindex, state, callback);
+    else if (std::is_same<cond, Less>::value)
+        ret = compare_relation<false, action, bitwidth, Callback>(value, start, end, baseindex, state, callback);
+    else
+        REALM_ASSERT_DEBUG(false);
+
+    return ret;
+}
+
+template<bool gt, Action action, size_t bitwidth, class Callback>
+bool Array::compare_relation(int64_t value, size_t start, size_t end, size_t baseindex, QueryState<int64_t>* state,
+                            Callback callback) const
+{
+    REALM_ASSERT(start <= m_size && (end <= m_size || end == size_t(-1)) && start <= end);
+    uint64_t mask = (bitwidth == 64 ? ~0ULL : ((1ULL << (bitwidth == 64 ? 0 : bitwidth)) - 1ULL)); // Warning free way of computing (1ULL << width) - 1
+
+    size_t ee = round_up(start, 64 / no0(bitwidth));
+    ee = ee > end ? end : ee;
+    for (; start < ee; start++) {
+        if (gt ? (get<bitwidth>(start) > value) : (get<bitwidth>(start) < value)) {
+            if (!find_action<action, Callback>(start + baseindex, get<bitwidth>(start), state, callback))
+                return false;
+        }
+    }
+
+    if (start >= end)
+        return true; // none found, continue (return true) regardless what find_action() would have returned on match
+
+    const int64_t* p = reinterpret_cast<const int64_t*>(m_data + (start * bitwidth / 8));
+    const int64_t* const e = reinterpret_cast<int64_t*>(m_data + (end * bitwidth / 8)) - 1;
+
+    // Matches are rare enough to setup fast linear search for remaining items. We use
+    // bit hacks from http://graphics.stanford.edu/~seander/bithacks.html#HasLessInWord
+
+    if (bitwidth == 1 || bitwidth == 2 || bitwidth == 4 || bitwidth == 8 || bitwidth == 16) {
+        uint64_t magic = find_gtlt_magic<gt, bitwidth>(value);
+
+        // Bit hacks only work if searched item has its most significant bit clear for 'greater than' or
+        // 'item <= 1 << bitwidth' for 'less than'
+        if (value != int64_t((magic & mask)) && value >= 0 && bitwidth >= 2 && value <= static_cast<int64_t>((mask >> 1) - (gt ? 1 : 0))) {
+            // 15 ms
+            while (p < e) {
+                uint64_t upper = lower_bits<bitwidth>() << (no0(bitwidth) - 1);
+
+                const int64_t v = *p;
+                size_t idx;
+
+                // Bit hacks only works if all items in chunk have their most significant bit clear. Test this:
+                upper = upper & v;
+
+                if (!upper) {
+                    idx = find_gtlt_fast<gt, action, bitwidth, Callback>(v, magic, state, (p - reinterpret_cast<int64_t*>(m_data)) * 8 * 8 / no0(bitwidth) + baseindex, callback);
+                }
+                else
+                    idx = find_gtlt<gt, action, bitwidth, Callback>(value, v, state, (p - reinterpret_cast<int64_t*>(m_data)) * 8 * 8 / no0(bitwidth) + baseindex, callback);
+
+                if (!idx)
+                    return false;
+                ++p;
+            }
+        }
+        else {
+            // 24 ms
+            while (p < e) {
+                int64_t v = *p;
+                if (!find_gtlt<gt, action, bitwidth, Callback>(value, v, state, (p - reinterpret_cast<int64_t*>(m_data)) * 8 * 8 / no0(bitwidth) + baseindex, callback))
+                    return false;
+                ++p;
+            }
+        }
+        start = (p - reinterpret_cast<int64_t *>(m_data)) * 8 * 8 / no0(bitwidth);
+    }
+
+    // matchcount logic in SIMD no longer pays off for 32/64 bit ints because we have just 4/2 elements
+
+    // Test unaligned end and/or values of width > 16 manually
+    while (start < end) {
+        if (gt ? get<bitwidth>(start) > value : get<bitwidth>(start) < value) {
+            if (!find_action<action, Callback>( start + baseindex, get<bitwidth>(start), state, callback))
+                return false;
+        }
+        ++start;
+    }
+    return true;
+
+}
+
+template<class cond>
+size_t Array::find_first(int64_t value, size_t start, size_t end) const
+{
+    REALM_ASSERT(start <= m_size && (end <= m_size || end == size_t(-1)) && start <= end);
+    QueryState<int64_t> state;
+    state.init(act_ReturnFirst, nullptr, 1); // todo, would be nice to avoid this in order to speed up find_first loops
+    Finder finder = m_vtable->finder[cond::condition];
+    (this->*finder)(value, start, end, 0, &state);
+
+    return static_cast<size_t>(state.m_state);
+}
+
+//*************************************************************************************
+// Finding code ends                                                                  *
+//*************************************************************************************
+
+
+} // namespace realm
+
+#endif // REALM_ARRAY_HPP
diff --git a/Pods/Realm/include/core/realm/array_basic.hpp b/Pods/Realm/include/core/realm/array_basic.hpp
new file mode 100644
index 0000000..f67f2c3
--- /dev/null
+++ b/Pods/Realm/include/core/realm/array_basic.hpp
@@ -0,0 +1,118 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_ARRAY_BASIC_HPP
+#define REALM_ARRAY_BASIC_HPP
+
+#include <realm/array.hpp>
+
+namespace realm {
+
+/// A BasicArray can currently only be used for simple unstructured
+/// types like float, double.
+template<class T>
+class BasicArray: public Array {
+public:
+    explicit BasicArray(Allocator&) noexcept;
+    explicit BasicArray(no_prealloc_tag) noexcept;
+    ~BasicArray() noexcept override {}
+
+    T get(size_t ndx) const noexcept;
+    bool is_null(size_t ndx) const noexcept;
+    void add(T value);
+    void set(size_t ndx, T value);
+    void set_null(size_t ndx);
+    void insert(size_t ndx, T value);
+    void erase(size_t ndx);
+    void truncate(size_t size);
+    void clear();
+
+    size_t find_first(T value, size_t begin = 0 , size_t end = npos) const;
+    void find_all(IntegerColumn* result, T value, size_t add_offset = 0,
+                  size_t begin = 0, size_t end = npos) const;
+
+    size_t count(T value, size_t begin = 0, size_t end = npos) const;
+    bool maximum(T& result, size_t begin = 0, size_t end = npos) const;
+    bool minimum(T& result, size_t begin = 0, size_t end = npos) const;
+
+    /// Compare two arrays for equality.
+    bool compare(const BasicArray<T>&) const;
+
+    /// Get the specified element without the cost of constructing an
+    /// array instance. If an array instance is already available, or
+    /// you need to get multiple values, then this method will be
+    /// slower.
+    static T get(const char* header, size_t ndx) noexcept;
+
+    ref_type bptree_leaf_insert(size_t ndx, T, TreeInsertBase& state);
+
+    size_t lower_bound(T value) const noexcept;
+    size_t upper_bound(T value) const noexcept;
+
+    /// Construct a basic array of the specified size and return just
+    /// the reference to the underlying memory. All elements will be
+    /// initialized to `T()`.
+    static MemRef create_array(size_t size, Allocator&);
+
+    static MemRef create_array(Array::Type leaf_type, bool context_flag, size_t size, T value,
+                               Allocator&);
+
+    /// Create a new empty array and attach this accessor to it. This
+    /// does not modify the parent reference information of this
+    /// accessor.
+    ///
+    /// Note that the caller assumes ownership of the allocated
+    /// underlying node. It is not owned by the accessor.
+    void create(Array::Type = type_Normal, bool context_flag = false);
+
+    /// Construct a copy of the specified slice of this basic array
+    /// using the specified target allocator.
+    MemRef slice(size_t offset, size_t size, Allocator& target_alloc) const;
+    MemRef slice_and_clone_children(size_t offset, size_t size, Allocator& target_alloc) const;
+
+#ifdef REALM_DEBUG
+    void to_dot(std::ostream&, StringData title = StringData()) const;
+#endif
+
+private:
+    size_t find(T target, size_t begin, size_t end) const;
+
+    size_t calc_byte_len(size_t count, size_t width) const override;
+    virtual size_t calc_item_count(size_t bytes, size_t width) const noexcept override;
+
+    template<bool find_max>
+    bool minmax(T& result, size_t begin, size_t end) const;
+
+    /// Calculate the total number of bytes needed for a basic array
+    /// with the specified number of elements. This includes the size
+    /// of the header. The result will be upwards aligned to the
+    /// closest 8-byte boundary.
+    static size_t calc_aligned_byte_size(size_t size);
+};
+
+
+// Class typedefs for BasicArray's: ArrayFloat and ArrayDouble
+typedef BasicArray<float> ArrayFloat;
+typedef BasicArray<double> ArrayDouble;
+
+} // namespace realm
+
+#include <realm/array_basic_tpl.hpp>
+
+#endif // REALM_ARRAY_BASIC_HPP
diff --git a/Pods/Realm/include/core/realm/array_basic_tpl.hpp b/Pods/Realm/include/core/realm/array_basic_tpl.hpp
new file mode 100644
index 0000000..3b122d1
--- /dev/null
+++ b/Pods/Realm/include/core/realm/array_basic_tpl.hpp
@@ -0,0 +1,468 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_ARRAY_BASIC_TPL_HPP
+#define REALM_ARRAY_BASIC_TPL_HPP
+
+#include <algorithm>
+#include <limits>
+#include <stdexcept>
+#include <iomanip>
+
+#include <realm/impl/destroy_guard.hpp>
+
+namespace realm {
+
+template<class T>
+inline BasicArray<T>::BasicArray(Allocator& allocator) noexcept:
+    Array(allocator)
+{
+}
+
+template<class T>
+inline BasicArray<T>::BasicArray(no_prealloc_tag) noexcept:
+    Array(no_prealloc_tag())
+{
+}
+
+
+template<class T>
+inline MemRef BasicArray<T>::create_array(size_t init_size, Allocator& allocator)
+{
+    size_t byte_size_0 = calc_aligned_byte_size(init_size); // Throws
+    // Adding zero to Array::initial_capacity to avoid taking the
+    // address of that member
+    size_t byte_size = std::max(byte_size_0, Array::initial_capacity+0); // Throws
+
+    MemRef mem = allocator.alloc(byte_size); // Throws
+
+    bool is_inner_bptree_node = false;
+    bool has_refs = false;
+    bool context_flag = false;
+    int width = sizeof (T);
+    init_header(mem.get_addr(), is_inner_bptree_node, has_refs, context_flag, wtype_Multiply,
+                width, init_size, byte_size);
+
+    return mem;
+}
+
+
+template<class T>
+inline MemRef BasicArray<T>::create_array(Array::Type type, bool context_flag, size_t init_size,
+                                          T value, Allocator& allocator)
+{
+    REALM_ASSERT(type == Array::type_Normal);
+    REALM_ASSERT(!context_flag);
+    MemRef mem = create_array(init_size, allocator);
+    if (init_size) {
+        BasicArray<T> tmp(allocator);
+        tmp.init_from_mem(mem);
+        for (size_t i = 0; i < init_size; ++i) {
+            tmp.set(i, value);
+        }
+        return tmp.get_mem();
+    }
+    return mem;
+}
+
+
+template<class T>
+inline void BasicArray<T>::create(Array::Type type, bool context_flag)
+{
+    REALM_ASSERT(type == Array::type_Normal);
+    REALM_ASSERT(!context_flag);
+    size_t length = 0;
+    MemRef mem = create_array(length, get_alloc()); // Throws
+    init_from_mem(mem);
+}
+
+
+template<class T>
+MemRef BasicArray<T>::slice(size_t offset, size_t slice_size, Allocator& target_alloc) const
+{
+    REALM_ASSERT(is_attached());
+
+    // FIXME: This can be optimized as a single contiguous copy
+    // operation.
+    BasicArray array_slice(target_alloc);
+    _impl::ShallowArrayDestroyGuard dg(&array_slice);
+    array_slice.create(); // Throws
+    size_t begin = offset;
+    size_t end   = offset + slice_size;
+    for (size_t i = begin; i != end; ++i) {
+        T value = get(i);
+        array_slice.add(value); // Throws
+    }
+    dg.release();
+    return array_slice.get_mem();
+}
+
+template<class T>
+MemRef BasicArray<T>::slice_and_clone_children(size_t offset, size_t slice_size,
+                                               Allocator& target_alloc) const
+{
+    // BasicArray<T> never contains refs, so never has children.
+    return slice(offset, slice_size, target_alloc);
+}
+
+
+template<class T>
+inline void BasicArray<T>::add(T value)
+{
+    insert(m_size, value);
+}
+
+
+template<class T>
+inline T BasicArray<T>::get(size_t ndx) const noexcept
+{
+    return *(reinterpret_cast<const T*>(m_data) + ndx);
+}
+
+
+template<class T>
+inline bool BasicArray<T>::is_null(size_t ndx) const noexcept
+{
+    // FIXME: This assumes BasicArray will only ever be instantiated for float-like T.
+    auto x = get(ndx);
+    return null::is_null_float(x);
+}
+
+
+template<class T>
+inline T BasicArray<T>::get(const char* header, size_t ndx) noexcept
+{
+    const char* data = get_data_from_header(header);
+    // FIXME: This casting assumes that T can be aliged on an 8-bype
+    // boundary (since data is aligned on an 8-byte boundary.) This
+    // restricts portability. The same problem recurs several times in
+    // the remainder of this file.
+    return *(reinterpret_cast<const T*>(data) + ndx);
+}
+
+
+template<class T>
+inline void BasicArray<T>::set(size_t ndx, T value)
+{
+    REALM_ASSERT_3(ndx, <, m_size);
+
+    // Check if we need to copy before modifying
+    copy_on_write(); // Throws
+
+    // Set the value
+    T* data = reinterpret_cast<T*>(m_data) + ndx;
+    *data = value;
+}
+
+template<class T>
+inline void BasicArray<T>::set_null(size_t ndx)
+{
+    // FIXME: This assumes BasicArray will only ever be instantiated for float-like T.
+    set(ndx, null::get_null_float<T>());
+}
+
+template<class T>
+void BasicArray<T>::insert(size_t ndx, T value)
+{
+    REALM_ASSERT_3(ndx, <=, m_size);
+
+    // Check if we need to copy before modifying
+    copy_on_write(); // Throws
+
+    // Make room for the new value
+    alloc(m_size+1, m_width); // Throws
+
+    // Move values below insertion
+    if (ndx != m_size) {
+        char* src_begin = m_data + ndx*m_width;
+        char* src_end   = m_data + m_size*m_width;
+        char* dst_end   = src_end + m_width;
+        std::copy_backward(src_begin, src_end, dst_end);
+    }
+
+    // Set the value
+    T* data = reinterpret_cast<T*>(m_data) + ndx;
+    *data = value;
+
+     ++m_size;
+}
+
+template<class T>
+void BasicArray<T>::erase(size_t ndx)
+{
+    REALM_ASSERT_3(ndx, <, m_size);
+
+    // Check if we need to copy before modifying
+    copy_on_write(); // Throws
+
+    // move data under deletion up
+    if (ndx < m_size-1) {
+        char* dst_begin = m_data + ndx*m_width;
+        const char* src_begin = dst_begin + m_width;
+        const char* src_end   = m_data + m_size*m_width;
+        std::copy(src_begin, src_end, dst_begin);
+    }
+
+    // Update size (also in header)
+    --m_size;
+    set_header_size(m_size);
+}
+
+template<class T>
+void BasicArray<T>::truncate(size_t to_size)
+{
+    REALM_ASSERT(is_attached());
+    REALM_ASSERT_3(to_size, <=, m_size);
+
+    copy_on_write(); // Throws
+
+    // Update size in accessor and in header. This leaves the capacity
+    // unchanged.
+    m_size = to_size;
+    set_header_size(to_size);
+}
+
+template<class T>
+inline void BasicArray<T>::clear()
+{
+    truncate(0); // Throws
+}
+
+template<class T>
+bool BasicArray<T>::compare(const BasicArray<T>& a) const
+{
+    size_t n = size();
+    if (a.size() != n)
+        return false;
+    const T* data_1 = reinterpret_cast<const T*>(m_data);
+    const T* data_2 = reinterpret_cast<const T*>(a.m_data);
+    return std::equal(data_1, data_1+n, data_2);
+}
+
+
+template<class T>
+size_t BasicArray<T>::calc_byte_len(size_t for_size, size_t) const
+{
+    // FIXME: Consider calling `calc_aligned_byte_size(size)`
+    // instead. Note however, that calc_byte_len() is supposed to return
+    // the unaligned byte size. It is probably the case that no harm
+    // is done by returning the aligned version, and most callers of
+    // calc_byte_len() will actually benefit if calc_byte_len() was
+    // changed to always return the aligned byte size.
+    return header_size + for_size * sizeof (T); // FIXME: Prone to overflow
+}
+
+template<class T>
+size_t BasicArray<T>::calc_item_count(size_t bytes, size_t) const noexcept
+{
+    // FIXME: ??? what about width = 0? return -1?
+
+    size_t bytes_without_header = bytes - header_size;
+    return bytes_without_header / sizeof (T);
+}
+
+template<class T>
+size_t BasicArray<T>::find(T value, size_t begin, size_t end) const
+{
+    if (end == npos)
+        end = m_size;
+    REALM_ASSERT(begin <= m_size && end <= m_size && begin <= end);
+    const T* data = reinterpret_cast<const T*>(m_data);
+    const T* i = std::find(data + begin, data + end, value);
+    return i == data + end ? not_found : size_t(i - data);
+}
+
+template<class T>
+inline size_t BasicArray<T>::find_first(T value, size_t begin, size_t end) const
+{
+    return this->find(value, begin, end);
+}
+
+template<class T>
+void BasicArray<T>::find_all(IntegerColumn* result, T value, size_t add_offset,
+                             size_t begin, size_t end) const
+{
+    size_t first = begin - 1;
+    for (;;) {
+        first = this->find(value, first + 1, end);
+        if (first == not_found)
+            break;
+
+        Array::add_to_column(result, first + add_offset);
+    }
+}
+
+template<class T>
+size_t BasicArray<T>::count(T value, size_t begin, size_t end) const
+{
+    if (end == npos)
+        end = m_size;
+    REALM_ASSERT(begin <= m_size && end <= m_size && begin <= end);
+    const T* data = reinterpret_cast<const T*>(m_data);
+    return std::count(data + begin, data + end, value);
+}
+
+#if 0
+// currently unused
+template<class T>
+double BasicArray<T>::sum(size_t begin, size_t end) const
+{
+    if (end == npos)
+        end = m_size;
+    REALM_ASSERT(begin <= m_size && end <= m_size && begin <= end);
+    const T* data = reinterpret_cast<const T*>(m_data);
+    return std::accumulate(data + begin, data + end, double(0));
+}
+#endif
+
+template<class T>
+template<bool find_max>
+bool BasicArray<T>::minmax(T& result, size_t begin, size_t end) const
+{
+    if (end == npos)
+        end = m_size;
+    if (m_size == 0)
+        return false;
+    REALM_ASSERT(begin < m_size && end <= m_size && begin < end);
+
+    T m = get(begin);
+    ++begin;
+    for (; begin < end; ++begin) {
+        T val = get(begin);
+        if (find_max ? val > m : val < m)
+            m = val;
+    }
+    result = m;
+    return true;
+}
+
+template<class T>
+bool BasicArray<T>::maximum(T& result, size_t begin, size_t end) const
+{
+    return minmax<true>(result, begin, end);
+}
+
+template<class T>
+bool BasicArray<T>::minimum(T& result, size_t begin, size_t end) const
+{
+    return minmax<false>(result, begin, end);
+}
+
+
+template<class T>
+ref_type BasicArray<T>::bptree_leaf_insert(size_t ndx, T value, TreeInsertBase& state)
+{
+    size_t leaf_size = size();
+    REALM_ASSERT_3(leaf_size, <=, REALM_MAX_BPNODE_SIZE);
+    if (leaf_size < ndx)
+        ndx = leaf_size;
+    if (REALM_LIKELY(leaf_size < REALM_MAX_BPNODE_SIZE)) {
+        insert(ndx, value);
+        return 0; // Leaf was not split
+    }
+
+    // Split leaf node
+    BasicArray<T> new_leaf(get_alloc());
+    new_leaf.create(); // Throws
+    if (ndx == leaf_size) {
+        new_leaf.add(value);
+        state.m_split_offset = ndx;
+    }
+    else {
+        // FIXME: Could be optimized by first resizing the target
+        // array, then copy elements with std::copy().
+        for (size_t i = ndx; i != leaf_size; ++i)
+            new_leaf.add(get(i));
+        truncate(ndx);
+        add(value);
+        state.m_split_offset = ndx + 1;
+    }
+    state.m_split_size = leaf_size + 1;
+    return new_leaf.get_ref();
+}
+
+template<class T>
+inline size_t BasicArray<T>::lower_bound(T value) const noexcept
+{
+    const T* begin = reinterpret_cast<const T*>(m_data);
+    const T* end = begin + size();
+    return std::lower_bound(begin, end, value) - begin;
+}
+
+template<class T>
+inline size_t BasicArray<T>::upper_bound(T value) const noexcept
+{
+    const T* begin = reinterpret_cast<const T*>(m_data);
+    const T* end = begin + size();
+    return std::upper_bound(begin, end, value) - begin;
+}
+
+template<class T>
+inline size_t BasicArray<T>::calc_aligned_byte_size(size_t size)
+{
+    size_t max = std::numeric_limits<size_t>::max();
+    size_t max_2 = max & ~size_t(7); // Allow for upwards 8-byte alignment
+    if (size > (max_2 - header_size) / sizeof (T))
+        throw std::runtime_error("Byte size overflow");
+    size_t byte_size = header_size + size * sizeof (T);
+    REALM_ASSERT_3(byte_size, >, 0);
+    size_t aligned_byte_size = ((byte_size-1) | 7) + 1; // 8-byte alignment
+    return aligned_byte_size;
+}
+
+
+#ifdef REALM_DEBUG
+
+template<class T>
+void BasicArray<T>::to_dot(std::ostream& out, StringData title) const
+{
+    ref_type ref = get_ref();
+    if (title.size() != 0) {
+        out << "subgraph cluster_" << ref << " {\n";
+        out << " label = \"" << title << "\";\n";
+        out << " color = white;\n";
+    }
+
+    out << "n" << std::hex << ref << std::dec << "[shape=none,label=<";
+    out << "<TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\" CELLPADDING=\"4\"><TR>\n";
+
+    // Header
+    out << "<TD BGCOLOR=\"lightgrey\"><FONT POINT-SIZE=\"7\"> ";
+    out << "0x" << std::hex << ref << std::dec << "<BR/>";
+    out << "</FONT></TD>\n";
+
+    // Values
+    size_t n = m_size;
+    for (size_t i = 0; i != n; ++i)
+        out << "<TD>" << get(i) << "</TD>\n";
+
+    out << "</TR></TABLE>>];\n";
+
+    if (title.size() != 0)
+        out << "}\n";
+
+    to_dot_parent_edge(out);
+}
+
+#endif // REALM_DEBUG
+
+
+} // namespace realm
+
+#endif // REALM_ARRAY_BASIC_TPL_HPP
diff --git a/Pods/Realm/include/core/realm/array_binary.hpp b/Pods/Realm/include/core/realm/array_binary.hpp
new file mode 100644
index 0000000..576e90e
--- /dev/null
+++ b/Pods/Realm/include/core/realm/array_binary.hpp
@@ -0,0 +1,256 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_ARRAY_BINARY_HPP
+#define REALM_ARRAY_BINARY_HPP
+
+#include <realm/binary_data.hpp>
+#include <realm/array_blob.hpp>
+#include <realm/array_integer.hpp>
+#include <realm/exceptions.hpp>
+
+namespace realm {
+
+/*
+STORAGE FORMAT
+---------------------------------------------------------------------------------------
+ArrayBinary stores binary elements using two ArrayInteger and one ArrayBlob. The ArrayBlob can only store one
+single concecutive array of bytes (contrary to its 'Array' name that misleadingly indicates it could store multiple
+elements).
+
+Assume we have the strings "a", "", "abc", null, "ab". Then the three arrays will contain:
+
+ArrayInteger    m_offsets   1, 1, 5, 5, 6
+ArrayBlob       m_blob      aabcab
+ArrayInteger    m_nulls     0, 0, 0, 1, 0 // 1 indicates null, 0 indicates non-null
+
+So for each element the ArrayInteger, the ArrayInteger points into the ArrayBlob at the position of the first
+byte of the next element.
+
+m_nulls is always present (except for old database files; see below), so any ArrayBinary is always nullable!
+The nullable property (such as throwing exception upon set(null) on non-nullable column, etc) is handled on
+column level only.
+
+DATABASE FILE VERSION CHANGES
+---------------------------------------------------------------------------------------
+Old database files do not have any m_nulls array. To be backwardscompatible, many methods will have tests like
+`if(Array::size() == 3)` and have a backwards compatible code paths for these (e.g. avoid writing to m_nulls
+in set(), etc). This way no file format upgrade is needed to support nulls for BinaryData.
+*/
+
+class ArrayBinary: public Array {
+public:
+    explicit ArrayBinary(Allocator&) noexcept;
+    ~ArrayBinary() noexcept override {}
+
+    /// Create a new empty binary array and attach this accessor to
+    /// it. This does not modify the parent reference information of
+    /// this accessor.
+    ///
+    /// Note that the caller assumes ownership of the allocated
+    /// underlying node. It is not owned by the accessor.
+    void create();
+
+    // Old database files will not have the m_nulls array, so we need code paths for
+    // backwards compatibility for these cases.
+    bool legacy_array_type() const noexcept;
+
+    //@{
+    /// Overriding functions of Array
+    void init_from_ref(ref_type) noexcept;
+    void init_from_mem(MemRef) noexcept;
+    void init_from_parent() noexcept;
+    //@}
+
+    bool is_empty() const noexcept;
+    size_t size() const noexcept;
+
+    BinaryData get(size_t ndx) const noexcept;
+
+    void add(BinaryData value, bool add_zero_term = false);
+    void set(size_t ndx, BinaryData value, bool add_zero_term = false);
+    void insert(size_t ndx, BinaryData value, bool add_zero_term = false);
+    void erase(size_t ndx);
+    void truncate(size_t new_size);
+    void clear();
+    void destroy();
+
+    /// Get the specified element without the cost of constructing an
+    /// array instance. If an array instance is already available, or
+    /// you need to get multiple values, then this method will be
+    /// slower.
+    static BinaryData get(const char* header, size_t ndx, Allocator&) noexcept;
+
+    ref_type bptree_leaf_insert(size_t ndx, BinaryData, bool add_zero_term,
+                                TreeInsertBase& state);
+
+    static size_t get_size_from_header(const char*, Allocator&) noexcept;
+
+    /// Construct a binary array of the specified size and return just
+    /// the reference to the underlying memory. All elements will be
+    /// initialized to the binary value `defaults`, which can be either
+    /// null or zero-length non-null (value with size > 0 is not allowed as
+    /// initialization value).
+    static MemRef create_array(size_t size, Allocator&, BinaryData defaults);
+
+    /// Construct a copy of the specified slice of this binary array
+    /// using the specified target allocator.
+    MemRef slice(size_t offset, size_t slice_size, Allocator& target_alloc) const;
+
+#ifdef REALM_DEBUG
+    void to_dot(std::ostream&, bool is_strings, StringData title = StringData()) const;
+#endif
+    bool update_from_parent(size_t old_baseline) noexcept;
+
+private:
+    ArrayInteger m_offsets;
+    ArrayBlob m_blob;
+    ArrayInteger m_nulls;
+};
+
+
+
+
+
+// Implementation:
+
+inline ArrayBinary::ArrayBinary(Allocator& allocator) noexcept:
+    Array(allocator), m_offsets(allocator), m_blob(allocator),
+    m_nulls(allocator)
+{
+    m_offsets.set_parent(this, 0);
+    m_blob.set_parent(this, 1);
+    m_nulls.set_parent(this, 2);
+}
+
+inline void ArrayBinary::create()
+{
+    size_t init_size = 0;
+    BinaryData defaults = BinaryData(0, 0); // This init value is ignored because size = 0
+    MemRef mem = create_array(init_size, get_alloc(), defaults); // Throws
+    init_from_mem(mem);
+}
+
+inline void ArrayBinary::init_from_ref(ref_type ref) noexcept
+{
+    REALM_ASSERT(ref);
+    char* header = get_alloc().translate(ref);
+    init_from_mem(MemRef(header, ref, m_alloc));
+}
+
+inline void ArrayBinary::init_from_parent() noexcept
+{
+    ref_type ref = get_ref_from_parent();
+    init_from_ref(ref);
+}
+
+inline bool ArrayBinary::is_empty() const noexcept
+{
+    return m_offsets.is_empty();
+}
+
+// Old database files will not have the m_nulls array, so we need code paths for
+// backwards compatibility for these cases. We can test if m_nulls exists by looking
+// at number of references in this ArrayBinary.
+inline bool ArrayBinary::legacy_array_type() const noexcept
+{
+    if (Array::size() == 3)
+        return false;               // New database file
+    else if (Array::size() == 2)
+        return true;                // Old database file
+    else
+        REALM_ASSERT(false);        // Should never happen
+    return false;
+}
+
+inline size_t ArrayBinary::size() const noexcept
+{
+    return m_offsets.size();
+}
+
+inline BinaryData ArrayBinary::get(size_t ndx) const noexcept
+{
+    REALM_ASSERT_3(ndx, <, m_offsets.size());
+
+    if (!legacy_array_type() && m_nulls.get(ndx)) {
+        return BinaryData();
+    }
+    else {
+        size_t begin = ndx ? to_size_t(m_offsets.get(ndx - 1)) : 0;
+        size_t end = to_size_t(m_offsets.get(ndx));
+
+        BinaryData bd = BinaryData(m_blob.get(begin), end - begin);
+        // Old database file (non-nullable column should never return null)
+        REALM_ASSERT(!bd.is_null());
+        return bd;
+    }
+}
+
+inline void ArrayBinary::truncate(size_t new_size)
+{
+    REALM_ASSERT_3(new_size, <, m_offsets.size());
+
+    size_t blob_size = new_size ? to_size_t(m_offsets.get(new_size-1)) : 0;
+
+    m_offsets.truncate(new_size);
+    m_blob.truncate(blob_size);
+    if (!legacy_array_type())
+        m_nulls.truncate(new_size);
+}
+
+inline void ArrayBinary::clear()
+{
+    m_blob.clear();
+    m_offsets.clear();
+    if (!legacy_array_type())
+        m_nulls.clear();
+}
+
+inline void ArrayBinary::destroy()
+{
+    m_blob.destroy();
+    m_offsets.destroy();
+    if (!legacy_array_type())
+        m_nulls.destroy();
+    Array::destroy();
+}
+
+inline size_t ArrayBinary::get_size_from_header(const char* header,
+                                                     Allocator& alloc) noexcept
+{
+    ref_type offsets_ref = to_ref(Array::get(header, 0));
+    const char* offsets_header = alloc.translate(offsets_ref);
+    return Array::get_size_from_header(offsets_header);
+}
+
+inline bool ArrayBinary::update_from_parent(size_t old_baseline) noexcept
+{
+    bool res = Array::update_from_parent(old_baseline);
+    if (res) {
+        m_blob.update_from_parent(old_baseline);
+        m_offsets.update_from_parent(old_baseline);
+        if (!legacy_array_type())
+            m_nulls.update_from_parent(old_baseline);
+    }
+    return res;
+}
+
+} // namespace realm
+
+#endif // REALM_ARRAY_BINARY_HPP
diff --git a/Pods/Realm/include/core/realm/array_blob.hpp b/Pods/Realm/include/core/realm/array_blob.hpp
new file mode 100644
index 0000000..42e7f81
--- /dev/null
+++ b/Pods/Realm/include/core/realm/array_blob.hpp
@@ -0,0 +1,143 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_ARRAY_BLOB_HPP
+#define REALM_ARRAY_BLOB_HPP
+
+#include <realm/array.hpp>
+
+namespace realm {
+
+
+class ArrayBlob: public Array {
+public:
+    explicit ArrayBlob(Allocator&) noexcept;
+    ~ArrayBlob() noexcept override {}
+
+    const char* get(size_t index) const noexcept;
+    bool is_null(size_t index) const noexcept;
+    void add(const char* data, size_t data_size, bool add_zero_term = false);
+    void insert(size_t pos, const char* data, size_t data_size, bool add_zero_term = false);
+    void replace(size_t begin, size_t end, const char* data, size_t data_size,
+                 bool add_zero_term = false);
+    void erase(size_t begin, size_t end);
+
+    /// Get the specified element without the cost of constructing an
+    /// array instance. If an array instance is already available, or
+    /// you need to get multiple values, then this method will be
+    /// slower.
+    static const char* get(const char* header, size_t index) noexcept;
+
+    /// Create a new empty blob (binary) array and attach this
+    /// accessor to it. This does not modify the parent reference
+    /// information of this accessor.
+    ///
+    /// Note that the caller assumes ownership of the allocated
+    /// underlying node. It is not owned by the accessor.
+    void create();
+
+    /// Construct a blob of the specified size and return just the
+    /// reference to the underlying memory. All bytes will be
+    /// initialized to zero.
+    static MemRef create_array(size_t init_size, Allocator&);
+
+#ifdef REALM_DEBUG
+    void verify() const;
+    void to_dot(std::ostream&, StringData title = StringData()) const;
+#endif
+
+private:
+    size_t calc_byte_len(size_t for_size, size_t width) const override;
+    size_t calc_item_count(size_t bytes,
+                              size_t width) const noexcept override;
+};
+
+
+
+
+// Implementation:
+
+// Creates new array (but invalid, call init_from_ref() to init)
+inline ArrayBlob::ArrayBlob(Allocator& allocator) noexcept:
+    Array(allocator)
+{
+}
+
+inline bool ArrayBlob::is_null(size_t index) const noexcept
+{
+    return (get(index) == nullptr);
+}
+
+inline const char* ArrayBlob::get(size_t index) const noexcept
+{
+    return m_data + index;
+}
+
+inline void ArrayBlob::add(const char* data, size_t data_size, bool add_zero_term)
+{
+    replace(m_size, m_size, data, data_size, add_zero_term);
+}
+
+inline void ArrayBlob::insert(size_t pos, const char* data, size_t data_size,
+                              bool add_zero_term)
+{
+    replace(pos, pos, data, data_size, add_zero_term);
+}
+
+inline void ArrayBlob::erase(size_t begin, size_t end)
+{
+    const char* data = nullptr;
+    size_t data_size = 0;
+    replace(begin, end, data, data_size);
+}
+
+inline const char* ArrayBlob::get(const char* header, size_t pos) noexcept
+{
+    const char* data = get_data_from_header(header);
+    return data + pos;
+}
+
+inline void ArrayBlob::create()
+{
+    size_t init_size = 0;
+    MemRef mem = create_array(init_size, get_alloc()); // Throws
+    init_from_mem(mem);
+}
+
+inline MemRef ArrayBlob::create_array(size_t init_size, Allocator& allocator)
+{
+    bool context_flag = false;
+    int_fast64_t value = 0;
+    return Array::create(type_Normal, context_flag, wtype_Ignore, init_size, value, allocator); // Throws
+}
+
+inline size_t ArrayBlob::calc_byte_len(size_t for_size, size_t) const
+{
+    return header_size + for_size;
+}
+
+inline size_t ArrayBlob::calc_item_count(size_t bytes, size_t) const noexcept
+{
+    return bytes - header_size;
+}
+
+
+} // namespace realm
+
+#endif // REALM_ARRAY_BLOB_HPP
diff --git a/Pods/Realm/include/core/realm/array_blobs_big.hpp b/Pods/Realm/include/core/realm/array_blobs_big.hpp
new file mode 100644
index 0000000..26e56cc
--- /dev/null
+++ b/Pods/Realm/include/core/realm/array_blobs_big.hpp
@@ -0,0 +1,220 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_ARRAY_BIG_BLOBS_HPP
+#define REALM_ARRAY_BIG_BLOBS_HPP
+
+#include <realm/array_blob.hpp>
+
+namespace realm {
+
+
+class ArrayBigBlobs: public Array {
+public:
+    typedef BinaryData value_type;
+
+    explicit ArrayBigBlobs(Allocator&, bool nullable) noexcept;
+
+    BinaryData get(size_t ndx) const noexcept;
+    void set(size_t ndx, BinaryData value, bool add_zero_term = false);
+    void add(BinaryData value, bool add_zero_term = false);
+    void insert(size_t ndx, BinaryData value, bool add_zero_term = false);
+    void erase(size_t ndx);
+    void truncate(size_t new_size);
+    void clear();
+    void destroy();
+
+    size_t count(BinaryData value, bool is_string = false, size_t begin = 0,
+                      size_t end = npos) const noexcept;
+    size_t find_first(BinaryData value, bool is_string = false, size_t begin = 0,
+                           size_t end = npos) const noexcept;
+    void find_all(IntegerColumn& result, BinaryData value, bool is_string = false,
+                  size_t add_offset = 0,
+                  size_t begin = 0, size_t end = npos);
+
+    /// Get the specified element without the cost of constructing an
+    /// array instance. If an array instance is already available, or
+    /// you need to get multiple values, then this method will be
+    /// slower.
+    static BinaryData get(const char* header, size_t ndx, Allocator&) noexcept;
+
+    ref_type bptree_leaf_insert(size_t ndx, BinaryData, bool add_zero_term,
+                                TreeInsertBase& state);
+
+    //@{
+    /// Those that return a string, discard the terminating zero from
+    /// the stored value. Those that accept a string argument, add a
+    /// terminating zero before storing the value.
+    StringData get_string(size_t ndx) const noexcept;
+    void add_string(StringData value);
+    void set_string(size_t ndx, StringData value);
+    void insert_string(size_t ndx, StringData value);
+    static StringData get_string(const char* header, size_t ndx, Allocator&, bool nullable) noexcept;
+    ref_type bptree_leaf_insert_string(size_t ndx, StringData, TreeInsertBase& state);
+    //@}
+
+    /// Create a new empty big blobs array and attach this accessor to
+    /// it. This does not modify the parent reference information of
+    /// this accessor.
+    ///
+    /// Note that the caller assumes ownership of the allocated
+    /// underlying node. It is not owned by the accessor.
+    void create();
+
+    /// Construct a copy of the specified slice of this big blobs
+    /// array using the specified target allocator.
+    MemRef slice(size_t offset, size_t slice_size, Allocator& target_alloc) const;
+
+#ifdef REALM_DEBUG
+    void verify() const;
+    void to_dot(std::ostream&, bool is_strings, StringData title = StringData()) const;
+#endif
+
+private:
+    bool m_nullable;
+};
+
+
+
+// Implementation:
+
+inline ArrayBigBlobs::ArrayBigBlobs(Allocator& allocator, bool nullable) noexcept:
+                                    Array(allocator), m_nullable(nullable)
+{
+}
+
+inline BinaryData ArrayBigBlobs::get(size_t ndx) const noexcept
+{
+    ref_type ref = get_as_ref(ndx);
+    if (ref == 0)
+        return BinaryData(); // realm::null();
+
+    const char* blob_header = get_alloc().translate(ref);
+    const char* value = ArrayBlob::get(blob_header, 0);
+    size_t blob_size = get_size_from_header(blob_header);
+    return BinaryData(value, blob_size);
+}
+
+inline BinaryData ArrayBigBlobs::get(const char* header, size_t ndx,
+                                     Allocator& alloc) noexcept
+{
+    ref_type blob_ref = to_ref(Array::get(header, ndx));
+    if (blob_ref == 0)
+        return BinaryData();
+
+    const char* blob_header = alloc.translate(blob_ref);
+    const char* blob_data = Array::get_data_from_header(blob_header);
+    size_t blob_size = Array::get_size_from_header(blob_header);
+    return BinaryData(blob_data, blob_size);
+}
+
+inline void ArrayBigBlobs::erase(size_t ndx)
+{
+    ref_type blob_ref = Array::get_as_ref(ndx);
+    if (blob_ref != 0) { // nothing to destroy if null
+        Array::destroy(blob_ref, get_alloc()); // Shallow
+    }
+    Array::erase(ndx);
+}
+
+inline void ArrayBigBlobs::truncate(size_t new_size)
+{
+    Array::truncate_and_destroy_children(new_size);
+}
+
+inline void ArrayBigBlobs::clear()
+{
+    Array::clear_and_destroy_children();
+}
+
+inline void ArrayBigBlobs::destroy()
+{
+    Array::destroy_deep();
+}
+
+inline StringData ArrayBigBlobs::get_string(size_t ndx) const noexcept
+{
+    BinaryData bin = get(ndx);
+    if (bin.is_null())
+        return realm::null();
+    else
+        return StringData(bin.data(), bin.size()-1); // Do not include terminating zero
+}
+
+inline void ArrayBigBlobs::set_string(size_t ndx, StringData value)
+{
+    REALM_ASSERT_DEBUG(!(!m_nullable && value.is_null()));
+    BinaryData bin(value.data(), value.size());
+    bool add_zero_term = true;
+    set(ndx, bin, add_zero_term);
+}
+
+inline void ArrayBigBlobs::add_string(StringData value)
+{
+    REALM_ASSERT_DEBUG(!(!m_nullable && value.is_null()));
+    BinaryData bin(value.data(), value.size());
+    bool add_zero_term = true;
+    add(bin, add_zero_term);
+}
+
+inline void ArrayBigBlobs::insert_string(size_t ndx, StringData value)
+{
+    REALM_ASSERT_DEBUG(!(!m_nullable && value.is_null()));
+    BinaryData bin(value.data(), value.size());
+    bool add_zero_term = true;
+    insert(ndx, bin, add_zero_term);
+}
+
+inline StringData ArrayBigBlobs::get_string(const char* header, size_t ndx,
+                                            Allocator& alloc, bool nullable) noexcept
+{
+    static_cast<void>(nullable);
+    BinaryData bin = get(header, ndx, alloc);
+    REALM_ASSERT_DEBUG(!(!nullable && bin.is_null()));
+    if (bin.is_null())
+        return realm::null();
+    else
+        return StringData(bin.data(), bin.size()-1); // Do not include terminating zero
+}
+
+inline ref_type ArrayBigBlobs::bptree_leaf_insert_string(size_t ndx, StringData value,
+                                                         TreeInsertBase& state)
+{
+    REALM_ASSERT_DEBUG(!(!m_nullable && value.is_null()));
+    BinaryData bin(value.data(), value.size());
+    bool add_zero_term = true;
+    return bptree_leaf_insert(ndx, bin, add_zero_term, state);
+}
+
+inline void ArrayBigBlobs::create()
+{
+    bool context_flag = true;
+    Array::create(type_HasRefs, context_flag); // Throws
+}
+
+inline MemRef ArrayBigBlobs::slice(size_t offset, size_t slice_size,
+                                   Allocator& target_alloc) const
+{
+    return slice_and_clone_children(offset, slice_size, target_alloc);
+}
+
+
+} // namespace realm
+
+#endif // REALM_ARRAY_BIG_BLOBS_HPP
diff --git a/Pods/Realm/include/core/realm/array_integer.hpp b/Pods/Realm/include/core/realm/array_integer.hpp
new file mode 100644
index 0000000..e501b6a
--- /dev/null
+++ b/Pods/Realm/include/core/realm/array_integer.hpp
@@ -0,0 +1,675 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+***************************************************************************/
+
+#ifndef REALM_ARRAY_INTEGER_HPP
+#define REALM_ARRAY_INTEGER_HPP
+
+#include <realm/array.hpp>
+#include <realm/util/safe_int_ops.hpp>
+#include <realm/util/optional.hpp>
+
+namespace realm {
+
+class ArrayInteger: public Array {
+public:
+    typedef int64_t value_type;
+
+    explicit ArrayInteger(no_prealloc_tag) noexcept;
+    explicit ArrayInteger(Allocator&) noexcept;
+    ~ArrayInteger() noexcept override {}
+
+    void create(Type type = type_Normal, bool context_flag = false);
+
+    void add(int64_t value);
+    void set(size_t ndx, int64_t value);
+    void set_uint(size_t ndx, uint64_t value) noexcept;
+    int64_t get(size_t ndx) const noexcept;
+    uint64_t get_uint(size_t ndx) const noexcept;
+    static int64_t get(const char* header, size_t ndx) noexcept;
+    bool compare(const ArrayInteger& a) const noexcept;
+
+    /// Add \a diff to the element at the specified index.
+    void adjust(size_t ndx, int_fast64_t diff);
+
+    /// Add \a diff to all the elements in the specified index range.
+    void adjust(size_t begin, size_t end, int_fast64_t diff);
+
+    /// Add signed \a diff to all elements that are greater than, or equal to \a
+    /// limit.
+    void adjust_ge(int_fast64_t limit, int_fast64_t diff);
+
+    int64_t operator[](size_t ndx) const noexcept { return get(ndx); }
+    int64_t front() const noexcept;
+    int64_t back() const noexcept;
+
+    size_t lower_bound(int64_t value) const noexcept;
+    size_t upper_bound(int64_t value) const noexcept;
+
+    std::vector<int64_t> to_vector() const;
+
+private:
+    template<size_t w>
+    bool minmax(size_t from, size_t to, uint64_t maxdiff,
+                                   int64_t* min, int64_t* max) const;
+};
+
+class ArrayIntNull: public Array {
+public:
+    using value_type = util::Optional<int64_t>;
+
+    explicit ArrayIntNull(no_prealloc_tag) noexcept;
+    explicit ArrayIntNull(Allocator&) noexcept;
+    ~ArrayIntNull() noexcept override;
+
+    /// Construct an array of the specified type and size, and return just the
+    /// reference to the underlying memory. All elements will be initialized to
+    /// the specified value.
+    static MemRef create_array(Type, bool context_flag, size_t size, value_type value,
+                               Allocator&);
+    void create(Type = type_Normal, bool context_flag = false);
+
+    void init_from_ref(ref_type) noexcept;
+    void init_from_mem(MemRef) noexcept;
+    void init_from_parent() noexcept;
+
+    size_t size() const noexcept;
+    bool is_empty() const noexcept;
+
+    void insert(size_t ndx, value_type value);
+    void add(value_type value);
+    void set(size_t ndx, value_type value) noexcept;
+    value_type get(size_t ndx) const noexcept;
+    static value_type get(const char* header, size_t ndx) noexcept;
+    void get_chunk(size_t ndx, value_type res[8]) const noexcept;
+    void set_null(size_t ndx) noexcept;
+    bool is_null(size_t ndx) const noexcept;
+    int64_t null_value() const noexcept;
+
+    value_type operator[](size_t ndx) const noexcept;
+    value_type front() const noexcept;
+    value_type back() const noexcept;
+    void erase(size_t ndx);
+    void erase(size_t begin, size_t end);
+    void truncate(size_t size);
+    void clear();
+    void set_all_to_zero();
+
+    void move(size_t begin, size_t end, size_t dest_begin);
+    void move_backward(size_t begin, size_t end, size_t dest_end);
+
+    size_t lower_bound(int64_t value) const noexcept;
+    size_t upper_bound(int64_t value) const noexcept;
+
+    int64_t sum(size_t start = 0, size_t end = npos) const;
+    size_t count(int64_t value) const noexcept;
+    bool maximum(int64_t& result, size_t start = 0, size_t end = npos,
+        size_t* return_ndx = nullptr) const;
+    bool minimum(int64_t& result, size_t start = 0, size_t end = npos,
+                 size_t* return_ndx = nullptr) const;
+
+    bool find(int cond, Action action, value_type value, size_t start, size_t end, size_t baseindex,
+              QueryState<int64_t>* state) const;
+
+    template<class cond, Action action, size_t bitwidth, class Callback>
+    bool find(value_type value, size_t start, size_t end, size_t baseindex,
+              QueryState<int64_t>* state, Callback callback) const;
+
+    // This is the one installed into the m_finder slots.
+    template<class cond, Action action, size_t bitwidth>
+    bool find(int64_t value, size_t start, size_t end, size_t baseindex,
+              QueryState<int64_t>* state) const;
+
+    template<class cond, Action action, class Callback>
+    bool find(value_type value, size_t start, size_t end, size_t baseindex,
+              QueryState<int64_t>* state, Callback callback) const;
+
+    // Optimized implementation for release mode
+    template<class cond, Action action, size_t bitwidth, class Callback>
+    bool find_optimized(value_type value, size_t start, size_t end, size_t baseindex,
+                        QueryState<int64_t>* state, Callback callback) const;
+
+    // Called for each search result
+    template<Action action, class Callback>
+    bool find_action(size_t index, value_type value,
+                     QueryState<int64_t>* state, Callback callback) const;
+
+    template<Action action, class Callback>
+    bool find_action_pattern(size_t index, uint64_t pattern,
+                             QueryState<int64_t>* state, Callback callback) const;
+
+    // Wrappers for backwards compatibility and for simple use without
+    // setting up state initialization etc
+    template<class cond>
+    size_t find_first(value_type value, size_t start = 0,
+                           size_t end = npos) const;
+
+    void find_all(IntegerColumn* result, value_type value, size_t col_offset = 0,
+                  size_t begin = 0, size_t end = npos) const;
+
+
+    size_t find_first(value_type value, size_t begin = 0, size_t end = npos) const;
+
+
+    // Overwrite Array::bptree_leaf_insert to correctly split nodes.
+    ref_type bptree_leaf_insert(size_t ndx, value_type value, TreeInsertBase& state);
+
+    MemRef slice(size_t offset, size_t slice_size, Allocator& target_alloc) const;
+
+    /// Construct a deep copy of the specified slice of this array using the
+    /// specified target allocator. Subarrays will be cloned.
+    MemRef slice_and_clone_children(size_t offset, size_t slice_size,
+                                    Allocator& target_alloc) const;
+protected:
+    void avoid_null_collision(int64_t value);
+private:
+    template<bool find_max>
+    bool minmax_helper(int64_t& result, size_t start = 0, size_t end = npos,
+                         size_t* return_ndx = nullptr) const;
+
+    int_fast64_t choose_random_null(int64_t incoming) const;
+    void replace_nulls_with(int64_t new_null);
+    bool can_use_as_null(int64_t value) const;
+};
+
+
+// Implementation:
+
+inline ArrayInteger::ArrayInteger(Array::no_prealloc_tag) noexcept:
+    Array(Array::no_prealloc_tag())
+{
+    m_is_inner_bptree_node = false;
+}
+
+inline ArrayInteger::ArrayInteger(Allocator& allocator) noexcept:
+    Array(allocator)
+{
+    m_is_inner_bptree_node = false;
+}
+
+inline void ArrayInteger::add(int64_t value)
+{
+    Array::add(value);
+}
+
+inline int64_t ArrayInteger::get(size_t ndx) const noexcept
+{
+    return Array::get(ndx);
+}
+
+inline int64_t ArrayInteger::get(const char* header, size_t ndx) noexcept
+{
+    return Array::get(header, ndx);
+}
+
+inline void ArrayInteger::set(size_t ndx, int64_t value)
+{
+    Array::set(ndx, value);
+}
+
+inline void ArrayInteger::set_uint(size_t ndx, uint_fast64_t value) noexcept
+{
+    // When a value of a signed type is converted to an unsigned type, the C++
+    // standard guarantees that negative values are converted from the native
+    // representation to 2's complement, but the effect of conversions in the
+    // opposite direction is left unspecified by the
+    // standard. `realm::util::from_twos_compl()` is used here to perform the
+    // correct opposite unsigned-to-signed conversion, which reduces to a no-op
+    // when 2's complement is the native representation of negative values.
+    set(ndx, util::from_twos_compl<int_fast64_t>(value));
+}
+
+inline bool ArrayInteger::compare(const ArrayInteger& a) const noexcept
+{
+    if (a.size() != size())
+        return false;
+
+    for (size_t i = 0; i < size(); ++i) {
+        if (get(i) != a.get(i))
+            return false;
+    }
+
+    return true;
+}
+
+inline int64_t ArrayInteger::front() const noexcept
+{
+    return Array::front();
+}
+
+inline int64_t ArrayInteger::back() const noexcept
+{
+    return Array::back();
+}
+
+inline void ArrayInteger::adjust(size_t ndx, int_fast64_t diff)
+{
+    Array::adjust(ndx, diff);
+}
+
+inline void ArrayInteger::adjust(size_t begin, size_t end, int_fast64_t diff)
+{
+    Array::adjust(begin, end, diff);
+}
+
+inline void ArrayInteger::adjust_ge(int_fast64_t limit, int_fast64_t diff)
+{
+    Array::adjust_ge(limit, diff);
+}
+
+inline size_t ArrayInteger::lower_bound(int64_t value) const noexcept
+{
+    return lower_bound_int(value);
+}
+
+inline size_t ArrayInteger::upper_bound(int64_t value) const noexcept
+{
+    return upper_bound_int(value);
+}
+
+
+inline
+ArrayIntNull::ArrayIntNull(no_prealloc_tag tag) noexcept: Array(tag)
+{
+}
+
+inline
+ArrayIntNull::ArrayIntNull(Allocator& allocator) noexcept: Array(allocator)
+{
+}
+
+inline
+ArrayIntNull::~ArrayIntNull() noexcept
+{
+}
+
+inline
+void ArrayIntNull::create(Type type, bool context_flag)
+{
+    MemRef r = create_array(type, context_flag, 0, util::none, m_alloc);
+    init_from_mem(r);
+}
+
+
+
+inline
+size_t ArrayIntNull::size() const noexcept
+{
+    return Array::size() - 1;
+}
+
+inline
+bool ArrayIntNull::is_empty() const noexcept
+{
+    return size() == 0;
+}
+
+inline
+void ArrayIntNull::insert(size_t ndx, value_type value)
+{
+    if (value) {
+        avoid_null_collision(*value);
+        Array::insert(ndx + 1, *value);
+    }
+    else {
+        Array::insert(ndx + 1, null_value());
+    }
+}
+
+inline
+void ArrayIntNull::add(value_type value)
+{
+    if (value) {
+        avoid_null_collision(*value);
+        Array::add(*value);
+    }
+    else {
+        Array::add(null_value());
+    }
+}
+
+inline
+void ArrayIntNull::set(size_t ndx, value_type value) noexcept
+{
+    if (value) {
+        avoid_null_collision(*value);
+        Array::set(ndx + 1, *value);
+    }
+    else {
+        Array::set(ndx + 1, null_value());
+    }
+}
+
+inline
+void ArrayIntNull::set_null(size_t ndx) noexcept
+{
+    Array::set(ndx + 1, null_value());
+}
+
+inline
+ArrayIntNull::value_type ArrayIntNull::get(size_t ndx) const noexcept
+{
+    int64_t value = Array::get(ndx + 1);
+    if (value == null_value()) {
+        return util::none;
+    }
+    return util::some<int64_t>(value);
+}
+
+inline
+ArrayIntNull::value_type ArrayIntNull::get(const char* header, size_t ndx) noexcept
+{
+    int64_t null_value = Array::get(header, 0);
+    int64_t value = Array::get(header, ndx + 1);
+    if (value == null_value) {
+        return util::none;
+    }
+    else {
+        return util::some<int64_t>(value);
+    }
+}
+
+inline
+bool ArrayIntNull::is_null(size_t ndx) const noexcept
+{
+    return !get(ndx);
+}
+
+inline
+int64_t ArrayIntNull::null_value() const noexcept
+{
+    return Array::get(0);
+}
+
+inline
+ArrayIntNull::value_type ArrayIntNull::operator[](size_t ndx) const noexcept
+{
+    return get(ndx);
+}
+
+inline
+ArrayIntNull::value_type ArrayIntNull::front() const noexcept
+{
+    return get(0);
+}
+
+inline
+ArrayIntNull::value_type ArrayIntNull::back() const noexcept
+{
+    return Array::back();
+}
+
+inline
+void ArrayIntNull::erase(size_t ndx)
+{
+    Array::erase(ndx + 1);
+}
+
+inline
+void ArrayIntNull::erase(size_t begin, size_t end)
+{
+    Array::erase(begin + 1, end + 1);
+}
+
+inline
+void ArrayIntNull::truncate(size_t to_size)
+{
+    Array::truncate(to_size + 1);
+}
+
+inline
+void ArrayIntNull::clear()
+{
+    truncate(0);
+}
+
+inline
+void ArrayIntNull::set_all_to_zero()
+{
+    // FIXME: Array::set_all_to_zero does something else
+    for (size_t i = 0; i < size(); ++i) {
+        set(i, 0);
+    }
+}
+
+inline
+void ArrayIntNull::move(size_t begin, size_t end, size_t dest_begin)
+{
+    Array::move(begin + 1, end + 1, dest_begin + 1);
+}
+
+inline
+void ArrayIntNull::move_backward(size_t begin, size_t end, size_t dest_end)
+{
+    Array::move_backward(begin + 1, end + 1, dest_end + 1);
+}
+
+inline
+size_t ArrayIntNull::lower_bound(int64_t value) const noexcept
+{
+    // FIXME: Consider this behaviour with NULLs.
+    // Array::lower_bound_int assumes an already sorted array, but
+    // this array could be sorted with nulls first or last.
+    return Array::lower_bound_int(value);
+}
+
+inline
+size_t ArrayIntNull::upper_bound(int64_t value) const noexcept
+{
+    // FIXME: see lower_bound
+    return Array::upper_bound_int(value);
+}
+
+inline
+int64_t ArrayIntNull::sum(size_t start, size_t end) const
+{
+    // FIXME: Optimize!
+    int64_t sum_of_range = 0;
+    if (end == npos)
+        end = size();
+    for (size_t i = start; i < end; ++i) {
+        value_type x = get(i);
+        if (x) {
+            sum_of_range += *x;
+        }
+    }
+    return sum_of_range;
+}
+
+inline
+size_t ArrayIntNull::count(int64_t value) const noexcept
+{
+    size_t count_of_value = Array::count(value);
+    if (value == null_value()) {
+        --count_of_value;
+    }
+    return count_of_value;
+}
+
+// FIXME: Optimize!
+template<bool find_max>
+inline
+bool ArrayIntNull::minmax_helper(int64_t& result, size_t start, size_t end, size_t* return_ndx) const
+{
+    size_t best_index = 1;
+
+    if (end == npos) {
+        end = m_size;
+    }
+
+    ++start;
+
+    REALM_ASSERT(start < m_size && end <= m_size && start < end);
+
+    if (m_size == 1) {
+        // empty array
+        return false;
+    }
+
+    if (m_width == 0) {
+        if (return_ndx)
+            *return_ndx = best_index - 1;
+        result = 0;
+        return true;
+    }
+
+    int64_t m = Array::get(start);
+
+    const int64_t null_val = null_value();
+    for (; start < end; ++start) {
+        const int64_t v = Array::get(start);
+        if (find_max ? v > m : v < m) {
+            if (v == null_val) {
+                continue;
+            }
+            m = v;
+            best_index = start;
+        }
+    }
+
+    result = m;
+    if (return_ndx) {
+        *return_ndx = best_index - 1;
+    }
+    return true;
+}
+
+inline
+bool ArrayIntNull::maximum(int64_t& result, size_t start, size_t end, size_t* return_ndx) const
+{
+    return minmax_helper<true>(result, start, end, return_ndx);
+}
+
+inline
+bool ArrayIntNull::minimum(int64_t& result, size_t start, size_t end, size_t* return_ndx) const
+{
+    return minmax_helper<false>(result, start, end, return_ndx);
+}
+
+inline
+bool ArrayIntNull::find(int cond, Action action, value_type value, size_t start, size_t end, size_t baseindex, QueryState<int64_t>* state) const
+{
+    if (value) {
+        return Array::find(cond, action, *value, start, end, baseindex, state,
+                           true /*treat as nullable array*/,
+                           false /*search parameter given in 'value' argument*/);
+    }
+    else {
+        return Array::find(cond, action, 0 /* unused dummy*/, start, end, baseindex, state,
+                           true /*treat as nullable array*/,
+                           true /*search for null, ignore value argument*/);
+    }
+}
+
+template<class cond, Action action, size_t bitwidth, class Callback>
+bool ArrayIntNull::find(value_type value, size_t start, size_t end, size_t baseindex, QueryState<int64_t>* state, Callback callback) const
+{
+    if (value) {
+        return Array::find<cond, action>(*value, start, end, baseindex, state, std::forward<Callback>(callback),
+                                         true /*treat as nullable array*/,
+                                         false /*search parameter given in 'value' argument*/);
+    }
+    else {
+        return Array::find<cond, action>(0 /*ignored*/, start, end, baseindex, state, std::forward<Callback>(callback),
+                                         true /*treat as nullable array*/,
+                                         true /*search for null, ignore value argument*/);
+    }
+}
+
+
+template<class cond, Action action, size_t bitwidth>
+bool ArrayIntNull::find(int64_t value, size_t start, size_t end, size_t baseindex, QueryState<int64_t>* state) const
+{
+    return Array::find<cond, action>(value, start, end, baseindex, state,
+                                     true /*treat as nullable array*/,
+                                     false /*search parameter given in 'value' argument*/);
+}
+
+
+template<class cond, Action action, class Callback>
+bool ArrayIntNull::find(value_type value, size_t start, size_t end, size_t baseindex, QueryState<int64_t>* state, Callback callback) const
+{
+    if (value) {
+        return Array::find<cond, action>(*value, start, end, baseindex, state, std::forward<Callback>(callback),
+                                         true /*treat as nullable array*/,
+                                         false /*search parameter given in 'value' argument*/);
+    }
+    else {
+        return Array::find<cond, action>(0 /*ignored*/, start, end, baseindex, state, std::forward<Callback>(callback),
+                                         true /*treat as nullable array*/,
+                                         true /*search for null, ignore value argument*/);
+    }
+}
+
+
+template<Action action, class Callback>
+bool ArrayIntNull::find_action(size_t index, value_type value, QueryState<int64_t>* state, Callback callback) const
+{
+    if (value) {
+        return Array::find_action<action, Callback>(index, *value, state, callback,
+                                                    true /*treat as nullable array*/,
+                                                    false /*search parameter given in 'value' argument*/);
+    }
+    else {
+        return Array::find_action<action, Callback>(index, 0 /* ignored */, state, callback,
+                                                    true /*treat as nullable array*/,
+                                                    true /*search for null, ignore value argument*/);
+    }
+}
+
+
+template<Action action, class Callback>
+bool ArrayIntNull::find_action_pattern(size_t index, uint64_t pattern, QueryState<int64_t>* state, Callback callback) const
+{
+    return Array::find_action_pattern<action, Callback>(index, pattern, state, callback,
+                                                        true /*treat as nullable array*/,
+                                                        false /*search parameter given in 'value' argument*/);
+}
+
+
+template<class cond>
+size_t ArrayIntNull::find_first(value_type value, size_t start, size_t end) const
+{
+    QueryState<int64_t> state;
+    state.init(act_ReturnFirst, nullptr, 1);
+    if (value) {
+        Array::find<cond, act_ReturnFirst>(*value, start, end, 0, &state, Array::CallbackDummy(),
+                                           true /*treat as nullable array*/,
+                                           false /*search parameter given in 'value' argument*/);
+    }
+    else {
+        Array::find<cond, act_ReturnFirst>(0 /*ignored*/, start, end, 0, &state, Array::CallbackDummy(),
+                                           true /*treat as nullable array*/,
+                                           true /*search for null, ignore value argument*/);
+    }
+
+    if (state.m_match_count > 0)
+        return to_size_t(state.m_state);
+    else
+        return not_found;
+}
+
+inline size_t ArrayIntNull::find_first(value_type value, size_t begin, size_t end) const
+{
+    return find_first<Equal>(value, begin, end);
+}
+
+}
+
+#endif // REALM_ARRAY_INTEGER_HPP
diff --git a/Pods/Realm/include/core/realm/array_string.hpp b/Pods/Realm/include/core/realm/array_string.hpp
new file mode 100644
index 0000000..f4f9bc3
--- /dev/null
+++ b/Pods/Realm/include/core/realm/array_string.hpp
@@ -0,0 +1,190 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_ARRAY_STRING_HPP
+#define REALM_ARRAY_STRING_HPP
+
+#include <realm/array.hpp>
+
+namespace realm {
+
+/*
+ArrayString stores strings as a concecutive list of fixed-length blocks of m_width bytes. The
+longest string it can store is (m_width - 1) bytes before it needs to expand.
+
+An example of the format for m_width = 4 is following sequence of bytes, where x is payload:
+
+xxx0 xx01 x002 0003 0004 (strings "xxx",. "xx", "x", "", realm::null())
+
+So each string is 0 terminated, and the last byte in a block tells how many 0s are present, except
+for a realm::null() which has the byte set to m_width (4). The byte is used to compute the length of a string
+in various functions.
+
+New: If m_witdh = 0, then all elements are realm::null(). So to add an empty string we must expand m_width
+New: StringData is null() if-and-only-if StringData::data() == 0.
+*/
+
+class ArrayString: public Array {
+public:
+    static const size_t max_width = 64;
+
+    typedef StringData value_type;
+    // Constructor defaults to non-nullable because we use non-nullable ArrayString so many places internally in core
+    // (data which isn't user payload) where null isn't needed.
+    explicit ArrayString(Allocator&, bool nullable = false) noexcept;
+    explicit ArrayString(no_prealloc_tag) noexcept;
+    ~ArrayString() noexcept override {}
+
+    bool is_null(size_t ndx) const;
+    void set_null(size_t ndx);
+    StringData get(size_t ndx) const noexcept;
+    void add();
+    void add(StringData value);
+    void set(size_t ndx, StringData value);
+    void insert(size_t ndx, StringData value);
+    void erase(size_t ndx);
+
+    size_t count(StringData value, size_t begin = 0,
+                      size_t end = npos) const noexcept;
+    size_t find_first(StringData value, size_t begin = 0,
+                           size_t end = npos) const noexcept;
+    void find_all(IntegerColumn& result, StringData value, size_t add_offset = 0,
+                  size_t begin = 0, size_t end = npos);
+
+    /// Compare two string arrays for equality.
+    bool compare_string(const ArrayString&) const noexcept;
+
+    /// Get the specified element without the cost of constructing an
+    /// array instance. If an array instance is already available, or
+    /// you need to get multiple values, then this method will be
+    /// slower.
+    static StringData get(const char* header, size_t ndx, bool nullable) noexcept;
+
+    ref_type bptree_leaf_insert(size_t ndx, StringData, TreeInsertBase& state);
+
+    /// Construct a string array of the specified size and return just
+    /// the reference to the underlying memory. All elements will be
+    /// initialized to the empty string.
+    static MemRef create_array(size_t size, Allocator&);
+
+    /// Create a new empty string array and attach this accessor to
+    /// it. This does not modify the parent reference information of
+    /// this accessor.
+    ///
+    /// Note that the caller assumes ownership of the allocated
+    /// underlying node. It is not owned by the accessor.
+    void create();
+
+    /// Construct a copy of the specified slice of this string array
+    /// using the specified target allocator.
+    MemRef slice(size_t offset, size_t slice_size, Allocator& target_alloc) const;
+
+#ifdef REALM_DEBUG
+    void string_stats() const;
+    void to_dot(std::ostream&, StringData title = StringData()) const;
+#endif
+
+private:
+    size_t calc_byte_len(size_t num_items, size_t width) const override;
+    size_t calc_item_count(size_t bytes,
+                              size_t width) const noexcept override;
+
+    bool m_nullable;
+};
+
+
+
+// Implementation:
+
+// Creates new array (but invalid, call init_from_ref() to init)
+inline ArrayString::ArrayString(Allocator& allocator, bool nullable) noexcept:
+Array(allocator), m_nullable(nullable)
+{
+}
+
+// Fastest way to instantiate an Array. For use with GetDirect() that only fills out m_width, m_data
+// and a few other basic things needed for read-only access. Or for use if you just want a way to call
+// some methods written in ArrayString.*
+inline ArrayString::ArrayString(no_prealloc_tag) noexcept:
+    Array(*static_cast<Allocator*>(nullptr))
+{
+}
+
+inline void ArrayString::create()
+{
+    size_t init_size = 0;
+    MemRef mem = create_array(init_size, get_alloc()); // Throws
+    init_from_mem(mem);
+}
+
+inline MemRef ArrayString::create_array(size_t init_size, Allocator& allocator)
+{
+    bool context_flag = false;
+    int_fast64_t value = 0;
+    return Array::create(type_Normal, context_flag, wtype_Multiply, init_size, value, allocator); // Throws
+}
+
+inline StringData ArrayString::get(size_t ndx) const noexcept
+{
+    REALM_ASSERT_3(ndx, <, m_size);
+    if (m_width == 0)
+        return m_nullable ? realm::null() : StringData("");
+
+    const char* data = m_data + (ndx * m_width);
+    size_t array_size = (m_width-1) - data[m_width-1];
+
+    if (array_size == static_cast<size_t>(-1))
+        return m_nullable ? realm::null() : StringData("");
+
+    REALM_ASSERT_EX(data[array_size] == 0, data[array_size], array_size); // Realm guarantees 0 terminated return strings
+    return StringData(data, array_size);
+}
+
+inline void ArrayString::add(StringData value)
+{
+    REALM_ASSERT(!(!m_nullable && value.is_null()));
+    insert(m_size, value); // Throws
+}
+
+inline void ArrayString::add()
+{
+    add(m_nullable ? realm::null() : StringData("")); // Throws
+}
+
+inline StringData ArrayString::get(const char* header, size_t ndx, bool nullable) noexcept
+{
+    REALM_ASSERT(ndx < get_size_from_header(header));
+    uint_least8_t width = get_width_from_header(header);
+    const char* data = get_data_from_header(header) + (ndx * width);
+
+    if (width == 0)
+        return nullable ? realm::null() : StringData("");
+
+    size_t size = (width-1) - data[width-1];
+
+    if (size == static_cast<size_t>(-1))
+        return nullable ? realm::null() : StringData("");
+
+    return StringData(data, size);
+}
+
+
+} // namespace realm
+
+#endif // REALM_ARRAY_STRING_HPP
diff --git a/Pods/Realm/include/core/realm/array_string_long.hpp b/Pods/Realm/include/core/realm/array_string_long.hpp
new file mode 100644
index 0000000..70c88cd
--- /dev/null
+++ b/Pods/Realm/include/core/realm/array_string_long.hpp
@@ -0,0 +1,227 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_ARRAY_STRING_LONG_HPP
+#define REALM_ARRAY_STRING_LONG_HPP
+
+#include <realm/array_blob.hpp>
+#include <realm/array_integer.hpp>
+
+namespace realm {
+
+
+class ArrayStringLong: public Array {
+public:
+    typedef StringData value_type;
+
+    explicit ArrayStringLong(Allocator&, bool nullable) noexcept;
+    ~ArrayStringLong() noexcept override{}
+
+    /// Create a new empty long string array and attach this accessor to
+    /// it. This does not modify the parent reference information of
+    /// this accessor.
+    ///
+    /// Note that the caller assumes ownership of the allocated
+    /// underlying node. It is not owned by the accessor.
+    void create();
+
+    //@{
+    /// Overriding functions of Array
+    void init_from_ref(ref_type) noexcept;
+    void init_from_mem(MemRef) noexcept;
+    void init_from_parent() noexcept;
+    //@}
+
+    bool is_empty() const noexcept;
+    size_t size() const noexcept;
+
+    StringData get(size_t ndx) const noexcept;
+
+
+    void add(StringData value);
+    void set(size_t ndx, StringData value);
+    void insert(size_t ndx, StringData value);
+    void erase(size_t ndx);
+    void truncate(size_t size);
+    void clear();
+    void destroy();
+
+    bool is_null(size_t ndx) const;
+    void set_null(size_t ndx);
+
+    size_t count(StringData value, size_t begin = 0,
+                      size_t end = npos) const noexcept;
+    size_t find_first(StringData value, size_t begin = 0,
+                           size_t end = npos) const noexcept;
+    void find_all(IntegerColumn &result, StringData value, size_t add_offset = 0,
+                  size_t begin = 0, size_t end = npos) const;
+
+    /// Get the specified element without the cost of constructing an
+    /// array instance. If an array instance is already available, or
+    /// you need to get multiple values, then this method will be
+    /// slower.
+    static StringData get(const char* header, size_t ndx, Allocator&, bool nullable) noexcept;
+
+    ref_type bptree_leaf_insert(size_t ndx, StringData, TreeInsertBase&);
+
+    static size_t get_size_from_header(const char*, Allocator&) noexcept;
+
+    /// Construct a long string array of the specified size and return
+    /// just the reference to the underlying memory. All elements will
+    /// be initialized to zero size blobs.
+    static MemRef create_array(size_t size, Allocator&, bool nullable);
+
+    /// Construct a copy of the specified slice of this long string
+    /// array using the specified target allocator.
+    MemRef slice(size_t offset, size_t slice_size, Allocator& target_alloc) const;
+
+#ifdef REALM_DEBUG
+    void to_dot(std::ostream&, StringData title = StringData()) const;
+#endif
+
+    bool update_from_parent(size_t old_baseline) noexcept;
+private:
+    ArrayInteger m_offsets;
+    ArrayBlob m_blob;
+    Array m_nulls;
+    bool m_nullable;
+};
+
+
+
+
+// Implementation:
+inline ArrayStringLong::ArrayStringLong(Allocator& allocator, bool nullable) noexcept:
+    Array(allocator), m_offsets(allocator), m_blob(allocator),
+    m_nulls(nullable ? allocator : Allocator::get_default()), m_nullable(nullable)
+{
+    m_offsets.set_parent(this, 0);
+    m_blob.set_parent(this, 1);
+    if (nullable)
+        m_nulls.set_parent(this, 2);
+}
+
+inline void ArrayStringLong::create()
+{
+    size_t init_size = 0;
+    MemRef mem = create_array(init_size, get_alloc(), m_nullable); // Throws
+    init_from_mem(mem);
+}
+
+inline void ArrayStringLong::init_from_ref(ref_type ref) noexcept
+{
+    REALM_ASSERT(ref);
+    char* header = get_alloc().translate(ref);
+    init_from_mem(MemRef(header, ref, m_alloc));
+    m_nullable = (Array::size() == 3);
+}
+
+inline void ArrayStringLong::init_from_parent() noexcept
+{
+    ref_type ref = get_ref_from_parent();
+    init_from_ref(ref);
+}
+
+inline bool ArrayStringLong::is_empty() const noexcept
+{
+    return m_offsets.is_empty();
+}
+
+inline size_t ArrayStringLong::size() const noexcept
+{
+    return m_offsets.size();
+}
+
+inline StringData ArrayStringLong::get(size_t ndx) const noexcept
+{
+    REALM_ASSERT_3(ndx, <, m_offsets.size());
+
+    if (m_nullable && m_nulls.get(ndx) == 0)
+        return realm::null();
+
+    size_t begin, end;
+    if (0 < ndx) {
+        // FIXME: Consider how much of a performance problem it is,
+        // that we have to issue two separate calls to read two
+        // consecutive values from an array.
+        begin = to_size_t(m_offsets.get(ndx-1));
+        end   = to_size_t(m_offsets.get(ndx));
+    }
+    else {
+        begin = 0;
+        end   = to_size_t(m_offsets.get(0));
+    }
+    --end; // Discount the terminating zero
+
+    return StringData(m_blob.get(begin), end-begin);
+}
+
+inline void ArrayStringLong::truncate(size_t new_size)
+{
+    REALM_ASSERT_3(new_size, <, m_offsets.size());
+
+    size_t blob_size = new_size ? to_size_t(m_offsets.get(new_size-1)) : 0;
+
+    m_offsets.truncate(new_size);
+    m_blob.truncate(blob_size);
+    if (m_nullable)
+        m_nulls.truncate(new_size);
+}
+
+inline void ArrayStringLong::clear()
+{
+    m_blob.clear();
+    m_offsets.clear();
+    if (m_nullable)
+        m_nulls.clear();
+}
+
+inline void ArrayStringLong::destroy()
+{
+    m_blob.destroy();
+    m_offsets.destroy();
+    if (m_nullable)
+        m_nulls.destroy();
+    Array::destroy();
+}
+
+inline bool ArrayStringLong::update_from_parent(size_t old_baseline) noexcept
+{
+    bool res = Array::update_from_parent(old_baseline);
+    if (res) {
+        m_blob.update_from_parent(old_baseline);
+        m_offsets.update_from_parent(old_baseline);
+        if (m_nullable)
+            m_nulls.update_from_parent(old_baseline);
+    }
+    return res;
+}
+
+inline size_t ArrayStringLong::get_size_from_header(const char* header,
+                                                         Allocator& alloc) noexcept
+{
+    ref_type offsets_ref = to_ref(Array::get(header, 0));
+    const char* offsets_header = alloc.translate(offsets_ref);
+    return Array::get_size_from_header(offsets_header);
+}
+
+
+} // namespace realm
+
+#endif // REALM_ARRAY_STRING_LONG_HPP
diff --git a/Pods/Realm/include/core/realm/binary_data.hpp b/Pods/Realm/include/core/realm/binary_data.hpp
new file mode 100644
index 0000000..c9524f8
--- /dev/null
+++ b/Pods/Realm/include/core/realm/binary_data.hpp
@@ -0,0 +1,218 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_BINARY_DATA_HPP
+#define REALM_BINARY_DATA_HPP
+
+#include <cstddef>
+#include <algorithm>
+#include <string>
+#include <ostream>
+
+#include <realm/util/features.h>
+#include <realm/utilities.hpp>
+#include <realm/owned_data.hpp>
+
+namespace realm {
+
+/// A reference to a chunk of binary data.
+///
+/// This class does not own the referenced memory, nor does it in any other way
+/// attempt to manage the lifetime of it.
+///
+/// \sa StringData
+class BinaryData {
+public:
+    BinaryData() noexcept : m_data(nullptr), m_size(0) {}
+    BinaryData(const char* external_data, size_t data_size) noexcept:
+        m_data(external_data), m_size(data_size) {}
+    template<size_t N>
+    explicit BinaryData(const char (&external_data)[N]):
+        m_data(external_data), m_size(N) {}
+    template<class T, class A>
+    explicit BinaryData(const std::basic_string<char, T, A>&);
+
+    template<class T, class A>
+    explicit operator std::basic_string<char, T, A>() const;
+
+    char operator[](size_t i) const noexcept { return m_data[i]; }
+
+    const char* data() const noexcept { return m_data; }
+    size_t size() const noexcept { return m_size; }
+
+    /// Is this a null reference?
+    ///
+    /// An instance of BinaryData is a null reference when, and only when the
+    /// stored size is zero (size()) and the stored pointer is the null pointer
+    /// (data()).
+    ///
+    /// In the case of the empty byte sequence, the stored size is still zero,
+    /// but the stored pointer is **not** the null pointer. Note that the actual
+    /// value of the pointer is immaterial in this case (as long as it is not
+    /// zero), because when the size is zero, it is an error to dereference the
+    /// pointer.
+    ///
+    /// Conversion of a BinaryData object to `bool` yields the logical negation
+    /// of the result of calling this function. In other words, a BinaryData
+    /// object is converted to true if it is not the null reference, otherwise
+    /// it is converted to false.
+    ///
+    /// It is important to understand that all of the functions and operators in
+    /// this class, and most of the functions in the Realm API in general
+    /// makes no distinction between a null reference and a reference to the
+    /// empty byte sequence. These functions and operators never look at the
+    /// stored pointer if the stored size is zero.
+    bool is_null() const noexcept;
+
+    friend bool operator==(const BinaryData&, const BinaryData&) noexcept;
+    friend bool operator!=(const BinaryData&, const BinaryData&) noexcept;
+
+    //@{
+    /// Trivial bytewise lexicographical comparison.
+    friend bool operator<(const BinaryData&, const BinaryData&) noexcept;
+    friend bool operator>(const BinaryData&, const BinaryData&) noexcept;
+    friend bool operator<=(const BinaryData&, const BinaryData&) noexcept;
+    friend bool operator>=(const BinaryData&, const BinaryData&) noexcept;
+    //@}
+
+    bool begins_with(BinaryData) const noexcept;
+    bool ends_with(BinaryData) const noexcept;
+    bool contains(BinaryData) const noexcept;
+
+    template<class C, class T>
+    friend std::basic_ostream<C,T>& operator<<(std::basic_ostream<C,T>&, const BinaryData&);
+
+    explicit operator bool() const noexcept;
+
+private:
+    const char* m_data;
+    size_t m_size;
+};
+
+/// A read-only chunk of binary data.
+class OwnedBinaryData : public OwnedData {
+public:
+    using OwnedData::OwnedData;
+
+    OwnedBinaryData() = default;
+    OwnedBinaryData(const BinaryData& binary_data):
+        OwnedData(binary_data.data(), binary_data.size()) { }
+
+    BinaryData get() const
+    {
+        return { data(), size() };
+    }
+};
+
+
+
+// Implementation:
+
+template<class T, class A>
+inline BinaryData::BinaryData(const std::basic_string<char, T, A>& s):
+    m_data(s.data()),
+    m_size(s.size())
+{
+}
+
+template<class T, class A>
+inline BinaryData::operator std::basic_string<char, T, A>() const
+{
+    return std::basic_string<char, T, A>(m_data, m_size);
+}
+
+inline bool BinaryData::is_null() const noexcept
+{
+    return !m_data;
+}
+
+inline bool operator==(const BinaryData& a, const BinaryData& b) noexcept
+{
+    return a.m_size == b.m_size && a.is_null() == b.is_null() && safe_equal(a.m_data, a.m_data + a.m_size, b.m_data);
+}
+
+inline bool operator!=(const BinaryData& a, const BinaryData& b) noexcept
+{
+    return !(a == b);
+}
+
+inline bool operator<(const BinaryData& a, const BinaryData& b) noexcept
+{
+    if (a.is_null() || b.is_null())
+        return !a.is_null() < !b.is_null();
+
+    return std::lexicographical_compare(a.m_data, a.m_data + a.m_size,
+                                        b.m_data, b.m_data + b.m_size);
+}
+
+inline bool operator>(const BinaryData& a, const BinaryData& b) noexcept
+{
+    return b < a;
+}
+
+inline bool operator<=(const BinaryData& a, const BinaryData& b) noexcept
+{
+    return !(b < a);
+}
+
+inline bool operator>=(const BinaryData& a, const BinaryData& b) noexcept
+{
+    return !(a < b);
+}
+
+inline bool BinaryData::begins_with(BinaryData d) const noexcept
+{
+    if (is_null() && !d.is_null())
+        return false;
+
+    return d.m_size <= m_size && safe_equal(m_data, m_data + d.m_size, d.m_data);
+}
+
+inline bool BinaryData::ends_with(BinaryData d) const noexcept
+{
+    if (is_null() && !d.is_null())
+        return false;
+
+    return d.m_size <= m_size && safe_equal(m_data + m_size - d.m_size, m_data + m_size, d.m_data);
+}
+
+inline bool BinaryData::contains(BinaryData d) const noexcept
+{
+    if (is_null() && !d.is_null())
+        return false;
+
+    return d.m_size == 0 ||
+        std::search(m_data, m_data + m_size, d.m_data, d.m_data + d.m_size) != m_data + m_size;
+}
+
+template<class C, class T>
+inline std::basic_ostream<C,T>& operator<<(std::basic_ostream<C,T>& out, const BinaryData& d)
+{
+    out << "BinaryData("<<static_cast<const void*>(d.m_data)<<", "<<d.m_size<<")";
+    return out;
+}
+
+inline BinaryData::operator bool() const noexcept
+{
+    return !is_null();
+}
+
+} // namespace realm
+
+#endif // REALM_BINARY_DATA_HPP
diff --git a/Pods/Realm/include/core/realm/bptree.hpp b/Pods/Realm/include/core/realm/bptree.hpp
new file mode 100644
index 0000000..bf4f80b
--- /dev/null
+++ b/Pods/Realm/include/core/realm/bptree.hpp
@@ -0,0 +1,878 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+
+#ifndef REALM_BPTREE_HPP
+#define REALM_BPTREE_HPP
+
+#include <memory> // std::unique_ptr
+#include <realm/array.hpp>
+#include <realm/column_type_traits.hpp>
+#include <realm/impl/destroy_guard.hpp>
+#include <realm/impl/output_stream.hpp>
+
+namespace realm {
+
+/// Specialize BpTree to implement column types.
+template<class T>
+class BpTree;
+
+class ArrayInteger;
+class ArrayIntNull;
+
+class BpTreeBase {
+public:
+    struct unattached_tag {};
+
+    // Accessor concept:
+    Allocator& get_alloc() const noexcept;
+    void destroy() noexcept;
+    void detach();
+    bool is_attached() const noexcept;
+    void set_parent(ArrayParent* parent, size_t ndx_in_parent) noexcept;
+    size_t get_ndx_in_parent() const noexcept;
+    void set_ndx_in_parent(size_t ndx) noexcept;
+    void update_from_parent(size_t old_baseline) noexcept;
+    MemRef clone_deep(Allocator& alloc) const;
+
+    // BpTree interface:
+    const Array& root() const noexcept;
+    Array& root() noexcept;
+    bool root_is_leaf() const noexcept;
+    void introduce_new_root(ref_type new_sibling_ref, Array::TreeInsertBase& state, bool is_append);
+    void replace_root(std::unique_ptr<Array> leaf);
+
+protected:
+    explicit BpTreeBase(std::unique_ptr<Array> root);
+    explicit BpTreeBase(BpTreeBase&&) = default;
+    BpTreeBase& operator=(BpTreeBase&&) = default;
+    std::unique_ptr<Array> m_root;
+
+    struct SliceHandler {
+        virtual MemRef slice_leaf(MemRef leaf_mem, size_t offset, size_t size,
+                                  Allocator& target_alloc) = 0;
+        ~SliceHandler() noexcept {}
+    };
+    static ref_type write_subtree(const Array& root, size_t slice_offset,
+                                  size_t slice_size, size_t table_size,
+                                  SliceHandler&, _impl::OutputStream&);
+    friend class ColumnBase;
+    friend class ColumnBaseSimple;
+private:
+    struct WriteSliceHandler;
+
+    // FIXME: Move B+Tree functionality from Array to this class.
+};
+
+
+// Default implementation of BpTree. This should work for all types that have monomorphic
+// leaves (i.e. all leaves are of the same type).
+template<class T>
+class BpTree : public BpTreeBase {
+public:
+    using value_type = T;
+    using LeafType = typename ColumnTypeTraits<T>::leaf_type;
+
+    /// LeafInfo is used by get_leaf() to provide access to a leaf
+    /// without instantiating unnecessary nodes along the way.
+    /// Upon return, out_leaf with hold a pointer to the leaf containing
+    /// the index given to get_leaf(). If the index happens to be
+    /// in the root node (i.e., the root is a leaf), it will point
+    /// to the root node.
+    /// If the index isn't in the root node, fallback will be initialized
+    /// to represent the leaf holding the node, and out_leaf will be set
+    /// to point to fallback.
+    struct LeafInfo {
+        const LeafType** out_leaf;
+        LeafType* fallback;
+    };
+
+    BpTree();
+    explicit BpTree(BpTreeBase::unattached_tag);
+    explicit BpTree(Allocator& alloc);
+    explicit BpTree(std::unique_ptr<Array> init_root) : BpTreeBase(std::move(init_root)) {}
+    BpTree(BpTree&&) = default;
+    BpTree& operator=(BpTree&&) = default;
+    void init_from_ref(Allocator& alloc, ref_type ref);
+    void init_from_mem(Allocator& alloc, MemRef mem);
+    void init_from_parent();
+
+    size_t size() const noexcept;
+    bool is_empty() const noexcept { return size() == 0; }
+
+    T get(size_t ndx) const noexcept;
+    bool is_null(size_t ndx) const noexcept;
+    void set(size_t, T value);
+    void set_null(size_t);
+    void insert(size_t ndx, T value, size_t num_rows = 1);
+    void erase(size_t ndx, bool is_last = false);
+    void move_last_over(size_t ndx, size_t last_row_ndx);
+    void clear();
+    T front() const noexcept;
+    T back() const noexcept;
+
+    size_t find_first(T value, size_t begin = 0, size_t end = npos) const;
+    void find_all(IntegerColumn& out_indices, T value,
+                  size_t begin = 0, size_t end = npos) const;
+
+    static MemRef create_leaf(Array::Type, size_t size, T value, Allocator&);
+
+    /// See LeafInfo for information about what to put in the inout_leaf
+    /// parameter.
+    ///
+    /// This function cannot be used for modifying operations as it
+    /// does not ensure the presence of an unbroken chain of parent
+    /// accessors. For this reason, the identified leaf should always
+    /// be accessed through the returned const-qualified reference,
+    /// and never directly through the specfied fallback accessor.
+    void get_leaf(size_t ndx, size_t& out_ndx_in_leaf,
+                  LeafInfo& inout_leaf) const noexcept;
+
+    void update_each(Array::UpdateHandler&);
+    void update_elem(size_t, Array::UpdateHandler&);
+
+    void adjust(size_t ndx, T diff);
+    void adjust(T diff);
+    void adjust_ge(T limit, T diff);
+
+    ref_type write(size_t slice_offset, size_t slice_size,
+                   size_t table_size, _impl::OutputStream& out) const;
+
+#if defined(REALM_DEBUG)
+    void verify() const;
+    static size_t verify_leaf(MemRef mem, Allocator& alloc);
+#endif
+    static void leaf_to_dot(MemRef mem, ArrayParent* parent, size_t ndx_in_parent,
+                         std::ostream& out, Allocator& alloc);
+private:
+    LeafType& root_as_leaf();
+    const LeafType& root_as_leaf() const;
+
+    std::unique_ptr<Array> create_root_from_ref(Allocator& alloc, ref_type ref);
+    std::unique_ptr<Array> create_root_from_mem(Allocator& alloc, MemRef mem);
+
+    struct EraseHandler;
+    struct UpdateHandler;
+    struct SetNullHandler;
+    struct SliceHandler;
+    struct AdjustHandler;
+    struct AdjustGEHandler;
+
+    struct LeafValueInserter;
+    struct LeafNullInserter;
+
+    template<class TreeTraits>
+    void bptree_insert(size_t row_ndx, Array::TreeInsert<TreeTraits>& state, size_t num_rows);
+};
+
+
+/// Implementation:
+
+inline BpTreeBase::BpTreeBase(std::unique_ptr<Array> init_root) : m_root(std::move(init_root))
+{
+}
+
+inline
+Allocator& BpTreeBase::get_alloc() const noexcept
+{
+    return m_root->get_alloc();
+}
+
+inline
+void BpTreeBase::destroy() noexcept
+{
+    if (m_root)
+        m_root->destroy_deep();
+}
+
+inline
+void BpTreeBase::detach()
+{
+    m_root->detach();
+}
+
+inline
+bool BpTreeBase::is_attached() const noexcept
+{
+    return m_root->is_attached();
+}
+
+inline
+bool BpTreeBase::root_is_leaf() const noexcept
+{
+    return !m_root->is_inner_bptree_node();
+}
+
+inline
+void BpTreeBase::set_parent(ArrayParent* parent, size_t ndx_in_parent) noexcept
+{
+    m_root->set_parent(parent, ndx_in_parent);
+}
+
+inline
+size_t BpTreeBase::get_ndx_in_parent() const noexcept
+{
+    return m_root->get_ndx_in_parent();
+}
+
+inline
+void BpTreeBase::set_ndx_in_parent(size_t ndx) noexcept
+{
+    m_root->set_ndx_in_parent(ndx);
+}
+
+inline
+void BpTreeBase::update_from_parent(size_t old_baseline) noexcept
+{
+    m_root->update_from_parent(old_baseline);
+}
+
+inline
+MemRef BpTreeBase::clone_deep(Allocator& alloc) const
+{
+    return m_root->clone_deep(alloc);
+}
+
+inline
+const Array& BpTreeBase::root() const noexcept
+{
+    return *m_root;
+}
+
+inline
+Array& BpTreeBase::root() noexcept
+{
+    return *m_root;
+}
+
+template<class T>
+BpTree<T>::BpTree() : BpTree(Allocator::get_default())
+{
+}
+
+template<class T>
+BpTree<T>::BpTree(Allocator& alloc) : BpTreeBase(std::unique_ptr<Array>(new LeafType(alloc)))
+{
+}
+
+template<class T>
+BpTree<T>::BpTree(BpTreeBase::unattached_tag) : BpTreeBase(nullptr)
+{
+}
+
+template<class T>
+std::unique_ptr<Array> BpTree<T>::create_root_from_mem(Allocator& alloc, MemRef mem)
+{
+    const char* header = mem.get_addr();
+    std::unique_ptr<Array> new_root;
+    bool is_inner_bptree_node = Array::get_is_inner_bptree_node_from_header(header);
+
+    bool can_reuse_root_accessor = m_root &&
+                                   &m_root->get_alloc() == &alloc &&
+                                   m_root->is_inner_bptree_node() == is_inner_bptree_node;
+    if (can_reuse_root_accessor) {
+        if (is_inner_bptree_node) {
+            m_root->init_from_mem(mem);
+        }
+        else {
+            static_cast<LeafType&>(*m_root).init_from_mem(mem);
+        }
+        return std::move(m_root); // Same root will be reinstalled.
+    }
+
+    // Not reusing root note, allocating a new one.
+    if (is_inner_bptree_node) {
+        new_root.reset(new Array{alloc});
+        new_root->init_from_mem(mem);
+    }
+    else {
+        std::unique_ptr<LeafType> leaf { new LeafType{alloc} };
+        leaf->init_from_mem(mem);
+        new_root = std::move(leaf);
+    }
+    return new_root;
+}
+
+template<class T>
+std::unique_ptr<Array> BpTree<T>::create_root_from_ref(Allocator& alloc, ref_type ref)
+{
+    MemRef mem = MemRef{alloc.translate(ref), ref, alloc};
+    return create_root_from_mem(alloc, mem);
+}
+
+template<class T>
+void BpTree<T>::init_from_ref(Allocator& alloc, ref_type ref)
+{
+    auto new_root = create_root_from_ref(alloc, ref);
+    replace_root(std::move(new_root));
+}
+
+template<class T>
+void BpTree<T>::init_from_mem(Allocator& alloc, MemRef mem)
+{
+    auto new_root = create_root_from_mem(alloc, mem);
+    replace_root(std::move(new_root));
+}
+
+template<class T>
+void BpTree<T>::init_from_parent()
+{
+    ref_type ref = root().get_ref_from_parent();
+    ArrayParent* parent = m_root->get_parent();
+    size_t ndx_in_parent = m_root->get_ndx_in_parent();
+    auto new_root = create_root_from_ref(get_alloc(), ref);
+    new_root->set_parent(parent, ndx_in_parent);
+    m_root = std::move(new_root);
+}
+
+template<class T>
+typename BpTree<T>::LeafType&
+BpTree<T>::root_as_leaf()
+{
+    REALM_ASSERT_DEBUG(root_is_leaf());
+    REALM_ASSERT_DEBUG(dynamic_cast<LeafType*>(m_root.get()) != nullptr);
+    return static_cast<LeafType&>(root());
+}
+
+template<class T>
+const typename BpTree<T>::LeafType&
+BpTree<T>::root_as_leaf() const
+{
+    REALM_ASSERT_DEBUG(root_is_leaf());
+    REALM_ASSERT_DEBUG(dynamic_cast<const LeafType*>(m_root.get()) != nullptr);
+    return static_cast<const LeafType&>(root());
+}
+
+template<class T>
+size_t BpTree<T>::size() const noexcept
+{
+    if (root_is_leaf()) {
+        return root_as_leaf().size();
+    }
+    return root().get_bptree_size();
+}
+
+template<class T>
+T BpTree<T>::back() const noexcept
+{
+    // FIXME: slow
+    return get(size()-1);
+}
+
+namespace _impl {
+
+// NullableOrNothing encapsulates the behavior of nullable and
+// non-nullable leaf types, so that non-nullable leaf types
+// don't have to implement is_null/set_null but BpTree can still
+// support the interface (and return false / assert when null
+// is not supported).
+template<class Leaf>
+struct NullableOrNothing {
+    static bool is_null(const Leaf& leaf, size_t ndx)
+    {
+        return leaf.is_null(ndx);
+    }
+    static void set_null(Leaf& leaf, size_t ndx)
+    {
+        leaf.set_null(ndx);
+    }
+};
+template<>
+struct NullableOrNothing<ArrayInteger> {
+    static bool is_null(const ArrayInteger&, size_t)
+    {
+        return false;
+    }
+    static void set_null(ArrayInteger&, size_t)
+    {
+        REALM_ASSERT_RELEASE(false);
+    }
+};
+
+}
+
+template<class T>
+bool BpTree<T>::is_null(size_t ndx) const noexcept
+{
+    if (root_is_leaf()) {
+        return _impl::NullableOrNothing<LeafType>::is_null(root_as_leaf(), ndx);
+    }
+    LeafType fallback(get_alloc());
+    const LeafType* leaf;
+    LeafInfo leaf_info { &leaf, &fallback };
+    size_t ndx_in_leaf;
+    get_leaf(ndx, ndx_in_leaf, leaf_info);
+    return _impl::NullableOrNothing<LeafType>::is_null(*leaf, ndx_in_leaf);
+}
+
+template<class T>
+T BpTree<T>::get(size_t ndx) const noexcept
+{
+    REALM_ASSERT_DEBUG_EX(ndx < size(), ndx, size());
+    if (root_is_leaf()) {
+        return root_as_leaf().get(ndx);
+    }
+
+    // Use direct getter to avoid initializing leaf array:
+    std::pair<MemRef, size_t> p = root().get_bptree_leaf(ndx);
+    const char* leaf_header = p.first.get_addr();
+    size_t ndx_in_leaf = p.second;
+    return LeafType::get(leaf_header, ndx_in_leaf);
+}
+
+template<class T>
+template<class TreeTraits>
+void BpTree<T>::bptree_insert(size_t row_ndx, Array::TreeInsert<TreeTraits>& state, size_t num_rows)
+{
+    ref_type new_sibling_ref;
+    for (size_t i = 0; i < num_rows; ++i) {
+        size_t row_ndx_2 = row_ndx == realm::npos ? realm::npos : row_ndx + i;
+        if (root_is_leaf()) {
+            REALM_ASSERT_DEBUG(row_ndx_2 == realm::npos || row_ndx_2 < REALM_MAX_BPNODE_SIZE);
+            new_sibling_ref = root_as_leaf().bptree_leaf_insert(row_ndx_2, state.m_value, state);
+        }
+        else {
+            if (row_ndx_2 == realm::npos) {
+                new_sibling_ref = root().bptree_append(state); // Throws
+            }
+            else {
+                new_sibling_ref = root().bptree_insert(row_ndx_2, state); // Throws
+            }
+        }
+
+        if (REALM_UNLIKELY(new_sibling_ref)) {
+            bool is_append = row_ndx_2 == realm::npos;
+            introduce_new_root(new_sibling_ref, state, is_append);
+        }
+    }
+}
+
+template<class T>
+struct BpTree<T>::LeafValueInserter {
+    using value_type = T;
+    T m_value;
+    LeafValueInserter(T value) : m_value(std::move(value)) {}
+
+    // TreeTraits concept:
+    static ref_type
+    leaf_insert(MemRef leaf_mem, ArrayParent& parent, size_t ndx_in_parent,
+                Allocator& alloc, size_t ndx_in_leaf, Array::TreeInsert<LeafValueInserter>& state)
+    {
+        LeafType leaf { alloc };
+        leaf.init_from_mem(leaf_mem);
+        leaf.set_parent(&parent, ndx_in_parent);
+        // Should not move out of m_value, because the same inserter may be used to perform
+        // multiple insertions (for example, if num_rows > 1).
+        return leaf.bptree_leaf_insert(ndx_in_leaf, state.m_value, state);
+    }
+};
+
+template<class T>
+struct BpTree<T>::LeafNullInserter {
+    using value_type = null;
+    // TreeTraits concept:
+    static ref_type
+    leaf_insert(MemRef leaf_mem, ArrayParent& parent, size_t ndx_in_parent,
+                Allocator& alloc, size_t ndx_in_leaf, Array::TreeInsert<LeafNullInserter>& state)
+    {
+        LeafType leaf { alloc };
+        leaf.init_from_mem(leaf_mem);
+        leaf.set_parent(&parent, ndx_in_parent);
+        return leaf.bptree_leaf_insert(ndx_in_leaf, null{}, state);
+    }
+};
+
+template<class T>
+void BpTree<T>::insert(size_t row_ndx, T value, size_t num_rows)
+{
+    REALM_ASSERT_DEBUG(row_ndx == npos || row_ndx < size());
+    Array::TreeInsert<LeafValueInserter> inserter;
+    inserter.m_value = std::move(value);
+    inserter.m_nullable = std::is_same<T, util::Optional<int64_t>>::value; // FIXME
+    bptree_insert(row_ndx, inserter, num_rows); // Throws
+}
+
+template<class T>
+struct BpTree<T>::UpdateHandler : Array::UpdateHandler
+{
+    LeafType m_leaf;
+    const T m_value;
+    UpdateHandler(BpTreeBase& tree, T value) noexcept:
+        m_leaf(tree.get_alloc()), m_value(std::move(value)) {}
+    void update(MemRef mem, ArrayParent* parent, size_t ndx_in_parent,
+                size_t elem_ndx_in_leaf) override
+    {
+        m_leaf.init_from_mem(mem);
+        m_leaf.set_parent(parent, ndx_in_parent);
+        m_leaf.set(elem_ndx_in_leaf, m_value); // Throws
+    }
+};
+
+template<class T>
+struct BpTree<T>::SetNullHandler : Array::UpdateHandler
+{
+    LeafType m_leaf;
+    SetNullHandler(BpTreeBase& tree) noexcept: m_leaf(tree.get_alloc()) {}
+    void update(MemRef mem, ArrayParent* parent, size_t ndx_in_parent,
+                size_t elem_ndx_in_leaf) override
+    {
+        m_leaf.init_from_mem(mem);
+        m_leaf.set_parent(parent, ndx_in_parent);
+        _impl::NullableOrNothing<LeafType>::set_null(m_leaf, elem_ndx_in_leaf); // Throws
+    }
+};
+
+template<class T>
+void BpTree<T>::set(size_t ndx, T value)
+{
+    if (root_is_leaf()) {
+        root_as_leaf().set(ndx, std::move(value));
+    }
+    else {
+        UpdateHandler set_leaf_elem(*this, std::move(value));
+        m_root->update_bptree_elem(ndx, set_leaf_elem); // Throws
+    }
+}
+
+template<class T>
+void BpTree<T>::set_null(size_t ndx)
+{
+    if (root_is_leaf()) {
+        _impl::NullableOrNothing<LeafType>::set_null(root_as_leaf(), ndx);
+    }
+    else {
+        SetNullHandler set_leaf_elem(*this);
+        m_root->update_bptree_elem(ndx, set_leaf_elem); // Throws;
+    }
+}
+
+template<class T>
+struct BpTree<T>::EraseHandler : Array::EraseHandler {
+    BpTreeBase& m_tree;
+    LeafType m_leaf;
+    bool m_leaves_have_refs; // FIXME: Should be able to eliminate this.
+    EraseHandler(BpTreeBase& tree) noexcept:
+        m_tree(tree),
+        m_leaf(tree.get_alloc()),
+        m_leaves_have_refs(false) {}
+    bool erase_leaf_elem(MemRef leaf_mem, ArrayParent* parent,
+                         size_t leaf_ndx_in_parent,
+                         size_t elem_ndx_in_leaf) override
+    {
+        m_leaf.init_from_mem(leaf_mem);
+        REALM_ASSERT_3(m_leaf.size(), >=, 1);
+        size_t last_ndx = m_leaf.size() - 1;
+        if (last_ndx == 0) {
+            m_leaves_have_refs = m_leaf.has_refs();
+            return true;
+        }
+        m_leaf.set_parent(parent, leaf_ndx_in_parent);
+        size_t ndx = elem_ndx_in_leaf;
+        if (ndx == npos)
+            ndx = last_ndx;
+        m_leaf.erase(ndx); // Throws
+        return false;
+    }
+    void destroy_leaf(MemRef leaf_mem) noexcept override
+    {
+        // FIXME: Seems like this would cause file space leaks if
+        // m_leaves_have_refs is true, but consider carefully how
+        // m_leaves_have_refs get its value.
+        m_tree.get_alloc().free_(leaf_mem);
+    }
+    void replace_root_by_leaf(MemRef leaf_mem) override
+    {
+        std::unique_ptr<LeafType> leaf{new LeafType(m_tree.get_alloc())}; // Throws
+        leaf->init_from_mem(leaf_mem);
+        m_tree.replace_root(std::move(leaf)); // Throws
+    }
+    void replace_root_by_empty_leaf() override
+    {
+        std::unique_ptr<LeafType> leaf{new LeafType(m_tree.get_alloc())}; // Throws
+        leaf->create(m_leaves_have_refs ? Array::type_HasRefs :
+                     Array::type_Normal); // Throws
+        m_tree.replace_root(std::move(leaf)); // Throws
+    }
+};
+
+template<class T>
+void BpTree<T>::erase(size_t ndx, bool is_last)
+{
+    REALM_ASSERT_DEBUG_EX(ndx < size(), ndx, size());
+    REALM_ASSERT_DEBUG(is_last == (ndx == size()-1));
+    if (root_is_leaf()) {
+        root_as_leaf().erase(ndx);
+    }
+    else {
+        size_t ndx_2 = is_last ? npos : ndx;
+        EraseHandler handler(*this);
+        Array::erase_bptree_elem(m_root.get(), ndx_2, handler);
+    }
+}
+
+template<class T>
+void BpTree<T>::move_last_over(size_t row_ndx, size_t last_row_ndx)
+{
+    // Copy value from last row over
+    T value = get(last_row_ndx);
+    set(row_ndx, value);
+    erase(last_row_ndx, true);
+}
+
+template<class T>
+void BpTree<T>::clear()
+{
+    if (root_is_leaf()) {
+        if (std::is_same<T, int64_t>::value && root().get_type() == Array::type_HasRefs) {
+            // FIXME: This is because some column types rely on integer columns
+            // to contain refs.
+            root().clear_and_destroy_children();
+        }
+        else {
+            root_as_leaf().clear();
+        }
+    }
+    else {
+        Allocator& alloc = get_alloc();
+        root().destroy_deep();
+
+        std::unique_ptr<LeafType> new_root(new LeafType(alloc));
+        new_root->create();
+        replace_root(std::move(new_root));
+    }
+}
+
+
+template<class T>
+struct BpTree<T>::AdjustHandler : Array::UpdateHandler {
+    LeafType m_leaf;
+    const T m_diff;
+    AdjustHandler(BpTreeBase& tree, T diff) : m_leaf(tree.get_alloc()),
+        m_diff(diff)
+    {}
+
+    void update(MemRef mem, ArrayParent* parent, size_t ndx_in_parent, size_t) final
+    {
+        m_leaf.init_from_mem(mem);
+        m_leaf.set_parent(parent, ndx_in_parent);
+        m_leaf.adjust(0, m_leaf.size(), m_diff);
+    }
+};
+
+template<class T>
+void BpTree<T>::adjust(T diff)
+{
+    if (root_is_leaf()) {
+        root_as_leaf().adjust(0, m_root->size(), std::move(diff)); // Throws
+    }
+    else {
+        AdjustHandler adjust_leaf_elem(*this, std::move(diff));
+        m_root->update_bptree_leaves(adjust_leaf_elem); // Throws
+    }
+}
+
+template<class T>
+void BpTree<T>::adjust(size_t ndx, T diff)
+{
+    static_assert(std::is_arithmetic<T>::value, "adjust is undefined for non-arithmetic trees");
+    set(ndx, get(ndx) + diff);
+}
+
+template<class T>
+struct BpTree<T>::AdjustGEHandler : Array::UpdateHandler {
+    LeafType m_leaf;
+    const T m_limit, m_diff;
+
+    AdjustGEHandler(BpTreeBase& tree, T limit, T diff) : m_leaf(tree.get_alloc()),
+        m_limit(limit), m_diff(diff)
+    {}
+
+    void update(MemRef mem, ArrayParent* parent, size_t ndx_in_parent, size_t) final
+    {
+        m_leaf.init_from_mem(mem);
+        m_leaf.set_parent(parent, ndx_in_parent);
+        m_leaf.adjust_ge(m_limit, m_diff);
+    }
+};
+
+template<class T>
+void BpTree<T>::adjust_ge(T limit, T diff)
+{
+    if (root_is_leaf()) {
+        root_as_leaf().adjust_ge(std::move(limit), std::move(diff)); // Throws
+    }
+    else {
+        AdjustGEHandler adjust_leaf_elem(*this, std::move(limit), std::move(diff));
+        m_root->update_bptree_leaves(adjust_leaf_elem); // Throws
+    }
+}
+
+template<class T>
+struct BpTree<T>::SliceHandler : public BpTreeBase::SliceHandler {
+public:
+    SliceHandler(Allocator& alloc): m_leaf(alloc) {}
+    MemRef slice_leaf(MemRef leaf_mem, size_t offset, size_t size,
+                      Allocator& target_alloc) override
+    {
+        m_leaf.init_from_mem(leaf_mem);
+        return m_leaf.slice_and_clone_children(offset, size, target_alloc); // Throws
+    }
+private:
+    LeafType m_leaf;
+};
+
+template<class T>
+ref_type BpTree<T>::write(size_t slice_offset, size_t slice_size,
+                            size_t table_size, _impl::OutputStream& out) const
+{
+    ref_type ref;
+    if (root_is_leaf()) {
+        Allocator& alloc = Allocator::get_default();
+        MemRef mem = root_as_leaf().slice_and_clone_children(slice_offset, slice_size, alloc); // Throws
+        Array slice(alloc);
+        _impl::DeepArrayDestroyGuard dg(&slice);
+        slice.init_from_mem(mem);
+        bool deep = true;
+        bool only_when_modified = false;
+        ref = slice.write(out, deep, only_when_modified); // Throws
+    }
+    else {
+        SliceHandler handler(get_alloc());
+        ref = write_subtree(root(), slice_offset, slice_size,
+                                table_size, handler, out); // Throws
+    }
+    return ref;
+}
+
+template<class T>
+MemRef BpTree<T>::create_leaf(Array::Type leaf_type, size_t size, T value, Allocator& alloc)
+{
+    bool context_flag = false;
+    return LeafType::create_array(leaf_type, context_flag, size, std::move(value), alloc);
+}
+
+template<class T>
+void BpTree<T>::get_leaf(size_t ndx, size_t& ndx_in_leaf,
+                                  LeafInfo& inout_leaf_info) const noexcept
+{
+    if (root_is_leaf()) {
+        ndx_in_leaf = ndx;
+        *inout_leaf_info.out_leaf = &root_as_leaf();
+        return;
+    }
+    std::pair<MemRef, size_t> p = root().get_bptree_leaf(ndx);
+    inout_leaf_info.fallback->init_from_mem(p.first);
+    ndx_in_leaf = p.second;
+    *inout_leaf_info.out_leaf = inout_leaf_info.fallback;
+}
+
+template<class T>
+size_t BpTree<T>::find_first(T value, size_t begin, size_t end) const
+{
+    if (root_is_leaf()) {
+        return root_as_leaf().find_first(value, begin, end);
+    }
+
+    // FIXME: It would be better to always require that 'end' is
+    // specified explicitly, since Table has the size readily
+    // available, and Array::get_bptree_size() is deprecated.
+    if (end == npos)
+        end = size();
+
+    LeafType leaf_cache(get_alloc());
+    size_t ndx_in_tree = begin;
+    while (ndx_in_tree < end) {
+        const LeafType* leaf;
+        LeafInfo leaf_info { &leaf, &leaf_cache };
+        size_t ndx_in_leaf;
+        get_leaf(ndx_in_tree, ndx_in_leaf, leaf_info);
+        size_t leaf_offset = ndx_in_tree - ndx_in_leaf;
+        size_t end_in_leaf = std::min(leaf->size(), end - leaf_offset);
+        size_t ndx = leaf->find_first(value, ndx_in_leaf, end_in_leaf); // Throws (maybe)
+        if (ndx != not_found)
+            return leaf_offset + ndx;
+        ndx_in_tree = leaf_offset + end_in_leaf;
+    }
+
+    return not_found;
+}
+
+template<class T>
+void BpTree<T>::find_all(IntegerColumn& result, T value, size_t begin, size_t end) const
+{
+    if (root_is_leaf()) {
+        root_as_leaf().find_all(&result, value, 0, begin, end); // Throws
+        return;
+    }
+
+    // FIXME: It would be better to always require that 'end' is
+    // specified explicitely, since Table has the size readily
+    // available, and Array::get_bptree_size() is deprecated.
+    if (end == npos)
+        end = size();
+
+    LeafType leaf_cache(get_alloc());
+    size_t ndx_in_tree = begin;
+    while (ndx_in_tree < end) {
+        const LeafType* leaf;
+        LeafInfo leaf_info { &leaf, &leaf_cache };
+        size_t ndx_in_leaf;
+        get_leaf(ndx_in_tree, ndx_in_leaf, leaf_info);
+        size_t leaf_offset = ndx_in_tree - ndx_in_leaf;
+        size_t end_in_leaf = std::min(leaf->size(), end - leaf_offset);
+        leaf->find_all(&result, value, leaf_offset, ndx_in_leaf, end_in_leaf); // Throws
+        ndx_in_tree = leaf_offset + end_in_leaf;
+    }
+}
+
+#if defined(REALM_DEBUG)
+template<class T>
+size_t BpTree<T>::verify_leaf(MemRef mem, Allocator& alloc)
+{
+    LeafType leaf(alloc);
+    leaf.init_from_mem(mem);
+    leaf.verify();
+    return leaf.size();
+}
+
+template<class T>
+void BpTree<T>::verify() const
+{
+    if (root_is_leaf()) {
+        root_as_leaf().verify();
+    }
+    else {
+        root().verify_bptree(&verify_leaf);
+    }
+}
+#endif // REALM_DEBUG
+
+template<class T>
+void BpTree<T>::leaf_to_dot(MemRef leaf_mem, ArrayParent* parent, size_t ndx_in_parent,
+                                    std::ostream& out, Allocator& alloc)
+{
+    LeafType leaf(alloc);
+    leaf.init_from_mem(leaf_mem);
+    leaf.set_parent(parent, ndx_in_parent);
+    leaf.to_dot(out);
+}
+
+} // namespace realm
+
+#endif // REALM_BPTREE_HPP
diff --git a/Pods/Realm/include/core/realm/column.hpp b/Pods/Realm/include/core/realm/column.hpp
new file mode 100644
index 0000000..854f773
--- /dev/null
+++ b/Pods/Realm/include/core/realm/column.hpp
@@ -0,0 +1,1497 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_COLUMN_HPP
+#define REALM_COLUMN_HPP
+
+#include <stdint.h> // unint8_t etc
+#include <cstdlib> // size_t
+#include <vector>
+#include <memory>
+
+#include <realm/array_integer.hpp>
+#include <realm/column_type.hpp>
+#include <realm/column_fwd.hpp>
+#include <realm/spec.hpp>
+#include <realm/impl/output_stream.hpp>
+#include <realm/query_conditions.hpp>
+#include <realm/bptree.hpp>
+#include <realm/index_string.hpp>
+#include <realm/impl/destroy_guard.hpp>
+#include <realm/exceptions.hpp>
+
+namespace realm {
+
+
+// Pre-definitions
+struct CascadeState;
+class StringIndex;
+
+template<class T>
+struct ImplicitNull;
+
+template<class T>
+struct ImplicitNull<util::Optional<T>> {
+    static constexpr bool value = true;
+};
+
+template<>
+struct ImplicitNull<int64_t> {
+    static constexpr bool value = false;
+};
+
+template<>
+struct ImplicitNull<float> {
+    static constexpr bool value = true;
+};
+
+template<>
+struct ImplicitNull<double> {
+    static constexpr bool value = true;
+};
+
+// FIXME: Add specialization for ImplicitNull for float, double, StringData, BinaryData.
+
+struct ColumnTemplateBase
+{
+    virtual int compare_values(size_t row1, size_t row2) const = 0;
+};
+
+template<class T, class R, Action action, class Condition, class ColType>
+R aggregate(const ColType& column, T target, size_t start, size_t end,
+                size_t limit, size_t* return_ndx);
+
+template<class T>
+struct ColumnTemplate : public ColumnTemplateBase
+{
+    // Overridden in column_string.* because == operator of StringData isn't yet locale aware; todo
+    virtual int compare_values(size_t row1, size_t row2) const
+    {
+        // we negate nullability such that the two ternary statements in this method can look identical to reduce
+        // risk of bugs
+        bool v1 = !is_null(row1);
+        bool v2 = !is_null(row2);
+
+        if (!v1 || !v2)
+            return v1 == v2 ? 0 : v1 < v2 ? 1 : -1;
+
+        T a = get_val(row1);
+        T b = get_val(row2);
+        return a == b ? 0 : a < b ? 1 : -1;
+    }
+
+    // We cannot use already-existing get() methods because StringEnumColumn and LinkList inherit from
+    // Column and overload get() with different return type than int64_t. Todo, find a way to simplify
+    virtual T get_val(size_t row) const = 0;
+    virtual bool is_null(size_t row) const = 0;
+};
+
+/// Base class for all column types.
+class ColumnBase {
+public:
+    /// Get the number of entries in this column. This operation is relatively
+    /// slow.
+    virtual size_t size() const noexcept = 0;
+
+    /// \throw LogicError Thrown if this column is not string valued.
+    virtual void set_string(size_t row_ndx, StringData value);
+
+    /// Whether or not this column is nullable.
+    virtual bool is_nullable() const noexcept;
+
+    /// Whether or not the value at \a row_ndx is NULL. If the column is not
+    /// nullable, always returns false.
+    virtual bool is_null(size_t row_ndx) const noexcept;
+
+    /// Sets the value at \a row_ndx to be NULL.
+    /// \throw LogicError Thrown if this column is not nullable.
+    virtual void set_null(size_t row_ndx);
+
+    //@{
+
+    /// `insert_rows()` inserts the specified number of elements into this column
+    /// starting at the specified row index. The new elements will have the
+    /// default value for the column type.
+    ///
+    /// `erase_rows()` removes the specified number of consecutive elements from
+    /// this column, starting at the specified row index.
+    ///
+    /// `move_last_row_over()` removes the element at the specified row index by
+    /// moving the element at the last row index over it. This reduces the
+    /// number of elements by one.
+    ///
+    /// \param prior_num_rows The number of elements in this column prior to the
+    /// modification.
+    ///
+    /// \param broken_reciprocal_backlinks If true, link columns must assume
+    /// that reciprocal backlinks have already been removed. Non-link columns
+    /// should ignore this argument.
+
+    virtual void insert_rows(size_t row_ndx, size_t num_rows_to_insert, size_t prior_num_rows, bool nullable) = 0;
+    virtual void erase_rows(size_t row_ndx, size_t num_rows_to_erase, size_t prior_num_rows,
+                            bool broken_reciprocal_backlinks) = 0;
+    virtual void move_last_row_over(size_t row_ndx, size_t prior_num_rows,
+                                    bool broken_reciprocal_backlinks) = 0;
+
+    //@}
+
+    /// Remove all elements from this column.
+    ///
+    /// \param num_rows The total number of rows in this column.
+    ///
+    /// \param broken_reciprocal_backlinks If true, link columns must assume
+    /// that reciprocal backlinks have already been removed. Non-link columns
+    /// should ignore this argument.
+    virtual void clear(size_t num_rows, bool broken_reciprocal_backlinks) = 0;
+
+    /// \brief Swap the elements at the specified indices.
+    ///
+    /// Behaviour is undefined if:
+    /// - \a row_ndx_1 or \a row_ndx_2 point to an invalid element (out-of
+    /// bounds)
+    /// - \a row_ndx_1 and \a row_ndx_2 point to the same value
+    virtual void swap_rows(size_t row_ndx_1, size_t row_ndx_2) = 0;
+
+    virtual void destroy() noexcept = 0;
+    void move_assign(ColumnBase& col) noexcept;
+
+    virtual ~ColumnBase() noexcept {}
+
+    // Getter function for index. For integer index, the caller must supply a buffer that we can store the
+    // extracted value in (it may be bitpacked, so we cannot return a pointer in to the Array as we do with
+    // String index).
+    virtual StringData get_index_data(size_t, StringIndex::StringConversionBuffer& buffer) const noexcept = 0;
+
+    // Search index
+    virtual bool supports_search_index() const noexcept;
+    virtual bool has_search_index() const noexcept;
+    virtual StringIndex* create_search_index();
+    virtual void destroy_search_index() noexcept;
+    virtual const StringIndex* get_search_index() const noexcept;
+    virtual StringIndex* get_search_index() noexcept;
+    virtual void set_search_index_ref(ref_type, ArrayParent*, size_t ndx_in_parent,
+                                      bool allow_duplicate_values);
+    virtual void set_search_index_allow_duplicate_values(bool) noexcept;
+
+    virtual Allocator& get_alloc() const noexcept = 0;
+
+    /// Returns the 'ref' of the root array.
+    virtual ref_type get_ref() const noexcept = 0;
+    virtual MemRef get_mem() const noexcept = 0;
+
+    virtual void replace_root_array(std::unique_ptr<Array> leaf) = 0;
+    virtual MemRef clone_deep(Allocator& alloc) const = 0;
+    virtual void detach(void) = 0;
+    virtual bool is_attached(void) const noexcept = 0;
+
+    static size_t get_size_from_type_and_ref(ColumnType, ref_type, Allocator&) noexcept;
+
+    // These assume that the right column compile-time type has been
+    // figured out.
+    static size_t get_size_from_ref(ref_type root_ref, Allocator&);
+    static size_t get_size_from_ref(ref_type spec_ref, ref_type columns_ref, Allocator&);
+
+    /// Write a slice of this column to the specified output stream.
+    virtual ref_type write(size_t slice_offset, size_t slice_size,
+                           size_t table_size, _impl::OutputStream&) const = 0;
+
+    virtual void set_parent(ArrayParent*, size_t ndx_in_parent) noexcept = 0;
+    virtual size_t get_ndx_in_parent() const noexcept = 0;
+    virtual void set_ndx_in_parent(size_t ndx_in_parent) noexcept = 0;
+
+    /// Called to update refs and memory pointers of this column accessor and
+    /// all its nested accessors, but only in cases where the logical contents
+    /// in strictly unchanged. Group::commit(), and
+    /// SharedGroup::commit_and_continue_as_read()() are examples of such
+    /// cases. In both those cases, the purpose is to keep user visible
+    /// accessors in a valid state across a commit.
+    virtual void update_from_parent(size_t old_baseline) noexcept = 0;
+
+    //@{
+
+    /// cascade_break_backlinks_to() is called iteratively for each column by
+    /// Table::cascade_break_backlinks_to() with the same arguments as are
+    /// passed to Table::cascade_break_backlinks_to(). Link columns must
+    /// override it. The same is true for cascade_break_backlinks_to_all_rows(),
+    /// except that it is called from
+    /// Table::cascade_break_backlinks_to_all_rows(), and that it expects
+    /// Table::cascade_break_backlinks_to_all_rows() to pass the number of rows
+    /// in the table as \a num_rows.
+
+    virtual void cascade_break_backlinks_to(size_t row_ndx, CascadeState&);
+    virtual void cascade_break_backlinks_to_all_rows(size_t num_rows, CascadeState&);
+
+    //@}
+
+    void discard_child_accessors() noexcept;
+
+    /// For columns that are able to contain subtables, this function returns
+    /// the pointer to the subtable accessor at the specified row index if it
+    /// exists, otherwise it returns null. For other column types, this function
+    /// returns null.
+    virtual Table* get_subtable_accessor(size_t row_ndx) const noexcept;
+
+    /// Detach and remove the subtable accessor at the specified row if it
+    /// exists. For column types that are unable to contain subtable, this
+    /// function does nothing.
+    virtual void discard_subtable_accessor(size_t row_ndx) noexcept;
+
+    virtual void adj_acc_insert_rows(size_t row_ndx, size_t num_rows) noexcept;
+    virtual void adj_acc_erase_row(size_t row_ndx) noexcept;
+    /// See Table::adj_acc_move_over()
+    virtual void adj_acc_move_over(size_t from_row_ndx,
+                                   size_t to_row_ndx) noexcept;
+    virtual void adj_acc_swap_rows(size_t row_ndx_1, size_t row_ndx_2) noexcept;
+    virtual void adj_acc_clear_root_table() noexcept;
+
+    enum {
+        mark_Recursive   = 0x01,
+        mark_LinkTargets = 0x02,
+        mark_LinkOrigins = 0x04
+    };
+
+    virtual void mark(int type) noexcept;
+
+    virtual void bump_link_origin_table_version() noexcept;
+
+    /// Refresh the dirty part of the accessor subtree rooted at this column
+    /// accessor.
+    ///
+    /// The following conditions are necessary and sufficient for the proper
+    /// operation of this function:
+    ///
+    ///  - The parent table accessor (excluding its column accessors) is in a
+    ///    valid state (already refreshed).
+    ///
+    ///  - Every subtable accessor in the subtree is marked dirty if it needs to
+    ///    be refreshed, or if it has a descendant accessor that needs to be
+    ///    refreshed.
+    ///
+    ///  - This column accessor, as well as all its descendant accessors, are in
+    ///    structural correspondence with the underlying node hierarchy whose
+    ///    root ref is stored in the parent (`Table::m_columns`) (see
+    ///    AccessorConsistencyLevels).
+    ///
+    ///  - The 'index in parent' property of the cached root array
+    ///    (`root->m_ndx_in_parent`) is valid.
+    virtual void refresh_accessor_tree(size_t new_col_ndx, const Spec&) = 0;
+
+#ifdef REALM_DEBUG
+    virtual void verify() const = 0;
+    virtual void verify(const Table&, size_t col_ndx) const;
+    virtual void to_dot(std::ostream&, StringData title = StringData()) const = 0;
+    void dump_node_structure() const; // To std::cerr (for GDB)
+    virtual void do_dump_node_structure(std::ostream&, int level) const = 0;
+    void bptree_to_dot(const Array* root, std::ostream& out) const;
+#endif
+
+protected:
+    using SliceHandler = BpTreeBase::SliceHandler;
+
+    ColumnBase() {}
+    ColumnBase(ColumnBase&&) = default;
+
+    // Must not assume more than minimal consistency (see
+    // AccessorConsistencyLevels).
+    virtual void do_discard_child_accessors() noexcept {}
+
+    //@{
+    /// \tparam L Any type with an appropriate `value_type`, %size(),
+    /// and %get() members.
+    template<class L, class T>
+    size_t lower_bound(const L& list, T value) const noexcept;
+
+    template<class L, class T>
+    size_t upper_bound(const L& list, T value) const noexcept;
+    //@}
+
+    // Node functions
+
+    class CreateHandler {
+    public:
+        virtual ref_type create_leaf(size_t size) = 0;
+        ~CreateHandler() noexcept {}
+    };
+
+    static ref_type create(Allocator&, size_t size, CreateHandler&);
+
+#ifdef REALM_DEBUG
+    class LeafToDot;
+    virtual void leaf_to_dot(MemRef, ArrayParent*, size_t ndx_in_parent,
+                             std::ostream&) const = 0;
+#endif
+
+private:
+    static ref_type build(size_t* rest_size_ptr, size_t fixed_height,
+                          Allocator&, CreateHandler&);
+};
+
+
+// FIXME: Temporary class until all column types have been migrated to use BpTree interface
+class ColumnBaseSimple : public ColumnBase {
+public:
+    //@{
+    /// Returns the array node at the root of this column, but note
+    /// that there is no guarantee that this node is an inner B+-tree
+    /// node or a leaf. This is the case for a MixedColumn in
+    /// particular.
+    Array* get_root_array() noexcept { return m_array.get(); }
+    const Array* get_root_array() const noexcept { return m_array.get(); }
+    //@}
+
+    Allocator& get_alloc() const noexcept final { return m_array->get_alloc(); }
+    void destroy() noexcept override { if (m_array) m_array->destroy_deep(); }
+    ref_type get_ref() const noexcept final { return m_array->get_ref(); }
+    MemRef get_mem() const noexcept final { return m_array->get_mem(); }
+    void detach() noexcept final { m_array->detach(); }
+    bool is_attached() const noexcept final { return m_array->is_attached(); }
+    void set_parent(ArrayParent* parent, size_t ndx_in_parent) noexcept final { m_array->set_parent(parent, ndx_in_parent); }
+    size_t get_ndx_in_parent() const noexcept final { return m_array->get_ndx_in_parent(); }
+    void set_ndx_in_parent(size_t ndx_in_parent) noexcept override { m_array->set_ndx_in_parent(ndx_in_parent); }
+    void update_from_parent(size_t old_baseline) noexcept override { m_array->update_from_parent(old_baseline); }
+    MemRef clone_deep(Allocator& alloc) const override { return m_array->clone_deep(alloc); }
+
+protected:
+    ColumnBaseSimple() {}
+    ColumnBaseSimple(Array* root) : m_array(root) {}
+    std::unique_ptr<Array> m_array;
+
+    void replace_root_array(std::unique_ptr<Array> new_root) final;
+    bool root_is_leaf() const noexcept { return !m_array->is_inner_bptree_node(); }
+
+    /// Introduce a new root node which increments the height of the
+    /// tree by one.
+    void introduce_new_root(ref_type new_sibling_ref, Array::TreeInsertBase& state,
+                            bool is_append);
+
+    static ref_type write(const Array* root, size_t slice_offset, size_t slice_size,
+                          size_t table_size, SliceHandler&, _impl::OutputStream&);
+
+#if defined(REALM_DEBUG)
+    void tree_to_dot(std::ostream&) const;
+#endif
+};
+
+class ColumnBaseWithIndex : public ColumnBase {
+public:
+    ~ColumnBaseWithIndex() noexcept override {}
+    void set_ndx_in_parent(size_t ndx) noexcept override;
+    void update_from_parent(size_t old_baseline) noexcept override;
+    void refresh_accessor_tree(size_t, const Spec&) override;
+    void move_assign(ColumnBaseWithIndex& col) noexcept;
+    void destroy() noexcept override;
+
+    virtual bool supports_search_index() const noexcept override { return true; }
+    bool has_search_index() const noexcept final { return bool(m_search_index); }
+    StringIndex* get_search_index() noexcept final { return m_search_index.get(); }
+    const StringIndex* get_search_index() const noexcept final { return m_search_index.get(); }
+    void destroy_search_index() noexcept override;
+    void set_search_index_ref(ref_type ref, ArrayParent* parent,
+            size_t ndx_in_parent, bool allow_duplicate_valaues) final;
+    StringIndex* create_search_index() override = 0;
+protected:
+    ColumnBaseWithIndex() {}
+    ColumnBaseWithIndex(ColumnBaseWithIndex&&) = default;
+    std::unique_ptr<StringIndex> m_search_index;
+};
+
+
+/// A column (Column) is a single B+-tree, and the root of
+/// the column is the root of the B+-tree. All leaf nodes are arrays.
+template<class T>
+class Column : public ColumnBaseWithIndex, public ColumnTemplate<T> {
+public:
+    using value_type = T;
+    using LeafInfo = typename BpTree<T>::LeafInfo;
+    using LeafType = typename BpTree<T>::LeafType;
+
+    static constexpr bool nullable = ImplicitNull<T>::value;
+
+    struct unattached_root_tag {};
+
+    explicit Column() noexcept : m_tree(Allocator::get_default()) {}
+    explicit Column(std::unique_ptr<Array> root) noexcept;
+    Column(Allocator&, ref_type);
+    Column(unattached_root_tag, Allocator&);
+    Column(Column&&) noexcept = default;
+    ~Column() noexcept override;
+
+    void init_from_parent();
+    void init_from_ref(Allocator&, ref_type);
+    void init_from_mem(Allocator&, MemRef);
+    // Accessor concept:
+    void destroy() noexcept override;
+    Allocator& get_alloc() const noexcept final;
+    ref_type get_ref() const noexcept final;
+    MemRef get_mem() const noexcept final;
+    void set_parent(ArrayParent* parent, size_t ndx_in_parent) noexcept override;
+    size_t get_ndx_in_parent() const noexcept final;
+    void set_ndx_in_parent(size_t ndx) noexcept final;
+    void update_from_parent(size_t old_baseline) noexcept override;
+    void refresh_accessor_tree(size_t, const Spec&) override;
+    void detach() noexcept final;
+    bool is_attached() const noexcept final;
+    MemRef clone_deep(Allocator&) const override;
+
+    void move_assign(Column&);
+
+    size_t size() const noexcept override;
+    bool is_empty() const noexcept { return size() == 0; }
+    bool is_nullable() const noexcept override;
+
+    /// Provides access to the leaf that contains the element at the
+    /// specified index. Upon return \a ndx_in_leaf will be set to the
+    /// corresponding index relative to the beginning of the leaf.
+    ///
+    /// LeafInfo is a struct defined by the underlying BpTree<T>
+    /// data structure, that provides a way for the caller to do
+    /// leaf caching without instantiating too many objects along
+    /// the way.
+    ///
+    /// This function cannot be used for modifying operations as it
+    /// does not ensure the presence of an unbroken chain of parent
+    /// accessors. For this reason, the identified leaf should always
+    /// be accessed through the returned const-qualified reference,
+    /// and never directly through the specfied fallback accessor.
+    void get_leaf(size_t ndx, size_t& ndx_in_leaf,
+        LeafInfo& inout_leaf) const noexcept;
+
+    // Getting and setting values
+    T get_val(size_t ndx) const noexcept final { return get(ndx); }
+    T get(size_t ndx) const noexcept;
+    bool is_null(size_t ndx) const noexcept override;
+    T back() const noexcept;
+    void set(size_t, T value);
+    void set_null(size_t) override;
+    void add(T value = T{});
+    void insert(size_t ndx, T value = T{}, size_t num_rows = 1);
+    void erase(size_t row_ndx);
+    void erase(size_t row_ndx, bool is_last);
+    void move_last_over(size_t row_ndx, size_t last_row_ndx);
+    void clear();
+
+    // Index support
+    StringData get_index_data(size_t ndx, StringIndex::StringConversionBuffer& buffer) const noexcept override;
+
+    // FIXME: Remove these
+    uint64_t get_uint(size_t ndx) const noexcept;
+    ref_type get_as_ref(size_t ndx) const noexcept;
+    void set_uint(size_t ndx, uint64_t value);
+    void set_as_ref(size_t ndx, ref_type value);
+
+    template<class U>
+    void adjust(size_t ndx, U diff);
+
+    template<class U>
+    void adjust(U diff);
+
+    template<class U>
+    void adjust_ge(T limit, U diff);
+
+    size_t count(T target) const;
+
+    typename ColumnTypeTraits<T>::sum_type
+    sum(size_t start = 0, size_t end = npos, size_t limit = npos, size_t* return_ndx = nullptr) const;
+
+    typename ColumnTypeTraits<T>::minmax_type
+    maximum(size_t start = 0, size_t end = npos, size_t limit = npos, size_t* return_ndx = nullptr) const;
+
+    typename ColumnTypeTraits<T>::minmax_type
+    minimum(size_t start = 0, size_t end = npos, size_t limit = npos, size_t* return_ndx = nullptr) const;
+
+    double average(size_t start = 0, size_t end = npos, size_t limit = npos,
+                    size_t* return_ndx = nullptr) const;
+
+    size_t find_first(T value, size_t begin = 0, size_t end = npos) const;
+    void find_all(Column<int64_t>& out_indices, T value,
+                  size_t begin = 0, size_t end = npos) const;
+
+    void populate_search_index();
+    StringIndex* create_search_index() override;
+    inline bool supports_search_index() const noexcept override 
+    { 
+        if (realm::is_any<T, float, double>::value)
+            return false;
+        else
+            return true; 
+    }
+
+
+    //@{
+    /// Find the lower/upper bound for the specified value assuming
+    /// that the elements are already sorted in ascending order
+    /// according to ordinary integer comparison.
+    size_t lower_bound(T value) const noexcept;
+    size_t upper_bound(T value) const noexcept;
+    //@}
+
+    size_t find_gte(T target, size_t start) const;
+
+    bool compare(const Column&) const noexcept;
+
+    static ref_type create(Allocator&, Array::Type leaf_type = Array::type_Normal,
+                           size_t size = 0, T value = T{});
+
+    // Overriding method in ColumnBase
+    ref_type write(size_t, size_t, size_t,
+                   _impl::OutputStream&) const override;
+
+    void insert_rows(size_t, size_t, size_t, bool) override;
+    void erase_rows(size_t, size_t, size_t, bool) override;
+    void move_last_row_over(size_t, size_t, bool) override;
+
+    /// \brief Swap the elements at the specified indices.
+    ///
+    /// If this \c Column has a search index defined, it will be updated to
+    /// reflect the changes induced by the swap.
+    ///
+    /// Behaviour is undefined if:
+    /// - \a row_ndx_1 or \a row_ndx_2 point to an invalid element (out-of
+    /// bounds)
+    /// - \a row_ndx_1 and \a row_ndx_2 point to the same value
+    void swap_rows(size_t, size_t) override;
+    void clear(size_t, bool) override;
+
+    /// \param row_ndx Must be `realm::npos` if appending.
+    void insert_without_updating_index(size_t row_ndx, T value, size_t num_rows);
+
+#ifdef REALM_DEBUG
+    void verify() const override;
+    using ColumnBase::verify;
+    void to_dot(std::ostream&, StringData title) const override;
+    void tree_to_dot(std::ostream&) const;
+    MemStats stats() const;
+    void do_dump_node_structure(std::ostream&, int) const override;
+#endif
+
+    //@{
+    /// Returns the array node at the root of this column, but note
+    /// that there is no guarantee that this node is an inner B+-tree
+    /// node or a leaf. This is the case for a MixedColumn in
+    /// particular.
+    Array* get_root_array() noexcept { return &m_tree.root(); }
+    const Array* get_root_array() const noexcept { return &m_tree.root(); }
+    //@}
+
+protected:
+    bool root_is_leaf() const noexcept { return m_tree.root_is_leaf(); }
+    void replace_root_array(std::unique_ptr<Array> leaf) final { m_tree.replace_root(std::move(leaf)); }
+
+    void set_without_updating_index(size_t row_ndx, T value);
+    void erase_without_updating_index(size_t row_ndx, bool is_last);
+    void move_last_over_without_updating_index(size_t row_ndx, size_t last_row_ndx);
+    void swap_rows_without_updating_index(size_t row_ndx_1, size_t row_ndx_2);
+
+    /// If any element points to an array node, this function recursively
+    /// destroys that array node. Note that the same is **not** true for
+    /// IntegerColumn::do_erase() and IntegerColumn::do_move_last_over().
+    ///
+    /// FIXME: Be careful, clear_without_updating_index() currently forgets
+    /// if the leaf type is Array::type_HasRefs.
+    void clear_without_updating_index();
+
+#ifdef REALM_DEBUG
+    void leaf_to_dot(MemRef, ArrayParent*, size_t ndx_in_parent,
+                     std::ostream&) const override;
+    static void dump_node_structure(const Array& root, std::ostream&, int level);
+#endif
+
+private:
+    class EraseLeafElem;
+    class CreateHandler;
+    class SliceHandler;
+
+    friend class Array;
+    friend class ColumnBase;
+    friend class StringIndex;
+
+    BpTree<T> m_tree;
+
+    void do_erase(size_t row_ndx, size_t num_rows_to_erase, bool is_last);
+};
+
+// Implementation:
+
+inline bool ColumnBase::supports_search_index() const noexcept
+{
+    REALM_ASSERT(!has_search_index());
+    return false;
+}
+
+inline bool ColumnBase::has_search_index() const noexcept
+{
+    return get_search_index() != nullptr;
+}
+
+inline StringIndex* ColumnBase::create_search_index()
+{
+    return nullptr;
+}
+
+inline void ColumnBase::destroy_search_index() noexcept
+{
+}
+
+inline const StringIndex* ColumnBase::get_search_index() const noexcept
+{
+    return nullptr;
+}
+
+inline StringIndex* ColumnBase::get_search_index() noexcept
+{
+    return nullptr;
+}
+
+inline void ColumnBase::set_search_index_ref(ref_type, ArrayParent*, size_t, bool)
+{
+}
+
+inline void ColumnBase::set_search_index_allow_duplicate_values(bool) noexcept
+{
+}
+
+inline void ColumnBase::discard_child_accessors() noexcept
+{
+    do_discard_child_accessors();
+}
+
+inline Table* ColumnBase::get_subtable_accessor(size_t) const noexcept
+{
+    return 0;
+}
+
+inline void ColumnBase::discard_subtable_accessor(size_t) noexcept
+{
+    // Noop
+}
+
+inline void ColumnBase::adj_acc_insert_rows(size_t, size_t) noexcept
+{
+    // Noop
+}
+
+inline void ColumnBase::adj_acc_erase_row(size_t) noexcept
+{
+    // Noop
+}
+
+inline void ColumnBase::adj_acc_move_over(size_t, size_t) noexcept
+{
+    // Noop
+}
+
+inline void ColumnBase::adj_acc_swap_rows(size_t, size_t) noexcept
+{
+    // Noop
+}
+
+inline void ColumnBase::adj_acc_clear_root_table() noexcept
+{
+    // Noop
+}
+
+inline void ColumnBase::mark(int) noexcept
+{
+    // Noop
+}
+
+inline void ColumnBase::bump_link_origin_table_version() noexcept
+{
+    // Noop
+}
+
+template<class T>
+void Column<T>::set_without_updating_index(size_t ndx, T value)
+{
+    m_tree.set(ndx, std::move(value));
+}
+
+template<class T>
+void Column<T>::set(size_t ndx, T value)
+{
+    REALM_ASSERT_DEBUG(ndx < size());
+    if (has_search_index()) {
+        m_search_index->set(ndx, value);
+    }
+    set_without_updating_index(ndx, std::move(value));
+}
+
+template<class T>
+void Column<T>::set_null(size_t ndx)
+{
+    REALM_ASSERT_DEBUG(ndx < size());
+    if (!is_nullable()) {
+        throw LogicError{LogicError::column_not_nullable};
+    }
+    if (has_search_index()) {
+        m_search_index->set(ndx, null{});
+    }
+    m_tree.set_null(ndx);
+}
+
+// When a value of a signed type is converted to an unsigned type, the C++ standard guarantees that negative values
+// are converted from the native representation to 2's complement, but the opposite conversion is left as undefined.
+// realm::util::from_twos_compl() is used here to perform the correct opposite unsigned-to-signed conversion,
+// which reduces to a no-op when 2's complement is the native representation of negative values.
+template<class T>
+void Column<T>::set_uint(size_t ndx, uint64_t value)
+{
+    set(ndx, util::from_twos_compl<int_fast64_t>(value));
+}
+
+template<class T>
+void Column<T>::set_as_ref(size_t ndx, ref_type ref)
+{
+    set(ndx, from_ref(ref));
+}
+
+template<class T>
+template<class U>
+void Column<T>::adjust(size_t ndx, U diff)
+{
+    REALM_ASSERT_3(ndx, <, size());
+    m_tree.adjust(ndx, diff);
+}
+
+template<class T>
+template<class U>
+void Column<T>::adjust(U diff)
+{
+    m_tree.adjust(diff);
+}
+
+template<class T>
+template<class U>
+void Column<T>::adjust_ge(T limit, U diff)
+{
+    m_tree.adjust_ge(limit, diff);
+}
+
+template<class T>
+size_t Column<T>::count(T target) const
+{
+    if (has_search_index()) {
+        return m_search_index->count(target);
+    }
+    return to_size_t(aggregate<T, int64_t, act_Count, Equal>(*this, target, 0, size(), npos, nullptr));
+}
+
+template<class T>
+typename ColumnTypeTraits<T>::sum_type
+Column<T>::sum(size_t start, size_t end, size_t limit, size_t* return_ndx) const
+{
+    using sum_type = typename ColumnTypeTraits<T>::sum_type;
+    if (nullable)
+        return aggregate<T, sum_type, act_Sum, NotNull>(*this, 0, start, end, limit, return_ndx);
+    else
+        return aggregate<T, sum_type, act_Sum, None>(*this, 0, start, end, limit, return_ndx);
+}
+
+template<class T>
+double Column<T>::average(size_t start, size_t end, size_t limit, size_t* return_ndx) const
+{
+    if (end == size_t(-1))
+        end = size();
+
+    auto s = sum(start, end, limit);
+    size_t cnt = to_size_t(aggregate<T, int64_t, act_Count, NotNull>(*this, 0, start, end, limit, nullptr));
+    if (return_ndx)
+        *return_ndx = cnt;
+    double avg = double(s) / (cnt == 0 ? 1 : cnt);
+    return avg;
+}
+
+template<class T>
+typename ColumnTypeTraits<T>::minmax_type
+Column<T>::minimum(size_t start, size_t end, size_t limit, size_t* return_ndx) const
+{
+    using R = typename ColumnTypeTraits<T>::minmax_type;
+    return aggregate<T, R, act_Min, NotNull>(*this, 0, start, end, limit, return_ndx);
+}
+
+template<class T>
+typename ColumnTypeTraits<T>::minmax_type
+Column<T>::maximum(size_t start, size_t end, size_t limit, size_t* return_ndx) const
+{
+    using R = typename ColumnTypeTraits<T>::minmax_type;
+    return aggregate<T, R, act_Max, NotNull>(*this, 0, start, end, limit, return_ndx);
+}
+
+template<class T>
+void Column<T>::get_leaf(size_t ndx, size_t& ndx_in_leaf,
+                             typename BpTree<T>::LeafInfo& inout_leaf_info) const noexcept
+{
+    m_tree.get_leaf(ndx, ndx_in_leaf, inout_leaf_info);
+}
+
+template<class T>
+StringData Column<T>::get_index_data(size_t ndx, StringIndex::StringConversionBuffer& buffer) const noexcept
+{
+    T x = get(ndx);
+    return to_str(x, buffer);
+}
+
+template<class T>
+void Column<T>::populate_search_index()
+{
+    REALM_ASSERT(has_search_index());
+    // Populate the index
+    size_t num_rows = size();
+    for (size_t row_ndx = 0; row_ndx != num_rows; ++row_ndx) {
+        bool is_append = true;
+        if (is_null(row_ndx)) {
+            m_search_index->insert(row_ndx, null{}, 1, is_append); // Throws
+        }
+        else {
+            T value = get(row_ndx);
+            m_search_index->insert(row_ndx, value, 1, is_append); // Throws
+        }
+    }
+}
+
+template<class T>
+StringIndex* Column<T>::create_search_index()
+{
+    if (realm::is_any<T, float, double>::value)
+        return nullptr;
+
+    REALM_ASSERT(!has_search_index());
+    REALM_ASSERT(supports_search_index());
+    m_search_index.reset(new StringIndex(this, get_alloc())); // Throws
+    populate_search_index();
+    return m_search_index.get();
+}
+
+template<class T>
+size_t Column<T>::find_first(T value, size_t begin, size_t end) const
+{
+    REALM_ASSERT_3(begin, <=, size());
+    REALM_ASSERT(end == npos || (begin <= end && end <= size()));
+
+    if (m_search_index && begin == 0 && end == npos)
+        return m_search_index->find_first(value);
+    return m_tree.find_first(value, begin, end);
+}
+
+template<class T>
+void Column<T>::find_all(IntegerColumn& result, T value, size_t begin, size_t end) const
+{
+    REALM_ASSERT_3(begin, <=, size());
+    REALM_ASSERT(end == npos || (begin <= end && end <= size()));
+
+    if (m_search_index && begin == 0 && end == npos)
+        return m_search_index->find_all(result, value);
+    return m_tree.find_all(result, value, begin, end);
+}
+
+inline size_t ColumnBase::get_size_from_ref(ref_type root_ref, Allocator& alloc)
+{
+    const char* root_header = alloc.translate(root_ref);
+    bool root_is_leaf = !Array::get_is_inner_bptree_node_from_header(root_header);
+    if (root_is_leaf)
+        return Array::get_size_from_header(root_header);
+    return Array::get_bptree_size_from_header(root_header);
+}
+
+template<class L, class T>
+size_t ColumnBase::lower_bound(const L& list, T value) const noexcept
+{
+    size_t i = 0;
+    size_t list_size = list.size();
+    while (0 < list_size) {
+        size_t half = list_size / 2;
+        size_t mid = i + half;
+        typename L::value_type probe = list.get(mid);
+        if (probe < value) {
+            i = mid + 1;
+            list_size -= half + 1;
+        }
+        else {
+            list_size = half;
+        }
+    }
+    return i;
+}
+
+template<class L, class T>
+size_t ColumnBase::upper_bound(const L& list, T value) const noexcept
+{
+    size_t i = 0;
+    size_t list_size = list.size();
+    while (0 < list_size) {
+        size_t half = list_size / 2;
+        size_t mid = i + half;
+        typename L::value_type probe = list.get(mid);
+        if (!(value < probe)) {
+            i = mid + 1;
+            list_size -= half + 1;
+        }
+        else {
+            list_size = half;
+        }
+    }
+    return i;
+}
+
+
+inline ref_type ColumnBase::create(Allocator& alloc, size_t column_size, CreateHandler& handler)
+{
+    size_t rest_size = column_size;
+    size_t fixed_height = 0; // Not fixed
+    return build(&rest_size, fixed_height, alloc, handler);
+}
+
+template<class T>
+Column<T>::Column(Allocator& alloc, ref_type ref) : m_tree(BpTreeBase::unattached_tag{})
+{
+    // fixme, must m_search_index be copied here?
+    m_tree.init_from_ref(alloc, ref);
+}
+
+template<class T>
+Column<T>::Column(unattached_root_tag, Allocator& alloc) : m_tree(alloc)
+{
+}
+
+template<class T>
+Column<T>::Column(std::unique_ptr<Array> root) noexcept : m_tree(std::move(root))
+{
+}
+
+template<class T>
+Column<T>::~Column() noexcept
+{
+}
+
+template<class T>
+void Column<T>::init_from_parent()
+{
+    m_tree.init_from_parent();
+}
+
+template<class T>
+void Column<T>::init_from_ref(Allocator& alloc, ref_type ref)
+{
+    m_tree.init_from_ref(alloc, ref);
+}
+
+template<class T>
+void Column<T>::init_from_mem(Allocator& alloc, MemRef mem)
+{
+    m_tree.init_from_mem(alloc, mem);
+}
+
+template<class T>
+void Column<T>::destroy() noexcept
+{
+    ColumnBaseWithIndex::destroy();
+    m_tree.destroy();
+}
+
+template<class T>
+void Column<T>::move_assign(Column<T>& col)
+{
+    ColumnBaseWithIndex::move_assign(col);
+    m_tree = std::move(col.m_tree);
+}
+
+template<class T>
+Allocator& Column<T>::get_alloc() const noexcept
+{
+    return m_tree.get_alloc();
+}
+
+template<class T>
+void Column<T>::set_parent(ArrayParent* parent, size_t ndx_in_parent) noexcept
+{
+    m_tree.set_parent(parent, ndx_in_parent);
+}
+
+template<class T>
+size_t Column<T>::get_ndx_in_parent() const noexcept
+{
+    return m_tree.get_ndx_in_parent();
+}
+
+template<class T>
+void Column<T>::set_ndx_in_parent(size_t ndx_in_parent) noexcept
+{
+    ColumnBaseWithIndex::set_ndx_in_parent(ndx_in_parent);
+    m_tree.set_ndx_in_parent(ndx_in_parent);
+}
+
+template<class T>
+void Column<T>::detach() noexcept
+{
+    m_tree.detach();
+}
+
+template<class T>
+bool Column<T>::is_attached() const noexcept
+{
+    return m_tree.is_attached();
+}
+
+template<class T>
+ref_type Column<T>::get_ref() const noexcept
+{
+    return get_root_array()->get_ref();
+}
+
+template<class T>
+MemRef Column<T>::get_mem() const noexcept
+{
+    return get_root_array()->get_mem();
+}
+
+template<class T>
+void Column<T>::update_from_parent(size_t old_baseline) noexcept
+{
+    ColumnBaseWithIndex::update_from_parent(old_baseline);
+    m_tree.update_from_parent(old_baseline);
+}
+
+template<class T>
+MemRef Column<T>::clone_deep(Allocator& alloc) const
+{
+    return m_tree.clone_deep(alloc);
+}
+
+template<class T>
+size_t Column<T>::size() const noexcept
+{
+    return m_tree.size();
+}
+
+template<class T>
+bool Column<T>::is_nullable() const noexcept
+{
+    return nullable;
+}
+
+template<class T>
+T Column<T>::get(size_t ndx) const noexcept
+{
+    return m_tree.get(ndx);
+}
+
+template<class T>
+bool Column<T>::is_null(size_t ndx) const noexcept
+{
+    return m_tree.is_null(ndx);
+}
+
+template<class T>
+T Column<T>::back() const noexcept
+{
+    return m_tree.back();
+}
+
+template<class T>
+ref_type Column<T>::get_as_ref(size_t ndx) const noexcept
+{
+    return to_ref(get(ndx));
+}
+
+template<class T>
+uint64_t Column<T>::get_uint(size_t ndx) const noexcept
+{
+    static_assert(std::is_convertible<T, uint64_t>::value, "T is not convertible to uint.");
+    return static_cast<uint64_t>(get(ndx));
+}
+
+template<class T>
+void Column<T>::add(T value)
+{
+    insert(npos, std::move(value));
+}
+
+template<class T>
+void Column<T>::insert_without_updating_index(size_t row_ndx, T value, size_t num_rows)
+{
+    size_t column_size = this->size(); // Slow
+    bool is_append = row_ndx == column_size || row_ndx == npos;
+    size_t ndx_or_npos_if_append = is_append ? npos : row_ndx;
+
+    m_tree.insert(ndx_or_npos_if_append, std::move(value), num_rows); // Throws
+}
+
+template<class T>
+void Column<T>::insert(size_t row_ndx, T value, size_t num_rows)
+{
+    size_t column_size = this->size(); // Slow
+    bool is_append = row_ndx == column_size || row_ndx == npos;
+    size_t ndx_or_npos_if_append = is_append ? npos : row_ndx;
+
+    m_tree.insert(ndx_or_npos_if_append, value, num_rows); // Throws
+
+    if (has_search_index()) {
+        row_ndx = is_append ? column_size : row_ndx;
+        m_search_index->insert(row_ndx, value, num_rows, is_append); // Throws
+    }
+}
+
+template<class T>
+void Column<T>::erase_without_updating_index(size_t row_ndx, bool is_last)
+{
+    m_tree.erase(row_ndx, is_last);
+}
+
+template<class T>
+void Column<T>::erase(size_t row_ndx)
+{
+    REALM_ASSERT(size() >= 1);
+    size_t last_row_ndx = size() - 1; // Note that size() is slow
+    bool is_last = (row_ndx == last_row_ndx);
+    erase(row_ndx, is_last); // Throws
+}
+
+template<class T>
+void Column<T>::erase(size_t row_ndx, bool is_last)
+{
+    size_t num_rows_to_erase = 1;
+    do_erase(row_ndx, num_rows_to_erase, is_last); // Throws
+}
+
+template<class T>
+void Column<T>::move_last_over_without_updating_index(size_t row_ndx, size_t last_row_ndx)
+{
+    m_tree.move_last_over(row_ndx, last_row_ndx);
+}
+
+template<class T>
+void Column<T>::move_last_over(size_t row_ndx, size_t last_row_ndx)
+{
+    REALM_ASSERT_3(row_ndx, <=, last_row_ndx);
+    REALM_ASSERT_DEBUG(last_row_ndx + 1 == size());
+
+    if (has_search_index()) {
+        // remove the value to be overwritten from index
+        bool is_last = true; // This tells StringIndex::erase() to not adjust subsequent indexes
+        m_search_index->erase<StringData>(row_ndx, is_last); // Throws
+
+        // update index to point to new location
+        if (row_ndx != last_row_ndx) {
+            T moved_value = get(last_row_ndx);
+            m_search_index->update_ref(moved_value, last_row_ndx, row_ndx); // Throws
+        }
+    }
+
+    move_last_over_without_updating_index(row_ndx, last_row_ndx);
+}
+
+template<class T>
+void Column<T>::swap_rows(size_t row_ndx_1, size_t row_ndx_2)
+{
+    REALM_ASSERT_3(row_ndx_1, <, size());
+    REALM_ASSERT_3(row_ndx_2, <, size());
+    REALM_ASSERT_DEBUG(row_ndx_1 != row_ndx_2);
+
+    if (has_search_index()) {
+        T value_1 = get(row_ndx_1);
+        T value_2 = get(row_ndx_2);
+        size_t column_size = this->size();
+        bool row_ndx_1_is_last = row_ndx_1 == column_size - 1;
+        bool row_ndx_2_is_last = row_ndx_2 == column_size - 1;
+        m_search_index->erase<StringData>(row_ndx_1, row_ndx_1_is_last);
+        m_search_index->insert(row_ndx_1, value_2, 1, row_ndx_1_is_last);
+
+        m_search_index->erase<StringData>(row_ndx_2, row_ndx_2_is_last);
+        m_search_index->insert(row_ndx_2, value_1, 1, row_ndx_2_is_last);
+    }
+
+    swap_rows_without_updating_index(row_ndx_1, row_ndx_2);
+}
+
+template<class T>
+void Column<T>::swap_rows_without_updating_index(size_t row_ndx_1, size_t row_ndx_2)
+{
+    // FIXME: This can be optimized with direct getters and setters.
+    T value_1 = get(row_ndx_1);
+    T value_2 = get(row_ndx_2);
+    m_tree.set(row_ndx_1, value_2);
+    m_tree.set(row_ndx_2, value_1);
+}
+
+template<class T>
+void Column<T>::clear_without_updating_index()
+{
+    m_tree.clear(); // Throws
+}
+
+template<class T>
+void Column<T>::clear()
+{
+    if (has_search_index()) {
+        m_search_index->clear();
+    }
+    clear_without_updating_index();
+}
+
+template<class T, class Enable = void> struct NullOrDefaultValue;
+template<class T> struct NullOrDefaultValue<T, typename std::enable_if<std::is_floating_point<T>::value>::type> {
+    static T null_or_default_value(bool is_null)
+    {
+        if (is_null) {
+            return null::get_null_float<T>();
+        }
+        else {
+            return T{};
+        }
+    }
+};
+template<class T> struct NullOrDefaultValue<util::Optional<T>, void> {
+    static util::Optional<T> null_or_default_value(bool is_null)
+    {
+        if (is_null) {
+            return util::none;
+        }
+        else {
+            return util::some<T>(T{});
+        }
+    }
+};
+template<class T> struct NullOrDefaultValue<T, typename std::enable_if<!ImplicitNull<T>::value>::type> {
+    static T null_or_default_value(bool is_null)
+    {
+        REALM_ASSERT(!is_null);
+        return T{};
+    }
+};
+
+// Implementing pure virtual method of ColumnBase.
+template<class T>
+void Column<T>::insert_rows(size_t row_ndx, size_t num_rows_to_insert, size_t prior_num_rows, bool insert_nulls)
+{
+    REALM_ASSERT_DEBUG(prior_num_rows == size());
+    REALM_ASSERT(row_ndx <= prior_num_rows);
+
+    size_t row_ndx_2 = (row_ndx == prior_num_rows ? realm::npos : row_ndx);
+    T value = NullOrDefaultValue<T>::null_or_default_value(insert_nulls);
+    insert(row_ndx_2, value, num_rows_to_insert); // Throws
+}
+
+// Implementing pure virtual method of ColumnBase.
+template<class T>
+void Column<T>::erase_rows(size_t row_ndx, size_t num_rows_to_erase, size_t prior_num_rows, bool)
+{
+    REALM_ASSERT_DEBUG(prior_num_rows == size());
+    REALM_ASSERT(num_rows_to_erase <= prior_num_rows);
+    REALM_ASSERT(row_ndx <= prior_num_rows - num_rows_to_erase);
+
+    bool is_last = (row_ndx + num_rows_to_erase == prior_num_rows);
+    do_erase(row_ndx, num_rows_to_erase, is_last); // Throws
+}
+
+// Implementing pure virtual method of ColumnBase.
+template<class T>
+void Column<T>::move_last_row_over(size_t row_ndx, size_t prior_num_rows, bool)
+{
+    REALM_ASSERT_DEBUG(prior_num_rows == size());
+    REALM_ASSERT(row_ndx < prior_num_rows);
+
+    size_t last_row_ndx = prior_num_rows - 1;
+    move_last_over(row_ndx, last_row_ndx); // Throws
+}
+
+// Implementing pure virtual method of ColumnBase.
+template<class T>
+void Column<T>::clear(size_t, bool)
+{
+    clear(); // Throws
+}
+
+
+template<class T>
+size_t Column<T>::lower_bound(T value) const noexcept
+{
+    if (root_is_leaf()) {
+        auto root = static_cast<const LeafType*>(get_root_array());
+        return root->lower_bound(value);
+    }
+    return ColumnBase::lower_bound(*this, value);
+}
+
+template<class T>
+size_t Column<T>::upper_bound(T value) const noexcept
+{
+    if (root_is_leaf()) {
+        auto root = static_cast<const LeafType*>(get_root_array());
+        return root->upper_bound(value);
+    }
+    return ColumnBase::upper_bound(*this, value);
+}
+
+// For a *sorted* Column, return first element E for which E >= target or return -1 if none
+template<class T>
+size_t Column<T>::find_gte(T target, size_t start) const
+{
+    // fixme: slow reference implementation. See Array::find_gte for faster version
+    size_t ref = 0;
+    size_t idx;
+    for (idx = start; idx < size(); ++idx) {
+        if (get(idx) >= target) {
+            ref = idx;
+            break;
+        }
+    }
+    if (idx == size())
+        ref = not_found;
+
+    return ref;
+}
+
+
+template<class T>
+bool Column<T>::compare(const Column<T>& c) const noexcept
+{
+    size_t n = size();
+    if (c.size() != n)
+        return false;
+    for (size_t i=0; i<n; ++i) {
+        bool left_is_null = is_null(i);
+        bool right_is_null = c.is_null(i);
+        if (left_is_null != right_is_null) {
+            return false;
+        }
+        if (!left_is_null) {
+            if (get(i) != c.get(i))
+                return false;
+        }
+    }
+    return true;
+}
+
+template<class T>
+class Column<T>::CreateHandler: public ColumnBase::CreateHandler {
+public:
+    CreateHandler(Array::Type leaf_type, T value, Allocator& alloc):
+        m_value(value), m_alloc(alloc), m_leaf_type(leaf_type) {}
+    ref_type create_leaf(size_t size) override
+    {
+        MemRef mem = BpTree<T>::create_leaf(m_leaf_type, size, m_value, m_alloc); // Throws
+        return mem.get_ref();
+    }
+private:
+    const T m_value;
+    Allocator& m_alloc;
+    Array::Type m_leaf_type;
+};
+
+template<class T>
+ref_type Column<T>::create(Allocator& alloc, Array::Type leaf_type, size_t size, T value)
+{
+    CreateHandler handler(leaf_type, std::move(value), alloc);
+    return ColumnBase::create(alloc, size, handler);
+}
+
+template<class T>
+ref_type Column<T>::write(size_t slice_offset, size_t slice_size,
+                       size_t table_size, _impl::OutputStream& out) const
+{
+    return m_tree.write(slice_offset, slice_size, table_size, out);
+}
+
+template<class T>
+void Column<T>::refresh_accessor_tree(size_t new_col_ndx, const Spec& spec)
+{
+    m_tree.init_from_parent();
+    ColumnBaseWithIndex::refresh_accessor_tree(new_col_ndx, spec);
+}
+
+template<class T>
+void Column<T>::do_erase(size_t row_ndx, size_t num_rows_to_erase, bool is_last)
+{
+    if (has_search_index()) {
+        for (size_t i = num_rows_to_erase; i > 0; --i) {
+            size_t row_ndx_2 = row_ndx + i - 1;
+            m_search_index->erase<T>(row_ndx_2, is_last); // Throws
+        }
+    }
+    for (size_t i = num_rows_to_erase; i > 0; --i) {
+        size_t row_ndx_2 = row_ndx + i - 1;
+        erase_without_updating_index(row_ndx_2, is_last); // Throws
+    }
+}
+
+#ifdef REALM_DEBUG
+
+template<class T>
+void Column<T>::verify() const
+{
+    m_tree.verify();
+}
+
+
+template<class T>
+void Column<T>::to_dot(std::ostream& out, StringData title) const
+{
+    ref_type ref = get_root_array()->get_ref();
+    out << "subgraph cluster_integer_column" << ref << " {" << std::endl;
+    out << " label = \"Integer column";
+    if (title.size() != 0)
+        out << "\\n'" << title << "'";
+    out << "\";" << std::endl;
+    tree_to_dot(out);
+    out << "}" << std::endl;
+}
+
+template<class T>
+void Column<T>::tree_to_dot(std::ostream& out) const
+{
+    ColumnBase::bptree_to_dot(get_root_array(), out);
+}
+
+template<class T>
+void Column<T>::leaf_to_dot(MemRef leaf_mem, ArrayParent* parent, size_t ndx_in_parent,
+                         std::ostream& out) const
+{
+    BpTree<T>::leaf_to_dot(leaf_mem, parent, ndx_in_parent, out, get_alloc());
+}
+
+template<class T>
+MemStats Column<T>::stats() const
+{
+    MemStats mem_stats;
+    get_root_array()->stats(mem_stats);
+    return mem_stats;
+}
+
+namespace _impl {
+    void leaf_dumper(MemRef mem, Allocator& alloc, std::ostream& out, int level);
+}
+
+template<class T>
+void Column<T>::do_dump_node_structure(std::ostream& out, int level) const
+{
+    dump_node_structure(*get_root_array(), out, level);
+}
+
+template<class T>
+void Column<T>::dump_node_structure(const Array& root, std::ostream& out, int level)
+{
+    root.dump_bptree_structure(out, level, &_impl::leaf_dumper);
+}
+
+#endif // REALM_DEBUG
+
+
+} // namespace realm
+
+#endif // REALM_COLUMN_HPP
diff --git a/Pods/Realm/include/core/realm/column_backlink.hpp b/Pods/Realm/include/core/realm/column_backlink.hpp
new file mode 100644
index 0000000..353c652
--- /dev/null
+++ b/Pods/Realm/include/core/realm/column_backlink.hpp
@@ -0,0 +1,236 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_COLUMN_BACKLINK_HPP
+#define REALM_COLUMN_BACKLINK_HPP
+
+#include <vector>
+
+#include <realm/column.hpp>
+#include <realm/column_linkbase.hpp>
+#include <realm/table.hpp>
+
+namespace realm {
+
+/// A column of backlinks (BacklinkColumn) is a single B+-tree, and the root of
+/// the column is the root of the B+-tree. All leaf nodes are single arrays of
+/// type Array with the hasRefs bit set.
+///
+/// The individual values in the column are either refs to Columns containing
+/// the row indexes in the origin table that links to it, or in the case where
+/// there is a single link, a tagged ref encoding the origin row position.
+class BacklinkColumn: public IntegerColumn, public ArrayParent {
+public:
+    BacklinkColumn(Allocator&, ref_type);
+    ~BacklinkColumn() noexcept override {}
+
+    static ref_type create(Allocator&, size_t size = 0);
+
+    bool has_backlinks(size_t row_ndx) const noexcept;
+    size_t get_backlink_count(size_t row_ndx) const noexcept;
+    size_t get_backlink(size_t row_ndx, size_t backlink_ndx) const noexcept;
+
+    void add_backlink(size_t row_ndx, size_t origin_row_ndx);
+    void remove_one_backlink(size_t row_ndx, size_t origin_row_ndx);
+    void remove_all_backlinks(size_t num_rows);
+    void update_backlink(size_t row_ndx, size_t old_origin_row_ndx,
+                         size_t new_origin_row_ndx);
+    void swap_backlinks(size_t row_ndx, size_t origin_row_ndx_1,
+                        size_t origin_row_ndx_2);
+
+    void add_row();
+
+    // Link origination info
+    Table& get_origin_table() const noexcept;
+    void set_origin_table(Table&) noexcept;
+    LinkColumnBase& get_origin_column() const noexcept;
+    size_t get_origin_column_index() const noexcept;
+    void set_origin_column(LinkColumnBase& column, size_t col_ndx) noexcept;
+
+    void insert_rows(size_t, size_t, size_t, bool) override;
+    void erase_rows(size_t, size_t, size_t, bool) override;
+    void move_last_row_over(size_t, size_t, bool) override;
+    void swap_rows(size_t, size_t) override;
+    void clear(size_t, bool) override;
+    void adj_acc_insert_rows(size_t, size_t) noexcept override;
+    void adj_acc_erase_row(size_t) noexcept override;
+    void adj_acc_move_over(size_t, size_t) noexcept override;
+    void adj_acc_swap_rows(size_t, size_t) noexcept override;
+    void adj_acc_clear_root_table() noexcept override;
+    void mark(int) noexcept override;
+    void refresh_accessor_tree(size_t, const Spec&) override;
+
+    void bump_link_origin_table_version() noexcept override;
+
+    void cascade_break_backlinks_to(size_t row_ndx, CascadeState& state) override;
+    void cascade_break_backlinks_to_all_rows(size_t num_rows, CascadeState&) override;
+
+#ifdef REALM_DEBUG
+    void verify() const override;
+    void verify(const Table&, size_t) const override;
+    struct VerifyPair {
+        size_t origin_row_ndx, target_row_ndx;
+        bool operator<(const VerifyPair&) const noexcept;
+    };
+    void get_backlinks(std::vector<VerifyPair>&); // Sorts
+#endif
+
+protected:
+    // ArrayParent overrides
+    void update_child_ref(size_t child_ndx, ref_type new_ref) override;
+    ref_type get_child_ref(size_t child_ndx) const noexcept override;
+
+#ifdef REALM_DEBUG
+    std::pair<ref_type, size_t> get_to_dot_parent(size_t) const override;
+#endif
+
+private:
+    TableRef        m_origin_table;
+    LinkColumnBase* m_origin_column = nullptr;
+    size_t     m_origin_column_ndx = npos;
+
+    template<typename Func>
+    size_t for_each_link(size_t row_ndx, bool do_destroy, Func&& f);
+};
+
+
+
+
+// Implementation
+
+inline BacklinkColumn::BacklinkColumn(Allocator& alloc, ref_type ref):
+    IntegerColumn(alloc, ref) // Throws
+{
+}
+
+inline ref_type BacklinkColumn::create(Allocator& alloc, size_t size)
+{
+    return IntegerColumn::create(alloc, Array::type_HasRefs, size); // Throws
+}
+
+inline bool BacklinkColumn::has_backlinks(size_t ndx) const noexcept
+{
+    return IntegerColumn::get(ndx) != 0;
+}
+
+inline Table& BacklinkColumn::get_origin_table() const noexcept
+{
+    return *m_origin_table;
+}
+
+inline void BacklinkColumn::set_origin_table(Table& table) noexcept
+{
+    REALM_ASSERT(!m_origin_table);
+    m_origin_table = table.get_table_ref();
+}
+
+inline LinkColumnBase& BacklinkColumn::get_origin_column() const noexcept
+{
+    return *m_origin_column;
+}
+
+inline size_t BacklinkColumn::get_origin_column_index() const noexcept
+{
+    return m_origin_column_ndx;
+}
+
+inline void BacklinkColumn::set_origin_column(LinkColumnBase& column, size_t col_ndx) noexcept
+{
+    m_origin_column = &column;
+    m_origin_column_ndx = col_ndx;
+}
+
+inline void BacklinkColumn::add_row()
+{
+    IntegerColumn::add(0);
+}
+
+inline void BacklinkColumn::adj_acc_insert_rows(size_t row_ndx,
+                                                size_t num_rows) noexcept
+{
+    IntegerColumn::adj_acc_insert_rows(row_ndx, num_rows);
+
+    typedef _impl::TableFriend tf;
+    tf::mark(*m_origin_table);
+}
+
+inline void BacklinkColumn::adj_acc_erase_row(size_t row_ndx) noexcept
+{
+    IntegerColumn::adj_acc_erase_row(row_ndx);
+
+    typedef _impl::TableFriend tf;
+    tf::mark(*m_origin_table);
+}
+
+inline void BacklinkColumn::adj_acc_move_over(size_t from_row_ndx,
+                                              size_t to_row_ndx) noexcept
+{
+    IntegerColumn::adj_acc_move_over(from_row_ndx, to_row_ndx);
+
+    typedef _impl::TableFriend tf;
+    tf::mark(*m_origin_table);
+}
+
+inline void BacklinkColumn::adj_acc_swap_rows(size_t row_ndx_1, size_t row_ndx_2) noexcept
+{
+    Column::adj_acc_swap_rows(row_ndx_1, row_ndx_2);
+
+    using tf = _impl::TableFriend;
+    tf::mark(*m_origin_table);
+}
+
+inline void BacklinkColumn::adj_acc_clear_root_table() noexcept
+{
+    IntegerColumn::adj_acc_clear_root_table();
+
+    typedef _impl::TableFriend tf;
+    tf::mark(*m_origin_table);
+}
+
+inline void BacklinkColumn::mark(int type) noexcept
+{
+    if (type & mark_LinkOrigins) {
+        typedef _impl::TableFriend tf;
+        tf::mark(*m_origin_table);
+    }
+}
+
+inline void BacklinkColumn::bump_link_origin_table_version() noexcept
+{
+    // It is important to mark connected tables as modified.
+    // Also see LinkColumnBase::bump_link_origin_table_version().
+    typedef _impl::TableFriend tf;
+    if (m_origin_table) {
+        bool bump_global = false;
+        tf::bump_version(*m_origin_table, bump_global);
+    }
+}
+
+#ifdef REALM_DEBUG
+
+inline bool BacklinkColumn::VerifyPair::operator<(const VerifyPair& p) const noexcept
+{
+    return origin_row_ndx < p.origin_row_ndx;
+}
+
+#endif // REALM_DEBUG
+
+} // namespace realm
+
+#endif // REALM_COLUMN_BACKLINK_HPP
diff --git a/Pods/Realm/include/core/realm/column_binary.hpp b/Pods/Realm/include/core/realm/column_binary.hpp
new file mode 100644
index 0000000..86dfe29
--- /dev/null
+++ b/Pods/Realm/include/core/realm/column_binary.hpp
@@ -0,0 +1,387 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_COLUMN_BINARY_HPP
+#define REALM_COLUMN_BINARY_HPP
+
+#include <realm/column.hpp>
+#include <realm/array_binary.hpp>
+#include <realm/array_blobs_big.hpp>
+
+namespace realm {
+
+
+/// A binary column (BinaryColumn) is a single B+-tree, and the root
+/// of the column is the root of the B+-tree. Leaf nodes are either of
+/// type ArrayBinary (array of small blobs) or ArrayBigBlobs (array of
+/// big blobs).
+class BinaryColumn: public ColumnBaseSimple {
+public:
+    typedef BinaryData value_type;
+
+    BinaryColumn(Allocator&, ref_type, bool nullable = false);
+
+    size_t size() const noexcept final;
+    bool is_empty() const noexcept { return size() == 0; }
+    bool is_nullable() const noexcept override;
+
+    BinaryData get(size_t ndx) const noexcept;
+    bool is_null(size_t ndx) const noexcept override;
+    StringData get_index_data(size_t, StringIndex::StringConversionBuffer& ) const noexcept final;
+
+    void add(BinaryData value);
+    void set(size_t ndx, BinaryData value, bool add_zero_term = false);
+    void set_null(size_t ndx) override;
+    void insert(size_t ndx, BinaryData value);
+    void erase(size_t row_ndx);
+    void erase(size_t row_ndx, bool is_last);
+    void move_last_over(size_t row_ndx);
+    void swap_rows(size_t row_ndx_1, size_t row_ndx_2) override;
+    void clear();
+    size_t find_first(BinaryData value) const;
+
+    // Requires that the specified entry was inserted as StringData.
+    StringData get_string(size_t ndx) const noexcept;
+
+    void add_string(StringData value);
+    void set_string(size_t ndx, StringData value) override;
+    void insert_string(size_t ndx, StringData value);
+
+    /// Compare two binary columns for equality.
+    bool compare_binary(const BinaryColumn&) const;
+
+    static ref_type create(Allocator&, size_t size, bool nullable);
+
+    static size_t get_size_from_ref(ref_type root_ref, Allocator&) noexcept;
+
+    // Overrriding method in ColumnBase
+    ref_type write(size_t, size_t, size_t,
+                   _impl::OutputStream&) const override;
+
+    void insert_rows(size_t, size_t, size_t, bool) override;
+    void erase_rows(size_t, size_t, size_t, bool) override;
+    void move_last_row_over(size_t, size_t, bool) override;
+    void clear(size_t, bool) override;
+    void update_from_parent(size_t) noexcept override;
+    void refresh_accessor_tree(size_t, const Spec&) override;
+
+    /// In contrast to update_from_parent(), this function is able to handle
+    /// cases where the accessed payload data has changed. In particular, it
+    /// handles cases where the B+-tree switches from having one level (root is
+    /// a leaf node), to having multiple levels (root is an inner node). Note
+    /// that this is at the expense of loosing the `noexcept` guarantee.
+    void update_from_ref(ref_type ref);
+
+#ifdef REALM_DEBUG
+    void verify() const override;
+    void to_dot(std::ostream&, StringData title) const override;
+    void do_dump_node_structure(std::ostream&, int) const override;
+#endif
+
+private:
+    /// \param row_ndx Must be `realm::npos` if appending.
+    void do_insert(size_t row_ndx, BinaryData value, bool add_zero_term,
+                   size_t num_rows);
+
+    // Called by Array::bptree_insert().
+    static ref_type leaf_insert(MemRef leaf_mem, ArrayParent&, size_t ndx_in_parent,
+                                Allocator&, size_t insert_ndx,
+                                Array::TreeInsert<BinaryColumn>& state);
+
+    struct InsertState: Array::TreeInsert<BinaryColumn> {
+        bool m_add_zero_term;
+    };
+
+    class EraseLeafElem;
+    class CreateHandler;
+    class SliceHandler;
+
+    void do_move_last_over(size_t row_ndx, size_t last_row_ndx);
+    void do_clear();
+
+    /// Root must be a leaf. Upgrades the root leaf if
+    /// necessary. Returns true if, and only if the root is a 'big
+    /// blobs' leaf upon return.
+    bool upgrade_root_leaf(size_t value_size);
+
+    bool m_nullable = false;
+
+#ifdef REALM_DEBUG
+    void leaf_to_dot(MemRef, ArrayParent*, size_t ndx_in_parent,
+                     std::ostream&) const override;
+#endif
+
+    friend class Array;
+    friend class ColumnBase;
+};
+
+
+
+
+// Implementation
+
+inline StringData BinaryColumn::get_index_data(size_t, StringIndex::StringConversionBuffer&) const noexcept
+{
+    REALM_ASSERT(false && "Index not implemented for BinaryColumn.");
+    REALM_UNREACHABLE();
+}
+
+inline size_t BinaryColumn::size() const noexcept
+{
+    if (root_is_leaf()) {
+        bool is_big = m_array->get_context_flag();
+        if (!is_big) {
+            // Small blobs root leaf
+            ArrayBinary* leaf = static_cast<ArrayBinary*>(m_array.get());
+            return leaf->size();
+        }
+        // Big blobs root leaf
+        ArrayBigBlobs* leaf = static_cast<ArrayBigBlobs*>(m_array.get());
+        return leaf->size();
+    }
+    // Non-leaf root
+    return m_array->get_bptree_size();
+}
+
+inline bool BinaryColumn::is_nullable() const noexcept
+{
+    return m_nullable;
+}
+
+inline void BinaryColumn::update_from_parent(size_t old_baseline) noexcept
+{
+    if (root_is_leaf()) {
+        bool is_big = m_array->get_context_flag();
+        if (!is_big) {
+            // Small blobs root leaf
+            REALM_ASSERT(dynamic_cast<ArrayBinary*>(m_array.get()));
+            ArrayBinary* leaf = static_cast<ArrayBinary*>(m_array.get());
+            leaf->update_from_parent(old_baseline);
+            return;
+        }
+        // Big blobs root leaf
+        REALM_ASSERT(dynamic_cast<ArrayBigBlobs*>(m_array.get()));
+        ArrayBigBlobs* leaf = static_cast<ArrayBigBlobs*>(m_array.get());
+        leaf->update_from_parent(old_baseline);
+        return;
+    }
+    // Non-leaf root
+    m_array->update_from_parent(old_baseline);
+}
+
+inline BinaryData BinaryColumn::get(size_t ndx) const noexcept
+{
+    REALM_ASSERT_DEBUG(ndx < size());
+    if (root_is_leaf()) {
+        bool is_big = m_array->get_context_flag();
+        BinaryData ret;
+        if (!is_big) {
+            // Small blobs root leaf
+            ArrayBinary* leaf = static_cast<ArrayBinary*>(m_array.get());
+            ret = leaf->get(ndx);
+        }
+        else {
+            // Big blobs root leaf
+            ArrayBigBlobs* leaf = static_cast<ArrayBigBlobs*>(m_array.get());
+            ret = leaf->get(ndx);
+        }
+        if (!m_nullable && ret.is_null())
+            return BinaryData("", 0); // return empty string (non-null)
+        return ret;
+    }
+
+    // Non-leaf root
+    std::pair<MemRef, size_t> p = m_array->get_bptree_leaf(ndx);
+    const char* leaf_header = p.first.get_addr();
+    size_t ndx_in_leaf = p.second;
+    Allocator& alloc = m_array->get_alloc();
+    bool is_big = Array::get_context_flag_from_header(leaf_header);
+    if (!is_big) {
+        // Small blobs
+        return ArrayBinary::get(leaf_header, ndx_in_leaf, alloc);
+    }
+    // Big blobs
+    return ArrayBigBlobs::get(leaf_header, ndx_in_leaf, alloc);
+}
+
+inline bool BinaryColumn::is_null(size_t ndx) const noexcept
+{
+    return get(ndx).is_null();
+}
+
+inline StringData BinaryColumn::get_string(size_t ndx) const noexcept
+{
+    BinaryData bin = get(ndx);
+    REALM_ASSERT_3(0, <, bin.size());
+    return StringData(bin.data(), bin.size()-1);
+}
+
+inline void BinaryColumn::set_string(size_t ndx, StringData value)
+{
+    if (value.is_null() && !m_nullable)
+        throw LogicError(LogicError::column_not_nullable);
+
+    BinaryData bin(value.data(), value.size());
+    bool add_zero_term = true;
+    set(ndx, bin, add_zero_term);
+}
+
+inline void BinaryColumn::add(BinaryData value)
+{
+    if (value.is_null() && !m_nullable)
+        throw LogicError(LogicError::column_not_nullable);
+
+    size_t row_ndx = realm::npos;
+    bool add_zero_term = false;
+    size_t num_rows = 1;
+    do_insert(row_ndx, value, add_zero_term, num_rows); // Throws
+}
+
+inline void BinaryColumn::insert(size_t row_ndx, BinaryData value)
+{
+    if (value.is_null() && !m_nullable)
+        throw LogicError(LogicError::column_not_nullable);
+
+    size_t column_size = this->size(); // Slow
+    REALM_ASSERT_3(row_ndx, <=, column_size);
+    size_t row_ndx_2 = row_ndx == column_size ? realm::npos : row_ndx;
+    bool add_zero_term = false;
+    size_t num_rows = 1;
+    do_insert(row_ndx_2, value, add_zero_term, num_rows); // Throws
+}
+
+inline void BinaryColumn::set_null(size_t row_ndx)
+{
+    set(row_ndx, BinaryData{});
+}
+
+inline size_t BinaryColumn::find_first(BinaryData value) const
+{
+    for (size_t t = 0; t < size(); t++)
+        if (get(t) == value)
+            return t;
+
+    return not_found;
+}
+
+
+inline void BinaryColumn::erase(size_t row_ndx)
+{
+    size_t last_row_ndx = size() - 1; // Note that size() is slow
+    bool is_last = row_ndx == last_row_ndx;
+    erase(row_ndx, is_last); // Throws
+}
+
+inline void BinaryColumn::move_last_over(size_t row_ndx)
+{
+    size_t last_row_ndx = size() - 1; // Note that size() is slow
+    do_move_last_over(row_ndx, last_row_ndx); // Throws
+}
+
+inline void BinaryColumn::clear()
+{
+    do_clear(); // Throws
+}
+
+// Implementing pure virtual method of ColumnBase.
+inline void BinaryColumn::insert_rows(size_t row_ndx, size_t num_rows_to_insert,
+                                      size_t prior_num_rows, bool insert_nulls)
+{
+    REALM_ASSERT_DEBUG(prior_num_rows == size());
+    REALM_ASSERT(row_ndx <= prior_num_rows);
+    REALM_ASSERT(!insert_nulls || m_nullable);
+
+    size_t row_ndx_2 = (row_ndx == prior_num_rows ? realm::npos : row_ndx);
+    BinaryData value = m_nullable ? BinaryData() : BinaryData("", 0);
+    bool add_zero_term = false;
+    do_insert(row_ndx_2, value, add_zero_term, num_rows_to_insert); // Throws
+}
+
+// Implementing pure virtual method of ColumnBase.
+inline void BinaryColumn::erase_rows(size_t row_ndx, size_t num_rows_to_erase,
+                                     size_t prior_num_rows, bool)
+{
+    REALM_ASSERT_DEBUG(prior_num_rows == size());
+    REALM_ASSERT(num_rows_to_erase <= prior_num_rows);
+    REALM_ASSERT(row_ndx <= prior_num_rows - num_rows_to_erase);
+
+    bool is_last = (row_ndx + num_rows_to_erase == prior_num_rows);
+    for (size_t i = num_rows_to_erase; i > 0; --i) {
+        size_t row_ndx_2 = row_ndx + i - 1;
+        erase(row_ndx_2, is_last); // Throws
+    }
+}
+
+// Implementing pure virtual method of ColumnBase.
+inline void BinaryColumn::move_last_row_over(size_t row_ndx, size_t prior_num_rows, bool)
+{
+    REALM_ASSERT_DEBUG(prior_num_rows == size());
+    REALM_ASSERT(row_ndx < prior_num_rows);
+
+    size_t last_row_ndx = prior_num_rows - 1;
+    do_move_last_over(row_ndx, last_row_ndx); // Throws
+}
+
+// Implementing pure virtual method of ColumnBase.
+inline void BinaryColumn::clear(size_t, bool)
+{
+    do_clear(); // Throws
+}
+
+inline void BinaryColumn::add_string(StringData value)
+{
+    size_t row_ndx = realm::npos;
+    BinaryData value_2(value.data(), value.size());
+    bool add_zero_term = true;
+    size_t num_rows = 1;
+    do_insert(row_ndx, value_2, add_zero_term, num_rows); // Throws
+}
+
+inline void BinaryColumn::insert_string(size_t row_ndx, StringData value)
+{
+    size_t column_size = this->size(); // Slow
+    REALM_ASSERT_3(row_ndx, <=, column_size);
+    size_t row_ndx_2 = row_ndx == column_size ? realm::npos : row_ndx;
+    BinaryData value_2(value.data(), value.size());
+    bool add_zero_term = false;
+    size_t num_rows = 1;
+    do_insert(row_ndx_2, value_2, add_zero_term, num_rows); // Throws
+}
+
+inline size_t BinaryColumn::get_size_from_ref(ref_type root_ref,
+                                                   Allocator& alloc) noexcept
+{
+    const char* root_header = alloc.translate(root_ref);
+    bool root_is_leaf = !Array::get_is_inner_bptree_node_from_header(root_header);
+    if (root_is_leaf) {
+        bool is_big = Array::get_context_flag_from_header(root_header);
+        if (!is_big) {
+            // Small blobs leaf
+            return ArrayBinary::get_size_from_header(root_header, alloc);
+        }
+        // Big blobs leaf
+        return ArrayBigBlobs::get_size_from_header(root_header);
+    }
+    return Array::get_bptree_size_from_header(root_header);
+}
+
+
+} // namespace realm
+
+#endif // REALM_COLUMN_BINARY_HPP
diff --git a/Pods/Realm/include/core/realm/column_fwd.hpp b/Pods/Realm/include/core/realm/column_fwd.hpp
new file mode 100644
index 0000000..81924a2
--- /dev/null
+++ b/Pods/Realm/include/core/realm/column_fwd.hpp
@@ -0,0 +1,55 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_COLUMN_FWD_HPP
+#define REALM_COLUMN_FWD_HPP
+
+#include <cstdint>
+
+namespace realm {
+
+// Regular classes
+class ColumnBase;
+class StringColumn;
+class StringEnumColumn;
+class BinaryColumn;
+class SubtableColumn;
+class MixedColumn;
+class LinkColumn;
+class LinkListColumn;
+
+// Templated classes
+template<class T>
+class Column;
+template<class T>
+class BasicColumn;
+
+namespace util {
+template <class> class Optional;
+}
+
+// Shortcuts, aka typedefs.
+using IntegerColumn = Column<int64_t>;
+using IntNullColumn = Column<util::Optional<int64_t>>;
+using DoubleColumn = Column<double>;
+using FloatColumn = Column<float>;
+
+} // namespace realm
+
+#endif // REALM_COLUMN_FWD_HPP
diff --git a/Pods/Realm/include/core/realm/column_link.hpp b/Pods/Realm/include/core/realm/column_link.hpp
new file mode 100644
index 0000000..8efc5a2
--- /dev/null
+++ b/Pods/Realm/include/core/realm/column_link.hpp
@@ -0,0 +1,186 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_COLUMN_LINK_HPP
+#define REALM_COLUMN_LINK_HPP
+
+#include <realm/column.hpp>
+#include <realm/column_linkbase.hpp>
+#include <realm/column_backlink.hpp>
+
+namespace realm {
+
+/// A link column is an extension of an integer column (Column) and maintains
+/// its node structure.
+///
+/// The individual values in a link column are indexes of rows in the target
+/// table (offset with one to allow zero to indicate null links.) The target
+/// table is specified by the table descriptor.
+class LinkColumn: public LinkColumnBase {
+public:
+    using LinkColumnBase::LinkColumnBase;
+    ~LinkColumn() noexcept override;
+
+    static ref_type create(Allocator&, size_t size = 0);
+
+    bool is_nullable() const noexcept override;
+
+    //@{
+
+    /// is_null_link() is shorthand for `get_link() == realm::npos`,
+    /// nullify_link() is shorthand foe `set_link(realm::npos)`, and
+    /// insert_null_link() is shorthand for
+    /// `insert_link(realm::npos)`. set_link() returns the original link, with
+    /// `realm::npos` indicating that it was null.
+
+    size_t get_link(size_t row_ndx) const noexcept;
+    bool is_null(size_t row_ndx) const noexcept override;
+    bool is_null_link(size_t row_ndx) const noexcept;
+    size_t set_link(size_t row_ndx, size_t target_row_ndx);
+    void set_null(size_t row_ndx) override;
+    void nullify_link(size_t row_ndx);
+    void insert_link(size_t row_ndx, size_t target_row_ndx);
+    void insert_null_link(size_t row_ndx);
+
+    //@}
+
+    void insert_rows(size_t, size_t, size_t, bool) override;
+    void erase_rows(size_t, size_t, size_t, bool) override;
+    void move_last_row_over(size_t, size_t, bool) override;
+    void swap_rows(size_t, size_t) override;
+    void clear(size_t, bool) override;
+    void cascade_break_backlinks_to(size_t, CascadeState&) override;
+    void cascade_break_backlinks_to_all_rows(size_t, CascadeState&) override;
+
+#ifdef REALM_DEBUG
+    void verify(const Table&, size_t) const override;
+#endif
+
+protected:
+    friend class BacklinkColumn;
+    void do_nullify_link(size_t row_ndx, size_t old_target_row_ndx) override;
+    void do_update_link(size_t row_ndx, size_t old_target_row_ndx,
+                        size_t new_target_row_ndx) override;
+    void do_swap_link(size_t row_ndx, size_t target_row_ndx_1,
+                      size_t target_row_ndx_2) override;
+
+private:
+    void remove_backlinks(size_t row_ndx);
+};
+
+
+// Implementation
+
+inline LinkColumn::~LinkColumn() noexcept
+{
+}
+
+inline bool LinkColumn::is_nullable() const noexcept
+{
+    return true;
+}
+
+inline ref_type LinkColumn::create(Allocator& alloc, size_t size)
+{
+    return IntegerColumn::create(alloc, Array::type_Normal, size); // Throws
+}
+
+inline bool LinkColumn::is_null(size_t row_ndx) const noexcept
+{
+    // Null is represented by zero
+    return LinkColumnBase::get(row_ndx) == 0;
+}
+
+inline size_t LinkColumn::get_link(size_t row_ndx) const noexcept
+{
+    // Map zero to realm::npos, and `n+1` to `n`, where `n` is a target row index.
+    return to_size_t(LinkColumnBase::get(row_ndx)) - size_t(1);
+}
+
+inline bool LinkColumn::is_null_link(size_t row_ndx) const noexcept
+{
+    return is_null(row_ndx);
+}
+
+inline size_t LinkColumn::set_link(size_t row_ndx, size_t target_row_ndx)
+{
+    int_fast64_t old_value = LinkColumnBase::get(row_ndx);
+    size_t old_target_row_ndx = to_size_t(old_value) - size_t(1);
+    if (old_value != 0)
+        m_backlink_column->remove_one_backlink(old_target_row_ndx, row_ndx); // Throws
+
+    int_fast64_t new_value = int_fast64_t(size_t(1) + target_row_ndx);
+    LinkColumnBase::set(row_ndx, new_value); // Throws
+
+    if (target_row_ndx != realm::npos)
+        m_backlink_column->add_backlink(target_row_ndx, row_ndx); // Throws
+
+    return old_target_row_ndx;
+}
+
+inline void LinkColumn::set_null(size_t row_ndx)
+{
+    set_link(row_ndx, realm::npos); // Throws
+}
+
+inline void LinkColumn::nullify_link(size_t row_ndx)
+{
+    set_null(row_ndx); // Throws
+}
+
+inline void LinkColumn::insert_link(size_t row_ndx, size_t target_row_ndx)
+{
+    int_fast64_t value = int_fast64_t(size_t(1) + target_row_ndx);
+    LinkColumnBase::insert(row_ndx, value); // Throws
+
+    if (target_row_ndx != realm::npos)
+        m_backlink_column->add_backlink(target_row_ndx, row_ndx); // Throws
+}
+
+inline void LinkColumn::insert_null_link(size_t row_ndx)
+{
+    insert_link(row_ndx, realm::npos); // Throws
+}
+
+inline void LinkColumn::do_update_link(size_t row_ndx, size_t,
+                                       size_t new_target_row_ndx)
+{
+    // Row pos is offset by one, to allow null refs
+    LinkColumnBase::set(row_ndx, new_target_row_ndx + 1);
+}
+
+inline void LinkColumn::do_swap_link(size_t row_ndx, size_t target_row_ndx_1,
+                                     size_t target_row_ndx_2)
+{
+    // Row pos is offset by one, to allow null refs
+    ++target_row_ndx_1;
+    ++target_row_ndx_2;
+
+    uint64_t value = LinkColumnBase::get_uint(row_ndx);
+    if (value == target_row_ndx_1) {
+        LinkColumnBase::set_uint(row_ndx, target_row_ndx_2);
+    }
+    else if (value == target_row_ndx_2) {
+        LinkColumnBase::set_uint(row_ndx, target_row_ndx_1);
+    }
+}
+
+} //namespace realm
+
+#endif //REALM_COLUMN_LINK_HPP
diff --git a/Pods/Realm/include/core/realm/column_linkbase.hpp b/Pods/Realm/include/core/realm/column_linkbase.hpp
new file mode 100644
index 0000000..71c2178
--- /dev/null
+++ b/Pods/Realm/include/core/realm/column_linkbase.hpp
@@ -0,0 +1,209 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_COLUMN_LINKBASE_HPP
+#define REALM_COLUMN_LINKBASE_HPP
+
+#include <realm/table.hpp>
+
+namespace realm {
+
+class BacklinkColumn;
+class Table;
+
+// Abstract base class for columns containing links
+class LinkColumnBase: public IntegerColumn {
+public:
+    // Create unattached root array aaccessor.
+    LinkColumnBase(Allocator& alloc, ref_type ref, Table* table, size_t column_ndx);
+    ~LinkColumnBase() noexcept override;
+
+    bool is_nullable() const noexcept override = 0;
+    void set_null(size_t) override = 0;
+    bool is_null(size_t) const noexcept override = 0;
+
+    bool supports_search_index() const noexcept final { return false; }
+    StringIndex* create_search_index() override;
+
+    bool get_weak_links() const noexcept;
+    void set_weak_links(bool) noexcept;
+
+    Table& get_target_table() const noexcept;
+    void set_target_table(Table&) noexcept;
+    BacklinkColumn& get_backlink_column() const noexcept;
+    void set_backlink_column(BacklinkColumn&) noexcept;
+
+    void swap_rows(size_t, size_t) override = 0;
+
+    virtual void do_nullify_link(size_t row_ndx, size_t old_target_row_ndx) = 0;
+    virtual void do_update_link(size_t row_ndx, size_t old_target_row_ndx,
+                                size_t new_target_row_ndx) = 0;
+    virtual void do_swap_link(size_t row_ndx, size_t target_row_ndx_1,
+                              size_t target_row_ndx_2) = 0;
+
+    void adj_acc_insert_rows(size_t, size_t) noexcept override;
+    void adj_acc_erase_row(size_t) noexcept override;
+    void adj_acc_move_over(size_t, size_t) noexcept override;
+    void adj_acc_swap_rows(size_t, size_t) noexcept override;
+    void adj_acc_clear_root_table() noexcept override;
+    void mark(int) noexcept override;
+    void refresh_accessor_tree(size_t, const Spec&) override;
+    void bump_link_origin_table_version() noexcept override;
+
+#ifdef REALM_DEBUG
+    void verify(const Table&, size_t) const override;
+    using IntegerColumn::verify;
+#endif
+
+protected:
+    // A pointer to the table that this column is part of.
+    Table* const m_table;
+
+    // The index of this column within m_table.m_cols.
+    size_t m_column_ndx;
+
+    TableRef m_target_table;
+    BacklinkColumn* m_backlink_column = nullptr;
+    bool m_weak_links = false; // True if these links are weak (not strong)
+
+    /// Call Table::cascade_break_backlinks_to() for the specified target row if
+    /// it is not already in \a state.rows, and the number of strong links to it
+    /// has dropped to zero.
+    void check_cascade_break_backlinks_to(size_t target_table_ndx, size_t target_row_ndx,
+                                          CascadeState& state);
+};
+
+
+
+
+// Implementation
+
+inline LinkColumnBase::LinkColumnBase(Allocator& alloc, ref_type ref, Table* table, size_t column_ndx):
+    IntegerColumn(alloc, ref), // Throws
+    m_table(table),
+    m_column_ndx(column_ndx)
+{
+}
+
+inline LinkColumnBase::~LinkColumnBase() noexcept
+{
+}
+
+inline StringIndex* LinkColumnBase::create_search_index()
+{
+    return nullptr;
+}
+
+inline bool LinkColumnBase::get_weak_links() const noexcept
+{
+    return m_weak_links;
+}
+
+inline void LinkColumnBase::set_weak_links(bool value) noexcept
+{
+    m_weak_links = value;
+}
+
+inline Table& LinkColumnBase::get_target_table() const noexcept
+{
+    return *m_target_table;
+}
+
+inline void LinkColumnBase::set_target_table(Table& table) noexcept
+{
+    REALM_ASSERT(!m_target_table);
+    m_target_table = table.get_table_ref();
+}
+
+inline BacklinkColumn& LinkColumnBase::get_backlink_column() const noexcept
+{
+    return *m_backlink_column;
+}
+
+inline void LinkColumnBase::set_backlink_column(BacklinkColumn& column) noexcept
+{
+    m_backlink_column = &column;
+}
+
+inline void LinkColumnBase::adj_acc_insert_rows(size_t row_ndx,
+                                                size_t num_rows) noexcept
+{
+    IntegerColumn::adj_acc_insert_rows(row_ndx, num_rows);
+
+    typedef _impl::TableFriend tf;
+    tf::mark(*m_target_table);
+}
+
+inline void LinkColumnBase::adj_acc_erase_row(size_t row_ndx) noexcept
+{
+    IntegerColumn::adj_acc_erase_row(row_ndx);
+
+    typedef _impl::TableFriend tf;
+    tf::mark(*m_target_table);
+}
+
+inline void LinkColumnBase::adj_acc_move_over(size_t from_row_ndx,
+                                              size_t to_row_ndx) noexcept
+{
+    IntegerColumn::adj_acc_move_over(from_row_ndx, to_row_ndx);
+
+    typedef _impl::TableFriend tf;
+    tf::mark(*m_target_table);
+}
+
+inline void LinkColumnBase::adj_acc_swap_rows(size_t row_ndx_1, size_t row_ndx_2) noexcept
+{
+    IntegerColumn::adj_acc_swap_rows(row_ndx_1, row_ndx_2);
+
+    typedef _impl::TableFriend tf;
+    tf::mark(*m_target_table);
+}
+
+inline void LinkColumnBase::adj_acc_clear_root_table() noexcept
+{
+    IntegerColumn::adj_acc_clear_root_table();
+
+    typedef _impl::TableFriend tf;
+    tf::mark(*m_target_table);
+}
+
+inline void LinkColumnBase::mark(int type) noexcept
+{
+    if (type & mark_LinkTargets) {
+        typedef _impl::TableFriend tf;
+        tf::mark(*m_target_table);
+    }
+}
+
+inline void LinkColumnBase::bump_link_origin_table_version() noexcept
+{
+    // It is important to mark connected tables as modified.
+    // Also see BacklinkColumn::bump_link_origin_table_version().
+    typedef _impl::TableFriend tf;
+    if (m_target_table) {
+        bool bump_global = false;
+        tf::bump_version(*m_target_table, bump_global);
+    }
+}
+
+
+
+} // namespace realm
+
+#endif // REALM_COLUMN_LINKBASE_HPP
diff --git a/Pods/Realm/include/core/realm/column_linklist.hpp b/Pods/Realm/include/core/realm/column_linklist.hpp
new file mode 100644
index 0000000..f8f383e
--- /dev/null
+++ b/Pods/Realm/include/core/realm/column_linklist.hpp
@@ -0,0 +1,252 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_COLUMN_LINKLIST_HPP
+#define REALM_COLUMN_LINKLIST_HPP
+
+#include <algorithm>
+#include <vector>
+
+#include <realm/column.hpp>
+#include <realm/column_linkbase.hpp>
+#include <realm/table.hpp>
+#include <realm/column_backlink.hpp>
+#include <realm/link_view_fwd.hpp>
+
+namespace realm {
+
+namespace _impl {
+class TransactLogConvenientEncoder;
+}
+
+
+/// A column of link lists (LinkListColumn) is a single B+-tree, and the root of
+/// the column is the root of the B+-tree. All leaf nodes are single arrays of
+/// type Array with the hasRefs bit set.
+///
+/// The individual values in the column are either refs to Columns containing the
+/// row positions in the target table, or in the case where they are empty, a zero
+/// ref.
+class LinkListColumn: public LinkColumnBase, public ArrayParent {
+public:
+    using LinkColumnBase::LinkColumnBase;
+    LinkListColumn(Allocator& alloc, ref_type ref, Table* table, size_t column_ndx);
+    ~LinkListColumn() noexcept override;
+
+    static ref_type create(Allocator&, size_t size = 0);
+
+    bool is_nullable() const noexcept final;
+
+    bool has_links(size_t row_ndx) const noexcept;
+    size_t get_link_count(size_t row_ndx) const noexcept;
+
+    ConstLinkViewRef get(size_t row_ndx) const;
+    LinkViewRef get(size_t row_ndx);
+
+    bool is_null(size_t row_ndx) const noexcept final;
+    void set_null(size_t row_ndx) final;
+
+    /// Compare two columns for equality.
+    bool compare_link_list(const LinkListColumn&) const;
+
+    void to_json_row(size_t row_ndx, std::ostream& out) const;
+
+    void insert_rows(size_t, size_t, size_t, bool) override;
+    void erase_rows(size_t, size_t, size_t, bool) override;
+    void move_last_row_over(size_t, size_t, bool) override;
+    void swap_rows(size_t, size_t) override;
+    void clear(size_t, bool) override;
+    void cascade_break_backlinks_to(size_t, CascadeState&) override;
+    void cascade_break_backlinks_to_all_rows(size_t, CascadeState&) override;
+    void update_from_parent(size_t) noexcept override;
+    void adj_acc_clear_root_table() noexcept override;
+    void adj_acc_insert_rows(size_t, size_t) noexcept override;
+    void adj_acc_erase_row(size_t) noexcept override;
+    void adj_acc_move_over(size_t, size_t) noexcept override;
+    void adj_acc_swap_rows(size_t, size_t) noexcept override;
+    void refresh_accessor_tree(size_t, const Spec&) override;
+
+#ifdef REALM_DEBUG
+    void verify() const override;
+    void verify(const Table&, size_t) const override;
+#endif
+
+protected:
+    void do_discard_child_accessors() noexcept override;
+
+private:
+    struct list_entry {
+        size_t m_row_ndx;
+        std::weak_ptr<LinkView> m_list;
+        bool operator<(const list_entry& other) const { return m_row_ndx < other.m_row_ndx; }
+    };
+
+    // The accessors stored in `m_list_accessors` are sorted by their row index.
+    // When a LinkList accessor is destroyed because the last shared_ptr pointing
+    // to it dies, its entry is implicitly replaced by a tombstone (an entry with 
+    // an empty `m_list`). These tombstones are pruned at a later time by 
+    // `prune_list_accessor_tombstones`. This is done to amortize the O(n) cost 
+    // of `std::vector::erase` that would otherwise be incurred each time an 
+    // accessor is removed.
+    mutable std::vector<list_entry> m_list_accessors;
+    mutable std::atomic<bool> m_list_accessors_contains_tombstones;
+
+    std::shared_ptr<LinkView> get_ptr(size_t row_ndx) const;
+
+    void do_nullify_link(size_t row_ndx, size_t old_target_row_ndx) override;
+    void do_update_link(size_t row_ndx, size_t old_target_row_ndx,
+                        size_t new_target_row_ndx) override;
+    void do_swap_link(size_t row_ndx, size_t target_row_ndx_1,
+                      size_t target_row_ndx_2) override;
+
+    void unregister_linkview();
+    ref_type get_row_ref(size_t row_ndx) const noexcept;
+    void set_row_ref(size_t row_ndx, ref_type new_ref);
+    void add_backlink(size_t target_row, size_t source_row);
+    void remove_backlink(size_t target_row, size_t source_row);
+
+    // ArrayParent overrides
+    void update_child_ref(size_t child_ndx, ref_type new_ref) override;
+    ref_type get_child_ref(size_t child_ndx) const noexcept override;
+
+    // These helpers are needed because of the way the B+-tree of links is
+    // traversed in cascade_break_backlinks_to() and
+    // cascade_break_backlinks_to_all_rows().
+    void cascade_break_backlinks_to__leaf(size_t row_ndx, const Array& link_list_leaf,
+                                          CascadeState&);
+    void cascade_break_backlinks_to_all_rows__leaf(const Array& link_list_leaf, CascadeState&);
+
+    void discard_child_accessors() noexcept;
+
+    template<bool fix_ndx_in_parent>
+    void adj_insert_rows(size_t row_ndx, size_t num_rows_inserted) noexcept;
+
+    template<bool fix_ndx_in_parent>
+    void adj_erase_rows(size_t row_ndx, size_t num_rows_erased) noexcept;
+
+    template<bool fix_ndx_in_parent>
+    void adj_move_over(size_t from_row_ndx, size_t to_row_ndx) noexcept;
+
+    template<bool fix_ndx_in_parent>
+    void adj_swap(size_t row_ndx_1, size_t row_ndx_2) noexcept;
+
+    void prune_list_accessor_tombstones() noexcept;
+    void validate_list_accessors() const noexcept;
+
+#ifdef REALM_DEBUG
+    std::pair<ref_type, size_t> get_to_dot_parent(size_t) const override;
+#endif
+
+    friend class BacklinkColumn;
+    friend class LinkView;
+    friend class _impl::TransactLogConvenientEncoder;
+};
+
+
+
+
+
+// Implementation
+
+inline LinkListColumn::LinkListColumn(Allocator& alloc, ref_type ref, Table* table, size_t column_ndx):
+    LinkColumnBase(alloc, ref, table, column_ndx)
+{ 
+    m_list_accessors_contains_tombstones.store(false); 
+}
+
+inline LinkListColumn::~LinkListColumn() noexcept
+{
+    discard_child_accessors();
+}
+
+inline ref_type LinkListColumn::create(Allocator& alloc, size_t size)
+{
+    return IntegerColumn::create(alloc, Array::type_HasRefs, size); // Throws
+}
+
+inline bool LinkListColumn::is_nullable() const noexcept
+{
+    return false;
+}
+
+inline bool LinkListColumn::has_links(size_t row_ndx) const noexcept
+{
+    ref_type ref = LinkColumnBase::get_as_ref(row_ndx);
+    return (ref != 0);
+}
+
+inline size_t LinkListColumn::get_link_count(size_t row_ndx) const noexcept
+{
+    ref_type ref = LinkColumnBase::get_as_ref(row_ndx);
+    if (ref == 0)
+        return 0;
+    return ColumnBase::get_size_from_ref(ref, get_alloc());
+}
+
+inline ConstLinkViewRef LinkListColumn::get(size_t row_ndx) const
+{
+    return get_ptr(row_ndx);
+}
+
+inline LinkViewRef LinkListColumn::get(size_t row_ndx)
+{
+    return get_ptr(row_ndx);
+}
+
+inline bool LinkListColumn::is_null(size_t) const noexcept
+{
+    return false;
+}
+
+inline void LinkListColumn::set_null(size_t)
+{
+    throw LogicError{LogicError::column_not_nullable};
+}
+
+inline void LinkListColumn::do_discard_child_accessors() noexcept
+{
+    discard_child_accessors();
+}
+
+inline ref_type LinkListColumn::get_row_ref(size_t row_ndx) const noexcept
+{
+    return LinkColumnBase::get_as_ref(row_ndx);
+}
+
+inline void LinkListColumn::set_row_ref(size_t row_ndx, ref_type new_ref)
+{
+    LinkColumnBase::set(row_ndx, new_ref); // Throws
+}
+
+inline void LinkListColumn::add_backlink(size_t target_row, size_t source_row)
+{
+    m_backlink_column->add_backlink(target_row, source_row); // Throws
+}
+
+inline void LinkListColumn::remove_backlink(size_t target_row, size_t source_row)
+{
+    m_backlink_column->remove_one_backlink(target_row, source_row); // Throws
+}
+
+
+} //namespace realm
+
+#endif //REALM_COLUMN_LINKLIST_HPP
+
+
diff --git a/Pods/Realm/include/core/realm/column_mixed.hpp b/Pods/Realm/include/core/realm/column_mixed.hpp
new file mode 100644
index 0000000..1b8de2d
--- /dev/null
+++ b/Pods/Realm/include/core/realm/column_mixed.hpp
@@ -0,0 +1,263 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_COLUMN_MIXED_HPP
+#define REALM_COLUMN_MIXED_HPP
+
+#include <limits>
+
+#include <realm/column.hpp>
+#include <realm/column_type.hpp>
+#include <realm/column_table.hpp>
+#include <realm/column_binary.hpp>
+#include <realm/table.hpp>
+#include <realm/utilities.hpp>
+
+
+namespace realm {
+
+
+// Pre-declarations
+class BinaryColumn;
+
+
+/// A mixed column (MixedColumn) is composed of three subcolumns. The first
+/// subcolumn is an integer column (Column) and stores value types. The second
+/// one stores values and is a subtable parent column (SubtableColumnBase),
+/// which is a subclass of an integer column (Column). The last one is a binary
+/// column (BinaryColumn) and stores additional data for values of type string
+/// or binary data. The last subcolumn is optional. The root of a mixed column
+/// is an array node of type Array that stores the root refs of the subcolumns.
+class MixedColumn: public ColumnBaseSimple {
+public:
+    /// Create a mixed column wrapper and attach it to a preexisting
+    /// underlying structure of arrays.
+    ///
+    /// \param table If this column is used as part of a table you
+    /// must pass a pointer to that table. Otherwise you must pass
+    /// null
+    ///
+    /// \param column_ndx If this column is used as part of a table
+    /// you must pass the logical index of the column within that
+    /// table. Otherwise you should pass zero.
+    MixedColumn(Allocator&, ref_type, Table* table, size_t column_ndx);
+
+    ~MixedColumn() noexcept override;
+
+    DataType get_type(size_t ndx) const noexcept;
+    size_t size() const noexcept final { return m_types->size(); }
+    bool is_empty() const noexcept { return size() == 0; }
+
+    int64_t get_int(size_t ndx) const noexcept;
+    bool get_bool(size_t ndx) const noexcept;
+    OldDateTime get_olddatetime(size_t ndx) const noexcept;
+    Timestamp get_timestamp(size_t ndx) const noexcept;
+    float get_float(size_t ndx) const noexcept;
+    double get_double(size_t ndx) const noexcept;
+    StringData get_string(size_t ndx) const noexcept;
+    BinaryData get_binary(size_t ndx) const noexcept;
+    StringData get_index_data(size_t ndx, StringIndex::StringConversionBuffer& buffer) const noexcept override;
+
+    /// The returned array ref is zero if the specified row does not
+    /// contain a subtable.
+    ref_type get_subtable_ref(size_t row_ndx) const noexcept;
+
+    /// The returned size is zero if the specified row does not
+    /// contain a subtable.
+    size_t get_subtable_size(size_t row_ndx) const noexcept;
+
+    Table* get_subtable_accessor(size_t row_ndx) const noexcept override;
+
+    void discard_subtable_accessor(size_t row_ndx) noexcept override;
+
+    /// If the value at the specified index is a subtable, return a
+    /// pointer to that accessor for that subtable. Otherwise return
+    /// null. The accessor will be created if it does not already
+    /// exist.
+    ///
+    /// The returned table pointer must **always** end up being
+    /// wrapped in some instantiation of BasicTableRef<>.
+    Table* get_subtable_ptr(size_t row_ndx);
+
+    const Table* get_subtable_ptr(size_t subtable_ndx) const;
+
+    void set_int(size_t ndx, int64_t value);
+    void set_bool(size_t ndx, bool value);
+    void set_olddatetime(size_t ndx, OldDateTime value);
+    void set_timestamp(size_t ndx, Timestamp value);
+    void set_float(size_t ndx, float value);
+    void set_double(size_t ndx, double value);
+    void set_string(size_t ndx, StringData value) override;
+    void set_binary(size_t ndx, BinaryData value);
+    void set_subtable(size_t ndx, const Table* value);
+
+    void insert_int(size_t ndx, int64_t value);
+    void insert_bool(size_t ndx, bool value);
+    void insert_olddatetime(size_t ndx, OldDateTime value);
+    void insert_timestamp(size_t ndx, Timestamp value);
+    void insert_float(size_t ndx, float value);
+    void insert_double(size_t ndx, double value);
+    void insert_string(size_t ndx, StringData value);
+    void insert_binary(size_t ndx, BinaryData value);
+    void insert_subtable(size_t ndx, const Table* value);
+
+    void erase(size_t row_ndx);
+    void move_last_over(size_t row_ndx);
+    void clear();
+
+    /// Compare two mixed columns for equality.
+    bool compare_mixed(const MixedColumn&) const;
+
+    void discard_child_accessors() noexcept;
+
+    static ref_type create(Allocator&, size_t size = 0);
+
+    static size_t get_size_from_ref(ref_type root_ref, Allocator&) noexcept;
+
+    // Overriding method in ColumnBase
+    ref_type write(size_t, size_t, size_t,
+                   _impl::OutputStream&) const override;
+
+    void insert_rows(size_t, size_t, size_t, bool) override;
+    void erase_rows(size_t, size_t, size_t, bool) override;
+    void move_last_row_over(size_t, size_t, bool) override;
+    void swap_rows(size_t, size_t) override;
+    void clear(size_t, bool) override;
+    void update_from_parent(size_t) noexcept override;
+    void adj_acc_insert_rows(size_t, size_t) noexcept override;
+    void adj_acc_erase_row(size_t) noexcept override;
+    void adj_acc_move_over(size_t, size_t) noexcept override;
+    void adj_acc_swap_rows(size_t, size_t) noexcept override;
+    void adj_acc_clear_root_table() noexcept override;
+    void mark(int) noexcept override;
+    void refresh_accessor_tree(size_t, const Spec&) override;
+
+#ifdef REALM_DEBUG
+    void verify() const override;
+    void verify(const Table&, size_t) const override;
+    void to_dot(std::ostream&, StringData title) const override;
+    void do_dump_node_structure(std::ostream&, int) const override;
+#endif
+
+private:
+    enum MixedColType {
+        // NOTE: below numbers must be kept in sync with ColumnType
+        // Column types used in Mixed
+        mixcol_Int         =  0,
+        mixcol_Bool        =  1,
+        mixcol_String      =  2,
+        //                    3, used for STRING_ENUM in ColumnType
+        mixcol_Binary      =  4,
+        mixcol_Table       =  5,
+        mixcol_Mixed       =  6,
+        mixcol_OldDateTime =  7,
+        mixcol_Timestamp   =  8,
+        mixcol_Float       =  9,
+        mixcol_Double      = 10, // Positive Double
+        mixcol_DoubleNeg   = 11, // Negative Double
+        mixcol_IntNeg      = 12  // Negative Integers
+    };
+
+    class RefsColumn;
+
+    /// Stores the MixedColType of each value at the given index. For
+    /// values that uses all 64 bits, the type also encodes the sign
+    /// bit by having distinct types for positive negative values.
+    std::unique_ptr<IntegerColumn> m_types;
+
+    /// Stores the data for each entry. For a subtable, the stored
+    /// value is the ref of the subtable. For string, binary data,
+    /// the stored value is an index within `m_binary_data`. Likewise,
+    /// for timestamp, an index into `m_timestamp` is stored. For other
+    /// types the stored value is itself. Since we only have 63 bits
+    /// available for a non-ref value, the sign of numeric values is
+    /// encoded as part of the type in `m_types`.
+    std::unique_ptr<RefsColumn> m_data;
+
+    /// For string and binary data types, the bytes are stored here.
+    std::unique_ptr<BinaryColumn> m_binary_data;
+
+    /// Timestamps are stored here.
+    std::unique_ptr<TimestampColumn> m_timestamp_data;
+
+    void do_erase(size_t row_ndx, size_t num_rows_to_erase, size_t prior_num_rows);
+    void do_move_last_over(size_t row_ndx, size_t prior_num_rows);
+    void do_swap_rows(size_t, size_t);
+    void do_clear(size_t num_rows);
+
+    void create(Allocator&, ref_type, Table*, size_t column_ndx);
+    void ensure_binary_data_column();
+    void ensure_timestamp_column();
+
+    MixedColType clear_value(size_t ndx, MixedColType new_type); // Returns old type
+    void clear_value_and_discard_subtab_acc(size_t ndx, MixedColType new_type);
+
+    // Get/set/insert 64-bit values in m_data/m_types
+    int64_t get_value(size_t ndx) const noexcept;
+    void set_value(size_t ndx, int64_t value, MixedColType);
+    void set_int64(size_t ndx, int64_t value, MixedColType pos_type, MixedColType neg_type);
+
+    void insert_value(size_t row_ndx, int_fast64_t types_value, int_fast64_t data_value);
+    void insert_int(size_t ndx, int_fast64_t value, MixedColType type);
+    void insert_pos_neg(size_t ndx, int_fast64_t value, MixedColType pos_type,
+                        MixedColType neg_type);
+
+    void do_discard_child_accessors() noexcept override;
+
+#ifdef REALM_DEBUG
+    void do_verify(const Table*, size_t col_ndx) const;
+    void leaf_to_dot(MemRef, ArrayParent*, size_t, std::ostream&) const override;
+#endif
+};
+
+// LCOV_EXCL_START
+inline StringData MixedColumn::get_index_data(size_t, StringIndex::StringConversionBuffer&) const noexcept
+{
+    REALM_ASSERT(false && "Index not supported for MixedColumn yet.");
+    REALM_UNREACHABLE();
+    return {};
+}
+// LCOV_EXCL_STOP
+
+
+class MixedColumn::RefsColumn: public SubtableColumnBase {
+public:
+    RefsColumn(Allocator& alloc, ref_type ref, Table* table, size_t column_ndx):
+        SubtableColumnBase(alloc, ref, table, column_ndx)
+    {
+    }
+
+    ~RefsColumn() noexcept override {}
+
+    using SubtableColumnBase::get_subtable_ptr;
+
+    void refresh_accessor_tree(size_t, const Spec&) override;
+
+    friend class MixedColumn;
+};
+
+
+} // namespace realm
+
+
+// Implementation
+#include <realm/column_mixed_tpl.hpp>
+
+
+#endif // REALM_COLUMN_MIXED_HPP
diff --git a/Pods/Realm/include/core/realm/column_mixed_tpl.hpp b/Pods/Realm/include/core/realm/column_mixed_tpl.hpp
new file mode 100644
index 0000000..dfdf88a
--- /dev/null
+++ b/Pods/Realm/include/core/realm/column_mixed_tpl.hpp
@@ -0,0 +1,507 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+
+namespace realm {
+
+inline MixedColumn::MixedColumn(Allocator& alloc, ref_type ref,
+                                Table* table, size_t column_ndx)
+{
+    create(alloc, ref, table, column_ndx);
+}
+
+inline void MixedColumn::adj_acc_insert_rows(size_t row_ndx, size_t num_rows) noexcept
+{
+    m_data->adj_acc_insert_rows(row_ndx, num_rows);
+}
+
+inline void MixedColumn::adj_acc_erase_row(size_t row_ndx) noexcept
+{
+    m_data->adj_acc_erase_row(row_ndx);
+}
+
+inline void MixedColumn::adj_acc_swap_rows(size_t row_ndx_1, size_t row_ndx_2) noexcept
+{
+    m_data->adj_acc_swap_rows(row_ndx_1, row_ndx_2);
+}
+
+inline void MixedColumn::adj_acc_move_over(size_t from_row_ndx, size_t to_row_ndx) noexcept
+{
+    m_data->adj_acc_move_over(from_row_ndx, to_row_ndx);
+}
+
+inline void MixedColumn::adj_acc_clear_root_table() noexcept
+{
+    m_data->adj_acc_clear_root_table();
+}
+
+inline ref_type MixedColumn::get_subtable_ref(size_t row_ndx) const noexcept
+{
+    REALM_ASSERT_3(row_ndx, <, m_types->size());
+    if (m_types->get(row_ndx) != type_Table)
+        return 0;
+    return m_data->get_as_ref(row_ndx);
+}
+
+inline size_t MixedColumn::get_subtable_size(size_t row_ndx) const noexcept
+{
+    ref_type top_ref = get_subtable_ref(row_ndx);
+    if (top_ref == 0)
+        return 0;
+    return _impl::TableFriend::get_size_from_ref(top_ref, m_data->get_alloc());
+}
+
+inline Table* MixedColumn::get_subtable_accessor(size_t row_ndx) const noexcept
+{
+    return m_data->get_subtable_accessor(row_ndx);
+}
+
+inline void MixedColumn::discard_subtable_accessor(size_t row_ndx) noexcept
+{
+    m_data->discard_subtable_accessor(row_ndx);
+}
+
+inline Table* MixedColumn::get_subtable_ptr(size_t row_ndx)
+{
+    REALM_ASSERT_3(row_ndx, <, m_types->size());
+    if (m_types->get(row_ndx) != type_Table)
+        return 0;
+    return m_data->get_subtable_ptr(row_ndx); // Throws
+}
+
+inline const Table* MixedColumn::get_subtable_ptr(size_t subtable_ndx) const
+{
+    return const_cast<MixedColumn*>(this)->get_subtable_ptr(subtable_ndx);
+}
+
+inline void MixedColumn::discard_child_accessors() noexcept
+{
+    m_data->discard_child_accessors();
+}
+
+
+//
+// Getters
+//
+
+#define REALM_BIT63 0x8000000000000000ULL
+
+inline int64_t MixedColumn::get_value(size_t ndx) const noexcept
+{
+    REALM_ASSERT_3(ndx, <, m_types->size());
+
+    // Shift the unsigned value right - ensuring 0 gets in from left.
+    // Shifting signed integers right doesn't ensure 0's.
+    uint64_t value = uint64_t(m_data->get(ndx)) >> 1;
+    return int64_t(value);
+}
+
+inline int64_t MixedColumn::get_int(size_t ndx) const noexcept
+{
+    // Get first 63 bits of the integer value
+    int64_t value = get_value(ndx);
+
+    // restore 'sign'-bit from the column-type
+    MixedColType col_type = MixedColType(m_types->get(ndx));
+    if (col_type == mixcol_IntNeg) {
+        // FIXME: Bad cast of result of '|' from unsigned to signed
+        value |= REALM_BIT63; // set sign bit (63)
+    }
+    else {
+        REALM_ASSERT_3(col_type, ==, mixcol_Int);
+    }
+    return value;
+}
+
+inline bool MixedColumn::get_bool(size_t ndx) const noexcept
+{
+    REALM_ASSERT_3(m_types->get(ndx), ==, mixcol_Bool);
+
+    return (get_value(ndx) != 0);
+}
+
+inline OldDateTime MixedColumn::get_olddatetime(size_t ndx) const noexcept
+{
+    REALM_ASSERT_3(m_types->get(ndx), ==, mixcol_OldDateTime);
+
+    return OldDateTime(get_value(ndx));
+}
+
+inline float MixedColumn::get_float(size_t ndx) const noexcept
+{
+    static_assert(std::numeric_limits<float>::is_iec559, "'float' is not IEEE");
+    static_assert((sizeof (float) * CHAR_BIT == 32), "Assume 32 bit float.");
+    REALM_ASSERT_3(m_types->get(ndx), ==, mixcol_Float);
+
+    return type_punning<float>(get_value(ndx));
+}
+
+inline double MixedColumn::get_double(size_t ndx) const noexcept
+{
+    static_assert(std::numeric_limits<double>::is_iec559, "'double' is not IEEE");
+    static_assert((sizeof (double) * CHAR_BIT == 64), "Assume 64 bit double.");
+
+    int64_t int_val = get_value(ndx);
+
+    // restore 'sign'-bit from the column-type
+    MixedColType col_type = MixedColType(m_types->get(ndx));
+    if (col_type == mixcol_DoubleNeg)
+        int_val |= REALM_BIT63; // set sign bit (63)
+    else {
+        REALM_ASSERT_3(col_type, ==, mixcol_Double);
+    }
+    return type_punning<double>(int_val);
+}
+
+inline StringData MixedColumn::get_string(size_t ndx) const noexcept
+{
+    REALM_ASSERT_3(ndx, <, m_types->size());
+    REALM_ASSERT_3(m_types->get(ndx), ==, mixcol_String);
+    REALM_ASSERT(m_binary_data);
+
+    size_t data_ndx = size_t(int64_t(m_data->get(ndx)) >> 1);
+    return m_binary_data->get_string(data_ndx);
+}
+
+inline BinaryData MixedColumn::get_binary(size_t ndx) const noexcept
+{
+    REALM_ASSERT_3(ndx, <, m_types->size());
+    REALM_ASSERT_3(m_types->get(ndx), ==, mixcol_Binary);
+    REALM_ASSERT(m_binary_data);
+
+    size_t data_ndx = size_t(uint64_t(m_data->get(ndx)) >> 1);
+    return m_binary_data->get(data_ndx);
+}
+
+inline Timestamp MixedColumn::get_timestamp(size_t ndx) const noexcept
+{
+    REALM_ASSERT_3(ndx, <, m_types->size());
+    REALM_ASSERT_3(m_types->get(ndx), ==, mixcol_Timestamp);
+    REALM_ASSERT(m_timestamp_data);
+    size_t data_ndx = size_t(uint64_t(m_data->get(ndx)) >> 1);
+    return m_timestamp_data->get(data_ndx);
+}
+
+//
+// Setters
+//
+
+// Set a int64 value.
+// Store 63 bit of the value in m_data. Store sign bit in m_types.
+
+inline void MixedColumn::set_int64(size_t ndx, int64_t value, MixedColType pos_type, MixedColType neg_type)
+{
+    REALM_ASSERT_3(ndx, <, m_types->size());
+
+    // If sign-bit is set in value, 'store' it in the column-type
+    MixedColType coltype = ((value & REALM_BIT63) == 0) ? pos_type : neg_type;
+
+    // Remove refs or binary data (sets type to double)
+    clear_value_and_discard_subtab_acc(ndx, coltype); // Throws
+
+    // Shift value one bit and set lowest bit to indicate that this is not a ref
+    value = (value << 1) + 1;
+    m_data->set(ndx, value);
+}
+
+inline void MixedColumn::set_int(size_t ndx, int64_t value)
+{
+    set_int64(ndx, value, mixcol_Int, mixcol_IntNeg); // Throws
+}
+
+inline void MixedColumn::set_double(size_t ndx, double value)
+{
+    int64_t val64 = type_punning<int64_t>(value);
+    set_int64(ndx, val64, mixcol_Double, mixcol_DoubleNeg); // Throws
+}
+
+inline void MixedColumn::set_value(size_t ndx, int64_t value, MixedColType coltype)
+{
+    REALM_ASSERT_3(ndx, <, m_types->size());
+
+    // Remove refs or binary data (sets type to float)
+    clear_value_and_discard_subtab_acc(ndx, coltype); // Throws
+
+    // Shift value one bit and set lowest bit to indicate that this is not a ref
+    int64_t v = (value << 1) + 1;
+    m_data->set(ndx, v); // Throws
+}
+
+inline void MixedColumn::set_float(size_t ndx, float value)
+{
+    int64_t val64 = type_punning<int64_t>(value);
+    set_value(ndx, val64, mixcol_Float); // Throws
+}
+
+inline void MixedColumn::set_bool(size_t ndx, bool value)
+{
+    set_value(ndx, (value ? 1 : 0), mixcol_Bool); // Throws
+}
+
+inline void MixedColumn::set_olddatetime(size_t ndx, OldDateTime value)
+{
+    set_value(ndx, int64_t(value.get_olddatetime()), mixcol_OldDateTime); // Throws
+}
+
+inline void MixedColumn::set_subtable(size_t ndx, const Table* t)
+{
+    REALM_ASSERT_3(ndx, <, m_types->size());
+    typedef _impl::TableFriend tf;
+    ref_type ref;
+    if (t) {
+        ref = tf::clone(*t, get_alloc()); // Throws
+    }
+    else {
+        ref = tf::create_empty_table(get_alloc()); // Throws
+    }
+    // Remove any previous refs or binary data
+    clear_value_and_discard_subtab_acc(ndx, mixcol_Table); // Throws
+    m_data->set(ndx, ref); // Throws
+}
+
+//
+// Inserts
+//
+
+inline void MixedColumn::insert_value(size_t row_ndx, int_fast64_t types_value,
+                                      int_fast64_t data_value)
+{
+    size_t types_size = m_types->size(); // Slow
+    bool is_append = row_ndx == types_size;
+    size_t row_ndx_2 = is_append ? realm::npos : row_ndx;
+    size_t num_rows = 1;
+    m_types->insert_without_updating_index(row_ndx_2, types_value, num_rows); // Throws
+    m_data->do_insert(row_ndx_2, data_value, num_rows); // Throws
+}
+
+// Insert a int64 value.
+// Store 63 bit of the value in m_data. Store sign bit in m_types.
+
+inline void MixedColumn::insert_int(size_t ndx, int_fast64_t value, MixedColType type)
+{
+    int_fast64_t types_value = type;
+    // Shift value one bit and set lowest bit to indicate that this is not a ref
+    int_fast64_t data_value =  1 + (value << 1);
+    insert_value(ndx, types_value, data_value); // Throws
+}
+
+inline void MixedColumn::insert_pos_neg(size_t ndx, int_fast64_t value, MixedColType pos_type,
+                                        MixedColType neg_type)
+{
+    // 'store' the sign-bit in the integer-type
+    MixedColType type = (value & REALM_BIT63) == 0 ? pos_type : neg_type;
+    int_fast64_t types_value = type;
+    // Shift value one bit and set lowest bit to indicate that this is not a ref
+    int_fast64_t data_value =  1 + (value << 1);
+    insert_value(ndx, types_value, data_value); // Throws
+}
+
+inline void MixedColumn::insert_int(size_t ndx, int_fast64_t value)
+{
+    insert_pos_neg(ndx, value, mixcol_Int, mixcol_IntNeg); // Throws
+}
+
+inline void MixedColumn::insert_double(size_t ndx, double value)
+{
+    int_fast64_t value_2 = type_punning<int64_t>(value);
+    insert_pos_neg(ndx, value_2, mixcol_Double, mixcol_DoubleNeg); // Throws
+}
+
+inline void MixedColumn::insert_float(size_t ndx, float value)
+{
+    int_fast64_t value_2 = type_punning<int32_t>(value);
+    insert_int(ndx, value_2, mixcol_Float); // Throws
+}
+
+inline void MixedColumn::insert_bool(size_t ndx, bool value)
+{
+    int_fast64_t value_2 = int_fast64_t(value);
+    insert_int(ndx, value_2, mixcol_Bool); // Throws
+}
+
+inline void MixedColumn::insert_olddatetime(size_t ndx, OldDateTime value)
+{
+    int_fast64_t value_2 = int_fast64_t(value.get_olddatetime());
+    insert_int(ndx, value_2, mixcol_OldDateTime); // Throws
+}
+
+inline void MixedColumn::insert_timestamp(size_t ndx, Timestamp value)
+{
+    ensure_timestamp_column();
+    size_t data_ndx = m_timestamp_data->size();
+    m_timestamp_data->add(value); // Throws
+    insert_int(ndx, int_fast64_t(data_ndx), mixcol_Timestamp);
+}
+
+inline void MixedColumn::insert_string(size_t ndx, StringData value)
+{
+    ensure_binary_data_column();
+    size_t blob_ndx = m_binary_data->size();
+    m_binary_data->add_string(value); // Throws
+
+    int_fast64_t value_2 = int_fast64_t(blob_ndx);
+    insert_int(ndx, value_2, mixcol_String); // Throws
+}
+
+inline void MixedColumn::insert_binary(size_t ndx, BinaryData value)
+{
+    ensure_binary_data_column();
+    size_t blob_ndx = m_binary_data->size();
+    m_binary_data->add(value); // Throws
+
+    int_fast64_t value_2 = int_fast64_t(blob_ndx);
+    insert_int(ndx, value_2, mixcol_Binary); // Throws
+}
+
+inline void MixedColumn::insert_subtable(size_t ndx, const Table* t)
+{
+    typedef _impl::TableFriend tf;
+    ref_type ref;
+    if (t) {
+        ref = tf::clone(*t, get_alloc()); // Throws
+    }
+    else {
+        ref = tf::create_empty_table(get_alloc()); // Throws
+    }
+    int_fast64_t types_value = mixcol_Table;
+    int_fast64_t data_value = int_fast64_t(ref);
+    insert_value(ndx, types_value, data_value); // Throws
+}
+
+inline void MixedColumn::erase(size_t row_ndx)
+{
+    size_t num_rows_to_erase = 1;
+    size_t prior_num_rows = size(); // Note that size() is slow
+    do_erase(row_ndx, num_rows_to_erase, prior_num_rows); // Throws
+}
+
+inline void MixedColumn::move_last_over(size_t row_ndx)
+{
+    size_t prior_num_rows = size(); // Note that size() is slow
+    do_move_last_over(row_ndx, prior_num_rows); // Throws
+}
+
+inline void MixedColumn::swap_rows(size_t row_ndx_1, size_t row_ndx_2)
+{
+    do_swap_rows(row_ndx_1, row_ndx_2);
+}
+
+inline void MixedColumn::clear()
+{
+    size_t num_rows = size(); // Note that size() is slow
+    do_clear(num_rows); // Throws
+}
+
+inline size_t MixedColumn::get_size_from_ref(ref_type root_ref,
+                                                  Allocator& alloc) noexcept
+{
+    const char* root_header = alloc.translate(root_ref);
+    ref_type types_ref = to_ref(Array::get(root_header, 0));
+    return IntegerColumn::get_size_from_ref(types_ref, alloc);
+}
+
+inline void MixedColumn::clear_value_and_discard_subtab_acc(size_t row_ndx,
+                                                            MixedColType new_type)
+{
+    MixedColType old_type = clear_value(row_ndx, new_type);
+    if (old_type == mixcol_Table)
+        m_data->discard_subtable_accessor(row_ndx);
+}
+
+// Implementing pure virtual method of ColumnBase.
+inline void MixedColumn::insert_rows(size_t row_ndx, size_t num_rows_to_insert,
+                                     size_t prior_num_rows, bool insert_nulls)
+{
+    REALM_ASSERT_DEBUG(prior_num_rows == size());
+    REALM_ASSERT(row_ndx <= prior_num_rows);
+    REALM_ASSERT(!insert_nulls);
+
+    size_t row_ndx_2 = (row_ndx == prior_num_rows ? realm::npos : row_ndx);
+
+    int_fast64_t type_value = mixcol_Int;
+    m_types->insert_without_updating_index(row_ndx_2, type_value, num_rows_to_insert); // Throws
+
+    // The least significant bit indicates that the rest of the bits form an
+    // integer value, so 1 is actually zero.
+    int_fast64_t data_value = 1;
+    m_data->do_insert(row_ndx_2, data_value, num_rows_to_insert); // Throws
+}
+
+// Implementing pure virtual method of ColumnBase.
+inline void MixedColumn::erase_rows(size_t row_ndx, size_t num_rows_to_erase,
+                                    size_t prior_num_rows, bool)
+{
+    do_erase(row_ndx, num_rows_to_erase, prior_num_rows); // Throws
+}
+
+// Implementing pure virtual method of ColumnBase.
+inline void MixedColumn::move_last_row_over(size_t row_ndx, size_t prior_num_rows, bool)
+{
+    do_move_last_over(row_ndx, prior_num_rows); // Throws
+}
+
+// Implementing pure virtual method of ColumnBase.
+inline void MixedColumn::clear(size_t num_rows, bool)
+{
+    do_clear(num_rows); // Throws
+}
+
+inline void MixedColumn::mark(int type) noexcept
+{
+    m_data->mark(type);
+}
+
+inline void MixedColumn::refresh_accessor_tree(size_t col_ndx, const Spec& spec)
+{
+    get_root_array()->init_from_parent();
+    m_types->refresh_accessor_tree(col_ndx, spec); // Throws
+    m_data->refresh_accessor_tree(col_ndx, spec); // Throws
+    if (m_binary_data) {
+        REALM_ASSERT_3(get_root_array()->size(), >=, 3);
+        m_binary_data->refresh_accessor_tree(col_ndx, spec); // Throws
+    }
+    if (m_timestamp_data) {
+        REALM_ASSERT_3(get_root_array()->size(), >=, 4);
+        m_timestamp_data->refresh_accessor_tree(col_ndx, spec); // Throws
+    }
+
+
+    // See if m_binary_data needs to be created.
+    if (get_root_array()->size() >= 3) {
+        ref_type ref = get_root_array()->get_as_ref(2);
+        m_binary_data.reset(new BinaryColumn(get_alloc(), ref)); // Throws
+        m_binary_data->set_parent(get_root_array(), 2);
+    }
+
+    // See if m_timestamp_data needs to be created.
+    if (get_root_array()->size() >= 4) {
+        ref_type ref = get_root_array()->get_as_ref(3);
+        m_timestamp_data.reset(new TimestampColumn(get_alloc(), ref)); // Throws
+        m_timestamp_data->set_parent(get_root_array(), 3);
+    }
+}
+
+inline void MixedColumn::RefsColumn::refresh_accessor_tree(size_t col_ndx, const Spec& spec)
+{
+    SubtableColumnBase::refresh_accessor_tree(col_ndx, spec); // Throws
+    size_t spec_ndx_in_parent = 0; // Ignored because these are root tables
+    m_subtable_map.refresh_accessor_tree(spec_ndx_in_parent); // Throws
+}
+
+} // namespace realm
diff --git a/Pods/Realm/include/core/realm/column_string.hpp b/Pods/Realm/include/core/realm/column_string.hpp
new file mode 100644
index 0000000..3c26dc2
--- /dev/null
+++ b/Pods/Realm/include/core/realm/column_string.hpp
@@ -0,0 +1,392 @@
+
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_COLUMN_STRING_HPP
+#define REALM_COLUMN_STRING_HPP
+
+#include <memory>
+#include <realm/array_string.hpp>
+#include <realm/array_string_long.hpp>
+#include <realm/array_blobs_big.hpp>
+#include <realm/column.hpp>
+#include <realm/column_tpl.hpp>
+
+namespace realm {
+
+// Pre-declarations
+class StringIndex;
+
+
+/// A string column (StringColumn) is a single B+-tree, and
+/// the root of the column is the root of the B+-tree. Leaf nodes are
+/// either of type ArrayString (array of small strings),
+/// ArrayStringLong (array of medium strings), or ArrayBigBlobs (array
+/// of big strings).
+///
+/// A string column can optionally be equipped with a search index. If
+/// it is, then the root ref of the index is stored in
+/// Table::m_columns immediately after the root ref of the string
+/// column.
+class StringColumn: public ColumnBaseSimple, public ColumnTemplate<StringData> {
+public:
+    typedef StringData value_type;
+
+    StringColumn(Allocator&, ref_type, bool nullable = false);
+    ~StringColumn() noexcept override;
+
+    void destroy() noexcept override;
+
+    size_t size() const noexcept final;
+    bool is_empty() const noexcept { return size() == 0; }
+
+    bool is_null(size_t ndx) const noexcept final;
+    void set_null(size_t ndx) final;
+    StringData get(size_t ndx) const noexcept;
+    void set(size_t ndx, StringData);
+    void add();
+    void add(StringData value);
+    void insert(size_t ndx);
+    void insert(size_t ndx, StringData value);
+    void erase(size_t row_ndx);
+    void move_last_over(size_t row_ndx);
+    void swap_rows(size_t row_ndx_1, size_t row_ndx_2) override;
+    void clear();
+
+    size_t count(StringData value) const;
+    size_t find_first(StringData value, size_t begin = 0,
+                           size_t end = npos) const;
+    void find_all(IntegerColumn& result, StringData value, size_t begin = 0,
+                  size_t end = npos) const;
+
+    int compare_values(size_t, size_t) const override;
+
+    //@{
+    /// Find the lower/upper bound for the specified value assuming
+    /// that the elements are already sorted in ascending order
+    /// according to StringData::operator<().
+    size_t lower_bound_string(StringData value) const noexcept;
+    size_t upper_bound_string(StringData value) const noexcept;
+    //@}
+
+    void set_string(size_t, StringData) override;
+
+    FindRes find_all_indexref(StringData value, size_t& dst) const;
+
+    bool is_nullable() const noexcept final;
+
+    // Search index
+    StringData get_index_data(size_t ndx, StringIndex::StringConversionBuffer& buffer) const noexcept final;
+    bool has_search_index() const noexcept override;
+    void set_search_index_ref(ref_type, ArrayParent*, size_t, bool) override;
+    void set_search_index_allow_duplicate_values(bool) noexcept override;
+    StringIndex* get_search_index() noexcept override;
+    const StringIndex* get_search_index() const noexcept override;
+    std::unique_ptr<StringIndex> release_search_index() noexcept;
+    bool supports_search_index() const noexcept final { return true; }
+    StringIndex* create_search_index() override;
+
+    // Simply inserts all column values in the index in a loop
+    void populate_search_index();
+    void destroy_search_index() noexcept override;
+
+    // Optimizing data layout. enforce == true will enforce enumeration;
+    // enforce == false will auto-evaluate if it should be enumerated or not
+    bool auto_enumerate(ref_type& keys, ref_type& values, bool enforce = false) const;
+
+    /// Compare two string columns for equality.
+    bool compare_string(const StringColumn&) const;
+
+    enum LeafType {
+        leaf_type_Small,  ///< ArrayString
+        leaf_type_Medium, ///< ArrayStringLong
+        leaf_type_Big     ///< ArrayBigBlobs
+    };
+
+    std::unique_ptr<const ArrayParent> get_leaf(size_t ndx, size_t& out_ndx_in_parent,
+                      LeafType& out_leaf_type) const;
+
+    static ref_type create(Allocator&, size_t size = 0);
+
+    static size_t get_size_from_ref(ref_type root_ref, Allocator&) noexcept;
+
+    // Overrriding method in ColumnBase
+    ref_type write(size_t, size_t, size_t,
+                   _impl::OutputStream&) const override;
+
+    void insert_rows(size_t, size_t, size_t, bool) override;
+    void erase_rows(size_t, size_t, size_t, bool) override;
+    void move_last_row_over(size_t, size_t, bool) override;
+    void clear(size_t, bool) override;
+    void set_ndx_in_parent(size_t ndx_in_parent) noexcept override;
+    void update_from_parent(size_t old_baseline) noexcept override;
+    void refresh_accessor_tree(size_t, const Spec&) override;
+
+#ifdef REALM_DEBUG
+    void verify() const override;
+    void verify(const Table&, size_t) const override;
+    void to_dot(std::ostream&, StringData title) const override;
+    void do_dump_node_structure(std::ostream&, int) const override;
+#endif
+
+protected:
+    StringData get_val(size_t row) const override { return get(row); }
+
+private:
+    std::unique_ptr<StringIndex> m_search_index;
+    bool m_nullable;
+
+    LeafType get_block(size_t ndx, ArrayParent**, size_t& off,
+                      bool use_retval = false) const;
+
+    /// If you are appending and have the size of the column readily available,
+    /// call the 4 argument version instead. If you are not appending, either
+    /// one is fine.
+    ///
+    /// \param row_ndx Must be `realm::npos` if appending.
+    void do_insert(size_t row_ndx, StringData value, size_t num_rows);
+
+    /// If you are appending and you do not have the size of the column readily
+    /// available, call the 3 argument version instead. If you are not
+    /// appending, either one is fine.
+    ///
+    /// \param is_append Must be true if, and only if `row_ndx` is equal to the
+    /// size of the column (before insertion).
+    void do_insert(size_t row_ndx, StringData value, size_t num_rows, bool is_append);
+
+    /// \param row_ndx Must be `realm::npos` if appending.
+    void bptree_insert(size_t row_ndx, StringData value, size_t num_rows);
+
+    // Called by Array::bptree_insert().
+    static ref_type leaf_insert(MemRef leaf_mem, ArrayParent&, size_t ndx_in_parent,
+                                Allocator&, size_t insert_ndx,
+                                Array::TreeInsert<StringColumn>& state);
+
+    class EraseLeafElem;
+    class CreateHandler;
+    class SliceHandler;
+
+    void do_erase(size_t row_ndx, bool is_last);
+    void do_move_last_over(size_t row_ndx, size_t last_row_ndx);
+    void do_swap_rows(size_t row_ndx_1, size_t row_ndx_2);
+    void do_clear();
+
+    /// Root must be a leaf. Upgrades the root leaf as
+    /// necessary. Returns the type of the root leaf as it is upon
+    /// return.
+    LeafType upgrade_root_leaf(size_t value_size);
+
+    void refresh_root_accessor();
+
+#ifdef REALM_DEBUG
+    void leaf_to_dot(MemRef, ArrayParent*, size_t ndx_in_parent,
+                     std::ostream&) const override;
+#endif
+
+    friend class Array;
+    friend class ColumnBase;
+};
+
+
+
+
+
+// Implementation:
+
+inline size_t StringColumn::size() const noexcept
+{
+    if (root_is_leaf()) {
+        bool long_strings = m_array->has_refs();
+        if (!long_strings) {
+            // Small strings root leaf
+            ArrayString* leaf = static_cast<ArrayString*>(m_array.get());
+            return leaf->size();
+        }
+        bool is_big = m_array->get_context_flag();
+        if (!is_big) {
+            // Medium strings root leaf
+            ArrayStringLong* leaf = static_cast<ArrayStringLong*>(m_array.get());
+            return leaf->size();
+        }
+        // Big strings root leaf
+        ArrayBigBlobs* leaf = static_cast<ArrayBigBlobs*>(m_array.get());
+        return leaf->size();
+    }
+    // Non-leaf root
+    return m_array->get_bptree_size();
+}
+
+inline void StringColumn::add(StringData value)
+{
+    REALM_ASSERT(!(value.is_null() && !m_nullable));
+    size_t row_ndx = realm::npos;
+    size_t num_rows = 1;
+    do_insert(row_ndx, value, num_rows); // Throws
+}
+
+inline void StringColumn::add()
+{
+    add(m_nullable ? realm::null() : StringData(""));
+}
+
+inline void StringColumn::insert(size_t row_ndx, StringData value)
+{
+    REALM_ASSERT(!(value.is_null() && !m_nullable));
+    size_t column_size = this->size();
+    REALM_ASSERT_3(row_ndx, <=, column_size);
+    size_t num_rows = 1;
+    bool is_append = row_ndx == column_size;
+    do_insert(row_ndx, value, num_rows, is_append); // Throws
+}
+
+inline void StringColumn::insert(size_t row_ndx)
+{
+    insert(row_ndx, m_nullable ? realm::null() : StringData(""));
+}
+
+inline void StringColumn::erase(size_t row_ndx)
+{
+    size_t last_row_ndx = size() - 1; // Note that size() is slow
+    bool is_last = row_ndx == last_row_ndx;
+    do_erase(row_ndx, is_last); // Throws
+}
+
+inline void StringColumn::move_last_over(size_t row_ndx)
+{
+    size_t last_row_ndx = size() - 1; // Note that size() is slow
+    do_move_last_over(row_ndx, last_row_ndx); // Throws
+}
+
+inline void StringColumn::swap_rows(size_t row_ndx_1, size_t row_ndx_2)
+{
+    do_swap_rows(row_ndx_1, row_ndx_2); // Throws
+}
+
+inline void StringColumn::clear()
+{
+    do_clear(); // Throws
+}
+
+inline int StringColumn::compare_values(size_t row1, size_t row2) const
+{
+    StringData a = get(row1);
+    StringData b = get(row2);
+
+    if (a.is_null() && !b.is_null())
+        return 1;
+    else if (b.is_null() && !a.is_null())
+        return -1;
+    else if (a.is_null() && b.is_null())
+        return 0;
+
+    if (a == b)
+        return 0;
+    return utf8_compare(a, b) ? 1 : -1;
+}
+
+inline void StringColumn::set_string(size_t row_ndx, StringData value)
+{
+    REALM_ASSERT(!(value.is_null() && !m_nullable));
+    set(row_ndx, value); // Throws
+}
+
+inline bool StringColumn::has_search_index() const noexcept
+{
+    return m_search_index != 0;
+}
+
+inline StringIndex* StringColumn::get_search_index() noexcept
+{
+    return m_search_index.get();
+}
+
+inline const StringIndex* StringColumn::get_search_index() const noexcept
+{
+    return m_search_index.get();
+}
+
+inline size_t StringColumn::get_size_from_ref(ref_type root_ref,
+                                                   Allocator& alloc) noexcept
+{
+    const char* root_header = alloc.translate(root_ref);
+    bool root_is_leaf = !Array::get_is_inner_bptree_node_from_header(root_header);
+    if (root_is_leaf) {
+        bool long_strings = Array::get_hasrefs_from_header(root_header);
+        if (!long_strings) {
+            // Small strings leaf
+            return ArrayString::get_size_from_header(root_header);
+        }
+        bool is_big = Array::get_context_flag_from_header(root_header);
+        if (!is_big) {
+            // Medium strings leaf
+            return ArrayStringLong::get_size_from_header(root_header, alloc);
+        }
+        // Big strings leaf
+        return ArrayBigBlobs::get_size_from_header(root_header);
+    }
+    return Array::get_bptree_size_from_header(root_header);
+}
+
+// Implementing pure virtual method of ColumnBase.
+inline void StringColumn::insert_rows(size_t row_ndx, size_t num_rows_to_insert,
+                                      size_t prior_num_rows, bool insert_nulls)
+{
+    REALM_ASSERT_DEBUG(prior_num_rows == size());
+    REALM_ASSERT(row_ndx <= prior_num_rows);
+    REALM_ASSERT(!insert_nulls || m_nullable);
+
+    StringData value = m_nullable ? realm::null() : StringData("");
+    bool is_append = (row_ndx == prior_num_rows);
+    do_insert(row_ndx, value, num_rows_to_insert, is_append); // Throws
+}
+
+// Implementing pure virtual method of ColumnBase.
+inline void StringColumn::erase_rows(size_t row_ndx, size_t num_rows_to_erase,
+                                     size_t prior_num_rows, bool)
+{
+    REALM_ASSERT_DEBUG(prior_num_rows == size());
+    REALM_ASSERT(num_rows_to_erase <= prior_num_rows);
+    REALM_ASSERT(row_ndx <= prior_num_rows - num_rows_to_erase);
+
+    bool is_last = (row_ndx + num_rows_to_erase == prior_num_rows);
+    for (size_t i = num_rows_to_erase; i > 0; --i) {
+        size_t row_ndx_2 = row_ndx + i - 1;
+        do_erase(row_ndx_2, is_last); // Throws
+    }
+}
+
+// Implementing pure virtual method of ColumnBase.
+inline void StringColumn::move_last_row_over(size_t row_ndx, size_t prior_num_rows, bool)
+{
+    REALM_ASSERT_DEBUG(prior_num_rows == size());
+    REALM_ASSERT(row_ndx < prior_num_rows);
+
+    size_t last_row_ndx = prior_num_rows - 1;
+    do_move_last_over(row_ndx, last_row_ndx); // Throws
+}
+
+// Implementing pure virtual method of ColumnBase.
+inline void StringColumn::clear(size_t, bool)
+{
+    do_clear(); // Throws
+}
+
+} // namespace realm
+
+#endif // REALM_COLUMN_STRING_HPP
diff --git a/Pods/Realm/include/core/realm/column_string_enum.hpp b/Pods/Realm/include/core/realm/column_string_enum.hpp
new file mode 100644
index 0000000..8a280b1
--- /dev/null
+++ b/Pods/Realm/include/core/realm/column_string_enum.hpp
@@ -0,0 +1,314 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_COLUMN_STRING_ENUM_HPP
+#define REALM_COLUMN_STRING_ENUM_HPP
+
+#include <realm/column_string.hpp>
+
+namespace realm {
+
+// Pre-declarations
+class StringIndex;
+
+
+/// From the point of view of the application, an enumerated strings column
+/// (StringEnumColumn) is like a string column (StringColumn), yet it manages
+/// its strings in such a way that each unique string is stored only once. In
+/// fact, an enumerated strings column is a combination of two subcolumns; a
+/// regular string column (StringColumn) that stores the unique strings, and an
+/// integer column that stores one unique string index for each entry in the
+/// enumerated strings column.
+///
+/// In terms of the underlying node structure, the subcolumn containing the
+/// unique strings is not a true part of the enumerated strings column. Instead
+/// it is a part of the spec structure that describes the table of which the
+/// enumerated strings column is a part. This way, the unique strings can be
+/// shared across enumerated strings columns of multiple subtables. This also
+/// means that the root of an enumerated strings column coincides with the root
+/// of the integer subcolumn, and in some sense, an enumerated strings column is
+/// just the integer subcolumn.
+///
+/// An enumerated strings column can optionally be equipped with a
+/// search index. If it is, then the root ref of the index is stored
+/// in Table::m_columns immediately after the root ref of the
+/// enumerated strings column.
+class StringEnumColumn: public IntegerColumn {
+public:
+    typedef StringData value_type;
+
+    StringEnumColumn(Allocator&, ref_type ref, ref_type keys_ref, bool nullable);
+    ~StringEnumColumn() noexcept override;
+    void destroy() noexcept override;
+    MemRef clone_deep(Allocator& alloc) const override;
+
+    int compare_values(size_t row1, size_t row2) const override
+    {
+        StringData a = get(row1);
+        StringData b = get(row2);
+
+        if (a.is_null() && !b.is_null())
+            return 1;
+        else if (b.is_null() && !a.is_null())
+            return -1;
+        else if (a.is_null() && b.is_null())
+            return 0;
+
+        if (a == b)
+            return 0;
+
+        return utf8_compare(a, b) ? 1 : -1;
+    }
+
+    StringData get(size_t ndx) const noexcept;
+    bool is_null(size_t ndx) const noexcept final;
+    void set(size_t ndx, StringData value);
+    void set_null(size_t ndx) override;
+    void add();
+    void add(StringData value);
+    void insert(size_t ndx);
+    void insert(size_t ndx, StringData value);
+    void erase(size_t row_ndx);
+    void move_last_over(size_t row_ndx);
+    void clear();
+    bool is_nullable() const noexcept final;
+
+    size_t count(StringData value) const;
+    size_t find_first(StringData value, size_t begin = 0, size_t end = npos) const;
+    void find_all(IntegerColumn& res, StringData value,
+                  size_t begin = 0, size_t end = npos) const;
+    FindRes find_all_indexref(StringData value, size_t& dst) const;
+
+    size_t count(size_t key_index) const;
+    size_t find_first(size_t key_index, size_t begin=0, size_t end=-1) const;
+    void find_all(IntegerColumn& res, size_t key_index, size_t begin = 0, size_t end = -1) const;
+
+    //@{
+    /// Find the lower/upper bound for the specified value assuming
+    /// that the elements are already sorted in ascending order
+    /// according to StringData::operator<().
+    size_t lower_bound_string(StringData value) const noexcept;
+    size_t upper_bound_string(StringData value) const noexcept;
+    //@}
+
+    void set_string(size_t, StringData) override;
+
+    void adjust_keys_ndx_in_parent(int diff) noexcept;
+
+    // Search index
+    StringData get_index_data(size_t ndx, StringIndex::StringConversionBuffer& buffer) const noexcept final;
+    void set_search_index_allow_duplicate_values(bool) noexcept override;
+    bool supports_search_index() const noexcept final { return true; }
+    StringIndex* create_search_index() override;
+    void install_search_index(std::unique_ptr<StringIndex>) noexcept;
+    void destroy_search_index() noexcept override;
+
+    // Compare two string columns for equality
+    bool compare_string(const StringColumn&) const;
+    bool compare_string(const StringEnumColumn&) const;
+
+    void insert_rows(size_t, size_t, size_t, bool) override;
+    void erase_rows(size_t, size_t, size_t, bool) override;
+    void move_last_row_over(size_t, size_t, bool) override;
+    void clear(size_t, bool) override;
+    void update_from_parent(size_t) noexcept override;
+    void refresh_accessor_tree(size_t, const Spec&) override;
+
+    size_t get_key_ndx(StringData value) const;
+    size_t get_key_ndx_or_add(StringData value);
+
+    StringColumn& get_keys();
+    const StringColumn& get_keys() const;
+
+#ifdef REALM_DEBUG
+    void verify() const override;
+    void verify(const Table&, size_t) const override;
+    void do_dump_node_structure(std::ostream&, int) const override;
+    void to_dot(std::ostream&, StringData title) const override;
+#endif
+
+private:
+    // Member variables
+    StringColumn m_keys;
+    bool m_nullable;
+
+    /// If you are appending and have the size of the column readily available,
+    /// call the 4 argument version instead. If you are not appending, either
+    /// one is fine.
+    ///
+    /// \param row_ndx Must be `realm::npos` if appending.
+    void do_insert(size_t row_ndx, StringData value, size_t num_rows);
+
+    /// If you are appending and you do not have the size of the column readily
+    /// available, call the 3 argument version instead. If you are not
+    /// appending, either one is fine.
+    ///
+    /// \param is_append Must be true if, and only if `row_ndx` is equal to the
+    /// size of the column (before insertion).
+    void do_insert(size_t row_ndx, StringData value, size_t num_rows, bool is_append);
+
+    void do_erase(size_t row_ndx, bool is_last);
+    void do_move_last_over(size_t row_ndx, size_t last_row_ndx);
+    void do_clear();
+};
+
+
+
+
+
+// Implementation:
+
+inline StringData StringEnumColumn::get(size_t ndx) const noexcept
+{
+    REALM_ASSERT_3(ndx, <, IntegerColumn::size());
+    size_t key_ndx = to_size_t(IntegerColumn::get(ndx));
+    StringData sd = m_keys.get(key_ndx);
+    REALM_ASSERT_DEBUG(!(!m_nullable && sd.is_null()));
+    return sd;
+}
+
+inline bool StringEnumColumn::is_null(size_t ndx) const noexcept
+{
+    return is_nullable() ? get(ndx).is_null() : false;
+}
+
+inline void StringEnumColumn::add()
+{
+    add(m_nullable ? realm::null() : StringData(""));
+}
+
+inline void StringEnumColumn::add(StringData value)
+{
+    REALM_ASSERT_DEBUG(!(!m_nullable && value.is_null()));
+    size_t row_ndx = realm::npos;
+    size_t num_rows = 1;
+    do_insert(row_ndx, value, num_rows); // Throws
+}
+
+inline void StringEnumColumn::insert(size_t row_ndx)
+{
+    insert(row_ndx, m_nullable ? realm::null() : StringData(""));
+}
+
+inline void StringEnumColumn::insert(size_t row_ndx, StringData value)
+{
+    REALM_ASSERT_DEBUG(!(!m_nullable && value.is_null()));
+    size_t column_size = this->size();
+    REALM_ASSERT_3(row_ndx, <=, column_size);
+    size_t num_rows = 1;
+    bool is_append = row_ndx == column_size;
+    do_insert(row_ndx, value, num_rows, is_append); // Throws
+}
+
+inline void StringEnumColumn::erase(size_t row_ndx)
+{
+    size_t last_row_ndx = size() - 1; // Note that size() is slow
+    bool is_last = row_ndx == last_row_ndx;
+    do_erase(row_ndx, is_last); // Throws
+}
+
+inline void StringEnumColumn::move_last_over(size_t row_ndx)
+{
+    size_t last_row_ndx = size() - 1; // Note that size() is slow
+    do_move_last_over(row_ndx, last_row_ndx); // Throws
+}
+
+inline void StringEnumColumn::clear()
+{
+    do_clear(); // Throws
+}
+
+// Overriding virtual method of Column.
+inline void StringEnumColumn::insert_rows(size_t row_ndx, size_t num_rows_to_insert,
+                                          size_t prior_num_rows, bool insert_nulls)
+{
+    REALM_ASSERT_DEBUG(prior_num_rows == size());
+    REALM_ASSERT(row_ndx <= prior_num_rows);
+    REALM_ASSERT(!insert_nulls || m_nullable);
+
+    StringData value = m_nullable ? realm::null() : StringData("");
+    bool is_append = (row_ndx == prior_num_rows);
+    do_insert(row_ndx, value, num_rows_to_insert, is_append); // Throws
+}
+
+// Overriding virtual method of Column.
+inline void StringEnumColumn::erase_rows(size_t row_ndx, size_t num_rows_to_erase,
+                                         size_t prior_num_rows, bool)
+{
+    REALM_ASSERT_DEBUG(prior_num_rows == size());
+    REALM_ASSERT(num_rows_to_erase <= prior_num_rows);
+    REALM_ASSERT(row_ndx <= prior_num_rows - num_rows_to_erase);
+
+    bool is_last = (row_ndx + num_rows_to_erase == prior_num_rows);
+    for (size_t i = num_rows_to_erase; i > 0; --i) {
+        size_t row_ndx_2 = row_ndx + i - 1;
+        do_erase(row_ndx_2, is_last); // Throws
+    }
+}
+
+// Overriding virtual method of Column.
+inline void StringEnumColumn::move_last_row_over(size_t row_ndx, size_t prior_num_rows, bool)
+{
+    REALM_ASSERT_DEBUG(prior_num_rows == size());
+    REALM_ASSERT(row_ndx < prior_num_rows);
+
+    size_t last_row_ndx = prior_num_rows - 1;
+    do_move_last_over(row_ndx, last_row_ndx); // Throws
+}
+
+// Overriding virtual method of Column.
+inline void StringEnumColumn::clear(size_t, bool)
+{
+    do_clear(); // Throws
+}
+
+inline size_t StringEnumColumn::lower_bound_string(StringData value) const noexcept
+{
+    return ColumnBase::lower_bound(*this, value);
+}
+
+inline size_t StringEnumColumn::upper_bound_string(StringData value) const noexcept
+{
+    return ColumnBase::upper_bound(*this, value);
+}
+
+inline void StringEnumColumn::set_string(size_t row_ndx, StringData value)
+{
+    set(row_ndx, value); // Throws
+}
+
+inline void StringEnumColumn::set_null(size_t row_ndx)
+{
+    set(row_ndx, realm::null{});
+}
+
+inline StringColumn& StringEnumColumn::get_keys()
+{
+    return m_keys;
+}
+
+inline const StringColumn& StringEnumColumn::get_keys() const
+{
+    return m_keys;
+}
+
+
+} // namespace realm
+
+#endif // REALM_COLUMN_STRING_ENUM_HPP
diff --git a/Pods/Realm/include/core/realm/column_table.hpp b/Pods/Realm/include/core/realm/column_table.hpp
new file mode 100644
index 0000000..b9f92fa
--- /dev/null
+++ b/Pods/Realm/include/core/realm/column_table.hpp
@@ -0,0 +1,616 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_COLUMN_TABLE_HPP
+#define REALM_COLUMN_TABLE_HPP
+
+#include <vector>
+
+#include <realm/util/features.h>
+#include <memory>
+#include <realm/column.hpp>
+#include <realm/table.hpp>
+
+namespace realm {
+
+
+/// Base class for any type of column that can contain subtables.
+// FIXME: Don't derive from IntegerColumn, but define a BpTree<ref_type> specialization.
+class SubtableColumnBase: public IntegerColumn, public Table::Parent {
+public:
+    void discard_child_accessors() noexcept;
+
+    ~SubtableColumnBase() noexcept override;
+
+    static ref_type create(Allocator&, size_t size = 0);
+
+    Table* get_subtable_accessor(size_t) const noexcept override;
+
+    void insert_rows(size_t, size_t, size_t, bool) override;
+    void erase_rows(size_t, size_t, size_t, bool) override;
+    void move_last_row_over(size_t, size_t, bool) override;
+    void clear(size_t, bool) override;
+    void swap_rows(size_t, size_t) override;
+    void discard_subtable_accessor(size_t) noexcept override;
+    void update_from_parent(size_t) noexcept override;
+    void adj_acc_insert_rows(size_t, size_t) noexcept override;
+    void adj_acc_erase_row(size_t) noexcept override;
+    void adj_acc_move_over(size_t, size_t) noexcept override;
+    void adj_acc_clear_root_table() noexcept override;
+    void adj_acc_swap_rows(size_t, size_t) noexcept override;
+    void mark(int) noexcept override;
+    void refresh_accessor_tree(size_t, const Spec&) override;
+    bool supports_search_index() const noexcept override { return false; }
+    StringIndex* create_search_index() override { return nullptr; }
+
+#ifdef REALM_DEBUG
+    void verify() const override;
+    void verify(const Table&, size_t) const override;
+#endif
+
+protected:
+    /// A pointer to the table that this column is part of. For a free-standing
+    /// column, this pointer is null.
+    Table* const m_table;
+
+    /// The index of this column within m_table.m_cols. For a free-standing
+    /// column, this index is zero.
+    size_t m_column_ndx;
+
+    struct SubtableMap {
+        ~SubtableMap() noexcept {}
+        bool empty() const noexcept { return m_entries.empty(); }
+        Table* find(size_t subtable_ndx) const noexcept;
+        void add(size_t subtable_ndx, Table*);
+        // Returns true if, and only if at least one entry was detached and
+        // removed from the map.
+        bool detach_and_remove_all() noexcept;
+        // Returns true if, and only if the entry was found and removed, and it
+        // was the last entry in the map.
+        bool detach_and_remove(size_t subtable_ndx) noexcept;
+        // Returns true if, and only if the entry was found and removed, and it
+        // was the last entry in the map.
+        bool remove(Table*) noexcept;
+        void update_from_parent(size_t old_baseline) const noexcept;
+        template<bool fix_ndx_in_parent>
+        void adj_insert_rows(size_t row_ndx, size_t num_rows_inserted) noexcept;
+        // Returns true if, and only if an entry was found and removed, and it
+        // was the last entry in the map.
+        template<bool fix_ndx_in_parent>
+        bool adj_erase_rows(size_t row_ndx, size_t num_rows_erased) noexcept;
+        // Returns true if, and only if an entry was found and removed, and it
+        // was the last entry in the map.
+        template<bool fix_ndx_in_parent>
+        bool adj_move_over(size_t from_row_ndx, size_t to_row_ndx) noexcept;
+        template<bool fix_ndx_in_parent>
+        void adj_swap_rows(size_t row_ndx_1, size_t row_ndx_2) noexcept;
+
+        void update_accessors(const size_t* col_path_begin, const size_t* col_path_end,
+                              _impl::TableFriend::AccessorUpdater&);
+        void recursive_mark() noexcept;
+        void refresh_accessor_tree(size_t spec_ndx_in_parent);
+    private:
+        struct SubtableEntry {
+            size_t m_subtable_ndx;
+            Table* m_table;
+        };
+        typedef std::vector<SubtableEntry> entries;
+        entries m_entries;
+    };
+
+    /// Contains all existing accessors that are attached to a subtable in this
+    /// column. It can map a row index into a pointer to the corresponding
+    /// accessor when it exists.
+    ///
+    /// There is an invariant in force: Either `m_table` is null, or there is an
+    /// additional referece count on `*m_table` when, and only when the map is
+    /// non-empty.
+    mutable SubtableMap m_subtable_map;
+
+    SubtableColumnBase(Allocator&, ref_type, Table*, size_t column_ndx);
+
+    /// Get a pointer to the accessor of the specified subtable. The
+    /// accessor will be created if it does not already exist.
+    ///
+    /// The returned table pointer must **always** end up being
+    /// wrapped in some instantiation of BasicTableRef<>.
+    ///
+    /// NOTE: This method must be used only for subtables with
+    /// independent specs, i.e. for elements of a MixedColumn.
+    Table* get_subtable_ptr(size_t subtable_ndx);
+
+    // Overriding method in ArrayParent
+    void update_child_ref(size_t, ref_type) override;
+
+    // Overriding method in ArrayParent
+    ref_type get_child_ref(size_t) const noexcept override;
+
+    // Overriding method in Table::Parent
+    Table* get_parent_table(size_t*) noexcept override;
+
+    // Overriding method in Table::Parent
+    void child_accessor_destroyed(Table*) noexcept override;
+
+    /// Assumes that the two tables have the same spec.
+    static bool compare_subtable_rows(const Table&, const Table&);
+
+    /// Construct a copy of the columns array of the specified table
+    /// and return just the ref to that array.
+    ///
+    /// In the clone, no string column will be of the enumeration
+    /// type.
+    ref_type clone_table_columns(const Table*);
+
+    size_t* record_subtable_path(size_t* begin,
+                                      size_t* end) noexcept override;
+
+    void update_table_accessors(const size_t* col_path_begin, const size_t* col_path_end,
+                                _impl::TableFriend::AccessorUpdater&);
+
+    /// \param row_ndx Must be `realm::npos` if appending.
+    void do_insert(size_t row_ndx, int_fast64_t value, size_t num_rows);
+
+#ifdef REALM_DEBUG
+    std::pair<ref_type, size_t>
+    get_to_dot_parent(size_t ndx_in_parent) const override;
+#endif
+
+    friend class Table;
+};
+
+
+
+class SubtableColumn: public SubtableColumnBase {
+public:
+    /// Create a subtable column accessor and attach it to a
+    /// preexisting underlying structure of arrays.
+    ///
+    /// \param table If this column is used as part of a table you must
+    /// pass a pointer to that table. Otherwise you must pass null.
+    ///
+    /// \param column_ndx If this column is used as part of a table
+    /// you must pass the logical index of the column within that
+    /// table. Otherwise you should pass zero.
+    SubtableColumn(Allocator&, ref_type, Table* table, size_t column_ndx);
+
+    ~SubtableColumn() noexcept override {}
+
+    size_t get_subtable_size(size_t ndx) const noexcept;
+
+    /// Get a pointer to the accessor of the specified subtable. The
+    /// accessor will be created if it does not already exist.
+    ///
+    /// The returned table pointer must **always** end up being
+    /// wrapped in some instantiation of BasicTableRef<>.
+    Table* get_subtable_ptr(size_t subtable_ndx);
+
+    const Table* get_subtable_ptr(size_t subtable_ndx) const;
+
+    // When passing a table to add() or insert() it is assumed that
+    // the table spec is compatible with this column. The number of
+    // columns must be the same, and the corresponding columns must
+    // have the same data type (as returned by
+    // Table::get_column_type()).
+
+    void add(const Table* value = nullptr);
+    void insert(size_t ndx, const Table* value = nullptr);
+    void set(size_t ndx, const Table*);
+    void clear_table(size_t ndx);
+
+    using SubtableColumnBase::insert;
+
+    void erase_rows(size_t, size_t, size_t, bool) override;
+    void move_last_row_over(size_t, size_t, bool) override;
+
+    /// Compare two subtable columns for equality.
+    bool compare_table(const SubtableColumn&) const;
+
+    void refresh_accessor_tree(size_t, const Spec&) override;
+
+#ifdef REALM_DEBUG
+    void verify(const Table&, size_t) const override;
+    void do_dump_node_structure(std::ostream&, int) const override;
+    void to_dot(std::ostream&, StringData title) const override;
+#endif
+
+private:
+    mutable size_t m_subspec_ndx; // Unknown if equal to `npos`
+
+    size_t get_subspec_ndx() const noexcept;
+
+    void destroy_subtable(size_t ndx) noexcept;
+
+    void do_discard_child_accessors() noexcept override;
+};
+
+
+
+
+
+// Implementation
+
+// Overriding virtual method of Column.
+inline void SubtableColumnBase::insert_rows(size_t row_ndx, size_t num_rows_to_insert,
+                                            size_t prior_num_rows, bool insert_nulls)
+{
+    REALM_ASSERT_DEBUG(prior_num_rows == size());
+    REALM_ASSERT(row_ndx <= prior_num_rows);
+    REALM_ASSERT(!insert_nulls);
+
+    size_t row_ndx_2 = (row_ndx == prior_num_rows ? realm::npos : row_ndx);
+    int_fast64_t value = 0;
+    do_insert(row_ndx_2, value, num_rows_to_insert); // Throws
+}
+
+// Overriding virtual method of Column.
+inline void SubtableColumnBase::erase_rows(size_t row_ndx, size_t num_rows_to_erase,
+                                           size_t prior_num_rows,
+                                           bool broken_reciprocal_backlinks)
+{
+    IntegerColumn::erase_rows(row_ndx, num_rows_to_erase, prior_num_rows,
+                       broken_reciprocal_backlinks); // Throws
+
+    const bool fix_ndx_in_parent = true;
+    bool last_entry_removed =
+        m_subtable_map.adj_erase_rows<fix_ndx_in_parent>(row_ndx, num_rows_to_erase);
+    typedef _impl::TableFriend tf;
+    if (last_entry_removed)
+        tf::unbind_ptr(*m_table);
+}
+
+// Overriding virtual method of Column.
+inline void SubtableColumnBase::move_last_row_over(size_t row_ndx, size_t prior_num_rows,
+                                                   bool broken_reciprocal_backlinks)
+{
+    IntegerColumn::move_last_row_over(row_ndx, prior_num_rows, broken_reciprocal_backlinks); // Throws
+
+    const bool fix_ndx_in_parent = true;
+    size_t last_row_ndx = prior_num_rows - 1;
+    bool last_entry_removed =
+        m_subtable_map.adj_move_over<fix_ndx_in_parent>(last_row_ndx, row_ndx);
+    typedef _impl::TableFriend tf;
+    if (last_entry_removed)
+        tf::unbind_ptr(*m_table);
+}
+
+inline void SubtableColumnBase::clear(size_t, bool)
+{
+    discard_child_accessors();
+    clear_without_updating_index(); // Throws
+    // FIXME: This one is needed because
+    // IntegerColumn::clear_without_updating_index() forgets about the
+    // leaf type. A better solution should probably be sought after.
+    get_root_array()->set_type(Array::type_HasRefs);
+}
+
+inline void SubtableColumnBase::swap_rows(size_t row_ndx_1, size_t row_ndx_2)
+{
+    IntegerColumn::swap_rows(row_ndx_1, row_ndx_2); // Throws
+
+    const bool fix_ndx_in_parent = true;
+    m_subtable_map.adj_swap_rows<fix_ndx_in_parent>(row_ndx_1, row_ndx_2);
+}
+
+inline void SubtableColumnBase::mark(int type) noexcept
+{
+    if (type & mark_Recursive)
+        m_subtable_map.recursive_mark();
+}
+
+inline void SubtableColumnBase::refresh_accessor_tree(size_t col_ndx, const Spec& spec)
+{
+    IntegerColumn::refresh_accessor_tree(col_ndx, spec); // Throws
+    m_column_ndx = col_ndx;
+}
+
+inline void SubtableColumnBase::adj_acc_insert_rows(size_t row_ndx,
+                                                    size_t num_rows) noexcept
+{
+    // This function must assume no more than minimal consistency of the
+    // accessor hierarchy. This means in particular that it cannot access the
+    // underlying node structure. See AccessorConsistencyLevels.
+
+    const bool fix_ndx_in_parent = false;
+    m_subtable_map.adj_insert_rows<fix_ndx_in_parent>(row_ndx, num_rows);
+}
+
+inline void SubtableColumnBase::adj_acc_erase_row(size_t row_ndx) noexcept
+{
+    // This function must assume no more than minimal consistency of the
+    // accessor hierarchy. This means in particular that it cannot access the
+    // underlying node structure. See AccessorConsistencyLevels.
+
+    const bool fix_ndx_in_parent = false;
+    size_t num_rows_erased = 1;
+    bool last_entry_removed =
+        m_subtable_map.adj_erase_rows<fix_ndx_in_parent>(row_ndx, num_rows_erased);
+    typedef _impl::TableFriend tf;
+    if (last_entry_removed)
+        tf::unbind_ptr(*m_table);
+}
+
+inline void SubtableColumnBase::adj_acc_move_over(size_t from_row_ndx,
+                                                  size_t to_row_ndx) noexcept
+{
+    // This function must assume no more than minimal consistency of the
+    // accessor hierarchy. This means in particular that it cannot access the
+    // underlying node structure. See AccessorConsistencyLevels.
+
+    const bool fix_ndx_in_parent = false;
+    bool last_entry_removed =
+        m_subtable_map.adj_move_over<fix_ndx_in_parent>(from_row_ndx, to_row_ndx);
+    typedef _impl::TableFriend tf;
+    if (last_entry_removed)
+        tf::unbind_ptr(*m_table);
+}
+
+inline void SubtableColumnBase::adj_acc_clear_root_table() noexcept
+{
+    // This function must assume no more than minimal consistency of the
+    // accessor hierarchy. This means in particular that it cannot access the
+    // underlying node structure. See AccessorConsistencyLevels.
+
+    IntegerColumn::adj_acc_clear_root_table();
+    discard_child_accessors();
+}
+
+inline void SubtableColumnBase::adj_acc_swap_rows(size_t row_ndx_1, size_t row_ndx_2) noexcept
+{
+    const bool fix_ndx_in_parent = false;
+    m_subtable_map.adj_swap_rows<fix_ndx_in_parent>(row_ndx_1, row_ndx_2);
+}
+
+inline Table* SubtableColumnBase::get_subtable_accessor(size_t row_ndx) const noexcept
+{
+    // This function must assume no more than minimal consistency of the
+    // accessor hierarchy. This means in particular that it cannot access the
+    // underlying node structure. See AccessorConsistencyLevels.
+
+    Table* subtable = m_subtable_map.find(row_ndx);
+    return subtable;
+}
+
+inline void SubtableColumnBase::discard_subtable_accessor(size_t row_ndx) noexcept
+{
+    // This function must assume no more than minimal consistency of the
+    // accessor hierarchy. This means in particular that it cannot access the
+    // underlying node structure. See AccessorConsistencyLevels.
+
+    bool last_entry_removed = m_subtable_map.detach_and_remove(row_ndx);
+    typedef _impl::TableFriend tf;
+    if (last_entry_removed)
+        tf::unbind_ptr(*m_table);
+}
+
+inline void SubtableColumnBase::SubtableMap::add(size_t subtable_ndx, Table* table)
+{
+    SubtableEntry e;
+    e.m_subtable_ndx = subtable_ndx;
+    e.m_table        = table;
+    m_entries.push_back(e);
+}
+
+template<bool fix_ndx_in_parent>
+void SubtableColumnBase::SubtableMap::adj_insert_rows(size_t row_ndx, size_t num_rows_inserted) noexcept
+{
+    for (auto& entry : m_entries) {
+        if (entry.m_subtable_ndx >= row_ndx) {
+            entry.m_subtable_ndx += num_rows_inserted;
+            typedef _impl::TableFriend tf;
+            if (fix_ndx_in_parent)
+                tf::set_ndx_in_parent(*(entry.m_table), entry.m_subtable_ndx);
+        }
+    }
+}
+
+template<bool fix_ndx_in_parent>
+bool SubtableColumnBase::SubtableMap::adj_erase_rows(size_t row_ndx, size_t num_rows_erased) noexcept
+{
+    if (m_entries.empty())
+        return false;
+    typedef _impl::TableFriend tf;
+    auto end = m_entries.end();
+    auto i = m_entries.begin();
+    do {
+        if (i->m_subtable_ndx >= row_ndx + num_rows_erased) {
+            i->m_subtable_ndx -= num_rows_erased;
+            if (fix_ndx_in_parent)
+                tf::set_ndx_in_parent(*(i->m_table), i->m_subtable_ndx);
+        }
+        else if (i->m_subtable_ndx >= row_ndx) {
+            // Must hold a counted reference while detaching
+            TableRef table(i->m_table);
+            tf::detach(*table);
+            // Move last over
+            *i = *--end;
+            continue;
+        }
+        ++i;
+    }
+    while (i != end);
+    m_entries.erase(end, m_entries.end());
+    return m_entries.empty();
+}
+
+
+template<bool fix_ndx_in_parent>
+bool SubtableColumnBase::SubtableMap::adj_move_over(size_t from_row_ndx,
+                                                    size_t to_row_ndx) noexcept
+{
+    typedef _impl::TableFriend tf;
+
+    size_t i = 0, n = m_entries.size();
+    // We return true if, and only if we remove the last entry in the map.  We
+    // need special handling for the case, where the set of entries are already
+    // empty, otherwise the final return statement would return true in this
+    // case, even though we didn't actually remove an entry.
+    if (n == 0)
+        return false;
+
+    while (i < n) {
+        SubtableEntry& e = m_entries[i];
+        if (REALM_UNLIKELY(e.m_subtable_ndx == to_row_ndx)) {
+            // Must hold a counted reference while detaching
+            TableRef table(e.m_table);
+            tf::detach(*table);
+            // Delete entry by moving last over (faster and avoids invalidating
+            // iterators)
+            e = m_entries[--n];
+            m_entries.pop_back();
+        }
+        else {
+            if (REALM_UNLIKELY(e.m_subtable_ndx == from_row_ndx)) {
+                e.m_subtable_ndx = to_row_ndx;
+                if (fix_ndx_in_parent)
+                    tf::set_ndx_in_parent(*(e.m_table), e.m_subtable_ndx);
+            }
+            ++i;
+        }
+    }
+    return m_entries.empty();
+}
+
+template<bool fix_ndx_in_parent>
+void SubtableColumnBase::SubtableMap::adj_swap_rows(size_t row_ndx_1, size_t row_ndx_2) noexcept
+{
+    using tf = _impl::TableFriend;
+    for (auto& entry : m_entries) {
+        if (REALM_UNLIKELY(entry.m_subtable_ndx == row_ndx_1)) {
+            entry.m_subtable_ndx = row_ndx_2;
+            if (fix_ndx_in_parent)
+                tf::set_ndx_in_parent(*(entry.m_table), entry.m_subtable_ndx);
+        }
+        else if (REALM_UNLIKELY(entry.m_subtable_ndx == row_ndx_2)) {
+            entry.m_subtable_ndx = row_ndx_1;
+            if (fix_ndx_in_parent)
+                tf::set_ndx_in_parent(*(entry.m_table), entry.m_subtable_ndx);
+        }
+    }
+}
+
+inline SubtableColumnBase::SubtableColumnBase(Allocator& alloc, ref_type ref,
+                                              Table* table, size_t column_ndx):
+    IntegerColumn(alloc, ref), // Throws
+    m_table(table),
+    m_column_ndx(column_ndx)
+{
+}
+
+inline void SubtableColumnBase::update_child_ref(size_t child_ndx, ref_type new_ref)
+{
+    set(child_ndx, new_ref);
+}
+
+inline ref_type SubtableColumnBase::get_child_ref(size_t child_ndx) const noexcept
+{
+    return get_as_ref(child_ndx);
+}
+
+inline void SubtableColumnBase::discard_child_accessors() noexcept
+{
+    bool last_entry_removed = m_subtable_map.detach_and_remove_all();
+    if (last_entry_removed && m_table)
+        _impl::TableFriend::unbind_ptr(*m_table);
+}
+
+inline SubtableColumnBase::~SubtableColumnBase() noexcept
+{
+    discard_child_accessors();
+}
+
+inline bool SubtableColumnBase::compare_subtable_rows(const Table& a, const Table& b)
+{
+    return _impl::TableFriend::compare_rows(a,b);
+}
+
+inline ref_type SubtableColumnBase::clone_table_columns(const Table* t)
+{
+    return _impl::TableFriend::clone_columns(*t, get_root_array()->get_alloc());
+}
+
+inline ref_type SubtableColumnBase::create(Allocator& alloc, size_t size)
+{
+    return IntegerColumn::create(alloc, Array::type_HasRefs, size); // Throws
+}
+
+inline size_t* SubtableColumnBase::record_subtable_path(size_t* begin, size_t* end) noexcept
+{
+    if (end == begin)
+        return 0; // Error, not enough space in buffer
+    *begin++ = m_column_ndx;
+    if (end == begin)
+        return 0; // Error, not enough space in buffer
+    return _impl::TableFriend::record_subtable_path(*m_table, begin, end);
+}
+
+inline void SubtableColumnBase::update_table_accessors(const size_t* col_path_begin,
+                                                       const size_t* col_path_end,
+                                                       _impl::TableFriend::AccessorUpdater& updater)
+{
+    // This function must assume no more than minimal consistency of the
+    // accessor hierarchy. This means in particular that it cannot access the
+    // underlying node structure. See AccessorConsistencyLevels.
+
+    m_subtable_map.update_accessors(col_path_begin, col_path_end, updater); // Throws
+}
+
+inline void SubtableColumnBase::do_insert(size_t row_ndx, int_fast64_t value, size_t num_rows)
+{
+    IntegerColumn::insert_without_updating_index(row_ndx, value, num_rows); // Throws
+    bool is_append = row_ndx == realm::npos;
+    if (!is_append) {
+        const bool fix_ndx_in_parent = true;
+        m_subtable_map.adj_insert_rows<fix_ndx_in_parent>(row_ndx, num_rows);
+    }
+}
+
+
+inline SubtableColumn::SubtableColumn(Allocator& alloc, ref_type ref,
+                                      Table* table, size_t column_ndx):
+    SubtableColumnBase(alloc, ref, table, column_ndx),
+    m_subspec_ndx(realm::npos)
+{
+}
+
+inline const Table* SubtableColumn::get_subtable_ptr(size_t subtable_ndx) const
+{
+    return const_cast<SubtableColumn*>(this)->get_subtable_ptr(subtable_ndx);
+}
+
+inline void SubtableColumn::refresh_accessor_tree(size_t col_ndx, const Spec& spec)
+{
+    SubtableColumnBase::refresh_accessor_tree(col_ndx, spec); // Throws
+    m_subspec_ndx = spec.get_subspec_ndx(col_ndx);
+    m_subtable_map.refresh_accessor_tree(m_subspec_ndx); // Throws
+}
+
+inline size_t SubtableColumn::get_subspec_ndx() const noexcept
+{
+    if (REALM_UNLIKELY(m_subspec_ndx == realm::npos)) {
+        typedef _impl::TableFriend tf;
+        const Spec& spec = tf::get_spec(*m_table);
+        m_subspec_ndx = spec.get_subspec_ndx(m_column_ndx);
+    }
+    return m_subspec_ndx;
+}
+
+
+} // namespace realm
+
+#endif // REALM_COLUMN_TABLE_HPP
diff --git a/Pods/Realm/include/core/realm/column_timestamp.hpp b/Pods/Realm/include/core/realm/column_timestamp.hpp
new file mode 100644
index 0000000..8a56a2e
--- /dev/null
+++ b/Pods/Realm/include/core/realm/column_timestamp.hpp
@@ -0,0 +1,144 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_COLUMN_TIMESTAMP_HPP
+#define REALM_COLUMN_TIMESTAMP_HPP
+
+#include <realm/column.hpp>
+#include <realm/timestamp.hpp>
+
+namespace realm {
+
+// Inherits from ColumnTemplate to get a compare_values() that can be called without knowing the
+// column type
+class TimestampColumn : public ColumnBaseSimple, public ColumnTemplate<Timestamp> {
+public:
+    TimestampColumn(Allocator& alloc, ref_type ref);
+    ~TimestampColumn() noexcept override;
+
+    static ref_type create(Allocator& alloc, size_t size, bool nullable);
+
+    /// Get the number of entries in this column. This operation is relatively
+    /// slow.
+    size_t size() const noexcept override;
+    /// Whether or not this column is nullable.
+    bool is_nullable() const noexcept override;
+    /// Whether or not the value at \a row_ndx is NULL. If the column is not
+    /// nullable, always returns false.
+    bool is_null(size_t row_ndx) const noexcept override;
+    /// Sets the value at \a row_ndx to be NULL.
+    /// \throw LogicError Thrown if this column is not nullable.
+    void set_null(size_t row_ndx) override;
+    void insert_rows(size_t row_ndx, size_t num_rows_to_insert, size_t prior_num_rows, bool nullable) override;
+    void erase_rows(size_t row_ndx, size_t num_rows_to_erase, size_t prior_num_rows,
+                    bool broken_reciprocal_backlinks) override;
+    void move_last_row_over(size_t row_ndx, size_t prior_num_rows,
+                            bool broken_reciprocal_backlinks) override;
+    void clear(size_t num_rows, bool broken_reciprocal_backlinks) override;
+    void swap_rows(size_t row_ndx_1, size_t row_ndx_2) override;
+    void destroy() noexcept override;
+
+    bool has_search_index() const noexcept final { return bool(m_search_index); }
+    StringIndex* get_search_index() noexcept final { return m_search_index.get(); }
+    StringIndex* get_search_index() const noexcept final { return m_search_index.get(); }
+    void destroy_search_index() noexcept override;
+    void set_search_index_ref(ref_type ref, ArrayParent* parent, size_t ndx_in_parent,
+            bool allow_duplicate_values) final;
+    void populate_search_index();
+    StringIndex* create_search_index() override;
+    bool supports_search_index() const noexcept final { return true; }
+    
+    StringData get_index_data(size_t, StringIndex::StringConversionBuffer& buffer) const noexcept override;
+    ref_type write(size_t slice_offset, size_t slice_size, size_t table_size, _impl::OutputStream&) const override;
+    void update_from_parent(size_t old_baseline) noexcept override;
+    void set_ndx_in_parent(size_t ndx) noexcept override;
+    void refresh_accessor_tree(size_t new_col_ndx, const Spec&) override;
+#ifdef REALM_DEBUG
+    void verify() const override;
+    void to_dot(std::ostream&, StringData title = StringData()) const override;
+    void do_dump_node_structure(std::ostream&, int level) const override;
+    void leaf_to_dot(MemRef, ArrayParent*, size_t ndx_in_parent, std::ostream&) const override;
+#endif
+    void add(const Timestamp& ts = Timestamp{});
+    Timestamp get(size_t row_ndx) const noexcept;
+    Timestamp get_val(size_t row_ndx) const noexcept override { return get(row_ndx); }
+    void set(size_t row_ndx, const Timestamp& ts);
+    bool compare(const TimestampColumn& c) const noexcept;
+
+    Timestamp maximum(size_t* result_index) const;
+    Timestamp minimum(size_t* result_index) const;
+    size_t count(Timestamp) const;
+    void erase(size_t row_ndx, bool is_last);
+
+    template <class Condition>
+    size_t find(Timestamp value, size_t begin, size_t end) const noexcept
+    {
+        // FIXME: Here we can do all sorts of clever optimizations. Use bithack-search on seconds, then for each match check
+        // nanoseconds, etc, etc, etc. Lots of possibilities. Below code is naive and slow but works.
+
+        Condition cond;
+        for (size_t t = begin; t < end; t++) {
+            Timestamp ts = get(t);
+            if (cond(ts, value, ts.is_null(), value.is_null()))
+                return t;
+        }
+        return npos;
+    }
+
+    typedef Timestamp value_type;
+
+private:
+    std::unique_ptr<BpTree<util::Optional<int64_t>>> m_seconds;
+    std::unique_ptr<BpTree<int64_t>> m_nanoseconds;
+
+    std::unique_ptr<StringIndex> m_search_index;
+
+    template<class BT>
+    class CreateHandler;
+
+    template <class Condition>
+    Timestamp minmax(size_t* result_index) const noexcept
+    {
+        // Condition is realm::Greater for maximum and realm::Less for minimum.
+
+        if (size() == 0) {
+            if (result_index)
+                *result_index = npos;
+            return Timestamp(null{});
+        }
+
+        Timestamp best = get(0);
+        size_t best_index = 0;
+
+        for (size_t i = 1; i < size(); ++i) {
+            Timestamp candidate = get(i);
+            if (Condition()(candidate, best, candidate.is_null(), best.is_null())) {
+                best = candidate;
+                best_index = i;
+            }
+        }
+        if (result_index)
+            *result_index = best_index;
+        return best;
+    }
+};
+
+} // namespace realm
+
+#endif // REALM_COLUMN_TIMESTAMP_HPP
diff --git a/Pods/Realm/include/core/realm/column_tpl.hpp b/Pods/Realm/include/core/realm/column_tpl.hpp
new file mode 100644
index 0000000..8710a94
--- /dev/null
+++ b/Pods/Realm/include/core/realm/column_tpl.hpp
@@ -0,0 +1,141 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_COLUMN_TPL_HPP
+#define REALM_COLUMN_TPL_HPP
+
+#include <cstdlib>
+
+#include <realm/util/features.h>
+#include <realm/array.hpp>
+#include <realm/array_basic.hpp>
+
+namespace realm {
+
+template<class T, class cond>
+class FloatDoubleNode;
+template<class ColType, class Cond>
+class IntegerNode;
+template<class T>
+class SequentialGetter;
+
+template<class cond, class T>
+struct ColumnTypeTraits2;
+
+template<class cond>
+struct ColumnTypeTraits2<cond, int64_t> {
+    typedef IntegerColumn column_type;
+    typedef ArrayInteger array_type;
+};
+template<class cond>
+struct ColumnTypeTraits2<cond, bool> {
+    typedef IntegerColumn column_type;
+    typedef ArrayInteger array_type;
+};
+template<class cond>
+struct ColumnTypeTraits2<cond, float> {
+    typedef FloatColumn column_type;
+    typedef ArrayFloat array_type;
+};
+template<class cond>
+struct ColumnTypeTraits2<cond, double> {
+    typedef DoubleColumn column_type;
+    typedef ArrayDouble array_type;
+};
+
+
+namespace _impl {
+
+template<class ColType>
+struct FindInLeaf {
+    using LeafType = typename ColType::LeafType;
+
+    template<Action action, class Condition, class T, class R>
+    static bool find(const LeafType& leaf, T target, size_t local_start, size_t local_end, size_t leaf_start, QueryState<R>& state)
+    {
+        Condition cond;
+        bool cont = true;
+        // todo, make an additional loop with hard coded `false` instead of is_null(v) for non-nullable columns
+        bool null_target = null::is_null_float(target);
+        for (size_t local_index = local_start; cont && local_index < local_end; local_index++) {
+            auto v = leaf.get(local_index);
+            if (cond(v, target, null::is_null_float(v), null_target)) {
+                cont = state.template match<action, false>(leaf_start + local_index , 0, static_cast<R>(v));
+            }
+        }
+        return cont;
+    }
+};
+
+template<>
+struct FindInLeaf<IntegerColumn> {
+    using LeafType = IntegerColumn::LeafType;
+
+    template<Action action, class Condition, class T, class R>
+    static bool find(const LeafType& leaf, T target, size_t local_start, size_t local_end, size_t leaf_start, QueryState<R>& state)
+    {
+        const int c = Condition::condition;
+        return leaf.find(c, action, target, local_start, local_end, leaf_start, &state);
+    }
+};
+
+template<>
+struct FindInLeaf<IntNullColumn> {
+    using LeafType = IntNullColumn::LeafType;
+
+    template<Action action, class Condition, class T, class R>
+    static bool find(const LeafType& leaf, T target, size_t local_start, size_t local_end, size_t leaf_start, QueryState<R>& state)
+    {
+        constexpr int cond = Condition::condition;
+        return leaf.find(cond, action, target, local_start, local_end, leaf_start, &state);
+    }
+};
+
+} // namespace _impl
+
+template<class T, class R, Action action, class Condition, class ColType>
+R aggregate(const ColType& column, T target, size_t start, size_t end,
+            size_t limit, size_t* return_ndx)
+{
+    if (end == npos)
+        end = column.size();
+
+    QueryState<R> state;
+    state.init(action, nullptr, limit);
+    SequentialGetter<ColType> sg { &column };
+
+    bool cont = true;
+    for (size_t s = start; cont && s < end; ) {
+        sg.cache_next(s);
+        size_t start2 = s - sg.m_leaf_start;
+        size_t end2 = sg.local_end(end);
+        cont = _impl::FindInLeaf<ColType>::template find<action, Condition>(*sg.m_leaf_ptr, target, start2, end2, sg.m_leaf_start, state);
+        s = sg.m_leaf_start + end2;
+    }
+
+    if (return_ndx)
+        *return_ndx = action == act_Sum ? state.m_match_count : state.m_minmax_index;
+
+    return state.m_state;
+}
+
+
+} // namespace realm
+
+#endif // REALM_COLUMN_TPL_HPP
diff --git a/Pods/Realm/include/core/realm/column_type.hpp b/Pods/Realm/include/core/realm/column_type.hpp
new file mode 100644
index 0000000..9618113
--- /dev/null
+++ b/Pods/Realm/include/core/realm/column_type.hpp
@@ -0,0 +1,71 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_COLUMN_TYPE_HPP
+#define REALM_COLUMN_TYPE_HPP
+
+namespace realm {
+
+
+// Note: Enumeration value assignments must be kept in sync with
+// <realm/data_type.hpp>.
+enum ColumnType {
+    // Column types
+    col_type_Int         =  0,
+    col_type_Bool        =  1,
+    col_type_String      =  2,
+    col_type_StringEnum  =  3, // double refs
+    col_type_Binary      =  4,
+    col_type_Table       =  5,
+    col_type_Mixed       =  6,
+    col_type_OldDateTime =  7,
+    col_type_Timestamp   =  8,
+    col_type_Float       =  9,
+    col_type_Double      = 10,
+    col_type_Reserved4   = 11, // Decimal
+    col_type_Link        = 12,
+    col_type_LinkList    = 13,
+    col_type_BackLink    = 14
+};
+
+
+// Column attributes can be combined using bitwise or.
+enum ColumnAttr {
+    col_attr_None = 0,
+    col_attr_Indexed = 1,
+
+    /// Specifies that this column forms a unique constraint. It requires
+    /// `col_attr_Indexed`.
+    col_attr_Unique = 2,
+
+    /// Reserved for future use.
+    col_attr_Reserved = 4,
+
+    /// Specifies that the links of this column are strong, not weak. Applies
+    /// only to link columns (`type_Link` and `type_LinkList`).
+    col_attr_StrongLinks = 8,
+
+    /// Specifies that elements in the column can be null.
+    col_attr_Nullable = 16
+};
+
+
+} // namespace realm
+
+#endif // REALM_COLUMN_TYPE_HPP
diff --git a/Pods/Realm/include/core/realm/column_type_traits.hpp b/Pods/Realm/include/core/realm/column_type_traits.hpp
new file mode 100644
index 0000000..d03fd33
--- /dev/null
+++ b/Pods/Realm/include/core/realm/column_type_traits.hpp
@@ -0,0 +1,177 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+
+#ifndef REALM_COLUMN_TYPE_TRAITS_HPP
+#define REALM_COLUMN_TYPE_TRAITS_HPP
+
+#include <realm/column_fwd.hpp>
+#include <realm/column_type.hpp>
+#include <realm/data_type.hpp>
+
+namespace realm {
+
+class OldDateTime;
+class ArrayBinary;
+class ArrayInteger;
+class ArrayIntNull;
+template <class> class BasicArray;
+
+template<class T>
+struct ColumnTypeTraits;
+
+template<>
+struct ColumnTypeTraits<int64_t> {
+    using column_type = Column<int64_t>;
+    using leaf_type = ArrayInteger;
+    using sum_type = int64_t;
+    using minmax_type = int64_t;
+    static const DataType id = type_Int;
+    static const ColumnType column_id = col_type_Int;
+    static const ColumnType real_column_type = col_type_Int;
+};
+
+template<>
+struct ColumnTypeTraits<util::Optional<int64_t>> {
+    using column_type = Column<util::Optional<int64_t>>;
+    using leaf_type = ArrayIntNull;
+    using sum_type = int64_t;
+    using minmax_type = int64_t;
+    static const DataType id = type_Int;
+    static const ColumnType column_id = col_type_Int;
+    static const ColumnType real_column_type = col_type_Int;
+};
+
+template<>
+struct ColumnTypeTraits<bool> :
+    ColumnTypeTraits<int64_t>
+{
+    static const DataType id = type_Bool;
+    static const ColumnType column_id = col_type_Bool;
+};
+
+template<>
+struct ColumnTypeTraits<util::Optional<bool>> :
+    ColumnTypeTraits<util::Optional<int64_t>>
+{
+    static const DataType id = type_Bool;
+    static const ColumnType column_id = col_type_Bool;
+};
+
+template<>
+struct ColumnTypeTraits<float> {
+    using column_type = FloatColumn;
+    using leaf_type = BasicArray<float>;
+    using sum_type = double;
+    using minmax_type = float;
+    static const DataType id = type_Float;
+    static const ColumnType column_id = col_type_Float;
+    static const ColumnType real_column_type = col_type_Float;
+};
+
+template<>
+struct ColumnTypeTraits<double> {
+    using column_type = DoubleColumn;
+    using leaf_type = BasicArray<double>;
+    using sum_type = double;
+    using minmax_type = double;
+    static const DataType id = type_Double;
+    static const ColumnType column_id = col_type_Double;
+    static const ColumnType real_column_type = col_type_Double;
+};
+
+template<>
+struct ColumnTypeTraits<OldDateTime> :
+    ColumnTypeTraits<int64_t>
+{
+    static const DataType id = type_OldDateTime;
+    static const ColumnType column_id = col_type_OldDateTime;
+};
+
+template<>
+struct ColumnTypeTraits<util::Optional<OldDateTime>> :
+    ColumnTypeTraits<util::Optional<int64_t>>
+{
+    static const DataType id = type_OldDateTime;
+    static const ColumnType column_id = col_type_OldDateTime;
+};
+
+template<>
+struct ColumnTypeTraits<StringData> {
+    using column_type = StringEnumColumn;
+    using leaf_type = ArrayInteger;
+    using sum_type = int64_t;
+    static const DataType id = type_String;
+    static const ColumnType column_id = col_type_String;
+    static const ColumnType real_column_type = col_type_String;
+};
+
+template<>
+struct ColumnTypeTraits<BinaryData> {
+    using column_type = BinaryColumn;
+    using leaf_type = ArrayBinary;
+    static const DataType id = type_Binary;
+    static const ColumnType column_id = col_type_Binary;
+    static const ColumnType real_column_type = col_type_Binary;
+};
+
+template<DataType, bool Nullable>
+struct GetColumnType;
+template<>
+struct GetColumnType<type_Int, false>
+{
+    using type = IntegerColumn;
+};
+template<>
+struct GetColumnType<type_Int, true>
+{
+    using type = IntNullColumn;
+};
+template<bool N>
+struct GetColumnType<type_Float, N> {
+    // FIXME: Null definition
+    using type = FloatColumn;
+};
+template<bool N>
+struct GetColumnType<type_Double, N> {
+    // FIXME: Null definition
+    using type = DoubleColumn;
+};
+
+// Only purpose is to return 'double' if and only if source column (T) is float and you're doing a sum (A)
+template<class T, Action A>
+struct ColumnTypeTraitsSum {
+    typedef T sum_type;
+};
+
+template<>
+struct ColumnTypeTraitsSum<float, act_Sum>
+{
+    typedef double sum_type;
+};
+
+template<Action A>
+struct ColumnTypeTraitsSum<util::Optional<int64_t>, A>
+{
+    using sum_type = int64_t;
+};
+
+}
+
+#endif // REALM_COLUMN_TYPE_TRAITS_HPP
diff --git a/Pods/Realm/include/core/realm/commit_log.hpp b/Pods/Realm/include/core/realm/commit_log.hpp
new file mode 100644
index 0000000..2c92b6a
--- /dev/null
+++ b/Pods/Realm/include/core/realm/commit_log.hpp
@@ -0,0 +1,53 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_COMMIT_LOG_HPP
+#define REALM_COMMIT_LOG_HPP
+
+#include <stdexcept>
+#include <string>
+
+#include <realm/binary_data.hpp>
+#include <realm/replication.hpp>
+
+
+namespace realm {
+
+// FIXME: Why is this exception class exposed?
+class LogFileError: public std::runtime_error {
+public:
+    LogFileError(const std::string& file_name):
+        std::runtime_error(file_name)
+    {
+    }
+};
+
+/// Create a writelog collector and associate it with a filepath. You'll need
+/// one writelog collector for each shared group. Commits from writelog
+/// collectors for a specific filepath may later be obtained through other
+/// writelog collectors associated with said filepath.  The caller assumes
+/// ownership of the writelog collector and must destroy it, but only AFTER
+/// destruction of the shared group using it.
+std::unique_ptr<Replication>
+make_client_history(const std::string& path, const char* encryption_key = nullptr);
+
+} // namespace realm
+
+
+#endif // REALM_COMMIT_LOG_HPP
diff --git a/Pods/Realm/include/core/realm/data_type.hpp b/Pods/Realm/include/core/realm/data_type.hpp
new file mode 100644
index 0000000..37ff60f
--- /dev/null
+++ b/Pods/Realm/include/core/realm/data_type.hpp
@@ -0,0 +1,52 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_DATA_TYPE_HPP
+#define REALM_DATA_TYPE_HPP
+
+namespace realm {
+
+// Note: Value assignments must be kept in sync with <realm/column_type.h>
+// Note: Value assignments must be kept in sync with <realm/c/data_type.h>
+// Note: Value assignments must be kept in sync with <realm/objc/type.h>
+// Note: Value assignments must be kept in sync with "com/realm/ColumnType.java"
+enum DataType {
+    type_Int         =  0,
+    type_Bool        =  1,
+    type_Float       =  9,
+    type_Double      = 10,
+    type_String      =  2,
+    type_Binary      =  4,
+    type_OldDateTime =  7,
+    type_Timestamp   =  8,
+    type_Table       =  5,
+    type_Mixed       =  6,
+    type_Link        = 12,
+    type_LinkList    = 13
+};
+
+/// See Descriptor::set_link_type().
+enum LinkType {
+    link_Strong,
+    link_Weak
+};
+
+} // namespace realm
+
+#endif // REALM_DATA_TYPE_HPP
diff --git a/Pods/Realm/include/core/realm/descriptor.hpp b/Pods/Realm/include/core/realm/descriptor.hpp
new file mode 100644
index 0000000..1b431cd
--- /dev/null
+++ b/Pods/Realm/include/core/realm/descriptor.hpp
@@ -0,0 +1,830 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_DESCRIPTOR_HPP
+#define REALM_DESCRIPTOR_HPP
+
+#include <cstddef>
+
+#include <realm/util/assert.hpp>
+#include <realm/descriptor_fwd.hpp>
+#include <realm/table.hpp>
+
+
+namespace realm {
+
+namespace _impl { class DescriptorFriend; }
+
+
+/// Accessor for table type descriptors.
+///
+/// A table type descriptor is an entity that specifies the dynamic
+/// type of a Realm table. Objects of this class are accessors
+/// through which the descriptor can be inspected and
+/// changed. Accessors can become detached, see is_attached() for more
+/// on this. The descriptor itself is stored inside the database file,
+/// or elsewhere in case of a free-standing table or a table in a
+/// free-standing group.
+///
+/// The dynamic type consists first, and foremost of an ordered list
+/// of column descriptors. Each column descriptor specifies the name
+/// and type of the column.
+///
+/// When a table has a subtable column, every cell in than column
+/// contains a subtable. All those subtables have the same dynamic
+/// type, and therefore have a shared descriptor. See is_root() for
+/// more on this.
+///
+/// The Table class contains convenience methods, such as
+/// Table::get_column_count() and Table::add_column(), that allow you
+/// to inspect and change the dynamic type of simple tables without
+/// resorting to use of descriptors. For example, the following two
+/// statements have the same effect:
+///
+///     table->add_column(type, name);
+///     table->get_descriptor()->add_column(type, name);
+///
+/// Note, however, that this equivalence holds only as long as no
+/// shared subtable descriptors are involved.
+///
+/// \sa Table::get_descriptor()
+class Descriptor {
+public:
+    /// Get the number of columns in the associated tables.
+    size_t get_column_count() const noexcept;
+
+    /// Get the type of the column at the specified index.
+    ///
+    /// The consequences of specifying a column index that is out of
+    /// range, are undefined.
+    DataType get_column_type(size_t column_ndx) const noexcept;
+
+    /// Get the name of the column at the specified index.
+    ///
+    /// The consequences of specifying a column index that is out of
+    /// range, are undefined.
+    StringData get_column_name(size_t column_ndx) const noexcept;
+
+    /// Search for a column with the specified name.
+    ///
+    /// This function finds the first column with the specified name,
+    /// and returns its index. If there are no such columns, it
+    /// returns `not_found`.
+    size_t get_column_index(StringData name) const noexcept;
+
+    /// Get the index of the column to which links in the column at the specified
+    /// index refer.
+    ///
+    /// The consequences of specifying a column index that is out of
+    /// range, are undefined.
+    ///
+    /// The consequences of specifying a column index that does not refer
+    /// to a link column, are undefined.
+    size_t get_column_link_target(size_t column_ndx) const noexcept;
+
+    /// Get whether or not the specified column is nullable.
+    ///
+    /// The consequences of specifying a column index that is out of
+    /// range, are undefined.
+    bool is_nullable(size_t column_ndx) const noexcept;
+
+    //@{
+
+    /// add_column() and add_column_link() are a shorthands for calling
+    /// insert_column() and insert_column_link(), respectively, with a column
+    /// index equal to the original number of columns. The returned value is
+    /// that column index.
+    ///
+    /// insert_column() inserts a new column into all the tables associated with
+    /// this descriptor. If any of the tables are not empty, the new column will
+    /// be filled with the default value associated with the specified data
+    /// type. This function cannot be used to insert link-type columns. For
+    /// that, you have to use insert_column_link() instead.
+    ///
+    /// This function modifies the dynamic type of all the tables that
+    /// share this descriptor. It does this by inserting a new column
+    /// with the specified name and type into the descriptor at the
+    /// specified index, and into each of the tables that share this
+    /// descriptor.
+    ///
+    /// insert_column_link() is like insert_column(), but inserts a link-type
+    /// column to a group-level table. It is not possible to add link-type
+    /// columns to tables that are not group-level tables. This functions must
+    /// be used in place of insert_column() when the column type is `type_Link`
+    /// or `type_LinkList`. A link-type column is associated with a particular
+    /// target table. All links in a link-type column refer to rows in the
+    /// target table of that column. The target table must also be a group-level
+    /// table, and it must belong to the same group as the origin table.
+    ///
+    /// \param name Name of new column. All strings are valid column names as
+    /// long as they are valid UTF-8 encodings and the number of bytes does not
+    /// exceed `max_column_name_length`. An attempt to add a column with a name
+    /// that is longer than `max_column_name_length` will cause an exception to
+    /// be thrown.
+    ///
+    /// \param subdesc If a non-null pointer is passed, and the
+    /// specified type is `type_Table`, then this function
+    /// automatically retrieves the descriptor associated with the new
+    /// subtable column, and stores a reference to its accessor in
+    /// `*subdesc`.
+    ///
+    /// \param col_ndx Insert the new column at this index. Preexisting columns
+    /// at indexes equal to, or greater than `col_ndx` will be shifted to the
+    /// next higher index. It is an error to specify an index that is greater
+    /// than the number of columns prior to the insertion.
+    ///
+    /// \param link_type See set_link_type().
+    ///
+    /// \sa Table::add_column()
+    /// \sa Table::insert_column()
+    /// \sa Table::add_column_link()
+    /// \sa Table::insert_column_link()
+    /// \sa is_root()
+
+    static const size_t max_column_name_length = 63;
+
+    size_t add_column(DataType type, StringData name, DescriptorRef* subdesc = nullptr, bool nullable = false);
+
+    void insert_column(size_t col_ndx, DataType type, StringData name,
+                       DescriptorRef* subdesc = nullptr, bool nullable = false);
+
+    size_t add_column_link(DataType type, StringData name, Table& target,
+                                LinkType = link_Weak);
+    void insert_column_link(size_t col_ndx, DataType type, StringData name, Table& target,
+                            LinkType = link_Weak);
+    //@}
+
+    /// Remove the specified column from each of the associated
+    /// tables. If the removed column is the only column in the
+    /// descriptor, then the table size will drop to zero for all
+    /// tables that were not already empty.
+    ///
+    /// This function modifies the dynamic type of all the tables that
+    /// share this descriptor. It does this by removing the column at
+    /// the specified index from the descriptor, and from each of the
+    /// tables that share this descriptor. The consequences of
+    /// specifying a column index that is out of range, are undefined.
+    ///
+    /// If the removed column was a subtable column, then the
+    /// associated descriptor accessor will be detached, if it
+    /// exists. This function will also detach all accessors of
+    /// subtables of the root table. Only the accessor of the root
+    /// table will remain attached. The root table is the table
+    /// associated with the root descriptor.
+    ///
+    /// \param col_ndx The index of the column to be removed. It is an error to
+    /// specify an index that is greater than, or equal to the number of
+    /// columns.
+    ///
+    /// \sa is_root()
+    /// \sa Table::remove_column()
+    void remove_column(size_t col_ndx);
+
+    /// Rename the specified column.
+    ///
+    /// This function modifies the dynamic type of all the tables that
+    /// share this descriptor. The consequences of specifying a column
+    /// index that is out of range, are undefined.
+    ///
+    /// This function will detach all accessors of subtables of the
+    /// root table. Only the accessor of the root table will remain
+    /// attached. The root table is the table associated with the root
+    /// descriptor.
+    ///
+    /// \param col_ndx The index of the column to be renamed. It is an error to
+    /// specify an index that is greater than, or equal to the number of
+    /// columns.
+    ///
+    /// \sa is_root()
+    /// \sa Table::rename_column()
+    void rename_column(size_t col_ndx, StringData new_name);
+
+    /// There are two kinds of links, 'weak' and 'strong'. A strong link is one
+    /// that implies ownership, i.e., that the origin row (parent) owns the
+    /// target row (child). Simply stated, this means that when the origin row
+    /// (parent) is removed, so is the target row (child). If there are multiple
+    /// strong links to a target row, the origin rows share ownership, and the
+    /// target row is removed when the last owner disappears. Weak links do not
+    /// imply ownership, and will be nullified or removed when the target row
+    /// disappears.
+    ///
+    /// To put this in precise terms; when a strong link is broken, and the
+    /// target row has no other strong links to it, the target row is removed. A
+    /// row that is implicitly removed in this way, is said to be
+    /// *cascade-removed*. When a weak link is broken, nothing is
+    /// cascade-removed.
+    ///
+    /// A link is considered broken if
+    ///
+    ///  - the link is nullified, removed, or replaced by a different link
+    ///    (Row::nullify_link(), Row::set_link(), LinkView::remove_link(),
+    ///    LinkView::set_link(), LinkView::clear()), or if
+    ///
+    ///  - the origin row is explicitly removed (Row::move_last_over(),
+    ///    Table::clear()), or if
+    ///
+    ///  - the origin row is cascade-removed, or if
+    ///
+    ///  - the origin column is removed from the table (Table::remove_column()),
+    ///    or if
+    ///
+    ///  - the origin table is removed from the group.
+    ///
+    /// Note that a link is *not* considered broken when it is replaced by a
+    /// link to the same target row. I.e., no no rows will be cascade-removed
+    /// due to such an operation.
+    ///
+    /// When a row is explicitly removed (such as by Table::move_last_over()),
+    /// all links to it are automatically removed or nullified. For single link
+    /// columns (type_Link), links to the removed row are nullified. For link
+    /// list columns (type_LinkList), links to the removed row are removed from
+    /// the list.
+    ///
+    /// When a row is cascade-removed there can no longer be any strong links to it,
+    /// but if there are any weak links, they will be removed or nullified.
+    ///
+    /// It is important to understand that this cascade-removal scheme is too
+    /// simplistic to enable detection and removal of orphaned link-cycles. In
+    /// this respect, it suffers from the same limitations as a reference
+    /// counting scheme generally does.
+    ///
+    /// It is also important to understand, that the possible presence of a link
+    /// cycle can cause a row to be cascade-removed as a consequence of being
+    /// modified. This happens, for example, if two rows, A and B, have strong
+    /// links to each other, and there are no other strong links to either of
+    /// them. In this case, if A->B is changed to A->C, then both A and B will
+    /// be cascade-removed. This can lead to obscure bugs in some applications,
+    /// such as in the following case:
+    ///
+    ///     table.set_link(col_ndx_1, row_ndx, ...);
+    ///     table.set_int(col_ndx_2, row_ndx, ...); // Oops, `row_ndx` may no longer refer to the same row
+    ///
+    /// To be safe, applications, that may encounter cycles, are advised to
+    /// adopt the following pattern:
+    ///
+    ///     Row row = table[row_ndx];
+    ///     row.set_link(col_ndx_1, ...);
+    ///     if (row)
+    ///         row.set_int(col_ndx_2, ...); // Ok, because we check whether the row has disappeared
+    ///
+    /// \param col_ndx The index of the link column (`type_Link` or
+    /// `type_LinkList`) to be modified. It is an error to specify an index that
+    /// is greater than, or equal to the number of columns, or to specify the
+    /// index of a non-link column.
+    void set_link_type(size_t col_ndx, LinkType);
+
+    //@{
+    /// Get the descriptor for the specified subtable column.
+    ///
+    /// This function provides access to the shared subtable
+    /// descriptor for the subtables in the specified column. The
+    /// specified column must be a column whose type is 'table'. The
+    /// consequences of specifying a column of a different type, or
+    /// specifying an index that is out of range, are undefined.
+    ///
+    /// Note that this function cannot be used with 'mixed' columns,
+    /// since subtables of that kind have independent dynamic types,
+    /// and therefore, have independent descriptors. You can only get
+    /// access to the descriptor of a subtable in a mixed column by
+    /// first getting access to the subtable itself.
+    ///
+    /// \sa is_root()
+    DescriptorRef get_subdescriptor(size_t column_ndx);
+    ConstDescriptorRef get_subdescriptor(size_t column_ndx) const;
+    //@}
+
+    //@{
+    /// Returns the parent table descriptor, if any.
+    ///
+    /// If this descriptor is the *root descriptor*, then this
+    /// function returns null. Otherwise it returns the accessor of
+    /// the parent descriptor.
+    ///
+    /// \sa is_root()
+    DescriptorRef get_parent() noexcept;
+    ConstDescriptorRef get_parent() const noexcept;
+    //@}
+
+    //@{
+    /// Get the table associated with the root descriptor.
+    ///
+    /// \sa get_parent()
+    /// \sa is_root()
+    TableRef get_root_table() noexcept;
+    ConstTableRef get_root_table() const noexcept;
+    //@}
+
+    //@{
+    /// Get the target table associated with the specified link column. This
+    /// descriptor must be a root descriptor (is_root()), and the specified column must be a
+    /// link column (`type_Link` or `type_LinkList`).
+    TableRef get_link_target(size_t col_ndx) noexcept;
+    ConstTableRef get_link_target(size_t col_ndx) const noexcept;
+    //@}
+
+    /// Is this a root descriptor?
+    ///
+    /// Descriptors of tables with independent dynamic type are root
+    /// descriptors. Root descriptors are never shared. Tables that
+    /// are direct members of groups have independent dynamic
+    /// types. The same is true for free-standing tables and subtables
+    /// in columns of type 'mixed'.
+    ///
+    /// When a table has a column of type 'table', the cells in that
+    /// column contain subtables. All those subtables have the same
+    /// dynamic type, and they share a single dynamic type
+    /// descriptor. Such shared descriptors are never root
+    /// descriptors.
+    ///
+    /// A type descriptor can even be shared by subtables with
+    /// different parent tables, but only if the parent tables
+    /// themselves have a shared type descriptor. For example, if a
+    /// table has a column `foo` of type 'table', and each of the
+    /// subtables in `foo` has a column `bar` of type 'table', then
+    /// all the subtables in all the `bar` columns share the same
+    /// dynamic type descriptor.
+    ///
+    /// \sa Table::has_shared_type()
+    bool is_root() const noexcept;
+
+    /// Determine whether this accessor is still attached.
+    ///
+    /// A table descriptor accessor may get detached from the
+    /// underlying descriptor for various reasons (see below). When it
+    /// does, it no longer refers to that descriptor, and can no
+    /// longer be used, except for calling is_attached(). The
+    /// consequences of calling other methods on a detached accessor
+    /// are undefined. Descriptor accessors obtained by calling
+    /// functions in the Realm API are always in the 'attached'
+    /// state immediately upon return from those functions.
+    ///
+    /// A descriptor accessor that is obtained directly from a table
+    /// becomes detached if the table becomes detached. A shared
+    /// subtable descriptor accessor that is obtained by a call to
+    /// get_subdescriptor() becomes detached if the parent descriptor
+    /// accessor becomes detached, or if the corresponding subtable
+    /// column is removed. A descriptor accessor does not get detached
+    /// under any other circumstances.
+    bool is_attached() const noexcept;
+
+    //@{
+    /// \brief Compare two table descriptors.
+    ///
+    /// Two table descriptors are equal if they have the same number of columns,
+    /// and for each column index, the two columns have the same name, data
+    /// type, and set of attributes.
+    ///
+    /// For link columns (`type_Link` and `type_LinkList`), the target table
+    /// (get_link_target()) of the two columns must be the same.
+    ///
+    /// For subtable columns (`type_Table`), the two corresponding
+    /// subdescriptors must themselves be equal, as if by a recursive call to
+    /// operator==().
+    ///
+    /// The consequences of comparing a detached descriptor are
+    /// undefined.
+    bool operator==(const Descriptor&) const noexcept;
+    bool operator!=(const Descriptor&) const noexcept;
+    //@}
+
+    /// If the specified column is optimized to store only unique values, then
+    /// this function returns the number of unique values currently
+    /// stored. Otherwise it returns zero. This function is mainly intended for
+    /// debugging purposes.
+    size_t get_num_unique_values(size_t column_ndx) const;
+
+    ~Descriptor() noexcept;
+
+
+private:
+    TableRef m_root_table; // Table associated with root descriptor. Detached iff null.
+    DescriptorRef m_parent; // Null iff detached or root descriptor.
+    Spec* m_spec; // Valid if attached. Owned iff valid and `m_parent`.
+
+    mutable unsigned long m_ref_count;
+
+    // Whenever a subtable descriptor accessor is created, it is
+    // stored in this map. This ensures that when get_subdescriptor()
+    // is called to created multiple DescriptorRef objects that
+    // overlap in time, then they will all refer to the same
+    // descriptor object.
+    //
+    // It also enables the necessary recursive detaching of descriptor
+    // objects.
+    struct subdesc_entry {
+        size_t m_column_ndx;
+        Descriptor* m_subdesc;
+        subdesc_entry(size_t column_ndx, Descriptor*);
+    };
+    typedef std::vector<subdesc_entry> subdesc_map;
+    mutable subdesc_map m_subdesc_map;
+
+    Descriptor() noexcept;
+
+    void bind_ptr() const noexcept;
+    void unbind_ptr() const noexcept;
+
+    // Called by the root table if this becomes the root
+    // descriptor. Otherwise it is called by the descriptor that
+    // becomes its parent.
+    //
+    // Puts this descriptor accessor into the attached state. This
+    // attaches it to the underlying structure of array nodes. It does
+    // not establish the parents reference to this descriptor, that is
+    // the job of the parent. When this function returns,
+    // is_attached() will return true.
+    //
+    // Not idempotent.
+    //
+    // The specified table is not allowed to be a subtable with a
+    // shareable spec. That is, Table::has_shared_spec() must return
+    // false.
+    //
+    // The specified spec must be the spec of the specified table or
+    // of one of its direct or indirect subtable columns.
+    //
+    // When the specified spec is the spec of the root table, the
+    // parent must be specified as null. When the specified spec is
+    // not the root spec, a proper parent must be specified.
+    void attach(Table*, Descriptor* parent, Spec*) noexcept;
+
+    // Detach accessor from underlying descriptor. Caller must ensure
+    // that a reference count exists upon return, for example by
+    // obtaining an extra reference count before the call.
+    //
+    // This function is called either by the root table if this is the
+    // root descriptor, or by the parent descriptor, if it is not.
+    //
+    // Puts this descriptor accessor into the detached state. This
+    // detaches it from the underlying structure of array nodes. It
+    // also calls detach_subdesc_accessors(). When this function
+    // returns, is_attached() will return false.
+    //
+    // Not idempotent.
+    void detach() noexcept;
+
+    // Recursively detach all subtable descriptor accessors that
+    // exist, that is, all subtable descriptor accessors that have
+    // this descriptor as ancestor.
+    void detach_subdesc_accessors() noexcept;
+
+    // Remove the entry from m_subdesc_map that refers to the
+    // specified subtable descriptor. It must be there.
+    void remove_subdesc_entry(Descriptor* subdesc) const noexcept;
+
+    // Record the path in terms of subtable column indexes from the
+    // root descriptor to this descriptor. If this descriptor is a
+    // root descriptor, the path is empty. Returns zero if the path is
+    // too long to fit in the specified buffer. Otherwise the path
+    // indexes will be stored between `begin_2`and `end`, where
+    // `begin_2` is the returned pointer.
+    size_t* record_subdesc_path(size_t* begin, size_t* end) const noexcept;
+
+    // Returns a pointer to the accessor of the specified
+    // subdescriptor if that accessor exists, otherwise this function
+    // return null.
+    Descriptor* get_subdesc_accessor(size_t column_ndx) noexcept;
+
+    void move_column(size_t from_ndx, size_t to_ndx);
+
+    void adj_insert_column(size_t col_ndx) noexcept;
+    void adj_erase_column(size_t col_ndx) noexcept;
+    void adj_move_column(size_t col_ndx_1, size_t col_ndx_2) noexcept;
+
+    friend class util::bind_ptr<Descriptor>;
+    friend class util::bind_ptr<const Descriptor>;
+    friend class _impl::DescriptorFriend;
+};
+
+
+
+
+// Implementation:
+
+inline size_t Descriptor::get_column_count() const noexcept
+{
+    REALM_ASSERT(is_attached());
+    return m_spec->get_public_column_count();
+}
+
+inline StringData Descriptor::get_column_name(size_t ndx) const noexcept
+{
+    REALM_ASSERT(is_attached());
+    return m_spec->get_column_name(ndx);
+}
+
+inline DataType Descriptor::get_column_type(size_t ndx) const noexcept
+{
+    REALM_ASSERT(is_attached());
+    return m_spec->get_public_column_type(ndx);
+}
+
+inline bool Descriptor::is_nullable(size_t ndx) const noexcept
+{
+    REALM_ASSERT(is_attached());
+    return m_spec->get_column_attr(ndx) & col_attr_Nullable;
+}
+
+inline size_t Descriptor::get_column_index(StringData name) const noexcept
+{
+    REALM_ASSERT(is_attached());
+    return m_spec->get_column_index(name);
+}
+
+inline size_t Descriptor::get_column_link_target(size_t column_ndx) const noexcept
+{
+    REALM_ASSERT(is_attached());
+    return m_spec->get_opposite_link_table_ndx(column_ndx);
+}
+
+inline size_t Descriptor::add_column(DataType type, StringData name, DescriptorRef* subdesc,
+                                     bool nullable)
+{
+    size_t col_ndx = m_spec->get_public_column_count();
+    insert_column(col_ndx, type, name, subdesc, nullable); // Throws
+    return col_ndx;
+}
+
+inline void Descriptor::insert_column(size_t col_ndx, DataType type, StringData name,
+                                      DescriptorRef* subdesc, bool nullable)
+{
+    typedef _impl::TableFriend tf;
+
+    if (REALM_UNLIKELY(!is_attached()))
+        throw LogicError(LogicError::detached_accessor);
+    if (REALM_UNLIKELY(col_ndx > get_column_count()))
+        throw LogicError(LogicError::column_index_out_of_range);
+    if (REALM_UNLIKELY(tf::is_link_type(ColumnType(type))))
+        throw LogicError(LogicError::illegal_type);
+
+    LinkTargetInfo invalid_link;
+    tf::insert_column(*this, col_ndx, type, name, invalid_link, nullable); // Throws
+    adj_insert_column(col_ndx);
+    if (subdesc && type == type_Table)
+        *subdesc = get_subdescriptor(col_ndx);
+}
+
+inline size_t Descriptor::add_column_link(DataType type, StringData name, Table& target,
+                                          LinkType link_type)
+{
+    size_t col_ndx = m_spec->get_public_column_count();
+    insert_column_link(col_ndx, type, name, target, link_type); // Throws
+    return col_ndx;
+}
+
+inline void Descriptor::insert_column_link(size_t col_ndx, DataType type, StringData name,
+                                           Table& target, LinkType link_type)
+{
+    typedef _impl::TableFriend tf;
+
+    if (REALM_UNLIKELY(!is_attached() || !target.is_attached()))
+        throw LogicError(LogicError::detached_accessor);
+    if (REALM_UNLIKELY(col_ndx > get_column_count()))
+        throw LogicError(LogicError::column_index_out_of_range);
+    if (REALM_UNLIKELY(!tf::is_link_type(ColumnType(type))))
+        throw LogicError(LogicError::illegal_type);
+    if (REALM_UNLIKELY(!is_root()))
+        throw LogicError(LogicError::wrong_kind_of_descriptor);
+    // Both origin and target must be group-level tables, and in the same group.
+    Group* origin_group = tf::get_parent_group(*get_root_table());
+    Group* target_group = tf::get_parent_group(target);
+    if (!origin_group || !target_group)
+        throw LogicError(LogicError::wrong_kind_of_table);
+    if (origin_group != target_group)
+        throw LogicError(LogicError::group_mismatch);
+
+    LinkTargetInfo link(&target);
+    tf::insert_column(*this, col_ndx, type, name, link); // Throws
+    adj_insert_column(col_ndx);
+
+    tf::set_link_type(*get_root_table(), col_ndx, link_type); // Throws
+}
+
+inline void Descriptor::remove_column(size_t col_ndx)
+{
+    typedef _impl::TableFriend tf;
+
+    if (REALM_UNLIKELY(!is_attached()))
+        throw LogicError(LogicError::detached_accessor);
+    if (REALM_UNLIKELY(col_ndx >= get_column_count()))
+        throw LogicError(LogicError::column_index_out_of_range);
+
+    tf::erase_column(*this, col_ndx); // Throws
+    adj_erase_column(col_ndx);
+}
+
+inline void Descriptor::rename_column(size_t col_ndx, StringData name)
+{
+    typedef _impl::TableFriend tf;
+
+    if (REALM_UNLIKELY(!is_attached()))
+        throw LogicError(LogicError::detached_accessor);
+    if (REALM_UNLIKELY(col_ndx >= get_column_count()))
+        throw LogicError(LogicError::column_index_out_of_range);
+
+    tf::rename_column(*this, col_ndx, name); // Throws
+}
+
+inline void Descriptor::move_column(size_t from_ndx, size_t to_ndx)
+{
+    REALM_ASSERT(is_attached());
+    typedef _impl::TableFriend tf;
+    tf::move_column(*this, from_ndx, to_ndx); // Throws
+    adj_move_column(from_ndx, to_ndx);
+}
+
+inline void Descriptor::set_link_type(size_t col_ndx, LinkType link_type)
+{
+    typedef _impl::TableFriend tf;
+
+    if (REALM_UNLIKELY(!is_attached()))
+        throw LogicError(LogicError::detached_accessor);
+    if (REALM_UNLIKELY(col_ndx >= get_column_count()))
+        throw LogicError(LogicError::column_index_out_of_range);
+    if (REALM_UNLIKELY(!tf::is_link_type(ColumnType(get_column_type(col_ndx)))))
+        throw LogicError(LogicError::illegal_type);
+
+    tf::set_link_type(*get_root_table(), col_ndx, link_type); // Throws
+}
+
+inline ConstDescriptorRef Descriptor::get_subdescriptor(size_t column_ndx) const
+{
+    return const_cast<Descriptor*>(this)->get_subdescriptor(column_ndx);
+}
+
+inline DescriptorRef Descriptor::get_parent() noexcept
+{
+    return m_parent;
+}
+
+inline ConstDescriptorRef Descriptor::get_parent() const noexcept
+{
+    return const_cast<Descriptor*>(this)->get_parent();
+}
+
+inline TableRef Descriptor::get_root_table() noexcept
+{
+    return m_root_table;
+}
+
+inline ConstTableRef Descriptor::get_root_table() const noexcept
+{
+    return const_cast<Descriptor*>(this)->get_root_table();
+}
+
+inline TableRef Descriptor::get_link_target(size_t col_ndx) noexcept
+{
+    REALM_ASSERT(is_attached());
+    REALM_ASSERT(is_root());
+    return get_root_table()->get_link_target(col_ndx);
+}
+
+inline ConstTableRef Descriptor::get_link_target(size_t col_ndx) const noexcept
+{
+    REALM_ASSERT(is_attached());
+    REALM_ASSERT(is_root());
+    return get_root_table()->get_link_target(col_ndx);
+}
+
+inline bool Descriptor::is_root() const noexcept
+{
+    return !m_parent;
+}
+
+inline Descriptor::Descriptor() noexcept: m_ref_count(0)
+{
+}
+
+inline void Descriptor::bind_ptr() const noexcept
+{
+    ++m_ref_count;
+}
+
+inline void Descriptor::unbind_ptr() const noexcept
+{
+    if (--m_ref_count == 0)
+        delete this;
+}
+
+inline void Descriptor::attach(Table* table, Descriptor* parent, Spec* spec) noexcept
+{
+    REALM_ASSERT(!is_attached());
+    REALM_ASSERT(!table->has_shared_type());
+    m_root_table.reset(table);
+    m_parent.reset(parent);
+    m_spec = spec;
+}
+
+inline bool Descriptor::is_attached() const noexcept
+{
+    return bool(m_root_table);
+}
+
+inline Descriptor::subdesc_entry::subdesc_entry(size_t n, Descriptor* d):
+    m_column_ndx(n),
+    m_subdesc(d)
+{
+}
+
+inline bool Descriptor::operator==(const Descriptor& d) const noexcept
+{
+    REALM_ASSERT(is_attached());
+    REALM_ASSERT(d.is_attached());
+    return *m_spec == *d.m_spec;
+}
+
+inline bool Descriptor::operator!=(const Descriptor& d) const noexcept
+{
+    return !(*this == d);
+}
+
+// The purpose of this class is to give internal access to some, but
+// not all of the non-public parts of the Descriptor class.
+class _impl::DescriptorFriend {
+public:
+    static Descriptor* create()
+    {
+        return new Descriptor; // Throws
+    }
+
+    static void attach(Descriptor& desc, Table* table, Descriptor* parent, Spec* spec) noexcept
+    {
+        desc.attach(table, parent, spec);
+    }
+
+    static void detach(Descriptor& desc) noexcept
+    {
+        desc.detach();
+    }
+
+    static Table& get_root_table(Descriptor& desc) noexcept
+    {
+        return *desc.m_root_table;
+    }
+
+    static const Table& get_root_table(const Descriptor& desc) noexcept
+    {
+        return *desc.m_root_table;
+    }
+
+    static Spec& get_spec(Descriptor& desc) noexcept
+    {
+        return *desc.m_spec;
+    }
+
+    static const Spec& get_spec(const Descriptor& desc) noexcept
+    {
+        return *desc.m_spec;
+    }
+
+    static size_t* record_subdesc_path(const Descriptor& desc, size_t* begin,
+                                            size_t* end) noexcept
+    {
+        return desc.record_subdesc_path(begin, end);
+    }
+
+    static Descriptor* get_subdesc_accessor(Descriptor& desc, size_t column_ndx) noexcept
+    {
+        return desc.get_subdesc_accessor(column_ndx);
+    }
+
+    static void move_column(Descriptor& desc, size_t from_ndx, size_t to_ndx)
+    {
+        return desc.move_column(from_ndx, to_ndx);
+    }
+
+    static void adj_insert_column(Descriptor& desc, size_t col_ndx) noexcept
+    {
+        desc.adj_insert_column(col_ndx);
+    }
+
+    static void adj_erase_column(Descriptor& desc, size_t col_ndx) noexcept
+    {
+        desc.adj_erase_column(col_ndx);
+    }
+
+    static void adj_move_column(Descriptor& desc, size_t col_ndx_1, size_t col_ndx_2) noexcept
+    {
+        desc.adj_move_column(col_ndx_1, col_ndx_2);
+    }
+};
+
+} // namespace realm
+
+#endif // REALM_DESCRIPTOR_HPP
diff --git a/Pods/Realm/include/core/realm/descriptor_fwd.hpp b/Pods/Realm/include/core/realm/descriptor_fwd.hpp
new file mode 100644
index 0000000..482b0fe
--- /dev/null
+++ b/Pods/Realm/include/core/realm/descriptor_fwd.hpp
@@ -0,0 +1,34 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_DESCRIPTOR_FWD_HPP
+#define REALM_DESCRIPTOR_FWD_HPP
+
+#include <realm/util/bind_ptr.hpp>
+
+
+namespace realm {
+
+class Descriptor;
+typedef util::bind_ptr<Descriptor> DescriptorRef;
+typedef util::bind_ptr<const Descriptor> ConstDescriptorRef;
+
+} // namespace realm
+
+#endif // REALM_DESCRIPTOR_FWD_HPP
diff --git a/Pods/Realm/include/core/realm/disable_sync_to_disk.hpp b/Pods/Realm/include/core/realm/disable_sync_to_disk.hpp
new file mode 100644
index 0000000..4b29959
--- /dev/null
+++ b/Pods/Realm/include/core/realm/disable_sync_to_disk.hpp
@@ -0,0 +1,38 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_DISABLE_SYNC_TO_DISK_HPP
+#define REALM_DISABLE_SYNC_TO_DISK_HPP
+
+#include <realm/util/features.h>
+
+namespace realm {
+
+/// Completely disable synchronization with storage device to speed up unit
+/// testing. This is an unsafe mode of operation, and should never be used in
+/// production. This function is thread safe.
+void disable_sync_to_disk();
+
+/// Returns true after disable_sync_to_disk() has been called. This function is
+/// thread safe.
+bool get_disable_sync_to_disk() noexcept;
+
+} // namespace realm
+
+#endif // REALM_DISABLE_SYNC_TO_DISK_HPP
diff --git a/Pods/Realm/include/core/realm/exceptions.hpp b/Pods/Realm/include/core/realm/exceptions.hpp
new file mode 100644
index 0000000..ef4ccc6
--- /dev/null
+++ b/Pods/Realm/include/core/realm/exceptions.hpp
@@ -0,0 +1,254 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+
+#ifndef REALM_EXCEPTIONS_HPP
+#define REALM_EXCEPTIONS_HPP
+
+#include <stdexcept>
+
+#include <realm/util/features.h>
+
+namespace realm {
+
+/// Thrown by various functions to indicate that a specified table does not
+/// exist.
+class NoSuchTable: public std::exception {
+public:
+    const char* what() const noexcept override;
+};
+
+
+/// Thrown by various functions to indicate that a specified table name is
+/// already in use.
+class TableNameInUse: public std::exception {
+public:
+    const char* what() const noexcept override;
+};
+
+
+// Thrown by functions that require a table to **not** be the target of link
+// columns, unless those link columns are part of the table itself.
+class CrossTableLinkTarget: public std::exception {
+public:
+    const char* what() const noexcept override;
+};
+
+
+/// Thrown by various functions to indicate that the dynamic type of a table
+/// does not match a particular other table type (dynamic or static).
+class DescriptorMismatch: public std::exception {
+public:
+    const char* what() const noexcept override;
+};
+
+
+/// The \c FileFormatUpgradeRequired exception can be thrown by the \c
+/// SharedGroup constructor when opening a database that uses a deprecated file
+/// format, and the user has indicated he does not want automatic upgrades to
+/// be performed. This exception indicates that until an upgrade of the file
+/// format is performed, the database will be unavailable for read or write
+/// operations.
+class FileFormatUpgradeRequired: public std::exception {
+public:
+    const char* what() const noexcept override;
+};
+
+/// Thrown when memory can no longer be mapped to. When mmap/remap fails.
+class AddressSpaceExhausted: public std::runtime_error {
+public:
+    AddressSpaceExhausted(const std::string& msg);
+    /// runtime_error::what() returns the msg provided in the constructor.
+};
+
+
+/// The \c LogicError exception class is intended to be thrown only when
+/// applications (or bindings) violate rules that are stated (or ought to have
+/// been stated) in the documentation of the public API, and only in cases
+/// where the violation could have been easily and efficiently predicted by the
+/// application. In other words, this exception class is for the cases where
+/// the error is due to incorrect use of the public API.
+///
+/// This class is not supposed to be caught by applications. It is not even
+/// supposed to be considered part of the public API, and therefore the
+/// documentation of the public API should **not** mention the \c LogicError
+/// exception class by name. Note how this contrasts with other exception
+/// classes, such as \c NoSuchTable, which are part of the public API, and are
+/// supposed to be mentioned in the documentation by name. The \c LogicError
+/// exception is part of Realm's private API.
+///
+/// In other words, the \c LogicError class should exclusively be used in
+/// replacement (or in addition to) asserts (debug or not) in order to
+/// guarantee program interruption, while still allowing for complete
+/// test-cases to be written and run.
+///
+/// To this effect, the special `CHECK_LOGIC_ERROR()` macro is provided as a
+/// test framework plugin to allow unit tests to check that the functions in
+/// the public API do throw \c LogicError when rules are violated.
+///
+/// The reason behind hiding this class from the public API is to prevent users
+/// from getting used to the idea that "Undefined Behaviour" equates a specific
+/// exception being thrown. The whole point of properly documenting "Undefined
+/// Behaviour" cases is to help the user know what the limits are, without
+/// constraining the database to handle every and any use-case thrown at it.
+///
+/// FIXME: This exception class should probably be moved to the `_impl`
+/// namespace, in order to avoid some confusion.
+class LogicError: public std::exception {
+public:
+    enum ErrorKind {
+        string_too_big,
+        binary_too_big,
+        table_name_too_long,
+        column_name_too_long,
+        table_index_out_of_range,
+        row_index_out_of_range,
+        column_index_out_of_range,
+        string_position_out_of_range,
+        link_index_out_of_range,
+        bad_version,
+        illegal_type,
+
+        /// Indicates that an argument has a value that is illegal in combination
+        /// with another argument, or with the state of an involved object.
+        illegal_combination,
+
+        /// Indicates a data type mismatch, such as when `Table::find_pkey_int()` is
+        /// called and the type of the primary key is not `type_Int`.
+        type_mismatch,
+
+        /// Indicates that two involved tables are not in the same group.
+        group_mismatch,
+
+        /// Indicates that an involved descriptor is of the wrong kind, i.e., if
+        /// it is a subtable descriptor, and the function requires a root table
+        /// descriptor.
+        wrong_kind_of_descriptor,
+
+        /// Indicates that an involved table is of the wrong kind, i.e., if it
+        /// is a subtable, and the function requires a root table, or if it is a
+        /// free-standing table, and the function requires a group-level table.
+        wrong_kind_of_table,
+
+        /// Indicates that an involved accessor is was detached, i.e., was not
+        /// attached to an underlying object.
+        detached_accessor,
+
+        /// Indicates that a specified row index of a target table (a link) is
+        /// out of range. This is used for disambiguation in cases such as
+        /// Table::set_link() where one specifies both a row index of the origin
+        /// table, and a row index of the target table.
+        target_row_index_out_of_range,
+
+        // Indicates that an involved column lacks a search index.
+        no_search_index,
+
+        /// Indicates that a modification was attempted that would have produced a
+        /// duplicate primary value.
+        unique_constraint_violation,
+
+        /// User attempted to insert null in non-nullable column
+        column_not_nullable,
+
+        /// Group::open() is called on a group accessor that is already in the
+        /// attached state. Or Group::open() or Group::commit() is called on a
+        /// group accessor that is managed by a SharedGroup object.
+        wrong_group_state,
+
+        /// No active transaction on a particular SharedGroup object (e.g.,
+        /// SharedGroup::commit()), or the active transaction on the SharedGroup
+        /// object is of the wrong type (read/write), or an attampt was made to
+        /// initiate a new transaction while one is already in progress on the
+        /// same SharedGroup object.
+        wrong_transact_state,
+
+        /// Attempted use of a continuous transaction through a SharedGroup
+        /// object with no history. See Replication::get_history().
+        no_history,
+
+        /// Durability setting (as passed to the SharedGroup constructor) was
+        /// not consistent across the session.
+        mixed_durability,
+
+        /// History type (as specified by the Replication implementation passed
+        /// to the SharedGroup constructor) was not consistent across the
+        /// session.
+        mixed_history_type,
+
+        /// Adding rows to a table with no columns is not supported.
+        table_has_no_columns
+    };
+
+    LogicError(ErrorKind message);
+
+    const char* what() const noexcept override;
+    ErrorKind kind() const noexcept;
+private:
+    ErrorKind m_kind;
+};
+
+
+
+
+// Implementation:
+
+inline const char* NoSuchTable::what() const noexcept
+{
+    return "No such table exists";
+}
+
+inline const char* TableNameInUse::what() const noexcept
+{
+    return "The specified table name is already in use";
+}
+
+inline const char* CrossTableLinkTarget::what() const noexcept
+{
+    return "Table is target of cross-table link columns";
+}
+
+inline const char* DescriptorMismatch::what() const noexcept
+{
+    return "Table descriptor mismatch";
+}
+
+inline const char* FileFormatUpgradeRequired::what() const noexcept
+{
+    return "Database upgrade required but prohibited";
+}
+
+inline AddressSpaceExhausted::AddressSpaceExhausted(const std::string& msg):
+    std::runtime_error(msg)
+{
+}
+
+inline LogicError::LogicError(LogicError::ErrorKind k):
+    m_kind(k)
+{
+}
+
+inline LogicError::ErrorKind LogicError::kind() const noexcept
+{
+    return m_kind;
+}
+
+
+} // namespace realm
+
+#endif // REALM_EXCEPTIONS_HPP
diff --git a/Pods/Realm/include/core/realm/group.hpp b/Pods/Realm/include/core/realm/group.hpp
new file mode 100644
index 0000000..431c341
--- /dev/null
+++ b/Pods/Realm/include/core/realm/group.hpp
@@ -0,0 +1,1381 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+
+#ifndef REALM_GROUP_HPP
+#define REALM_GROUP_HPP
+
+#include <functional>
+#include <string>
+#include <vector>
+#include <map>
+#include <stdexcept>
+
+#include <realm/util/features.h>
+#include <realm/exceptions.hpp>
+#include <realm/impl/input_stream.hpp>
+#include <realm/impl/output_stream.hpp>
+#include <realm/impl/continuous_transactions_history.hpp>
+#include <realm/table.hpp>
+#include <realm/table_basic_fwd.hpp>
+#include <realm/alloc_slab.hpp>
+
+namespace realm {
+
+class SharedGroup;
+namespace _impl {
+class GroupFriend;
+class TransactLogConvenientEncoder;
+class TransactLogParser;
+}
+
+
+/// A group is a collection of named tables.
+///
+/// Tables occur in the group in an unspecified order, but an order that
+/// generally remains fixed. The order is guaranteed to remain fixed between two
+/// points in time if no tables are added to, or removed from the group during
+/// that time. When tables are added to, or removed from the group, the order
+/// may change arbitrarily.
+///
+/// If `table` is a table accessor attached to a group-level table, and `group`
+/// is a group accessor attached to the group, then the following is guaranteed,
+/// even after a change in the table order:
+///
+/// \code{.cpp}
+///
+///     table == group.get_table(table.get_index_in_group())
+///
+/// \endcode
+///
+class Group: private Table::Parent {
+public:
+    /// Construct a free-standing group. This group instance will be
+    /// in the attached state, but neither associated with a file, nor
+    /// with an external memory buffer.
+    Group();
+
+    enum OpenMode {
+        /// Open in read-only mode. Fail if the file does not already exist.
+        mode_ReadOnly,
+        /// Open in read/write mode. Create the file if it doesn't exist.
+        mode_ReadWrite,
+        /// Open in read/write mode. Fail if the file does not already exist.
+        mode_ReadWriteNoCreate
+    };
+
+    /// Equivalent to calling open(const std::string&, const char*, OpenMode)
+    /// on an unattached group accessor.
+    explicit Group(const std::string& file, const char* encryption_key = nullptr,
+                   OpenMode = mode_ReadOnly);
+
+    /// Equivalent to calling open(BinaryData, bool) on an unattached
+    /// group accessor. Note that if this constructor throws, the
+    /// ownership of the memory buffer will remain with the caller,
+    /// regardless of whether \a take_ownership is set to `true` or
+    /// `false`.
+    explicit Group(BinaryData, bool take_ownership = true);
+
+    struct unattached_tag {};
+
+    /// Create a Group instance in its unattached state. It may then
+    /// be attached to a database file later by calling one of the
+    /// open() methods. You may test whether this instance is
+    /// currently in its attached state by calling
+    /// is_attached(). Calling any other method (except the
+    /// destructor) while in the unattached state has undefined
+    /// behavior.
+    Group(unattached_tag) noexcept;
+
+    // FIXME: Implement a proper copy constructor (fairly trivial).
+    Group(const Group&) = delete;
+
+    ~Group() noexcept override;
+
+    /// Attach this Group instance to the specified database file.
+    ///
+    /// By default, the specified file is opened in read-only mode
+    /// (mode_ReadOnly). This allows opening a file even when the
+    /// caller lacks permission to write to that file. The opened
+    /// group may still be modified freely, but the changes cannot be
+    /// written back to the same file using the commit() function. An
+    /// attempt to do that, will cause an exception to be thrown. When
+    /// opening in read-only mode, it is an error if the specified
+    /// file does not already exist in the file system.
+    ///
+    /// Alternatively, the file can be opened in read/write mode
+    /// (mode_ReadWrite). This allows use of the commit() function,
+    /// but, of course, it also requires that the caller has
+    /// permission to write to the specified file. When opening in
+    /// read-write mode, an attempt to create the specified file will
+    /// be made, if it does not already exist in the file system.
+    ///
+    /// In any case, if the file already exists, it must contain a
+    /// valid Realm database. In many cases invalidity will be
+    /// detected and cause the InvalidDatabase exception to be thrown,
+    /// but you should not rely on it.
+    ///
+    /// Note that changes made to the database via a Group instance
+    /// are not automatically committed to the specified file. You
+    /// may, however, at any time, explicitly commit your changes by
+    /// calling the commit() method, provided that the specified
+    /// open-mode is not mode_ReadOnly. Alternatively, you may call
+    /// write() to write the entire database to a new file. Writing
+    /// the database to a new file does not end, or in any other way
+    /// change the association between the Group instance and the file
+    /// that was specified in the call to open().
+    ///
+    /// A file that is passed to Group::open(), may not be modified by
+    /// a third party until after the Group object is
+    /// destroyed. Behavior is undefined if a file is modified by a
+    /// third party while any Group object is associated with it.
+    ///
+    /// Calling open() on a Group instance that is already in the
+    /// attached state has undefined behavior.
+    ///
+    /// Accessing a Realm database file through manual construction
+    /// of a Group object does not offer any level of thread safety or
+    /// transaction safety. When any of those kinds of safety are a
+    /// concern, consider using a SharedGroup instead. When accessing
+    /// a database file in read/write mode through a manually
+    /// constructed Group object, it is entirely the responsibility of
+    /// the application that the file is not accessed in any way by a
+    /// third party during the life-time of that group object. It is,
+    /// on the other hand, safe to concurrently access a database file
+    /// by multiple manually created Group objects, as long as all of
+    /// them are opened in read-only mode, and there is no other party
+    /// that modifies the file concurrently.
+    ///
+    /// Do not call this function on a group instance that is managed
+    /// by a shared group. Doing so will result in undefined behavior.
+    ///
+    /// Even if this function throws, it may have the side-effect of
+    /// creating the specified file, and the file may get left behind
+    /// in an invalid state. Of course, this can only happen if
+    /// read/write mode (mode_ReadWrite) was requested, and the file
+    /// did not already exist.
+    ///
+    /// \param file File system path to a Realm database file.
+    ///
+    /// \param encryption_key 32-byte key used to encrypt and decrypt
+    /// the database file, or nullptr to disable encryption.
+    ///
+    /// \param mode Specifying a mode that is not mode_ReadOnly
+    /// requires that the specified file can be opened in read/write
+    /// mode. In general there is no reason to open a group in
+    /// read/write mode unless you want to be able to call
+    /// Group::commit().
+    ///
+    /// \throw util::File::AccessError If the file could not be
+    /// opened. If the reason corresponds to one of the exception
+    /// types that are derived from util::File::AccessError, the
+    /// derived exception type is thrown. Note that InvalidDatabase is
+    /// among these derived exception types.
+    void open(const std::string& file, const char* encryption_key = nullptr,
+              OpenMode mode = mode_ReadOnly);
+
+    /// Attach this Group instance to the specified memory buffer.
+    ///
+    /// This is similar to constructing a group from a file except
+    /// that in this case the database is assumed to be stored in the
+    /// specified memory buffer.
+    ///
+    /// If \a take_ownership is `true`, you pass the ownership of the
+    /// specified buffer to the group. In this case the buffer will
+    /// eventually be freed using std::free(), so the buffer you pass,
+    /// must have been allocated using std::malloc().
+    ///
+    /// On the other hand, if \a take_ownership is set to `false`, it
+    /// is your responsibility to keep the memory buffer alive during
+    /// the lifetime of the group, and in case the buffer needs to be
+    /// deallocated afterwards, that is your responsibility too.
+    ///
+    /// If this function throws, the ownership of the memory buffer
+    /// will remain with the caller, regardless of whether \a
+    /// take_ownership is set to `true` or `false`.
+    ///
+    /// Calling open() on a Group instance that is already in the
+    /// attached state has undefined behavior.
+    ///
+    /// Do not call this function on a group instance that is managed
+    /// by a shared group. Doing so will result in undefined behavior.
+    ///
+    /// \throw InvalidDatabase If the specified buffer does not appear
+    /// to contain a valid database.
+    void open(BinaryData, bool take_ownership = true);
+
+    /// A group may be created in the unattached state, and then later
+    /// attached to a file with a call to open(). Calling any method
+    /// other than open(), and is_attached() on an unattached instance
+    /// results in undefined behavior.
+    bool is_attached() const noexcept;
+
+    /// Returns true if, and only if the number of tables in this
+    /// group is zero.
+    bool is_empty() const noexcept;
+
+    /// Returns the number of tables in this group.
+    size_t size() const noexcept;
+
+    //@{
+
+    /// has_table() returns true if, and only if this group contains a table
+    /// with the specified name.
+    ///
+    /// find_table() returns the index of the first table in this group with the
+    /// specified name, or `realm::not_found` if this group does not contain a
+    /// table with the specified name.
+    ///
+    /// get_table_name() returns the name of table at the specified index.
+    ///
+    /// The versions of get_table(), that accepts a \a name argument, return the
+    /// first table with the specified name, or null if no such table exists.
+    ///
+    /// add_table() adds a table with the specified name to this group. It
+    /// throws TableNameInUse if \a require_unique_name is true and \a name
+    /// clashes with the name of an existing table. If \a require_unique_name is
+    /// false, it is possible to add more than one table with the same
+    /// name. Whenever a table is added, the order of the preexisting tables may
+    /// change arbitrarily, and the new table may not end up as the last one
+    /// either. But know that you can always call Table::get_index_in_group() on
+    /// the returned table accessor to find out at which index it ends up.
+    ///
+    /// get_or_add_table() checks if a table exists in this group with the specified
+    /// name. If it doesn't exist, a table is created.
+    ///
+    /// get_or_insert_table() works slightly differently from get_or_add_table(),
+    /// in that it considers the position of the requested table as part of that
+    /// table's identifying "key", in addition to the name.
+    ///
+    /// remove_table() removes the specified table from this group. A table can
+    /// be removed only when it is not the target of a link column of a
+    /// different table. Whenever a table is removed, the order of the remaining
+    /// tables may change arbitrarily.
+    ///
+    /// rename_table() changes the name of a preexisting table. If \a
+    /// require_unique_name is false, it becomes possible to have more than one
+    /// table with a given name in a single group.
+    ///
+    /// The template functions work exactly like their non-template namesakes
+    /// except as follows: The template versions of get_table() and
+    /// get_or_add_table() throw DescriptorMismatch if the dynamic type of the
+    /// specified table does not match the statically specified custom table
+    /// type. The template versions of add_table() and get_or_add_table() set
+    /// the dynamic type (descriptor) to match the statically specified custom
+    /// table type.
+    ///
+    /// \tparam T An instance of the BasicTable class template.
+    ///
+    /// \param index Index of table in this group.
+    ///
+    /// \param name Name of table. All strings are valid table names as long as
+    /// they are valid UTF-8 encodings and the number of bytes does not exceed
+    /// `max_table_name_length`. A call to add_table() or get_or_add_table()
+    /// with a name that is longer than `max_table_name_length` will cause an
+    /// exception to be thrown.
+    ///
+    /// \param new_name New name for preexisting table.
+    ///
+    /// \param require_unique_name When set to true (the default), it becomes
+    /// impossible to add a table with a name that is already in use, or to
+    /// rename a table to a name that is already in use.
+    ///
+    /// \param was_added When specified, the boolean variable is set to true if
+    /// the table was added, and to false otherwise. If the function throws, the
+    /// boolean variable retains its original value.
+    ///
+    /// \return get_table(), add_table(), and get_or_add_table() return a table
+    /// accessor attached to the requested (or added) table. get_table() may
+    /// return null.
+    ///
+    /// \throw DescriptorMismatch Thrown by get_table() and get_or_add_table()
+    /// tf the dynamic table type does not match the statically specified custom
+    /// table type (\a T).
+    ///
+    /// \throw NoSuchTable Thrown by remove_table() and rename_table() if there
+    /// is no table with the specified \a name.
+    ///
+    /// \throw TableNameInUse Thrown by add_table() if \a require_unique_name is
+    /// true and \a name clashes with the name of a preexisting table. Thrown by
+    /// rename_table() if \a require_unique_name is true and \a new_name clashes
+    /// with the name of a preexisting table.
+    ///
+    /// \throw CrossTableLinkTarget Thrown by remove_table() if the specified
+    /// table is the target of a link column of a different table.
+
+    static const size_t max_table_name_length = 63;
+
+    bool has_table(StringData name) const noexcept;
+    size_t find_table(StringData name) const noexcept;
+    StringData get_table_name(size_t table_ndx) const;
+
+    TableRef get_table(size_t index);
+    ConstTableRef get_table(size_t index) const;
+
+    TableRef get_table(StringData name);
+    ConstTableRef get_table(StringData name) const;
+
+    TableRef add_table(StringData name, bool require_unique_name = true);
+    TableRef insert_table(size_t index, StringData name, bool require_unique_name = true);
+    TableRef get_or_add_table(StringData name, bool* was_added = nullptr);
+    TableRef get_or_insert_table(size_t index, StringData name, bool* was_added = nullptr);
+
+    template<class T>
+    BasicTableRef<T> get_table(size_t index);
+
+    template<class T>
+    BasicTableRef<const T> get_table(size_t index) const;
+
+    template<class T>
+    BasicTableRef<T> get_table(StringData name);
+
+    template<class T>
+    BasicTableRef<const T> get_table(StringData name) const;
+
+    template<class T>
+    BasicTableRef<T> add_table(StringData name, bool require_unique_name = true);
+
+    template<class T>
+    BasicTableRef<T> insert_table(size_t index, StringData name, bool require_unique_name = true);
+
+    template<class T>
+    BasicTableRef<T> get_or_add_table(StringData name, bool* was_added = nullptr);
+
+    template<class T>
+    BasicTableRef<T> get_or_insert_table(size_t index, StringData name, bool* was_added = nullptr);
+
+    void remove_table(size_t index);
+    void remove_table(StringData name);
+
+    void rename_table(size_t index, StringData new_name, bool require_unique_name = true);
+    void rename_table(StringData name, StringData new_name, bool require_unique_name = true);
+
+    //@}
+
+    /// Move the table at \a from_index such that it ends up at \a
+    /// to_index. Other tables are shifted as necessary in such a way that their
+    /// order is preserved.
+    ///
+    /// Note that \a to_index is the desired final index of the moved table,
+    /// therefore, `move_table(1,1)` is a no-op, while `move_table(1,2)` moves
+    /// the table at index 1 by one position, such that it ends up at index 2. A
+    /// side-effect of that, is that the table, that was originally at index 2,
+    /// is moved to index 1.
+    void move_table(size_t from_index, size_t to_index);
+
+    // Serialization
+
+    /// Write this database to the specified output stream.
+    ///
+    /// \param pad If true, the file is padded to ensure the footer is aligned
+    /// to the end of a page
+    void write(std::ostream&, bool pad=false) const;
+
+    /// Write this database to a new file. It is an error to specify a
+    /// file that already exists. This is to protect against
+    /// overwriting a database file that is currently open, which
+    /// would cause undefined behaviour.
+    ///
+    /// \param file A filesystem path.
+    ///
+    /// \param encryption_key 32-byte key used to encrypt the database file,
+    /// or nullptr to disable encryption.
+    ///
+    /// \throw util::File::AccessError If the file could not be
+    /// opened. If the reason corresponds to one of the exception
+    /// types that are derived from util::File::AccessError, the
+    /// derived exception type is thrown. In particular,
+    /// util::File::Exists will be thrown if the file exists already.
+    void write(const std::string& file, const char* encryption_key=0) const;
+
+    /// Write this database to a memory buffer.
+    ///
+    /// Ownership of the returned buffer is transferred to the
+    /// caller. The memory will have been allocated using
+    /// std::malloc().
+    BinaryData write_to_mem() const;
+
+    /// Commit changes to the attached file. This requires that the
+    /// attached file is opened in read/write mode.
+    ///
+    /// Calling this function on an unattached group, a free-standing
+    /// group, a group whose attached file is opened in read-only
+    /// mode, a group that is attached to a memory buffer, or a group
+    /// that is managed by a shared group, is an error and will result
+    /// in undefined behavior.
+    ///
+    /// Table accesors will remain valid across the commit. Note that
+    /// this is not the case when working with proper transactions.
+    void commit();
+
+    //@{
+    /// Some operations on Tables in a Group can cause indirect changes to other
+    /// fields, including in other Tables in the same Group. Specifically,
+    /// removing a row will set any links to that row to null, and if it had the
+    /// last strong links to other rows, will remove those rows. When this
+    /// happens, The cascade notification handler will be called with a
+    /// CascadeNotification containing information about what indirect changes
+    /// will occur, before any changes are made.
+    ///
+    /// has_cascade_notification_handler() returns true if and only if there is
+    /// currently a non-null notification handler registered.
+    ///
+    /// set_cascade_notification_handler() replaces the current handler (if any)
+    /// with the passed in handler. Pass in nullptr to remove the current handler
+    /// without registering a new one.
+    ///
+    /// CascadeNotification contains a vector of rows which will be removed and
+    /// a vector of links which will be set to null (or removed, for entries in
+    /// LinkLists).
+    struct CascadeNotification {
+        struct row {
+            /// Non-zero iff the removal of this row is ordered
+            /// (Table::remove()), as opposed to ordered
+            /// (Table::move_last_over()). Implicit removals are always
+            /// unordered.
+            ///
+            /// This flag does not take part in comparisons (operator==() and
+            /// operator<()).
+            size_t is_ordered_removal : 1;
+
+            /// Index within group of a group-level table.
+            size_t table_ndx : std::numeric_limits<size_t>::digits - 1;
+
+            /// Row index which will be removed.
+            size_t row_ndx;
+
+            row(): is_ordered_removal(0) {}
+
+            bool operator==(const row&) const noexcept;
+            bool operator!=(const row&) const noexcept;
+
+            /// Trivial lexicographic order
+            bool operator<(const row&) const noexcept;
+        };
+
+        struct link {
+            const Table* origin_table; ///< A group-level table.
+            size_t origin_col_ndx; ///< Link column being nullified.
+            size_t origin_row_ndx; ///< Row in column being nullified.
+            /// The target row index which is being removed. Mostly relevant for
+            /// LinkList (to know which entries are being removed), but also
+            /// valid for Link.
+            size_t old_target_row_ndx;
+        };
+
+        /// A sorted list of rows which will be removed by the current operation.
+        std::vector<row> rows;
+
+        /// An unordered list of links which will be nullified by the current
+        /// operation.
+        std::vector<link> links;
+    };
+
+    bool has_cascade_notification_handler() const noexcept;
+    void set_cascade_notification_handler(std::function<void (const CascadeNotification&)> new_handler) noexcept;
+
+    //@}
+
+    //@{
+    /// During sync operation, schema changes may happen at runtime as connected
+    /// clients update their schema as part of an app update. Since this is a
+    /// relatively rare event, no attempt is made at limiting the amount of work
+    /// the handler is required to do to update its information about table and
+    /// column indices (i.e., all table and column indices must be recalculated).
+    ///
+    /// At the time of writing, only additive schema changes may occur in that
+    /// scenario.
+    ///
+    /// has_schema_change_notification_handler() returns true iff there is currently
+    /// a non-null notification handler registered.
+    ///
+    /// set_schema_change_notification_handler() replaces the current handler (if any)
+    /// with the passed in handler. Pass in nullptr to remove the current handler
+    /// without registering a new one.
+
+    bool has_schema_change_notification_handler() const noexcept;
+    void set_schema_change_notification_handler(std::function<void()> new_handler) noexcept;
+
+    //@}
+
+    // Conversion
+    template<class S>
+    void to_json(S& out, size_t link_depth = 0,
+        std::map<std::string, std::string>* renames = nullptr) const;
+    void to_string(std::ostream& out) const;
+
+    /// Compare two groups for equality. Two groups are equal if, and
+    /// only if, they contain the same tables in the same order, that
+    /// is, for each table T at index I in one of the groups, there is
+    /// a table at index I in the other group that is equal to T.
+    /// Tables are equal if they have the same content and the same table name.
+    bool operator==(const Group&) const;
+
+    /// Compare two groups for inequality. See operator==().
+    bool operator!=(const Group& g) const { return !(*this == g); }
+
+#ifdef REALM_DEBUG
+    void verify() const;
+    void print() const;
+    void print_free() const;
+    MemStats stats();
+    void enable_mem_diagnostics(bool enable = true) { m_alloc.enable_debug(enable); }
+    void to_dot(std::ostream&) const;
+    void to_dot() const; // To std::cerr (for GDB)
+    void to_dot(const char* file_path) const;
+#else
+    void verify() const {}
+#endif
+
+private:
+    SlabAlloc m_alloc;
+
+    /// `m_top` is the root node (or top array) of the Realm, and has the
+    /// following layout:
+    ///
+    /// <pre>
+    ///
+    ///   slot  value
+    ///   -----------------------
+    ///   1st   m_table_names
+    ///   2nd   m_tables
+    ///   3rd   Logical file size
+    ///   4th   GroupWriter::m_free_positions (optional)
+    ///   5th   GroupWriter::m_free_lengths   (optional)
+    ///   6th   GroupWriter::m_free_versions  (optional)
+    ///   7th   Transaction number / version  (optional)
+    ///   8th   In-Realm history type         (optional)
+    ///   9th   In-Realm history ref          (optional)
+    ///
+    /// </pre>
+    ///
+    /// The 'in-Realm history type' slot stores a value of
+    /// Replication::HistoryType, although never
+    /// Replication::hist_OutOfRealm. For more information about that, see
+    /// Replication::get_history_type().
+    ///
+    /// The first three entries are mandatory. In files created by
+    /// Group::write(), none of the optional entries are present and the size of
+    /// `m_top` is 3. In files updated by Group::commit(), the 4th and 5th entry
+    /// is present, and the size of `m_top` is 5. In files updated by way of a
+    /// transaction (SharedGroup::commit()), the 4th, 5th, 6th, and 7th entry is
+    /// present, and the size of `m_top` is 7. In files that contain a changeset
+    /// history, the 8th and 9th entry is present.
+    ///
+    /// When a group accessor is attached to a newly created file or an empty
+    /// memory buffer where there is no top array yet, `m_top`, `m_tables`, and
+    /// `m_table_names` with be left in the detached state until the initiation
+    /// of the first write transaction. In particular, they will remain in the
+    /// detached state during read transactions that precede the first write
+    /// transaction.
+    Array m_top;
+    ArrayInteger m_tables;
+    ArrayString m_table_names;
+
+    typedef std::vector<Table*> table_accessors;
+    mutable table_accessors m_table_accessors;
+
+    bool m_attached = false;
+    const bool m_is_shared;
+
+    std::function<void (const CascadeNotification&)> m_notify_handler;
+    std::function<void ()> m_schema_change_handler;
+
+    struct shared_tag {};
+    Group(shared_tag) noexcept;
+
+    void init_array_parents() noexcept;
+
+    /// If `top_ref` is not zero, attach this group accessor to the specified
+    /// underlying node structure. If `top_ref` is zero and \a
+    /// create_group_when_missing is true, create a new node structure that
+    /// represents an empty group, and attach this group accessor to it. It is
+    /// an error to call this function on an already attached group accessor.
+    void attach(ref_type top_ref, bool create_group_when_missing);
+
+    /// Detach this group accessor from the underlying node structure. If this
+    /// group accessors is already in the detached state, this function does
+    /// nothing (idempotency).
+    void detach() noexcept;
+
+    /// \param writable Must be set to true when, and only when attaching for a
+    /// write transaction.
+    void attach_shared(ref_type new_top_ref, size_t new_file_size, bool writable);
+
+    void create_empty_group();
+
+    void reset_free_space_tracking();
+
+    void remap(size_t new_file_size);
+    void remap_and_update_refs(ref_type new_top_ref, size_t new_file_size);
+
+    /// Recursively update refs stored in all cached array
+    /// accessors. This includes cached array accessors in any
+    /// currently attached table accessors. This ensures that the
+    /// group instance itself, as well as any attached table accessor
+    /// that exists across Group::commit() will remain valid. This
+    /// function is not appropriate for use in conjunction with
+    /// commits via shared group.
+    void update_refs(ref_type top_ref, size_t old_baseline) noexcept;
+
+    // Overriding method in ArrayParent
+    void update_child_ref(size_t, ref_type) override;
+
+    // Overriding method in ArrayParent
+    ref_type get_child_ref(size_t) const noexcept override;
+
+    // Overriding method in Table::Parent
+    StringData get_child_name(size_t) const noexcept override;
+
+    // Overriding method in Table::Parent
+    void child_accessor_destroyed(Table*) noexcept override;
+
+    // Overriding method in Table::Parent
+    Group* get_parent_group() noexcept override;
+
+    class TableWriter;
+    class DefaultTableWriter;
+
+    static void write(std::ostream&, const Allocator&, TableWriter&, bool no_top_array,
+                      bool pad_for_encryption, uint_fast64_t version_number);
+
+    typedef void (*DescSetter)(Table&);
+    typedef bool (*DescMatcher)(const Spec&);
+
+    Table* do_get_table(size_t table_ndx, DescMatcher desc_matcher);
+    const Table* do_get_table(size_t table_ndx, DescMatcher desc_matcher) const;
+    Table* do_get_table(StringData name, DescMatcher desc_matcher);
+    const Table* do_get_table(StringData name, DescMatcher desc_matcher) const;
+    Table* do_insert_table(size_t, StringData name, DescSetter desc_setter, bool require_unique_name);
+    Table* do_insert_table(size_t, StringData name, DescSetter desc_setter);
+    Table* do_get_or_add_table(StringData name, DescMatcher desc_matcher, DescSetter setter,
+                               bool* was_added);
+    Table* do_get_or_insert_table(size_t, StringData name, DescMatcher desc_matcher,
+                                  DescSetter desc_setter, bool* was_added);
+
+    void create_and_insert_table(size_t new_table_ndx, StringData name);
+    Table* create_table_accessor(size_t table_ndx);
+
+    void detach_table_accessors() noexcept; // Idempotent
+
+    void mark_all_table_accessors() noexcept;
+
+    void write(const std::string& file, const char* encryption_key,
+               uint_fast64_t version_number) const;
+    void write(util::File& file, const char* encryption_key,
+               uint_fast64_t version_number) const;
+    void write(std::ostream&, bool pad, uint_fast64_t version_numer) const;
+
+    Replication* get_replication() const noexcept;
+    void set_replication(Replication*) noexcept;
+    class TransactAdvancer;
+    void advance_transact(ref_type new_top_ref, size_t new_file_size, _impl::NoCopyInputStream&);
+    void refresh_dirty_accessors();
+    template<class F>
+    void update_table_indices(F&& map_function);
+
+    int get_file_format_version() const noexcept;
+    void set_file_format_version(int) noexcept;
+    int get_committed_file_format_version() const noexcept;
+
+    /// The specified history type must be a value of Replication::HistoryType.
+    static int get_target_file_format_version_for_session(int current_file_format_version,
+                                                          int history_type) noexcept;
+
+    /// Must be called from within a write transaction
+    void upgrade_file_format(int target_file_format_version);
+
+#ifdef REALM_DEBUG
+    std::pair<ref_type, size_t>
+    get_to_dot_parent(size_t ndx_in_parent) const override;
+#endif
+
+    void send_cascade_notification(const CascadeNotification& notification) const;
+    void send_schema_change_notification() const;
+
+    static void get_version_and_history_type(const Array& top,
+                                             _impl::History::version_type& version,
+                                             int& history_type) noexcept;
+    static ref_type get_history_ref(const Array& top) noexcept;
+    void set_history_parent(Array& history_root) noexcept;
+    void prepare_history_parent(Array& history_root, int history_type);
+
+    friend class Table;
+    friend class GroupWriter;
+    friend class SharedGroup;
+    friend class _impl::GroupFriend;
+    friend class _impl::TransactLogConvenientEncoder;
+    friend class _impl::TransactLogParser;
+    friend class Replication;
+    friend class TrivialReplication;
+};
+
+
+
+
+
+// Implementation
+
+inline Group::Group(const std::string& file, const char* key, OpenMode mode):
+    m_alloc(), // Throws
+    m_top(m_alloc),
+    m_tables(m_alloc),
+    m_table_names(m_alloc),
+    m_is_shared(false)
+{
+    init_array_parents();
+
+    open(file, key, mode); // Throws
+}
+
+inline Group::Group(BinaryData buffer, bool take_ownership):
+    m_alloc(), // Throws
+    m_top(m_alloc),
+    m_tables(m_alloc),
+    m_table_names(m_alloc),
+    m_is_shared(false)
+{
+    init_array_parents();
+    open(buffer, take_ownership); // Throws
+}
+
+inline Group::Group(unattached_tag) noexcept:
+    m_alloc(), // Throws
+    m_top(m_alloc),
+    m_tables(m_alloc),
+    m_table_names(m_alloc),
+    m_is_shared(false)
+{
+    init_array_parents();
+}
+
+inline Group* Group::get_parent_group() noexcept
+{
+    return this;
+}
+
+inline Group::Group(shared_tag) noexcept:
+    m_alloc(), // Throws
+    m_top(m_alloc),
+    m_tables(m_alloc),
+    m_table_names(m_alloc),
+    m_is_shared(true)
+{
+    init_array_parents();
+}
+
+inline bool Group::is_attached() const noexcept
+{
+    return m_attached;
+}
+
+inline bool Group::is_empty() const noexcept
+{
+    if (!is_attached())
+        return false;
+    if (m_table_names.is_attached())
+        return m_table_names.is_empty();
+    return true;
+}
+
+inline size_t Group::size() const noexcept
+{
+    if (!is_attached())
+        return 0;
+    if (m_table_names.is_attached())
+        return m_table_names.size();
+    return 0;
+}
+
+inline StringData Group::get_table_name(size_t table_ndx) const
+{
+    if (table_ndx >= size())
+        throw LogicError(LogicError::table_index_out_of_range);
+    return m_table_names.get(table_ndx);
+}
+
+inline bool Group::has_table(StringData name) const noexcept
+{
+    size_t ndx = find_table(name);
+    return ndx != not_found;
+}
+
+inline size_t Group::find_table(StringData name) const noexcept
+{
+    if (!is_attached())
+        return 0;
+    if (m_table_names.is_attached())
+        return m_table_names.find_first(name);
+    return not_found;
+}
+
+inline TableRef Group::get_table(size_t table_ndx)
+{
+    if (!is_attached())
+        throw LogicError(LogicError::detached_accessor);
+    DescMatcher desc_matcher = nullptr; // Do not check descriptor
+    Table* table = do_get_table(table_ndx, desc_matcher); // Throws
+    return TableRef(table);
+}
+
+inline ConstTableRef Group::get_table(size_t table_ndx) const
+{
+    if (!is_attached())
+        throw LogicError(LogicError::detached_accessor);
+    DescMatcher desc_matcher = nullptr; // Do not check descriptor
+    const Table* table = do_get_table(table_ndx, desc_matcher); // Throws
+    return ConstTableRef(table);
+}
+
+inline TableRef Group::get_table(StringData name)
+{
+    if (!is_attached())
+        throw LogicError(LogicError::detached_accessor);
+    DescMatcher desc_matcher = nullptr; // Do not check descriptor
+    Table* table = do_get_table(name, desc_matcher); // Throws
+    return TableRef(table);
+}
+
+inline ConstTableRef Group::get_table(StringData name) const
+{
+    if (!is_attached())
+        throw LogicError(LogicError::detached_accessor);
+    DescMatcher desc_matcher = nullptr; // Do not check descriptor
+    const Table* table = do_get_table(name, desc_matcher); // Throws
+    return ConstTableRef(table);
+}
+
+inline TableRef Group::insert_table(size_t table_ndx, StringData name, bool require_unique_name)
+{
+    if (!is_attached())
+        throw LogicError(LogicError::detached_accessor);
+    DescSetter desc_setter = nullptr; // Do not add any columns
+    Table* table = do_insert_table(table_ndx, name, desc_setter, require_unique_name); // Throws
+    return TableRef(table);
+}
+
+inline TableRef Group::add_table(StringData name, bool require_unique_name)
+{
+    return insert_table(size(), name, require_unique_name);
+}
+
+inline TableRef Group::get_or_insert_table(size_t table_ndx, StringData name, bool* was_added)
+{
+    if (!is_attached())
+        throw LogicError(LogicError::detached_accessor);
+    DescMatcher desc_matcher = nullptr; // Do not check descriptor
+    DescSetter desc_setter = nullptr; // Do not add any columns
+    Table* table = do_get_or_insert_table(table_ndx, name, desc_matcher, desc_setter, was_added); // Throws
+    return TableRef(table);
+}
+
+inline TableRef Group::get_or_add_table(StringData name, bool* was_added)
+{
+    if (!is_attached())
+        throw LogicError(LogicError::detached_accessor);
+    DescMatcher desc_matcher = nullptr; // Do not check descriptor
+    DescSetter desc_setter = nullptr; // Do not add any columns
+    Table* table = do_get_or_add_table(name, desc_matcher, desc_setter, was_added); // Throws
+    return TableRef(table);
+}
+
+template<class T>
+inline BasicTableRef<T> Group::get_table(size_t table_ndx)
+{
+    static_assert(IsBasicTable<T>::value, "Invalid table type");
+    if (!is_attached())
+        throw LogicError(LogicError::detached_accessor);
+    DescMatcher desc_matcher = &T::matches_dynamic_type;
+    Table* table = do_get_table(table_ndx, desc_matcher); // Throws
+    return BasicTableRef<T>(static_cast<T*>(table));
+}
+
+template<class T>
+inline BasicTableRef<const T> Group::get_table(size_t table_ndx) const
+{
+    static_assert(IsBasicTable<T>::value, "Invalid table type");
+    if (!is_attached())
+        throw LogicError(LogicError::detached_accessor);
+    DescMatcher desc_matcher = &T::matches_dynamic_type;
+    const Table* table = do_get_table(table_ndx, desc_matcher); // Throws
+    return BasicTableRef<const T>(static_cast<const T*>(table));
+}
+
+template<class T>
+inline BasicTableRef<T> Group::get_table(StringData name)
+{
+    static_assert(IsBasicTable<T>::value, "Invalid table type");
+    if (!is_attached())
+        throw LogicError(LogicError::detached_accessor);
+    DescMatcher desc_matcher = &T::matches_dynamic_type;
+    Table* table = do_get_table(name, desc_matcher); // Throws
+    return BasicTableRef<T>(static_cast<T*>(table));
+}
+
+template<class T>
+inline BasicTableRef<const T> Group::get_table(StringData name) const
+{
+    static_assert(IsBasicTable<T>::value, "Invalid table type");
+    if (!is_attached())
+        throw LogicError(LogicError::detached_accessor);
+    DescMatcher desc_matcher = &T::matches_dynamic_type;
+    const Table* table = do_get_table(name, desc_matcher); // Throws
+    return BasicTableRef<const T>(static_cast<const T*>(table));
+}
+
+template<class T>
+inline BasicTableRef<T> Group::insert_table(size_t table_ndx, StringData name,
+                                            bool require_unique_name)
+{
+    static_assert(IsBasicTable<T>::value, "Invalid table type");
+    if (!is_attached())
+        throw LogicError(LogicError::detached_accessor);
+    DescSetter desc_setter = &T::set_dynamic_type;
+    Table* table = do_insert_table(table_ndx, name, desc_setter, require_unique_name); // Throws
+    return BasicTableRef<T>(static_cast<T*>(table));
+}
+
+template<class T>
+inline BasicTableRef<T> Group::add_table(StringData name, bool require_unique_name)
+{
+    return insert_table<T>(size(), name, require_unique_name);
+}
+
+template<class T>
+BasicTableRef<T> Group::get_or_insert_table(size_t table_ndx, StringData name, bool* was_added)
+{
+    static_assert(IsBasicTable<T>::value, "Invalid table type");
+    if (!is_attached())
+        throw LogicError(LogicError::detached_accessor);
+    DescMatcher desc_matcher = &T::matches_dynamic_type;
+    DescSetter desc_setter = &T::set_dynamic_type;
+    Table* table = do_get_or_insert_table(table_ndx, name, desc_matcher,
+                                          desc_setter, was_added); // Throws
+    return BasicTableRef<T>(static_cast<T*>(table));
+}
+
+template<class T>
+BasicTableRef<T> Group::get_or_add_table(StringData name, bool* was_added)
+{
+    static_assert(IsBasicTable<T>::value, "Invalid table type");
+    if (!is_attached())
+        throw LogicError(LogicError::detached_accessor);
+    DescMatcher desc_matcher = &T::matches_dynamic_type;
+    DescSetter desc_setter = &T::set_dynamic_type;
+    Table* table = do_get_or_add_table(name, desc_matcher,
+                                       desc_setter, was_added); // Throws
+    return BasicTableRef<T>(static_cast<T*>(table));
+}
+
+template<class S>
+void Group::to_json(S& out, size_t link_depth,
+                    std::map<std::string, std::string>* renames) const
+{
+    if (!is_attached())
+        throw LogicError(LogicError::detached_accessor);
+
+    std::map<std::string, std::string> renames2;
+    renames = renames ? renames : &renames2;
+
+    out << "{";
+
+    for (size_t i = 0; i < m_tables.size(); ++i) {
+        StringData name = m_table_names.get(i);
+        std::map<std::string, std::string>& m = *renames;
+        if (m[name] != "")
+            name = m[name];
+
+        ConstTableRef table = get_table(i);
+
+        if (i)
+            out << ",";
+        out << "\"" << name << "\"";
+        out << ":";
+        table->to_json(out, link_depth, renames);
+    }
+
+    out << "}";
+}
+
+inline void Group::init_array_parents() noexcept
+{
+    m_table_names.set_parent(&m_top, 0);
+    m_tables.set_parent(&m_top, 1);
+}
+
+inline void Group::update_child_ref(size_t child_ndx, ref_type new_ref)
+{
+    m_tables.set(child_ndx, new_ref);
+}
+
+inline ref_type Group::get_child_ref(size_t child_ndx) const noexcept
+{
+    return m_tables.get_as_ref(child_ndx);
+}
+
+inline StringData Group::get_child_name(size_t child_ndx) const noexcept
+{
+    return m_table_names.get(child_ndx);
+}
+
+inline void Group::child_accessor_destroyed(Table*) noexcept
+{
+    // Ignore
+}
+
+inline bool Group::has_cascade_notification_handler() const noexcept
+{
+    return !!m_notify_handler;
+}
+
+inline void Group::set_cascade_notification_handler(std::function<void (const CascadeNotification&)> new_handler) noexcept
+{
+    m_notify_handler = std::move(new_handler);
+}
+
+inline void Group::send_cascade_notification(const CascadeNotification& notification) const
+{
+    if (m_notify_handler)
+        m_notify_handler(notification);
+}
+
+inline bool Group::has_schema_change_notification_handler() const noexcept
+{
+    return !!m_schema_change_handler;
+}
+
+inline void Group::set_schema_change_notification_handler(std::function<void ()> new_handler) noexcept
+{
+    m_schema_change_handler = std::move(new_handler);
+}
+
+inline void Group::send_schema_change_notification() const
+{
+    if (m_schema_change_handler)
+        m_schema_change_handler();
+}
+
+inline void Group::get_version_and_history_type(const Array& top,
+                                                _impl::History::version_type& version,
+                                                int& history_type) noexcept
+{
+    _impl::History::version_type version_2 = 0;
+    int history_type_2 = 0;
+    if (top.is_attached()) {
+        if (top.size() >= 6) {
+            REALM_ASSERT(top.size() >= 7);
+            version_2 = _impl::History::version_type(top.get(6) / 2);
+        }
+        if (top.size() >= 8) {
+            REALM_ASSERT(top.size() >= 9);
+            history_type_2 = int(top.get(7) / 2);
+        }
+    }
+    // Version 0 is not a legal initial version, so it has to be set to 1
+    // instead.
+    if (version_2 == 0)
+        version_2 = 1;
+    version      = version_2;
+    history_type = history_type_2;
+}
+
+inline ref_type Group::get_history_ref(const Array& top) noexcept
+{
+    if (top.is_attached()) {
+        if (top.size() >= 8) {
+            REALM_ASSERT(top.size() >= 9);
+            return top.get_as_ref(8);
+        }
+    }
+    return 0;
+}
+
+inline void Group::set_history_parent(Array& history_root) noexcept
+{
+    history_root.set_parent(&m_top, 8);
+}
+
+inline void Group::prepare_history_parent(Array& history_root, int history_type)
+{
+    REALM_ASSERT(m_alloc.get_file_format_version() >= 4);
+    // Ensure that there are slots for both the history type and the history
+    // ref.
+    while (m_top.size() < 9)
+        m_top.add(0); // Throws
+    m_top.set(7, RefOrTagged::make_tagged(history_type)); // Throws
+    set_history_parent(history_root);
+}
+
+class Group::TableWriter {
+public:
+    virtual ref_type write_names(_impl::OutputStream&) = 0;
+    virtual ref_type write_tables(_impl::OutputStream&) = 0;
+    virtual ~TableWriter() noexcept {}
+};
+
+inline const Table* Group::do_get_table(size_t table_ndx, DescMatcher desc_matcher) const
+{
+    return const_cast<Group*>(this)->do_get_table(table_ndx, desc_matcher); // Throws
+}
+
+inline const Table* Group::do_get_table(StringData name, DescMatcher desc_matcher) const
+{
+    return const_cast<Group*>(this)->do_get_table(name, desc_matcher); // Throws
+}
+
+inline void Group::reset_free_space_tracking()
+{
+    m_alloc.reset_free_space_tracking(); // Throws
+}
+
+inline Replication* Group::get_replication() const noexcept
+{
+    return m_alloc.get_replication();
+}
+
+inline void Group::set_replication(Replication* repl) noexcept
+{
+    m_alloc.set_replication(repl);
+}
+
+// The purpose of this class is to give internal access to some, but
+// not all of the non-public parts of the Group class.
+class _impl::GroupFriend {
+public:
+    static Allocator& get_alloc(Group& group) noexcept
+    {
+        return group.m_alloc;
+    }
+
+    static Table& get_table(Group& group, size_t ndx_in_group)
+    {
+        Group::DescMatcher desc_matcher = 0; // Do not check descriptor
+        Table* table = group.do_get_table(ndx_in_group, desc_matcher); // Throws
+        return *table;
+    }
+
+    static const Table& get_table(const Group& group, size_t ndx_in_group)
+    {
+        Group::DescMatcher desc_matcher = 0; // Do not check descriptor
+        const Table* table = group.do_get_table(ndx_in_group, desc_matcher); // Throws
+        return *table;
+    }
+
+    static Table* get_table(Group& group, StringData name)
+    {
+        Group::DescMatcher desc_matcher = 0; // Do not check descriptor
+        Table* table = group.do_get_table(name, desc_matcher); // Throws
+        return table;
+    }
+
+    static const Table* get_table(const Group& group, StringData name)
+    {
+        Group::DescMatcher desc_matcher = 0; // Do not check descriptor
+        const Table* table = group.do_get_table(name, desc_matcher); // Throws
+        return table;
+    }
+
+    static Table& insert_table(Group& group, size_t table_ndx, StringData name,
+                               bool require_unique_name)
+    {
+        Group::DescSetter desc_setter = nullptr; // Do not add any columns
+        return *group.do_insert_table(table_ndx, name, desc_setter, require_unique_name);
+    }
+
+    static Table& add_table(Group& group, StringData name, bool require_unique_name)
+    {
+        return insert_table(group, group.size(), name, require_unique_name);
+    }
+
+    static Table& get_or_insert_table(Group& group, size_t table_ndx, StringData name,
+                                      bool* was_inserted)
+    {
+        Group::DescMatcher desc_matcher = nullptr; // Do not check descriptor
+        Group::DescSetter  desc_setter  = nullptr; // Do not add any columns
+        return *group.do_get_or_insert_table(table_ndx, name, desc_matcher, desc_setter, was_inserted);
+    }
+
+    static Table& get_or_add_table(Group& group, StringData name, bool* was_inserted)
+    {
+        Group::DescMatcher desc_matcher = nullptr; // Do not check descriptor
+        Group::DescSetter  desc_setter  = nullptr; // Do not add any columns
+        return *group.do_get_or_add_table(name, desc_matcher, desc_setter, was_inserted);
+    }
+
+    static void send_cascade_notification(const Group& group, const Group::CascadeNotification& notification)
+    {
+        group.send_cascade_notification(notification);
+    }
+
+    static Replication* get_replication(const Group& group) noexcept
+    {
+        return group.get_replication();
+    }
+
+    static void set_replication(Group& group, Replication* repl) noexcept
+    {
+        group.set_replication(repl);
+    }
+
+    static void detach(Group& group) noexcept
+    {
+        group.detach();
+    }
+
+    static void attach_shared(Group& group, ref_type new_top_ref, size_t new_file_size,
+                              bool writable)
+    {
+        group.attach_shared(new_top_ref, new_file_size, writable); // Throws
+    }
+
+    static void reset_free_space_tracking(Group& group)
+    {
+        group.reset_free_space_tracking(); // Throws
+    }
+
+    static void remap(Group& group, size_t new_file_size)
+    {
+        group.remap(new_file_size); // Throws
+    }
+
+    static void remap_and_update_refs(Group& group, ref_type new_top_ref, size_t new_file_size)
+    {
+        group.remap_and_update_refs(new_top_ref, new_file_size); // Throws
+    }
+
+    static void advance_transact(Group& group, ref_type new_top_ref, size_t new_file_size,
+                                 _impl::NoCopyInputStream& in)
+    {
+        group.advance_transact(new_top_ref, new_file_size, in); // Throws
+    }
+
+    static void create_empty_group_when_missing(Group& group)
+    {
+        if (!group.m_top.is_attached())
+            group.create_empty_group(); // Throws
+    }
+
+    static void get_version_and_history_type(Allocator& alloc, ref_type top_ref,
+                                             _impl::History::version_type& version,
+                                             int& history_type) noexcept
+    {
+        Array top(alloc);
+        if (top_ref != 0)
+            top.init_from_ref(top_ref);
+        Group::get_version_and_history_type(top, version, history_type);
+    }
+
+    static ref_type get_history_ref(const Group& group) noexcept
+    {
+        return Group::get_history_ref(group.m_top);
+    }
+
+    static ref_type get_history_ref(Allocator& alloc, ref_type top_ref) noexcept
+    {
+        Array top(alloc);
+        if (top_ref != 0)
+            top.init_from_ref(top_ref);
+        return Group::get_history_ref(top);
+    }
+
+    static void set_history_parent(Group& group, Array& history_root) noexcept
+    {
+        group.set_history_parent(history_root);
+    }
+
+    static void prepare_history_parent(Group& group, Array& history_root, int history_type)
+    {
+        group.prepare_history_parent(history_root, history_type); // Throws
+    }
+
+    static int get_file_format_version(const Group& group) noexcept
+    {
+        return group.get_file_format_version();
+    }
+
+    static void set_file_format_version(Group& group, int file_format_version) noexcept
+    {
+        group.set_file_format_version(file_format_version);
+    }
+
+    static int get_committed_file_format_version(const Group& group) noexcept
+    {
+        return group.get_committed_file_format_version();
+    }
+
+    static int get_target_file_format_version_for_session(int current_file_format_version,
+                                                          int history_type) noexcept
+    {
+        return Group::get_target_file_format_version_for_session(current_file_format_version,
+                                                                 history_type);
+    }
+
+    static void upgrade_file_format(Group& group, int target_file_format_version)
+    {
+        group.upgrade_file_format(target_file_format_version); // Throws
+    }
+
+};
+
+
+struct CascadeState: Group::CascadeNotification {
+    /// If non-null, then no recursion will be performed for rows of that
+    /// table. The effect is then exactly as if all the rows of that table were
+    /// added to \a state.rows initially, and then removed again after the
+    /// explicit invocations of Table::cascade_break_backlinks_to() (one for
+    /// each initiating row). This is used by Table::clear() to avoid
+    /// reentrance.
+    ///
+    /// Must never be set concurrently with stop_on_link_list_column.
+    Table* stop_on_table = nullptr;
+
+    /// If non-null, then Table::cascade_break_backlinks_to() will skip the
+    /// removal of reciprocal backlinks for the link list at
+    /// stop_on_link_list_row_ndx in this column, and no recursion will happen
+    /// on its behalf. This is used by LinkView::clear() to avoid reentrance.
+    ///
+    /// Must never be set concurrently with stop_on_table.
+    LinkListColumn* stop_on_link_list_column = nullptr;
+
+    /// Is ignored if stop_on_link_list_column is null.
+    size_t stop_on_link_list_row_ndx = 0;
+
+    /// If false, the links field is not needed, so any work done just for that
+    /// can be skipped.
+    bool track_link_nullifications = false;
+};
+
+inline bool Group::CascadeNotification::row::operator==(const row& r) const noexcept
+{
+    return table_ndx == r.table_ndx && row_ndx == r.row_ndx;
+}
+
+inline bool Group::CascadeNotification::row::operator!=(const row& r) const noexcept
+{
+    return !(*this == r);
+}
+
+inline bool Group::CascadeNotification::row::operator<(const row& r) const noexcept
+{
+    return table_ndx < r.table_ndx || (table_ndx == r.table_ndx && row_ndx < r.row_ndx);
+}
+
+} // namespace realm
+
+#endif // REALM_GROUP_HPP
diff --git a/Pods/Realm/include/core/realm/group_shared.hpp b/Pods/Realm/include/core/realm/group_shared.hpp
new file mode 100644
index 0000000..9010b4d
--- /dev/null
+++ b/Pods/Realm/include/core/realm/group_shared.hpp
@@ -0,0 +1,1187 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_GROUP_SHARED_HPP
+#define REALM_GROUP_SHARED_HPP
+
+#ifdef REALM_DEBUG
+    #include <time.h> // usleep()
+#endif
+
+#include <functional>
+#include <limits>
+#include <realm/util/features.h>
+#include <realm/util/thread.hpp>
+#ifndef _WIN32
+#include <realm/util/interprocess_condvar.hpp>
+#endif
+#include <realm/util/interprocess_mutex.hpp>
+#include <realm/group.hpp>
+#include <realm/handover_defs.hpp>
+#include <realm/impl/transact_log.hpp>
+#include <realm/replication.hpp>
+
+namespace realm {
+
+namespace _impl {
+class SharedGroupFriend;
+class WriteLogCollector;
+}
+
+/// Thrown by SharedGroup::open() if the lock file is already open in another
+/// process which can't share mutexes with this process
+struct IncompatibleLockFile: std::runtime_error {
+    IncompatibleLockFile(const std::string& msg):
+        std::runtime_error("Incompatible lock file. " + msg)
+    {
+    }
+};
+
+/// A SharedGroup facilitates transactions.
+///
+/// When multiple threads or processes need to access a database
+/// concurrently, they must do so using transactions. By design,
+/// Realm does not allow for multiple threads (or processes) to
+/// share a single instance of SharedGroup. Instead, each concurrently
+/// executing thread or process must use a separate instance of
+/// SharedGroup.
+///
+/// Each instance of SharedGroup manages a single transaction at a
+/// time. That transaction can be either a read transaction, or a
+/// write transaction.
+///
+/// Utility classes ReadTransaction and WriteTransaction are provided
+/// to make it safe and easy to work with transactions in a scoped
+/// manner (by means of the RAII idiom). However, transactions can
+/// also be explicitly started (begin_read(), begin_write()) and
+/// stopped (end_read(), commit(), rollback()).
+///
+/// If a transaction is active when the SharedGroup is destroyed, that
+/// transaction is implicitly terminated, either by a call to
+/// end_read() or rollback().
+///
+/// Two processes that want to share a database file must reside on
+/// the same host.
+///
+///
+/// Desired exception behavior (not yet fully implemented)
+/// ------------------------------------------------------
+///
+///  - If any data access API function throws an unexpected exception during a
+///    read transaction, the shared group accessor is left in state "error
+///    during read".
+///
+///  - If any data access API function throws an unexpected exception during a
+///    write transaction, the shared group accessor is left in state "error
+///    during write".
+///
+///  - If SharedGroup::begin_write() or SharedGroup::begin_read() throws an
+///    unexpected exception, the shared group accessor is left in state "no
+///    transaction in progress".
+///
+///  - SharedGroup::end_read() and SharedGroup::rollback() do not throw.
+///
+///  - If SharedGroup::commit() throws an unexpected exception, the shared group
+///    accessor is left in state "error during write" and the transaction was
+///    not committed.
+///
+///  - If SharedGroup::advance_read() or SharedGroup::promote_to_write() throws
+///    an unexpected exception, the shared group accessor is left in state "error
+///    during read".
+///
+///  - If SharedGroup::commit_and_continue_as_read() or
+///    SharedGroup::rollback_and_continue_as_read() throws an unexpected
+///    exception, the shared group accessor is left in state "error during
+///    write".
+///
+/// It has not yet been decided exactly what an "unexpected exception" is, but
+/// `std::bad_alloc` is surely one example. On the other hand, an expected
+/// exception is one that is mentioned in the function specific documentation,
+/// and is used to abort an operation due to a special, but expected condition.
+///
+/// States
+/// ------
+///
+///  - A newly created shared group accessor is in state "no transaction in
+///    progress".
+///
+///  - In state "error during read", almost all Realm API functions are
+///    illegal on the connected group of accessors. The only valid operations
+///    are destruction of the shared group, and SharedGroup::end_read(). If
+///    SharedGroup::end_read() is called, the new state becomes "no transaction
+///    in progress".
+///
+///  - In state "error during write", almost all Realm API functions are
+///    illegal on the connected group of accessors. The only valid operations
+///    are destruction of the shared group, and SharedGroup::rollback(). If
+///    SharedGroup::end_write() is called, the new state becomes "no transaction
+///    in progress"
+class SharedGroup {
+public:
+    enum DurabilityLevel {
+        durability_Full,
+        durability_MemOnly,
+        durability_Async    ///< Not yet supported on windows.
+    };
+
+    /// \brief Same as calling the corresponding version of open() on a instance
+    /// constructed in the unattached state. Exception safety note: if the
+    /// `upgrade_callback` throws, then the file will be closed properly and the
+    /// upgrade will be aborted.
+    explicit SharedGroup(const std::string& file, bool no_create = false,
+                         DurabilityLevel durability = durability_Full,
+                         const char* encryption_key = nullptr,
+                         bool allow_file_format_upgrade = true,
+                         std::function<void(int,int)> upgrade_callback = std::function<void(int,int)>());
+
+    /// \brief Same as calling the corresponding version of open() on a instance
+    /// constructed in the unattached state. Exception safety note: if the
+    /// `upgrade_callback` throws, then the file will be closed properly and
+    /// the upgrade will be aborted.
+    explicit SharedGroup(Replication& repl,
+                         DurabilityLevel durability = durability_Full,
+                         const char* encryption_key = nullptr,
+                         bool allow_file_format_upgrade = true,
+                         std::function<void(int,int)> upgrade_callback = std::function<void(int,int)>());
+
+    struct unattached_tag {};
+
+    /// Create a SharedGroup instance in its unattached state. It may
+    /// then be attached to a database file later by calling
+    /// open(). You may test whether this instance is currently in its
+    /// attached state by calling is_attached(). Calling any other
+    /// function (except the destructor) while in the unattached state
+    /// has undefined behavior.
+    SharedGroup(unattached_tag) noexcept;
+
+    ~SharedGroup() noexcept;
+
+    /// Attach this SharedGroup instance to the specified database file.
+    ///
+    /// If the database file does not already exist, it will be created (unless
+    /// \a no_create is set to true.) When multiple threads are involved, it is
+    /// safe to let the first thread, that gets to it, create the file.
+    ///
+    /// While at least one instance of SharedGroup exists for a specific
+    /// database file, a "lock" file will be present too. The lock file will be
+    /// placed in the same directory as the database file, and its name will be
+    /// derived by appending ".lock" to the name of the database file.
+    ///
+    /// When multiple SharedGroup instances refer to the same file, they must
+    /// specify the same durability level, otherwise an exception will be
+    /// thrown.
+    ///
+    /// If \a allow_file_format_upgrade is set to `true`, this function will
+    /// automatically upgrade the file format used in the specified Realm file
+    /// if necessary (and if it is possible). In order to prevent this, set \a
+    /// allow_upgrade to `false`.
+    ///
+    /// If \a allow_upgrade is set to `false`, only two outcomes are possible:
+    ///
+    /// - the specified Realm file is already using the latest file format, and
+    ///   can be used, or
+    ///
+    /// - the specified Realm file uses a deprecated file format, resulting a
+    ///   the throwing of FileFormatUpgradeRequired.
+    ///
+    /// Calling open() on a SharedGroup instance that is already in the attached
+    /// state has undefined behavior.
+    ///
+    /// \param file Filesystem path to a Realm database file.
+    ///
+    /// \throw util::File::AccessError If the file could not be opened. If the
+    /// reason corresponds to one of the exception types that are derived from
+    /// util::File::AccessError, the derived exception type is thrown. Note that
+    /// InvalidDatabase is among these derived exception types.
+    ///
+    /// \throw FileFormatUpgradeRequired only if \a allow_upgrade is `false`
+    ///        and an upgrade is required.
+    void open(const std::string& file, bool no_create = false,
+              DurabilityLevel = durability_Full,
+              const char* encryption_key = nullptr, bool allow_file_format_upgrade = true);
+
+    /// Open this group in replication mode. The specified Replication instance
+    /// must remain in existence for as long as the SharedGroup.
+    void open(Replication&, DurabilityLevel = durability_Full,
+              const char* encryption_key = nullptr, bool allow_file_format_upgrade = true);
+
+    /// Close any open database, returning to the unattached state.
+    void close() noexcept;
+
+    /// A SharedGroup may be created in the unattached state, and then
+    /// later attached to a file with a call to open(). Calling any
+    /// function other than open(), is_attached(), and ~SharedGroup()
+    /// on an unattached instance results in undefined behavior.
+    bool is_attached() const noexcept;
+
+    /// Reserve disk space now to avoid allocation errors at a later
+    /// point in time, and to minimize on-disk fragmentation. In some
+    /// cases, less fragmentation translates into improved
+    /// performance.
+    ///
+    /// When supported by the system, a call to this function will
+    /// make the database file at least as big as the specified size,
+    /// and cause space on the target device to be allocated (note
+    /// that on many systems on-disk allocation is done lazily by
+    /// default). If the file is already bigger than the specified
+    /// size, the size will be unchanged, and on-disk allocation will
+    /// occur only for the initial section that corresponds to the
+    /// specified size. On systems that do not support preallocation,
+    /// this function has no effect. To know whether preallocation is
+    /// supported by Realm on your platform, call
+    /// util::File::is_prealloc_supported().
+    ///
+    /// It is an error to call this function on an unattached shared
+    /// group. Doing so will result in undefined behavior.
+    void reserve(size_t size_in_bytes);
+
+    /// Querying for changes:
+    ///
+    /// NOTE:
+    /// "changed" means that one or more commits has been made to the database
+    /// since the SharedGroup (on which wait_for_change() is called) last
+    /// started, committed, promoted or advanced a transaction. If the SharedGroup
+    /// has not yet begun a transaction, "changed" is undefined.
+    ///
+    /// No distinction is made between changes done by another process
+    /// and changes done by another thread in the same process as the caller.
+    ///
+    /// Has db been changed ?
+    bool has_changed();
+
+    /// The calling thread goes to sleep until the database is changed, or
+    /// until wait_for_change_release() is called. After a call to wait_for_change_release()
+    /// further calls to wait_for_change() will return immediately. To restore
+    /// the ability to wait for a change, a call to enable_wait_for_change()
+    /// is required. Return true if the database has changed, false if it might have.
+    bool wait_for_change();
+
+    /// release any thread waiting in wait_for_change() on *this* SharedGroup.
+    void wait_for_change_release();
+
+    /// re-enable waiting for change
+    void enable_wait_for_change();
+    // Transactions:
+
+    using version_type = _impl::History::version_type;
+
+    struct VersionID {
+        version_type version = std::numeric_limits<version_type>::max();
+        uint_fast32_t index   = 0;
+
+        VersionID() {}
+        VersionID(version_type initial_version, uint_fast32_t initial_index)
+        {
+            version = initial_version;
+            index = initial_index;
+        }
+
+        bool operator==(const VersionID& other) { return version == other.version; }
+        bool operator!=(const VersionID& other) { return version != other.version; }
+        bool operator<(const VersionID& other) { return version < other.version; }
+        bool operator<=(const VersionID& other) { return version <= other.version; }
+        bool operator>(const VersionID& other) { return version > other.version; }
+        bool operator>=(const VersionID& other) { return version >= other.version; }
+    };
+
+    /// Thrown by begin_read() if the specified version does not correspond to a
+    /// bound (or tethered) snapshot.
+    struct BadVersion;
+
+
+    //@{
+
+    /// begin_read() initiates a new read transaction. A read transaction is
+    /// bound to, and provides access to a particular snapshot of the underlying
+    /// Realm (in general the latest snapshot, but see \a version). It cannot be
+    /// used to modify the Realm, and in that sense, a read transaction is not a
+    /// real transaction.
+    ///
+    /// begin_write() initiates a new write transaction. A write transaction
+    /// allows the application to both read and modify the underlying Realm
+    /// file. At most one write transaction can be in progress at any given time
+    /// for a particular underlying Realm file. If another write transaction is
+    /// already in progress, begin_write() will block the caller until the other
+    /// write transaction terminates. No guarantees are made about the order in
+    /// which multiple concurrent requests will be served.
+    ///
+    /// It is an error to call begin_read() or begin_write() on a SharedGroup
+    /// object with an active read or write transaction.
+    ///
+    /// If begin_read() or begin_write() throws, no transaction is initiated,
+    /// and the application may try to initiate a new read or write transaction
+    /// later.
+    ///
+    /// end_read() terminates the active read transaction. If no read
+    /// transaction is active, end_read() does nothing. It is an error to call
+    /// this function on a SharedGroup object with an active write
+    /// transaction. end_read() does not throw.
+    ///
+    /// commit() commits all changes performed in the context of the active
+    /// write transaction, and thereby terminates that transaction. This
+    /// produces a new snapshot in the underlying Realm. commit() returns the
+    /// version associated with the new snapshot. It is an error to call
+    /// commit() when there is no active write transaction. If commit() throws,
+    /// no changes will have been committed, and the transaction will still be
+    /// active, but in a bad state. In that case, the application must either
+    /// call rollback() to terminate the bad transaction (in which case a new
+    /// transaction can be initiated), call close() which also terminates the
+    /// bad transaction, or destroy the SharedGroup object entirely. When the
+    /// transaction is in a bad state, the application is not allowed to call
+    /// any method on the Group accessor or on any of its subordinate accessors
+    /// (Table, Row, Descriptor). Note that the transaction is also left in a
+    /// bad state when a modifying operation on any subordinate accessor throws.
+    ///
+    /// rollback() terminates the active write transaction and discards any
+    /// changes performed in the context of it. If no write transaction is
+    /// active, rollback() does nothing. It is an error to call this function in
+    /// a SharedGroup object with an active read transaction. rollback() does
+    /// not throw.
+    ///
+    /// the Group accessor and all subordinate accessors (Table, Row,
+    /// Descriptor) that are obtained in the context of a particular read or
+    /// write transaction will become detached upon termination of that
+    /// transaction, which means that they can no longer be used to access the
+    /// underlying objects.
+    ///
+    /// Subordinate accessors that were detached at the end of the previous
+    /// read or write transaction will not be automatically reattached when a
+    /// new transaction is initiated. The application must reobtain new
+    /// accessors during a new transaction to regain access to the underlying
+    /// objects.
+    ///
+    /// \param version If specified, this must be the version associated with a
+    /// *bound* snapshot. A snapshot is said to be bound (or tethered) if there
+    /// is at least one active read or write transaction bound to it. A read
+    /// transaction is bound to the snapshot that it provides access to. A write
+    /// transaction is bound to the latest snapshot available at the time of
+    /// initiation of the write transaction. If the specified version is not
+    /// associated with a bound snapshot, this function throws BadVersion.
+    ///
+    /// \throw BadVersion Thrown by begin_read() if the specified version does
+    /// not correspond to a bound (or tethered) snapshot.
+
+    const Group& begin_read(VersionID version = VersionID());
+    void end_read() noexcept;
+    Group& begin_write();
+    version_type commit();
+    void rollback() noexcept;
+
+    //@}
+
+    enum TransactStage {
+        transact_Ready,
+        transact_Reading,
+        transact_Writing
+    };
+
+    /// Get the current transaction type
+    TransactStage get_transact_stage() const noexcept;
+
+    /// Get a version id which may be used to request a different SharedGroup
+    /// to start transaction at a specific version.
+    VersionID get_version_of_current_transaction();
+
+    /// Report the number of distinct versions currently stored in the database.
+    /// Note: the database only cleans up versions as part of commit, so ending
+    /// a read transaction will not immediately release any versions.
+    uint_fast64_t get_number_of_versions();
+
+    /// Compact the database file.
+    /// - The method will throw if called inside a transaction.
+    /// - The method will throw if called in unattached state.
+    /// - The method will return false if other SharedGroups are accessing the database
+    ///   in which case compaction is not done. This is not necessarily an error.
+    /// It will return true following successful compaction.
+    /// While compaction is in progress, attempts by other
+    /// threads or processes to open the database will wait.
+    /// Be warned that resource requirements for compaction is proportional to the amount
+    /// of live data in the database.
+    /// Compaction works by writing the database contents to a temporary database file and
+    /// then replacing the database with the temporary one. The name of the temporary
+    /// file is formed by appending ".tmp_compaction_space" to the name of the database
+    ///
+    /// FIXME: This function is not yet implemented in an exception-safe manner,
+    /// therefore, if it throws, the application should not attempt to
+    /// continue. If may not even be safe to destroy the SharedGroup object.
+    bool compact();
+
+#ifdef REALM_DEBUG
+    void test_ringbuf();
+#endif
+
+    /// To handover a table view, query, linkview or row accessor of type T, you must
+    /// wrap it into a Handover<T> for the transfer. Wrapping and unwrapping of a handover
+    /// object is done by the methods 'export_for_handover()' and 'import_from_handover()'
+    /// declared below. 'export_for_handover()' returns a Handover object, and
+    /// 'import_for_handover()' consumes that object, producing a new accessor which
+    /// is ready for use in the context of the importing SharedGroup.
+    ///
+    /// The Handover always creates a new accessor object at the importing side.
+    /// For TableViews, there are 3 forms of handover.
+    ///
+    /// - with payload move: the payload is handed over and ends up as a payload
+    ///   held by the accessor at the importing side. The accessor on the exporting
+    ///   side will rerun its query and generate a new payload, if TableView::sync_if_needed() is
+    ///   called. If the original payload was in sync at the exporting side, it will
+    ///   also be in sync at the importing side. This is indicated to handover_export()
+    ///   by the argument MutableSourcePayload::Move
+    ///
+    /// - with payload copy: a copy of the payload is handed over, so both the accessors
+    ///   on the exporting side *and* the accessors created at the importing side has
+    ///   their own payload. This is indicated to handover_export() by the argument
+    ///   ConstSourcePayload::Copy
+    ///
+    /// - without payload: the payload stays with the accessor on the exporting
+    ///   side. On the importing side, the new accessor is created without payload.
+    ///   a call to TableView::sync_if_needed() will trigger generation of a new payload.
+    ///   This form of handover is indicated to handover_export() by the argument
+    ///   ConstSourcePayload::Stay.
+    ///
+    /// For all other (non-TableView) accessors, handover is done with payload copy,
+    /// since the payload is trivial.
+    ///
+    /// Handover *without* payload is useful when you want to ship a tableview with its query for
+    /// execution in a background thread. Handover with *payload move* is useful when you want to
+    /// transfer the result back.
+    ///
+    /// Handover *without* payload or with payload copy is guaranteed *not* to change
+    /// the accessors on the exporting side.
+    ///
+    /// Handover is *not* thread safe and should be carried out
+    /// by the thread that "owns" the involved accessors.
+    ///
+    /// Handover is transitive:
+    /// If the object being handed over depends on other views (table- or link- ), those
+    /// objects will be handed over as well. The mode of handover (payload copy, payload
+    /// move, without payload) is applied recursively. Note: If you are handing over
+    /// a tableview dependent upon another tableview and using MutableSourcePayload::Move,
+    /// you are on thin ice!
+    ///
+    /// On the importing side, the top-level accessor being created during import takes ownership
+    /// of all other accessors (if any) being created as part of the import.
+
+    /// Type used to support handover of accessors between shared groups.
+    template<typename T>
+    struct Handover;
+
+    /// thread-safe/const export (mode is Stay or Copy)
+    /// during export, the following operations on the shared group is locked:
+    /// - advance_read(), promote_to_write(), commit_and_continue_as_read(),
+    ///   rollback_and_continue_as_read(), close()
+    template<typename T>
+    std::unique_ptr<Handover<T>> export_for_handover(const T& accessor, ConstSourcePayload mode);
+
+    // specialization for handover of Rows
+    template<typename T>
+    std::unique_ptr<Handover<BasicRow<T>>> export_for_handover(const BasicRow<T>& accessor);
+
+    // destructive export (mode is Move)
+    template<typename T>
+    std::unique_ptr<Handover<T>> export_for_handover(T& accessor, MutableSourcePayload mode);
+
+    /// Import an accessor wrapped in a handover object. The import will fail if the
+    /// importing SharedGroup is viewing a version of the database that is different
+    /// from the exporting SharedGroup. The call to import_from_handover is not thread-safe.
+    template<typename T>
+    std::unique_ptr<T> import_from_handover(std::unique_ptr<Handover<T>> handover);
+
+    // we need to special case handling of LinkViews, because they are ref counted.
+    std::unique_ptr<Handover<LinkView>> export_linkview_for_handover(const LinkViewRef& accessor);
+    LinkViewRef import_linkview_from_handover(std::unique_ptr<Handover<LinkView>> handover);
+
+    // likewise for Tables.
+    std::unique_ptr<Handover<Table>> export_table_for_handover(const TableRef& accessor);
+    TableRef import_table_from_handover(std::unique_ptr<Handover<Table>> handover);
+
+    /// When doing handover to background tasks that may be run later, we
+    /// may want to momentarily pin the current version until the other thread
+    /// has retrieved it.
+    ///
+    /// The release is not thread-safe, so it has to be done on the SharedGroup
+    /// associated with the thread calling unpin_version(), and the SharedGroup
+    /// must be attached to the realm file at the point of unpinning.
+
+    // Pin version for handover (not thread safe)
+    VersionID pin_version();
+
+    // Release pinned version (not thread safe)
+    void unpin_version(VersionID version);
+
+private:
+    struct SharedInfo;
+    struct ReadCount;
+    struct ReadLockInfo {
+        uint_fast64_t   m_version    = std::numeric_limits<version_type>::max();
+        uint_fast32_t   m_reader_idx = 0;
+        ref_type        m_top_ref    = 0;
+        size_t          m_file_size  = 0;
+    };
+    class ReadLockUnlockGuard;
+
+    // Member variables
+    Group m_group;
+    ReadLockInfo m_read_lock;
+    uint_fast32_t m_local_max_entry;
+    util::File m_file;
+    util::File::Map<SharedInfo> m_file_map; // Never remapped
+    util::File::Map<SharedInfo> m_reader_map;
+    bool m_wait_for_change_enabled;
+    std::string m_lockfile_path;
+    std::string m_lockfile_prefix;
+    std::string m_db_path;
+    std::string m_coordination_dir;
+    const char* m_key;
+    TransactStage m_transact_stage;
+    util::InterprocessMutex m_writemutex;
+    util::InterprocessMutex m_balancemutex;
+    util::InterprocessMutex m_controlmutex;
+#ifndef _WIN32
+    util::InterprocessCondVar m_room_to_write;
+    util::InterprocessCondVar m_work_to_do;
+    util::InterprocessCondVar m_daemon_becomes_ready;
+    util::InterprocessCondVar m_new_commit_available;
+#endif
+    std::function<void(int,int)> m_upgrade_callback;
+
+    void do_open(const std::string& file, bool no_create, DurabilityLevel, bool is_backend,
+                 const char* encryption_key, bool allow_file_format_upgrade);
+
+    // Ring buffer management
+    bool        ringbuf_is_empty() const noexcept;
+    size_t ringbuf_size() const noexcept;
+    size_t ringbuf_capacity() const noexcept;
+    bool        ringbuf_is_first(size_t ndx) const noexcept;
+    void        ringbuf_remove_first() noexcept;
+    size_t ringbuf_find(uint64_t version) const noexcept;
+    ReadCount&  ringbuf_get(size_t ndx) noexcept;
+    ReadCount&  ringbuf_get_first() noexcept;
+    ReadCount&  ringbuf_get_last() noexcept;
+    void        ringbuf_put(const ReadCount& v);
+    void        ringbuf_expand();
+
+    /// Grab a read lock on the snapshot associated with the specified
+    /// version. If `version_id == VersionID()`, a read lock will be grabbed on
+    /// the latest available snapshot. Fails if the snapshot is no longer
+    /// available.
+    ///
+    /// As a side effect update memory mapping to ensure that the ringbuffer entries
+    /// referenced in the readlock info is accessible.
+    ///
+    /// FIXME: It needs to be made more clear exactly under which conditions
+    /// this function fails. Also, why is it useful to promise anything about
+    /// detection of bad versions? Can we really promise enough to make such a
+    /// promise useful to the caller?
+    void grab_read_lock(ReadLockInfo&, VersionID);
+
+    // Release a specific read lock. The read lock MUST have been obtained by a
+    // call to grab_read_lock().
+    void release_read_lock(ReadLockInfo&) noexcept;
+
+    void do_begin_read(VersionID, bool writable);
+    void do_end_read() noexcept;
+    void do_begin_write();
+    version_type do_commit();
+    void do_end_write() noexcept;
+
+    /// Returns the version of the latest snapshot.
+    version_type get_version_of_latest_snapshot();
+
+    /// Returns the version of the snapshot bound in the current read or write
+    /// transaction. It is an error to call this function when no transaction is
+    /// in progress.
+    version_type get_version_of_bound_snapshot() const noexcept;
+
+    // make sure the given index is within the currently mapped area.
+    // if not, expand the mapped area. Returns true if the area is expanded.
+    bool grow_reader_mapping(uint_fast32_t index);
+
+    // Must be called only by someone that has a lock on the write
+    // mutex.
+    void low_level_commit(uint_fast64_t new_version);
+
+    void do_async_commits();
+
+    void upgrade_file_format(bool allow_file_format_upgrade, int target_file_format_version);
+
+    //@{
+    /// See LangBindHelper.
+    template<class O> void advance_read(O* observer, VersionID);
+    template<class O> void promote_to_write(O* observer);
+    version_type commit_and_continue_as_read();
+    template<class O> void rollback_and_continue_as_read(O* observer);
+    //@}
+
+    /// Returns true if, and only if _impl::History::update_early_from_top_ref()
+    /// was called during the execution of this function.
+    template<class O> bool do_advance_read(O* observer, VersionID, _impl::History&);
+
+    /// If there is an associated \ref Replication object, then this function
+    /// returns `repl->get_history()` where `repl` is that Replication object,
+    /// otherwise this function returns null.
+    _impl::History* get_history();
+
+    int get_file_format_version() const noexcept;
+
+    friend class _impl::SharedGroupFriend;
+};
+
+
+
+class ReadTransaction {
+public:
+    ReadTransaction(SharedGroup& sg):
+        m_shared_group(sg)
+    {
+        m_shared_group.begin_read(); // Throws
+    }
+
+    ~ReadTransaction() noexcept
+    {
+        m_shared_group.end_read();
+    }
+
+    bool has_table(StringData name) const noexcept
+    {
+        return get_group().has_table(name);
+    }
+
+    ConstTableRef get_table(size_t table_ndx) const
+    {
+        return get_group().get_table(table_ndx); // Throws
+    }
+
+    ConstTableRef get_table(StringData name) const
+    {
+        return get_group().get_table(name); // Throws
+    }
+
+    template<class T>
+    BasicTableRef<const T> get_table(StringData name) const
+    {
+        return get_group().get_table<T>(name); // Throws
+    }
+
+    const Group& get_group() const noexcept;
+
+    /// Get the version of the snapshot to which this read transaction is bound.
+    SharedGroup::version_type get_version() const noexcept;
+
+private:
+    SharedGroup& m_shared_group;
+};
+
+
+class WriteTransaction {
+public:
+    WriteTransaction(SharedGroup& sg):
+        m_shared_group(&sg)
+    {
+        m_shared_group->begin_write(); // Throws
+    }
+
+    ~WriteTransaction() noexcept
+    {
+        if (m_shared_group)
+            m_shared_group->rollback();
+    }
+
+    bool has_table(StringData name) const noexcept
+    {
+        return get_group().has_table(name);
+    }
+
+    TableRef get_table(size_t table_ndx) const
+    {
+        return get_group().get_table(table_ndx); // Throws
+    }
+
+    TableRef get_table(StringData name) const
+    {
+        return get_group().get_table(name); // Throws
+    }
+
+    TableRef add_table(StringData name, bool require_unique_name = true) const
+    {
+        return get_group().add_table(name, require_unique_name); // Throws
+    }
+
+    TableRef get_or_add_table(StringData name, bool* was_added = nullptr) const
+    {
+        return get_group().get_or_add_table(name, was_added); // Throws
+    }
+
+    template<class T>
+    BasicTableRef<T> get_table(StringData name) const
+    {
+        return get_group().get_table<T>(name); // Throws
+    }
+
+    template<class T>
+    BasicTableRef<T> add_table(StringData name, bool require_unique_name = true) const
+    {
+        return get_group().add_table<T>(name, require_unique_name); // Throws
+    }
+
+    template<class T>
+    BasicTableRef<T> get_or_add_table(StringData name, bool* was_added = nullptr) const
+    {
+        return get_group().get_or_add_table<T>(name, was_added); // Throws
+    }
+
+    Group& get_group() const noexcept;
+
+    /// Get the version of the snapshot on which this write transaction is
+    /// based.
+    SharedGroup::version_type get_version() const noexcept;
+
+    SharedGroup::version_type commit()
+    {
+        REALM_ASSERT(m_shared_group);
+        SharedGroup::version_type new_version = m_shared_group->commit();
+        m_shared_group = nullptr;
+        return new_version;
+    }
+
+    void rollback() noexcept
+    {
+        REALM_ASSERT(m_shared_group);
+        m_shared_group->rollback();
+        m_shared_group = nullptr;
+    }
+
+private:
+    SharedGroup* m_shared_group;
+};
+
+
+
+
+
+
+// Implementation:
+
+struct SharedGroup::BadVersion: std::exception {};
+
+inline SharedGroup::SharedGroup(const std::string& file, bool no_create,
+                                DurabilityLevel durability, const char* encryption_key,
+                                bool allow_file_format_upgrade, std::function<void(int,int)> upgrade_callback):
+    m_group(Group::shared_tag()),
+    m_upgrade_callback(std::move(upgrade_callback))
+{
+    open(file, no_create, durability, encryption_key, allow_file_format_upgrade); // Throws
+}
+
+inline SharedGroup::SharedGroup(unattached_tag) noexcept:
+    m_group(Group::shared_tag())
+{
+}
+
+inline SharedGroup::SharedGroup(Replication& repl, DurabilityLevel durability,
+                                const char* encryption_key, bool allow_file_format_upgrade,
+                                std::function<void(int,int)> upgrade_callback):
+    m_group(Group::shared_tag()),
+    m_upgrade_callback(std::move(upgrade_callback))
+{
+    open(repl, durability, encryption_key, allow_file_format_upgrade); // Throws
+}
+
+inline void SharedGroup::open(const std::string& path, bool no_create_file,
+                              DurabilityLevel durability, const char* encryption_key,
+                              bool allow_file_format_upgrade)
+{
+    // Exception safety: Since open() is called from constructors, if it throws,
+    // it must leave the file closed.
+
+    bool is_backend = false;
+    do_open(path, no_create_file, durability, is_backend, encryption_key,
+            allow_file_format_upgrade); // Throws
+}
+
+inline void SharedGroup::open(Replication& repl, DurabilityLevel durability,
+                              const char* encryption_key, bool allow_file_format_upgrade)
+{
+    // Exception safety: Since open() is called from constructors, if it throws,
+    // it must leave the file closed.
+
+    REALM_ASSERT(!is_attached());
+
+    repl.initialize(*this); // Throws
+
+    typedef _impl::GroupFriend gf;
+    gf::set_replication(m_group, &repl);
+
+    std::string file = repl.get_database_path();
+    bool no_create   = false;
+    bool is_backend  = false;
+    do_open(file, no_create, durability, is_backend, encryption_key,
+            allow_file_format_upgrade); // Throws
+}
+
+inline bool SharedGroup::is_attached() const noexcept
+{
+    return m_file_map.is_attached();
+}
+
+inline SharedGroup::TransactStage SharedGroup::get_transact_stage() const noexcept
+{
+    return m_transact_stage;
+}
+
+inline SharedGroup::version_type SharedGroup::get_version_of_bound_snapshot() const noexcept
+{
+    return m_read_lock.m_version;
+}
+
+class SharedGroup::ReadLockUnlockGuard {
+public:
+    ReadLockUnlockGuard(SharedGroup& shared_group, ReadLockInfo& read_lock) noexcept:
+        m_shared_group(shared_group),
+        m_read_lock(&read_lock)
+    {
+    }
+    ~ReadLockUnlockGuard() noexcept
+    {
+        if (m_read_lock)
+            m_shared_group.release_read_lock(*m_read_lock);
+    }
+    void release() noexcept
+    {
+        m_read_lock = 0;
+    }
+private:
+    SharedGroup& m_shared_group;
+    ReadLockInfo* m_read_lock;
+};
+
+
+template<typename T>
+struct SharedGroup::Handover {
+    std::unique_ptr<typename T::HandoverPatch> patch;
+    std::unique_ptr<T> clone;
+    VersionID version;
+};
+
+template<typename T>
+std::unique_ptr<SharedGroup::Handover<T>> SharedGroup::export_for_handover(const T& accessor, ConstSourcePayload mode)
+{
+    if (m_transact_stage != transact_Reading)
+        throw LogicError(LogicError::wrong_transact_state);
+    std::unique_ptr<Handover<T>> result(new Handover<T>());
+    // Implementation note:
+    // often, the return value from clone will be T*, BUT it may be ptr to some base of T
+    // instead, so we must cast it to T*. This is always safe, because no matter the type,
+    // clone() will clone the actual accessor instance, and hence return an instance of the
+    // same type.
+    result->clone.reset(dynamic_cast<T*>(accessor.clone_for_handover(result->patch, mode).release()));
+    result->version = get_version_of_current_transaction();
+    return move(result);
+}
+
+
+template<typename T>
+std::unique_ptr<SharedGroup::Handover<BasicRow<T>>> SharedGroup::export_for_handover(const BasicRow<T>& accessor)
+{
+    if (m_transact_stage != transact_Reading)
+        throw LogicError(LogicError::wrong_transact_state);
+    std::unique_ptr<Handover<BasicRow<T>>> result(new Handover<BasicRow<T>>());
+    // See implementation note above.
+    result->clone.reset(dynamic_cast<BasicRow<T>*>(accessor.clone_for_handover(result->patch).release()));
+    result->version = get_version_of_current_transaction();
+    return move(result);
+}
+
+
+template<typename T>
+std::unique_ptr<SharedGroup::Handover<T>> SharedGroup::export_for_handover(T& accessor, MutableSourcePayload mode)
+{
+    if (m_transact_stage != transact_Reading)
+        throw LogicError(LogicError::wrong_transact_state);
+    std::unique_ptr<Handover<T>> result(new Handover<T>());
+    // see implementation note above.
+    result->clone.reset(dynamic_cast<T*>(accessor.clone_for_handover(result->patch, mode).release()));
+    result->version = get_version_of_current_transaction();
+    return move(result);
+}
+
+
+template<typename T>
+std::unique_ptr<T> SharedGroup::import_from_handover(std::unique_ptr<SharedGroup::Handover<T>> handover)
+{
+    if (handover->version != get_version_of_current_transaction()) {
+        throw BadVersion();
+    }
+    std::unique_ptr<T> result = move(handover->clone);
+    result->apply_and_consume_patch(handover->patch, m_group);
+    return result;
+}
+
+template<class O>
+inline void SharedGroup::advance_read(O* observer, VersionID version_id)
+{
+    if (m_transact_stage != transact_Reading)
+        throw LogicError(LogicError::wrong_transact_state);
+
+    // It is an error if the new version precedes the currently bound one.
+    if (version_id.version < m_read_lock.m_version)
+        throw LogicError(LogicError::bad_version);
+
+    _impl::History* hist = get_history(); // Throws
+    if (!hist)
+        throw LogicError(LogicError::no_history);
+
+    do_advance_read(observer, version_id, *hist); // Throws
+}
+
+template<class O>
+inline void SharedGroup::promote_to_write(O* observer)
+{
+    if (m_transact_stage != transact_Reading)
+        throw LogicError(LogicError::wrong_transact_state);
+
+    _impl::History* hist = get_history(); // Throws
+    if (!hist)
+        throw LogicError(LogicError::no_history);
+
+    do_begin_write(); // Throws
+    try {
+        VersionID version = VersionID(); // Latest
+        bool history_updated = do_advance_read(observer, version, *hist); // Throws
+
+        Replication* repl = m_group.get_replication();
+        REALM_ASSERT(repl); // Presence of `repl` follows from the presence of `hist`
+        version_type current_version = m_read_lock.m_version;
+        repl->initiate_transact(current_version, history_updated); // Throws
+
+        // If the group has no top array (top_ref == 0), create a new node
+        // structure for an empty group now, to be ready for modifications. See
+        // also Group::attach_shared().
+        using gf = _impl::GroupFriend;
+        gf::create_empty_group_when_missing(m_group); // Throws
+    }
+    catch (...) {
+        do_end_write();
+        throw;
+    }
+
+    m_transact_stage = transact_Writing;
+}
+
+template<class O>
+inline void SharedGroup::rollback_and_continue_as_read(O* observer)
+{
+    if (m_transact_stage != transact_Writing)
+        throw LogicError(LogicError::wrong_transact_state);
+
+    _impl::History* hist = get_history(); // Throws
+    if (!hist)
+        throw LogicError(LogicError::no_history);
+
+    // Mark all managed space (beyond the attached file) as free.
+    using gf = _impl::GroupFriend;
+    gf::reset_free_space_tracking(m_group); // Throws
+
+    BinaryData uncommitted_changes = hist->get_uncommitted_changes();
+
+    // FIXME: We are currently creating two transaction log parsers, one here,
+    // and one in advance_transact(). That is wasteful as the parser creation is
+    // expensive.
+    _impl::SimpleInputStream in(uncommitted_changes.data(), uncommitted_changes.size());
+    _impl::TransactLogParser parser; // Throws
+    _impl::TransactReverser reverser;
+    parser.parse(in, reverser); // Throws
+
+    if (observer && uncommitted_changes.size()) {
+        _impl::ReversedNoCopyInputStream reversed_in(reverser);
+        parser.parse(reversed_in, *observer); // Throws
+        observer->parse_complete(); // Throws
+    }
+
+    ref_type top_ref = m_read_lock.m_top_ref;
+    size_t file_size = m_read_lock.m_file_size;
+    _impl::ReversedNoCopyInputStream reversed_in(reverser);
+    gf::advance_transact(m_group, top_ref, file_size, reversed_in); // Throws
+
+    do_end_write();
+
+    Replication* repl = gf::get_replication(m_group);
+    REALM_ASSERT(repl); // Presence of `repl` follows from the presence of `hist`
+    repl->abort_transact();
+
+    m_transact_stage = transact_Reading;
+}
+
+template<class O>
+inline bool SharedGroup::do_advance_read(O* observer, VersionID version_id, _impl::History& hist)
+{
+    ReadLockInfo new_read_lock;
+    grab_read_lock(new_read_lock, version_id); // Throws
+    REALM_ASSERT(new_read_lock.m_version >= m_read_lock.m_version);
+    if (new_read_lock.m_version == m_read_lock.m_version) {
+        release_read_lock(new_read_lock);
+        return false; // _impl::History::update_early_from_top_ref() was not called
+    }
+
+    ReadLockUnlockGuard g(*this, new_read_lock);
+    {
+        version_type new_version = new_read_lock.m_version;
+        size_t new_file_size = new_read_lock.m_file_size;
+        ref_type new_top_ref = new_read_lock.m_top_ref;
+        hist.update_early_from_top_ref(new_version, new_file_size, new_top_ref); // Throws
+    }
+
+    if (observer) {
+        // This has to happen in the context of the originally bound snapshot
+        // and while the read transaction is still in a fully functional state.
+        _impl::TransactLogParser parser;
+        version_type old_version = m_read_lock.m_version;
+        version_type new_version = new_read_lock.m_version;
+        _impl::ChangesetInputStream in(hist, old_version, new_version);
+        parser.parse(in, *observer); // Throws
+        observer->parse_complete(); // Throws
+    }
+
+    // The old read lock must be retained for as long as the change history is
+    // accessed (until Group::advance_transact() returns). This ensures that the
+    // oldest needed changeset remains in the history, even when the history is
+    // implemented as a separate unversioned entity outside the Realm (i.e., the
+    // old implementation and ShortCircuitHistory in
+    // test_lang_Bind_helper.cpp). On the other hand, if it had been the case,
+    // that the history was always implemented as a versioned entity, that was
+    // part of the Realm state, then it would not have been necessary to retain
+    // the old read lock beyond this point.
+
+    {
+        version_type old_version = m_read_lock.m_version;
+        version_type new_version = new_read_lock.m_version;
+        ref_type new_top_ref = new_read_lock.m_top_ref;
+        size_t new_file_size = new_read_lock.m_file_size;
+        _impl::ChangesetInputStream in(hist, old_version, new_version);
+        m_group.advance_transact(new_top_ref, new_file_size, in); // Throws
+    }
+
+    g.release();
+    release_read_lock(m_read_lock);
+    m_read_lock = new_read_lock;
+
+    return true; // _impl::History::update_early_from_top_ref() was called
+}
+
+inline _impl::History* SharedGroup::get_history()
+{
+    using gf = _impl::GroupFriend;
+    if (Replication* repl = gf::get_replication(m_group))
+        return repl->get_history();
+    return 0;
+}
+
+inline int SharedGroup::get_file_format_version() const noexcept
+{
+    using gf = _impl::GroupFriend;
+    return gf::get_file_format_version(m_group);
+}
+
+
+// The purpose of this class is to give internal access to some, but
+// not all of the non-public parts of the SharedGroup class.
+class _impl::SharedGroupFriend {
+public:
+    static Group& get_group(SharedGroup& sg) noexcept
+    {
+        return sg.m_group;
+    }
+
+    template<class O>
+    static void advance_read(SharedGroup& sg, O* obs, SharedGroup::VersionID ver)
+    {
+        sg.advance_read(obs, ver); // Throws
+    }
+
+    template<class O>
+    static void promote_to_write(SharedGroup& sg, O* obs)
+    {
+        sg.promote_to_write(obs); // Throws
+    }
+
+    static SharedGroup::version_type commit_and_continue_as_read(SharedGroup& sg)
+    {
+        return sg.commit_and_continue_as_read(); // Throws
+    }
+
+    template<class O>
+    static void rollback_and_continue_as_read(SharedGroup& sg, O* obs)
+    {
+        sg.rollback_and_continue_as_read(obs); // Throws
+    }
+
+    static void async_daemon_open(SharedGroup& sg, const std::string& file)
+    {
+        bool no_create = true;
+        SharedGroup::DurabilityLevel durability = SharedGroup::durability_Async;
+        bool is_backend = true;
+        const char* encryption_key = nullptr;
+        bool allow_file_format_upgrade = false;
+        sg.do_open(file, no_create, durability, is_backend, encryption_key,
+                   allow_file_format_upgrade); // Throws
+    }
+
+    static int get_file_format_version(const SharedGroup& sg) noexcept
+    {
+        return sg.get_file_format_version();
+    }
+
+    static SharedGroup::version_type get_version_of_latest_snapshot(SharedGroup& sg)
+    {
+        return sg.get_version_of_latest_snapshot();
+    }
+
+    static SharedGroup::version_type get_version_of_bound_snapshot(const SharedGroup& sg) noexcept
+    {
+        return sg.get_version_of_bound_snapshot();
+    }
+};
+
+inline const Group& ReadTransaction::get_group() const noexcept
+{
+    using sgf = _impl::SharedGroupFriend;
+    return sgf::get_group(m_shared_group);
+}
+
+inline SharedGroup::version_type ReadTransaction::get_version() const noexcept
+{
+    using sgf = _impl::SharedGroupFriend;
+    return sgf::get_version_of_bound_snapshot(m_shared_group);
+}
+
+inline Group& WriteTransaction::get_group() const noexcept
+{
+    REALM_ASSERT(m_shared_group);
+    using sgf = _impl::SharedGroupFriend;
+    return sgf::get_group(*m_shared_group);
+}
+
+inline SharedGroup::version_type WriteTransaction::get_version() const noexcept
+{
+    using sgf = _impl::SharedGroupFriend;
+    return sgf::get_version_of_bound_snapshot(*m_shared_group);
+}
+
+} // namespace realm
+
+#endif // REALM_GROUP_SHARED_HPP
diff --git a/Pods/Realm/include/core/realm/group_writer.hpp b/Pods/Realm/include/core/realm/group_writer.hpp
new file mode 100644
index 0000000..81a02ea
--- /dev/null
+++ b/Pods/Realm/include/core/realm/group_writer.hpp
@@ -0,0 +1,169 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_GROUP_WRITER_HPP
+#define REALM_GROUP_WRITER_HPP
+
+#include <stdint.h> // unint8_t etc
+#include <utility>
+
+#include <realm/util/file.hpp>
+#include <realm/alloc.hpp>
+#include <realm/impl/array_writer.hpp>
+#include <realm/array_integer.hpp>
+
+
+namespace realm {
+
+// Pre-declarations
+class Group;
+class SlabAlloc;
+
+
+/// This class is not supposed to be reused for multiple write sessions. In
+/// particular, do not reuse it in case any of the functions throw.
+///
+/// FIXME: Move this class to namespace realm::_impl and to subdir src/realm/impl.
+class GroupWriter: public _impl::ArrayWriterBase {
+public:
+    // For groups in transactional mode (Group::m_is_shared), this constructor
+    // must be called while a write transaction is in progress.
+    //
+    // The constructor adds free-space tracking information to the specified
+    // group, if it is not already present (4th and 5th entry in
+    // Group::m_top). If the specified group is in transactional mode
+    // (Group::m_is_shared), the constructor also adds version tracking
+    // information to the group, if it is not already present (6th and 7th entry
+    // in Group::m_top).
+    GroupWriter(Group&);
+    ~GroupWriter();
+
+    void set_versions(uint64_t current, uint64_t read_lock) noexcept;
+
+    /// Write all changed array nodes into free space.
+    ///
+    /// Returns the new top ref. When in full durability mode, call
+    /// commit() with the returned top ref.
+    ref_type write_group();
+
+    /// Flush changes to physical medium, then write the new top ref
+    /// to the file header, then flush again. Pass the top ref
+    /// returned by write_group().
+    void commit(ref_type new_top_ref);
+
+    size_t get_file_size() const noexcept;
+
+    /// Write the specified chunk into free space.
+    void write(const char* data, size_t size);
+
+    ref_type write_array(const char*, size_t, uint32_t) override;
+
+#ifdef REALM_DEBUG
+    void dump();
+#endif
+
+private:
+    class MapWindow;
+    Group&     m_group;
+    SlabAlloc& m_alloc;
+    ArrayInteger m_free_positions; // 4th slot in Group::m_top
+    ArrayInteger m_free_lengths;   // 5th slot in Group::m_top
+    ArrayInteger m_free_versions;  // 6th slot in Group::m_top
+    uint64_t   m_current_version;
+    uint64_t   m_readlock_version;
+
+    // Currently cached memory mappings. We keep as many as 16 1MB windows
+    // open for writing. The allocator will favor sequential allocation
+    // from a modest number of windows, depending upon fragmentation, so
+    // 16 windows should be more than enough. If more than 16 windows are
+    // needed, the least recently used is sync'ed and closed to make room
+    // for a new one. The windows are kept in MRU (most recently used) order.
+    const static int num_map_windows = 16;
+    std::vector<MapWindow*> m_map_windows;
+
+    // Get a suitable memory mapping for later access:
+    // potentially adding it to the cache, potentially closing
+    // the least recently used and sync'ing it to disk
+    MapWindow* get_window(ref_type start_ref, size_t size);
+
+    // Sync all cached memory mappings
+    void sync_all_mappings();
+
+    // Merge adjacent chunks
+    void merge_free_space();
+
+    /// Allocate a chunk of free space of the specified size. The
+    /// specified size must be 8-byte aligned. Extend the file if
+    /// required. The returned chunk is removed from the amount of
+    /// remaing free space. The returned chunk is guaranteed to be
+    /// within a single contiguous memory mapping.
+    ///
+    /// \return The position within the database file of the allocated
+    /// chunk.
+    size_t get_free_space(size_t size);
+
+    /// Find a block of free space that is at least as big as the
+    /// specified size and which will allow an allocation that is mapped
+    /// inside a contiguous address range. The specified size does not
+    /// need to be 8-byte aligned. Extend the file if required.
+    /// The returned chunk is not removed from the amount of remaing
+    /// free space.
+    ///
+    /// \return A pair (`chunk_ndx`, `chunk_size`) where `chunk_ndx`
+    /// is the index of a chunk whose size is at least the requestd
+    /// size, and `chunk_size` is the size of that chunk.
+    std::pair<size_t, size_t> reserve_free_space(size_t size);
+
+    /// Search only a range of the free list for a block as big as the
+    /// specified size. Return a pair with index and size of the found chunk.
+    /// \param found indicates whether a suitable block was found.
+    std::pair<size_t, size_t>
+    search_free_space_in_part_of_freelist(size_t size, size_t begin,
+                                          size_t end, bool& found);
+
+    /// Extend the file to ensure that a chunk of free space of the
+    /// specified size is available. The specified size does not need
+    /// to be 8-byte aligned. This function guarantees that it will
+    /// add at most one entry to the free-lists.
+    ///
+    /// \return A pair (`chunk_ndx`, `chunk_size`) where `chunk_ndx`
+    /// is the index of a chunk whose size is at least the requestd
+    /// size, and `chunk_size` is the size of that chunk.
+    std::pair<size_t, size_t> extend_free_space(size_t requested_size);
+
+    void write_array_at(MapWindow* window, ref_type, const char* data, size_t size);
+    size_t split_freelist_chunk(size_t index, size_t start_pos,
+                                size_t alloc_pos, size_t chunk_size, bool is_shared);
+};
+
+
+
+
+// Implementation:
+
+inline void GroupWriter::set_versions(uint64_t current, uint64_t read_lock) noexcept
+{
+    REALM_ASSERT(read_lock <= current);
+    m_current_version  = current;
+    m_readlock_version = read_lock;
+}
+
+} // namespace realm
+
+#endif // REALM_GROUP_WRITER_HPP
diff --git a/Pods/Realm/include/core/realm/handover_defs.hpp b/Pods/Realm/include/core/realm/handover_defs.hpp
new file mode 100644
index 0000000..ec495ef
--- /dev/null
+++ b/Pods/Realm/include/core/realm/handover_defs.hpp
@@ -0,0 +1,76 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_HANDOVER_DEFS
+#define REALM_HANDOVER_DEFS
+
+#include <memory>
+#include <vector>
+
+namespace realm {
+
+enum class ConstSourcePayload { Copy, Stay };
+enum class MutableSourcePayload { Move };
+
+struct RowBaseHandoverPatch;
+struct TableViewHandoverPatch;
+
+struct TableHandoverPatch {
+    size_t m_table_num;
+};
+
+struct LinkViewHandoverPatch {
+    std::unique_ptr<TableHandoverPatch> m_table;
+    size_t m_col_num;
+    size_t m_row_ndx;
+};
+
+// Base class for handover patches for query nodes. Subclasses are declared in query_engine.hpp.
+struct QueryNodeHandoverPatch {
+    virtual ~QueryNodeHandoverPatch() = default;
+};
+
+using QueryNodeHandoverPatches = std::vector<std::unique_ptr<QueryNodeHandoverPatch>>;
+
+struct QueryHandoverPatch {
+    std::unique_ptr<TableHandoverPatch> m_table;
+    std::unique_ptr<TableViewHandoverPatch> table_view_data;
+    std::unique_ptr<LinkViewHandoverPatch> link_view_data;
+    QueryNodeHandoverPatches m_node_data;
+};
+
+struct TableViewHandoverPatch {
+    std::unique_ptr<TableHandoverPatch> m_table;
+    std::unique_ptr<TableHandoverPatch> linked_table;
+    std::unique_ptr<RowBaseHandoverPatch> linked_row;
+    bool was_in_sync;
+    QueryHandoverPatch query_patch;
+    std::unique_ptr<LinkViewHandoverPatch> linkview_patch;
+};
+
+
+struct RowBaseHandoverPatch {
+    std::unique_ptr<TableHandoverPatch> m_table;
+    size_t row_ndx;
+};
+
+
+} // end namespace Realm
+
+#endif
diff --git a/Pods/Realm/include/core/realm/history.hpp b/Pods/Realm/include/core/realm/history.hpp
new file mode 100644
index 0000000..40282f9
--- /dev/null
+++ b/Pods/Realm/include/core/realm/history.hpp
@@ -0,0 +1,36 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_HISTORY_HPP
+#define REALM_HISTORY_HPP
+
+#include <memory>
+#include <string>
+
+#include <realm/replication.hpp>
+
+
+namespace realm {
+
+std::unique_ptr<Replication> make_in_realm_history(const std::string& realm_path);
+
+} // namespace realm
+
+
+#endif // REALM_HISTORY_HPP
diff --git a/Pods/Realm/include/core/realm/impl/array_writer.hpp b/Pods/Realm/include/core/realm/impl/array_writer.hpp
new file mode 100644
index 0000000..35c5fed
--- /dev/null
+++ b/Pods/Realm/include/core/realm/impl/array_writer.hpp
@@ -0,0 +1,44 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+***************************************************************************/
+
+#ifndef REALM_ARRAY_WRITER_HPP
+#define REALM_ARRAY_WRITER_HPP
+
+#include <realm/alloc.hpp>
+
+namespace realm {
+namespace _impl {
+
+class ArrayWriterBase {
+public:
+    virtual ~ArrayWriterBase() {}
+
+    /// Write the specified array data and its checksum into free
+    /// space.
+    ///
+    /// Returns the ref (position in the target stream) of the written copy of
+    /// the specified array data.
+    virtual ref_type write_array(const char* data, size_t size, uint32_t checksum) = 0;
+};
+
+} // namespace impl_
+} // namespace realm
+
+#endif // REALM_ARRAY_WRITER_HPP
diff --git a/Pods/Realm/include/core/realm/impl/continuous_transactions_history.hpp b/Pods/Realm/include/core/realm/impl/continuous_transactions_history.hpp
new file mode 100644
index 0000000..4efe687
--- /dev/null
+++ b/Pods/Realm/include/core/realm/impl/continuous_transactions_history.hpp
@@ -0,0 +1,214 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+
+#ifndef REALM_IMPL_CONTINUOUS_TRANSACTIONS_HISTORY_HPP
+#define REALM_IMPL_CONTINUOUS_TRANSACTIONS_HISTORY_HPP
+
+#include <stdint.h>
+#include <memory>
+
+#include <realm/column_binary.hpp>
+
+namespace realm {
+
+class Group;
+
+namespace _impl {
+
+/// Read-only access to history of changesets as needed to enable continuous
+/// transactions.
+class History {
+public:
+    using version_type = uint_fast64_t;
+
+    /// May be called during a read transaction to gain early access to the
+    /// history as it appears in a new snapshot that succeeds the one bound in
+    /// the current read transaction.
+    ///
+    /// May also be called at other times as long as the caller owns a read lock
+    /// (SharedGroup::grab_read_lock()) on the Realm for the specified file size
+    /// and top ref, and the allocator is in a 'free space clean' state
+    /// (SlabAlloc::is_free_space_clean()).
+    ///
+    /// This function may cause a remapping of the Realm file
+    /// (SlabAlloc::remap()) if it needs to make the new snapshot fully visible
+    /// in memory.
+    ///
+    /// Note that this method of gaining early access to the history in a new
+    /// snaphot only gives read access. It does not allow for modifications of
+    /// the history or any other part of the new snapshot. For modifications to
+    /// be allowed, `Group::m_top` (the parent of the history) would first have
+    /// to be updated to reflect the new snapshot, but at that time we are no
+    /// longer in an 'early access' situation.
+    ///
+    /// This is not a problem from the point of view of this history interface,
+    /// as it only contains methods for reading from the history, but some
+    /// implementations will want to also provide for ways to modify the
+    /// history, but in those cases, modifications must occur only after the
+    /// Group accessor has been fully updated to reflect the new snapshot.
+    virtual void update_early_from_top_ref(version_type new_version, size_t new_file_size,
+                                           ref_type new_top_ref) = 0;
+
+    virtual void update_from_parent(version_type current_version) = 0;
+
+    /// Get all changesets between the specified versions. References to those
+    /// changesets will be made availble in successive entries of `buffer`. The
+    /// number of retreived changesets is exactly `end_version -
+    /// begin_version`. If this number is greater than zero, the changeset made
+    /// avaialable in `buffer[0]` is the one that brought the database from
+    /// `begin_version` to `begin_version + 1`.
+    ///
+    /// It is an error to specify a version (for \a begin_version or \a
+    /// end_version) that is outside the range [V,W] where V is the version that
+    /// immediately precedes the first changeset available in the history as the
+    /// history appears in the **latest** available snapshot, and W is the
+    /// versionm that immediately succeeds the last changeset available in the
+    /// history as the history appears in the snapshot bound to the **current**
+    /// transaction. This restriction is necessary to allow for different kinds
+    /// of implementations of the history (separate standalone history or
+    /// history as part of versioned Realm state).
+    ///
+    /// The calee retains ownership of the memory referenced by those entries,
+    /// i.e., the memory referenced by `buffer[i].changeset` is **not** handed
+    /// over to the caller.
+    ///
+    /// This function may be called only during a transaction (prior to
+    /// initiation of commit operation), and only after a successfull invocation
+    /// of update_early_from_top_ref(). In that case, the caller may assume that
+    /// the memory references stay valid for the remainder of the transaction
+    /// (up until initiation of the commit operation).
+    virtual void get_changesets(version_type begin_version, version_type end_version,
+                                BinaryData* buffer) const noexcept = 0;
+
+    /// \brief Specify the version of the oldest bound snapshot.
+    ///
+    /// This function must be called by the associated SharedGroup object during
+    /// each successfully committed write transaction. It must be called before
+    /// the transaction is finalized (Replication::finalize_commit()) or aborted
+    /// (Replication::abort_transact()), but after the initiation of the commit
+    /// operation (Replication::prepare_commit()). This allows history
+    /// implementations to add new history entries before triming off old ones,
+    /// and this, in turn, guarantees that the history never becomes empty,
+    /// except in the initial empty Realm state.
+    ///
+    /// The caller must pass the version (\a version) of the oldest snapshot
+    /// that is currently (or was recently) bound via a transaction of the
+    /// current session. This gives the history implementation an opportunity to
+    /// trim off leading (early) history entries.
+    ///
+    /// Since this function must be called during a write transaction, there
+    /// will always be at least one snapshot that is currently bound via a
+    /// transaction.
+    ///
+    /// The caller must guarantee that the passed version (\a version) is less
+    /// than or equal to `begin_version` in all future invocations of
+    /// get_changesets().
+    ///
+    /// The caller is allowed to pass a version that is less than the version
+    /// passed in a preceeding invocation.
+    ///
+    /// This function should be called as late as possible, to maximize the
+    /// trimming opportunity, but at a time where the write transaction is still
+    /// open for additional modifications. This is necessary because some types
+    /// of histories are stored inside the Realm file.
+    virtual void set_oldest_bound_version(version_type version) = 0;
+
+    /// Get the list of uncommited changes accumulated so far in the current
+    /// write transaction.
+    ///
+    /// The callee retains ownership of the referenced memory. The ownership is
+    /// not handed over the the caller.
+    ///
+    /// This function may be called only during a write transaction (prior to
+    /// initiation of commit operation). In that case, the caller may assume that the
+    /// returned memory reference stays valid for the remainder of the transaction (up
+    /// until initiation of the commit operation).
+    virtual BinaryData get_uncommitted_changes() noexcept = 0;
+
+#ifdef REALM_DEBUG
+    virtual void verify() const = 0;
+#endif
+
+    virtual ~History() noexcept {}
+};
+
+
+/// This class is intended to eventually become a basis for implementing the
+/// Replication API for the purpose of supporting continuous transactions. That
+/// is, its purpose is to replace the current implementation in commit_log.cpp,
+/// which places the history in separate files.
+///
+/// By ensuring that the root node of the history is correctly configured with
+/// Group::m_top as its parent, this class allows for modifications of the
+/// history as long as those modifications happen after the remainder of the
+/// Group accessor is updated to reflect the new snapshot (see
+/// History::update_early_from_top_ref()).
+class InRealmHistory: public History {
+public:
+    void initialize(Group&);
+
+    /// Must never be called more than once per transaction. Returns the version
+    /// produced by the added changeset.
+    version_type add_changeset(BinaryData);
+
+    void update_early_from_top_ref(version_type, size_t, ref_type) override;
+    void update_from_parent(version_type) override;
+    void get_changesets(version_type, version_type, BinaryData*) const noexcept override;
+    void set_oldest_bound_version(version_type) override;
+
+#ifdef REALM_DEBUG
+    void verify() const override;
+#endif
+
+private:
+    Group* m_group = 0;
+
+    /// Version on which the first changeset in the history is based, or if the
+    /// history is empty, the version associatede with currently bound
+    /// snapshot. In general, the version associatede with currently bound
+    /// snapshot is equal to `m_base_version + m_size`, but after
+    /// add_changeset() is called, it is equal to one minus that.
+    version_type m_base_version;
+
+    /// Current number of entries in the history. A cache of
+    /// `m_changesets->size()`.
+    size_t m_size;
+
+    /// A list of changesets, one for each entry in the history. If null, the
+    /// history is empty.
+    ///
+    /// FIXME: Ideally, the B+tree accessor below should have been just
+    /// Bptree<BinaryData>, but Bptree<BinaryData> seems to not allow that yet.
+    ///
+    /// FIXME: The memory-wise indirection is an unfortunate consequence of the
+    /// fact that it is impossible to construct a BinaryColumn without already
+    /// having a ref to a valid underlying node structure. This, in turn, is an
+    /// unfortunate consequence of the fact that a column accessor contains a
+    /// dynamically allocated root node accessor, and the type of the required
+    /// root node accessor depends on the size of the B+-tree.
+    std::unique_ptr<BinaryColumn> m_changesets;
+
+    void update_from_ref(ref_type, version_type);
+};
+
+} // namespace _impl
+} // namespace realm
+
+#endif // REALM_IMPL_CONTINUOUS_TRANSACTIONS_HISTORY_HPP
diff --git a/Pods/Realm/include/core/realm/impl/destroy_guard.hpp b/Pods/Realm/include/core/realm/impl/destroy_guard.hpp
new file mode 100644
index 0000000..a8b8cf7
--- /dev/null
+++ b/Pods/Realm/include/core/realm/impl/destroy_guard.hpp
@@ -0,0 +1,231 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+
+#ifndef REALM_IMPL_DESTROY_GUARD_HPP
+#define REALM_IMPL_DESTROY_GUARD_HPP
+
+#include <realm/util/features.h>
+#include <realm/array.hpp>
+
+namespace realm {
+namespace _impl {
+
+
+/// Calls `ptr->destroy()` if the guarded pointer (`ptr`) is not null
+/// when the guard is destroyed. For arrays (`T` = `Array`) this means
+/// that the array is destroyed in a shallow fashion. See
+/// `DeepArrayDestroyGuard` for an alternative.
+template<class T>
+class DestroyGuard {
+public:
+    DestroyGuard() noexcept;
+
+    DestroyGuard(T*) noexcept;
+
+    ~DestroyGuard() noexcept;
+
+    void reset(T*) noexcept;
+
+    T* get() const noexcept;
+
+    T* release() noexcept;
+
+private:
+    T* m_ptr;
+};
+
+using ShallowArrayDestroyGuard = DestroyGuard<Array>;
+
+
+/// Calls `ptr->destroy_deep()` if the guarded Array pointer (`ptr`)
+/// is not null when the guard is destroyed.
+class DeepArrayDestroyGuard {
+public:
+    DeepArrayDestroyGuard() noexcept;
+
+    DeepArrayDestroyGuard(Array*) noexcept;
+
+    ~DeepArrayDestroyGuard() noexcept;
+
+    void reset(Array*) noexcept;
+
+    Array* get() const noexcept;
+
+    Array* release() noexcept;
+
+private:
+    Array* m_ptr;
+};
+
+
+/// Calls `Array::destroy_deep(ref, alloc)` if the guarded 'ref'
+/// (`ref`) is not zero when the guard is destroyed.
+class DeepArrayRefDestroyGuard {
+public:
+    DeepArrayRefDestroyGuard(Allocator&) noexcept;
+
+    DeepArrayRefDestroyGuard(ref_type, Allocator&) noexcept;
+
+    ~DeepArrayRefDestroyGuard() noexcept;
+
+    void reset(ref_type) noexcept;
+
+    ref_type get() const noexcept;
+
+    ref_type release() noexcept;
+
+private:
+    ref_type m_ref;
+    Allocator& m_alloc;
+};
+
+
+
+
+
+// Implementation:
+
+// DestroyGuard<T>
+
+template<class T>
+inline DestroyGuard<T>::DestroyGuard() noexcept:
+    m_ptr(nullptr)
+{
+}
+
+template<class T>
+inline DestroyGuard<T>::DestroyGuard(T* ptr) noexcept:
+    m_ptr(ptr)
+{
+}
+
+template<class T>
+inline DestroyGuard<T>::~DestroyGuard() noexcept
+{
+    if (m_ptr)
+        m_ptr->destroy();
+}
+
+template<class T>
+inline void DestroyGuard<T>::reset(T* ptr) noexcept
+{
+    if (m_ptr)
+        m_ptr->destroy();
+    m_ptr = ptr;
+}
+
+template<class T>
+inline T* DestroyGuard<T>::get() const noexcept
+{
+    return m_ptr;
+}
+
+template<class T>
+inline T* DestroyGuard<T>::release() noexcept
+{
+    T* ptr = m_ptr;
+    m_ptr = nullptr;
+    return ptr;
+}
+
+
+// DeepArrayDestroyGuard
+
+inline DeepArrayDestroyGuard::DeepArrayDestroyGuard() noexcept:
+    m_ptr(nullptr)
+{
+}
+
+inline DeepArrayDestroyGuard::DeepArrayDestroyGuard(Array* ptr) noexcept:
+    m_ptr(ptr)
+{
+}
+
+inline DeepArrayDestroyGuard::~DeepArrayDestroyGuard() noexcept
+{
+    if (m_ptr)
+        m_ptr->destroy_deep();
+}
+
+inline void DeepArrayDestroyGuard::reset(Array* ptr) noexcept
+{
+    if (m_ptr)
+        m_ptr->destroy_deep();
+    m_ptr = ptr;
+}
+
+inline Array* DeepArrayDestroyGuard::get() const noexcept
+{
+    return m_ptr;
+}
+
+inline Array* DeepArrayDestroyGuard::release() noexcept
+{
+    Array* ptr = m_ptr;
+    m_ptr = nullptr;
+    return ptr;
+}
+
+
+// DeepArrayRefDestroyGuard
+
+inline DeepArrayRefDestroyGuard::DeepArrayRefDestroyGuard(Allocator& alloc) noexcept:
+    m_ref(0),
+    m_alloc(alloc)
+{
+}
+
+inline DeepArrayRefDestroyGuard::DeepArrayRefDestroyGuard(ref_type ref,
+                                                          Allocator& alloc) noexcept:
+    m_ref(ref),
+    m_alloc(alloc)
+{
+}
+
+inline DeepArrayRefDestroyGuard::~DeepArrayRefDestroyGuard() noexcept
+{
+    if (m_ref)
+        Array::destroy_deep(m_ref, m_alloc);
+}
+
+inline void DeepArrayRefDestroyGuard::reset(ref_type ref) noexcept
+{
+    if (m_ref)
+        Array::destroy_deep(m_ref, m_alloc);
+    m_ref = ref;
+}
+
+inline ref_type DeepArrayRefDestroyGuard::get() const noexcept
+{
+    return m_ref;
+}
+
+inline ref_type DeepArrayRefDestroyGuard::release() noexcept
+{
+    ref_type ref = m_ref;
+    m_ref = 0;
+    return ref;
+}
+
+
+} // namespace _impl
+} // namespace realm
+
+#endif // REALM_IMPL_DESTROY_GUARD_HPP
diff --git a/Pods/Realm/include/core/realm/impl/input_stream.hpp b/Pods/Realm/include/core/realm/impl/input_stream.hpp
new file mode 100644
index 0000000..19725d5
--- /dev/null
+++ b/Pods/Realm/include/core/realm/impl/input_stream.hpp
@@ -0,0 +1,242 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+
+#ifndef REALM_IMPL_INPUT_STREAM_HPP
+#define REALM_IMPL_INPUT_STREAM_HPP
+
+#include <algorithm>
+
+#include <realm/binary_data.hpp>
+#include <realm/impl/continuous_transactions_history.hpp>
+
+
+namespace realm {
+namespace _impl {
+
+
+class InputStream {
+public:
+    /// Read bytes from this input stream and place them in the specified
+    /// buffer. The returned value is the actual number of bytes that were read,
+    /// and this is some number `n` such that `n <= min(size, m)` where `m` is
+    /// the number of bytes that could have been read from this stream before
+    /// reaching its end. Also, `n` cannot be zero unless `m` or `size` is
+    /// zero. The intention is that `size` should be non-zero, a the return
+    /// value used as the end-of-input indicator.
+    ///
+    /// Implementations are only allowed to block (put the calling thread to
+    /// sleep) up until the point in time where the first byte can be made
+    /// availble.
+    virtual size_t read(char* buffer, size_t size) = 0;
+
+    virtual ~InputStream() noexcept {}
+};
+
+
+class SimpleInputStream: public InputStream {
+public:
+    SimpleInputStream(const char* data, size_t size) noexcept:
+        m_ptr(data),
+        m_end(data + size)
+    {
+    }
+    size_t read(char* buffer, size_t size) override
+    {
+        size_t n = std::min(size, size_t(m_end-m_ptr));
+        const char* begin = m_ptr;
+        m_ptr += n;
+        const char* end = m_ptr;
+        std::copy(begin, end, buffer);
+        return n;
+    }
+private:
+    const char* m_ptr;
+    const char* const m_end;
+};
+
+
+class NoCopyInputStream {
+public:
+    /// \return the number of accessible bytes.
+    /// A value of zero indicates end-of-input.
+    /// For non-zero return value, \a begin and \a end are
+    /// updated to reflect the start and limit of a
+    /// contiguous memory chunk.
+    virtual size_t next_block(const char*& begin, const char*& end) = 0;
+
+    virtual ~NoCopyInputStream() noexcept {}
+};
+
+
+class NoCopyInputStreamAdaptor: public NoCopyInputStream {
+public:
+    NoCopyInputStreamAdaptor(InputStream& in, char* buffer, size_t buffer_size) noexcept:
+        m_in(in),
+        m_buffer(buffer),
+        m_buffer_size(buffer_size)
+    {
+    }
+    size_t next_block(const char*& begin, const char*& end) override
+    {
+        size_t n = m_in.read(m_buffer, m_buffer_size);
+        begin = m_buffer;
+        end = m_buffer + n;
+        return n;
+    }
+private:
+    InputStream& m_in;
+    char* m_buffer;
+    size_t m_buffer_size;
+};
+
+
+class SimpleNoCopyInputStream: public NoCopyInputStream {
+public:
+    SimpleNoCopyInputStream(const char* data, size_t size):
+        m_data(data),
+        m_size(size)
+    {
+    }
+
+    size_t next_block(const char*& begin, const char*& end) override
+    {
+        if (m_size == 0)
+            return 0;
+        size_t size = m_size;
+        begin = m_data;
+        end = m_data + size;
+        m_size = 0;
+        return size;
+    }
+
+private:
+    const char* m_data;
+    size_t m_size;
+};
+
+class MultiLogNoCopyInputStream: public NoCopyInputStream {
+public:
+    MultiLogNoCopyInputStream(const BinaryData* logs_begin, const BinaryData* logs_end):
+        m_logs_begin(logs_begin), m_logs_end(logs_end)
+    {
+        if (m_logs_begin != m_logs_end)
+            m_curr_buf_remaining_size = m_logs_begin->size();
+    }
+
+    size_t read(char* buffer, size_t size)
+    {
+        if (m_logs_begin == m_logs_end)
+            return 0;
+        for (;;) {
+            if (m_curr_buf_remaining_size > 0) {
+                size_t offset = m_logs_begin->size() - m_curr_buf_remaining_size;
+                const char* data = m_logs_begin->data() + offset;
+                size_t size_2 = std::min(m_curr_buf_remaining_size, size);
+                m_curr_buf_remaining_size -= size_2;
+                // FIXME: Eliminate the need for copying by changing the API of
+                // Replication::InputStream such that blocks can be handed over
+                // without copying. This is a straight forward change, but the
+                // result is going to be more complicated and less conventional.
+                std::copy(data, data + size_2, buffer);
+                return size_2;
+            }
+
+            ++m_logs_begin;
+            if (m_logs_begin == m_logs_end)
+                return 0;
+            m_curr_buf_remaining_size = m_logs_begin->size();
+        }
+    }
+
+    size_t next_block(const char*& begin, const char*& end) override
+    {
+        while (m_logs_begin < m_logs_end) {
+            size_t result = m_logs_begin->size();
+            const char* data = m_logs_begin->data();
+            m_logs_begin++;
+            if (result == 0)
+                continue; // skip empty blocks
+            begin = data;
+            end = data + result;
+            return result;
+        }
+        return 0;
+    }
+
+private:
+    const BinaryData* m_logs_begin;
+    const BinaryData* m_logs_end;
+    size_t m_curr_buf_remaining_size;
+};
+
+
+class ChangesetInputStream: public NoCopyInputStream {
+public:
+    using version_type = History::version_type;
+    ChangesetInputStream(History&, version_type begin_version, version_type end_version);
+    size_t next_block(const char*& begin, const char*& end) override;
+private:
+    History& m_history;
+    version_type m_begin_version, m_end_version;
+    BinaryData m_changesets[8]; // Buffer
+    BinaryData* m_changesets_begin = 0;
+    BinaryData* m_changesets_end = 0;
+};
+
+
+inline ChangesetInputStream::ChangesetInputStream(History& hist, version_type begin_version,
+                                                  version_type end_version):
+    m_history(hist),
+    m_begin_version(begin_version),
+    m_end_version(end_version)
+{
+}
+
+inline size_t ChangesetInputStream::next_block(const char*& begin, const char*& end)
+{
+    for (;;) {
+        if (REALM_UNLIKELY(m_changesets_begin == m_changesets_end)) {
+            if (m_begin_version == m_end_version)
+                return 0; // End of input
+            version_type n = sizeof m_changesets / sizeof m_changesets[0];
+            version_type avail = m_end_version - m_begin_version;
+            if (n > avail)
+                n = avail;
+            version_type end_version = m_begin_version + n;
+            m_history.get_changesets(m_begin_version, end_version, m_changesets);
+            m_begin_version = end_version;
+            m_changesets_begin = m_changesets;
+            m_changesets_end = m_changesets_begin + n;
+        }
+
+        BinaryData changeset = *m_changesets_begin++;
+        if (changeset.size() > 0) {
+            begin = changeset.data();
+            end   = changeset.data() + changeset.size();
+            return changeset.size();
+        }
+    }
+}
+
+
+} // namespace _impl
+} // namespace realm
+
+#endif // REALM_IMPL_INPUT_STREAM_HPP
diff --git a/Pods/Realm/include/core/realm/impl/output_stream.hpp b/Pods/Realm/include/core/realm/impl/output_stream.hpp
new file mode 100644
index 0000000..c49f562
--- /dev/null
+++ b/Pods/Realm/include/core/realm/impl/output_stream.hpp
@@ -0,0 +1,79 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_IMPL_OUTPUT_STREAM_HPP
+#define REALM_IMPL_OUTPUT_STREAM_HPP
+
+#include <cstddef>
+#include <ostream>
+
+#include <stdint.h>
+
+#include <realm/util/features.h>
+
+#include <realm/impl/array_writer.hpp>
+
+namespace realm {
+namespace _impl {
+
+
+class OutputStream: public ArrayWriterBase {
+public:
+    OutputStream(std::ostream&);
+    ~OutputStream() noexcept;
+
+    ref_type get_ref_of_next_array() const noexcept;
+
+    void write(const char* data, size_t size);
+
+    ref_type write_array(const char* data, size_t size, uint32_t checksum) override;
+
+private:
+    ref_type m_next_ref;
+    std::ostream& m_out;
+
+    void do_write(const char* data, size_t size);
+};
+
+
+
+
+
+// Implementation:
+
+inline OutputStream::OutputStream(std::ostream& out):
+    m_next_ref(0),
+    m_out(out)
+{
+}
+
+inline OutputStream::~OutputStream() noexcept
+{
+}
+
+inline size_t OutputStream::get_ref_of_next_array() const noexcept
+{
+    return m_next_ref;
+}
+
+
+} // namespace _impl
+} // namespace realm
+
+#endif // REALM_IMPL_OUTPUT_STREAM_HPP
diff --git a/Pods/Realm/include/core/realm/impl/sequential_getter.hpp b/Pods/Realm/include/core/realm/impl/sequential_getter.hpp
new file mode 100644
index 0000000..f14557d
--- /dev/null
+++ b/Pods/Realm/include/core/realm/impl/sequential_getter.hpp
@@ -0,0 +1,117 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+
+#ifndef REALM_IMPL_SEQUENTIAL_GETTER_HPP
+#define REALM_IMPL_SEQUENTIAL_GETTER_HPP
+
+namespace realm {
+
+class SequentialGetterBase {
+public:
+    virtual ~SequentialGetterBase() noexcept {}
+};
+
+template<class ColType>
+class SequentialGetter : public SequentialGetterBase {
+public:
+    using T = typename ColType::value_type;
+    using ArrayType = typename ColType::LeafType;
+
+    SequentialGetter() {}
+
+    SequentialGetter(const Table& table, size_t column_ndx)
+    {
+        if (column_ndx != not_found)
+            m_column = static_cast<const ColType*>(&table.get_column_base(column_ndx));
+        init(m_column);
+    }
+
+    SequentialGetter(const ColType* column)
+    {
+        init(column);
+    }
+
+    ~SequentialGetter() noexcept override {}
+
+    void init(const ColType* column)
+    {
+        m_array_ptr.reset(); // Explicitly destroy the old one first, because we're reusing the memory.
+        m_array_ptr.reset(new(&m_leaf_accessor_storage) ArrayType(column->get_alloc()));
+        m_column = column;
+        m_leaf_end = 0;
+    }
+
+    REALM_FORCEINLINE bool cache_next(size_t index)
+    {
+        // Return whether or not leaf array has changed (could be useful to know for caller)
+        if (index >= m_leaf_end || index < m_leaf_start) {
+            typename ColType::LeafInfo leaf { &m_leaf_ptr, m_array_ptr.get() };
+            size_t ndx_in_leaf;
+            m_column->get_leaf(index, ndx_in_leaf, leaf);
+            m_leaf_start = index - ndx_in_leaf;
+            const size_t leaf_size = m_leaf_ptr->size();
+            m_leaf_end = m_leaf_start + leaf_size;
+            return true;
+        }
+        return false;
+    }
+
+
+    REALM_FORCEINLINE T get_next(size_t index)
+    {
+#ifdef _MSC_VER
+#pragma warning(push)
+#pragma warning(disable:4800)   // Disable the Microsoft warning about bool performance issue.
+#endif
+
+        cache_next(index);
+        T av = m_leaf_ptr->get(index - m_leaf_start);
+        return av;
+
+#ifdef _MSC_VER
+#pragma warning(pop)
+#endif
+    }
+
+    size_t local_end(size_t global_end)
+    {
+        if (global_end > m_leaf_end)
+            return m_leaf_end - m_leaf_start;
+        else
+            return global_end - m_leaf_start;
+    }
+
+    size_t m_leaf_start;
+    size_t m_leaf_end;
+    const ColType* m_column;
+
+    const ArrayType* m_leaf_ptr = nullptr;
+private:
+    // Leaf cache for when the root of the column is not a leaf.
+    // This dog and pony show is because Array has a reference to Allocator internally,
+    // but we need to be able to transfer queries between contexts, so init() reinitializes
+    // the leaf cache in the context of the current column.
+    typename std::aligned_storage<sizeof(ArrayType), alignof(ArrayType)>::type m_leaf_accessor_storage;
+    std::unique_ptr<ArrayType, PlacementDelete> m_array_ptr;
+};
+
+} // namespace realm
+
+#endif // REALM_IMPL_SEQUENTIAL_GETTER_HPP
diff --git a/Pods/Realm/include/core/realm/impl/simulated_failure.hpp b/Pods/Realm/include/core/realm/impl/simulated_failure.hpp
new file mode 100644
index 0000000..6bc6ed5
--- /dev/null
+++ b/Pods/Realm/include/core/realm/impl/simulated_failure.hpp
@@ -0,0 +1,218 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+
+#ifndef REALM_IMPL_SIMULATED_FAILURE_HPP
+#define REALM_IMPL_SIMULATED_FAILURE_HPP
+
+#include <stdint.h>
+#include <system_error>
+
+#include <realm/util/features.h>
+
+#ifdef REALM_DEBUG
+#  define REALM_ENABLE_SIMULATED_FAILURE
+#endif
+
+namespace realm {
+namespace _impl {
+
+class SimulatedFailure: public std::system_error {
+public:
+    enum FailureType {
+        generic,
+        slab_alloc__reset_free_space_tracking,
+        slab_alloc__remap,
+        shared_group__grow_reader_mapping,
+        sync_client__read_head,
+        sync_server__read_head,
+        _num_failure_types
+    };
+
+    class OneShotPrimeGuard;
+    class RandomPrimeGuard;
+
+    /// Prime the specified failure type on the calling thread for triggering
+    /// once.
+    static void prime_one_shot(FailureType);
+
+    /// Prime the specified failure type on the calling thread for triggering
+    /// randomly \a n out of \a m times.
+    static void prime_random(FailureType, int n, int m, uint_fast64_t seed = 0);
+
+    /// Unprime the specified failure type on the calling thread.
+    static void unprime(FailureType) noexcept;
+
+    /// Returns true according to the mode of priming of the specified failure
+    /// type on the calling thread, but only if REALM_ENABLE_SIMULATED_FAILURE
+    /// was defined during compilation. If REALM_ENABLE_SIMULATED_FAILURE was
+    /// not defined, this function always return false.
+    static bool check_trigger(FailureType) noexcept;
+
+    /// The specified error code is set to `make_error_code(failure_type)` if
+    /// check_trigger() returns true. Otherwise it is set to
+    /// `std::error_code()`. Returns a copy of the updated error code.
+    static std::error_code trigger(FailureType failure_type, std::error_code&) noexcept;
+
+    /// Throws SimulatedFailure if check_trigger() returns true. The exception
+    /// will be constructed with an error code equal to
+    /// `make_error_code(failure_type)`.
+    static void trigger(FailureType failure_type);
+
+    /// Returns true when, and only when REALM_ENABLE_SIMULATED_FAILURE was
+    /// defined during compilation.
+    static constexpr bool is_enabled();
+
+    SimulatedFailure(std::error_code);
+
+private:
+#ifdef REALM_ENABLE_SIMULATED_FAILURE
+    static void do_prime_one_shot(FailureType);
+    static void do_prime_random(FailureType, int n, int m, uint_fast64_t seed);
+    static void do_unprime(FailureType) noexcept;
+    static bool do_check_trigger(FailureType) noexcept;
+#endif
+};
+
+std::error_code make_error_code(SimulatedFailure::FailureType) noexcept;
+
+
+class SimulatedFailure::OneShotPrimeGuard {
+public:
+    OneShotPrimeGuard(FailureType);
+    ~OneShotPrimeGuard() noexcept;
+private:
+    const FailureType m_type;
+};
+
+
+class SimulatedFailure::RandomPrimeGuard {
+public:
+    RandomPrimeGuard(FailureType, int n, int m, uint_fast64_t seed = 0);
+    ~RandomPrimeGuard() noexcept;
+private:
+    const FailureType m_type;
+};
+
+
+
+
+
+// Implementation
+
+inline void SimulatedFailure::prime_one_shot(FailureType failure_type)
+{
+#ifdef REALM_ENABLE_SIMULATED_FAILURE
+    do_prime_one_shot(failure_type);
+#else
+    static_cast<void>(failure_type);
+#endif
+}
+
+inline void SimulatedFailure::prime_random(FailureType failure_type, int n, int m,
+                                           uint_fast64_t seed)
+{
+#ifdef REALM_ENABLE_SIMULATED_FAILURE
+    do_prime_random(failure_type, n, m, seed);
+#else
+    static_cast<void>(failure_type);
+    static_cast<void>(n);
+    static_cast<void>(m);
+    static_cast<void>(seed);
+#endif
+}
+
+inline void SimulatedFailure::unprime(FailureType failure_type) noexcept
+{
+#ifdef REALM_ENABLE_SIMULATED_FAILURE
+    do_unprime(failure_type);
+#else
+    static_cast<void>(failure_type);
+#endif
+}
+
+inline bool SimulatedFailure::check_trigger(FailureType failure_type) noexcept
+{
+#ifdef REALM_ENABLE_SIMULATED_FAILURE
+    return do_check_trigger(failure_type);
+#else
+    static_cast<void>(failure_type);
+    return false;
+#endif
+}
+
+inline std::error_code SimulatedFailure::trigger(FailureType failure_type,
+                                                 std::error_code& ec) noexcept
+{
+    if (check_trigger(failure_type)) {
+        ec = make_error_code(failure_type);
+    }
+    else {
+        ec = std::error_code();
+    }
+    return ec;
+}
+
+inline void SimulatedFailure::trigger(FailureType failure_type)
+{
+    if (check_trigger(failure_type))
+        throw SimulatedFailure(make_error_code(failure_type));
+}
+
+inline constexpr bool SimulatedFailure::is_enabled()
+{
+#ifdef REALM_ENABLE_SIMULATED_FAILURE
+    return true;
+#else
+    return false;
+#endif
+}
+
+inline SimulatedFailure::SimulatedFailure(std::error_code ec):
+    std::system_error(ec)
+{
+}
+
+inline SimulatedFailure::OneShotPrimeGuard::OneShotPrimeGuard(FailureType failure_type):
+    m_type(failure_type)
+{
+    prime_one_shot(m_type);
+}
+
+inline SimulatedFailure::OneShotPrimeGuard::~OneShotPrimeGuard() noexcept
+{
+    unprime(m_type);
+}
+
+inline SimulatedFailure::RandomPrimeGuard::RandomPrimeGuard(FailureType failure_type, int n, int m,
+                                                            uint_fast64_t seed):
+    m_type(failure_type)
+{
+    prime_random(m_type, n, m, seed);
+}
+
+inline SimulatedFailure::RandomPrimeGuard::~RandomPrimeGuard() noexcept
+{
+    unprime(m_type);
+}
+
+} // namespace _impl
+} // namespace realm
+
+#endif // REALM_IMPL_SIMULATED_FAILURE_HPP
diff --git a/Pods/Realm/include/core/realm/impl/transact_log.hpp b/Pods/Realm/include/core/realm/impl/transact_log.hpp
new file mode 100644
index 0000000..385b4dc
--- /dev/null
+++ b/Pods/Realm/include/core/realm/impl/transact_log.hpp
@@ -0,0 +1,2640 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+
+#ifndef REALM_IMPL_TRANSACT_LOG_HPP
+#define REALM_IMPL_TRANSACT_LOG_HPP
+
+#include <stdexcept>
+
+#include <realm/string_data.hpp>
+#include <realm/data_type.hpp>
+#include <realm/binary_data.hpp>
+#include <realm/olddatetime.hpp>
+#include <realm/mixed.hpp>
+#include <realm/util/safe_int_ops.hpp>
+#include <realm/util/buffer.hpp>
+#include <realm/util/string_buffer.hpp>
+#include <realm/util/tuple.hpp>
+#include <realm/impl/input_stream.hpp>
+
+#include <realm/group.hpp>
+#include <realm/descriptor.hpp>
+
+namespace realm {
+namespace _impl {
+
+/// Transaction log instruction encoding
+enum Instruction {
+    instr_InsertGroupLevelTable =  1,
+    instr_EraseGroupLevelTable  =  2, // Remove columnless table from group
+    instr_RenameGroupLevelTable =  3,
+    instr_MoveGroupLevelTable   = 45,
+    instr_SelectTable           =  4,
+    instr_SetInt                =  5,
+    instr_SetIntUnique          = 31,
+    instr_SetBool               =  6,
+    instr_SetFloat              =  7,
+    instr_SetDouble             =  8,
+    instr_SetString             =  9,
+    instr_SetStringUnique       = 32,
+    instr_SetBinary             = 10,
+    instr_SetOldDateTime        = 11,
+    instr_SetTimestamp          = 48,
+    instr_SetTable              = 12,
+    instr_SetMixed              = 13,
+    instr_SetLink               = 14,
+    instr_NullifyLink           = 15, // Set link to null due to target being erased
+    instr_SetNull               = 16,
+    instr_InsertSubstring       = 43,                                                      // FIXME: Reenumerate
+    instr_EraseFromString       = 44,                                                      // FIXME: Reenumerate
+    instr_InsertEmptyRows       = 17,
+    instr_EraseRows             = 18, // Remove (multiple) rows
+    instr_SwapRows              = 19,
+    instr_ChangeLinkTargets     = 47, // Replace links pointing to row A with links to row B
+    instr_ClearTable            = 20, // Remove all rows in selected table
+    instr_OptimizeTable         = 21,
+    instr_SelectDescriptor      = 22, // Select descriptor from currently selected root table
+    instr_InsertColumn          = 23, // Insert new non-nullable column into to selected descriptor (nullable is instr_InsertNullableColumn)
+    instr_InsertLinkColumn      = 24, // do, but for a link-type column
+    instr_InsertNullableColumn  = 25, // Insert nullable column
+    instr_EraseColumn           = 26, // Remove column from selected descriptor
+    instr_EraseLinkColumn       = 27, // Remove link-type column from selected descriptor
+    instr_RenameColumn          = 28, // Rename column in selected descriptor
+    instr_MoveColumn            = 46, // Move column in selected descriptor                // FIXME: Reenumerate
+    instr_AddSearchIndex        = 29, // Add a search index to a column
+    instr_RemoveSearchIndex     = 30, // Remove a search index from a column
+    instr_SetLinkType           = 33, // Strong/weak
+    instr_SelectLinkList        = 34,
+    instr_LinkListSet           = 35, // Assign to link list entry
+    instr_LinkListInsert        = 36, // Insert entry into link list
+    instr_LinkListMove          = 37, // Move an entry within a link list
+    instr_LinkListSwap          = 38, // Swap two entries within a link list
+    instr_LinkListErase         = 39, // Remove an entry from a link list
+    instr_LinkListNullify       = 40, // Remove an entry from a link list due to linked row being erased
+    instr_LinkListClear         = 41, // Ramove all entries from a link list
+    instr_LinkListSetAll        = 42, // Assign to link list entry
+};
+
+
+class TransactLogStream {
+public:
+    /// Ensure contiguous free space in the transaction log
+    /// buffer. This method must update `out_free_begin`
+    /// and `out_free_end` such that they refer to a chunk
+    /// of free space whose size is at least \a n.
+    ///
+    /// \param n The required amount of contiguous free space. Must be
+    /// small (probably not greater than 1024)
+    /// \param n Must be small (probably not greater than 1024)
+    virtual void transact_log_reserve(size_t size, char** out_free_begin, char** out_free_end) = 0;
+
+    /// Copy the specified data into the transaction log buffer. This
+    /// function should be called only when the specified data does
+    /// not fit inside the chunk of free space currently referred to
+    /// by `out_free_begin` and `out_free_end`.
+    ///
+    /// This method must update `out_begin` and
+    /// `out_end` such that, upon return, they still
+    /// refer to a (possibly empty) chunk of free space.
+    virtual void transact_log_append(const char* data, size_t size, char** out_free_begin, char** out_free_end) = 0;
+};
+
+class TransactLogBufferStream: public TransactLogStream {
+public:
+    void transact_log_reserve(size_t size, char** out_free_begin, char** out_free_end) override;
+    void transact_log_append(const char* data, size_t size, char** out_free_begin, char** out_free_end) override;
+
+    const char* transact_log_data() const;
+
+    util::Buffer<char> m_buffer;
+};
+
+
+// LCOV_EXCL_START (because the NullInstructionObserver is trivial)
+class NullInstructionObserver {
+public:
+    /// The following methods are also those that TransactLogParser expects
+    /// to find on the `InstructionHandler`.
+
+    // No selection needed:
+    bool select_table(size_t, size_t, const size_t*) { return true; }
+    bool select_descriptor(size_t, const size_t*) { return true; }
+    bool select_link_list(size_t, size_t, size_t) { return true; }
+    bool insert_group_level_table(size_t, size_t, StringData) { return true; }
+    bool erase_group_level_table(size_t, size_t) { return true; }
+    bool rename_group_level_table(size_t, StringData) { return true; }
+    bool move_group_level_table(size_t, size_t) { return true; }
+
+    // Must have table selected:
+    bool insert_empty_rows(size_t, size_t, size_t, bool) { return true; }
+    bool erase_rows(size_t, size_t, size_t, bool) { return true; }
+    bool swap_rows(size_t, size_t) { return true; }
+    bool change_link_targets(size_t, size_t) { return true; }
+    bool clear_table() { return true; }
+    bool set_int(size_t, size_t, int_fast64_t) { return true; }
+    bool set_int_unique(size_t, size_t, size_t, int_fast64_t) { return true; }
+    bool set_bool(size_t, size_t, bool) { return true; }
+    bool set_float(size_t, size_t, float) { return true; }
+    bool set_double(size_t, size_t, double) { return true; }
+    bool set_string(size_t, size_t, StringData) { return true; }
+    bool set_string_unique(size_t, size_t, size_t, StringData) { return true; }
+    bool set_binary(size_t, size_t, BinaryData) { return true; }
+    bool set_olddatetime(size_t, size_t, OldDateTime) { return true; }
+    bool set_timestamp(size_t, size_t, Timestamp) { return true; }
+    bool set_table(size_t, size_t) { return true; }
+    bool set_mixed(size_t, size_t, const Mixed&) { return true; }
+    bool set_link(size_t, size_t, size_t, size_t) { return true; }
+    bool set_null(size_t, size_t) { return true; }
+    bool nullify_link(size_t, size_t, size_t) { return true; }
+    bool insert_substring(size_t, size_t, size_t, StringData) { return true; }
+    bool erase_substring(size_t, size_t, size_t, size_t) { return true; }
+    bool optimize_table() { return true; }
+
+    // Must have descriptor selected:
+    bool insert_link_column(size_t, DataType, StringData, size_t, size_t) { return true; }
+    bool insert_column(size_t, DataType, StringData, bool) { return true; }
+    bool erase_link_column(size_t, size_t, size_t) { return true; }
+    bool erase_column(size_t) { return true; }
+    bool rename_column(size_t, StringData) { return true; }
+    bool move_column(size_t, size_t) { return true; }
+    bool add_search_index(size_t) { return true; }
+    bool remove_search_index(size_t) { return true; }
+    bool set_link_type(size_t, LinkType) { return true; }
+
+    // Must have linklist selected:
+    bool link_list_set(size_t, size_t) { return true; }
+    bool link_list_insert(size_t, size_t) { return true; }
+    bool link_list_move(size_t, size_t) { return true; }
+    bool link_list_swap(size_t, size_t) { return true; }
+    bool link_list_erase(size_t) { return true; }
+    bool link_list_nullify(size_t) { return true; }
+    bool link_list_clear(size_t) { return true; }
+
+    void parse_complete() {}
+};
+// LCOV_EXCL_STOP (NullInstructionObserver)
+
+
+/// See TransactLogConvenientEncoder for information about the meaning of the
+/// arguments of each of the functions in this class.
+class TransactLogEncoder {
+public:
+    /// The following methods are also those that TransactLogParser expects
+    /// to find on the `InstructionHandler`.
+
+    // No selection needed:
+    bool select_table(size_t group_level_ndx, size_t levels, const size_t* path);
+    bool select_descriptor(size_t levels, const size_t* path);
+    bool select_link_list(size_t col_ndx, size_t row_ndx, size_t link_target_group_level_ndx);
+    bool insert_group_level_table(size_t table_ndx, size_t num_tables, StringData name);
+    bool erase_group_level_table(size_t table_ndx, size_t num_tables);
+    bool rename_group_level_table(size_t table_ndx, StringData new_name);
+    bool move_group_level_table(size_t from_table_ndx, size_t to_table_ndx);
+
+    /// Must have table selected.
+    bool insert_empty_rows(size_t row_ndx, size_t num_rows_to_insert, size_t prior_num_rows,
+                           bool unordered);
+    bool erase_rows(size_t row_ndx, size_t num_rows_to_erase, size_t prior_num_rows,
+                    bool unordered);
+    bool swap_rows(size_t row_ndx_1, size_t row_ndx_2);
+    bool change_link_targets(size_t row_ndx, size_t new_row_ndx);
+    bool clear_table();
+
+    bool set_int(size_t col_ndx, size_t row_ndx, int_fast64_t);
+    bool set_int_unique(size_t col_ndx, size_t row_ndx, size_t prior_num_rows, int_fast64_t);
+    bool set_bool(size_t col_ndx, size_t row_ndx, bool);
+    bool set_float(size_t col_ndx, size_t row_ndx, float);
+    bool set_double(size_t col_ndx, size_t row_ndx, double);
+    bool set_string(size_t col_ndx, size_t row_ndx, StringData);
+    bool set_string_unique(size_t col_ndx, size_t row_ndx, size_t prior_num_rows, StringData);
+    bool set_binary(size_t col_ndx, size_t row_ndx, BinaryData);
+    bool set_olddatetime(size_t col_ndx, size_t row_ndx, OldDateTime);
+    bool set_timestamp(size_t col_ndx, size_t row_ndx, Timestamp);
+    bool set_table(size_t col_ndx, size_t row_ndx);
+    bool set_mixed(size_t col_ndx, size_t row_ndx, const Mixed&);
+    bool set_link(size_t col_ndx, size_t row_ndx, size_t, size_t target_group_level_ndx);
+    bool set_null(size_t col_ndx, size_t row_ndx);
+    bool nullify_link(size_t col_ndx, size_t row_ndx, size_t target_group_level_ndx);
+    bool insert_substring(size_t col_ndx, size_t row_ndx, size_t pos, StringData);
+    bool erase_substring(size_t col_ndx, size_t row_ndx, size_t pos, size_t size);
+    bool optimize_table();
+
+    // Must have descriptor selected:
+    bool insert_link_column(size_t col_ndx, DataType, StringData name, size_t link_target_table_ndx, size_t backlink_col_ndx);
+    bool insert_column(size_t col_ndx, DataType, StringData name, bool nullable = false);
+    bool erase_link_column(size_t col_ndx, size_t link_target_table_ndx, size_t backlink_col_ndx);
+    bool erase_column(size_t col_ndx);
+    bool rename_column(size_t col_ndx, StringData new_name);
+    bool move_column(size_t col_ndx_1, size_t col_ndx_2);
+    bool add_search_index(size_t col_ndx);
+    bool remove_search_index(size_t col_ndx);
+    bool set_link_type(size_t col_ndx, LinkType);
+
+    // Must have linklist selected:
+    bool link_list_set(size_t link_ndx, size_t value);
+    bool link_list_set_all(const IntegerColumn& values);
+    bool link_list_insert(size_t link_ndx, size_t value);
+    bool link_list_move(size_t from_link_ndx, size_t to_link_ndx);
+    bool link_list_swap(size_t link1_ndx, size_t link2_ndx);
+    bool link_list_erase(size_t link_ndx);
+    bool link_list_nullify(size_t link_ndx);
+    bool link_list_clear(size_t old_list_size);
+
+    /// End of methods expected by parser.
+
+
+    TransactLogEncoder(TransactLogStream& out_stream);
+    void set_buffer(char* new_free_begin, char* new_free_end);
+    char* write_position() const { return m_transact_log_free_begin; }
+
+private:
+    // Make sure this is in agreement with the actual integer encoding
+    // scheme (see encode_int()).
+    static const int max_enc_bytes_per_int = 10;
+    static const int max_enc_bytes_per_double = sizeof (double);
+    static const int max_enc_bytes_per_num = max_enc_bytes_per_int <
+        max_enc_bytes_per_double ? max_enc_bytes_per_double : max_enc_bytes_per_int;
+
+    TransactLogStream& m_stream;
+
+    // These two delimit a contiguous region of free space in a
+    // transaction log buffer following the last written data. It may
+    // be empty.
+    char* m_transact_log_free_begin = 0;
+    char* m_transact_log_free_end   = 0;
+
+    char* reserve(size_t size);
+    /// \param ptr Must be in the range [m_transact_log_free_begin, m_transact_log_free_end]
+    void advance(char* ptr) noexcept;
+
+    template<class L>
+    void append_simple_instr(Instruction, const util::Tuple<L>& numbers);
+
+    template<class L>
+    void append_string_instr(Instruction, const util::Tuple<L>& numbers, StringData);
+
+    template<class L>
+    void append_mixed_instr(Instruction, const util::Tuple<L>& numbers, const Mixed&);
+
+    template<class L, class I>
+    bool append_variable_size_instr(Instruction instr, const util::Tuple<L>& numbers,
+                                    I var_begin, I var_end);
+
+    template<class T>
+    static char* encode_int(char*, T value);
+    static char* encode_bool(char*, bool value);
+    static char* encode_float(char*, float value);
+    static char* encode_double(char*, double value);
+    template<class>
+    struct EncodeNumber;
+};
+
+class TransactLogConvenientEncoder {
+public:
+    void insert_group_level_table(size_t table_ndx, size_t num_tables, StringData name);
+    void erase_group_level_table(size_t table_ndx, size_t num_tables);
+    void rename_group_level_table(size_t table_ndx, StringData new_name);
+    void move_group_level_table(size_t from_table_ndx, size_t to_table_ndx);
+    void insert_column(const Descriptor&, size_t col_ndx, DataType type, StringData name,
+                       LinkTargetInfo& link, bool nullable = false);
+    void erase_column(const Descriptor&, size_t col_ndx);
+    void rename_column(const Descriptor&, size_t col_ndx, StringData name);
+    void move_column(const Descriptor&, size_t from, size_t to);
+
+    void set_int(const Table*, size_t col_ndx, size_t ndx, int_fast64_t value);
+    void set_int_unique(const Table*, size_t col_ndx, size_t ndx, int_fast64_t value);
+    void set_bool(const Table*, size_t col_ndx, size_t ndx, bool value);
+    void set_float(const Table*, size_t col_ndx, size_t ndx, float value);
+    void set_double(const Table*, size_t col_ndx, size_t ndx, double value);
+    void set_string(const Table*, size_t col_ndx, size_t ndx, StringData value);
+    void set_string_unique(const Table*, size_t col_ndx, size_t ndx, StringData value);
+    void set_binary(const Table*, size_t col_ndx, size_t ndx, BinaryData value);
+    void set_olddatetime(const Table*, size_t col_ndx, size_t ndx, OldDateTime value);
+    void set_timestamp(const Table*, size_t col_ndx, size_t ndx, Timestamp value);
+    void set_table(const Table*, size_t col_ndx, size_t ndx);
+    void set_mixed(const Table*, size_t col_ndx, size_t ndx, const Mixed& value);
+    void set_link(const Table*, size_t col_ndx, size_t ndx, size_t value);
+    void set_null(const Table*, size_t col_ndx, size_t ndx);
+    void set_link_list(const LinkView&, const IntegerColumn& values);
+    void insert_substring(const Table*, size_t col_ndx, size_t row_ndx, size_t pos, StringData);
+    void erase_substring(const Table*, size_t col_ndx, size_t row_ndx, size_t pos, size_t size);
+
+    /// \param prior_num_rows The number of rows in the table prior to the
+    /// modification.
+    void insert_empty_rows(const Table*, size_t row_ndx, size_t num_rows_to_insert,
+                           size_t prior_num_rows);
+
+    /// \param prior_num_rows The number of rows in the table prior to the
+    /// modification.
+    void erase_rows(const Table*, size_t row_ndx, size_t num_rows_to_erase, size_t prior_num_rows,
+                    bool is_move_last_over);
+
+    void swap_rows(const Table*, size_t row_ndx_1, size_t row_ndx_2);
+    void change_link_targets(const Table*, size_t row_ndx, size_t new_row_ndx);
+    void add_search_index(const Table*, size_t col_ndx);
+    void remove_search_index(const Table*, size_t col_ndx);
+    void set_link_type(const Table*, size_t col_ndx, LinkType);
+    void clear_table(const Table*);
+    void optimize_table(const Table*);
+
+    void link_list_set(const LinkView&, size_t link_ndx, size_t value);
+    void link_list_insert(const LinkView&, size_t link_ndx, size_t value);
+    void link_list_move(const LinkView&, size_t from_link_ndx, size_t to_link_ndx);
+    void link_list_swap(const LinkView&, size_t link_ndx_1, size_t link_ndx_2);
+    void link_list_erase(const LinkView&, size_t link_ndx);
+    void link_list_clear(const LinkView&);
+
+    //@{
+
+    /// Implicit nullifications due to removal of target row. This is redundant
+    /// information from the point of view of replication, as the removal of the
+    /// target row will reproduce the implicit nullifications in the target
+    /// Realm anyway. The purpose of this instruction is to allow observers
+    /// (reactor pattern) to be explicitly notified about the implicit
+    /// nullifications.
+
+    void nullify_link(const Table*, size_t col_ndx, size_t ndx);
+    void link_list_nullify(const LinkView&, size_t link_ndx);
+
+    //@}
+
+    void on_table_destroyed(const Table*) noexcept;
+    void on_spec_destroyed(const Spec*) noexcept;
+    void on_link_list_destroyed(const LinkView&) noexcept;
+
+protected:
+    TransactLogConvenientEncoder(TransactLogStream& encoder);
+
+    void reset_selection_caches() noexcept;
+    void set_buffer(char* new_free_begin, char* new_free_end) { m_encoder.set_buffer(new_free_begin, new_free_end); }
+    char* write_position() const { return m_encoder.write_position(); }
+
+private:
+    TransactLogEncoder m_encoder;
+    // These are mutable because they are caches.
+    mutable util::Buffer<size_t> m_subtab_path_buf;
+    mutable const Table*    m_selected_table;
+    mutable const Spec*     m_selected_spec;
+    // Has to be atomic to support concurrent reset when a linklist
+    // is unselected. This can happen on a different thread. In case
+    // of races, setting of a new value must win.
+    mutable std::atomic<const LinkView*> m_selected_link_list;
+
+    void unselect_all() noexcept;
+    void select_table(const Table*); // unselects descriptor and link list
+    void select_desc(const Descriptor&); // unselects link list
+    void select_link_list(const LinkView&); // unselects descriptor
+
+    void record_subtable_path(const Table&, size_t*& out_begin, size_t*& out_end);
+    void do_select_table(const Table*);
+    void do_select_desc(const Descriptor&);
+    void do_select_link_list(const LinkView&);
+
+    friend class TransactReverser;
+};
+
+
+class TransactLogParser {
+public:
+    class BadTransactLog; // Exception
+
+    TransactLogParser();
+    ~TransactLogParser() noexcept;
+
+    /// See `TransactLogEncoder` for a list of methods that the `InstructionHandler` must define.
+    /// parse() promises that the path passed by reference to
+    /// InstructionHandler::select_descriptor() will remain valid
+    /// during subsequent calls to all descriptor modifying functions.
+    template<class InstructionHandler>
+    void parse(InputStream&, InstructionHandler&);
+
+    template<class InstructionHandler>
+    void parse(NoCopyInputStream&, InstructionHandler&);
+
+private:
+    util::Buffer<char> m_input_buffer;
+
+    // The input stream is assumed to consist of chunks of memory organised such that
+    // every instruction resides in a single chunk only.
+    NoCopyInputStream* m_input;
+    // pointer into transaction log, each instruction is parsed from m_input_begin and onwards.
+    // Each instruction are assumed to be contiguous in memory.
+    const char* m_input_begin;
+    // pointer to one past current instruction log chunk. If m_input_begin reaches m_input_end,
+    // a call to next_input_buffer will move m_input_begin and m_input_end to a new chunk of
+    // memory. Setting m_input_end to 0 disables this check, and is used if it is already known
+    // that all of the instructions are in memory.
+    const char* m_input_end;
+    util::StringBuffer m_string_buffer;
+    static const int m_max_levels = 1024;
+    util::Buffer<size_t> m_path;
+
+    REALM_NORETURN void parser_error() const;
+
+    template<class InstructionHandler>
+    void parse_one(InstructionHandler&);
+    bool has_next() noexcept;
+
+    template<class T>
+    T read_int();
+
+    void read_bytes(char* data, size_t size);
+    BinaryData read_buffer(util::StringBuffer&, size_t size);
+
+    bool read_bool();
+    float read_float();
+    double read_double();
+
+    StringData read_string(util::StringBuffer&);
+    BinaryData read_binary(util::StringBuffer&);
+    Timestamp read_timestamp();
+    void read_mixed(Mixed*);
+
+    // Advance m_input_begin and m_input_end to reflect the next block of instructions
+    // Returns false if no more input was available
+    bool next_input_buffer();
+
+    // return true if input was available
+    bool read_char(char&); // throws
+
+    bool is_valid_data_type(int type);
+    bool is_valid_link_type(int type);
+};
+
+
+class TransactLogParser::BadTransactLog: public std::exception {
+public:
+    const char* what() const noexcept override
+    {
+        return "Bad transaction log";
+    }
+};
+
+
+
+/// Implementation:
+
+inline void TransactLogBufferStream::transact_log_reserve(size_t n, char** inout_new_begin, char** out_new_end)
+{
+    char* data = m_buffer.data();
+    REALM_ASSERT(*inout_new_begin >= data);
+    REALM_ASSERT(*inout_new_begin <= (data + m_buffer.size()));
+    size_t size = *inout_new_begin - data;
+    m_buffer.reserve_extra(size, n);
+    data = m_buffer.data(); // May have changed
+    *inout_new_begin = data + size;
+    *out_new_end = data + m_buffer.size();
+}
+
+inline void TransactLogBufferStream::transact_log_append(const char* data, size_t size, char** out_new_begin, char** out_new_end)
+{
+    transact_log_reserve(size, out_new_begin, out_new_end);
+    *out_new_begin = std::copy(data, data + size, *out_new_begin);
+}
+
+inline const char* TransactLogBufferStream::transact_log_data() const
+{
+    return m_buffer.data();
+}
+
+inline TransactLogEncoder::TransactLogEncoder(TransactLogStream& stream):
+    m_stream(stream)
+{
+}
+
+inline void TransactLogEncoder::set_buffer(char* free_begin, char* free_end)
+{
+    REALM_ASSERT(free_begin <= free_end);
+    m_transact_log_free_begin = free_begin;
+    m_transact_log_free_end   = free_end;
+}
+
+inline void TransactLogConvenientEncoder::reset_selection_caches() noexcept
+{
+    unselect_all();
+}
+
+inline char* TransactLogEncoder::reserve(size_t n)
+{
+    if (size_t(m_transact_log_free_end - m_transact_log_free_begin) < n) {
+        m_stream.transact_log_reserve(n, &m_transact_log_free_begin, &m_transact_log_free_end);
+    }
+    return m_transact_log_free_begin;
+}
+
+inline void TransactLogEncoder::advance(char* ptr) noexcept
+{
+    REALM_ASSERT_DEBUG(m_transact_log_free_begin <= ptr);
+    REALM_ASSERT_DEBUG(ptr <= m_transact_log_free_end);
+    m_transact_log_free_begin = ptr;
+}
+
+
+// The integer encoding is platform independent. Also, it does not
+// depend on the type of the specified integer. Integers of any type
+// can be encoded as long as the specified buffer is large enough (see
+// below). The decoding does not have to use the same type. Decoding
+// will fail if, and only if the encoded value falls outside the range
+// of the requested destination type.
+//
+// The encoding uses one or more bytes. It never uses more than 8 bits
+// per byte. The last byte in the sequence is the first one that has
+// its 8th bit set to zero.
+//
+// Consider a particular non-negative value V. Let W be the number of
+// bits needed to encode V using the trivial binary encoding of
+// integers. The total number of bytes produced is then
+// ceil((W+1)/7). The first byte holds the 7 least significant bits of
+// V. The last byte holds at most 6 bits of V including the most
+// significant one. The value of the first bit of the last byte is
+// always 2**((N-1)*7) where N is the total number of bytes.
+//
+// A negative value W is encoded by setting the sign bit to one and
+// then encoding the positive result of -(W+1) as described above. The
+// advantage of this representation is that it converts small negative
+// values to small positive values which require a small number of
+// bytes. This would not have been true for 2's complements
+// representation, for example. The sign bit is always stored as the
+// 7th bit of the last byte.
+//
+//               value bits    value + sign    max bytes
+//     --------------------------------------------------
+//     int8_t         7              8              2
+//     uint8_t        8              9              2
+//     int16_t       15             16              3
+//     uint16_t      16             17              3
+//     int32_t       31             32              5
+//     uint32_t      32             33              5
+//     int64_t       63             64             10
+//     uint64_t      64             65             10
+//
+template<class T>
+char* TransactLogEncoder::encode_int(char* ptr, T value)
+{
+    static_assert(std::numeric_limits<T>::is_integer, "Integer required");
+    bool negative = util::is_negative(value);
+    if (negative) {
+        // The following conversion is guaranteed by C++11 to never
+        // overflow (contrast this with "-value" which indeed could
+        // overflow). See C99+TC3 section 6.2.6.2 paragraph 2.
+        REALM_DIAG_PUSH();
+        REALM_DIAG_IGNORE_UNSIGNED_MINUS();
+        value = -(value + 1);
+        REALM_DIAG_POP();
+    }
+    // At this point 'value' is always a positive number. Also, small
+    // negative numbers have been converted to small positive numbers.
+    REALM_ASSERT(!util::is_negative(value));
+    // One sign bit plus number of value bits
+    const int num_bits = 1 + std::numeric_limits<T>::digits;
+    // Only the first 7 bits are available per byte. Had it not been
+    // for the fact that maximum guaranteed bit width of a char is 8,
+    // this value could have been increased to 15 (one less than the
+    // number of value bits in 'unsigned').
+    const int bits_per_byte = 7;
+    const int max_bytes = (num_bits + (bits_per_byte-1)) / bits_per_byte;
+    static_assert(max_bytes <= max_enc_bytes_per_int, "Bad max_enc_bytes_per_int");
+    // An explicit constant maximum number of iterations is specified
+    // in the hope that it will help the optimizer (to do loop
+    // unrolling, for example).
+    typedef unsigned char uchar;
+    for (int i=0; i<max_bytes; ++i) {
+        if (value >> (bits_per_byte-1) == 0)
+            break;
+        *reinterpret_cast<uchar*>(ptr) =
+            uchar((1U<<bits_per_byte) | unsigned(value & ((1U<<bits_per_byte)-1)));
+        ++ptr;
+        value >>= bits_per_byte;
+    }
+    *reinterpret_cast<uchar*>(ptr) =
+        uchar(negative ? (1U<<(bits_per_byte-1)) | unsigned(value) : value);
+    return ++ptr;
+}
+
+inline char* TransactLogEncoder::encode_bool(char* ptr, bool value)
+{
+    // A `char` is the smallest element that the encoder/decoder can process. So we encode the bool
+    // in a char. If we called encode_int<bool> it would end up as a char too, but we would get
+    // Various warnings about arithmetic on non-arithmetic type.
+    return encode_int<char>(ptr, value);
+}
+
+inline char* TransactLogEncoder::encode_float(char* ptr, float value)
+{
+    static_assert(std::numeric_limits<float>::is_iec559 &&
+                          sizeof (float) * std::numeric_limits<unsigned char>::digits == 32,
+                          "Unsupported 'float' representation");
+    const char* val_ptr = reinterpret_cast<char*>(&value);
+    return std::copy(val_ptr, val_ptr + sizeof value, ptr);
+}
+
+inline char* TransactLogEncoder::encode_double(char* ptr, double value)
+{
+    static_assert(std::numeric_limits<double>::is_iec559 &&
+                          sizeof (double) * std::numeric_limits<unsigned char>::digits == 64,
+                          "Unsupported 'double' representation");
+    const char* val_ptr = reinterpret_cast<char*>(&value);
+    return std::copy(val_ptr, val_ptr + sizeof value, ptr);
+}
+
+template<class T>
+struct TransactLogEncoder::EncodeNumber {
+    void operator()(T value, char** ptr)
+    {
+        auto value_2 = value + 0; // Perform integral promotion
+        *ptr = encode_int(*ptr, value_2);
+    }
+};
+template<>
+struct TransactLogEncoder::EncodeNumber<bool> {
+    void operator()(bool value, char** ptr)
+    {
+        *ptr = encode_bool(*ptr, value);
+    }
+};
+template<>
+struct TransactLogEncoder::EncodeNumber<float> {
+    void operator()(float value, char** ptr)
+    {
+        *ptr = encode_float(*ptr, value);
+    }
+};
+template<>
+struct TransactLogEncoder::EncodeNumber<double> {
+    void operator()(double value, char** ptr)
+    {
+        *ptr = encode_double(*ptr, value);
+    }
+};
+
+template<class L>
+void TransactLogEncoder::append_simple_instr(Instruction instr, const util::Tuple<L>& numbers)
+{
+    size_t num_numbers = util::TypeCount<L>::value;
+    size_t max_required_bytes = 1 + max_enc_bytes_per_num * num_numbers;
+    char* ptr = reserve(max_required_bytes); // Throws
+    *ptr++ = char(instr);
+    util::for_each<EncodeNumber>(numbers, &ptr);
+    advance(ptr);
+}
+
+template<class L>
+void TransactLogEncoder::append_string_instr(Instruction instr, const util::Tuple<L>& numbers,
+                                             StringData string)
+{
+    size_t num_numbers = util::TypeCount<L>::value + 1;
+    size_t max_required_bytes = 1 + max_enc_bytes_per_num * num_numbers + string.size();
+    char* ptr = reserve(max_required_bytes); // Throws
+    *ptr++ = char(instr);
+    util::for_each<EncodeNumber>(append(numbers, string.size()), &ptr);
+    ptr = std::copy(string.data(), string.data() + string.size(), ptr);
+    advance(ptr);
+}
+
+template<class L>
+void TransactLogEncoder::append_mixed_instr(Instruction instr, const util::Tuple<L>& numbers,
+                                            const Mixed& value)
+{
+    DataType type = value.get_type();
+    auto numbers_2 = append(numbers, type);
+    switch (type) {
+        case type_Int:
+            append_simple_instr(instr, append(numbers_2, value.get_int())); // Throws
+            return;
+        case type_Bool:
+            append_simple_instr(instr, append(numbers_2, value.get_bool())); // Throws
+            return;
+        case type_Float:
+            append_simple_instr(instr, append(numbers_2, value.get_float())); // Throws
+            return;
+        case type_Double:
+            append_simple_instr(instr, append(numbers_2, value.get_double())); // Throws
+            return;
+        case type_OldDateTime: {
+            auto value_2 = value.get_olddatetime().get_olddatetime();
+            append_simple_instr(instr, append(numbers_2, value_2)); // Throws
+            return;
+        }
+        case type_String: {
+            append_string_instr(instr, numbers_2, value.get_string()); // Throws
+            return;
+        }
+        case type_Binary: {
+            BinaryData value_2 = value.get_binary();
+            StringData value_3(value_2.data(), value_2.size());
+            append_string_instr(instr, numbers_2, value_3); // Throws
+            return;
+        }
+        case type_Timestamp: {
+            Timestamp ts= value.get_timestamp();
+            int64_t seconds = ts.get_seconds();
+            int32_t nano_seconds = ts.get_nanoseconds();
+            auto numbers_3 = append(numbers_2, seconds);
+            append_simple_instr(instr, append(numbers_3, nano_seconds)); // Throws
+            return;
+        }
+        case type_Table:
+            append_simple_instr(instr, numbers_2); // Throws
+            return;
+        case type_Mixed:
+            // Mixed in mixed is not possible
+            REALM_ASSERT_RELEASE(false);
+        case type_Link:
+        case type_LinkList:
+            // FIXME: Need to handle new link types here.
+            REALM_ASSERT_RELEASE(false);
+    }
+    REALM_ASSERT_RELEASE(false);
+}
+
+template<class L, class I>
+bool TransactLogEncoder::append_variable_size_instr(Instruction instr,
+                                                    const util::Tuple<L>& numbers,
+                                                    I var_begin, I var_end)
+{
+    // Space is reserved in chunks to avoid excessive over allocation.
+#ifdef REALM_DEBUG
+    const int max_numbers_per_chunk = 2; // Increase the chance of chunking in debug mode
+#else
+    const int max_numbers_per_chunk = 8;
+#endif
+    size_t num_numbers = util::TypeCount<L>::value + max_numbers_per_chunk;
+    size_t max_required_bytes = 1 + max_enc_bytes_per_num * num_numbers;
+    char* ptr = reserve(max_required_bytes); // Throws
+    *ptr++ = char(instr);
+    util::for_each<EncodeNumber>(numbers, &ptr);
+    I i = var_begin;
+    while (var_end - i > max_numbers_per_chunk) {
+        for (int j = 0; j < max_numbers_per_chunk; ++j)
+            ptr = encode_int(ptr, *i++);
+        advance(ptr);
+        size_t max_required_bytes_2 = max_enc_bytes_per_num * max_numbers_per_chunk;
+        ptr = reserve(max_required_bytes_2); // Throws
+    }
+    while (i != var_end)
+        ptr = encode_int(ptr, *i++);
+    advance(ptr);
+    return true;
+}
+
+inline void TransactLogConvenientEncoder::unselect_all() noexcept
+{
+    m_selected_table     = nullptr;
+    m_selected_spec      = nullptr;
+    // no race with on_link_list_destroyed since both are setting to nullptr
+    m_selected_link_list = nullptr;
+}
+
+inline void TransactLogConvenientEncoder::select_table(const Table* table)
+{
+    if (table != m_selected_table)
+        do_select_table(table); // Throws
+    m_selected_spec      = nullptr;
+    // no race with on_link_list_destroyed since both are setting to nullptr
+    m_selected_link_list = nullptr;
+}
+
+inline void TransactLogConvenientEncoder::select_desc(const Descriptor& desc)
+{
+    typedef _impl::DescriptorFriend df;
+    if (&df::get_spec(desc) != m_selected_spec)
+        do_select_desc(desc); // Throws
+    // no race with on_link_list_destroyed since both are setting to nullptr
+    m_selected_link_list = nullptr;
+}
+
+inline void TransactLogConvenientEncoder::select_link_list(const LinkView& list)
+{
+    // A race between this and a call to on_link_list_destroyed() must
+    // end up with m_selected_link_list pointing to the list argument given
+    // here. We assume that the list given to on_link_list_destroyed() can
+    // *never* be the same as the list argument given here. We resolve the
+    // race by a) always updating m_selected_link_list in do_select_link_list()
+    // and b) only atomically and conditionally updating it in 
+    // on_link_list_destroyed().
+    if (&list != m_selected_link_list) {
+        do_select_link_list(list); // Throws
+    }
+    m_selected_spec = nullptr;
+}
+
+
+inline bool TransactLogEncoder::insert_group_level_table(size_t table_ndx, size_t prior_num_tables,
+                                                         StringData name)
+{
+    append_string_instr(instr_InsertGroupLevelTable, util::tuple(table_ndx, prior_num_tables),
+                        name); // Throws
+    return true;
+}
+
+inline void TransactLogConvenientEncoder::insert_group_level_table(size_t table_ndx,
+                                                                   size_t prior_num_tables,
+                                                                   StringData name)
+{
+    unselect_all();
+    m_encoder.insert_group_level_table(table_ndx, prior_num_tables, name); // Throws
+}
+
+inline bool TransactLogEncoder::erase_group_level_table(size_t table_ndx, size_t prior_num_tables)
+{
+    append_simple_instr(instr_EraseGroupLevelTable, util::tuple(table_ndx, prior_num_tables)); // Throws
+    return true;
+}
+
+inline void TransactLogConvenientEncoder::erase_group_level_table(size_t table_ndx, size_t prior_num_tables)
+{
+    unselect_all();
+    m_encoder.erase_group_level_table(table_ndx, prior_num_tables); // Throws
+}
+
+inline bool TransactLogEncoder::rename_group_level_table(size_t table_ndx, StringData new_name)
+{
+    append_string_instr(instr_RenameGroupLevelTable, util::tuple(table_ndx), new_name); // Throws
+    return true;
+}
+
+inline void TransactLogConvenientEncoder::rename_group_level_table(size_t table_ndx,
+                                                                   StringData new_name)
+{
+    unselect_all();
+    m_encoder.rename_group_level_table(table_ndx, new_name); // Throws
+}
+
+inline bool TransactLogEncoder::move_group_level_table(size_t from_table_ndx, size_t to_table_ndx)
+{
+    REALM_ASSERT(from_table_ndx != to_table_ndx);
+    append_simple_instr(instr_MoveGroupLevelTable, util::tuple(from_table_ndx, to_table_ndx));
+    return true;
+}
+
+inline void TransactLogConvenientEncoder::move_group_level_table(size_t from_table_ndx, size_t to_table_ndx)
+{
+    unselect_all();
+    m_encoder.move_group_level_table(from_table_ndx, to_table_ndx);
+}
+
+inline bool TransactLogEncoder::insert_column(size_t col_ndx, DataType type, StringData name,
+                                              bool nullable)
+{
+    Instruction instr = (nullable ? instr_InsertNullableColumn : instr_InsertColumn);
+    append_string_instr(instr, util::tuple(col_ndx, type), name); // Throws
+    return true;
+}
+
+inline bool TransactLogEncoder::insert_link_column(size_t col_ndx, DataType type, StringData name,
+                                                   size_t link_target_table_ndx,
+                                                   size_t backlink_col_ndx)
+{
+    REALM_ASSERT(_impl::TableFriend::is_link_type(ColumnType(type)));
+    append_string_instr(instr_InsertLinkColumn, util::tuple(col_ndx, type, link_target_table_ndx,
+                                                            backlink_col_ndx), name); // Throws
+    return true;
+}
+
+
+inline void TransactLogConvenientEncoder::insert_column(const Descriptor& desc, size_t col_ndx,
+                                                        DataType type,
+                                                        StringData name,
+                                                        LinkTargetInfo& link,
+                                                        bool nullable)
+{
+    select_desc(desc); // Throws
+    if (link.is_valid()) {
+        typedef _impl::TableFriend tf;
+        typedef _impl::DescriptorFriend df;
+        size_t target_table_ndx = link.m_target_table->get_index_in_group();
+        const Table& origin_table = df::get_root_table(desc);
+        REALM_ASSERT(origin_table.is_group_level());
+        const Spec& target_spec = tf::get_spec(*(link.m_target_table));
+        size_t origin_table_ndx = origin_table.get_index_in_group();
+        size_t backlink_col_ndx = target_spec.find_backlink_column(origin_table_ndx, col_ndx);
+        REALM_ASSERT_3(backlink_col_ndx, ==, link.m_backlink_col_ndx);
+        m_encoder.insert_link_column(col_ndx, type, name, target_table_ndx, backlink_col_ndx); // Throws
+    }
+    else {
+        m_encoder.insert_column(col_ndx, type, name, nullable); // Throws
+    }
+}
+
+inline bool TransactLogEncoder::erase_column(size_t col_ndx)
+{
+    append_simple_instr(instr_EraseColumn, util::tuple(col_ndx)); // Throws
+    return true;
+}
+
+inline bool TransactLogEncoder::erase_link_column(size_t col_ndx, size_t link_target_table_ndx,
+                                                  size_t backlink_col_ndx)
+{
+    append_simple_instr(instr_EraseLinkColumn, util::tuple(col_ndx, link_target_table_ndx,
+                                                           backlink_col_ndx)); // Throws
+    return true;
+}
+
+inline void TransactLogConvenientEncoder::erase_column(const Descriptor& desc, size_t col_ndx)
+{
+    select_desc(desc); // Throws
+
+    DataType type = desc.get_column_type(col_ndx);
+    typedef _impl::TableFriend tf;
+    if (!tf::is_link_type(ColumnType(type))) {
+        m_encoder.erase_column(col_ndx); // Throws
+    }
+    else { // it's a link column:
+        REALM_ASSERT(desc.is_root());
+        typedef _impl::DescriptorFriend df;
+        const Table& origin_table = df::get_root_table(desc);
+        REALM_ASSERT(origin_table.is_group_level());
+        const Table& target_table = *tf::get_link_target_table_accessor(origin_table, col_ndx);
+        size_t target_table_ndx = target_table.get_index_in_group();
+        const Spec& target_spec = tf::get_spec(target_table);
+        size_t origin_table_ndx = origin_table.get_index_in_group();
+        size_t backlink_col_ndx = target_spec.find_backlink_column(origin_table_ndx, col_ndx);
+        m_encoder.erase_link_column(col_ndx, target_table_ndx, backlink_col_ndx); // Throws
+    }
+}
+
+inline bool TransactLogEncoder::rename_column(size_t col_ndx, StringData new_name)
+{
+    append_string_instr(instr_RenameColumn, util::tuple(col_ndx), new_name); // Throws
+    return true;
+}
+
+inline void TransactLogConvenientEncoder::rename_column(const Descriptor& desc, size_t col_ndx,
+                                       StringData name)
+{
+    select_desc(desc); // Throws
+    m_encoder.rename_column(col_ndx, name); // Throws
+}
+
+
+inline bool TransactLogEncoder::move_column(size_t from, size_t to)
+{
+    append_simple_instr(instr_MoveColumn, util::tuple(from, to)); // Throws
+    return true;
+}
+
+inline void TransactLogConvenientEncoder::move_column(const Descriptor& desc, size_t from, size_t to)
+{
+    select_desc(desc); // Throws
+    m_encoder.move_column(from, to);
+}
+
+
+inline bool TransactLogEncoder::set_int(size_t col_ndx, size_t ndx, int_fast64_t value)
+{
+    append_simple_instr(instr_SetInt, util::tuple(col_ndx, ndx, value)); // Throws
+    return true;
+}
+
+inline void TransactLogConvenientEncoder::set_int(const Table* t, size_t col_ndx,
+                                 size_t ndx, int_fast64_t value)
+{
+    select_table(t); // Throws
+    m_encoder.set_int(col_ndx, ndx, value); // Throws
+}
+
+inline bool TransactLogEncoder::set_int_unique(size_t col_ndx, size_t ndx, size_t prior_num_rows, int_fast64_t value)
+{
+    append_simple_instr(instr_SetIntUnique, util::tuple(col_ndx, ndx, prior_num_rows, value));
+    return true;
+}
+
+inline void TransactLogConvenientEncoder::set_int_unique(const Table* t, size_t col_ndx,
+                                                         size_t ndx, int_fast64_t value)
+{
+    select_table(t); // Throws
+    m_encoder.set_int_unique(col_ndx, ndx, t->size(), value); // Throws
+}
+
+inline bool TransactLogEncoder::set_bool(size_t col_ndx, size_t ndx, bool value)
+{
+    append_simple_instr(instr_SetBool, util::tuple(col_ndx, ndx, value)); // Throws
+    return true;
+}
+
+inline void TransactLogConvenientEncoder::set_bool(const Table* t, size_t col_ndx,
+                                  size_t ndx, bool value)
+{
+    select_table(t); // Throws
+    m_encoder.set_bool(col_ndx, ndx, value); // Throws
+}
+
+inline bool TransactLogEncoder::set_float(size_t col_ndx, size_t ndx, float value)
+{
+    append_simple_instr(instr_SetFloat, util::tuple(col_ndx, ndx, value)); // Throws
+    return true;
+}
+
+inline void TransactLogConvenientEncoder::set_float(const Table* t, size_t col_ndx,
+                                   size_t ndx, float value)
+{
+    select_table(t); // Throws
+    m_encoder.set_float(col_ndx, ndx, value); // Throws
+}
+
+inline bool TransactLogEncoder::set_double(size_t col_ndx, size_t ndx, double value)
+{
+    append_simple_instr(instr_SetDouble, util::tuple(col_ndx, ndx, value)); // Throws
+    return true;
+}
+
+inline void TransactLogConvenientEncoder::set_double(const Table* t, size_t col_ndx,
+                                    size_t ndx, double value)
+{
+    select_table(t); // Throws
+    m_encoder.set_double(col_ndx, ndx, value); // Throws
+}
+
+inline bool TransactLogEncoder::set_string(size_t col_ndx, size_t ndx, StringData value)
+{
+    if (value.is_null()) {
+        set_null(col_ndx, ndx); // Throws
+    }
+    else {
+        append_string_instr(instr_SetString, util::tuple(col_ndx, ndx), value); // Throws
+    }
+    return true;
+}
+
+inline void TransactLogConvenientEncoder::set_string(const Table* t, size_t col_ndx,
+                                    size_t ndx, StringData value)
+{
+    select_table(t); // Throws
+    m_encoder.set_string(col_ndx, ndx, value); // Throws
+}
+
+inline bool TransactLogEncoder::set_string_unique(size_t col_ndx, size_t ndx, size_t prior_num_rows, StringData value)
+{
+    if (value.is_null()) {
+        // FIXME: This loses SetUnique information.
+        set_null(col_ndx, ndx); // Throws
+    }
+    else {
+        append_string_instr(instr_SetStringUnique, util::tuple(col_ndx, ndx, prior_num_rows), value); // Throws
+    }
+    return true;
+}
+
+inline void TransactLogConvenientEncoder::set_string_unique(const Table* t, size_t col_ndx,
+                                                            size_t ndx, StringData value)
+{
+    select_table(t); // Throws
+    m_encoder.set_string_unique(col_ndx, ndx, t->size(), value); // Throws
+}
+
+inline bool TransactLogEncoder::set_binary(size_t col_ndx, size_t row_ndx, BinaryData value)
+{
+    if (value.is_null()) {
+        set_null(col_ndx, row_ndx); // Throws
+    }
+    else {
+        StringData value_2(value.data(), value.size());
+        append_string_instr(instr_SetBinary, util::tuple(col_ndx, row_ndx), value_2); // Throws
+    }
+    return true;
+}
+
+inline void TransactLogConvenientEncoder::set_binary(const Table* t, size_t col_ndx,
+                                    size_t ndx, BinaryData value)
+{
+    select_table(t); // Throws
+    m_encoder.set_binary(col_ndx, ndx, value); // Throws
+}
+
+inline bool TransactLogEncoder::set_olddatetime(size_t col_ndx, size_t ndx, OldDateTime value)
+{
+    append_simple_instr(instr_SetOldDateTime, util::tuple(col_ndx, ndx,
+                                                          value.get_olddatetime())); // Throws
+    return true;
+}
+
+inline void TransactLogConvenientEncoder::set_olddatetime(const Table* t, size_t col_ndx,
+                                                          size_t ndx, OldDateTime value)
+{
+    select_table(t); // Throws
+    m_encoder.set_olddatetime(col_ndx, ndx, value); // Throws
+}
+
+inline bool TransactLogEncoder::set_timestamp(size_t col_ndx, size_t ndx, Timestamp value)
+{
+    append_simple_instr(instr_SetTimestamp, util::tuple(col_ndx, ndx,
+                                                        value.get_seconds(), value.get_nanoseconds())); // Throws
+    return true;
+}
+
+inline void TransactLogConvenientEncoder::set_timestamp(const Table* t, size_t col_ndx, size_t ndx, Timestamp value)
+{
+    select_table(t); // Throws
+    m_encoder.set_timestamp(col_ndx, ndx, value); // Throws
+}
+
+inline bool TransactLogEncoder::set_table(size_t col_ndx, size_t ndx)
+{
+    append_simple_instr(instr_SetTable, util::tuple(col_ndx, ndx)); // Throws
+    return true;
+}
+
+inline void TransactLogConvenientEncoder::set_table(const Table* t, size_t col_ndx,
+                                   size_t ndx)
+{
+    select_table(t); // Throws
+    m_encoder.set_table(col_ndx, ndx); // Throws
+}
+
+inline bool TransactLogEncoder::set_mixed(size_t col_ndx, size_t ndx, const Mixed& value)
+{
+    append_mixed_instr(instr_SetMixed, util::tuple(col_ndx, ndx), value); // Throws
+    return true;
+}
+
+inline void TransactLogConvenientEncoder::set_mixed(const Table* t, size_t col_ndx,
+                                   size_t ndx, const Mixed& value)
+{
+    select_table(t); // Throws
+    m_encoder.set_mixed(col_ndx, ndx, value); // Throws
+}
+
+inline bool TransactLogEncoder::set_link(size_t col_ndx, size_t ndx,
+                                         size_t value, size_t target_group_level_ndx)
+{
+    // Map `realm::npos` to zero, and `n` to `n+1`, where `n` is a target row
+    // index.
+    size_t value_2 = size_t(1) + value;
+    append_simple_instr(instr_SetLink, util::tuple(col_ndx, ndx, value_2,
+                                                   target_group_level_ndx)); // Throws
+    return true;
+}
+
+inline void TransactLogConvenientEncoder::set_link(const Table* t, size_t col_ndx,
+                                  size_t ndx, size_t value)
+{
+    select_table(t); // Throws
+    size_t target_group_level_ndx = t->get_descriptor()->get_column_link_target(col_ndx);
+    m_encoder.set_link(col_ndx, ndx, value, target_group_level_ndx); // Throws
+}
+
+inline bool TransactLogEncoder::set_null(size_t col_ndx, size_t ndx)
+{
+    append_simple_instr(instr_SetNull, util::tuple(col_ndx, ndx)); // Throws
+    return true;
+}
+
+inline void TransactLogConvenientEncoder::set_null(const Table* t, size_t col_ndx,
+                                                   size_t row_ndx)
+{
+    select_table(t); // Throws
+    m_encoder.set_null(col_ndx, row_ndx); // Throws
+}
+
+inline bool TransactLogEncoder::nullify_link(size_t col_ndx, size_t ndx,
+                                             size_t target_group_level_ndx)
+{
+    append_simple_instr(instr_NullifyLink, util::tuple(col_ndx, ndx,
+                                                       target_group_level_ndx)); // Throws
+    return true;
+}
+
+inline void TransactLogConvenientEncoder::nullify_link(const Table* t, size_t col_ndx, size_t ndx)
+{
+    select_table(t); // Throws
+    size_t target_group_level_ndx = t->get_descriptor()->get_column_link_target(col_ndx);
+    m_encoder.nullify_link(col_ndx, ndx, target_group_level_ndx); // Throws
+}
+
+inline bool TransactLogEncoder::insert_substring(size_t col_ndx, size_t row_ndx, size_t pos,
+                                                 StringData value)
+{
+    append_string_instr(instr_InsertSubstring, util::tuple(col_ndx, row_ndx, pos),
+                        value); // Throws
+    return true;
+}
+
+inline void TransactLogConvenientEncoder::insert_substring(const Table* t, size_t col_ndx,
+                                                           size_t row_ndx, size_t pos,
+                                                           StringData value)
+{
+    if (value.size() > 0) {
+        select_table(t); // Throws
+        m_encoder.insert_substring(col_ndx, row_ndx, pos, value); // Throws
+    }
+}
+
+inline bool TransactLogEncoder::erase_substring(size_t col_ndx, size_t row_ndx, size_t pos,
+                                                size_t size)
+{
+    append_simple_instr(instr_EraseFromString, util::tuple(col_ndx, row_ndx, pos, size)); // Throws
+    return true;
+}
+
+inline void TransactLogConvenientEncoder::erase_substring(const Table* t, size_t col_ndx,
+                                                          size_t row_ndx, size_t pos,
+                                                          size_t size)
+{
+    if (size > 0) {
+        select_table(t); // Throws
+        m_encoder.erase_substring(col_ndx, row_ndx, pos, size); // Throws
+    }
+}
+
+inline bool TransactLogEncoder::insert_empty_rows(size_t row_ndx, size_t num_rows_to_insert,
+                                                  size_t prior_num_rows, bool unordered)
+{
+    append_simple_instr(instr_InsertEmptyRows, util::tuple(row_ndx, num_rows_to_insert,
+                                                           prior_num_rows, unordered)); // Throws
+    return true;
+}
+
+inline void TransactLogConvenientEncoder::insert_empty_rows(const Table* t, size_t row_ndx,
+                                                            size_t num_rows_to_insert,
+                                                            size_t prior_num_rows)
+{
+    select_table(t); // Throws
+    bool unordered = false;
+    m_encoder.insert_empty_rows(row_ndx, num_rows_to_insert, prior_num_rows,
+                                unordered); // Throws
+}
+
+inline bool TransactLogEncoder::erase_rows(size_t row_ndx, size_t num_rows_to_erase,
+                                           size_t prior_num_rows, bool unordered)
+{
+    append_simple_instr(instr_EraseRows, util::tuple(row_ndx, num_rows_to_erase, prior_num_rows,
+                                                     unordered)); // Throws
+    return true;
+}
+
+
+inline void TransactLogConvenientEncoder::erase_rows(const Table* t, size_t row_ndx,
+                                                     size_t num_rows_to_erase,
+                                                     size_t prior_num_rows,
+                                                     bool is_move_last_over)
+{
+    select_table(t); // Throws
+    bool unordered = is_move_last_over;
+    m_encoder.erase_rows(row_ndx, num_rows_to_erase, prior_num_rows, unordered); // Throws
+}
+
+inline bool TransactLogEncoder::swap_rows(size_t row_ndx_1, size_t row_ndx_2)
+{
+    append_simple_instr(instr_SwapRows, util::tuple(row_ndx_1, row_ndx_2)); // Throws
+    return true;
+}
+
+inline void TransactLogConvenientEncoder::swap_rows(const Table* t, size_t row_ndx_1, size_t row_ndx_2)
+{
+    REALM_ASSERT(row_ndx_1 < row_ndx_2);
+    select_table(t); // Throws
+    m_encoder.swap_rows(row_ndx_1, row_ndx_2);
+}
+
+inline bool TransactLogEncoder::change_link_targets(size_t row_ndx, size_t new_row_ndx)
+{
+    append_simple_instr(instr_ChangeLinkTargets, util::tuple(row_ndx, new_row_ndx)); // Throws
+    return true;
+}
+
+inline void TransactLogConvenientEncoder::change_link_targets(const Table* t, size_t row_ndx,
+                                                      size_t new_row_ndx)
+{
+    select_table(t); // Throws
+    m_encoder.change_link_targets(row_ndx, new_row_ndx);
+}
+
+inline bool TransactLogEncoder::add_search_index(size_t col_ndx)
+{
+    append_simple_instr(instr_AddSearchIndex, util::tuple(col_ndx)); // Throws
+    return true;
+}
+
+inline void TransactLogConvenientEncoder::add_search_index(const Table* t, size_t col_ndx)
+{
+    select_table(t); // Throws
+    m_encoder.add_search_index(col_ndx); // Throws
+}
+
+
+inline bool TransactLogEncoder::remove_search_index(size_t col_ndx)
+{
+    append_simple_instr(instr_RemoveSearchIndex, util::tuple(col_ndx)); // Throws
+    return true;
+}
+
+inline void TransactLogConvenientEncoder::remove_search_index(const Table* t, size_t col_ndx)
+{
+    select_table(t); // Throws
+    m_encoder.remove_search_index(col_ndx); // Throws
+}
+
+inline bool TransactLogEncoder::set_link_type(size_t col_ndx, LinkType link_type)
+{
+    append_simple_instr(instr_SetLinkType, util::tuple(col_ndx, int(link_type))); // Throws
+    return true;
+}
+
+inline void TransactLogConvenientEncoder::set_link_type(const Table* t, size_t col_ndx, LinkType link_type)
+{
+    select_table(t); // Throws
+    m_encoder.set_link_type(col_ndx, link_type); // Throws
+}
+
+
+inline bool TransactLogEncoder::clear_table()
+{
+    append_simple_instr(instr_ClearTable, util::tuple()); // Throws
+    return true;
+}
+
+inline void TransactLogConvenientEncoder::clear_table(const Table* t)
+{
+    select_table(t); // Throws
+    m_encoder.clear_table(); // Throws
+}
+
+inline bool TransactLogEncoder::optimize_table()
+{
+    append_simple_instr(instr_OptimizeTable, util::tuple()); // Throws
+    return true;
+}
+
+inline void TransactLogConvenientEncoder::optimize_table(const Table* t)
+{
+    select_table(t); // Throws
+    m_encoder.optimize_table(); // Throws
+}
+
+inline bool TransactLogEncoder::link_list_set(size_t link_ndx, size_t value)
+{
+    append_simple_instr(instr_LinkListSet, util::tuple(link_ndx, value)); // Throws
+    return true;
+}
+
+inline void TransactLogConvenientEncoder::link_list_set(const LinkView& list, size_t link_ndx,
+                                       size_t value)
+{
+    select_link_list(list); // Throws
+    m_encoder.link_list_set(link_ndx, value); // Throws
+}
+
+inline bool TransactLogEncoder::link_list_nullify(size_t link_ndx)
+{
+    append_simple_instr(instr_LinkListNullify, util::tuple(link_ndx)); // Throws
+    return true;
+}
+
+inline void TransactLogConvenientEncoder::link_list_nullify(const LinkView& list, size_t link_ndx)
+{
+    select_link_list(list); // Throws
+    m_encoder.link_list_nullify(link_ndx); // Throws
+}
+
+inline bool TransactLogEncoder::link_list_set_all(const IntegerColumn& values)
+{
+    struct iter {
+        iter(const IntegerColumn& iter_values, size_t ndx): m_values(&iter_values), m_ndx(ndx) {}
+        const IntegerColumn* m_values;
+        size_t m_ndx;
+        bool operator==(const iter& i) const { return m_ndx == i.m_ndx; }
+        bool operator!=(const iter& i) const { return m_ndx != i.m_ndx; }
+        size_t operator-(const iter& i) const { return m_ndx - i.m_ndx; }
+        int_fast64_t operator*() const { return m_values->get(m_ndx); }
+        iter& operator++() { ++m_ndx; return *this; }
+        iter operator++(int) { iter i = *this; ++m_ndx; return i; }
+    };
+    size_t num_values = values.size();
+    append_variable_size_instr(instr_LinkListSetAll, util::tuple(num_values),
+                               iter(values, 0), iter(values, num_values)); // Throws
+    return true;
+}
+
+inline void TransactLogConvenientEncoder::set_link_list(const LinkView& list, const IntegerColumn& values)
+{
+    select_link_list(list); // Throws
+    m_encoder.link_list_set_all(values); // Throws
+}
+
+inline bool TransactLogEncoder::link_list_insert(size_t link_ndx, size_t value)
+{
+    append_simple_instr(instr_LinkListInsert, util::tuple(link_ndx, value)); // Throws
+    return true;
+}
+
+inline void TransactLogConvenientEncoder::link_list_insert(const LinkView& list, size_t link_ndx,
+                                          size_t value)
+{
+    select_link_list(list); // Throws
+    m_encoder.link_list_insert(link_ndx, value); // Throws
+}
+
+inline bool TransactLogEncoder::link_list_move(size_t from_link_ndx, size_t to_link_ndx)
+{
+    REALM_ASSERT(from_link_ndx != to_link_ndx);
+    append_simple_instr(instr_LinkListMove, util::tuple(from_link_ndx, to_link_ndx)); // Throws
+    return true;
+}
+
+inline void TransactLogConvenientEncoder::link_list_move(const LinkView& list, size_t from_link_ndx,
+                                                         size_t to_link_ndx)
+{
+    select_link_list(list); // Throws
+    m_encoder.link_list_move(from_link_ndx, to_link_ndx); // Throws
+}
+
+inline bool TransactLogEncoder::link_list_swap(size_t link1_ndx, size_t link2_ndx)
+{
+    append_simple_instr(instr_LinkListSwap, util::tuple(link1_ndx, link2_ndx)); // Throws
+    return true;
+}
+
+inline void TransactLogConvenientEncoder::link_list_swap(const LinkView& list, size_t link1_ndx,
+                                                         size_t link2_ndx)
+{
+    select_link_list(list); // Throws
+    m_encoder.link_list_swap(link1_ndx, link2_ndx); // Throws
+}
+
+inline bool TransactLogEncoder::link_list_erase(size_t link_ndx)
+{
+    append_simple_instr(instr_LinkListErase, util::tuple(link_ndx)); // Throws
+    return true;
+}
+
+inline void TransactLogConvenientEncoder::link_list_erase(const LinkView& list, size_t link_ndx)
+{
+    select_link_list(list); // Throws
+    m_encoder.link_list_erase(link_ndx); // Throws
+}
+
+inline bool TransactLogEncoder::link_list_clear(size_t old_list_size)
+{
+    append_simple_instr(instr_LinkListClear, util::tuple(old_list_size)); // Throws
+    return true;
+}
+
+inline void TransactLogConvenientEncoder::on_table_destroyed(const Table* t) noexcept
+{
+    if (m_selected_table == t)
+        m_selected_table = nullptr;
+}
+
+inline void TransactLogConvenientEncoder::on_spec_destroyed(const Spec* s) noexcept
+{
+    if (m_selected_spec == s)
+        m_selected_spec = nullptr;
+}
+
+
+inline void TransactLogConvenientEncoder::on_link_list_destroyed(const LinkView& list) noexcept
+{
+    const LinkView* lw_ptr = &list;
+    // atomically clear m_selected_link_list iff it already points to 'list':
+    // (lw_ptr will be modified if the swap fails, but we ignore that)
+    m_selected_link_list.compare_exchange_strong(lw_ptr, nullptr,
+                                                 std::memory_order_relaxed,
+                                                 std::memory_order_relaxed);
+}
+
+
+inline TransactLogParser::TransactLogParser():
+    m_input_buffer(1024) // Throws
+{
+}
+
+
+inline TransactLogParser::~TransactLogParser() noexcept
+{
+}
+
+
+template<class InstructionHandler>
+void TransactLogParser::parse(NoCopyInputStream& in, InstructionHandler& handler)
+{
+    m_input = &in;
+    m_input_begin = m_input_end = nullptr;
+
+    while (has_next())
+        parse_one(handler); // Throws
+}
+
+template<class InstructionHandler>
+void TransactLogParser::parse(InputStream& in, InstructionHandler& handler)
+{
+    NoCopyInputStreamAdaptor in_2(in, m_input_buffer.data(), m_input_buffer.size());
+    parse(in_2, handler); // Throws
+}
+
+inline bool TransactLogParser::has_next() noexcept
+{
+    return m_input_begin != m_input_end || next_input_buffer();
+}
+
+template<class InstructionHandler>
+void TransactLogParser::parse_one(InstructionHandler& handler)
+{
+    char instr;
+    if (!read_char(instr))
+        parser_error();
+//    std::cerr << "parsing " << util::promote(instr) << " @ " << std::hex << long(m_input_begin) << std::dec << "\n";
+    switch (Instruction(instr)) {
+        case instr_SetInt: {
+            size_t col_ndx = read_int<size_t>(); // Throws
+            size_t row_ndx = read_int<size_t>(); // Throws
+            // FIXME: Don't depend on the existence of int64_t,
+            // but don't allow values to use more than 64 bits
+            // either.
+            int_fast64_t value = read_int<int64_t>(); // Throws
+            if (!handler.set_int(col_ndx, row_ndx, value)) // Throws
+                parser_error();
+            return;
+        }
+        case instr_SetIntUnique: {
+            size_t col_ndx = read_int<size_t>(); // Throws
+            size_t row_ndx = read_int<size_t>(); // Throws
+            size_t prior_num_rows = read_int<size_t>(); // Throws
+            // FIXME: Don't depend on the existence of int64_t,
+            // but don't allow values to use more than 64 bits
+            // either.
+            int_fast64_t value = read_int<int64_t>(); // Throws
+            if (!handler.set_int_unique(col_ndx, row_ndx, prior_num_rows, value)) // Throws
+                parser_error();
+            return;
+        }
+        case instr_SetBool: {
+            size_t col_ndx = read_int<size_t>(); // Throws
+            size_t row_ndx = read_int<size_t>(); // Throws
+            bool value = read_bool(); // Throws
+            if (!handler.set_bool(col_ndx, row_ndx, value)) // Throws
+                parser_error();
+            return;
+        }
+        case instr_SetFloat: {
+            size_t col_ndx = read_int<size_t>(); // Throws
+            size_t row_ndx = read_int<size_t>(); // Throws
+            float value = read_float(); // Throws
+            if (!handler.set_float(col_ndx, row_ndx, value)) // Throws
+                parser_error();
+            return;
+        }
+        case instr_SetDouble: {
+            size_t col_ndx = read_int<size_t>(); // Throws
+            size_t row_ndx = read_int<size_t>(); // Throws
+            double value = read_double(); // Throws
+            if (!handler.set_double(col_ndx, row_ndx, value)) // Throws
+                parser_error();
+            return;
+        }
+        case instr_SetString: {
+            size_t col_ndx = read_int<size_t>(); // Throws
+            size_t row_ndx = read_int<size_t>(); // Throws
+            StringData value = read_string(m_string_buffer); // Throws
+            if (!handler.set_string(col_ndx, row_ndx, value)) // Throws
+                parser_error();
+            return;
+        }
+        case instr_SetStringUnique: {
+            size_t col_ndx = read_int<size_t>(); // Throws
+            size_t row_ndx = read_int<size_t>(); // Throws
+            size_t prior_num_rows = read_int<size_t>(); // Throws
+            StringData value = read_string(m_string_buffer); // Throws
+            if (!handler.set_string_unique(col_ndx, row_ndx, prior_num_rows, value)) // Throws
+                parser_error();
+            return;
+        }
+        case instr_SetBinary: {
+            size_t col_ndx = read_int<size_t>(); // Throws
+            size_t row_ndx = read_int<size_t>(); // Throws
+            BinaryData value = read_binary(m_string_buffer); // Throws
+            if (!handler.set_binary(col_ndx, row_ndx, value)) // Throws
+                parser_error();
+            return;
+        }
+        case instr_SetOldDateTime: {
+            size_t col_ndx = read_int<size_t>(); // Throws
+            size_t row_ndx = read_int<size_t>(); // Throws
+            int_fast64_t value = read_int<int_fast64_t>(); // Throws
+            if (!handler.set_olddatetime(col_ndx, row_ndx, value)) // Throws
+                parser_error();
+            return;
+        }
+        case instr_SetTimestamp: {
+            size_t col_ndx = read_int<size_t>(); // Throws
+            size_t row_ndx = read_int<size_t>(); // Throws
+            int64_t seconds = read_int<int64_t>(); // Throws
+            int32_t nanoseconds = read_int<int32_t>(); // Throws
+            Timestamp value = Timestamp(seconds, nanoseconds);
+            if (!handler.set_timestamp(col_ndx, row_ndx, value)) // Throws
+                parser_error();
+            return;
+        }
+        case instr_SetTable: {
+            size_t col_ndx = read_int<size_t>(); // Throws
+            size_t row_ndx = read_int<size_t>(); // Throws
+            if (!handler.set_table(col_ndx, row_ndx)) // Throws
+                parser_error();
+            return;
+        }
+        case instr_SetMixed: {
+            size_t col_ndx = read_int<size_t>(); // Throws
+            size_t row_ndx = read_int<size_t>(); // Throws
+            Mixed value;
+            read_mixed(&value); // Throws
+            if (!handler.set_mixed(col_ndx, row_ndx, value)) // Throws
+                parser_error();
+            return;
+        }
+        case instr_SetLink: {
+            size_t col_ndx = read_int<size_t>(); // Throws
+            size_t row_ndx = read_int<size_t>(); // Throws
+            size_t value = read_int<size_t>(); // Throws
+            // Map zero to realm::npos, and `n+1` to `n`, where `n` is a target row index.
+            size_t target_row_ndx = size_t(value - 1);
+            size_t target_group_level_ndx = read_int<size_t>(); // Throws
+            if (!handler.set_link(col_ndx, row_ndx, target_row_ndx, target_group_level_ndx)) // Throws
+                parser_error();
+            return;
+        }
+        case instr_SetNull: {
+            size_t col_ndx = read_int<size_t>(); // Throws
+            size_t row_ndx = read_int<size_t>(); // Throws
+            if (!handler.set_null(col_ndx, row_ndx)) // Throws
+                parser_error();
+            return;
+        }
+        case instr_NullifyLink: {
+            size_t col_ndx = read_int<size_t>(); // Throws
+            size_t row_ndx = read_int<size_t>(); // Throws
+            size_t target_group_level_ndx = read_int<size_t>(); // Throws
+            if (!handler.nullify_link(col_ndx, row_ndx, target_group_level_ndx)) // Throws
+                parser_error();
+            return;
+        }
+        case instr_InsertSubstring: {
+            size_t col_ndx = read_int<size_t>(); // Throws
+            size_t row_ndx = read_int<size_t>(); // Throws
+            size_t pos = read_int<size_t>(); // Throws
+            StringData value = read_string(m_string_buffer); // Throws
+            if (!handler.insert_substring(col_ndx, row_ndx, pos, value)) // Throws
+                parser_error();
+            return;
+        }
+        case instr_EraseFromString: {
+            size_t col_ndx = read_int<size_t>(); // Throws
+            size_t row_ndx = read_int<size_t>(); // Throws
+            size_t pos = read_int<size_t>(); // Throws
+            size_t size = read_int<size_t>(); // Throws
+            if (!handler.erase_substring(col_ndx, row_ndx, pos, size)) // Throws
+                parser_error();
+            return;
+        }
+        case instr_InsertEmptyRows: {
+            size_t row_ndx = read_int<size_t>(); // Throws
+            size_t num_rows_to_insert = read_int<size_t>(); // Throws
+            size_t prior_num_rows = read_int<size_t>(); // Throws
+            bool unordered = read_bool(); // Throws
+            if (!handler.insert_empty_rows(row_ndx, num_rows_to_insert, prior_num_rows,
+                                           unordered)) // Throws
+                parser_error();
+            return;
+        }
+        case instr_EraseRows: {
+            size_t row_ndx = read_int<size_t>(); // Throws
+            size_t num_rows_to_erase = read_int<size_t>(); // Throws
+            size_t prior_num_rows = read_int<size_t>(); // Throws
+            bool unordered = read_bool(); // Throws
+            if (!handler.erase_rows(row_ndx, num_rows_to_erase, prior_num_rows,
+                                    unordered)) // Throws
+                parser_error();
+            return;
+        }
+        case instr_SwapRows: {
+            size_t row_ndx_1 = read_int<size_t>(); // Throws
+            size_t row_ndx_2 = read_int<size_t>(); // Throws
+            if (!handler.swap_rows(row_ndx_1, row_ndx_2)) // Throws
+                parser_error();
+            return;
+        }
+        case instr_ChangeLinkTargets: {
+            size_t row_ndx = read_int<size_t>(); // Throws
+            size_t new_row_ndx = read_int<size_t>(); // Throws
+            if (!handler.change_link_targets(row_ndx, new_row_ndx)) // Throws
+                parser_error();
+            return;
+        }
+        case instr_SelectTable: {
+            int levels = read_int<int>(); // Throws
+            if (levels < 0 || levels > m_max_levels)
+                parser_error();
+            m_path.reserve(0, 2*levels); // Throws
+            size_t* path = m_path.data();
+            size_t group_level_ndx = read_int<size_t>(); // Throws
+            for (int i = 0; i != levels; ++i) {
+                size_t col_ndx = read_int<size_t>(); // Throws
+                size_t row_ndx = read_int<size_t>(); // Throws
+                path[2*i + 0] = col_ndx;
+                path[2*i + 1] = row_ndx;
+            }
+            if (!handler.select_table(group_level_ndx, levels, path)) // Throws
+                parser_error();
+            return;
+        }
+        case instr_ClearTable: {
+            if (!handler.clear_table()) // Throws
+                parser_error();
+            return;
+        }
+        case instr_LinkListSet: {
+            size_t link_ndx = read_int<size_t>(); // Throws
+            size_t value = read_int<size_t>(); // Throws
+            if (!handler.link_list_set(link_ndx, value)) // Throws
+                parser_error();
+            return;
+        }
+        case instr_LinkListSetAll: {
+            // todo, log that it's a SetAll we're doing
+            size_t size = read_int<size_t>(); // Throws
+            for (size_t i = 0; i < size; i++) {
+                size_t link = read_int<size_t>(); // Throws
+                if (!handler.link_list_set(i, link)) // Throws
+                    parser_error();
+            }
+            return;
+        }
+        case instr_LinkListInsert: {
+            size_t link_ndx = read_int<size_t>(); // Throws
+            size_t value = read_int<size_t>(); // Throws
+            if (!handler.link_list_insert(link_ndx, value)) // Throws
+                parser_error();
+            return;
+        }
+        case instr_LinkListMove: {
+            size_t from_link_ndx = read_int<size_t>(); // Throws
+            size_t to_link_ndx   = read_int<size_t>(); // Throws
+            if (!handler.link_list_move(from_link_ndx, to_link_ndx)) // Throws
+                parser_error();
+            return;
+        }
+        case instr_LinkListSwap: {
+            size_t link1_ndx = read_int<size_t>(); // Throws
+            size_t link2_ndx = read_int<size_t>(); // Throws
+            if (!handler.link_list_swap(link1_ndx, link2_ndx)) // Throws
+                parser_error();
+            return;
+        }
+        case instr_LinkListErase: {
+            size_t link_ndx = read_int<size_t>(); // Throws
+            if (!handler.link_list_erase(link_ndx)) // Throws
+                parser_error();
+            return;
+        }
+        case instr_LinkListNullify: {
+            size_t link_ndx = read_int<size_t>(); // Throws
+            if (!handler.link_list_nullify(link_ndx)) // Throws
+                parser_error();
+            return;
+        }
+        case instr_LinkListClear: {
+            size_t old_list_size = read_int<size_t>(); // Throws
+            if (!handler.link_list_clear(old_list_size)) // Throws
+                parser_error();
+            return;
+        }
+        case instr_SelectLinkList: {
+            size_t col_ndx = read_int<size_t>(); // Throws
+            size_t row_ndx = read_int<size_t>(); // Throws
+            size_t target_group_level_ndx = read_int<size_t>(); // Throws
+            if (!handler.select_link_list(col_ndx, row_ndx, target_group_level_ndx)) // Throws
+                parser_error();
+            return;
+        }
+        case instr_AddSearchIndex: {
+            size_t col_ndx = read_int<size_t>(); // Throws
+            if (!handler.add_search_index(col_ndx)) // Throws
+                parser_error();
+            return;
+        }
+        case instr_RemoveSearchIndex: {
+            size_t col_ndx = read_int<size_t>(); // Throws
+            if (!handler.remove_search_index(col_ndx)) // Throws
+                parser_error();
+            return;
+        }
+        case instr_SetLinkType: {
+            size_t col_ndx = read_int<size_t>(); // Throws
+            int link_type = read_int<int>(); // Throws
+            if (!is_valid_link_type(link_type))
+                parser_error();
+            if (!handler.set_link_type(col_ndx, LinkType(link_type))) // Throws
+                parser_error();
+            return;
+        }
+        case instr_InsertColumn:
+        case instr_InsertNullableColumn: {
+            size_t col_ndx = read_int<size_t>(); // Throws
+            int type = read_int<int>(); // Throws
+            if (!is_valid_data_type(type))
+                parser_error();
+            if (REALM_UNLIKELY(type == type_Link || type == type_LinkList))
+                parser_error();
+            StringData name = read_string(m_string_buffer); // Throws
+            bool nullable = (Instruction(instr) == instr_InsertNullableColumn);
+            if (REALM_UNLIKELY(nullable && (type == type_Table || type == type_Mixed))) {
+                // Nullability not supported for Table and Mixed columns.
+                parser_error();
+            }
+            if (!handler.insert_column(col_ndx, DataType(type), name, nullable)) // Throws
+                parser_error();
+            return;
+        }
+        case instr_InsertLinkColumn: {
+            size_t col_ndx = read_int<size_t>(); // Throws
+            int type = read_int<int>(); // Throws
+            if (!is_valid_data_type(type))
+                parser_error();
+            if (REALM_UNLIKELY(type != type_Link && type != type_LinkList))
+                parser_error();
+            size_t link_target_table_ndx = read_int<size_t>(); // Throws
+            size_t backlink_col_ndx = read_int<size_t>(); // Throws
+            StringData name = read_string(m_string_buffer); // Throws
+            if (!handler.insert_link_column(col_ndx, DataType(type), name,
+                                            link_target_table_ndx, backlink_col_ndx)) // Throws
+                parser_error();
+            return;
+        }
+        case instr_EraseColumn: {
+            size_t col_ndx = read_int<size_t>(); // Throws
+            if (!handler.erase_column(col_ndx)) // Throws
+                parser_error();
+            return;
+        }
+        case instr_EraseLinkColumn: {
+            size_t col_ndx = read_int<size_t>(); // Throws
+            size_t link_target_table_ndx = read_int<size_t>(); // Throws
+            size_t backlink_col_ndx      = read_int<size_t>(); // Throws
+            if (!handler.erase_link_column(col_ndx, link_target_table_ndx,
+                                           backlink_col_ndx)) // Throws
+                parser_error();
+            return;
+        }
+        case instr_RenameColumn: {
+            size_t col_ndx = read_int<size_t>(); // Throws
+            StringData name = read_string(m_string_buffer); // Throws
+            if (!handler.rename_column(col_ndx, name)) // Throws
+                parser_error();
+            return;
+        }
+        case instr_MoveColumn: {
+            size_t col_ndx_1 = read_int<size_t>(); // Throws
+            size_t col_ndx_2 = read_int<size_t>(); // Throws
+            if (!handler.move_column(col_ndx_1, col_ndx_2)) // Throws
+                parser_error();
+            return;
+        }
+        case instr_SelectDescriptor: {
+            int levels = read_int<int>(); // Throws
+            if (levels < 0 || levels > m_max_levels)
+                parser_error();
+            m_path.reserve(0, levels); // Throws
+            size_t* path = m_path.data();
+            for (int i = 0; i != levels; ++i) {
+                size_t col_ndx = read_int<size_t>(); // Throws
+                path[i] = col_ndx;
+            }
+            if (!handler.select_descriptor(levels, path)) // Throws
+                parser_error();
+            return;
+        }
+        case instr_InsertGroupLevelTable: {
+            size_t table_ndx  = read_int<size_t>(); // Throws
+            size_t num_tables = read_int<size_t>(); // Throws
+            StringData name = read_string(m_string_buffer); // Throws
+            if (!handler.insert_group_level_table(table_ndx, num_tables, name)) // Throws
+                parser_error();
+            return;
+        }
+        case instr_EraseGroupLevelTable: {
+            size_t table_ndx  = read_int<size_t>(); // Throws
+            size_t prior_num_tables = read_int<size_t>(); // Throws
+            if (!handler.erase_group_level_table(table_ndx, prior_num_tables)) // Throws
+                parser_error();
+            return;
+        }
+        case instr_RenameGroupLevelTable: {
+            size_t table_ndx = read_int<size_t>(); // Throws
+            StringData new_name = read_string(m_string_buffer); // Throws
+            if (!handler.rename_group_level_table(table_ndx, new_name)) // Throws
+                parser_error();
+            return;
+        }
+        case instr_MoveGroupLevelTable: {
+            size_t from_table_ndx = read_int<size_t>(); // Throws
+            size_t to_table_ndx   = read_int<size_t>(); // Throws
+            if (!handler.move_group_level_table(from_table_ndx, to_table_ndx)) // Throws
+                parser_error();
+            return;
+        }
+        case instr_OptimizeTable: {
+            if (!handler.optimize_table()) // Throws
+                parser_error();
+            return;
+        }
+    }
+
+    throw BadTransactLog();
+}
+
+
+template<class T>
+T TransactLogParser::read_int()
+{
+    T value = 0;
+    int part = 0;
+    const int max_bytes = (std::numeric_limits<T>::digits+1+6)/7;
+    for (int i = 0; i != max_bytes; ++i) {
+        char c;
+        if (!read_char(c))
+            goto bad_transact_log;
+        part = static_cast<unsigned char>(c);
+        if (0xFF < part)
+            goto bad_transact_log; // Only the first 8 bits may be used in each byte
+        if ((part & 0x80) == 0) {
+            T p = part & 0x3F;
+            if (util::int_shift_left_with_overflow_detect(p, i*7))
+                goto bad_transact_log;
+            value |= p;
+            break;
+        }
+        if (i == max_bytes-1)
+            goto bad_transact_log; // Too many bytes
+        value |= T(part & 0x7F) << (i*7);
+    }
+    if (part & 0x40) {
+        // The real value is negative. Because 'value' is positive at
+        // this point, the following negation is guaranteed by C++11
+        // to never overflow. See C99+TC3 section 6.2.6.2 paragraph 2.
+        REALM_DIAG_PUSH();
+        REALM_DIAG_IGNORE_UNSIGNED_MINUS();
+        value = -value;
+        REALM_DIAG_POP();
+        if (util::int_subtract_with_overflow_detect(value, 1))
+            goto bad_transact_log;
+    }
+    return value;
+
+  bad_transact_log:
+    throw BadTransactLog();
+}
+
+
+inline void TransactLogParser::read_bytes(char* data, size_t size)
+{
+    for (;;) {
+        const size_t avail = m_input_end - m_input_begin;
+        if (size <= avail)
+            break;
+        const char* to = m_input_begin + avail;
+        std::copy(m_input_begin, to, data);
+        if (!next_input_buffer())
+            throw BadTransactLog();
+        data += avail;
+        size -= avail;
+    }
+    const char* to = m_input_begin + size;
+    std::copy(m_input_begin, to, data);
+    m_input_begin = to;
+}
+
+
+inline BinaryData TransactLogParser::read_buffer(util::StringBuffer& buf, size_t size)
+{
+    const size_t avail = m_input_end - m_input_begin;
+    if (avail >= size) {
+        m_input_begin += size;
+        return BinaryData(m_input_begin - size, size);
+    }
+
+    buf.clear();
+    buf.resize(size); // Throws
+    read_bytes(buf.data(), size);
+    return BinaryData(buf.data(), size);
+}
+
+
+inline bool TransactLogParser::read_bool()
+{
+    return read_int<char>();
+}
+
+
+inline float TransactLogParser::read_float()
+{
+    static_assert(std::numeric_limits<float>::is_iec559 &&
+                          sizeof (float) * std::numeric_limits<unsigned char>::digits == 32,
+                          "Unsupported 'float' representation");
+    float value;
+    read_bytes(reinterpret_cast<char*>(&value), sizeof value); // Throws
+    return value;
+}
+
+
+inline double TransactLogParser::read_double()
+{
+    static_assert(std::numeric_limits<double>::is_iec559 &&
+                          sizeof (double) * std::numeric_limits<unsigned char>::digits == 64,
+                          "Unsupported 'double' representation");
+    double value;
+    read_bytes(reinterpret_cast<char*>(&value), sizeof value); // Throws
+    return value;
+}
+
+
+inline StringData TransactLogParser::read_string(util::StringBuffer& buf)
+{
+    size_t size = read_int<size_t>(); // Throws
+
+    if (size > Table::max_string_size)
+        parser_error();
+
+    BinaryData buffer = read_buffer(buf, size);
+    return StringData{buffer.data(), size};
+}
+
+inline Timestamp TransactLogParser::read_timestamp()
+{
+    REALM_ASSERT(false);
+    return Timestamp(null{});
+}
+
+
+inline BinaryData TransactLogParser::read_binary(util::StringBuffer& buf)
+{
+    size_t size = read_int<size_t>(); // Throws
+
+    if (size > Table::max_binary_size)
+        parser_error();
+
+    return read_buffer(buf, size);
+}
+
+
+inline void TransactLogParser::read_mixed(Mixed* mixed)
+{
+    DataType type = DataType(read_int<int>()); // Throws
+    switch (type) {
+        case type_Int: {
+            // FIXME: Don't depend on the existence of
+            // int64_t, but don't allow values to use more
+            // than 64 bits either.
+            int_fast64_t value = read_int<int64_t>(); // Throws
+            mixed->set_int(value);
+            return;
+        }
+        case type_Bool: {
+            bool value = read_bool(); // Throws
+            mixed->set_bool(value);
+            return;
+        }
+        case type_Float: {
+            float value = read_float(); // Throws
+            mixed->set_float(value);
+            return;
+        }
+        case type_Double: {
+            double value = read_double(); // Throws
+            mixed->set_double(value);
+            return;
+        }
+        case type_OldDateTime: {
+            int_fast64_t value = read_int<int_fast64_t>(); // Throws
+            mixed->set_olddatetime(value);
+            return;
+        }
+        case type_Timestamp: {
+            Timestamp value = read_timestamp(); // Throws
+            mixed->set_timestamp(value);
+            return;
+        }
+        case type_String: {
+            StringData value = read_string(m_string_buffer); // Throws
+            mixed->set_string(value);
+            return;
+        }
+        case type_Binary: {
+            BinaryData value = read_binary(m_string_buffer); // Throws
+            mixed->set_binary(value);
+            return;
+        }
+        case type_Table: {
+            *mixed = Mixed::subtable_tag();
+            return;
+        }
+        case type_Mixed:
+            break;
+        case type_Link:
+        case type_LinkList:
+            // FIXME: Need to handle new link types here
+            break;
+    }
+    throw BadTransactLog();
+}
+
+
+inline bool TransactLogParser::next_input_buffer()
+{
+    size_t sz = m_input->next_block(m_input_begin, m_input_end);
+    if (sz == 0)
+        return false;
+    else
+        return true;
+}
+
+
+inline bool TransactLogParser::read_char(char& c)
+{
+    if (m_input_begin == m_input_end && !next_input_buffer())
+        return false;
+    c = *m_input_begin++;
+    return true;
+}
+
+
+inline bool TransactLogParser::is_valid_data_type(int type)
+{
+    switch (DataType(type)) {
+        case type_Int:
+        case type_Bool:
+        case type_Float:
+        case type_Double:
+        case type_String:
+        case type_Binary:
+        case type_OldDateTime:
+        case type_Timestamp:
+        case type_Table:
+        case type_Mixed:
+        case type_Link:
+        case type_LinkList:
+            return true;
+    }
+    return false;
+}
+
+
+inline bool TransactLogParser::is_valid_link_type(int type)
+{
+    switch (LinkType(type)) {
+        case link_Strong:
+        case link_Weak:
+            return true;
+    }
+    return false;
+}
+
+
+class TransactReverser {
+public:
+    bool select_table(size_t group_level_ndx, size_t levels, const size_t* path)
+    {
+        sync_table();
+        m_encoder.select_table(group_level_ndx, levels, path);
+        m_pending_ts_instr = get_inst();
+        return true;
+    }
+
+    bool select_descriptor(size_t levels, const size_t* path)
+    {
+        sync_descriptor();
+        m_encoder.select_descriptor(levels, path);
+        m_pending_ds_instr = get_inst();
+        return true;
+    }
+
+    bool insert_group_level_table(size_t table_ndx, size_t num_tables, StringData)
+    {
+        sync_table();
+        m_encoder.erase_group_level_table(table_ndx, num_tables + 1);
+        append_instruction();
+        return true;
+    }
+
+    bool erase_group_level_table(size_t table_ndx, size_t num_tables)
+    {
+        sync_table();
+        m_encoder.insert_group_level_table(table_ndx, num_tables - 1, "");
+        append_instruction();
+        return true;
+    }
+
+    bool rename_group_level_table(size_t, StringData)
+    {
+        sync_table();
+        return true;
+    }
+
+    bool move_group_level_table(size_t from_table_ndx, size_t to_table_ndx)
+    {
+        sync_table();
+        m_encoder.move_group_level_table(to_table_ndx, from_table_ndx);
+        append_instruction();
+        return true;
+    }
+
+    bool optimize_table()
+    {
+        return true; // No-op
+    }
+
+    bool insert_empty_rows(size_t row_ndx, size_t num_rows_to_insert, size_t prior_num_rows,
+                           bool unordered)
+    {
+        size_t num_rows_to_erase = num_rows_to_insert;
+        size_t prior_num_rows_2 = prior_num_rows + num_rows_to_insert;
+        m_encoder.erase_rows(row_ndx, num_rows_to_erase, prior_num_rows_2, unordered); // Throws
+        append_instruction();
+        return true;
+    }
+
+    bool erase_rows(size_t row_ndx, size_t num_rows_to_erase, size_t prior_num_rows,
+                    bool unordered)
+    {
+        size_t num_rows_to_insert = num_rows_to_erase;
+        // Number of rows in table after removal, but before inverse insertion
+        size_t prior_num_rows_2 = prior_num_rows - num_rows_to_erase;
+        m_encoder.insert_empty_rows(row_ndx, num_rows_to_insert, prior_num_rows_2,
+                                    unordered); // Throws
+        append_instruction();
+        return true;
+    }
+
+    bool swap_rows(size_t row_ndx_1, size_t row_ndx_2)
+    {
+        m_encoder.swap_rows(row_ndx_1, row_ndx_2);
+        append_instruction();
+        return true;
+    }
+
+    bool change_link_targets(size_t row_ndx, size_t new_row_ndx)
+    {
+        static_cast<void>(row_ndx);
+        static_cast<void>(new_row_ndx);
+        // There is no instruction we can generate here to change back.
+        return true;
+    }
+
+    bool set_int(size_t col_ndx, size_t row_ndx, int_fast64_t value)
+    {
+        m_encoder.set_int(col_ndx, row_ndx, value);
+        append_instruction();
+        return true;
+    }
+
+    bool set_int_unique(size_t col_ndx, size_t row_ndx, size_t prior_num_rows, int_fast64_t value)
+    {
+        m_encoder.set_int_unique(col_ndx, row_ndx, prior_num_rows, value);
+        append_instruction();
+        return true;
+    }
+
+    bool set_bool(size_t col_ndx, size_t row_ndx, bool value)
+    {
+        m_encoder.set_bool(col_ndx, row_ndx, value);
+        append_instruction();
+        return true;
+    }
+
+    bool set_float(size_t col_ndx, size_t row_ndx, float value)
+    {
+        m_encoder.set_float(col_ndx, row_ndx, value);
+        append_instruction();
+        return true;
+    }
+
+    bool set_double(size_t col_ndx, size_t row_ndx, double value)
+    {
+        m_encoder.set_double(col_ndx, row_ndx, value);
+        append_instruction();
+        return true;
+    }
+
+    bool set_string(size_t col_ndx, size_t row_ndx, StringData value)
+    {
+        m_encoder.set_string(col_ndx, row_ndx, value);
+        append_instruction();
+        return true;
+    }
+
+    bool set_string_unique(size_t col_ndx, size_t row_ndx, size_t prior_num_rows, StringData value)
+    {
+        m_encoder.set_string_unique(col_ndx, row_ndx, prior_num_rows, value);
+        append_instruction();
+        return true;
+    }
+
+    bool set_binary(size_t col_ndx, size_t row_ndx, BinaryData value)
+    {
+        m_encoder.set_binary(col_ndx, row_ndx, value);
+        append_instruction();
+        return true;
+    }
+
+    bool set_olddatetime(size_t col_ndx, size_t row_ndx, OldDateTime value)
+    {
+        m_encoder.set_olddatetime(col_ndx, row_ndx, value);
+        append_instruction();
+        return true;
+    }
+
+    bool set_timestamp(size_t col_ndx, size_t row_ndx, Timestamp value)
+    {
+        m_encoder.set_timestamp(col_ndx, row_ndx, value);
+        append_instruction();
+        return true;
+    }
+
+    bool set_table(size_t col_ndx, size_t row_ndx)
+    {
+        m_encoder.set_table(col_ndx, row_ndx);
+        append_instruction();
+        return true;
+    }
+
+    bool set_mixed(size_t col_ndx, size_t row_ndx, const Mixed& value)
+    {
+        m_encoder.set_mixed(col_ndx, row_ndx, value);
+        append_instruction();
+        return true;
+    }
+
+    bool set_null(size_t col_ndx, size_t row_ndx)
+    {
+        m_encoder.set_null(col_ndx, row_ndx);
+        append_instruction();
+        return true;
+    }
+
+    bool set_link(size_t col_ndx, size_t row_ndx, size_t value, size_t target_group_level_ndx)
+    {
+        m_encoder.set_link(col_ndx, row_ndx, value, target_group_level_ndx);
+        append_instruction();
+        return true;
+    }
+
+    bool insert_substring(size_t, size_t, size_t, StringData)
+    {
+        return true; // No-op
+    }
+
+    bool erase_substring(size_t, size_t, size_t, size_t)
+    {
+        return true; // No-op
+    }
+
+    bool clear_table()
+    {
+        m_encoder.insert_empty_rows(0, 0, 0, true); // FIXME: Explain what is going on here (Finn).
+        append_instruction();
+        return true;
+    }
+
+    bool add_search_index(size_t)
+    {
+        return true; // No-op
+    }
+
+    bool remove_search_index(size_t)
+    {
+        return true; // No-op
+    }
+
+    bool set_link_type(size_t, LinkType)
+    {
+        return true; // No-op
+    }
+
+    bool insert_link_column(size_t col_idx, DataType, StringData,
+                            size_t target_table_idx, size_t backlink_col_ndx)
+    {
+        m_encoder.erase_link_column(col_idx, target_table_idx, backlink_col_ndx);
+        append_instruction();
+        return true;
+    }
+
+    bool erase_link_column(size_t col_idx, size_t target_table_idx,
+                           size_t backlink_col_idx)
+    {
+        DataType type = type_Link; // The real type of the column doesn't matter here,
+                                   // but the encoder asserts that it's actually a link type.
+        m_encoder.insert_link_column(col_idx, type, "", target_table_idx, backlink_col_idx);
+        append_instruction();
+        return true;
+    }
+
+    bool insert_column(size_t col_idx, DataType, StringData, bool)
+    {
+        m_encoder.erase_column(col_idx);
+        append_instruction();
+        return true;
+    }
+
+    bool erase_column(size_t col_idx)
+    {
+        m_encoder.insert_column(col_idx, DataType(), "");
+        append_instruction();
+        return true;
+    }
+
+    bool rename_column(size_t, StringData)
+    {
+        return true; // No-op
+    }
+
+    bool move_column(size_t col_ndx_1, size_t col_ndx_2)
+    {
+        m_encoder.move_column(col_ndx_2, col_ndx_1);
+        append_instruction();
+        return true;
+    }
+
+    bool select_link_list(size_t col_ndx, size_t row_ndx, size_t link_target_group_level_ndx)
+    {
+        sync_linkview();
+        m_encoder.select_link_list(col_ndx, row_ndx, link_target_group_level_ndx);
+        m_pending_lv_instr = get_inst();
+        return true;
+    }
+
+    bool link_list_set(size_t row, size_t value)
+    {
+        m_encoder.link_list_set(row, value);
+        append_instruction();
+        return true;
+    }
+
+    bool link_list_insert(size_t link_ndx, size_t)
+    {
+        m_encoder.link_list_erase(link_ndx);
+        append_instruction();
+        return true;
+    }
+
+    bool link_list_move(size_t from_link_ndx, size_t to_link_ndx)
+    {
+        m_encoder.link_list_move(from_link_ndx, to_link_ndx);
+        append_instruction();
+        return true;
+    }
+
+    bool link_list_swap(size_t link1_ndx, size_t link2_ndx)
+    {
+        m_encoder.link_list_swap(link1_ndx, link2_ndx);
+        append_instruction();
+        return true;
+    }
+
+    bool link_list_erase(size_t link_ndx)
+    {
+        m_encoder.link_list_insert(link_ndx, 0);
+        append_instruction();
+        return true;
+    }
+
+    bool link_list_clear(size_t old_list_size)
+    {
+        // Append in reverse order because the reversed log is itself applied
+        // in reverse, and this way it generates all back-insertions rather than
+        // all front-insertions
+        for (size_t i = old_list_size; i > 0; --i) {
+            m_encoder.link_list_insert(i - 1, 0);
+            append_instruction();
+        }
+        return true;
+    }
+
+    bool nullify_link(size_t col_ndx, size_t row_ndx, size_t target_group_level_ndx)
+    {
+        size_t value = 0;
+        // FIXME: Is zero this right value to pass here, or should
+        // TransactReverser::nullify_link() also have taken a
+        // `target_group_level_ndx` argument.
+        m_encoder.set_link(col_ndx, row_ndx, value, target_group_level_ndx);
+        append_instruction();
+        return true;
+    }
+
+    bool link_list_nullify(size_t link_ndx)
+    {
+        m_encoder.link_list_insert(link_ndx, 0);
+        append_instruction();
+        return true;
+    }
+
+private:
+    _impl::TransactLogBufferStream m_buffer;
+    _impl::TransactLogEncoder m_encoder{m_buffer};
+    struct Instr { size_t begin; size_t end; };
+    std::vector<Instr> m_instructions;
+    size_t current_instr_start = 0;
+    Instr m_pending_ts_instr{0, 0};
+    Instr m_pending_ds_instr{0, 0};
+    Instr m_pending_lv_instr{0, 0};
+
+    Instr get_inst()
+    {
+        Instr instr;
+        instr.begin = current_instr_start;
+        current_instr_start = transact_log_size();
+        instr.end = current_instr_start;
+        return instr;
+    }
+
+    size_t transact_log_size() const
+    {
+        REALM_ASSERT_3(m_encoder.write_position(), >=, m_buffer.transact_log_data());
+        return m_encoder.write_position() - m_buffer.transact_log_data();
+    }
+
+    void append_instruction()
+    {
+        m_instructions.push_back(get_inst());
+    }
+
+    void append_instruction(Instr instr)
+    {
+        m_instructions.push_back(instr);
+    }
+
+    void sync_select(Instr& pending_instr)
+    {
+        if (pending_instr.begin != pending_instr.end) {
+            append_instruction(pending_instr);
+            pending_instr = {0, 0};
+        }
+    }
+
+    void sync_linkview()
+    {
+        sync_select(m_pending_lv_instr);
+    }
+
+    void sync_descriptor()
+    {
+        sync_linkview();
+        sync_select(m_pending_ds_instr);
+    }
+
+    void sync_table()
+    {
+        sync_descriptor();
+        sync_select(m_pending_ts_instr);
+    }
+
+    friend class ReversedNoCopyInputStream;
+};
+
+
+class ReversedNoCopyInputStream: public NoCopyInputStream {
+public:
+    ReversedNoCopyInputStream(TransactReverser& reverser):
+        m_instr_order(reverser.m_instructions)
+    {
+        // push any pending select_table or select_descriptor into the buffer
+        reverser.sync_table();
+
+        m_buffer = reverser.m_buffer.transact_log_data();
+        m_current = m_instr_order.size();
+    }
+
+    size_t next_block(const char*& begin, const char*& end) override
+    {
+        if (m_current != 0) {
+            m_current--;
+            begin = m_buffer + m_instr_order[m_current].begin;
+            end   = m_buffer + m_instr_order[m_current].end;
+            return end-begin;
+        }
+        return 0;
+    }
+
+private:
+    const char* m_buffer;
+    std::vector<TransactReverser::Instr>& m_instr_order;
+    size_t m_current;
+};
+
+} // namespace _impl
+} // namespace realm
+
+#endif // REALM_IMPL_TRANSACT_LOG_HPP
diff --git a/Pods/Realm/include/core/realm/importer.hpp b/Pods/Realm/include/core/realm/importer.hpp
new file mode 100644
index 0000000..9bf14bb
--- /dev/null
+++ b/Pods/Realm/include/core/realm/importer.hpp
@@ -0,0 +1,110 @@
+#ifndef REALM_IMPORTER_HPP
+#define REALM_IMPORTER_HPP
+
+/*
+Main method: import_csv(). Arguments:
+---------------------------------------------------------------------------------------------------------------------
+empty_as_string_flag:
+    Imports a column that has occurences of empty strings as String type column. Else fields arec onverted to false/0/0.0
+
+type_detection_rows:
+    tells how many rows to read before analyzing data types (to see if numeric rows are really
+    numeric everywhere, and not strings that happen to just mostly contain numeric characters
+
+
+This library supports:
+---------------------------------------------------------------------------------------------------------------------
+    * Auto detection of float vs. double, depending on number of significant digits
+    * Bool types can be case insensitive "true, false, 0, 1, yes, no"
+    * Newline inside data fields, plus auto detection of non-conforming non-quoted newlines (as in some IBM sample files)
+    * Realm types String, Integer, Bool, Float and Double
+    * Auto detection of header and naming of Realm columns accordingly
+    * double-quoted and non-quoted fields, and these can be mixed arbitrarely
+    * double-quotes inside data field
+    * *nix + MacOSv9 + Windows line feed
+    * Scientific notation of floats/doubles (+1.23e-10)
+    * Comma in floats - but ONLY if field is double-quoted
+    * FAST FAST FAST (200 MB/s). Uses state-machine instead of traditional char-by-char loop with state checks inside
+
+
+Problems:
+---------------------------------------------------------------------------------------------------------------------
+    A csv file does not tell its sheme. So we auto-detect it, based on the first N rows. However if a given column
+    contains 'false, false, false, hello' and we detect and create Realm table scheme using the first 3 rows, we fail
+    when we meet 'hello' (this error is handled with a thorough error message)
+
+    Does not support commas in floats unless field is double-quoted
+
+
+Design:
+---------------------------------------------------------------------------------------------------------------------
+
+import_csv(csv file handle, realm table)
+    Calls tokenize(csv file handle):
+        reads payload chunk and returns std::vector<std::vector<std::string>> with the right dimensions filled with rows and columns of
+        the chunk payload
+    Calls parse_float(), parse_bool(), etc, which tests for type and returns converted values
+    Calls table.add_empty_row(), table.set_float(), table.set_bool()
+*/
+
+#include <stddef.h>
+
+// Disk read chunk size. This MUST be large enough to contain at least TWO rows of csv plaintext! It's a good idea
+// to set it as low as ever possible (like 32 K) even though it's counter-intuitive with respect to performance. It
+// will make the operating system read 32 K from disk and return it, and then read-ahead 32-64 K more after fread()
+// has returned. This read-ahead behaviour does NOT occur if we request megabyte-sized chunks (observed on Windows 7 /
+// Ubuntu)
+static const size_t chunk_size = 32*1024;
+
+// Number of rows to csv-parse + insert into realm in each iteration.
+static const size_t record_chunks = 100;
+
+// Width of each column when printing them on screen (non-Quiet mode)
+const size_t print_width = 25;
+
+#include <vector>
+#include <realm.hpp>
+
+namespace realm {
+
+class Importer
+{
+public:
+    Importer();
+    size_t import_csv_auto(FILE* file, Table& table, size_t type_detection_rows = 1000,
+                            size_t import_rows = static_cast<size_t>(-1));
+
+    size_t import_csv_manual(FILE* file, Table& table, std::vector<DataType> scheme, std::vector<std::string> column_names,
+                             size_t skip_first_rows = 0, size_t import_rows = static_cast<size_t>(-1));
+
+    bool Quiet;              // Quiet mode, only print to screen upon errors
+    char Separator;          // csv delimitor/separator
+    bool Empty_as_string;    // Import columns that have occurences of empty strings as String type column
+
+private:
+    size_t import_csv(FILE* file, Table& table, std::vector<DataType> *import_scheme, std::vector<std::string> *column_names,
+                      size_t type_detection_rows, size_t skip_first_rows, size_t import_rows);
+    template<bool can_fail>
+    float parse_float(const char*col, bool* success = nullptr);
+    template<bool can_fail>
+    double parse_double(const char* col, bool* success = nullptr, size_t* significants = nullptr);
+    template<bool can_fail>
+    int64_t parse_integer(const char* col, bool* success = nullptr);
+    template<bool can_fail>
+    bool parse_bool(const char*col, bool* success = nullptr);
+    std::vector<DataType> types (std::vector<std::string> v);
+    size_t tokenize(std::vector<std::vector<std::string>> & payload, size_t records);
+    std::vector<DataType> detect_scheme (std::vector<std::vector<std::string>> payload, size_t begin, size_t end);
+    std::vector<DataType> lowest_common (std::vector<DataType> types1, std::vector<DataType> types2);
+
+    char src[2*chunk_size];    // .csv input buffer
+    size_t m_top;              // points at top of buffer
+    size_t m_curpos;           // points at next byte to parse
+    FILE* m_file;              // handle to .csv file
+    size_t m_fields;           // number of fields in each row
+    size_t m_row;              // current row in .csv file, including field-embedded line breaks. Used for err msg only
+};
+
+} // namespace realm
+
+#endif // REALM_IMPORTER_HPP
diff --git a/Pods/Realm/include/core/realm/index_string.hpp b/Pods/Realm/include/core/realm/index_string.hpp
new file mode 100644
index 0000000..f82ac49
--- /dev/null
+++ b/Pods/Realm/include/core/realm/index_string.hpp
@@ -0,0 +1,541 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_INDEX_STRING_HPP
+#define REALM_INDEX_STRING_HPP
+
+#include <cstring>
+#include <memory>
+#include <array>
+
+#include <realm/array.hpp>
+#include <realm/column_fwd.hpp>
+
+ /*
+The StringIndex class is used for both type_String and all integral types, such as type_Bool, type_OldDateTime and
+type_Int. When used for integral types, the 64-bit integer is simply casted to a string of 8 bytes through a
+pretty simple "wrapper layer" in all public methods.
+
+The StringIndex data structure is like an "inversed" B+ tree where the leafs contain row indexes and the non-leafs
+contain 4-byte chunks of payload. Imagine a table with following strings:
+
+        hello, kitty, kitten, foobar, kitty, foobar
+
+The topmost level of the index tree contains prefixes of the payload strings of length <= 4. The next level contains
+prefixes of the remaining parts of the strings. Unnecessary levels of the tree are optimized away; the prefix "foob"
+is shared only by rows that are identical ("foobar"), so "ar" is not needed to be stored in the tree.
+
+        hell   kitt      foob
+         |      /\        |
+         0     en  y    {3, 5}
+               |    \
+            {1, 4}   2
+
+Each non-leafs consists of two integer arrays of the same length, one containing payload and the other containing
+references to the sublevel nodes.
+
+The leafs can be either a single value or a Column. If the reference in its parent node has its least significant
+bit set, then the remaining upper bits specify the row index at which the string is stored. If the bit is clear,
+it must be interpreted as a reference to a Column that stores the row indexes at which the string is stored.
+
+If a Column is used, then all row indexes are guaranteed to be sorted increasingly, which means you an search in it
+using our binary search functions such as upper_bound() and lower_bound().
+*/
+
+namespace realm {
+
+class Spec;
+class Timestamp;
+
+class StringIndex {
+public:
+    StringIndex(ColumnBase* target_column, Allocator&);
+    StringIndex(ref_type, ArrayParent*, size_t ndx_in_parent, ColumnBase* target_column,
+                bool allow_duplicate_values, Allocator&);
+    ~StringIndex() noexcept {}
+    void set_target(ColumnBase* target_column) noexcept;
+
+    // Accessor concept:
+    Allocator& get_alloc() const noexcept;
+    void destroy() noexcept;
+    void detach();
+    bool is_attached() const noexcept;
+    void set_parent(ArrayParent* parent, size_t ndx_in_parent) noexcept;
+    size_t get_ndx_in_parent() const noexcept;
+    void set_ndx_in_parent(size_t ndx_in_parent) noexcept;
+    void update_from_parent(size_t old_baseline) noexcept;
+    void refresh_accessor_tree(size_t, const Spec&);
+    ref_type get_ref() const noexcept;
+
+    // StringIndex interface:
+
+    static const size_t string_conversion_buffer_size = 12; // 12 is the biggest element size of any non-string/binary Realm type
+    using StringConversionBuffer = std::array<char, string_conversion_buffer_size>;
+
+    bool is_empty() const;
+
+    template<class T>
+    void insert(size_t row_ndx, T value, size_t num_rows, bool is_append);
+    template<class T>
+    void insert(size_t row_ndx, util::Optional<T> value, size_t num_rows, bool is_append);
+
+    template<class T>
+    void set(size_t row_ndx, T new_value);
+    template<class T>
+    void set(size_t row_ndx, util::Optional<T> new_value);
+
+    template<class T>
+    void erase(size_t row_ndx, bool is_last);
+
+    template<class T>
+    size_t find_first(T value) const;
+    template<class T>
+    void find_all(IntegerColumn& result, T value) const;
+    template<class T>
+    FindRes find_all(T value, ref_type& ref) const;
+    template<class T>
+    size_t count(T value) const;
+    template<class T>
+    void update_ref(T value, size_t old_row_ndx, size_t new_row_ndx);
+
+    void clear();
+
+    void distinct(IntegerColumn& result) const;
+    bool has_duplicate_values() const noexcept;
+
+    /// By default, duplicate values are allowed.
+    void set_allow_duplicate_values(bool) noexcept;
+
+#ifdef REALM_DEBUG
+    void verify() const;
+    void verify_entries(const StringColumn& column) const;
+    void do_dump_node_structure(std::ostream&, int) const;
+    void to_dot() const;
+    void to_dot(std::ostream&, StringData title = StringData()) const;
+#endif
+
+    typedef int32_t key_type;
+
+    static const size_t s_index_key_length = 4;
+    static key_type create_key(StringData) noexcept;
+    static key_type create_key(StringData, size_t) noexcept;
+
+private:
+
+    // m_array is a compact representation for storing the children of this StringIndex.
+    // Children can be:
+    // 1) a row number
+    // 2) a reference to a list which stores row numbers (for duplicate strings).
+    // 3) a reference to a sub-index
+    // m_array[0] is always a reference to a values array which stores the 4 byte chunk
+    // of payload data for quick string chunk comparisons. The array stored
+    // at m_array[0] lines up with the indices of values in m_array[1] so for example
+    // starting with an empty StringIndex:
+    // StringColumn::insert(target_row_ndx=42, value="test_string") would result with
+    // get_array_from_ref(m_array[0])[0] == create_key("test") and
+    // m_array[1] == 42
+    // In this way, m_array which stores one child has a size of two.
+    // Children are type 1 (row number) if the LSB of the value is set.
+    // To get the actual row value, shift value down by one.
+    // If the LSB of the value is 0 then the value is a reference and can be either
+    // type 2, or type 3 (no shifting in either case).
+    // References point to a list if the context header flag is NOT set.
+    // If the header flag is set, references point to a sub-StringIndex (nesting).
+    std::unique_ptr<Array> m_array;
+    ColumnBase* m_target_column;
+    bool m_deny_duplicate_values;
+
+    struct inner_node_tag {};
+    StringIndex(inner_node_tag, Allocator&);
+
+    static Array* create_node(Allocator&, bool is_leaf);
+
+    void insert_with_offset(size_t row_ndx, StringData value, size_t offset);
+    void insert_row_list(size_t ref, size_t offset, StringData value);
+    key_type get_last_key() const;
+
+    /// Add small signed \a diff to all elements that are greater than, or equal
+    /// to \a min_row_ndx.
+    void adjust_row_indexes(size_t min_row_ndx, int diff);
+
+    struct NodeChange {
+        size_t ref1;
+        size_t ref2;
+        enum ChangeType { none, insert_before, insert_after, split } type;
+        NodeChange(ChangeType t, size_t r1=0, size_t r2=0) : ref1(r1), ref2(r2), type(t) {}
+        NodeChange() : ref1(0), ref2(0), type(none) {}
+    };
+
+    // B-Tree functions
+    void TreeInsert(size_t row_ndx, key_type, size_t offset, StringData value);
+    NodeChange do_insert(size_t ndx, key_type, size_t offset, StringData value);
+    /// Returns true if there is room or it can join existing entries
+    bool leaf_insert(size_t row_ndx, key_type, size_t offset, StringData value, bool noextend=false);
+    void node_insert_split(size_t ndx, size_t new_ref);
+    void node_insert(size_t ndx, size_t ref);
+    void do_delete(size_t ndx, StringData, size_t offset);
+    void do_update_ref(StringData value, size_t row_ndx, size_t new_row_ndx, size_t offset);
+
+    StringData get(size_t ndx, StringConversionBuffer& buffer) const;
+
+    void node_add_key(ref_type ref);
+
+#ifdef REALM_DEBUG
+    static void dump_node_structure(const Array& node, std::ostream&, int level);
+    void to_dot_2(std::ostream&, StringData title = StringData()) const;
+    static void array_to_dot(std::ostream&, const Array&);
+    static void keys_to_dot(std::ostream&, const Array&, StringData title = StringData());
+#endif
+};
+
+
+
+
+// Implementation:
+
+template<class T> struct GetIndexData;
+
+template<> struct GetIndexData<int64_t> {
+    static StringData get_index_data(const int64_t& value, StringIndex::StringConversionBuffer& buffer)
+    {
+        const char* c = reinterpret_cast<const char*>(&value);
+        std::copy(c, c + sizeof(int64_t), buffer.data());
+        return StringData{buffer.data(), sizeof(int64_t)};
+    }
+};
+
+template<> struct GetIndexData<StringData> {
+    static StringData get_index_data(StringData data, StringIndex::StringConversionBuffer&)
+    {
+        return data;
+    }
+};
+
+template<> struct GetIndexData<null> {
+    static StringData get_index_data(null, StringIndex::StringConversionBuffer&)
+    {
+        return null{};
+    }
+};
+
+template<> struct GetIndexData<Timestamp> {
+    static StringData get_index_data(const Timestamp&, StringIndex::StringConversionBuffer&);
+};
+
+template<class T> struct GetIndexData<util::Optional<T>> {
+    static StringData get_index_data(const util::Optional<T>& value, StringIndex::StringConversionBuffer& buffer)
+    {
+        if (value)
+            return GetIndexData<T>::get_index_data(*value, buffer);
+        return null{};
+    }
+};
+
+template<> struct GetIndexData<float> {
+    static StringData get_index_data(float, StringIndex::StringConversionBuffer&)
+    {
+        REALM_ASSERT_RELEASE(false); // LCOV_EXCL_LINE; Index on float not supported
+    }
+};
+
+template<> struct GetIndexData<double> {
+    static StringData get_index_data(double, StringIndex::StringConversionBuffer&)
+    {
+        REALM_ASSERT_RELEASE(false); // LCOV_EXCL_LINE; Index on float not supported
+    }
+};
+
+template<> struct GetIndexData<const char*>: GetIndexData<StringData> {};
+
+// to_str() is used by the integer index. The existing StringIndex is re-used for this
+// by making IntegerColumn convert its integers to strings by calling to_str().
+
+template<class T>
+inline StringData to_str(T&& value, StringIndex::StringConversionBuffer& buffer)
+{
+    return GetIndexData<typename std::remove_reference<T>::type>::get_index_data(value, buffer);
+}
+
+
+inline StringIndex::StringIndex(ColumnBase* target_column, Allocator& alloc):
+    m_array(create_node(alloc, true)), // Throws
+    m_target_column(target_column),
+    m_deny_duplicate_values(false)
+{
+}
+
+inline StringIndex::StringIndex(ref_type ref, ArrayParent* parent, size_t ndx_in_parent,
+                                ColumnBase* target_column,
+                                bool deny_duplicate_values, Allocator& alloc):
+    m_array(new Array(alloc)),
+    m_target_column(target_column),
+    m_deny_duplicate_values(deny_duplicate_values)
+{
+    REALM_ASSERT_EX(Array::get_context_flag_from_header(alloc.translate(ref)), ref, size_t(alloc.translate(ref)));
+    m_array->init_from_ref(ref);
+    set_parent(parent, ndx_in_parent);
+}
+
+inline StringIndex::StringIndex(inner_node_tag, Allocator& alloc):
+    m_array(create_node(alloc, false)), // Throws
+    m_target_column(nullptr),
+    m_deny_duplicate_values(false)
+{
+}
+
+inline void StringIndex::set_allow_duplicate_values(bool allow) noexcept
+{
+    m_deny_duplicate_values = !allow;
+}
+
+// Byte order of the key is *reversed*, so that for the integer index, the least significant
+// byte comes first, so that it fits little-endian machines. That way we can perform fast
+// range-lookups and iterate in order, etc, as future features. This, however, makes the same
+// features slower for string indexes. Todo, we should reverse the order conditionally, depending
+// on the column type.
+inline StringIndex::key_type StringIndex::create_key(StringData str) noexcept
+{
+    key_type key = 0;
+
+    if (str.size() >= 4) goto four;
+    if (str.size() < 2) {
+        if (str.size() == 0) goto none;
+        goto one;
+    }
+    if (str.size() == 2) goto two;
+    goto three;
+
+    // Create 4 byte index key
+    // (encoded like this to allow literal comparisons
+    // independently of endianness)
+  four:
+    key |= (key_type(static_cast<unsigned char>(str[3])) <<  0);
+  three:
+    key |= (key_type(static_cast<unsigned char>(str[2])) <<  8);
+  two:
+    key |= (key_type(static_cast<unsigned char>(str[1])) << 16);
+  one:
+    key |= (key_type(static_cast<unsigned char>(str[0])) << 24);
+  none:
+    return key;
+}
+
+// Index works as follows: All non-NULL values are stored as if they had appended an 'X' character at the end. So
+// "foo" is stored as if it was "fooX", and "" (empty string) is stored as "X". And NULLs are stored as empty strings.
+inline StringIndex::key_type StringIndex::create_key(StringData str, size_t offset) noexcept
+{
+    if (str.is_null())
+        return 0;
+
+    if (offset > str.size())
+        return 0;
+
+    // for very short strings
+    size_t tail = str.size() - offset;
+    if (tail <= sizeof(key_type)-1) {
+        char buf[sizeof(key_type)];
+        memset(buf, 0, sizeof(key_type));
+        buf[tail] = 'X';
+        memcpy(buf, str.data() + offset, tail);
+        return create_key(StringData(buf, tail + 1));
+    }
+    // else fallback
+    return create_key(str.substr(offset));
+}
+
+template<class T>
+void StringIndex::insert(size_t row_ndx, T value, size_t num_rows, bool is_append)
+{
+    REALM_ASSERT_3(row_ndx, !=, npos);
+
+    // If the new row is inserted after the last row in the table, we don't need
+    // to adjust any row indexes.
+    if (!is_append) {
+        for (size_t i = 0; i < num_rows; ++i) {
+            size_t row_ndx_2 = row_ndx + i;
+            adjust_row_indexes(row_ndx_2, 1); // Throws
+        }
+    }
+
+    StringConversionBuffer buffer;
+
+    for (size_t i = 0; i < num_rows; ++i) {
+        size_t row_ndx_2 = row_ndx + i;
+        size_t offset = 0; // First key from beginning of string
+        insert_with_offset(row_ndx_2, to_str(value, buffer), offset); // Throws
+    }
+}
+
+template<class T>
+void StringIndex::insert(size_t row_ndx, util::Optional<T> value, size_t num_rows, bool is_append)
+{
+    if (value) {
+        insert(row_ndx, *value, num_rows, is_append);
+    }
+    else {
+        insert(row_ndx, null{}, num_rows, is_append);
+    }
+}
+
+template<class T>
+void StringIndex::set(size_t row_ndx, T new_value)
+{
+    StringConversionBuffer buffer;
+    StringConversionBuffer buffer2;
+    StringData old_value = get(row_ndx, buffer);
+    StringData new_value2 = to_str(new_value, buffer2);
+
+    // Note that insert_with_offset() throws UniqueConstraintViolation.
+
+    if (REALM_LIKELY(new_value2 != old_value)) {
+        size_t offset = 0; // First key from beginning of string
+        insert_with_offset(row_ndx, new_value2, offset); // Throws
+
+        bool is_last = true; // To avoid updating refs
+        erase<T>(row_ndx, is_last); // Throws
+    }
+}
+
+template<class T>
+void StringIndex::set(size_t row_ndx, util::Optional<T> new_value)
+{
+    if (new_value) {
+        set(row_ndx, *new_value);
+    }
+    else {
+        set(row_ndx, null{});
+    }
+}
+
+template<class T>
+void StringIndex::erase(size_t row_ndx, bool is_last)
+{
+    StringConversionBuffer buffer;
+    StringData value = get(row_ndx, buffer);
+
+    do_delete(row_ndx, value, 0);
+
+    // Collapse top nodes with single item
+    while (m_array->is_inner_bptree_node()) {
+        REALM_ASSERT(m_array->size() > 1); // node cannot be empty
+        if (m_array->size() > 2)
+            break;
+
+        ref_type ref = m_array->get_as_ref(1);
+        m_array->set(1, 1); // avoid destruction of the extracted ref
+        m_array->destroy_deep();
+        m_array->init_from_ref(ref);
+        m_array->update_parent();
+    }
+
+    // If it is last item in column, we don't have to update refs
+    if (!is_last)
+        adjust_row_indexes(row_ndx, -1);
+}
+
+template<class T>
+size_t StringIndex::find_first(T value) const
+{
+    // Use direct access method
+    StringConversionBuffer buffer;
+    return m_array->index_string_find_first(to_str(value, buffer), m_target_column);
+}
+
+template<class T>
+void StringIndex::find_all(IntegerColumn& result, T value) const
+{
+    // Use direct access method
+    StringConversionBuffer buffer;
+    return m_array->index_string_find_all(result, to_str(value, buffer), m_target_column);
+}
+
+template<class T>
+FindRes StringIndex::find_all(T value, ref_type& ref) const
+{
+    // Use direct access method
+    StringConversionBuffer buffer;
+    return m_array->index_string_find_all_no_copy(to_str(value, buffer), ref, m_target_column);
+}
+
+template<class T>
+size_t StringIndex::count(T value) const
+{
+    // Use direct access method
+    StringConversionBuffer buffer;
+    return m_array->index_string_count(to_str(value, buffer), m_target_column);
+}
+
+template<class T>
+void StringIndex::update_ref(T value, size_t old_row_ndx, size_t new_row_ndx)
+{
+    StringConversionBuffer buffer;
+    do_update_ref(to_str(value, buffer), old_row_ndx, new_row_ndx, 0);
+}
+
+inline
+void StringIndex::destroy() noexcept
+{
+    return m_array->destroy_deep();
+}
+
+inline
+bool StringIndex::is_attached() const noexcept
+{
+    return m_array->is_attached();
+}
+
+inline
+void StringIndex::refresh_accessor_tree(size_t, const Spec&)
+{
+    m_array->init_from_parent();
+}
+
+inline
+ref_type StringIndex::get_ref() const noexcept
+{
+    return m_array->get_ref();
+}
+
+inline
+void StringIndex::set_parent(ArrayParent* parent, size_t ndx_in_parent) noexcept
+{
+    m_array->set_parent(parent, ndx_in_parent);
+}
+
+inline
+size_t StringIndex::get_ndx_in_parent() const noexcept
+{
+    return m_array->get_ndx_in_parent();
+}
+
+inline
+void StringIndex::set_ndx_in_parent(size_t ndx_in_parent) noexcept
+{
+    m_array->set_ndx_in_parent(ndx_in_parent);
+}
+
+inline
+void StringIndex::update_from_parent(size_t old_baseline) noexcept
+{
+    m_array->update_from_parent(old_baseline);
+}
+
+} //namespace realm
+
+#endif // REALM_INDEX_STRING_HPP
diff --git a/Pods/Realm/include/core/realm/lang_bind_helper.hpp b/Pods/Realm/include/core/realm/lang_bind_helper.hpp
new file mode 100644
index 0000000..19a22c5
--- /dev/null
+++ b/Pods/Realm/include/core/realm/lang_bind_helper.hpp
@@ -0,0 +1,394 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_LANG_BIND_HELPER_HPP
+#define REALM_LANG_BIND_HELPER_HPP
+
+#include <cstddef>
+
+#include <realm/table.hpp>
+#include <realm/table_view.hpp>
+#include <realm/link_view.hpp>
+#include <realm/group.hpp>
+#include <realm/group_shared.hpp>
+
+#include <realm/replication.hpp>
+
+namespace realm {
+
+
+/// These functions are only to be used by language bindings to gain
+/// access to certain memebers that are othewise private.
+///
+/// \note Applications are not supposed to call any of these functions
+/// directly.
+///
+/// All of the get_subtable_ptr() functions bind the table accessor pointer
+/// before it is returned (bind_table_ptr()). The caller is then responsible for
+/// making the corresponding call to unbind_table_ptr().
+class LangBindHelper {
+public:
+    /// Increment the reference counter of the specified table accessor. This is
+    /// done automatically by all of the functions in this class that return
+    /// table accessor pointers, but if the binding/application makes a copy of
+    /// such a pointer, and the copy needs to have an "independent life", then
+    /// the binding/application must bind that copy using this function.
+    static void bind_table_ptr(const Table*) noexcept;
+
+    /// Decrement the reference counter of the specified table accessor. The
+    /// binding/application must call this function for every bound table
+    /// accessor pointer object, when that pointer object ends its life.
+    static void unbind_table_ptr(const Table*) noexcept;
+
+    /// Construct a new freestanding table. The table accessor pointer is bound
+    /// by the callee before it is returned (bind_table_ptr()).
+    static Table* new_table();
+
+    /// Construct a new freestanding table as a copy of the specified one. The
+    /// table accessor pointer is bound by the callee before it is returned
+    /// (bind_table_ptr()).
+    static Table* copy_table(const Table&);
+
+    //@{
+
+    /// These functions are like their namesakes in Group, but these bypass the
+    /// construction of a smart-pointer object (TableRef). The table accessor
+    /// pointer is bound by the callee before it is returned (bind_table_ptr()).
+
+    static Table* get_table(Group&, size_t index_in_group);
+    static const Table* get_table(const Group&, size_t index_in_group);
+
+    static Table* get_table(Group&, StringData name);
+    static const Table* get_table(const Group&, StringData name);
+
+    static Table* add_table(Group&, StringData name, bool require_unique_name = true);
+    static Table* get_or_add_table(Group&, StringData name, bool* was_added = nullptr);
+
+    //@}
+
+    static Table* get_subtable_ptr(Table*, size_t column_ndx, size_t row_ndx);
+    static const Table* get_subtable_ptr(const Table*, size_t column_ndx,
+                                         size_t row_ndx);
+
+    // FIXME: This is an 'oddball', do we really need it? If we do,
+    // please provide a comment that explains why it is needed!
+    static Table* get_subtable_ptr_during_insert(Table*, size_t col_ndx,
+                                                 size_t row_ndx);
+
+    static Table* get_subtable_ptr(TableView*, size_t column_ndx, size_t row_ndx);
+    static const Table* get_subtable_ptr(const TableView*, size_t column_ndx,
+                                         size_t row_ndx);
+    static const Table* get_subtable_ptr(const ConstTableView*, size_t column_ndx,
+                                         size_t row_ndx);
+
+    /// Calls parent.set_mixed_subtable(col_ndx, row_ndx, &source). Note
+    /// that the source table must have a descriptor that is
+    /// compatible with the target subtable column.
+    static void set_mixed_subtable(Table& parent, size_t col_ndx, size_t row_ndx,
+                                   const Table& source);
+
+    static const LinkViewRef& get_linklist_ptr(Row&, size_t col_ndx);
+    static void unbind_linklist_ptr(const LinkViewRef&);
+
+    using VersionID = SharedGroup::VersionID;
+
+    //@{
+
+    /// Continuous transactions.
+    ///
+    /// advance_read() is equivalent to terminating the current read transaction
+    /// (SharedGroup::end_read()), and initiating a new one
+    /// (SharedGroup::begin_read()), except that all subordinate accessors
+    /// (Table, Row, Descriptor) will remain attached to the underlying objects,
+    /// unless those objects were removed in the target snapshot. By default,
+    /// the read transaction is advanced to the latest available snapshot, but
+    /// see SharedGroup::begin_read() for information about \a version.
+    ///
+    /// promote_to_write() is equivalent to terminating the current read
+    /// transaction (SharedGroup::end_read()), and initiating a new write
+    /// transaction (SharedGroup::begin_write()), except that all subordinate
+    /// accessors (Table, Row, Descriptor) will remain attached to the
+    /// underlying objects, unless those objects were removed in the target
+    /// snapshot.
+    ///
+    /// commit_and_continue_as_read() is equivalent to committing the current
+    /// write transaction (SharedGroup::commit()) and initiating a new read
+    /// transaction, which is bound to the snapshot produced by the write
+    /// transaction (SharedGroup::begin_read()), except that all subordinate
+    /// accessors (Table, Row, Descriptor) will remain attached to the
+    /// underlying objects. commit_and_continue_as_read() returns the version
+    /// produced by the committed transaction.
+    ///
+    /// rollback_and_continue_as_read() is equivalent to rolling back the
+    /// current write transaction (SharedGroup::rollback()) and initiating a new
+    /// read transaction, which is bound to the snapshot, that the write
+    /// transaction was based on (SharedGroup::begin_read()), except that all
+    /// subordinate accessors (Table, Row, Descriptor) will remain attached to
+    /// the underlying objects, unless they were attached to object that were
+    /// added during the rolled back transaction.
+    ///
+    /// If advance_read(), promote_to_write(), commit_and_continue_as_read(), or
+    /// rollback_and_continue_as_read() throws, the associated group accessor
+    /// and all of its subordinate accessors are left in a state that may not be
+    /// fully consistent. Only minimal consistency is guaranteed (see
+    /// AccessorConsistencyLevels). In this case, the application is required to
+    /// either destroy the SharedGroup object, forcing all associated accessors
+    /// to become detached, or take some other equivalent action that involves a
+    /// complete accessor detachment, such as terminating the transaction in
+    /// progress. Until then it is an error, and unsafe if the application
+    /// attempts to access any of those accessors.
+    ///
+    /// The application must use SharedGroup::end_read() if it wants to
+    /// terminate the transaction after advance_read() or promote_to_write() has
+    /// thrown an exception. Likewise, it must use SharedGroup::rollback() if it
+    /// wants to terminate the transaction after commit_and_continue_as_read()
+    /// or rollback_and_continue_as_read() has thrown an exception.
+    ///
+    /// \param history The modification history accessor associated with the
+    /// specified SharedGroup object.
+    ///
+    /// \param observer An optional custom replication instruction handler. The
+    /// application may pass such a handler to observe the sequence of
+    /// modifications that advances (or rolls back) the state of the Realm.
+    ///
+    /// \throw SharedGroup::BadVersion Thrown by advance_read() if the specified
+    /// version does not correspond to a bound (or tethered) snapshot.
+
+    static void advance_read(SharedGroup&, VersionID = VersionID());
+    template<class O> static void advance_read(SharedGroup&, O&& observer, VersionID = VersionID());
+    static void promote_to_write(SharedGroup&);
+    template<class O> static void promote_to_write(SharedGroup&, O&& observer);
+    static SharedGroup::version_type commit_and_continue_as_read(SharedGroup&);
+    static void rollback_and_continue_as_read(SharedGroup&);
+    template<class O> static void rollback_and_continue_as_read(SharedGroup&, O&& observer);
+
+    //@}
+
+    /// Returns the name of the specified data type. Examples:
+    ///
+    /// <pre>
+    ///
+    ///   type_Int          ->  "int"
+    ///   type_Bool         ->  "bool"
+    ///   type_Float        ->  "float"
+    ///   ...
+    ///
+    /// </pre>
+    static const char* get_data_type_name(DataType) noexcept;
+
+    static SharedGroup::version_type get_version_of_latest_snapshot(SharedGroup&);
+};
+
+
+
+
+// Implementation:
+
+inline Table* LangBindHelper::new_table()
+{
+    typedef _impl::TableFriend tf;
+    Allocator& alloc = Allocator::get_default();
+    size_t ref = tf::create_empty_table(alloc); // Throws
+    Table::Parent* parent = nullptr;
+    size_t ndx_in_parent = 0;
+    Table* table = tf::create_accessor(alloc, ref, parent, ndx_in_parent); // Throws
+    bind_table_ptr(table);
+    return table;
+}
+
+inline Table* LangBindHelper::copy_table(const Table& table)
+{
+    typedef _impl::TableFriend tf;
+    Allocator& alloc = Allocator::get_default();
+    size_t ref = tf::clone(table, alloc); // Throws
+    Table::Parent* parent = nullptr;
+    size_t ndx_in_parent = 0;
+    Table* copy_of_table = tf::create_accessor(alloc, ref, parent, ndx_in_parent); // Throws
+    bind_table_ptr(copy_of_table);
+    return copy_of_table;
+}
+
+inline Table* LangBindHelper::get_subtable_ptr(Table* t, size_t column_ndx,
+                                               size_t row_ndx)
+{
+    Table* subtab = t->get_subtable_ptr(column_ndx, row_ndx); // Throws
+    subtab->bind_ptr();
+    return subtab;
+}
+
+inline const Table* LangBindHelper::get_subtable_ptr(const Table* t, size_t column_ndx,
+                                                     size_t row_ndx)
+{
+    const Table* subtab = t->get_subtable_ptr(column_ndx, row_ndx); // Throws
+    subtab->bind_ptr();
+    return subtab;
+}
+
+inline Table* LangBindHelper::get_subtable_ptr(TableView* tv, size_t column_ndx,
+                                               size_t row_ndx)
+{
+    return get_subtable_ptr(&tv->get_parent(), column_ndx, tv->get_source_ndx(row_ndx));
+}
+
+inline const Table* LangBindHelper::get_subtable_ptr(const TableView* tv, size_t column_ndx,
+                                                     size_t row_ndx)
+{
+    return get_subtable_ptr(&tv->get_parent(), column_ndx, tv->get_source_ndx(row_ndx));
+}
+
+inline const Table* LangBindHelper::get_subtable_ptr(const ConstTableView* tv,
+                                                     size_t column_ndx, size_t row_ndx)
+{
+    return get_subtable_ptr(&tv->get_parent(), column_ndx, tv->get_source_ndx(row_ndx));
+}
+
+inline Table* LangBindHelper::get_table(Group& group, size_t index_in_group)
+{
+    typedef _impl::GroupFriend gf;
+    Table* table = &gf::get_table(group, index_in_group); // Throws
+    table->bind_ptr();
+    return table;
+}
+
+inline const Table* LangBindHelper::get_table(const Group& group, size_t index_in_group)
+{
+    typedef _impl::GroupFriend gf;
+    const Table* table = &gf::get_table(group, index_in_group); // Throws
+    table->bind_ptr();
+    return table;
+}
+
+inline Table* LangBindHelper::get_table(Group& group, StringData name)
+{
+    typedef _impl::GroupFriend gf;
+    Table* table = gf::get_table(group, name); // Throws
+    if (table)
+        table->bind_ptr();
+    return table;
+}
+
+inline const Table* LangBindHelper::get_table(const Group& group, StringData name)
+{
+    typedef _impl::GroupFriend gf;
+    const Table* table = gf::get_table(group, name); // Throws
+    if (table)
+        table->bind_ptr();
+    return table;
+}
+
+inline Table* LangBindHelper::add_table(Group& group, StringData name, bool require_unique_name)
+{
+    typedef _impl::GroupFriend gf;
+    Table* table = &gf::add_table(group, name, require_unique_name); // Throws
+    table->bind_ptr();
+    return table;
+}
+
+inline Table* LangBindHelper::get_or_add_table(Group& group, StringData name, bool* was_added)
+{
+    typedef _impl::GroupFriend gf;
+    Table* table = &gf::get_or_add_table(group, name, was_added); // Throws
+    table->bind_ptr();
+    return table;
+}
+
+inline void LangBindHelper::unbind_table_ptr(const Table* t) noexcept
+{
+   t->unbind_ptr();
+}
+
+inline void LangBindHelper::bind_table_ptr(const Table* t) noexcept
+{
+   t->bind_ptr();
+}
+
+inline void LangBindHelper::set_mixed_subtable(Table& parent, size_t col_ndx,
+                                               size_t row_ndx, const Table& source)
+{
+    parent.set_mixed_subtable(col_ndx, row_ndx, &source);
+}
+
+inline const LinkViewRef& LangBindHelper::get_linklist_ptr(Row& row, size_t col_ndx)
+{
+    LinkViewRef* link_view = new LinkViewRef(row.get_linklist(col_ndx));
+    return *link_view;
+}
+
+inline void LangBindHelper::unbind_linklist_ptr(const LinkViewRef& link_view)
+{
+    delete (&link_view);
+}
+
+inline void LangBindHelper::advance_read(SharedGroup& sg, VersionID version)
+{
+    using sgf = _impl::SharedGroupFriend;
+    _impl::NullInstructionObserver* observer = nullptr;
+    sgf::advance_read(sg, observer, version); // Throws
+}
+
+template<class O>
+inline void LangBindHelper::advance_read(SharedGroup& sg, O&& observer, VersionID version)
+{
+    using sgf = _impl::SharedGroupFriend;
+    sgf::advance_read(sg, &observer, version); // Throws
+}
+
+inline void LangBindHelper::promote_to_write(SharedGroup& sg)
+{
+    using sgf = _impl::SharedGroupFriend;
+    _impl::NullInstructionObserver* observer = nullptr;
+    sgf::promote_to_write(sg, observer); // Throws
+}
+
+template<class O>
+inline void LangBindHelper::promote_to_write(SharedGroup& sg, O&& observer)
+{
+    using sgf = _impl::SharedGroupFriend;
+    sgf::promote_to_write(sg, &observer); // Throws
+}
+
+inline SharedGroup::version_type LangBindHelper::commit_and_continue_as_read(SharedGroup& sg)
+{
+    using sgf = _impl::SharedGroupFriend;
+    return sgf::commit_and_continue_as_read(sg); // Throws
+}
+
+inline void LangBindHelper::rollback_and_continue_as_read(SharedGroup& sg)
+{
+    using sgf = _impl::SharedGroupFriend;
+    _impl::NullInstructionObserver* observer = nullptr;
+    sgf::rollback_and_continue_as_read(sg, observer); // Throws
+}
+
+template<class O>
+inline void LangBindHelper::rollback_and_continue_as_read(SharedGroup& sg, O&& observer)
+{
+    using sgf = _impl::SharedGroupFriend;
+    sgf::rollback_and_continue_as_read(sg, &observer); // Throws
+}
+
+inline SharedGroup::version_type LangBindHelper::get_version_of_latest_snapshot(SharedGroup& sg)
+{
+    using sgf = _impl::SharedGroupFriend;
+    return sgf::get_version_of_latest_snapshot(sg); // Throws
+}
+
+} // namespace realm
+
+#endif // REALM_LANG_BIND_HELPER_HPP
diff --git a/Pods/Realm/include/core/realm/link_view.hpp b/Pods/Realm/include/core/realm/link_view.hpp
new file mode 100644
index 0000000..1d9359a
--- /dev/null
+++ b/Pods/Realm/include/core/realm/link_view.hpp
@@ -0,0 +1,378 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_LINK_VIEW_HPP
+#define REALM_LINK_VIEW_HPP
+
+#include <realm/column.hpp>
+#include <realm/column_linklist.hpp>
+#include <realm/link_view_fwd.hpp>
+#include <realm/table.hpp>
+
+namespace realm {
+
+class LinkListColumn;
+
+namespace _impl {
+class LinkListFriend;
+class TransactLogConvenientEncoder;
+}
+
+
+/// The effect of calling most of the link list functions on a detached accessor
+/// is unspecified and may lead to general corruption, or even a crash. The
+/// exceptions are is_attached() and the destructor.
+///
+/// FIXME: Rename this class to `LinkList`.
+class LinkView : public RowIndexes, public std::enable_shared_from_this<LinkView> {
+public:
+    ~LinkView() noexcept;
+    bool is_attached() const noexcept;
+
+    /// This method will return true if the LinkView is detached (no assert).
+    bool is_empty() const noexcept;
+
+    /// This method will return 0 if the LinkView is detached (no assert).
+    size_t size() const noexcept override;
+
+    bool operator==(const LinkView&) const noexcept;
+    bool operator!=(const LinkView&) const noexcept;
+
+    // Getting links
+    Table::ConstRowExpr operator[](size_t link_ndx) const noexcept;
+    Table::RowExpr operator[](size_t link_ndx) noexcept;
+    Table::ConstRowExpr get(size_t link_ndx) const noexcept;
+    Table::RowExpr get(size_t link_ndx) noexcept;
+
+    // Modifiers
+    void add(size_t target_row_ndx);
+    void insert(size_t link_ndx, size_t target_row_ndx);
+    void set(size_t link_ndx, size_t target_row_ndx);
+    /// Move the link at \a from_ndx such that it ends up at \a to_ndx. Other
+    /// links are shifted as necessary in such a way that their order is
+    /// preserved.
+    ///
+    /// Note that \a to_ndx is the desired final index of the moved link,
+    /// therefore, `move(1,1)` is a no-op, while `move(1,2)` moves the link at
+    /// index 1 by one position, such that it ends up at index 2. A side-effect
+    /// of that, is that the link, that was originally at index 2, is moved to
+    /// index 1.
+    void move(size_t from_ndx, size_t to_ndx);
+    void swap(size_t link1_ndx, size_t link2_ndx);
+    void remove(size_t link_ndx);
+    void clear();
+
+    void sort(size_t column, bool ascending = true);
+    void sort(std::vector<size_t> columns, std::vector<bool> ascending);
+
+    TableView get_sorted_view(std::vector<size_t> column_indexes, std::vector<bool> ascending) const;
+    TableView get_sorted_view(size_t column_index, bool ascending = true) const;
+
+    /// Remove the target row of the specified link from the target table. This
+    /// also removes the specified link from this link list, and any other link
+    /// pointing to that row. This is merely a shorthand for
+    /// `get_target_table.move_last_over(get(link_ndx))`.
+    void remove_target_row(size_t link_ndx);
+
+    /// Remove all target rows pointed to by links in this link list, and clear
+    /// this link list.
+    void remove_all_target_rows();
+
+    /// Search this list for a link to the specified target table row (specified
+    /// by its index in the target table). If found, the index of the link to
+    /// that row within this list is returned, otherwise `realm::not_found` is
+    /// returned.
+    size_t find(size_t target_row_ndx, size_t start=0) const noexcept;
+
+    const ColumnBase& get_column_base(size_t index) const override; // FIXME: `ColumnBase` is not part of the public API, so this function must be made private.
+    const Table& get_origin_table() const noexcept;
+    Table& get_origin_table() noexcept;
+
+    size_t get_origin_row_index() const noexcept;
+
+    const Table& get_target_table() const noexcept;
+    Table& get_target_table() noexcept;
+
+    // No-op because LinkViews are always kept in sync.
+    uint_fast64_t sync_if_needed() const override;
+    bool is_in_sync() const override { return true; }
+
+private:
+    struct ctor_cookie {};
+
+    TableRef m_origin_table;
+    LinkListColumn& m_origin_column;
+    mutable size_t m_ref_count;
+
+    using HandoverPatch = LinkViewHandoverPatch;
+    static void generate_patch(const ConstLinkViewRef& ref, std::unique_ptr<HandoverPatch>& patch);
+    static LinkViewRef create_from_and_consume_patch(std::unique_ptr<HandoverPatch>& patch, Group& group);
+
+    void detach();
+    void set_origin_row_index(size_t row_ndx) noexcept;
+
+    size_t do_set(size_t link_ndx, size_t target_row_ndx);
+    size_t do_remove(size_t link_ndx);
+    void do_clear(bool broken_reciprocal_backlinks);
+
+    void do_nullify_link(size_t old_target_row_ndx);
+    void do_update_link(size_t old_target_row_ndx, size_t new_target_row_ndx);
+    void do_swap_link(size_t target_row_ndx_1, size_t target_row_ndx_2);
+
+    void refresh_accessor_tree(size_t new_row_ndx) noexcept;
+
+    void update_from_parent(size_t old_baseline) noexcept;
+
+    Replication* get_repl() noexcept;
+    void repl_unselect() noexcept;
+    friend class _impl::TransactLogConvenientEncoder;
+
+#ifdef REALM_DEBUG
+    void verify(size_t row_ndx) const;
+#endif
+    // allocate using make_shared:
+    static std::shared_ptr<LinkView> create(Table* origin_table, LinkListColumn&, size_t row_ndx);
+
+    friend class _impl::LinkListFriend;
+    friend class LinkListColumn;
+    friend class LangBindHelper;
+    friend class SharedGroup;
+    friend class Query;
+    friend class TableViewBase;
+
+    // must be public for use by make_shared, but cannot be called from outside,
+    // because ctor_cookie is private
+public:
+    LinkView(const ctor_cookie&, Table* origin_table, LinkListColumn&, size_t row_ndx);
+};
+
+
+// Implementation
+
+inline LinkView::LinkView(const ctor_cookie&, Table* origin_table, LinkListColumn& column, size_t row_ndx):
+    RowIndexes(IntegerColumn::unattached_root_tag(), column.get_alloc()), // Throws
+    m_origin_table(origin_table->get_table_ref()),
+    m_origin_column(column),
+    m_ref_count(0)
+{
+    Array& root = *m_row_indexes.get_root_array();
+    root.set_parent(&column, row_ndx);
+    if (ref_type ref = root.get_ref_from_parent())
+        root.init_from_ref(ref);
+}
+
+inline std::shared_ptr<LinkView> 
+LinkView::create(Table* origin_table, LinkListColumn& column, size_t row_ndx)
+{
+    return std::make_shared<LinkView>(ctor_cookie(), origin_table, column, row_ndx);
+}
+
+inline LinkView::~LinkView() noexcept
+{
+    if (is_attached()) {
+        repl_unselect();
+        m_origin_column.unregister_linkview();
+    }
+}
+
+inline void LinkView::detach()
+{
+    REALM_ASSERT(is_attached());
+    repl_unselect();
+    m_origin_table.reset();
+    m_row_indexes.detach();
+}
+
+inline bool LinkView::is_attached() const noexcept
+{
+    return static_cast<bool>(m_origin_table);
+}
+
+inline bool LinkView::is_empty() const noexcept
+{
+    if (!is_attached())
+        return true;
+
+    if (!m_row_indexes.is_attached())
+        return true;
+
+    return m_row_indexes.is_empty();
+}
+
+inline size_t LinkView::size() const noexcept
+{
+    if (!is_attached())
+        return 0;
+
+    if (!m_row_indexes.is_attached())
+        return 0;
+
+    return m_row_indexes.size();
+}
+
+inline bool LinkView::operator==(const LinkView& link_list) const noexcept
+{
+    Table& target_table_1 = m_origin_column.get_target_table();
+    Table& target_table_2 = link_list.m_origin_column.get_target_table();
+    if (target_table_1.get_index_in_group() != target_table_2.get_index_in_group())
+        return false;
+    if (!m_row_indexes.is_attached() || m_row_indexes.is_empty()) {
+        return !link_list.m_row_indexes.is_attached() ||
+            link_list.m_row_indexes.is_empty();
+    }
+    return link_list.m_row_indexes.is_attached() &&
+        m_row_indexes.compare(link_list.m_row_indexes);
+}
+
+inline bool LinkView::operator!=(const LinkView& link_list) const noexcept
+{
+    return !(*this == link_list);
+}
+
+inline Table::ConstRowExpr LinkView::get(size_t link_ndx) const noexcept
+{
+    return const_cast<LinkView*>(this)->get(link_ndx);
+}
+
+inline Table::RowExpr LinkView::get(size_t link_ndx) noexcept
+{
+    REALM_ASSERT(is_attached());
+    REALM_ASSERT(m_row_indexes.is_attached());
+    REALM_ASSERT_3(link_ndx, <, m_row_indexes.size());
+
+    Table& target_table = m_origin_column.get_target_table();
+    size_t target_row_ndx = to_size_t(m_row_indexes.get(link_ndx));
+    return target_table[target_row_ndx];
+}
+
+inline Table::ConstRowExpr LinkView::operator[](size_t link_ndx) const noexcept
+{
+    return get(link_ndx);
+}
+
+inline Table::RowExpr LinkView::operator[](size_t link_ndx) noexcept
+{
+    return get(link_ndx);
+}
+
+inline void LinkView::add(size_t target_row_ndx)
+{
+    REALM_ASSERT(is_attached());
+    size_t ins_pos = (m_row_indexes.is_attached()) ? m_row_indexes.size() : 0;
+    insert(ins_pos, target_row_ndx);
+}
+
+inline size_t LinkView::find(size_t target_row_ndx, size_t start) const noexcept
+{
+    REALM_ASSERT(is_attached());
+    REALM_ASSERT_3(target_row_ndx, <, m_origin_column.get_target_table().size());
+    REALM_ASSERT_3(start, <=, size());
+
+    if (!m_row_indexes.is_attached())
+        return not_found;
+
+    return m_row_indexes.find_first(target_row_ndx, start);
+}
+
+inline const ColumnBase& LinkView::get_column_base(size_t index) const
+{
+    return get_target_table().get_column_base(index);
+}
+
+inline const Table& LinkView::get_origin_table() const noexcept
+{
+    return *m_origin_table;
+}
+
+inline Table& LinkView::get_origin_table() noexcept
+{
+    return *m_origin_table;
+}
+
+inline size_t LinkView::get_origin_row_index() const noexcept
+{
+    REALM_ASSERT(is_attached());
+    return m_row_indexes.get_root_array()->get_ndx_in_parent();
+}
+
+inline void LinkView::set_origin_row_index(size_t row_ndx) noexcept
+{
+    REALM_ASSERT(is_attached());
+    m_row_indexes.get_root_array()->set_ndx_in_parent(row_ndx);
+}
+
+inline const Table& LinkView::get_target_table() const noexcept
+{
+    return m_origin_column.get_target_table();
+}
+
+inline Table& LinkView::get_target_table() noexcept
+{
+    return m_origin_column.get_target_table();
+}
+
+inline void LinkView::refresh_accessor_tree(size_t new_row_ndx) noexcept
+{
+    Array& root = *m_row_indexes.get_root_array();
+    root.set_ndx_in_parent(new_row_ndx);
+    if (ref_type ref = root.get_ref_from_parent()) {
+        root.init_from_ref(ref);
+    }
+    else {
+        root.detach();
+    }
+}
+
+inline void LinkView::update_from_parent(size_t old_baseline) noexcept
+{
+    if (m_row_indexes.is_attached())
+        m_row_indexes.update_from_parent(old_baseline);
+}
+
+inline Replication* LinkView::get_repl() noexcept
+{
+    typedef _impl::TableFriend tf;
+    return tf::get_repl(*m_origin_table);
+}
+
+
+// The purpose of this class is to give internal access to some, but not all of
+// the non-public parts of LinkView.
+class _impl::LinkListFriend {
+public:
+    static void do_set(LinkView& list, size_t link_ndx, size_t target_row_ndx)
+    {
+        list.do_set(link_ndx, target_row_ndx);
+    }
+
+    static void do_remove(LinkView& list, size_t link_ndx)
+    {
+        list.do_remove(link_ndx);
+    }
+
+    static void do_clear(LinkView& list)
+    {
+        bool broken_reciprocal_backlinks = false;
+        list.do_clear(broken_reciprocal_backlinks);
+    }
+};
+
+} // namespace realm
+
+#endif // REALM_LINK_VIEW_HPP
diff --git a/Pods/Realm/include/core/realm/link_view_fwd.hpp b/Pods/Realm/include/core/realm/link_view_fwd.hpp
new file mode 100644
index 0000000..b1b40f9
--- /dev/null
+++ b/Pods/Realm/include/core/realm/link_view_fwd.hpp
@@ -0,0 +1,33 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_LINK_VIEW_FWD_HPP
+#define REALM_LINK_VIEW_FWD_HPP
+
+#include <memory>
+
+namespace realm {
+
+class LinkView;
+using LinkViewRef = std::shared_ptr<LinkView>;
+using ConstLinkViewRef = std::shared_ptr<const LinkView>;
+
+} // namespace realm
+
+#endif // REALM_LINK_VIEW_FWD_HPP
diff --git a/Pods/Realm/include/core/realm/mixed.hpp b/Pods/Realm/include/core/realm/mixed.hpp
new file mode 100644
index 0000000..0d6c588
--- /dev/null
+++ b/Pods/Realm/include/core/realm/mixed.hpp
@@ -0,0 +1,624 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_MIXED_HPP
+#define REALM_MIXED_HPP
+
+#include <stdint.h> // int64_t - not part of C++03, not even required by C++11 (see C++11 section 18.4.1)
+
+#include <cstddef> // size_t
+#include <cstring>
+
+#include <realm/util/assert.hpp>
+#include <realm/util/meta.hpp>
+#include <realm/utilities.hpp>
+#include <realm/data_type.hpp>
+#include <realm/olddatetime.hpp>
+#include <realm/string_data.hpp>
+#include <realm/binary_data.hpp>
+#include <realm/column_timestamp.hpp>
+
+namespace realm {
+
+
+/// This class represents a polymorphic Realm value.
+///
+/// At any particular moment an instance of this class stores a
+/// definite value of a definite type. If, for instance, that is an
+/// integer value, you may call get_int() to extract that value. You
+/// may call get_type() to discover what type of value is currently
+/// stored. Calling get_int() on an instance that does not store an
+/// integer, has undefined behavior, and likewise for all the other
+/// types that can be stored.
+///
+/// It is crucial to understand that the act of extracting a value of
+/// a particular type requires definite knowledge about the stored
+/// type. Calling a getter method for any particular type, that is not
+/// the same type as the stored value, has undefined behavior.
+///
+/// While values of numeric types are contained directly in a Mixed
+/// instance, character and binary data are merely referenced. A Mixed
+/// instance never owns the referenced data, nor does it in any other
+/// way attempt to manage its lifetime.
+///
+/// For compatibility with C style strings, when a string (character
+/// data) is stored in a Realm database, it is always followed by a
+/// terminating null character. This is also true when strings are
+/// stored in a mixed type column. This means that in the following
+/// code, if the 'mixed' value of the 8th row stores a string, then \c
+/// c_str will always point to a null-terminated string:
+///
+/// \code{.cpp}
+///
+///   const char* c_str = my_table[7].mixed.data(); // Always null-terminated
+///
+/// \endcode
+///
+/// Note that this assumption does not hold in general for strings in
+/// instances of Mixed. Indeed there is nothing stopping you from
+/// constructing a new Mixed instance that refers to a string without
+/// a terminating null character.
+///
+/// At the present time no soultion has been found that would allow
+/// for a Mixed instance to directly store a reference to a table. The
+/// problem is roughly as follows: From most points of view, the
+/// desirable thing to do, would be to store the table reference in a
+/// Mixed instance as a plain pointer without any ownership
+/// semantics. This would have no negative impact on the performance
+/// of copying and destroying Mixed instances, and it would serve just
+/// fine for passing a table as argument when setting the value of an
+/// entry in a mixed column. In that case a copy of the referenced
+/// table would be inserted into the mixed column.
+///
+/// On the other hand, when retrieving a table reference from a mixed
+/// column, storing it as a plain pointer in a Mixed instance is no
+/// longer an acceptable option. The complex rules for managing the
+/// lifetime of a Table instance, that represents a subtable,
+/// necessitates the use of a "smart pointer" such as
+/// TableRef. Enhancing the Mixed class to be able to act as a
+/// TableRef would be possible, but would also lead to several new
+/// problems. One problem is the risk of a Mixed instance outliving a
+/// stack allocated Table instance that it references. This would be a
+/// fatal error. Another problem is the impact that the nontrivial
+/// table reference has on the performance of copying and destroying
+/// Mixed instances.
+///
+/// \sa StringData
+class Mixed {
+public:
+    Mixed() noexcept;
+
+    Mixed(bool)       noexcept;
+    Mixed(int64_t)    noexcept;
+    Mixed(float)      noexcept;
+    Mixed(double)     noexcept;
+    Mixed(StringData) noexcept;
+    Mixed(BinaryData) noexcept;
+    Mixed(OldDateTime)   noexcept;
+    Mixed(Timestamp)    noexcept;
+
+    // These are shortcuts for Mixed(StringData(c_str)), and are
+    // needed to avoid unwanted implicit conversion of char* to bool.
+    Mixed(      char* c_str) noexcept { set_string(c_str); }
+    Mixed(const char* c_str) noexcept { set_string(c_str); }
+
+    struct subtable_tag {};
+    Mixed(subtable_tag) noexcept: m_type(type_Table) {}
+
+    ~Mixed() noexcept {}
+
+    DataType get_type() const noexcept { return m_type; }
+
+    int64_t     get_int()      const noexcept;
+    bool        get_bool()     const noexcept;
+    float       get_float()    const noexcept;
+    double      get_double()   const noexcept;
+    StringData  get_string()   const noexcept;
+    BinaryData  get_binary()   const noexcept;
+    OldDateTime    get_olddatetime() const noexcept;
+    Timestamp     get_timestamp()  const noexcept;
+
+    void set_int(int64_t) noexcept;
+    void set_bool(bool) noexcept;
+    void set_float(float) noexcept;
+    void set_double(double) noexcept;
+    void set_string(StringData) noexcept;
+    void set_binary(BinaryData) noexcept;
+    void set_binary(const char* data, size_t size) noexcept;
+    void set_olddatetime(OldDateTime) noexcept;
+    void set_timestamp(Timestamp) noexcept;
+
+    template<class Ch, class Tr>
+    friend std::basic_ostream<Ch, Tr>& operator<<(std::basic_ostream<Ch, Tr>&, const Mixed&);
+
+private:
+    DataType m_type;
+    union {
+        int64_t      m_int;
+        bool         m_bool;
+        float        m_float;
+        double       m_double;
+        const char*  m_data;
+        int_fast64_t m_date;
+        Timestamp      m_timestamp;
+    };
+    size_t m_size = 0;
+};
+
+// Note: We cannot compare two mixed values, since when the type of
+// both is type_Table, we would have to compare the two tables, but
+// the mixed values do not provide access to those tables.
+
+// Note: The mixed values are specified as Wrap<Mixed>. If they were
+// not, these operators would apply to simple comparisons, such as int
+// vs int64_t, and cause ambiguity. This is because the constructors
+// of Mixed are not explicit.
+
+// Compare mixed with integer
+template<class T>
+bool operator==(Wrap<Mixed>, const T&) noexcept;
+template<class T>
+bool operator!=(Wrap<Mixed>, const T&) noexcept;
+template<class T>
+bool operator==(const T&, Wrap<Mixed>) noexcept;
+template<class T>
+bool operator!=(const T&, Wrap<Mixed>) noexcept;
+
+// Compare mixed with boolean
+bool operator==(Wrap<Mixed>, bool) noexcept;
+bool operator!=(Wrap<Mixed>, bool) noexcept;
+bool operator==(bool, Wrap<Mixed>) noexcept;
+bool operator!=(bool, Wrap<Mixed>) noexcept;
+
+// Compare mixed with float
+bool operator==(Wrap<Mixed>, float);
+bool operator!=(Wrap<Mixed>, float);
+bool operator==(float, Wrap<Mixed>);
+bool operator!=(float, Wrap<Mixed>);
+
+// Compare mixed with double
+bool operator==(Wrap<Mixed>, double);
+bool operator!=(Wrap<Mixed>, double);
+bool operator==(double, Wrap<Mixed>);
+bool operator!=(double, Wrap<Mixed>);
+
+// Compare mixed with string
+bool operator==(Wrap<Mixed>, StringData) noexcept;
+bool operator!=(Wrap<Mixed>, StringData) noexcept;
+bool operator==(StringData, Wrap<Mixed>) noexcept;
+bool operator!=(StringData, Wrap<Mixed>) noexcept;
+bool operator==(Wrap<Mixed>, const char* c_str) noexcept;
+bool operator!=(Wrap<Mixed>, const char* c_str) noexcept;
+bool operator==(const char* c_str, Wrap<Mixed>) noexcept;
+bool operator!=(const char* c_str, Wrap<Mixed>) noexcept;
+bool operator==(Wrap<Mixed>, char* c_str) noexcept;
+bool operator!=(Wrap<Mixed>, char* c_str) noexcept;
+bool operator==(char* c_str, Wrap<Mixed>) noexcept;
+bool operator!=(char* c_str, Wrap<Mixed>) noexcept;
+
+// Compare mixed with binary data
+bool operator==(Wrap<Mixed>, BinaryData) noexcept;
+bool operator!=(Wrap<Mixed>, BinaryData) noexcept;
+bool operator==(BinaryData, Wrap<Mixed>) noexcept;
+bool operator!=(BinaryData, Wrap<Mixed>) noexcept;
+
+// Compare mixed with date
+bool operator==(Wrap<Mixed>, OldDateTime) noexcept;
+bool operator!=(Wrap<Mixed>, OldDateTime) noexcept;
+bool operator==(OldDateTime, Wrap<Mixed>) noexcept;
+bool operator!=(OldDateTime, Wrap<Mixed>) noexcept;
+
+
+
+
+// Implementation:
+
+inline Mixed::Mixed() noexcept
+{
+    m_type = type_Int;
+    m_int  = 0;
+}
+
+inline Mixed::Mixed(int64_t v) noexcept
+{
+    m_type = type_Int;
+    m_int  = v;
+}
+
+inline Mixed::Mixed(bool v) noexcept
+{
+    m_type = type_Bool;
+    m_bool = v;
+}
+
+inline Mixed::Mixed(float v) noexcept
+{
+    m_type = type_Float;
+    m_float = v;
+}
+
+inline Mixed::Mixed(double v) noexcept
+{
+   m_type = type_Double;
+   m_double = v;
+}
+
+inline Mixed::Mixed(StringData v) noexcept
+{
+    m_type = type_String;
+    m_data = v.data();
+    m_size = v.size();
+}
+
+inline Mixed::Mixed(BinaryData v) noexcept
+{
+    m_type = type_Binary;
+    m_data = v.data();
+    m_size = v.size();
+}
+
+inline Mixed::Mixed(OldDateTime v) noexcept
+{
+    m_type = type_OldDateTime;
+    m_date = v.get_olddatetime();
+}
+
+inline Mixed::Mixed(Timestamp v) noexcept
+{
+    m_type = type_Timestamp;
+    m_timestamp = v;
+}
+
+inline int64_t Mixed::get_int() const noexcept
+{
+    REALM_ASSERT(m_type == type_Int);
+    return m_int;
+}
+
+inline bool Mixed::get_bool() const noexcept
+{
+    REALM_ASSERT(m_type == type_Bool);
+    return m_bool;
+}
+
+inline float Mixed::get_float() const noexcept
+{
+    REALM_ASSERT(m_type == type_Float);
+    return m_float;
+}
+
+inline double Mixed::get_double() const noexcept
+{
+    REALM_ASSERT(m_type == type_Double);
+    return m_double;
+}
+
+inline StringData Mixed::get_string() const noexcept
+{
+    REALM_ASSERT(m_type == type_String);
+    return StringData(m_data, m_size);
+}
+
+inline BinaryData Mixed::get_binary() const noexcept
+{
+    REALM_ASSERT(m_type == type_Binary);
+    return BinaryData(m_data, m_size);
+}
+
+inline OldDateTime Mixed::get_olddatetime() const noexcept
+{
+    REALM_ASSERT(m_type == type_OldDateTime);
+    return m_date;
+}
+
+inline Timestamp Mixed::get_timestamp() const noexcept
+{
+    REALM_ASSERT(m_type == type_Timestamp);
+    return m_timestamp;
+}
+
+inline void Mixed::set_int(int64_t v) noexcept
+{
+    m_type = type_Int;
+    m_int = v;
+}
+
+inline void Mixed::set_bool(bool v) noexcept
+{
+    m_type = type_Bool;
+    m_bool = v;
+}
+
+inline void Mixed::set_float(float v) noexcept
+{
+    m_type = type_Float;
+    m_float = v;
+}
+
+inline void Mixed::set_double(double v) noexcept
+{
+    m_type = type_Double;
+    m_double = v;
+}
+
+inline void Mixed::set_string(StringData v) noexcept
+{
+    m_type = type_String;
+    m_data = v.data();
+    m_size = v.size();
+}
+
+inline void Mixed::set_binary(BinaryData v) noexcept
+{
+    set_binary(v.data(), v.size());
+}
+
+inline void Mixed::set_binary(const char* data, size_t size) noexcept
+{
+    m_type = type_Binary;
+    m_data = data;
+    m_size = size;
+}
+
+inline void Mixed::set_olddatetime(OldDateTime v) noexcept
+{
+    m_type = type_OldDateTime;
+    m_date = v.get_olddatetime();
+}
+
+inline void Mixed::set_timestamp(Timestamp v) noexcept
+{
+    REALM_ASSERT(false && "not yet implemented");
+    m_type = type_Timestamp;
+    m_timestamp = v;
+}
+
+
+template<class Ch, class Tr>
+inline std::basic_ostream<Ch, Tr>& operator<<(std::basic_ostream<Ch, Tr>& out, const Mixed& m)
+{
+    out << "Mixed(";
+    switch (m.m_type) {
+        case type_Int:         out << m.m_int;                        break;
+        case type_Bool:        out << m.m_bool;                       break;
+        case type_Float:       out << m.m_float;                      break;
+        case type_Double:      out << m.m_double;                     break;
+        case type_String:      out << StringData(m.m_data, m.m_size); break;
+        case type_Binary:      out << BinaryData(m.m_data, m.m_size); break;
+        case type_OldDateTime: out << OldDateTime(m.m_date);          break;
+        case type_Timestamp:   out << Timestamp(m.m_timestamp);       break;
+        case type_Table:       out << "subtable";                     break;
+        case type_Mixed:
+        case type_Link:
+        case type_LinkList:
+            REALM_ASSERT(false);
+    }
+    out << ")";
+    return out;
+}
+
+
+// Compare mixed with integer
+
+template<class T>
+inline bool operator==(Wrap<Mixed> a, const T& b) noexcept
+{
+    return Mixed(a).get_type() == type_Int && Mixed(a).get_int() == b;
+}
+
+template<class T>
+inline bool operator!=(Wrap<Mixed> a, const T& b) noexcept
+{
+    return Mixed(a).get_type() != type_Int || Mixed(a).get_int() != b;
+}
+
+template<class T>
+inline bool operator==(const T& a, Wrap<Mixed> b) noexcept
+{
+    return type_Int == Mixed(b).get_type() && a == Mixed(b).get_int();
+}
+
+template<class T>
+inline bool operator!=(const T& a, Wrap<Mixed> b) noexcept
+{
+    return type_Int != Mixed(b).get_type() || a != Mixed(b).get_int();
+}
+
+
+// Compare mixed with boolean
+
+inline bool operator==(Wrap<Mixed> a, bool b) noexcept
+{
+    return Mixed(a).get_type() == type_Bool && Mixed(a).get_bool() == b;
+}
+
+inline bool operator!=(Wrap<Mixed> a, bool b) noexcept
+{
+    return Mixed(a).get_type() != type_Bool || Mixed(a).get_bool() != b;
+}
+
+inline bool operator==(bool a, Wrap<Mixed> b) noexcept
+{
+    return type_Bool == Mixed(b).get_type() && a == Mixed(b).get_bool();
+}
+
+inline bool operator!=(bool a, Wrap<Mixed> b) noexcept
+{
+    return type_Bool != Mixed(b).get_type() || a != Mixed(b).get_bool();
+}
+
+
+// Compare mixed with float
+
+inline bool operator==(Wrap<Mixed> a, float b)
+{
+    return Mixed(a).get_type() == type_Float && Mixed(a).get_float() == b;
+}
+
+inline bool operator!=(Wrap<Mixed> a, float b)
+{
+    return Mixed(a).get_type() != type_Float || Mixed(a).get_float() != b;
+}
+
+inline bool operator==(float a, Wrap<Mixed> b)
+{
+    return type_Float == Mixed(b).get_type() && a == Mixed(b).get_float();
+}
+
+inline bool operator!=(float a, Wrap<Mixed> b)
+{
+    return type_Float != Mixed(b).get_type() || a != Mixed(b).get_float();
+}
+
+
+// Compare mixed with double
+
+inline bool operator==(Wrap<Mixed> a, double b)
+{
+    return Mixed(a).get_type() == type_Double && Mixed(a).get_double() == b;
+}
+
+inline bool operator!=(Wrap<Mixed> a, double b)
+{
+    return Mixed(a).get_type() != type_Double || Mixed(a).get_double() != b;
+}
+
+inline bool operator==(double a, Wrap<Mixed> b)
+{
+    return type_Double == Mixed(b).get_type() && a == Mixed(b).get_double();
+}
+
+inline bool operator!=(double a, Wrap<Mixed> b)
+{
+    return type_Double != Mixed(b).get_type() || a != Mixed(b).get_double();
+}
+
+
+// Compare mixed with string
+
+inline bool operator==(Wrap<Mixed> a, StringData b) noexcept
+{
+    return Mixed(a).get_type() == type_String && Mixed(a).get_string() == b;
+}
+
+inline bool operator!=(Wrap<Mixed> a, StringData b) noexcept
+{
+    return Mixed(a).get_type() != type_String || Mixed(a).get_string() != b;
+}
+
+inline bool operator==(StringData a, Wrap<Mixed> b) noexcept
+{
+    return type_String == Mixed(b).get_type() && a == Mixed(b).get_string();
+}
+
+inline bool operator!=(StringData a, Wrap<Mixed> b) noexcept
+{
+    return type_String != Mixed(b).get_type() || a != Mixed(b).get_string();
+}
+
+inline bool operator==(Wrap<Mixed> a, const char* b) noexcept
+{
+    return a == StringData(b);
+}
+
+inline bool operator!=(Wrap<Mixed> a, const char* b) noexcept
+{
+    return a != StringData(b);
+}
+
+inline bool operator==(const char* a, Wrap<Mixed> b) noexcept
+{
+    return StringData(a) == b;
+}
+
+inline bool operator!=(const char* a, Wrap<Mixed> b) noexcept
+{
+    return StringData(a) != b;
+}
+
+inline bool operator==(Wrap<Mixed> a, char* b) noexcept
+{
+    return a == StringData(b);
+}
+
+inline bool operator!=(Wrap<Mixed> a, char* b) noexcept
+{
+    return a != StringData(b);
+}
+
+inline bool operator==(char* a, Wrap<Mixed> b) noexcept
+{
+    return StringData(a) == b;
+}
+
+inline bool operator!=(char* a, Wrap<Mixed> b) noexcept
+{
+    return StringData(a) != b;
+}
+
+
+// Compare mixed with binary data
+
+inline bool operator==(Wrap<Mixed> a, BinaryData b) noexcept
+{
+    return Mixed(a).get_type() == type_Binary && Mixed(a).get_binary() == b;
+}
+
+inline bool operator!=(Wrap<Mixed> a, BinaryData b) noexcept
+{
+    return Mixed(a).get_type() != type_Binary || Mixed(a).get_binary() != b;
+}
+
+inline bool operator==(BinaryData a, Wrap<Mixed> b) noexcept
+{
+    return type_Binary == Mixed(b).get_type() && a == Mixed(b).get_binary();
+}
+
+inline bool operator!=(BinaryData a, Wrap<Mixed> b) noexcept
+{
+    return type_Binary != Mixed(b).get_type() || a != Mixed(b).get_binary();
+}
+
+
+// Compare mixed with date
+
+inline bool operator==(Wrap<Mixed> a, OldDateTime b) noexcept
+{
+    return Mixed(a).get_type() == type_OldDateTime && OldDateTime(Mixed(a).get_olddatetime()) == b;
+}
+
+inline bool operator!=(Wrap<Mixed> a, OldDateTime b) noexcept
+{
+    return Mixed(a).get_type() != type_OldDateTime || OldDateTime(Mixed(a).get_olddatetime()) != b;
+}
+
+inline bool operator==(OldDateTime a, Wrap<Mixed> b) noexcept
+{
+    return type_OldDateTime == Mixed(b).get_type() && a == OldDateTime(Mixed(b).get_olddatetime());
+}
+
+inline bool operator!=(OldDateTime a, Wrap<Mixed> b) noexcept
+{
+    return type_OldDateTime != Mixed(b).get_type() || a != OldDateTime(Mixed(b).get_olddatetime());
+}
+
+
+} // namespace realm
+
+#endif // REALM_MIXED_HPP
diff --git a/Pods/Realm/include/core/realm/null.hpp b/Pods/Realm/include/core/realm/null.hpp
new file mode 100644
index 0000000..30134c8
--- /dev/null
+++ b/Pods/Realm/include/core/realm/null.hpp
@@ -0,0 +1,130 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_NULL_HPP
+#define REALM_NULL_HPP
+
+#include <cmath>
+
+#include <realm/util/features.h>
+#include <realm/util/optional.hpp>
+#include <realm/utilities.hpp>
+#include <realm/exceptions.hpp>
+
+namespace realm {
+
+/*
+Represents null in Query, find(), get(), set(), etc.
+
+Float/Double: Realm can both store user-given NaNs and null. Any user-given signaling NaN is converted to
+0x7fa00000 (if float) or 0x7ff4000000000000 (if double). Any user-given quiet NaN is converted to
+0x7fc00000 (if float) or 0x7ff8000000000000 (if double). So Realm does not preserve the optional bits in
+user-given NaNs.
+
+However, since both clang and gcc on x64 and ARM, and also Java on x64, return these bit patterns when
+requesting NaNs, these will actually seem to roundtrip bit-exact for the end-user in most cases.
+
+If set_null() is called, a null is stored in form of the bit pattern 0xffffffff (if float) or
+0xffffffffffffffff (if double). These are quiet NaNs.
+
+Executing a query that involves a float/double column that contains NaNs gives an undefined result. If
+it contains signaling NaNs, it may throw an exception.
+
+Notes on IEEE:
+
+A NaN float is any bit pattern `s 11111111 S xxxxxxxxxxxxxxxxxxxxxx` where `s` and `x` are arbitrary, but at
+least 1 `x` must be 1. If `S` is 1, it's a quiet NaN, else it's a signaling NaN.
+
+A NaN doubule is the same as above, but for `s eeeeeeeeeee S xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx`
+
+The `S` bit is at position 22 (float) or 51 (double).
+*/
+
+struct null {
+    null() {}
+    operator int64_t() { throw(LogicError::type_mismatch); }
+    template<class T>
+    operator util::Optional<T>() { return util::none; }
+
+    template<class T>
+    bool operator == (const T&) const { REALM_ASSERT(false); return false; }
+    template<class T>
+    bool operator != (const T&) const { REALM_ASSERT(false); return false; }
+    template<class T>
+    bool operator > (const T&) const { REALM_ASSERT(false); return false; }
+    template<class T>
+    bool operator >= (const T&) const { REALM_ASSERT(false); return false; }
+    template<class T>
+    bool operator <= (const T&) const { REALM_ASSERT(false); return false; }
+    template<class T>
+    bool operator < (const T&) const { REALM_ASSERT(false); return false; }
+
+    /// Returns whether `v` bitwise equals the null bit-pattern
+    template<class T>
+    static bool is_null_float(T v) {
+        T i = null::get_null_float<T>();
+        return std::memcmp(&i, &v, sizeof(T)) == 0;
+    }
+
+    /// Returns the quiet NaNs that represent null for floats/doubles in Realm in stored payload.
+    template<class T>
+    static T get_null_float() {
+        typename std::conditional<std::is_same<T, float>::value, uint32_t, uint64_t>::type i;
+        int64_t double_nan = 0x7ff80000000000aa;
+        i = std::is_same<T, float>::value ? 0x7fc000aa : static_cast<decltype(i)>(double_nan);
+        T d = type_punning<T, decltype(i)>(i);
+        REALM_ASSERT_DEBUG(std::isnan(static_cast<double>(d)));
+        REALM_ASSERT_DEBUG(!is_signaling(d));
+        return d;
+    }
+
+    /// Takes a NaN as argument and returns whether or not it's signaling
+    template<class T>
+    static bool is_signaling(T v) {
+        REALM_ASSERT(std::isnan(static_cast<double>(v)));
+        typename std::conditional<std::is_same<T, float>::value, uint32_t, uint64_t>::type i;
+        size_t signal_bit = std::is_same<T, float>::value ? 22 : 51; // If this bit is set, it's quiet
+        i = type_punning<decltype(i), T>(v);
+        return !(i & (1ull << signal_bit));
+    }
+
+    /// Converts any signaling or quiet NaN to their their respective bit patterns that are used on x64 gcc+clang,
+    /// ARM clang and x64 Java.
+    template<class T>
+    static T to_realm(T v) {
+        if (std::isnan(static_cast<double>(v))) {
+            typename std::conditional<std::is_same<T, float>::value, uint32_t, uint64_t>::type i;
+            if (std::is_same<T, float>::value) {
+                i = is_signaling(v) ? 0x7fa00000 : 0x7fc00000;
+            }
+            else {
+                i = static_cast<decltype(i)>(is_signaling(v) ? 0x7ff4000000000000 : 0x7ff8000000000000);
+            }
+            return type_punning<T, decltype(i)>(i);
+        }
+        else {
+            return v;
+        }
+    }
+
+};
+
+} // namespace realm
+
+#endif // REALM_NULL_HPP
diff --git a/Pods/Realm/include/core/realm/olddatetime.hpp b/Pods/Realm/include/core/realm/olddatetime.hpp
new file mode 100644
index 0000000..47aca7c
--- /dev/null
+++ b/Pods/Realm/include/core/realm/olddatetime.hpp
@@ -0,0 +1,148 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_DATETIME_HPP
+#define REALM_DATETIME_HPP
+
+#include <ctime>
+#include <ostream>
+
+namespace realm {
+
+
+class OldDateTime {
+public:
+    OldDateTime() noexcept: m_time(0) {}
+
+    /// Construct from the number of seconds since Jan 1 00:00:00 UTC
+    /// 1970.
+    /// FIXME: See if we can make this private again. Required by query_expression.hpp
+    OldDateTime(int_fast64_t d) noexcept : m_time(d) {}
+
+    /// Return the time as seconds since Jan 1 00:00:00 UTC 1970.
+    int_fast64_t get_olddatetime() const noexcept { return m_time; }
+
+    friend bool operator==(const OldDateTime&, const OldDateTime&) noexcept;
+    friend bool operator!=(const OldDateTime&, const OldDateTime&) noexcept;
+    friend bool operator< (const OldDateTime&, const OldDateTime&) noexcept;
+    friend bool operator<= (const OldDateTime&, const OldDateTime&) noexcept;
+    friend bool operator> (const OldDateTime&, const OldDateTime&) noexcept;
+    friend bool operator>= (const OldDateTime&, const OldDateTime&) noexcept;
+
+    /// Construct from broken down local time.
+    ///
+    /// \note This constructor uses std::mktime() to convert the
+    /// specified local time to seconds since the Epoch, that is, the
+    /// result depends on the current globally specified time zone
+    /// setting.
+    ///
+    /// \param year The year (the minimum valid value is 1970).
+    ///
+    /// \param month The month in the range [1, 12].
+    ///
+    /// \param day The day of the month in the range [1, 31].
+    ///
+    /// \param hours Hours since midnight in the range [0, 23].
+    ///
+    /// \param minutes Minutes after the hour in the range [0, 59].
+    ///
+    /// \param seconds Seconds after the minute in the range [0,
+    /// 60]. Note that the range allows for leap seconds.
+    OldDateTime(int year, int month, int day, int hours = 0, int minutes = 0, int seconds = 0);
+
+    template<class Ch, class Tr>
+    friend std::basic_ostream<Ch, Tr>& operator<<(std::basic_ostream<Ch, Tr>& out, const OldDateTime&);
+
+    // This is used by query_expression.hpp to generalize its templates and simplify the code *alot*; it is needed
+    // because OldDateTime is internally stored in an int64_t column.
+    operator int_fast64_t() noexcept;
+
+private:
+    int_fast64_t m_time; // Seconds since Jan 1 00:00:00 UTC 1970.
+    static std::time_t assemble(int year, int month, int day, int hours, int minutes, int seconds);
+    template<typename T>
+    friend class Value;
+};
+
+
+// Implementation:
+
+inline bool operator==(const OldDateTime& a, const OldDateTime& b) noexcept
+{
+    return a.m_time == b.m_time;
+}
+
+inline bool operator!=(const OldDateTime& a, const OldDateTime& b) noexcept
+{
+    return a.m_time != b.m_time;
+}
+
+inline bool operator<(const OldDateTime& a, const OldDateTime& b) noexcept
+{
+    return a.m_time < b.m_time;
+}
+
+inline bool operator<=(const OldDateTime& a, const OldDateTime& b) noexcept
+{
+    return a.m_time <= b.m_time;
+}
+
+inline bool operator>(const OldDateTime& a, const OldDateTime& b) noexcept
+{
+    return a.m_time > b.m_time;
+}
+
+inline bool operator>=(const OldDateTime& a, const OldDateTime& b) noexcept
+{
+    return a.m_time >= b.m_time;
+}
+
+inline OldDateTime::operator int_fast64_t() noexcept
+{
+    return m_time;
+}
+
+inline OldDateTime::OldDateTime(int year, int month, int day, int hours, int minutes, int seconds):
+    m_time(assemble(year, month, day, hours, minutes, seconds)) {}
+
+template<class Ch, class Tr>
+inline std::basic_ostream<Ch, Tr>& operator<<(std::basic_ostream<Ch, Tr>& out, const OldDateTime& d)
+{
+    out << "OldDateTime("<<d.m_time<<")";
+    return out;
+}
+
+inline std::time_t OldDateTime::assemble(int year, int month, int day, int hours, int minutes, int seconds)
+{
+    std::tm local_time;
+    local_time.tm_year  = year  - 1900;
+    local_time.tm_mon   = month - 1;
+    local_time.tm_mday  = day;
+    local_time.tm_hour  = hours;
+    local_time.tm_min   = minutes;
+    local_time.tm_sec   = seconds;
+    local_time.tm_isdst = -1;
+    return std::mktime(&local_time);
+}
+
+
+} // namespace realm
+
+#endif // REALM_DATETIME_HPP
+
diff --git a/Pods/Realm/include/core/realm/owned_data.hpp b/Pods/Realm/include/core/realm/owned_data.hpp
new file mode 100644
index 0000000..f869278
--- /dev/null
+++ b/Pods/Realm/include/core/realm/owned_data.hpp
@@ -0,0 +1,81 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_OWNED_DATA_HPP
+#define REALM_OWNED_DATA_HPP
+
+#include <cstring>
+#include <memory>
+
+namespace realm {
+
+/// A chunk of owned data.
+class OwnedData {
+public:
+    /// Construct a null reference.
+    OwnedData() noexcept {}
+
+    /// If \a data_to_copy is 'null', \a data_size must be zero.
+    OwnedData(const char* data_to_copy, size_t data_size) : m_size(data_size)
+    {
+        REALM_ASSERT_DEBUG(data_to_copy || data_size == 0);
+        if (data_to_copy) {
+            m_data = std::unique_ptr<char[]>(new char[data_size]);
+            memcpy(m_data.get(), data_to_copy, data_size);
+        }
+    }
+
+    /// If \a unique_data is 'null', \a data_size must be zero.
+    OwnedData(std::unique_ptr<char[]> unique_data, size_t data_size) noexcept :
+        m_data(std::move(unique_data)), m_size(data_size)
+    {
+        REALM_ASSERT_DEBUG(m_data || m_size == 0);
+    }
+
+    OwnedData(const OwnedData& other) : OwnedData(other.m_data.get(), other.m_size) { }
+    OwnedData& operator=(const OwnedData& other);
+
+    OwnedData(OwnedData&&) = default;
+    OwnedData& operator=(OwnedData&&) = default;
+
+    const char* data() const { return m_data.get(); }
+    size_t size() const { return m_size; }
+
+private:
+    std::unique_ptr<char[]> m_data;
+    size_t m_size = 0;
+};
+
+inline OwnedData& OwnedData::operator=(const OwnedData& other)
+{
+    if (this != &other) {
+        if (other.m_data) {
+            m_data = std::unique_ptr<char[]>(new char[other.m_size]);
+            memcpy(m_data.get(), other.m_data.get(), other.m_size);
+        } else {
+            m_data = nullptr;
+        }
+        m_size = other.m_size;
+    }
+    return *this;
+}
+
+} // namespace realm
+
+#endif // REALM_OWNED_DATA_HPP
diff --git a/Pods/Realm/include/core/realm/query.hpp b/Pods/Realm/include/core/realm/query.hpp
new file mode 100644
index 0000000..6520311
--- /dev/null
+++ b/Pods/Realm/include/core/realm/query.hpp
@@ -0,0 +1,431 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_QUERY_HPP
+#define REALM_QUERY_HPP
+
+#include <stdint.h>
+#include <cstdio>
+#include <climits>
+#include <algorithm>
+#include <string>
+#include <vector>
+
+#define REALM_MULTITHREAD_QUERY 0
+
+#if REALM_MULTITHREAD_QUERY
+// FIXME: Use our C++ thread abstraction API since it provides a much
+// higher level of encapsulation and safety.
+#include <pthread.h>
+#endif
+
+#include <realm/views.hpp>
+#include <realm/table_ref.hpp>
+#include <realm/binary_data.hpp>
+#include <realm/olddatetime.hpp>
+#include <realm/handover_defs.hpp>
+#include <realm/link_view_fwd.hpp>
+#include <realm/descriptor_fwd.hpp>
+#include <realm/row.hpp>
+
+namespace realm {
+
+
+// Pre-declarations
+class ParentNode;
+class Table;
+class TableView;
+class TableViewBase;
+class ConstTableView;
+class Array;
+class Expression;
+class SequentialGetterBase;
+class Group;
+
+struct QueryGroup {
+    enum class State {
+        Default,
+        OrCondition,
+        OrConditionChildren,
+    };
+
+    QueryGroup() = default;
+
+    QueryGroup(const QueryGroup&);
+    QueryGroup& operator=(const QueryGroup&);
+
+    QueryGroup(QueryGroup&&) = default;
+    QueryGroup& operator=(QueryGroup&&) = default;
+
+    QueryGroup(const QueryGroup&, QueryNodeHandoverPatches&);
+
+    std::unique_ptr<ParentNode> m_root_node;
+
+    bool m_pending_not = false;
+    size_t m_subtable_column = not_found;
+    State m_state = State::Default;
+};
+
+class Query {
+public:
+    Query(const Table& table, TableViewBase* tv = nullptr);
+    Query(const Table& table, std::unique_ptr<TableViewBase>);
+    Query(const Table& table, const LinkViewRef& lv);
+    Query();
+    Query(std::unique_ptr<Expression>);
+    virtual ~Query() noexcept;
+
+    Query(const Query& copy);
+    Query& operator = (const Query& source);
+
+    Query(Query&&);
+    Query& operator=(Query&&);
+
+    // Find links that point to a specific target row
+    Query& links_to(size_t column_ndx, const ConstRow& target_row);
+
+    // Conditions: null
+    Query& equal(size_t column_ndx, null);
+    Query& not_equal(size_t column_ndx, null);
+
+    // Conditions: int64_t
+    Query& equal(size_t column_ndx, int64_t value);
+    Query& not_equal(size_t column_ndx, int64_t value);
+    Query& greater(size_t column_ndx, int64_t value);
+    Query& greater_equal(size_t column_ndx, int64_t value);
+    Query& less(size_t column_ndx, int64_t value);
+    Query& less_equal(size_t column_ndx, int64_t value);
+    Query& between(size_t column_ndx, int64_t from, int64_t to);
+
+    // Conditions: int (we need those because conversion from '1234' is ambiguous with float/double)
+    Query& equal(size_t column_ndx, int value);
+    Query& not_equal(size_t column_ndx, int value);
+    Query& greater(size_t column_ndx, int value);
+    Query& greater_equal(size_t column_ndx, int value);
+    Query& less(size_t column_ndx, int value);
+    Query& less_equal(size_t column_ndx, int value);
+    Query& between(size_t column_ndx, int from, int to);
+
+    // Conditions: 2 int columns
+    Query& equal_int(size_t column_ndx1, size_t column_ndx2);
+    Query& not_equal_int(size_t column_ndx1, size_t column_ndx2);
+    Query& greater_int(size_t column_ndx1, size_t column_ndx2);
+    Query& less_int(size_t column_ndx1, size_t column_ndx2);
+    Query& greater_equal_int(size_t column_ndx1, size_t column_ndx2);
+    Query& less_equal_int(size_t column_ndx1, size_t column_ndx2);
+
+    // Conditions: float
+    Query& equal(size_t column_ndx, float value);
+    Query& not_equal(size_t column_ndx, float value);
+    Query& greater(size_t column_ndx, float value);
+    Query& greater_equal(size_t column_ndx, float value);
+    Query& less(size_t column_ndx, float value);
+    Query& less_equal(size_t column_ndx, float value);
+    Query& between(size_t column_ndx, float from, float to);
+
+    // Conditions: 2 float columns
+    Query& equal_float(size_t column_ndx1, size_t column_ndx2);
+    Query& not_equal_float(size_t column_ndx1, size_t column_ndx2);
+    Query& greater_float(size_t column_ndx1, size_t column_ndx2);
+    Query& greater_equal_float(size_t column_ndx1, size_t column_ndx2);
+    Query& less_float(size_t column_ndx1, size_t column_ndx2);
+    Query& less_equal_float(size_t column_ndx1, size_t column_ndx2);
+
+     // Conditions: double
+    Query& equal(size_t column_ndx, double value);
+    Query& not_equal(size_t column_ndx, double value);
+    Query& greater(size_t column_ndx, double value);
+    Query& greater_equal(size_t column_ndx, double value);
+    Query& less(size_t column_ndx, double value);
+    Query& less_equal(size_t column_ndx, double value);
+    Query& between(size_t column_ndx, double from, double to);
+
+    // Conditions: 2 double columns
+    Query& equal_double(size_t column_ndx1, size_t column_ndx2);
+    Query& not_equal_double(size_t column_ndx1, size_t column_ndx2);
+    Query& greater_double(size_t column_ndx1, size_t column_ndx2);
+    Query& greater_equal_double(size_t column_ndx1, size_t column_ndx2);
+    Query& less_double(size_t column_ndx1, size_t column_ndx2);
+    Query& less_equal_double(size_t column_ndx1, size_t column_ndx2);
+
+    Query& equal(size_t column_ndx, Timestamp value);
+    Query& not_equal(size_t column_ndx, Timestamp value);
+    Query& greater(size_t column_ndx, Timestamp value);
+    Query& greater_equal(size_t column_ndx, Timestamp value);
+    Query& less_equal(size_t column_ndx, Timestamp value);
+    Query& less(size_t column_ndx, Timestamp value);
+
+    // Conditions: bool
+    Query& equal(size_t column_ndx, bool value);
+
+    // Conditions: date
+    Query& equal_olddatetime(size_t column_ndx, OldDateTime value) { return equal(column_ndx, int64_t(value.get_olddatetime())); }
+    Query& not_equal_olddatetime(size_t column_ndx, OldDateTime value) { return not_equal(column_ndx, int64_t(value.get_olddatetime())); }
+    Query& greater_olddatetime(size_t column_ndx, OldDateTime value) { return greater(column_ndx, int64_t(value.get_olddatetime())); }
+    Query& greater_equal_olddatetime(size_t column_ndx, OldDateTime value) { return greater_equal(column_ndx, int64_t(value.get_olddatetime())); }
+    Query& less_olddatetime(size_t column_ndx, OldDateTime value) { return less(column_ndx, int64_t(value.get_olddatetime())); }
+    Query& less_equal_olddatetime(size_t column_ndx, OldDateTime value) { return less_equal(column_ndx, int64_t(value.get_olddatetime())); }
+    Query& between_olddatetime(size_t column_ndx, OldDateTime from, OldDateTime to) { return between(column_ndx, int64_t(from.get_olddatetime()), int64_t(to.get_olddatetime())); }
+
+    // Conditions: strings
+    Query& equal(size_t column_ndx, StringData value, bool case_sensitive=true);
+    Query& not_equal(size_t column_ndx, StringData value, bool case_sensitive=true);
+    Query& begins_with(size_t column_ndx, StringData value, bool case_sensitive=true);
+    Query& ends_with(size_t column_ndx, StringData value, bool case_sensitive=true);
+    Query& contains(size_t column_ndx, StringData value, bool case_sensitive=true);
+
+    // These are shortcuts for equal(StringData(c_str)) and
+    // not_equal(StringData(c_str)), and are needed to avoid unwanted
+    // implicit conversion of char* to bool.
+    Query& equal(size_t column_ndx, const char* c_str, bool case_sensitive=true);
+    Query& not_equal(size_t column_ndx, const char* c_str, bool case_sensitive=true);
+
+    // Conditions: binary data
+    Query& equal(size_t column_ndx, BinaryData value);
+    Query& not_equal(size_t column_ndx, BinaryData value);
+    Query& begins_with(size_t column_ndx, BinaryData value);
+    Query& ends_with(size_t column_ndx, BinaryData value);
+    Query& contains(size_t column_ndx, BinaryData value);
+
+    // Negation
+    Query& Not();
+
+    // Grouping
+    Query& group();
+    Query& end_group();
+    Query& subtable(size_t column);
+    Query& end_subtable();
+    Query& Or();
+
+    Query& and_query(const Query& q);
+    Query& and_query(Query&& q);
+    Query operator||(const Query& q);
+    Query operator&&(const Query& q);
+    Query operator!();
+
+
+    // Searching
+    size_t         find(size_t begin_at_table_row=size_t(0));
+    TableView      find_all(size_t start = 0, size_t end=size_t(-1), size_t limit = size_t(-1));
+    ConstTableView find_all(size_t start = 0, size_t end=size_t(-1), size_t limit = size_t(-1)) const;
+
+    // Aggregates
+    size_t count(size_t start = 0, size_t end=size_t(-1), size_t limit = size_t(-1)) const;
+
+    int64_t sum_int(size_t column_ndx, size_t* resultcount = nullptr, size_t start = 0, size_t end = size_t(-1),
+                    size_t limit = size_t(-1)) const;
+
+    double  average_int(size_t column_ndx, size_t* resultcount = nullptr, size_t start = 0, size_t end = size_t(-1),
+                        size_t limit = size_t(-1)) const;
+
+    int64_t maximum_int(size_t column_ndx, size_t* resultcount = nullptr, size_t start = 0, size_t end = size_t(-1),
+                        size_t limit = size_t(-1), size_t* return_ndx = nullptr) const;
+
+    int64_t minimum_int(size_t column_ndx, size_t* resultcount = nullptr, size_t start = 0, size_t end = size_t(-1),
+                        size_t limit = size_t(-1), size_t* return_ndx = nullptr) const;
+
+    double sum_float(    size_t column_ndx, size_t* resultcount = nullptr, size_t start = 0, size_t end = size_t(-1),
+                         size_t limit = size_t(-1)) const;
+
+    double average_float(size_t column_ndx, size_t* resultcount = nullptr, size_t start = 0, size_t end = size_t(-1),
+                         size_t limit = size_t(-1)) const;
+
+    float  maximum_float(size_t column_ndx, size_t* resultcount = nullptr, size_t start = 0, size_t end = size_t(-1),
+                         size_t limit = size_t(-1), size_t* return_ndx = nullptr) const;
+
+    float  minimum_float(size_t column_ndx, size_t* resultcount = nullptr, size_t start = 0, size_t end = size_t(-1),
+                         size_t limit = size_t(-1), size_t* return_ndx = nullptr) const;
+
+    double sum_double(    size_t column_ndx, size_t* resultcount = nullptr, size_t start = 0, size_t end = size_t(-1),
+                          size_t limit = size_t(-1)) const;
+
+    double average_double(size_t column_ndx, size_t* resultcount = nullptr, size_t start = 0, size_t end = size_t(-1),
+                          size_t limit = size_t(-1)) const;
+
+    double maximum_double(size_t column_ndx, size_t* resultcount = nullptr, size_t start = 0, size_t end = size_t(-1),
+                          size_t limit = size_t(-1), size_t* return_ndx = nullptr) const;
+
+    double minimum_double(size_t column_ndx, size_t* resultcount = nullptr, size_t start = 0, size_t end = size_t(-1),
+                          size_t limit = size_t(-1), size_t* return_ndx = nullptr) const;
+
+    OldDateTime maximum_olddatetime(size_t column_ndx, size_t* resultcount = nullptr, size_t start = 0, size_t end = size_t(-1),
+                              size_t limit = size_t(-1), size_t* return_ndx = nullptr) const;
+
+    OldDateTime minimum_olddatetime(size_t column_ndx, size_t* resultcount = nullptr, size_t start = 0, size_t end = size_t(-1),
+                              size_t limit = size_t(-1), size_t* return_ndx = nullptr) const;
+
+    Timestamp maximum_timestamp(size_t column_ndx, size_t* return_ndx, size_t start = 0, size_t end = size_t(-1),
+                                size_t limit = size_t(-1));
+
+    Timestamp minimum_timestamp(size_t column_ndx, size_t* return_ndx, size_t start = 0, size_t end = size_t(-1), 
+                                size_t limit = size_t(-1));
+
+    // Deletion
+    size_t  remove(size_t start = 0, size_t end=size_t(-1), size_t limit = size_t(-1));
+
+#if REALM_MULTITHREAD_QUERY
+    // Multi-threading
+    TableView      find_all_multi(size_t start = 0, size_t end=size_t(-1));
+    ConstTableView find_all_multi(size_t start = 0, size_t end=size_t(-1)) const;
+    int            set_threads(unsigned int threadcount);
+#endif
+
+    TableRef& get_table() {return m_table;}
+
+    // True if matching rows are guaranteed to be returned in table order.
+    bool produces_results_in_table_order() const { return !m_view; }
+
+    // Calls sync_if_needed on the restricting view, if present.
+    // Returns the current version of the table(s) this query depends on,
+    // or util::none if the query is not associated with a table.
+    util::Optional<uint_fast64_t> sync_view_if_needed() const;
+
+    std::string validate();
+
+protected:
+    Query(Table& table, TableViewBase* tv = nullptr);
+    void create();
+
+    void   init(const Table& table) const;
+    bool   is_initialized() const;
+    size_t find_internal(size_t start = 0, size_t end=size_t(-1)) const;
+    size_t peek_tableview(size_t tv_index) const;
+    void handle_pending_not();
+    void set_table(TableRef tr);
+
+    static bool  comp(const std::pair<size_t, size_t>& a, const std::pair<size_t, size_t>& b);
+
+public:
+    using HandoverPatch = QueryHandoverPatch;
+
+    virtual std::unique_ptr<Query> clone_for_handover(std::unique_ptr<HandoverPatch>& patch,
+                                                      ConstSourcePayload mode) const
+    {
+        patch.reset(new HandoverPatch);
+        std::unique_ptr<Query> retval(new Query(*this, *patch, mode));
+        return retval;
+    }
+
+    virtual std::unique_ptr<Query> clone_for_handover(std::unique_ptr<HandoverPatch>& patch,
+                                                      MutableSourcePayload mode)
+    {
+        patch.reset(new HandoverPatch);
+        std::unique_ptr<Query> retval(new Query(*this, *patch, mode));
+        return retval;
+    }
+
+    virtual void apply_and_consume_patch(std::unique_ptr<HandoverPatch>& patch, Group& dest_group)
+    {
+        apply_patch(*patch, dest_group);
+        patch.reset();
+    }
+
+    void apply_patch(HandoverPatch& patch, Group& dest_group);
+    Query(const Query& source, HandoverPatch& patch, ConstSourcePayload mode);
+    Query(Query& source, HandoverPatch& patch, MutableSourcePayload mode);
+private:
+    void fetch_descriptor();
+
+    void add_expression_node(std::unique_ptr<Expression>);
+
+    template<class ColumnType>
+    Query& equal(size_t column_ndx1, size_t column_ndx2);
+
+    template<class ColumnType>
+    Query& less(size_t column_ndx1, size_t column_ndx2);
+
+    template<class ColumnType>
+    Query& less_equal(size_t column_ndx1, size_t column_ndx2);
+
+    template<class ColumnType>
+    Query& greater(size_t column_ndx1, size_t column_ndx2);
+
+    template<class ColumnType>
+    Query& greater_equal(size_t column_ndx1, size_t column_ndx2);
+
+    template<class ColumnType>
+    Query& not_equal(size_t column_ndx1, size_t column_ndx2);
+
+    template<typename TConditionFunction, class T>
+    Query& add_condition(size_t column_ndx, T value);
+
+    template<typename T, bool Nullable>
+    double average(size_t column_ndx, size_t* resultcount = nullptr, size_t start = 0,
+                   size_t end=size_t(-1), size_t limit = size_t(-1)) const;
+
+    template<Action action, typename T, typename R, class ColClass>
+    R aggregate(R (ColClass::*method)(size_t, size_t, size_t, size_t*) const,
+                size_t column_ndx, size_t* resultcount, size_t start, size_t end, size_t limit,
+                size_t* return_ndx = nullptr) const;
+
+    void aggregate_internal(Action TAction, DataType TSourceColumn, bool nullable,
+                            ParentNode* pn, QueryStateBase* st,
+                            size_t start, size_t end, SequentialGetterBase* source_column) const;
+
+    void find_all(TableViewBase& tv, size_t start = 0, size_t end=size_t(-1), size_t limit = size_t(-1)) const;
+    void delete_nodes() noexcept;
+
+    bool has_conditions() const { return m_groups.size() > 0 && m_groups[0].m_root_node; }
+    ParentNode* root_node() const
+    {
+        REALM_ASSERT(m_groups.size());
+        return m_groups[0].m_root_node.get();
+    }
+
+    void add_node(std::unique_ptr<ParentNode>);
+
+    friend class Table;
+    friend class TableViewBase;
+
+    std::string error_code;
+
+    std::vector<QueryGroup> m_groups;
+
+    // Used to access schema while building query:
+    std::vector<size_t> m_subtable_path;
+
+    ConstDescriptorRef m_current_descriptor;
+    TableRef m_table;
+
+    // points to the base class of the restricting view. If the restricting
+    // view is a link view, m_source_link_view is non-zero. If it is a table view,
+    // m_source_table_view is non-zero.
+    RowIndexes* m_view = nullptr;
+
+    // At most one of these can be non-zero, and if so the non-zero one indicates the restricting view.
+    LinkViewRef m_source_link_view; // link views are refcounted and shared.
+    TableViewBase* m_source_table_view = nullptr; // table views are not refcounted, and not owned by the query.
+    std::unique_ptr<TableViewBase> m_owned_source_table_view; // <--- except when indicated here
+};
+
+// Implementation:
+
+inline Query& Query::equal(size_t column_ndx, const char* c_str, bool case_sensitive)
+{
+    return equal(column_ndx, StringData(c_str), case_sensitive);
+}
+
+inline Query& Query::not_equal(size_t column_ndx, const char* c_str, bool case_sensitive)
+{
+    return not_equal(column_ndx, StringData(c_str), case_sensitive);
+}
+
+} // namespace realm
+
+#endif // REALM_QUERY_HPP
diff --git a/Pods/Realm/include/core/realm/query_conditions.hpp b/Pods/Realm/include/core/realm/query_conditions.hpp
new file mode 100644
index 0000000..c32cc9a
--- /dev/null
+++ b/Pods/Realm/include/core/realm/query_conditions.hpp
@@ -0,0 +1,387 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_QUERY_CONDITIONS_HPP
+#define REALM_QUERY_CONDITIONS_HPP
+
+#include <stdint.h>
+#include <string>
+
+#include <realm/unicode.hpp>
+#include <realm/binary_data.hpp>
+#include <realm/utilities.hpp>
+
+namespace realm {
+
+// Array::VTable only uses the first 4 conditions (enums) in an array of function pointers
+enum {cond_Equal, cond_NotEqual, cond_Greater, cond_Less, cond_VTABLE_FINDER_COUNT, cond_None, cond_LeftNotNull };
+
+// Quick hack to make "Queries with Integer null columns" able to compile in Visual Studio 2015 which doesn't full support sfinae
+// (real cause hasn't been investigated yet, cannot exclude that we don't obey c++11 standard)
+struct HackClass
+{
+    template<class A, class B, class C>
+    bool can_match(A, B, C) { REALM_ASSERT(false); return false; }
+    template<class A, class B, class C>
+    bool will_match(A, B, C) { REALM_ASSERT(false); return false; }
+};
+
+// Does v2 contain v1?
+struct Contains : public HackClass {
+    bool operator()(StringData v1, const char*, const char*, StringData v2, bool = false, bool = false) const { return v2.contains(v1); }
+    bool operator()(StringData v1, StringData v2, bool = false, bool = false) const { return v2.contains(v1); }
+    bool operator()(BinaryData v1, BinaryData v2, bool = false, bool = false) const { return v2.contains(v1); }
+
+    template<class A, class B> bool operator()(A, B) const { REALM_ASSERT(false); return false; }
+    template<class A, class B, class C, class D> bool operator()(A, B, C, D) const { REALM_ASSERT(false); return false; }
+    bool operator()(int64_t, int64_t, bool, bool) const { REALM_ASSERT(false); return false; }
+
+    static const int condition = -1;
+};
+
+// Does v2 begin with v1?
+struct BeginsWith : public HackClass {
+    bool operator()(StringData v1, const char*, const char*, StringData v2, bool = false, bool = false) const { return v2.begins_with(v1); }
+    bool operator()(StringData v1, StringData v2, bool = false, bool = false) const { return v2.begins_with(v1); }
+    bool operator()(BinaryData v1, BinaryData v2, bool = false, bool = false) const { return v2.begins_with(v1); }
+
+    template<class A, class B, class C, class D>
+    bool operator()(A, B, C, D) const { REALM_ASSERT(false); return false; }
+    template<class A, class B>
+    bool operator()(A, B) const { REALM_ASSERT(false); return false; }
+
+    static const int condition = -1;
+};
+
+// Does v2 end with v1?
+struct EndsWith : public HackClass {
+    bool operator()(StringData v1, const char*, const char*, StringData v2, bool = false, bool = false) const { return v2.ends_with(v1); }
+    bool operator()(StringData v1, StringData v2, bool = false, bool = false) const { return v2.ends_with(v1); }
+    bool operator()(BinaryData v1, BinaryData v2, bool = false, bool = false) const { return v2.ends_with(v1); }
+
+    template<class A, class B>
+    bool operator()(A, B) const { REALM_ASSERT(false); return false; }
+    template<class A, class B, class C, class D>
+    bool operator()(A, B, C, D) const { REALM_ASSERT(false); return false; }
+
+    static const int condition = -1;
+};
+
+struct Equal {
+    static const int avx = 0x00; // _CMP_EQ_OQ
+//    bool operator()(const bool v1, const bool v2, bool v1null = false, bool v2null = false) const { return v1 == v2; }
+    bool operator()(StringData v1, const char*, const char*, StringData v2, bool = false, bool = false) const
+    {
+        return v1 == v2;
+    }
+    bool operator()(BinaryData v1, BinaryData v2, bool = false, bool = false) const { return v1 == v2; }
+
+    template<class T>
+    bool operator()(const T& v1, const T& v2, bool v1null = false, bool v2null = false) const
+    {
+        return (v1null && v2null) || (!v1null && !v2null && v1 == v2);
+    }
+    static const int condition = cond_Equal;
+    bool can_match(int64_t v, int64_t lbound, int64_t ubound) { return (v >= lbound && v <= ubound); }
+    bool will_match(int64_t v, int64_t lbound, int64_t ubound) { return (v == 0 && ubound == 0 && lbound == 0); }
+};
+
+struct NotEqual {
+    static const int avx = 0x0B; // _CMP_FALSE_OQ
+    bool operator()(StringData v1, const char*, const char*, StringData v2, bool = false, bool = false) const { return v1 != v2; }
+   // bool operator()(BinaryData v1, BinaryData v2, bool = false, bool = false) const { return v1 != v2; }
+
+    template<class T>
+    bool operator()(const T& v1, const T& v2, bool v1null = false, bool v2null = false) const
+    {
+        if (!v1null && !v2null)
+            return v1 != v2;
+
+        if (v1null && v2null)
+            return false;
+
+        return true;
+    }
+
+    static const int condition = cond_NotEqual;
+    bool can_match(int64_t v, int64_t lbound, int64_t ubound) { return !(v == 0 && ubound == 0 && lbound == 0); }
+    bool will_match(int64_t v, int64_t lbound, int64_t ubound) { return (v > ubound || v < lbound); }
+
+    template<class A, class B, class C, class D>
+    bool operator()(A, B, C, D) const { REALM_ASSERT(false); return false; }
+};
+
+// Does v2 contain v1?
+struct ContainsIns : public HackClass {
+    bool operator()(StringData v1, const char* v1_upper, const char* v1_lower, StringData v2, bool = false, bool = false) const
+    {
+        if (v2.is_null() && !v1.is_null())
+            return false;
+
+        if (v1.size() == 0 && !v2.is_null())
+            return true;
+
+        return search_case_fold(v2, v1_upper, v1_lower, v1.size()) != v2.size();
+    }
+
+    // Slow version, used if caller hasn't stored an upper and lower case version
+    bool operator()(StringData v1, StringData v2, bool = false, bool = false) const
+    {
+        if (v2.is_null() && !v1.is_null())
+            return false;
+
+        if (v1.size() == 0 && !v2.is_null())
+            return true;
+
+        std::string v1_upper = case_map(v1, true, IgnoreErrors);
+        std::string v1_lower = case_map(v1, false, IgnoreErrors);
+        return search_case_fold(v2, v1_upper.c_str(), v1_lower.c_str(), v1.size()) != v2.size();
+    }
+
+    template<class A, class B> bool operator()(A, B) const { REALM_ASSERT(false); return false; }
+    template<class A, class B, class C, class D> bool operator()(A, B, C, D) const { REALM_ASSERT(false); return false; }
+    bool operator()(int64_t, int64_t, bool, bool) const { REALM_ASSERT(false); return false; }
+
+    static const int condition = -1;
+};
+
+// Does v2 begin with v1?
+struct BeginsWithIns : public HackClass {
+    bool operator()(StringData v1, const char* v1_upper, const char* v1_lower, StringData v2, bool = false, bool = false) const
+    {
+        if (v2.is_null() && !v1.is_null())
+            return false;
+        return v1.size() <= v2.size() && equal_case_fold(v2.prefix(v1.size()), v1_upper, v1_lower);
+    }
+
+    // Slow version, used if caller hasn't stored an upper and lower case version
+    bool operator()(StringData v1, StringData v2, bool = false, bool = false) const
+    {
+        if (v2.is_null() && !v1.is_null())
+            return false;
+
+        if (v1.size() > v2.size())
+            return false;
+        std::string v1_upper = case_map(v1, true, IgnoreErrors);
+        std::string v1_lower = case_map(v1, false, IgnoreErrors);
+        return equal_case_fold(v2.prefix(v1.size()), v1_upper.c_str(), v1_lower.c_str());
+    }
+
+    template<class A, class B> bool operator()(A, B) const { REALM_ASSERT(false); return false; }
+    template<class A, class B, class C, class D> bool operator()(A, B, C, D) const { REALM_ASSERT(false); return false; }
+    bool operator()(int64_t, int64_t, bool, bool) const { REALM_ASSERT(false); return false; }
+
+    static const int condition = -1;
+};
+
+// Does v2 end with v1?
+struct EndsWithIns : public HackClass {
+    bool operator()(StringData v1, const char* v1_upper, const char* v1_lower, StringData v2, bool = false, bool = false) const
+    {
+        if (v2.is_null() && !v1.is_null())
+            return false;
+
+        return v1.size() <= v2.size() && equal_case_fold(v2.suffix(v1.size()), v1_upper, v1_lower);
+    }
+
+    // Slow version, used if caller hasn't stored an upper and lower case version
+    bool operator()(StringData v1, StringData v2, bool = false, bool = false) const
+    {
+        if (v2.is_null() && !v1.is_null())
+            return false;
+
+        if (v1.size() > v2.size())
+            return false;
+        std::string v1_upper = case_map(v1, true, IgnoreErrors);
+        std::string v1_lower = case_map(v1, false, IgnoreErrors);
+        return equal_case_fold(v2.suffix(v1.size()), v1_upper.c_str(), v1_lower.c_str());
+    }
+
+    template<class A, class B> bool operator()(A, B) const { REALM_ASSERT(false); return false; }
+    template<class A, class B, class C, class D> bool operator()(A, B, C, D) const { REALM_ASSERT(false); return false; }
+    bool operator()(int64_t, int64_t, bool, bool) const { REALM_ASSERT(false); return false; }
+
+    static const int condition = -1;
+};
+
+struct EqualIns : public HackClass {
+    bool operator()(StringData v1, const char* v1_upper, const char* v1_lower, StringData v2, bool = false, bool = false) const
+    {
+        if (v1.is_null() != v2.is_null())
+            return false;
+
+        return v1.size() == v2.size() && equal_case_fold(v2, v1_upper, v1_lower);
+    }
+
+    // Slow version, used if caller hasn't stored an upper and lower case version
+    bool operator()(StringData v1, StringData v2, bool = false, bool = false) const
+    {
+        if (v1.is_null() != v2.is_null())
+            return false;
+
+        if (v1.size() != v2.size())
+            return false;
+        std::string v1_upper = case_map(v1, true, IgnoreErrors);
+        std::string v1_lower = case_map(v1, false, IgnoreErrors);
+        return equal_case_fold(v2, v1_upper.c_str() , v1_lower.c_str());
+    }
+
+    template<class A, class B> bool operator()(A, B) const { REALM_ASSERT(false); return false; }
+    template<class A, class B, class C, class D> bool operator()(A, B, C, D) const { REALM_ASSERT(false); return false; }
+    bool operator()(int64_t, int64_t, bool, bool) const { REALM_ASSERT(false); return false; }
+
+    static const int condition = -1;
+};
+
+struct NotEqualIns : public HackClass {
+    bool operator()(StringData v1, const char* v1_upper, const char* v1_lower, StringData v2, bool = false, bool = false) const
+    {
+        if (v1.is_null() != v2.is_null())
+            return true;
+        return v1.size() != v2.size() || !equal_case_fold(v2, v1_upper, v1_lower);
+    }
+
+    // Slow version, used if caller hasn't stored an upper and lower case version
+    bool operator()(StringData v1, StringData v2, bool = false, bool = false) const
+    {
+        if (v1.is_null() != v2.is_null())
+            return true;
+
+        if (v1.size() != v2.size())
+            return true;
+        std::string v1_upper = case_map(v1, true, IgnoreErrors);
+        std::string v1_lower = case_map(v1, false, IgnoreErrors);
+        return !equal_case_fold(v2, v1_upper.c_str(), v1_lower.c_str());
+    }
+
+    template<class A, class B>
+    bool operator()(A, B) const { REALM_ASSERT(false); return false; }
+    template<class A, class B, class C, class D>
+    bool operator()(A, B, C, D) const { REALM_ASSERT(false); return false; }
+
+    static const int condition = -1;
+};
+
+struct Greater {
+    static const int avx = 0x1E;  // _CMP_GT_OQ
+    template<class T>
+    bool operator()(const T& v1, const T& v2, bool v1null = false, bool v2null = false) const
+    {
+        if (v1null || v2null)
+            return false;
+
+        return v1 > v2;
+    }
+    static const int condition = cond_Greater;
+    template<class A, class B, class C, class D>
+    bool operator()(A, B, C, D) const { REALM_ASSERT(false); return false; }
+
+    bool can_match(int64_t v, int64_t lbound, int64_t ubound) { static_cast<void>(lbound); return ubound > v; }
+    bool will_match(int64_t v, int64_t lbound, int64_t ubound) { static_cast<void>(ubound); return lbound > v; }
+};
+
+struct None {
+    template<class T>
+    bool operator()(const T&, const T&, bool = false, bool = false) const {return true;}
+    static const int condition = cond_None;
+    template<class A, class B, class C, class D>
+    bool operator()(A, B, C, D) const { REALM_ASSERT(false); return false; }
+    bool can_match(int64_t v, int64_t lbound, int64_t ubound) {static_cast<void>(lbound); static_cast<void>(ubound); static_cast<void>(v); return true; }
+    bool will_match(int64_t v, int64_t lbound, int64_t ubound) {static_cast<void>(lbound); static_cast<void>(ubound); static_cast<void>(v); return true; }
+};
+
+struct NotNull {
+    template<class T>
+    bool operator()(const T&, const T&, bool v = false, bool = false) const { return !v; }
+    static const int condition = cond_LeftNotNull;
+    template<class A, class B, class C, class D>
+    bool operator()(A, B, C, D) const { REALM_ASSERT(false); return false; }
+    bool can_match(int64_t v, int64_t lbound, int64_t ubound) { static_cast<void>(lbound); static_cast<void>(ubound); static_cast<void>(v); return true; }
+    bool will_match(int64_t v, int64_t lbound, int64_t ubound) { static_cast<void>(lbound); static_cast<void>(ubound); static_cast<void>(v); return true; }
+};
+
+
+struct Less {
+    static const int avx = 0x11; // _CMP_LT_OQ
+    template<class T>
+    bool operator()(const T& v1, const T& v2, bool v1null = false, bool v2null = false) const {
+        if (v1null || v2null)
+            return false;
+
+        return v1 < v2;
+    }
+    template<class A, class B, class C, class D>
+    bool operator()(A, B, C, D) const { REALM_ASSERT(false); return false; }
+    static const int condition = cond_Less;
+    bool can_match(int64_t v, int64_t lbound, int64_t ubound) { static_cast<void>(ubound); return lbound < v; }
+    bool will_match(int64_t v, int64_t lbound, int64_t ubound) { static_cast<void>(lbound); return ubound < v; }
+};
+
+struct LessEqual : public HackClass {
+    static const int avx = 0x12;  // _CMP_LE_OQ
+    template<class T>
+    bool operator()(const T& v1, const T& v2, bool v1null = false, bool v2null = false) const {
+        if (v1null && v2null)
+            return true;
+
+        return (!v1null && !v2null && v1 <= v2);
+    }
+    template<class A, class B, class C, class D>
+    bool operator()(A, B, C, D) const { REALM_ASSERT(false); return false; }
+    static const int condition = -1;
+};
+
+struct GreaterEqual : public HackClass {
+    static const int avx = 0x1D;  // _CMP_GE_OQ
+    template<class T>
+    bool operator()(const T& v1, const T& v2, bool v1null = false, bool v2null = false) const {
+        if (v1null && v2null)
+            return true;
+
+        return (!v1null && !v2null && v1 >= v2);
+    }
+    template<class A, class B, class C, class D>
+    bool operator()(A, B, C, D) const { REALM_ASSERT(false); return false; }
+    static const int condition = -1;
+};
+
+
+// CompareLess is a temporary hack to have a generalized way to compare any realm types. Todo, enable correct <
+// operator of StringData (currently gives circular header dependency with utf8.hpp)
+template<class T>
+struct CompareLess
+{
+    static bool compare(T v1, T v2, bool = false, bool = false)
+    {
+        return v1 < v2;
+    }
+};
+template<>
+struct CompareLess<StringData>
+{
+    static bool compare(StringData v1, StringData v2, bool = false, bool = false)
+    {
+        bool ret = utf8_compare(v1.data(), v2.data());
+        return ret;
+    }
+};
+
+} // namespace realm
+
+#endif // REALM_QUERY_CONDITIONS_HPP
diff --git a/Pods/Realm/include/core/realm/query_engine.hpp b/Pods/Realm/include/core/realm/query_engine.hpp
new file mode 100644
index 0000000..8b093d4
--- /dev/null
+++ b/Pods/Realm/include/core/realm/query_engine.hpp
@@ -0,0 +1,1784 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+
+/*
+A query consists of node objects, one for each query condition. Each node contains pointers to all other nodes:
+
+node1        node2         node3
+------       -----         -----
+node2*       node1*        node1*
+node3*       node3*        node2*
+
+The construction of all this takes part in query.cpp. Each node has two important functions:
+
+    aggregate(start, end)
+    aggregate_local(start, end)
+
+The aggregate() function executes the aggregate of a query. You can call the method on any of the nodes
+(except children nodes of OrNode and SubtableNode) - it has the same behaviour. The function contains
+scheduling that calls aggregate_local(start, end) on different nodes with different start/end ranges,
+depending on what it finds is most optimal.
+
+The aggregate_local() function contains a tight loop that tests the condition of its own node, and upon match
+it tests all other conditions at that index to report a full match or not. It will remain in the tight loop
+after a full match.
+
+So a call stack with 2 and 9 being local matches of a node could look like this:
+
+aggregate(0, 10)
+    node1->aggregate_local(0, 3)
+        node2->find_first_local(2, 3)
+        node3->find_first_local(2, 3)
+    node3->aggregate_local(3, 10)
+        node1->find_first_local(4, 5)
+        node2->find_first_local(4, 5)
+        node1->find_first_local(7, 8)
+        node2->find_first_local(7, 8)
+
+find_first_local(n, n + 1) is a function that can be used to test a single row of another condition. Note that
+this is very simplified. There are other statistical arguments to the methods, and also, find_first_local() can be
+called from a callback function called by an integer Array.
+
+
+Template arguments in methods:
+----------------------------------------------------------------------------------------------------
+
+TConditionFunction: Each node has a condition from query_conditions.c such as Equal, GreaterEqual, etc
+
+TConditionValue:    Type of values in condition column. That is, int64_t, float, int, bool, etc
+
+TAction:            What to do with each search result, from the enums act_ReturnFirst, act_Count, act_Sum, etc
+
+TResult:            Type of result of actions - float, double, int64_t, etc. Special notes: For act_Count it's
+                    int64_t, for RLM_FIND_ALL it's int64_t which points at destination array.
+
+TSourceColumn:      Type of source column used in actions, or *ignored* if no source column is used (like for
+                    act_Count, act_ReturnFirst)
+
+
+There are two important classes used in queries:
+----------------------------------------------------------------------------------------------------
+SequentialGetter    Column iterator used to get successive values with leaf caching. Used both for condition columns
+                    and aggregate source column
+
+AggregateState      State of the aggregate - contains a state variable that stores intermediate sum, max, min,
+                    etc, etc.
+
+*/
+
+#ifndef REALM_QUERY_ENGINE_HPP
+#define REALM_QUERY_ENGINE_HPP
+
+#include <string>
+#include <functional>
+#include <algorithm>
+
+#include <realm/util/shared_ptr.hpp>
+#include <realm/util/meta.hpp>
+#include <realm/util/miscellaneous.hpp>
+#include <realm/unicode.hpp>
+#include <realm/utilities.hpp>
+#include <realm/table.hpp>
+#include <realm/table_view.hpp>
+#include <realm/column_fwd.hpp>
+#include <realm/column_string.hpp>
+#include <realm/column_string_enum.hpp>
+#include <realm/column_binary.hpp>
+#include <realm/column_timestamp.hpp>
+#include <realm/column_type_traits.hpp>
+#include <realm/query_conditions.hpp>
+#include <realm/array_basic.hpp>
+#include <realm/array_string.hpp>
+#include <realm/column_linklist.hpp>
+#include <realm/column_link.hpp>
+#include <realm/link_view.hpp>
+#include <realm/query_expression.hpp>
+#include <realm/column_type_traits.hpp>
+
+#include <map>
+
+#if defined(_MSC_FULL_VER) && _MSC_FULL_VER >= 160040219
+#  include <immintrin.h>
+#endif
+
+namespace realm {
+
+// Number of matches to find in best condition loop before breaking out to probe other conditions. Too low value gives too many
+// constant time overheads everywhere in the query engine. Too high value makes it adapt less rapidly to changes in match
+// frequencies.
+const size_t findlocals = 64;
+
+// Average match distance in linear searches where further increase in distance no longer increases query speed (because time
+// spent on handling each match becomes insignificant compared to time spent on the search).
+const size_t bestdist = 512;
+
+// Minimum number of matches required in a certain condition before it can be used to compute statistics. Too high value can spent
+// too much time in a bad node (with high match frequency). Too low value gives inaccurate statistics.
+const size_t probe_matches = 4;
+
+const size_t bitwidth_time_unit = 64;
+
+typedef bool (*CallbackDummy)(int64_t);
+
+
+class ParentNode {
+    typedef ParentNode ThisType;
+public:
+    ParentNode() = default;
+    virtual ~ParentNode() = default;
+
+    void gather_children(std::vector<ParentNode*>& v)
+    {
+        m_children.clear();
+        size_t i = v.size();
+        v.push_back(this);
+
+        if (m_child)
+            m_child->gather_children(v);
+
+        m_children = v;
+        m_children.erase(m_children.begin() + i);
+        m_children.insert(m_children.begin(), this);
+    }
+
+    struct score_compare {
+        bool operator ()(const ParentNode* a, const ParentNode* b) const { return a->cost() < b->cost(); }
+    };
+
+    double cost() const
+    {
+        return 8 * bitwidth_time_unit / m_dD + m_dT; // dt = 1/64 to 1. Match dist is 8 times more important than bitwidth
+    }
+
+    size_t find_first(size_t start, size_t end);
+
+    virtual void init(const Table& table)
+    {
+        m_table = &table;
+        if (m_child)
+            m_child->init(table);
+        m_column_action_specializer = nullptr;
+    }
+
+    virtual bool is_initialized() const
+    {
+        return m_table != nullptr;
+    }
+
+    virtual size_t find_first_local(size_t start, size_t end) = 0;
+
+    virtual void aggregate_local_prepare(Action TAction, DataType col_id, bool nullable);
+
+    template<Action TAction, class TSourceColumn>
+    bool column_action_specialization(QueryStateBase* st, SequentialGetterBase* source_column, size_t r)
+    {
+        // TResult: type of query result
+        // TSourceValue: type of aggregate source
+        using TSourceValue = typename TSourceColumn::value_type;
+        using TResult = typename ColumnTypeTraitsSum<TSourceValue, TAction>::sum_type;
+
+        // Sum of float column must accumulate in double
+        static_assert( !(TAction == act_Sum && (std::is_same<TSourceColumn, float>::value &&
+                                                !std::is_same<TResult, double>::value)), "");
+
+        TSourceValue av{};
+        // uses_val test because compiler cannot see that IntegerColumn::get has no side effect and result is discarded
+        if (static_cast<QueryState<TResult>*>(st)->template uses_val<TAction>() && source_column != nullptr) {
+            REALM_ASSERT_DEBUG(dynamic_cast<SequentialGetter<TSourceColumn>*>(source_column) != nullptr);
+            av = static_cast<SequentialGetter<TSourceColumn>*>(source_column)->get_next(r);
+        }
+        REALM_ASSERT_DEBUG(dynamic_cast<QueryState<TResult>*>(st) != nullptr);
+        bool cont = static_cast<QueryState<TResult>*>(st)->template match<TAction, 0>(r, 0, av);
+        return cont;
+    }
+
+    virtual size_t aggregate_local(QueryStateBase* st, size_t start, size_t end, size_t local_limit,
+                                   SequentialGetterBase* source_column);
+
+
+    virtual std::string validate()
+    {
+        if (error_code != "")
+            return error_code;
+        if (m_child == nullptr)
+            return "";
+        else
+            return m_child->validate();
+    }
+
+    ParentNode(const ParentNode& from, QueryNodeHandoverPatches* patches) :
+        m_child(from.m_child ? from.m_child->clone(patches) : nullptr),
+        m_condition_column_idx(from.m_condition_column_idx), m_dD(from.m_dD), m_dT(from.m_dT),
+        m_probes(from.m_probes), m_matches(from.m_matches)
+    {
+    }
+
+    void add_child(std::unique_ptr<ParentNode> child)
+    {
+        if (m_child)
+            m_child->add_child(std::move(child));
+        else
+            m_child = std::move(child);
+    }
+
+    virtual std::unique_ptr<ParentNode> clone(QueryNodeHandoverPatches* = nullptr) const = 0;
+
+    virtual void apply_handover_patch(QueryNodeHandoverPatches& patches, Group& group)
+    {
+        if (m_child)
+            m_child->apply_handover_patch(patches, group);
+    }
+
+    std::unique_ptr<ParentNode> m_child;
+    std::vector<ParentNode*> m_children;
+    size_t m_condition_column_idx = npos; // Column of search criteria
+
+    double m_dD; // Average row distance between each local match at current position
+    double m_dT; // Time overhead of testing index i + 1 if we have just tested index i. > 1 for linear scans, 0 for index/tableview
+
+    size_t m_probes = 0;
+    size_t m_matches = 0;
+protected:
+    typedef bool (ParentNode::* Column_action_specialized)(QueryStateBase*, SequentialGetterBase*, size_t);
+    Column_action_specialized m_column_action_specializer;
+    const Table* m_table;
+    std::string error_code;
+
+    const ColumnBase& get_column_base(const Table& table, size_t ndx)
+    {
+        return table.get_column_base(ndx);
+    }
+
+    ColumnType get_real_column_type(const Table& table, size_t ndx)
+    {
+        return table.get_real_column_type(ndx);
+    }
+};
+
+// Used for performing queries on a Tableview. This is done by simply passing the TableView to this query condition
+class ListviewNode: public ParentNode {
+public:
+    ListviewNode(TableView& tv) : m_size(tv.size()), m_tv(tv) { m_dT = 0.0; }
+
+    // Return the n'th table row index contained in the TableView.
+    size_t tableindex(size_t n)
+    {
+        return to_size_t(m_tv.m_row_indexes.get(n));
+    }
+
+    void init(const Table& table) override
+    {
+        m_table = &table;
+
+        m_dD = m_table->size() / (m_tv.size() + 1.0);
+
+        m_next = 0;
+        if (m_size > 0)
+            m_max = tableindex(m_size - 1);
+        if (m_child) m_child->init(table);
+    }
+
+    size_t find_first_local(size_t start, size_t end) override
+    {
+        // Simply return index of first table row which is >= start
+        size_t r;
+        r = m_tv.m_row_indexes.find_gte(start, m_next);
+
+        if (r >= end)
+            return not_found;
+
+        m_next = r;
+        return tableindex(r);
+    }
+
+    std::unique_ptr<ParentNode> clone(QueryNodeHandoverPatches* patches) const override
+    {
+        return std::unique_ptr<ParentNode>(new ListviewNode(*this, patches));
+    }
+
+    ListviewNode(const ListviewNode& from, QueryNodeHandoverPatches* patches)
+        : ParentNode(from, patches), m_max(from.m_max), m_next(from.m_next), m_size(from.m_size), m_tv(from.m_tv)
+    {
+    }
+
+protected:
+    size_t m_max = 0;
+    size_t m_next = 0;
+    size_t m_size;
+
+    TableView& m_tv;
+};
+
+// For conditions on a subtable (encapsulated in subtable()...end_subtable()). These return the parent row as match if and
+// only if one or more subtable rows match the condition.
+class SubtableNode: public ParentNode {
+public:
+    SubtableNode(size_t column, std::unique_ptr<ParentNode> condition) :
+        m_condition(std::move(condition)), m_column(column)
+    {
+        m_dT = 100.0;
+    }
+
+    void init(const Table& table) override
+    {
+        m_dD = 10.0;
+        m_table = &table;
+
+        // m_condition is first node in condition of subtable query.
+        if (m_condition) {
+            // Can't call init() here as usual since the subtable can be degenerate
+            // m_condition->init(table);
+            std::vector<ParentNode*> v;
+            m_condition->gather_children(v);
+        }
+
+        // m_child is next node of parent query
+        if (m_child)
+            m_child->init(table);
+    }
+
+    std::string validate() override
+    {
+        if (error_code != "")
+            return error_code;
+        if (m_condition == nullptr)
+            return "Unbalanced subtable/end_subtable block";
+        else
+            return m_condition->validate();
+    }
+
+    size_t find_first_local(size_t start, size_t end) override
+    {
+        REALM_ASSERT(m_table);
+        REALM_ASSERT(m_condition);
+
+        for (size_t s = start; s < end; ++s) {
+            ConstTableRef subtable = m_table->get_subtable(m_column, s);
+
+            if (subtable->is_degenerate())
+                return not_found;
+
+            m_condition->init(*subtable);
+            const size_t subsize = subtable->size();
+            const size_t sub = m_condition->find_first(0, subsize);
+
+            if (sub != not_found)
+                return s;
+        }
+        return not_found;
+    }
+
+    std::unique_ptr<ParentNode> clone(QueryNodeHandoverPatches* patches) const override
+    {
+        return std::unique_ptr<ParentNode>(new SubtableNode(*this, patches));
+    }
+
+    SubtableNode(const SubtableNode& from, QueryNodeHandoverPatches* patches) : ParentNode(from, patches),
+        m_condition(from.m_condition ? from.m_condition->clone(patches) : nullptr), m_column(from.m_column)
+    {
+    }
+
+    void apply_handover_patch(QueryNodeHandoverPatches& patches, Group& group) override
+    {
+        m_condition->apply_handover_patch(patches, group);
+        ParentNode::apply_handover_patch(patches, group);
+    }
+
+    std::unique_ptr<ParentNode> m_condition;
+    size_t m_column = npos;
+};
+
+namespace _impl {
+
+template<class ColType>
+struct CostHeuristic;
+
+template<>
+struct CostHeuristic<IntegerColumn>
+{
+    static const double dD;
+    static const double dT;
+};
+
+template<>
+struct CostHeuristic<IntNullColumn>
+{
+    static const double dD;
+    static const double dT;
+};
+
+// FIXME: Add AdaptiveStringColumn, BasicColumn, etc.
+
+}
+
+class ColumnNodeBase : public ParentNode
+{
+protected:
+    ColumnNodeBase(size_t column_idx)
+    {
+        m_condition_column_idx = column_idx;
+    }
+
+    ColumnNodeBase(const ColumnNodeBase& from, QueryNodeHandoverPatches* patches) : ParentNode(from, patches),
+        m_last_local_match(from.m_last_local_match), m_local_matches(from.m_local_matches),
+        m_local_limit(from.m_local_limit), m_fastmode_disabled(from.m_fastmode_disabled), m_action(from.m_action),
+        m_state(from.m_state), m_source_column(from.m_source_column)
+    {
+    }
+
+    template<Action TAction, class ColType>
+    bool match_callback(int64_t v)
+    {
+        using TSourceValue = typename ColType::value_type;
+        using QueryStateType = typename ColumnTypeTraitsSum<TSourceValue, TAction>::sum_type;
+
+        size_t i = to_size_t(v);
+        m_last_local_match = i;
+        m_local_matches++;
+
+        auto state = static_cast<QueryState<QueryStateType>*>(m_state);
+        auto source_column = static_cast<SequentialGetter<ColType>*>(m_source_column);
+
+        // Test remaining sub conditions of this node. m_children[0] is the node that called match_callback(), so skip it
+        for (size_t c = 1; c < m_children.size(); c++) {
+            m_children[c]->m_probes++;
+            size_t m = m_children[c]->find_first_local(i, i + 1);
+            if (m != i)
+                return true;
+        }
+
+        bool b;
+        if (state->template uses_val<TAction>())    { // Compiler cannot see that IntegerColumn::Get has no side effect and result is discarded
+            TSourceValue av = source_column->get_next(i);
+            b = state->template match<TAction, false>(i, 0, av);
+        }
+        else {
+            b = state->template match<TAction, false>(i, 0, TSourceValue{});
+        }
+
+        return b;
+    }
+
+    // Aggregate bookkeeping
+    size_t m_last_local_match = npos;
+    size_t m_local_matches = 0;
+    size_t m_local_limit = 0;
+    bool m_fastmode_disabled = false;
+    Action m_action;
+    QueryStateBase* m_state = nullptr;
+    SequentialGetterBase* m_source_column = nullptr; // Column of values used in aggregate (act_FindAll, actReturnFirst, act_Sum, etc)
+};
+
+template<class ColType>
+class IntegerNodeBase : public ColumnNodeBase
+{
+    using ThisType = IntegerNodeBase<ColType>;
+public:
+    using TConditionValue = typename ColType::value_type;
+    static const bool nullable = ColType::nullable;
+
+    template<class TConditionFunction, Action TAction, DataType TDataType, bool Nullable>
+    bool find_callback_specialization(size_t s, size_t end_in_leaf)
+    {
+        using AggregateColumnType = typename GetColumnType<TDataType, Nullable>::type;
+        bool cont;
+        size_t start_in_leaf = s - this->m_leaf_start;
+        cont = this->m_leaf_ptr->template find<TConditionFunction, act_CallbackIdx>
+                (m_value, start_in_leaf, end_in_leaf, this->m_leaf_start, nullptr,
+                 std::bind1st(std::mem_fun(&ThisType::template match_callback<TAction, AggregateColumnType>), this));
+        return cont;
+    }
+
+protected:
+    using LeafType = typename ColType::LeafType;
+    using LeafInfo = typename ColType::LeafInfo;
+
+    size_t aggregate_local_impl(QueryStateBase* st, size_t start, size_t end, size_t local_limit,
+                           SequentialGetterBase* source_column, int c)
+    {
+        REALM_ASSERT(m_children.size() > 0);
+        m_local_matches = 0;
+        m_local_limit = local_limit;
+        m_last_local_match = start - 1;
+        m_state = st;
+
+        // If there are no other nodes than us (m_children.size() == 1) AND the column used for our condition is
+        // the same as the column used for the aggregate action, then the entire query can run within scope of that
+        // column only, with no references to other columns:
+        bool fastmode = should_run_in_fastmode(source_column);
+        for (size_t s = start; s < end; ) {
+            cache_leaf(s);
+
+            size_t end_in_leaf;
+            if (end > m_leaf_end)
+                end_in_leaf = m_leaf_end - m_leaf_start;
+            else
+                end_in_leaf = end - m_leaf_start;
+
+            if (fastmode) {
+                bool cont;
+                size_t start_in_leaf = s - m_leaf_start;
+                cont = m_leaf_ptr->find(c, m_action, m_value, start_in_leaf, end_in_leaf, m_leaf_start, static_cast<QueryState<int64_t>*>(st));
+                if (!cont)
+                    return not_found;
+            }
+            // Else, for each match in this node, call our IntegerNodeBase::match_callback to test remaining nodes and/or extract
+            // aggregate payload from aggregate column:
+            else {
+                m_source_column = source_column;
+                bool cont = (this->*m_find_callback_specialized)(s, end_in_leaf);
+                if (!cont)
+                    return not_found;
+            }
+
+            if (m_local_matches == m_local_limit)
+                break;
+
+            s = end_in_leaf + m_leaf_start;
+        }
+
+        if (m_local_matches == m_local_limit) {
+            m_dD = (m_last_local_match + 1 - start) / (m_local_matches + 1.0);
+            return m_last_local_match + 1;
+        }
+        else {
+            m_dD = (end - start) / (m_local_matches + 1.0);
+            return end;
+        }
+    }
+
+    IntegerNodeBase(TConditionValue value, size_t column_idx) : ColumnNodeBase(column_idx),
+        m_value(std::move(value))
+    {
+        m_dT = _impl::CostHeuristic<ColType>::dT;
+        m_dD = _impl::CostHeuristic<ColType>::dD;
+    }
+
+    IntegerNodeBase(const ThisType& from, QueryNodeHandoverPatches* patches) : ColumnNodeBase(from, patches),
+        m_value(from.m_value), m_condition_column(from.m_condition_column),
+        m_find_callback_specialized(from.m_find_callback_specialized)
+    {
+        // state is transient/only valid during search, no need to copy
+        m_dT = _impl::CostHeuristic<ColType>::dT;
+        m_dD = _impl::CostHeuristic<ColType>::dD;
+    }
+
+    void init(const Table& table) override
+    {
+        ColumnNodeBase::init(table);
+
+        m_dD = _impl::CostHeuristic<ColType>::dD;
+
+        const ColumnBase* col = &get_column_base(table, m_condition_column_idx);
+        REALM_ASSERT_DEBUG(dynamic_cast<const ColType*>(col) != nullptr);
+        m_condition_column = static_cast<const ColType*>(col);
+        m_table = &table;
+
+        // Clear leaf cache
+        m_leaf_end = 0;
+        m_array_ptr.reset(); // Explicitly destroy the old one first, because we're reusing the memory.
+        m_array_ptr.reset(new(&m_leaf_cache_storage) LeafType(table.get_alloc()));
+
+        if (m_child) {
+            m_child->init(table);
+        }
+    }
+
+    void get_leaf(const ColType& col, size_t ndx)
+    {
+        size_t ndx_in_leaf;
+        LeafInfo leaf_info{&m_leaf_ptr, m_array_ptr.get()};
+        col.get_leaf(ndx, ndx_in_leaf, leaf_info);
+        m_leaf_start = ndx - ndx_in_leaf;
+        m_leaf_end = m_leaf_start + m_leaf_ptr->size();
+    }
+
+    void cache_leaf(size_t s)
+    {
+        if (s >= m_leaf_end || s < m_leaf_start) {
+            get_leaf(*m_condition_column, s);
+            size_t w = m_leaf_ptr->get_width();
+            m_dT = (w == 0 ? 1.0 / REALM_MAX_BPNODE_SIZE : w / float(bitwidth_time_unit));
+        }
+    }
+
+    bool should_run_in_fastmode(SequentialGetterBase* source_column) const
+    {
+        return (m_children.size() == 1 &&
+                (source_column == nullptr ||
+                 (!m_fastmode_disabled
+                  && static_cast<SequentialGetter<ColType>*>(source_column)->m_column == m_condition_column)));
+    }
+
+    // Search value:
+    TConditionValue m_value;
+
+    // Column on which search criteria are applied
+    const ColType* m_condition_column = nullptr;
+
+    // Leaf cache
+    using LeafCacheStorage = typename std::aligned_storage<sizeof(LeafType), alignof(LeafType)>::type;
+    LeafCacheStorage m_leaf_cache_storage;
+    std::unique_ptr<LeafType, PlacementDelete> m_array_ptr;
+    const LeafType* m_leaf_ptr = nullptr;
+    size_t m_leaf_start = npos;
+    size_t m_leaf_end = 0;
+    size_t m_local_end;
+
+    // Aggregate optimization
+    using TFind_callback_specialized = bool(ThisType::*)(size_t, size_t);
+    TFind_callback_specialized m_find_callback_specialized = nullptr;
+};
+
+// FIXME: Add specialization that uses index for TConditionFunction = Equal
+template<class ColType, class TConditionFunction>
+class IntegerNode : public IntegerNodeBase<ColType> {
+    using BaseType = IntegerNodeBase<ColType>;
+    using ThisType = IntegerNode<ColType, TConditionFunction>;
+public:
+    static const bool special_null_node = false;
+    using TConditionValue = typename BaseType::TConditionValue;
+
+    IntegerNode(TConditionValue value, size_t column_ndx) : IntegerNodeBase<ColType>(value, column_ndx)
+    {
+    }
+
+    void aggregate_local_prepare(Action action, DataType col_id, bool nullable) override
+    {
+        this->m_fastmode_disabled = (col_id == type_Float || col_id == type_Double);
+        this->m_action = action;
+        this->m_find_callback_specialized = get_specialized_callback(action, col_id, nullable);
+    }
+
+    size_t aggregate_local(QueryStateBase* st, size_t start, size_t end, size_t local_limit,
+                           SequentialGetterBase* source_column) override
+    {
+        constexpr int cond = TConditionFunction::condition;
+        return this->aggregate_local_impl(st, start, end, local_limit, source_column, cond);
+    }
+
+
+    size_t find_first_local(size_t start, size_t end) override
+    {
+        REALM_ASSERT(this->m_table);
+
+        while (start < end) {
+
+            // Cache internal leaves
+            if (start >= this->m_leaf_end || start < this->m_leaf_start) {
+                this->get_leaf(*this->m_condition_column, start);
+            }
+
+            // FIXME: Create a fast bypass when you just need to check 1 row, which is used alot from within core.
+            // It should just call array::get and save the initial overhead of find_first() which has become quite
+            // big. Do this when we have cleaned up core a bit more.
+
+            size_t end2;
+            if (end > this->m_leaf_end)
+                end2 = this->m_leaf_end - this->m_leaf_start;
+            else
+                end2 = end - this->m_leaf_start;
+
+            size_t s;
+            s = this->m_leaf_ptr->template find_first<TConditionFunction>(this->m_value, start - this->m_leaf_start, end2);
+
+            if (s == not_found) {
+                start = this->m_leaf_end;
+                continue;
+            }
+            else
+                return s + this->m_leaf_start;
+        }
+
+        return not_found;
+    }
+
+    std::unique_ptr<ParentNode> clone(QueryNodeHandoverPatches* patches) const override
+    {
+        return std::unique_ptr<ParentNode>(new IntegerNode<ColType, TConditionFunction>(*this, patches));
+    }
+
+    IntegerNode(const IntegerNode& from, QueryNodeHandoverPatches* patches) : BaseType(from, patches)
+    {
+    }
+
+protected:
+    using TFind_callback_specialized = typename BaseType::TFind_callback_specialized;
+
+    static TFind_callback_specialized get_specialized_callback(Action action, DataType col_id, bool nullable)
+    {
+        switch (action) {
+            case act_Count: return get_specialized_callback_2_int<act_Count>(col_id, nullable);
+            case act_Sum: return get_specialized_callback_2<act_Sum>(col_id, nullable);
+            case act_Max: return get_specialized_callback_2<act_Max>(col_id, nullable);
+            case act_Min: return get_specialized_callback_2<act_Min>(col_id, nullable);
+            case act_FindAll: return get_specialized_callback_2_int<act_FindAll>(col_id, nullable);
+            case act_CallbackIdx: return get_specialized_callback_2_int<act_CallbackIdx>(col_id, nullable);
+            default: break;
+        }
+        REALM_ASSERT(false); // Invalid aggregate function
+        return nullptr;
+    }
+
+    template<Action TAction>
+    static TFind_callback_specialized get_specialized_callback_2(DataType col_id, bool nullable)
+    {
+        switch (col_id) {
+            case type_Int: return get_specialized_callback_3<TAction, type_Int>(nullable);
+            case type_Float: return get_specialized_callback_3<TAction, type_Float>(nullable);
+            case type_Double: return get_specialized_callback_3<TAction, type_Double>(nullable);
+            default: break;
+        }
+        REALM_ASSERT(false); // Invalid aggregate source column
+        return nullptr;
+    }
+
+    template<Action TAction>
+    static TFind_callback_specialized get_specialized_callback_2_int(DataType col_id, bool nullable)
+    {
+        if (col_id == type_Int) {
+            return get_specialized_callback_3<TAction, type_Int>(nullable);
+        }
+        REALM_ASSERT(false); // Invalid aggregate source column
+        return nullptr;
+    }
+
+    template<Action TAction, DataType TDataType>
+    static TFind_callback_specialized get_specialized_callback_3(bool nullable)
+    {
+        if (nullable) {
+            return &BaseType::template find_callback_specialization<TConditionFunction, TAction, TDataType, true>;
+        } else {
+            return &BaseType::template find_callback_specialization<TConditionFunction, TAction, TDataType, false>;
+        }
+    }
+};
+
+
+// This node is currently used for floats and doubles only
+template<class ColType, class TConditionFunction>
+class FloatDoubleNode: public ParentNode {
+public:
+    using TConditionValue = typename ColType::value_type;
+    static const bool special_null_node = false;
+
+    FloatDoubleNode(TConditionValue v, size_t column_ndx) : m_value(v)
+    {
+        m_condition_column_idx = column_ndx;
+        m_dT = 1.0;
+    }
+    FloatDoubleNode(null, size_t column_ndx) : m_value(null::get_null_float<TConditionValue>())
+    {
+        m_condition_column_idx = column_ndx;
+        m_dT = 1.0;
+    }
+
+    void init(const Table& table) override
+    {
+        m_dD = 100.0;
+        m_table = &table;
+        m_condition_column.init(static_cast<const ColType*>(&get_column_base(table, m_condition_column_idx)));
+
+        if (m_child)
+            m_child->init(table);
+    }
+
+    size_t find_first_local(size_t start, size_t end) override
+    {
+        TConditionFunction cond;
+
+        auto find = [&](bool nullability)   {
+            bool m_value_nan = nullability ? null::is_null_float(m_value) : false;
+            for (size_t s = start; s < end; ++s) {
+                TConditionValue v = m_condition_column.get_next(s);
+                REALM_ASSERT(!(null::is_null_float(v) && !nullability));
+                if (cond(v, m_value, nullability ? null::is_null_float<TConditionValue>(v) : false, m_value_nan))
+                    return s;
+            }
+            return not_found;
+        };
+
+        // This will inline the second case but no the first. Todo, use templated lambda when switching to c++14
+        if (m_table->is_nullable(m_condition_column_idx))
+            return find(true);
+        else
+            return find(false);
+    }
+
+    std::unique_ptr<ParentNode> clone(QueryNodeHandoverPatches* patches) const override
+    {
+        return std::unique_ptr<ParentNode>(new FloatDoubleNode(*this, patches));
+    }
+
+    FloatDoubleNode(const FloatDoubleNode& from, QueryNodeHandoverPatches* patches) : ParentNode(from, patches),
+        m_value(from.m_value)
+    {
+        // m_condition_column is not copied
+    }
+
+protected:
+    TConditionValue m_value;
+    SequentialGetter<ColType> m_condition_column;
+};
+
+
+template<class TConditionFunction>
+class BinaryNode: public ParentNode {
+public:
+    using TConditionValue = BinaryData;
+    static const bool special_null_node = false;
+
+    template<Action TAction>
+    int64_t find_all(IntegerColumn* /*res*/, size_t /*start*/, size_t /*end*/, size_t /*limit*/, size_t /*source_column*/) {REALM_ASSERT(false); return 0;}
+
+    BinaryNode(BinaryData v, size_t column) : m_value(v)
+    {
+        m_dT = 100.0;
+        m_condition_column_idx = column;
+    }
+
+    BinaryNode(null, size_t column) : BinaryNode(BinaryData{}, column)
+    {
+    }
+
+    void init(const Table& table) override
+    {
+        m_dD = 100.0;
+        m_table = &table;
+        m_condition_column = static_cast<const BinaryColumn*>(&get_column_base(table, m_condition_column_idx));
+        m_column_type = get_real_column_type(table, m_condition_column_idx);
+
+        if (m_child)
+            m_child->init(table);
+    }
+
+    size_t find_first_local(size_t start, size_t end) override
+    {
+        TConditionFunction condition;
+        for (size_t s = start; s < end; ++s) {
+            BinaryData value = m_condition_column->get(s);
+            if (condition(m_value.get(), value))
+                return s;
+        }
+        return not_found;
+    }
+
+    std::unique_ptr<ParentNode> clone(QueryNodeHandoverPatches* patches) const override
+    {
+        return std::unique_ptr<ParentNode>(new BinaryNode(*this, patches));
+    }
+
+    BinaryNode(const BinaryNode& from, QueryNodeHandoverPatches* patches) : ParentNode(from, patches),
+        m_value(from.m_value), m_condition_column(from.m_condition_column), m_column_type(from.m_column_type)
+    {
+    }
+
+private:
+    OwnedBinaryData m_value;
+    const BinaryColumn* m_condition_column;
+    ColumnType m_column_type;
+};
+
+
+template<class TConditionFunction>
+class TimestampNode : public ParentNode {
+public:
+    using TConditionValue = Timestamp;
+    static const bool special_null_node = false;
+
+    template<Action TAction>
+    int64_t find_all(IntegerColumn* /*res*/, size_t /*start*/, size_t /*end*/, size_t /*limit*/, size_t /*source_column*/) { REALM_ASSERT(false); return 0; }
+
+    TimestampNode(Timestamp v, size_t column) : m_value(v)
+    {
+        m_dT = 100.0;
+        m_condition_column_idx = column;
+    }
+
+    TimestampNode(null, size_t column) : TimestampNode(Timestamp(null{}), column)
+    {
+    }
+
+    void init(const Table& table) override
+    {
+        m_dD = 100.0;
+        m_table = &table;
+        m_condition_column = static_cast<const TimestampColumn*>(&get_column_base(table, m_condition_column_idx));
+        REALM_ASSERT(dynamic_cast<const TimestampColumn*>(&get_column_base(table, m_condition_column_idx)));
+        m_column_type = get_real_column_type(table, m_condition_column_idx);
+        REALM_ASSERT_3(m_column_type, == , col_type_Timestamp);
+
+        if (m_child)
+            m_child->init(table);
+    }
+
+    size_t find_first_local(size_t start, size_t end) override
+    {
+        size_t ret = m_condition_column->find<TConditionFunction>(m_value, start, end);
+        return ret;
+    }
+
+    std::unique_ptr<ParentNode> clone(QueryNodeHandoverPatches* patches) const override
+    {
+        return std::unique_ptr<ParentNode>(new TimestampNode(*this, patches));
+    }
+
+    TimestampNode(const TimestampNode& from, QueryNodeHandoverPatches* patches) : ParentNode(from, patches),
+        m_value(from.m_value), m_condition_column(from.m_condition_column), m_column_type(from.m_column_type)
+    {
+    }
+
+private:
+    Timestamp m_value;
+    const TimestampColumn* m_condition_column;
+    ColumnType m_column_type;
+};
+
+class StringNodeBase : public ParentNode {
+public:
+    using TConditionValue = StringData;
+    static const bool special_null_node = true;
+
+    template<Action TAction>
+    int64_t find_all(IntegerColumn*, size_t, size_t, size_t, size_t)
+    {
+        REALM_ASSERT(false);
+        return 0;
+    }
+
+    StringNodeBase(StringData v, size_t column) :
+        m_value(v.is_null() ? util::none : util::make_optional(std::string(v)))
+    {
+        m_condition_column_idx = column;
+        m_dT = 10.0;
+    }
+
+    void init(const Table& table) override
+    {
+        m_probes = 0;
+        m_matches = 0;
+        m_end_s = 0;
+        m_leaf_start = 0;
+        m_leaf_end = 0;
+        m_table = &table;
+        m_condition_column = &get_column_base(table, m_condition_column_idx);
+        m_column_type = get_real_column_type(table, m_condition_column_idx);
+    }
+
+    void clear_leaf_state()
+    {
+        m_leaf.reset(nullptr);
+    }
+
+    StringNodeBase(const StringNodeBase& from, QueryNodeHandoverPatches* patches) : ParentNode(from, patches),
+        m_value(from.m_value), m_condition_column(from.m_condition_column), m_column_type(from.m_column_type),
+        m_leaf_type(from.m_leaf_type), m_end_s(0), m_leaf_start(0), m_leaf_end(0)
+    {
+    }
+
+protected:
+    util::Optional<std::string> m_value;
+
+    const ColumnBase* m_condition_column;
+    ColumnType m_column_type;
+
+    // Used for linear scan through short/long-string
+    std::unique_ptr<const ArrayParent> m_leaf;
+    StringColumn::LeafType m_leaf_type;
+    size_t m_end_s;
+    size_t m_leaf_start;
+    size_t m_leaf_end;
+
+};
+
+// Conditions for strings. Note that Equal is specialized later in this file!
+template<class TConditionFunction>
+class StringNode: public StringNodeBase {
+public:
+    StringNode(StringData v, size_t column) : StringNodeBase(v, column)
+    {
+        auto upper = case_map(v, true);
+        auto lower = case_map(v, false);
+        if (!upper || !lower) {
+            error_code = "Malformed UTF-8: " + std::string(v);
+        }
+        else {
+            m_ucase = std::move(*upper);
+            m_lcase = std::move(*lower);
+        }
+    }
+
+    void init(const Table& table) override
+    {
+        clear_leaf_state();
+
+        m_dD = 100.0;
+
+        StringNodeBase::init(table);
+
+        if (m_child)
+            m_child->init(table);
+    }
+
+
+    size_t find_first_local(size_t start, size_t end) override
+    {
+        TConditionFunction cond;
+
+        for (size_t s = start; s < end; ++s) {
+            StringData t;
+
+            if (m_column_type == col_type_StringEnum) {
+                // enum
+                t = static_cast<const StringEnumColumn*>(m_condition_column)->get(s);
+            }
+            else {
+                // short or long
+                const StringColumn* asc = static_cast<const StringColumn*>(m_condition_column);
+                REALM_ASSERT_3(s, <, asc->size());
+                if (s >= m_end_s || s < m_leaf_start) {
+                    // we exceeded current leaf's range
+                    clear_leaf_state();
+                    size_t ndx_in_leaf;
+                    m_leaf = asc->get_leaf(s, ndx_in_leaf, m_leaf_type);
+                    m_leaf_start = s - ndx_in_leaf;
+
+                    if (m_leaf_type == StringColumn::leaf_type_Small)
+                        m_end_s = m_leaf_start + static_cast<const ArrayString&>(*m_leaf).size();
+                    else if (m_leaf_type ==  StringColumn::leaf_type_Medium)
+                        m_end_s = m_leaf_start + static_cast<const ArrayStringLong&>(*m_leaf).size();
+                    else
+                        m_end_s = m_leaf_start + static_cast<const ArrayBigBlobs&>(*m_leaf).size();
+                }
+
+                if (m_leaf_type == StringColumn::leaf_type_Small)
+                    t = static_cast<const ArrayString&>(*m_leaf).get(s - m_leaf_start);
+                else if (m_leaf_type ==  StringColumn::leaf_type_Medium)
+                    t = static_cast<const ArrayStringLong&>(*m_leaf).get(s - m_leaf_start);
+                else
+                    t = static_cast<const ArrayBigBlobs&>(*m_leaf).get_string(s - m_leaf_start);
+            }
+            if (cond(StringData(m_value), m_ucase.data(), m_lcase.data(), t))
+                return s;
+        }
+        return not_found;
+    }
+
+    std::unique_ptr<ParentNode> clone(QueryNodeHandoverPatches* patches) const override
+    {
+        return std::unique_ptr<ParentNode>(new StringNode<TConditionFunction>(*this, patches));
+    }
+
+    StringNode(const StringNode& from, QueryNodeHandoverPatches* patches) : StringNodeBase(from, patches),
+        m_ucase(from.m_ucase), m_lcase(from.m_lcase)
+    {
+    }
+
+protected:
+    std::string m_ucase;
+    std::string m_lcase;
+};
+
+
+
+// Specialization for Equal condition on Strings - we specialize because we can utilize indexes (if they exist) for Equal.
+// Future optimization: make specialization for greater, notequal, etc
+template<>
+class StringNode<Equal>: public StringNodeBase {
+public:
+    StringNode(StringData v, size_t column): StringNodeBase(v,column)
+    {
+    }
+    ~StringNode() noexcept override
+    {
+        deallocate();
+    }
+
+    void deallocate() noexcept
+    {
+        // Must be called after each query execution too free temporary resources used by the execution. Run in
+        // destructor, but also in Init because a user could define a query once and execute it multiple times.
+        clear_leaf_state();
+
+        if (m_index_matches_destroy)
+            m_index_matches->destroy();
+
+        m_index_matches_destroy = false;
+        m_index_matches.reset();
+        m_index_getter.reset();
+    }
+
+    void init(const Table& table) override
+    {
+        deallocate();
+        m_dD = 10.0;
+        StringNodeBase::init(table);
+
+        if (m_column_type == col_type_StringEnum) {
+            m_dT = 1.0;
+            m_key_ndx = static_cast<const StringEnumColumn*>(m_condition_column)->get_key_ndx(m_value);
+        }
+        else if (m_condition_column->has_search_index()) {
+            m_dT = 0.0;
+        }
+        else {
+            m_dT = 10.0;
+        }
+
+        if (m_condition_column->has_search_index()) {
+
+            FindRes fr;
+            size_t index_ref;
+
+            if (m_column_type == col_type_StringEnum) {
+                fr = static_cast<const StringEnumColumn*>(m_condition_column)->find_all_indexref(m_value, index_ref);
+            }
+            else {
+                fr = static_cast<const StringColumn*>(m_condition_column)->find_all_indexref(m_value, index_ref);
+            }
+
+            m_index_matches_destroy = false;
+            m_last_indexed = 0;
+            m_last_start = 0;
+
+            switch (fr) {
+                case FindRes_single:
+                    m_index_matches.reset(new IntegerColumn(IntegerColumn::unattached_root_tag(), Allocator::get_default())); // Throws
+                    m_index_matches->get_root_array()->create(Array::type_Normal); // Throws
+                    m_index_matches->add(index_ref);
+                    m_index_matches_destroy = true;        // we own m_index_matches, so we must destroy it
+                    break;
+
+                case FindRes_column:
+                    // todo: Apparently we can't use m_index.get_alloc() because it uses default allocator which simply makes
+                    // translate(x) = x. Shouldn't it inherit owner column's allocator?!
+                    m_index_matches.reset(new IntegerColumn(IntegerColumn::unattached_root_tag(), m_condition_column->get_alloc())); // Throws
+                    m_index_matches->get_root_array()->init_from_ref(index_ref);
+                    break;
+
+                case FindRes_not_found:
+                    m_index_matches.reset();
+                    m_index_getter.reset();
+                    m_index_size = 0;
+                    break;
+            }
+
+            if (m_index_matches) {
+                m_index_getter.reset(new SequentialGetter<IntegerColumn>(m_index_matches.get()));
+                m_index_size = m_index_getter->m_column->size();
+            }
+
+        }
+        else if (m_column_type != col_type_String) {
+            REALM_ASSERT_DEBUG(dynamic_cast<const StringEnumColumn*>(m_condition_column));
+            m_cse.init(static_cast<const StringEnumColumn*>(m_condition_column));
+        }
+
+        if (m_child)
+            m_child->init(table);
+    }
+
+    size_t find_first_local(size_t start, size_t end) override
+    {
+        REALM_ASSERT(m_table);
+
+        if (m_condition_column->has_search_index()) {
+            // Indexed string column
+            if (!m_index_getter)
+                return not_found; // no matches in the index
+
+            size_t f = not_found;
+
+            if (m_last_start > start)
+                m_last_indexed = 0;
+            m_last_start = start;
+
+            while (f == not_found && m_last_indexed < m_index_size) {
+                m_index_getter->cache_next(m_last_indexed);
+                f = m_index_getter->m_leaf_ptr->find_gte(start, m_last_indexed - m_index_getter->m_leaf_start, nullptr);
+
+                if (f >= end || f == not_found) {
+                    m_last_indexed = m_index_getter->m_leaf_end;
+                }
+                else {
+                    start = to_size_t(m_index_getter->m_leaf_ptr->get(f));
+                    if (start >= end)
+                        return not_found;
+                    else {
+                        m_last_indexed = f + m_index_getter->m_leaf_start;
+                        return start;
+                    }
+                }
+            }
+            return not_found;
+        }
+
+        if (m_column_type != col_type_String) {
+            // Enum string column
+            if (m_key_ndx == not_found)
+                return not_found;  // not in key set
+
+            for (size_t s = start; s < end; ++s) {
+                m_cse.cache_next(s);
+                s = m_cse.m_leaf_ptr->find_first(m_key_ndx, s - m_cse.m_leaf_start, m_cse.local_end(end));
+                if (s == not_found)
+                    s = m_cse.m_leaf_end - 1;
+                else
+                    return s + m_cse.m_leaf_start;
+            }
+
+            return not_found;
+        }
+
+        // Normal string column, with long or short leaf
+        for (size_t s = start; s < end; ++s) {
+            const StringColumn* asc = static_cast<const StringColumn*>(m_condition_column);
+            if (s >= m_leaf_end || s < m_leaf_start) {
+                clear_leaf_state();
+                size_t ndx_in_leaf;
+                m_leaf = asc->get_leaf(s, ndx_in_leaf, m_leaf_type);
+                m_leaf_start = s - ndx_in_leaf;
+                if (m_leaf_type == StringColumn::leaf_type_Small)
+                    m_leaf_end = m_leaf_start + static_cast<const ArrayString&>(*m_leaf).size();
+                else if (m_leaf_type ==  StringColumn::leaf_type_Medium)
+                    m_leaf_end = m_leaf_start + static_cast<const ArrayStringLong&>(*m_leaf).size();
+                else
+                    m_leaf_end = m_leaf_start + static_cast<const ArrayBigBlobs&>(*m_leaf).size();
+                REALM_ASSERT(m_leaf);
+            }
+            size_t end2 = (end > m_leaf_end ? m_leaf_end - m_leaf_start : end - m_leaf_start);
+
+            if (m_leaf_type == StringColumn::leaf_type_Small)
+                s = static_cast<const ArrayString&>(*m_leaf).find_first(m_value, s - m_leaf_start, end2);
+            else if (m_leaf_type ==  StringColumn::leaf_type_Medium)
+                s = static_cast<const ArrayStringLong&>(*m_leaf).find_first(m_value, s - m_leaf_start, end2);
+            else
+                s = static_cast<const ArrayBigBlobs&>(*m_leaf).find_first(str_to_bin(m_value), true, s - m_leaf_start, end2);
+
+            if (s == not_found)
+                s = m_leaf_end - 1;
+            else
+                return s + m_leaf_start;
+        }
+
+        return not_found;
+    }
+
+    std::unique_ptr<ParentNode> clone(QueryNodeHandoverPatches* patches) const override
+    {
+        return std::unique_ptr<ParentNode>(new StringNode<Equal>(*this, patches));
+    }
+
+    StringNode(const StringNode& from, QueryNodeHandoverPatches* patches) : StringNodeBase(from, patches),
+        m_index_matches_destroy(false)
+    {
+    }
+
+private:
+    inline BinaryData str_to_bin(const StringData& s) noexcept
+    {
+        return BinaryData(s.data(), s.size());
+    }
+
+    size_t m_key_ndx = not_found;
+    size_t m_last_indexed;
+
+    // Used for linear scan through enum-string
+    SequentialGetter<StringEnumColumn> m_cse;
+
+    // Used for index lookup
+    std::unique_ptr<IntegerColumn> m_index_matches;
+    bool m_index_matches_destroy = false;
+    std::unique_ptr<SequentialGetter<IntegerColumn>> m_index_getter;
+    size_t m_index_size;
+    size_t m_last_start;
+};
+
+// OR node contains at least two node pointers: Two or more conditions to OR
+// together in m_conditions, and the next AND condition (if any) in m_child.
+//
+// For 'second.equal(23).begin_group().first.equal(111).Or().first.equal(222).end_group().third().equal(555)', this
+// will first set m_conditions[0] = left-hand-side through constructor, and then later, when .first.equal(222) is invoked,
+// invocation will set m_conditions[1] = right-hand-side through Query& Query::Or() (see query.cpp). In there, m_child is
+// also set to next AND condition (if any exists) following the OR.
+class OrNode: public ParentNode {
+public:
+    template<Action TAction>
+    int64_t find_all(IntegerColumn*, size_t, size_t, size_t, size_t)
+    {
+        REALM_ASSERT(false);
+        return 0;
+    }
+
+    OrNode(std::unique_ptr<ParentNode> condition)
+    {
+        m_dT = 50.0;
+        if (condition)
+            m_conditions.emplace_back(std::move(condition));
+    }
+
+    OrNode(const OrNode& other, QueryNodeHandoverPatches* patches) : ParentNode(other, patches)
+    {
+        for (const auto& condition : other.m_conditions) {
+            m_conditions.emplace_back(condition->clone(patches));
+        }
+    }
+
+    void init(const Table& table) override
+    {
+        m_dD = 10.0;
+
+        m_start.clear();
+        m_start.resize(m_conditions.size(), 0);
+
+        m_last.clear();
+        m_last.resize(m_conditions.size(), 0);
+
+        m_was_match.clear();
+        m_was_match.resize(m_conditions.size(), false);
+
+        std::vector<ParentNode*> v;
+        for (auto& condition : m_conditions) {
+            condition->init(table);
+            v.clear();
+            condition->gather_children(v);
+        }
+
+        if (m_child)
+            m_child->init(table);
+
+        m_table = &table;
+    }
+
+    size_t find_first_local(size_t start, size_t end) override
+    {
+        if (start >= end)
+            return not_found;
+
+        size_t index = not_found;
+
+        for (size_t c = 0; c < m_conditions.size(); ++c) {
+            // out of order search; have to discard cached results
+            if (start < m_start[c]) {
+                m_last[c] = 0;
+                m_was_match[c] = false;
+            }
+            // already searched this range and didn't match
+            else if (m_last[c] >= end)
+                continue;
+            // already search this range and *did* match
+           else if (m_was_match[c] && m_last[c] >= start) {
+                if (index > m_last[c])
+                    index = m_last[c];
+               continue;
+            }
+
+            m_start[c] = start;
+            size_t fmax = std::max(m_last[c], start);
+            size_t f = m_conditions[c]->find_first(fmax, end);
+            m_was_match[c] = f != not_found;
+            m_last[c] = f == not_found ? end : f;
+            if (f != not_found && index > m_last[c])
+                index = m_last[c];
+        }
+
+        return index;
+    }
+
+    std::string validate() override
+    {
+        if (error_code != "")
+            return error_code;
+        if (m_conditions.size() == 0)
+            return "Missing left-hand side of OR";
+        if (m_conditions.size() == 1)
+            return "Missing right-hand side of OR";
+        std::string s;
+        if (m_child != 0)
+            s = m_child->validate();
+        if (s != "")
+            return s;
+        for (size_t i = 0; i < m_conditions.size(); ++i) {
+            s = m_conditions[i]->validate();
+            if (s != "")
+                return s;
+        }
+        return "";
+    }
+
+    std::unique_ptr<ParentNode> clone(QueryNodeHandoverPatches* patches) const override
+    {
+        return std::unique_ptr<ParentNode>(new OrNode(*this, patches));
+    }
+
+    void apply_handover_patch(QueryNodeHandoverPatches& patches, Group& group) override
+    {
+        for (auto it = m_conditions.rbegin(); it != m_conditions.rend(); ++it)
+            (*it)->apply_handover_patch(patches, group);
+
+        ParentNode::apply_handover_patch(patches, group);
+    }
+
+    std::vector<std::unique_ptr<ParentNode>> m_conditions;
+private:
+    // start index of the last find for each cond
+    std::vector<size_t> m_start;
+    // last looked at index of the lasft find for each cond
+    // is a matching index if m_was_match is true
+    std::vector<size_t> m_last;
+    std::vector<bool> m_was_match;
+};
+
+
+
+class NotNode: public ParentNode {
+public:
+    template<Action TAction>
+    int64_t find_all(IntegerColumn*, size_t, size_t, size_t, size_t)
+    {
+        REALM_ASSERT(false);
+        return 0;
+    }
+
+    NotNode(std::unique_ptr<ParentNode> condition) : m_condition(std::move(condition))
+    {
+        m_dT = 50.0;
+    }
+
+    void init(const Table& table) override
+    {
+        m_dD = 10.0;
+
+        std::vector<ParentNode*> v;
+
+        m_condition->init(table);
+        v.clear();
+        m_condition->gather_children(v);
+
+        // Heuristics bookkeeping:
+        m_known_range_start = 0;
+        m_known_range_end = 0;
+        m_first_in_known_range = not_found;
+
+        if (m_child)
+            m_child->init(table);
+
+        m_table = &table;
+    }
+
+    size_t find_first_local(size_t start, size_t end) override;
+
+    std::string validate() override
+    {
+        if (error_code != "")
+            return error_code;
+        if (m_condition == 0)
+            return "Missing argument to Not";
+        std::string s;
+        if (m_child != 0)
+            s = m_child->validate();
+        if (s != "")
+            return s;
+        s = m_condition->validate();
+        if (s != "")
+            return s;
+        return "";
+    }
+
+    std::unique_ptr<ParentNode> clone(QueryNodeHandoverPatches* patches) const override
+    {
+        return std::unique_ptr<ParentNode>(new NotNode(*this, patches));
+    }
+
+    NotNode(const NotNode& from, QueryNodeHandoverPatches* patches) : ParentNode(from, patches),
+        m_condition(from.m_condition ? from.m_condition->clone(patches) : nullptr),
+        m_known_range_start(from.m_known_range_start), m_known_range_end(from.m_known_range_end),
+        m_first_in_known_range(from.m_first_in_known_range)
+    {
+    }
+
+    void apply_handover_patch(QueryNodeHandoverPatches& patches, Group& group) override
+    {
+        m_condition->apply_handover_patch(patches, group);
+        ParentNode::apply_handover_patch(patches, group);
+    }
+
+    std::unique_ptr<ParentNode> m_condition;
+private:
+    // FIXME This heuristic might as well be reused for all condition nodes.
+    size_t m_known_range_start;
+    size_t m_known_range_end;
+    size_t m_first_in_known_range;
+
+    bool evaluate_at(size_t rowndx);
+    void update_known(size_t start, size_t end, size_t first);
+    size_t find_first_loop(size_t start, size_t end);
+    size_t find_first_covers_known(size_t start, size_t end);
+    size_t find_first_covered_by_known(size_t start, size_t end);
+    size_t find_first_overlap_lower(size_t start, size_t end);
+    size_t find_first_overlap_upper(size_t start, size_t end);
+    size_t find_first_no_overlap(size_t start, size_t end);
+};
+
+
+// Compare two columns with eachother row-by-row
+template<class ColType, class TConditionFunction>
+class TwoColumnsNode: public ParentNode {
+public:
+    using TConditionValue = typename ColType::value_type;
+
+    template<Action TAction>
+    int64_t find_all(IntegerColumn* /*res*/, size_t /*start*/, size_t /*end*/, size_t /*limit*/, size_t /*source_column*/) {REALM_ASSERT(false); return 0;}
+
+    TwoColumnsNode(size_t column1, size_t column2)
+    {
+        m_dT = 100.0;
+        m_condition_column_idx1 = column1;
+        m_condition_column_idx2 = column2;
+    }
+
+    ~TwoColumnsNode() noexcept override
+    {
+        delete[] m_value.data();
+    }
+
+    void init(const Table& table) override
+    {
+        m_dD = 100.0;
+        m_table = &table;
+
+        const ColumnBase* cb = &get_column_base(table, m_condition_column_idx1);
+        REALM_ASSERT_DEBUG(dynamic_cast<const ColType*>(cb));
+        const ColType* c = static_cast<const ColType*>(cb);
+        m_getter1.init(c);
+
+        c = static_cast<const ColType*>(&get_column_base(table, m_condition_column_idx2));
+        m_getter2.init(c);
+
+        if (m_child)
+            m_child->init(table);
+    }
+
+    size_t find_first_local(size_t start, size_t end) override
+    {
+        size_t s = start;
+
+        while (s < end) {
+            if (std::is_same<TConditionValue, int64_t>::value) {
+                // For int64_t we've created an array intrinsics named compare_leafs which template expands bitwidths
+                // of boths arrays to make Get faster.
+                m_getter1.cache_next(s);
+                m_getter2.cache_next(s);
+
+                QueryState<int64_t> qs;
+                bool resume = m_getter1.m_leaf_ptr->template compare_leafs<TConditionFunction, act_ReturnFirst>(m_getter2.m_leaf_ptr, s - m_getter1.m_leaf_start, m_getter1.local_end(end), 0, &qs, CallbackDummy());
+
+                if (resume)
+                    s = m_getter1.m_leaf_end;
+                else
+                    return to_size_t(qs.m_state) + m_getter1.m_leaf_start;
+            }
+            else {
+                // This is for float and double.
+
+#if 0 && defined(REALM_COMPILER_AVX)
+// AVX has been disabled because of array alignment (see https://app.asana.com/0/search/8836174089724/5763107052506)
+//
+// For AVX you can call things like if (sseavx<1>()) to test for AVX, and then utilize _mm256_movemask_ps (VC)
+// or movemask_cmp_ps (gcc/clang)
+//
+// See https://github.com/rrrlasse/realm/tree/AVX for an example of utilizing AVX for a two-column search which has
+// been benchmarked to: floats: 288 ms vs 552 by using AVX compared to 2-level-unrolled FPU loop. doubles: 415 ms vs
+// 475 (more bandwidth bound). Tests against SSE have not been performed; AVX may not pay off. Please benchmark
+#endif
+
+                TConditionValue v1 = m_getter1.get_next(s);
+                TConditionValue v2 = m_getter2.get_next(s);
+                TConditionFunction C;
+
+                if (C(v1, v2))
+                    return s;
+                else
+                    s++;
+            }
+        }
+        return not_found;
+    }
+
+    std::unique_ptr<ParentNode> clone(QueryNodeHandoverPatches* patches) const override
+    {
+        return std::unique_ptr<ParentNode>(new TwoColumnsNode<ColType, TConditionFunction>(*this, patches));
+    }
+
+    TwoColumnsNode(const TwoColumnsNode& from, QueryNodeHandoverPatches* patches) : ParentNode(from, patches),
+        m_value(from.m_value), m_condition_column(from.m_condition_column), m_column_type(from.m_column_type),
+        m_condition_column_idx1(from.m_condition_column_idx1), m_condition_column_idx2(from.m_condition_column_idx2)
+    {
+        // NOT copied:
+        // m_getter1 = from.m_getter1;
+        // m_getter2 = from.m_getter2;
+    }
+
+private:
+    BinaryData m_value;
+    const BinaryColumn* m_condition_column;
+    ColumnType m_column_type;
+
+    size_t m_condition_column_idx1;
+    size_t m_condition_column_idx2;
+
+    SequentialGetter<ColType> m_getter1;
+    SequentialGetter<ColType> m_getter2;
+};
+
+
+// For Next-Generation expressions like col1 / col2 + 123 > col4 * 100.
+class ExpressionNode: public ParentNode {
+
+public:
+    ExpressionNode(std::unique_ptr<Expression> expression) : m_expression(std::move(expression))
+    {
+        m_dD = 10.0;
+        m_dT = 50.0;
+    }
+
+    void init(const Table& table) override
+    {
+        m_expression->set_base_table(&table);
+        if (m_child)
+            m_child->init(table);
+    }
+
+    size_t find_first_local(size_t start, size_t end) override
+    {
+        return m_expression->find_first(start, end);
+    }
+
+    std::unique_ptr<ParentNode> clone(QueryNodeHandoverPatches* patches) const override
+    {
+        return std::unique_ptr<ParentNode>(new ExpressionNode(*this, patches));
+    }
+
+    void apply_handover_patch(QueryNodeHandoverPatches& patches, Group& group) override
+    {
+        m_expression->apply_handover_patch(patches, group);
+        ParentNode::apply_handover_patch(patches, group);
+    }
+
+private:
+    ExpressionNode(const ExpressionNode& from, QueryNodeHandoverPatches* patches) : ParentNode(from, patches),
+        m_expression(from.m_expression->clone(patches))
+    {
+    }
+
+    std::unique_ptr<Expression> m_expression;
+};
+
+
+struct LinksToNodeHandoverPatch : public QueryNodeHandoverPatch {
+    std::unique_ptr<RowBaseHandoverPatch> m_target_row;
+    size_t m_origin_column;
+};
+
+class LinksToNode : public ParentNode {
+public:
+    LinksToNode(size_t origin_column_index, const ConstRow& target_row) :
+        m_origin_column(origin_column_index),
+        m_target_row(target_row)
+    {
+        m_dD = 10.0;
+        m_dT = 50.0;
+    }
+
+    void init(const Table& table) override
+    {
+        m_table = &table;
+        if (m_child)
+            m_child->init(table);
+    }
+
+    size_t find_first_local(size_t start, size_t end) override
+    {
+        if (!m_target_row.is_attached())
+            return not_found;
+
+        DataType type = m_table->get_column_type(m_origin_column);
+        REALM_ASSERT(type == type_Link || type == type_LinkList);
+
+        if (type == type_Link) {
+            LinkColumnBase& clb = const_cast<Table*>(m_table)->get_column_link_base(m_origin_column);
+            LinkColumn& cl = static_cast<LinkColumn&>(clb);
+            return cl.find_first(m_target_row.get_index() + 1, start, end); // LinkColumn stores link to row N as the integer N + 1
+        }
+        else if (type == type_LinkList) {
+            LinkColumnBase& clb = const_cast<Table*>(m_table)->get_column_link_base(m_origin_column);
+            LinkListColumn& cll = static_cast<LinkListColumn&>(clb);
+
+            for (size_t i = start; i < end; i++) {
+                LinkViewRef lv = cll.get(i);
+                if (lv->find(m_target_row.get_index()) != not_found)
+                    return i;
+            }
+        }
+
+        return not_found;
+    }
+
+    std::unique_ptr<ParentNode> clone(QueryNodeHandoverPatches* patches) const override
+    {
+        return std::unique_ptr<ParentNode>(new LinksToNode(*this, patches));
+    }
+
+    void apply_handover_patch(QueryNodeHandoverPatches& patches, Group& group) override
+    {
+        REALM_ASSERT(patches.size());
+        std::unique_ptr<QueryNodeHandoverPatch> abstract_patch = std::move(patches.back());
+        patches.pop_back();
+
+        auto patch = dynamic_cast<LinksToNodeHandoverPatch*>(abstract_patch.get());
+        REALM_ASSERT(patch);
+
+        m_origin_column = patch->m_origin_column;
+        m_target_row.apply_and_consume_patch(patch->m_target_row, group);
+
+        ParentNode::apply_handover_patch(patches, group);
+    }
+
+private:
+    size_t m_origin_column;
+    ConstRow m_target_row;
+
+    LinksToNode(const LinksToNode& source, QueryNodeHandoverPatches* patches) : ParentNode(source, patches),
+         m_origin_column(patches ? npos : source.m_origin_column),
+         m_target_row(patches ? ConstRow() : source.m_target_row)
+    {
+        if (!patches)
+            return;
+
+        std::unique_ptr<LinksToNodeHandoverPatch> patch(new LinksToNodeHandoverPatch);
+        patch->m_origin_column = source.m_origin_column;
+        ConstRow::generate_patch(source.m_target_row, patch->m_target_row);
+        patches->emplace_back(patch.release());
+    }
+};
+
+} // namespace realm
+
+#endif // REALM_QUERY_ENGINE_HPP
diff --git a/Pods/Realm/include/core/realm/query_expression.hpp b/Pods/Realm/include/core/realm/query_expression.hpp
new file mode 100644
index 0000000..46409c0
--- /dev/null
+++ b/Pods/Realm/include/core/realm/query_expression.hpp
@@ -0,0 +1,2776 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+
+/*
+This file lets you write queries in C++ syntax like: Expression* e = (first + 1 / second >= third + 12.3);
+
+Type conversion/promotion semantics is the same as in the C++ expressions, e.g float + int > double == float +
+(float)int > double.
+
+
+Grammar:
+-----------------------------------------------------------------------------------------------------------------------
+    Expression:         Subexpr2<T>  Compare<Cond, T>  Subexpr2<T>
+                        operator! Expression
+
+    Subexpr2<T>:        Value<T>
+                        Columns<T>
+                        Subexpr2<T>  Operator<Oper<T>  Subexpr2<T>
+                        power(Subexpr2<T>) // power(x) = x * x, as example of unary operator
+
+    Value<T>:           T
+
+    Operator<Oper<T>>:  +, -, *, /
+
+    Compare<Cond, T>:   ==, !=, >=, <=, >, <
+
+    T:                  bool, int, int64_t, float, double, StringData
+
+
+Class diagram
+-----------------------------------------------------------------------------------------------------------------------
+Subexpr2
+    void evaluate(size_t i, ValueBase* destination)
+
+Compare: public Subexpr2
+    size_t find_first(size_t start, size_t end)     // main method that executes query
+
+    unique_ptr<Subexpr2> m_left;                               // left expression subtree
+    unique_ptr<Subexpr2> m_right;                              // right expression subtree
+
+Operator: public Subexpr2
+    void evaluate(size_t i, ValueBase* destination)
+    unique_ptr<Subexpr2> m_left;                               // left expression subtree
+    unique_ptr<Subexpr2> m_right;                              // right expression subtree
+
+Value<T>: public Subexpr2
+    void evaluate(size_t i, ValueBase* destination)
+    T m_v[8];
+
+Columns<T>: public Subexpr2
+    void evaluate(size_t i, ValueBase* destination)
+    SequentialGetter<T> sg;                         // class bound to a column, lets you read values in a fast way
+    Table* m_table;
+
+class ColumnAccessor<>: public Columns<double>
+
+
+Call diagram:
+-----------------------------------------------------------------------------------------------------------------------
+Example of 'table.first > 34.6 + table.second':
+
+size_t Compare<Greater>::find_first()-------------+
+         |                                        |
+         |                                        |
+         |                                        |
+         +--> Columns<float>::evaluate()          +--------> Operator<Plus>::evaluate()
+                                                                |               |
+                                               Value<float>::evaluate()    Columns<float>::evaluate()
+
+Operator, Value and Columns have an evaluate(size_t i, ValueBase* destination) method which returns a Value<T>
+containing 8 values representing table rows i...i + 7.
+
+So Value<T> contains 8 concecutive values and all operations are based on these chunks. This is
+to save overhead by virtual calls needed for evaluating a query that has been dynamically constructed at runtime.
+
+
+Memory allocation:
+-----------------------------------------------------------------------------------------------------------------------
+Subexpressions created by the end-user are stack allocated. They are cloned to the heap when passed to UnaryOperator,
+Operator, and Compare. Those types own the clones and deallocate them when destroyed.
+
+
+Caveats, notes and todos
+-----------------------------------------------------------------------------------------------------------------------
+    * Perhaps disallow columns from two different tables in same expression
+    * The name Columns (with s) an be confusing because we also have Column (without s)
+    * We have Columns::m_table, Query::m_table and ColumnAccessorBase::m_table that point at the same thing, even with
+      ColumnAccessor<> extending Columns. So m_table is redundant, but this is in order to keep class dependencies and
+      entanglement low so that the design is flexible (if you perhaps later want a Columns class that is not dependent
+      on ColumnAccessor)
+
+Nulls
+-----------------------------------------------------------------------------------------------------------------------
+First note that at array level, nulls are distinguished between non-null in different ways:
+String:
+    m_data == 0 && m_size == 0
+
+Integer, Bool, OldDateTime stored in ArrayIntNull:
+    value == get(0) (entry 0 determins a magic value that represents nulls)
+
+Float/double:
+    null::is_null(value) which tests if value bit-matches one specific bit pattern reserved for null
+
+The Columns class encapsulates all this into a simple class that, for any type T has
+    evaluate(size_t index) that reads values from a column, taking nulls in count
+    get(index)
+    set(index)
+    is_null(index)
+    set_null(index)
+*/
+
+#ifndef REALM_QUERY_EXPRESSION_HPP
+#define REALM_QUERY_EXPRESSION_HPP
+
+#include <realm/column_type_traits.hpp>
+#include <realm/util/optional.hpp>
+#include <realm/impl/sequential_getter.hpp>
+
+#include <numeric>
+
+// Normally, if a next-generation-syntax condition is supported by the old query_engine.hpp, a query_engine node is
+// created because it's faster (by a factor of 5 - 10). Because many of our existing next-generation-syntax unit
+// unit tests are indeed simple enough to fallback to old query_engine, query_expression gets low test coverage. Undef
+// flag to get higher query_expression test coverage. This is a good idea to try out each time you develop on/modify
+// query_expression.
+
+#define REALM_OLDQUERY_FALLBACK
+
+namespace realm {
+
+template<class T>
+T minimum(T a, T b)
+{
+    return a < b ? a : b;
+}
+
+// FIXME, this needs to exist elsewhere
+typedef int64_t             Int;
+typedef bool                Bool;
+typedef realm::OldDateTime   OldDateTime;
+typedef float               Float;
+typedef double              Double;
+typedef realm::StringData String;
+typedef realm::BinaryData Binary;
+
+// Hack to avoid template instantiation errors. See create(). Todo, see if we can simplify only_numeric somehow
+namespace {
+template<class T, class U>
+T only_numeric(U in)
+{
+    return static_cast<T>(util::unwrap(in));
+}
+
+template<class T>
+int only_numeric(const StringData&)
+{
+    REALM_ASSERT(false);
+    return 0;
+}
+
+template<class T>
+int only_numeric(const BinaryData&)
+{
+    REALM_ASSERT(false);
+    return 0;
+}
+
+template<class T>
+StringData only_string(T in)
+{
+    REALM_ASSERT(false);
+    static_cast<void>(in);
+    return StringData();
+}
+
+StringData only_string(StringData in)
+{
+    return in;
+}
+
+template<class T, class U>
+T no_timestamp(U in)
+{
+    return static_cast<T>(util::unwrap(in));
+}
+
+template<class T>
+int no_timestamp(const Timestamp&)
+{
+    REALM_ASSERT(false);
+    return 0;
+}
+
+
+} // anonymous namespace
+
+template<class T>struct Plus {
+    T operator()(T v1, T v2) const { return v1 + v2; }
+    typedef T type;
+};
+
+template<class T>struct Minus {
+    T operator()(T v1, T v2) const { return v1 - v2; }
+    typedef T type;
+};
+
+template<class T>struct Div {
+    T operator()(T v1, T v2) const { return v1 / v2; }
+    typedef T type;
+};
+
+template<class T>struct Mul {
+    T operator()(T v1, T v2) const { return v1 * v2; }
+    typedef T type;
+};
+
+// Unary operator
+template<class T>struct Pow {
+    T operator()(T v) const { return v * v; }
+    typedef T type;
+};
+
+// Finds a common type for T1 and T2 according to C++ conversion/promotion in arithmetic (float + int => float, etc)
+template<class T1, class T2,
+    bool T1_is_int = std::numeric_limits<T1>::is_integer || std::is_same<T1, null>::value,
+    bool T2_is_int = std::numeric_limits<T2>::is_integer || std::is_same<T2, null>::value,
+    bool T1_is_widest = (sizeof(T1) > sizeof(T2)   ||     std::is_same<T2, null>::value    ) > struct Common;
+template<class T1, class T2, bool b>
+struct Common<T1, T2, b, b, true > {
+    typedef T1 type;
+};
+template<class T1, class T2, bool b>
+struct Common<T1, T2, b, b, false> {
+    typedef T2 type;
+};
+template<class T1, class T2, bool b>
+struct Common<T1, T2, false, true , b> {
+    typedef T1 type;
+};
+template<class T1, class T2, bool b>
+struct Common<T1, T2, true, false, b> {
+    typedef T2 type;
+};
+
+
+struct RowIndex {
+    enum DetachedTag {
+        Detached
+    };
+
+    explicit RowIndex() : m_row_index(npos) { }
+    explicit RowIndex(size_t row_index) : m_row_index(row_index) { }
+    RowIndex(DetachedTag) : m_row_index() { }
+
+    bool is_attached() const { return bool(m_row_index); }
+    bool is_null() const { return is_attached() && *m_row_index == npos; }
+
+    bool operator == (const RowIndex& other) const {
+        // Row indexes that are detached are never equal to any other row index.
+        if (!is_attached() || !other.is_attached())
+            return false;
+        return m_row_index == other.m_row_index;
+    }
+    bool operator != (const RowIndex& other) const { return !(*this == other); }
+
+private:
+    util::Optional<size_t> m_row_index;
+};
+
+
+struct ValueBase
+{
+    static const size_t default_size = 8;
+    virtual void export_bool(ValueBase& destination) const = 0;
+    virtual void export_Timestamp(ValueBase& destination) const = 0;
+    virtual void export_int(ValueBase& destination) const = 0;
+    virtual void export_float(ValueBase& destination) const = 0;
+    virtual void export_int64_t(ValueBase& destination) const = 0;
+    virtual void export_double(ValueBase& destination) const = 0;
+    virtual void export_StringData(ValueBase& destination) const = 0;
+    virtual void export_BinaryData(ValueBase& destination) const = 0;
+    virtual void export_RowIndex(ValueBase& destination) const = 0;
+    virtual void export_null(ValueBase& destination) const = 0;
+    virtual void import(const ValueBase& destination) = 0;
+
+    // If true, all values in the class come from a link list of a single field in the parent table (m_table). If
+    // false, then values come from successive rows of m_table (query operations are operated on in bulks for speed)
+    bool m_from_link_list;
+
+    // Number of values stored in the class.
+    size_t m_values;
+};
+
+class Expression
+{
+public:
+    Expression() { }
+    virtual ~Expression() {}
+
+    virtual size_t find_first(size_t start, size_t end) const = 0;
+    virtual void set_base_table(const Table* table) = 0;
+    virtual const Table* get_base_table() const = 0;
+
+    virtual std::unique_ptr<Expression> clone(QueryNodeHandoverPatches*) const = 0;
+    virtual void apply_handover_patch(QueryNodeHandoverPatches&, Group&) { }
+};
+
+template<typename T, typename... Args>
+std::unique_ptr<Expression> make_expression(Args&&... args)
+{
+    return std::unique_ptr<Expression>(new T(std::forward<Args>(args)...));
+}
+
+class Subexpr
+{
+public:
+    virtual ~Subexpr() {}
+
+    virtual std::unique_ptr<Subexpr> clone(QueryNodeHandoverPatches* = nullptr) const = 0;
+    virtual void apply_handover_patch(QueryNodeHandoverPatches&, Group&) { }
+
+    // When the user constructs a query, it always "belongs" to one single base/parent table (regardless of
+    // any links or not and regardless of any queries assembled with || or &&). When you do a Query::find(),
+    // then Query::m_table is set to this table, and set_base_table() is called on all Columns and LinkMaps in
+    // the query expression tree so that they can set/update their internals as required.
+    //
+    // During thread-handover of a Query, set_base_table() is also called to make objects point at the new table
+    // instead of the old one from the old thread.
+    virtual void set_base_table(const Table*) {}
+
+    // Recursively fetch tables of columns in expression tree. Used when user first builds a stand-alone expression and
+    // binds it to a Query at a later time
+    virtual const Table* get_base_table() const
+    {
+        return nullptr;
+    }
+
+    virtual void evaluate(size_t index, ValueBase& destination) = 0;
+};
+
+template<typename T, typename... Args>
+std::unique_ptr<Subexpr> make_subexpr(Args&&... args)
+{
+    return std::unique_ptr<Subexpr>(new T(std::forward<Args>(args)...));
+}
+
+template<class T>
+class Columns;
+template<class T>
+class Value;
+class ConstantStringValue;
+template<class T>
+class Subexpr2;
+template<class oper, class TLeft = Subexpr, class TRight = Subexpr>
+class Operator;
+template<class oper, class TLeft = Subexpr>
+class UnaryOperator;
+template<class TCond, class T, class TLeft = Subexpr, class TRight = Subexpr>
+class Compare;
+template<bool has_links>
+class UnaryLinkCompare;
+class ColumnAccessorBase;
+
+
+// Handle cases where left side is a constant (int, float, int64_t, double, StringData)
+template<class L, class Cond, class R>
+Query create(L left, const Subexpr2<R>& right)
+{
+    // Purpose of below code is to intercept the creation of a condition and test if it's supported by the old
+    // query_engine.hpp which is faster. If it's supported, create a query_engine.hpp node, otherwise create a
+    // query_expression.hpp node.
+    //
+    // This method intercepts only Value <cond> Subexpr2. Interception of Subexpr2 <cond> Subexpr is elsewhere.
+
+#ifdef REALM_OLDQUERY_FALLBACK // if not defined, then never fallback to query_engine.hpp; always use query_expression
+    const Columns<R>* column = dynamic_cast<const Columns<R>*>(&right);
+
+    if (column &&
+        ((std::numeric_limits<L>::is_integer && std::numeric_limits<L>::is_integer) ||
+        (std::is_same<L, double>::value && std::is_same<R, double>::value) ||
+        (std::is_same<L, float>::value && std::is_same<R, float>::value) ||
+        (std::is_same<L, Timestamp>::value && std::is_same<R, Timestamp>::value) ||
+        (std::is_same<L, StringData>::value && std::is_same<R, StringData>::value) ||
+        (std::is_same<L, BinaryData>::value && std::is_same<R, BinaryData>::value))
+        &&
+        !column->links_exist()) {
+        const Table* t = column->get_base_table();
+        Query q = Query(*t);
+
+        if (std::is_same<Cond, Less>::value)
+            q.greater(column->m_column, only_numeric<R>(left));
+        else if (std::is_same<Cond, Greater>::value)
+            q.less(column->m_column, only_numeric<R>(left));
+        else if (std::is_same<Cond, Equal>::value)
+            q.equal(column->m_column, left);
+        else if (std::is_same<Cond, NotEqual>::value)
+            q.not_equal(column->m_column, left);
+        else if (std::is_same<Cond, LessEqual>::value)
+            q.greater_equal(column->m_column, only_numeric<R>(left));
+        else if (std::is_same<Cond, GreaterEqual>::value)
+            q.less_equal(column->m_column, only_numeric<R>(left));
+        else if (std::is_same<Cond, EqualIns>::value)
+            q.equal(column->m_column, only_string(left), false);
+        else if (std::is_same<Cond, NotEqualIns>::value)
+            q.not_equal(column->m_column, only_string(left), false);
+        else if (std::is_same<Cond, BeginsWith>::value)
+            q.begins_with(column->m_column, only_string(left));
+        else if (std::is_same<Cond, BeginsWithIns>::value)
+            q.begins_with(column->m_column, only_string(left), false);
+        else if (std::is_same<Cond, EndsWith>::value)
+            q.ends_with(column->m_column, only_string(left));
+        else if (std::is_same<Cond, EndsWithIns>::value)
+            q.ends_with(column->m_column, only_string(left), false);
+        else if (std::is_same<Cond, Contains>::value)
+            q.contains(column->m_column, only_string(left));
+        else if (std::is_same<Cond, ContainsIns>::value)
+            q.contains(column->m_column, only_string(left), false);
+        else {
+            // query_engine.hpp does not support this Cond. Please either add support for it in query_engine.hpp or
+            // fallback to using use 'return new Compare<>' instead.
+            REALM_ASSERT(false);
+        }
+        // Return query_engine.hpp node
+        return q;
+    }
+    else
+#endif
+    {
+        // Return query_expression.hpp node
+        using CommonType = typename Common<L, R>::type;
+        using ValueType = typename std::conditional<std::is_same<L, StringData>::value, ConstantStringValue, Value<L>>::type;
+        return make_expression<Compare<Cond, CommonType>>(make_subexpr<ValueType>(left), right.clone());
+    }
+}
+
+
+// All overloads where left-hand-side is Subexpr2<L>:
+//
+// left-hand-side       operator                              right-hand-side
+// Subexpr2<L>          +, -, *, /, <, >, ==, !=, <=, >=      R, Subexpr2<R>
+//
+// For L = R = {int, int64_t, float, double, StringData, Timestamp}:
+template<class L, class R>
+class Overloads
+{
+    typedef typename Common<L, R>::type CommonType;
+
+    std::unique_ptr<Subexpr> clone_subexpr() const
+    {
+        return static_cast<const Subexpr2<L>&>(*this).clone();
+    }
+
+public:
+
+    // Arithmetic, right side constant
+    Operator<Plus<CommonType>> operator + (R right) const
+    {
+        return { clone_subexpr(), make_subexpr<Value<R>>(right) };
+    }
+    Operator<Minus<CommonType>> operator - (R right) const
+    {
+        return { clone_subexpr(), make_subexpr<Value<R>>(right) };
+    }
+    Operator<Mul<CommonType>> operator * (R right) const
+    {
+        return { clone_subexpr(), make_subexpr<Value<R>>(right) };
+    }
+    Operator<Div<CommonType>> operator / (R right) const
+    {
+        return { clone_subexpr(), make_subexpr<Value<R>>(right) };
+    }
+
+    // Arithmetic, right side subexpression
+    Operator<Plus<CommonType>> operator + (const Subexpr2<R>& right) const
+    {
+        return { clone_subexpr(), right.clone() };
+    }
+    Operator<Minus<CommonType>> operator - (const Subexpr2<R>& right) const
+    {
+        return { clone_subexpr(), right.clone() };
+    }
+    Operator<Mul<CommonType>> operator * (const Subexpr2<R>& right) const
+    {
+        return { clone_subexpr(), right.clone() };
+    }
+    Operator<Div<CommonType>> operator / (const Subexpr2<R>& right) const
+    {
+        return { clone_subexpr(), right.clone() };
+    }
+
+    // Compare, right side constant
+    Query operator > (R right)
+    {
+        return create<R, Less, L>(right, static_cast<Subexpr2<L>&>(*this));
+    }
+    Query operator < (R right)
+    {
+        return create<R, Greater, L>(right, static_cast<Subexpr2<L>&>(*this));
+    }
+    Query operator >= (R right)
+    {
+        return create<R, LessEqual, L>(right, static_cast<Subexpr2<L>&>(*this));
+    }
+    Query operator <= (R right)
+    {
+        return create<R, GreaterEqual, L>(right, static_cast<Subexpr2<L>&>(*this));
+    }
+    Query operator == (R right)
+    {
+        return create<R, Equal, L>(right, static_cast<Subexpr2<L>&>(*this));
+    }
+    Query operator != (R right)
+    {
+        return create<R, NotEqual, L>(right, static_cast<Subexpr2<L>&>(*this));
+    }
+
+    // Purpose of this method is to intercept the creation of a condition and test if it's supported by the old
+    // query_engine.hpp which is faster. If it's supported, create a query_engine.hpp node, otherwise create a
+    // query_expression.hpp node.
+    //
+    // This method intercepts Subexpr2 <cond> Subexpr2 only. Value <cond> Subexpr2 is intercepted elsewhere.
+    template<class Cond>
+    Query create2 (const Subexpr2<R>& right)
+    {
+#ifdef REALM_OLDQUERY_FALLBACK // if not defined, never fallback query_engine; always use query_expression
+        // Test if expressions are of type Columns. Other possibilities are Value and Operator.
+        const Columns<R>* left_col = dynamic_cast<const Columns<R>*>(static_cast<Subexpr2<L>*>(this));
+        const Columns<R>* right_col = dynamic_cast<const Columns<R>*>(&right);
+
+        // query_engine supports 'T-column <op> <T-column>' for T = {int64_t, float, double}, op = {<, >, ==, !=, <=, >=},
+        // but only if both columns are non-nullable, and aren't in linked tables.
+        if (left_col && right_col && std::is_same<L, R>::value && !left_col->is_nullable() && !right_col->is_nullable()
+            && !left_col->links_exist() && !right_col->links_exist() && !std::is_same<L, Timestamp>::value) {
+            const Table* t = left_col->get_base_table();
+            Query q = Query(*t);
+
+            if (std::numeric_limits<L>::is_integer || std::is_same<L, OldDateTime>::value) {
+                if (std::is_same<Cond, Less>::value)
+                    q.less_int(left_col->m_column, right_col->m_column);
+                else if (std::is_same<Cond, Greater>::value)
+                    q.greater_int(left_col->m_column, right_col->m_column);
+                else if (std::is_same<Cond, Equal>::value)
+                    q.equal_int(left_col->m_column, right_col->m_column);
+                else if (std::is_same<Cond, NotEqual>::value)
+                    q.not_equal_int(left_col->m_column, right_col->m_column);
+                else if (std::is_same<Cond, LessEqual>::value)
+                    q.less_equal_int(left_col->m_column, right_col->m_column);
+                else if (std::is_same<Cond, GreaterEqual>::value)
+                    q.greater_equal_int(left_col->m_column, right_col->m_column);
+                else {
+                    REALM_ASSERT(false);
+                }
+            }
+            else if (std::is_same<L, float>::value) {
+                if (std::is_same<Cond, Less>::value)
+                    q.less_float(left_col->m_column, right_col->m_column);
+                else if (std::is_same<Cond, Greater>::value)
+                    q.greater_float(left_col->m_column, right_col->m_column);
+                else if (std::is_same<Cond, Equal>::value)
+                    q.equal_float(left_col->m_column, right_col->m_column);
+                else if (std::is_same<Cond, NotEqual>::value)
+                    q.not_equal_float(left_col->m_column, right_col->m_column);
+                else if (std::is_same<Cond, LessEqual>::value)
+                    q.less_equal_float(left_col->m_column, right_col->m_column);
+                else if (std::is_same<Cond, GreaterEqual>::value)
+                    q.greater_equal_float(left_col->m_column, right_col->m_column);
+                else {
+                    REALM_ASSERT(false);
+                }
+            }
+            else if (std::is_same<L, double>::value) {
+                if (std::is_same<Cond, Less>::value)
+                    q.less_double(left_col->m_column, right_col->m_column);
+                else if (std::is_same<Cond, Greater>::value)
+                    q.greater_double(left_col->m_column, right_col->m_column);
+                else if (std::is_same<Cond, Equal>::value)
+                    q.equal_double(left_col->m_column, right_col->m_column);
+                else if (std::is_same<Cond, NotEqual>::value)
+                    q.not_equal_double(left_col->m_column, right_col->m_column);
+                else if (std::is_same<Cond, LessEqual>::value)
+                    q.less_equal_double(left_col->m_column, right_col->m_column);
+                else if (std::is_same<Cond, GreaterEqual>::value)
+                    q.greater_equal_double(left_col->m_column, right_col->m_column);
+                else {
+                    REALM_ASSERT(false);
+                }
+            }
+            else {
+                REALM_ASSERT(false);
+            }
+            // Return query_engine.hpp node
+            return q;
+        }
+        else
+#endif
+        {
+            // Return query_expression.hpp node
+            return make_expression<Compare<Cond, typename Common<L, R>::type>>(clone_subexpr(), right.clone());
+        }
+    }
+
+    // Compare, right side subexpression
+    Query operator == (const Subexpr2<R>& right)
+    {
+        return create2<Equal>(right);
+    }
+    Query operator != (const Subexpr2<R>& right)
+    {
+        return create2<NotEqual>(right);
+    }
+    Query operator > (const Subexpr2<R>& right)
+    {
+        return create2<Greater>(right);
+    }
+    Query operator < (const Subexpr2<R>& right)
+    {
+        return create2<Less>(right);
+    }
+    Query operator >= (const Subexpr2<R>& right)
+    {
+        return create2<GreaterEqual>(right);
+    }
+    Query operator <= (const Subexpr2<R>& right)
+    {
+        return create2<LessEqual>(right);
+    }
+};
+
+// With this wrapper class we can define just 20 overloads inside Overloads<L, R> instead of 5 * 20 = 100. Todo: We can
+// consider if it's simpler/better to remove this class completely and just list all 100 overloads manually anyway.
+template<class T>
+class Subexpr2 : public Subexpr, public Overloads<T, const char*>, public Overloads<T, int>, public
+Overloads<T, float>, public Overloads<T, double>, public Overloads<T, int64_t>, public Overloads<T, StringData>,
+public Overloads<T, bool>, public Overloads<T, Timestamp>, public Overloads<T, OldDateTime>, public Overloads<T, null>
+{
+public:
+    virtual ~Subexpr2() {}
+
+#define RLM_U2(t, o) using Overloads<T, t>::operator o;
+#define RLM_U(o) RLM_U2(int, o) RLM_U2(float, o) RLM_U2(double, o) RLM_U2(int64_t, o) RLM_U2(StringData, o) RLM_U2(bool, o) RLM_U2(OldDateTime, o) RLM_U2(Timestamp, o) RLM_U2(null, o)
+    RLM_U(+) RLM_U(-) RLM_U(*) RLM_U(/ ) RLM_U(> ) RLM_U(< ) RLM_U(== ) RLM_U(!= ) RLM_U(>= ) RLM_U(<= )
+};
+
+// Subexpr2<Link> only provides equality comparisons. Their implementations can be found later in this file.
+template<>
+class Subexpr2<Link> : public Subexpr
+{
+};
+
+
+/*
+This class is used to store N values of type T = {int64_t, bool, OldDateTime or StringData}, and allows an entry
+to be null too. It's used by the Value class for internal storage.
+
+To indicate nulls, we could have chosen a separate bool vector or some other bitmask construction. But for
+performance, we customize indication of nulls to match the same indication that is used in the persisted database
+file
+
+Queries in query_expression.hpp execute by processing chunks of 8 rows at a time. Assume you have a column:
+
+    price (int) = {1, 2, 3, null, 1, 6, 6, 9, 5, 2, null}
+
+And perform a query:
+
+    Query q = (price + 2 == 5);
+
+query_expression.hpp will then create a NullableVector<int> = {5, 5, 5, 5, 5, 5, 5, 5} and then read values
+NullableVector<int> = {1, 2, 3, null, 1, 6, 6, 9} from the column, and then perform `+` and `==` on these chunks.
+
+See the top of this file for more information on all this.
+
+Assume the user specifies the null constant in a query:
+
+Query q = (price == null)
+
+The query system will then construct a NullableVector of type `null` (NullableVector<null>). This allows compile
+time optimizations for these cases.
+*/
+
+template<class T, size_t prealloc = 8>
+struct NullableVector
+{
+    using Underlying = typename util::RemoveOptional<T>::type;
+    using t_storage  = typename std::conditional<std::is_same<Underlying, bool>::value
+        || std::is_same<Underlying, int>::value, int64_t, Underlying>::type;
+
+    NullableVector() {}
+
+    NullableVector& operator= (const NullableVector& other)
+    {
+        if (this != &other) {
+            init(other.m_size);
+            std::copy(other.m_first, other.m_first + other.m_size, m_first);
+            m_null = other.m_null;
+        }
+        return *this;
+    }
+
+    NullableVector(const NullableVector& other)
+    {
+        init(other.m_size);
+        std::copy(other.m_first, other.m_first + other.m_size, m_first);
+        m_null = other.m_null;
+    }
+
+    ~NullableVector()
+    {
+        dealloc();
+    }
+
+    T operator[](size_t index) const
+    {
+        REALM_ASSERT_3(index, <, m_size);
+        return static_cast<T>(m_first[index]);
+    }
+
+    inline bool is_null(size_t index) const
+    {
+        REALM_ASSERT((std::is_same<t_storage, int64_t>::value));
+        return m_first[index] == m_null;
+    }
+
+    inline void set_null(size_t index)
+    {
+        REALM_ASSERT((std::is_same<t_storage, int64_t>::value));
+        m_first[index] = m_null;
+    }
+
+    template <typename Type = t_storage>
+    typename std::enable_if<std::is_same<Type, int64_t>::value, void>::type
+    set(size_t index, t_storage value)
+    {
+        REALM_ASSERT((std::is_same<t_storage, int64_t>::value));
+
+        // If value collides with magic null value, then switch to a new unique representation for null
+        if (REALM_UNLIKELY(value == m_null)) {
+            // adding a prime will generate 2^64 unique values. Todo: Only works on 2's complement architecture
+            uint64_t candidate = static_cast<uint64_t>(m_null) + 0xfffffffbULL;
+            while (std::find(m_first, m_first + m_size, static_cast<int64_t>(candidate)) != m_first + m_size)
+                candidate += 0xfffffffbULL;
+            std::replace(m_first, m_first + m_size, m_null, static_cast<int64_t>(candidate));
+        }
+        m_first[index] = value;
+    }
+
+    template <typename Type = T>
+    typename std::enable_if<realm::is_any<Type, float, double, OldDateTime, BinaryData, StringData, RowIndex, Timestamp, null>::value,
+                            void>::type
+    set(size_t index, t_storage value) {
+        m_first[index] = value;
+    }
+
+
+    inline util::Optional<T> get(size_t index) const
+    {
+        if (is_null(index))
+            return util::none;
+
+        return util::make_optional((*this)[index]);
+    }
+
+    inline void set(size_t index, util::Optional<Underlying> value)
+    {
+        if (value) {
+            Underlying v = *value;
+            set(index, v);
+        }
+        else {
+            set_null(index);
+        }
+    }
+
+    void fill(T value)
+    {
+        for (size_t t = 0; t < m_size; t++) {
+            if (std::is_same<T, null>::value)
+                set_null(t);
+            else
+                set(t, value);
+        }
+    }
+
+    void init(size_t size)
+    {
+        if (size == m_size)
+            return;
+
+        dealloc();
+        m_size = size;
+        if (m_size > 0) {
+            if (m_size > prealloc)
+                m_first = reinterpret_cast<t_storage*>(new t_storage[m_size]);
+            else
+                m_first = m_cache;
+        }
+    }
+
+    void init(size_t size, T values)
+    {
+        init(size);
+        fill(values);
+    }
+
+    void dealloc()
+    {
+        if (m_first) {
+            if (m_size > prealloc)
+                delete[] m_first;
+            m_first = nullptr;
+        }
+    }
+
+    t_storage m_cache[prealloc];
+    t_storage* m_first = &m_cache[0];
+    size_t m_size = 0;
+
+    int64_t m_null = reinterpret_cast<int64_t>(&m_null); // choose magic value to represent nulls
+};
+
+// Double
+// NOTE: fails in gcc 4.8 without `inline`. Do not remove. Same applies for all methods below.
+template<>
+inline bool NullableVector<double>::is_null(size_t index) const
+{
+    return null::is_null_float(m_first[index]);
+}
+
+template<>
+inline void NullableVector<double>::set_null(size_t index)
+{
+    m_first[index] = null::get_null_float<double>();
+}
+
+// Float
+template<>
+inline bool NullableVector<float>::is_null(size_t index) const
+{
+    return null::is_null_float(m_first[index]);
+}
+
+template<>
+inline void NullableVector<float>::set_null(size_t index)
+{
+    m_first[index] = null::get_null_float<float>();
+}
+
+
+// Null
+template<>
+inline void NullableVector<null>::set_null(size_t)
+{
+    return;
+}
+template<>
+inline bool NullableVector<null>::is_null(size_t) const
+{
+    return true;
+}
+
+
+// OldDateTime
+template<>
+inline bool NullableVector<OldDateTime>::is_null(size_t index) const
+{
+    return m_first[index].get_olddatetime() == m_null;
+}
+
+
+template<>
+inline void NullableVector<OldDateTime>::set_null(size_t index)
+{
+    m_first[index] = m_null;
+}
+
+// StringData
+
+template<>
+inline bool NullableVector<StringData>::is_null(size_t index) const
+{
+    return m_first[index].is_null();
+}
+
+template<>
+inline void NullableVector<StringData>::set_null(size_t index)
+{
+    m_first[index] = StringData();
+}
+
+// BinaryData
+
+template<>
+inline bool NullableVector<BinaryData>::is_null(size_t index) const
+{
+    return m_first[index].is_null();
+}
+
+template<>
+inline void NullableVector<BinaryData>::set_null(size_t index)
+{
+    m_first[index] = BinaryData();
+}
+
+// RowIndex
+template<>
+inline bool NullableVector<RowIndex>::is_null(size_t index) const
+{
+    return m_first[index].is_null();
+}
+template<>
+inline void NullableVector<RowIndex>::set_null(size_t index)
+{
+    m_first[index] = RowIndex();
+}
+
+
+// Timestamp
+
+template<>
+inline bool NullableVector<Timestamp>::is_null(size_t index) const
+{
+    return m_first[index].is_null();
+}
+
+template<>
+inline void NullableVector<Timestamp>::set_null(size_t index)
+{
+    m_first[index] = Timestamp(null{});
+}
+
+
+template<typename Operator>
+struct OperatorOptionalAdapter {
+    template<typename L, typename R>
+    util::Optional<typename Operator::type> operator()(const util::Optional<L>& left, const util::Optional<R>& right)
+    {
+        if (!left || !right)
+            return util::none;
+        return Operator()(*left, *right);
+    }
+
+    template<typename T>
+    util::Optional<typename Operator::type> operator()(const util::Optional<T>& arg)
+    {
+        if (!arg)
+            return util::none;
+        return Operator()(*arg);
+    }
+};
+
+// Stores N values of type T. Can also exchange data with other ValueBase of different types
+template<class T>
+class Value : public ValueBase, public Subexpr2<T>
+{
+public:
+    Value()
+    {
+        init(false, ValueBase::default_size, T());
+    }
+    Value(T v)
+    {
+        init(false, ValueBase::default_size, v);
+    }
+
+    Value(bool from_link_list, size_t values)
+    {
+        init(from_link_list, values, T());
+    }
+
+    Value(bool from_link_list, size_t values, T v)
+    {
+        init(from_link_list, values, v);
+    }
+
+    Value(const Value&) = default;
+    Value& operator=(const Value&) = default;
+
+    void init(bool from_link_list, size_t values, T v) {
+        m_storage.init(values, v);
+        ValueBase::m_from_link_list = from_link_list;
+        ValueBase::m_values = values;
+    }
+
+    void init(bool from_link_list, size_t values) {
+        m_storage.init(values);
+        ValueBase::m_from_link_list = from_link_list;
+        ValueBase::m_values = values;
+    }
+
+    void evaluate(size_t, ValueBase& destination) override
+    {
+        destination.import(*this);
+    }
+
+
+    template<class TOperator>
+    REALM_FORCEINLINE void fun(const Value* left, const Value* right)
+    {
+        OperatorOptionalAdapter<TOperator> o;
+
+        if (!left->m_from_link_list && !right->m_from_link_list) {
+            // Operate on values one-by-one (one value is one row; no links)
+            size_t min = std::min(left->m_values, right->m_values);
+            init(false, min);
+
+            for (size_t i = 0; i < min; i++) {
+                m_storage.set(i, o(left->m_storage.get(i), right->m_storage.get(i)));
+            }
+        }
+        else if (left->m_from_link_list && right->m_from_link_list) {
+            // FIXME: Many-to-many links not supported yet. Need to specify behaviour
+            REALM_ASSERT_DEBUG(false);
+        }
+        else if (!left->m_from_link_list && right->m_from_link_list) {
+            // Right values come from link. Left must come from single row.
+            REALM_ASSERT_DEBUG(left->m_values > 0);
+            init(true, right->m_values);
+
+            auto left_value = left->m_storage.get(0);
+            for (size_t i = 0; i < right->m_values; i++) {
+                m_storage.set(i, o(left_value, right->m_storage.get(i)));
+            }
+        }
+        else if (left->m_from_link_list && !right->m_from_link_list) {
+            // Same as above, but with left values coming from links
+            REALM_ASSERT_DEBUG(right->m_values > 0);
+            init(true, left->m_values);
+
+            auto right_value = right->m_storage.get(0);
+            for (size_t i = 0; i < left->m_values; i++) {
+                m_storage.set(i, o(left->m_storage.get(i), right_value));
+            }
+        }
+    }
+
+    template<class TOperator>
+    REALM_FORCEINLINE void fun(const Value* value)
+    {
+        init(value->m_from_link_list, value->m_values);
+
+        OperatorOptionalAdapter<TOperator> o;
+        for (size_t i = 0; i < value->m_values; i++) {
+            m_storage.set(i, o(value->m_storage.get(i)));
+        }
+    }
+
+
+    // Below import and export methods are for type conversion between float, double, int64_t, etc.
+    template<class D>
+    typename std::enable_if<std::is_convertible<T, D>::value>::type
+    REALM_FORCEINLINE export2(ValueBase& destination) const
+    {
+        Value<D>& d = static_cast<Value<D>&>(destination);
+        d.init(ValueBase::m_from_link_list, ValueBase::m_values, D());
+        for (size_t t = 0; t < ValueBase::m_values; t++) {
+            if (m_storage.is_null(t))
+                d.m_storage.set_null(t);
+            else {
+                d.m_storage.set(t, static_cast<D>(m_storage[t]));
+            }
+        }
+    }
+
+    template<class D>
+    typename std::enable_if<!std::is_convertible<T, D>::value>::type
+    REALM_FORCEINLINE export2(ValueBase&) const
+    {
+        // export2 is instantiated for impossible conversions like T=StringData, D=int64_t. These are never
+        // performed at runtime but would result in a compiler error if we did not provide this implementation.
+        REALM_ASSERT_DEBUG(false);
+    }
+
+    REALM_FORCEINLINE void export_Timestamp(ValueBase& destination) const override
+    {
+        export2<Timestamp>(destination);
+    }
+
+    REALM_FORCEINLINE void export_bool(ValueBase& destination) const override
+    {
+        export2<bool>(destination);
+    }
+
+    REALM_FORCEINLINE void export_int64_t(ValueBase& destination) const override
+    {
+        export2<int64_t>(destination);
+    }
+
+    REALM_FORCEINLINE void export_float(ValueBase& destination) const override
+    {
+        export2<float>(destination);
+    }
+
+    REALM_FORCEINLINE void export_int(ValueBase& destination) const override
+    {
+        export2<int>(destination);
+    }
+
+    REALM_FORCEINLINE void export_double(ValueBase& destination) const override
+    {
+        export2<double>(destination);
+    }
+    REALM_FORCEINLINE void export_StringData(ValueBase& destination) const override
+    {
+        export2<StringData>(destination);
+    }
+    REALM_FORCEINLINE void export_BinaryData(ValueBase& destination) const override
+    {
+        export2<BinaryData>(destination);
+    }
+    REALM_FORCEINLINE void export_RowIndex(ValueBase& destination) const override
+    {
+        export2<RowIndex>(destination);
+    }
+    REALM_FORCEINLINE void export_null(ValueBase& destination) const override
+    {
+        Value<null>& d = static_cast<Value<null>&>(destination);
+        d.init(m_from_link_list, m_values);
+    }
+
+    REALM_FORCEINLINE void import(const ValueBase& source) override
+    {
+        if (std::is_same<T, int>::value)
+            source.export_int(*this);
+        else if (std::is_same<T, Timestamp>::value)
+            source.export_Timestamp(*this);
+        else if (std::is_same<T, bool>::value)
+            source.export_bool(*this);
+        else if (std::is_same<T, float>::value)
+            source.export_float(*this);
+        else if (std::is_same<T, double>::value)
+            source.export_double(*this);
+        else if (std::is_same<T, int64_t>::value || std::is_same<T, bool>::value ||  std::is_same<T, OldDateTime>::value)
+            source.export_int64_t(*this);
+        else if (std::is_same<T, StringData>::value)
+            source.export_StringData(*this);
+        else if (std::is_same<T, BinaryData>::value)
+            source.export_BinaryData(*this);
+        else if (std::is_same<T, RowIndex>::value)
+            source.export_RowIndex(*this);
+        else if (std::is_same<T, null>::value)
+            source.export_null(*this);
+        else
+            REALM_ASSERT_DEBUG(false);
+    }
+
+    // Given a TCond (==, !=, >, <, >=, <=) and two Value<T>, return index of first match
+    template<class TCond>
+    REALM_FORCEINLINE static size_t compare(Value<T>* left, Value<T>* right)
+    {
+        TCond c;
+
+        if (!left->m_from_link_list && !right->m_from_link_list) {
+            // Compare values one-by-one (one value is one row; no link lists)
+            size_t min = minimum(left->ValueBase::m_values, right->ValueBase::m_values);
+            for (size_t m = 0; m < min; m++) {
+
+                if (c(left->m_storage[m], right->m_storage[m], left->m_storage.is_null(m), right->m_storage.is_null(m)))
+                    return m;
+            }
+        }
+        else if (left->m_from_link_list && right->m_from_link_list) {
+            // FIXME: Many-to-many links not supported yet. Need to specify behaviour
+            REALM_ASSERT_DEBUG(false);
+        }
+        else if (!left->m_from_link_list && right->m_from_link_list) {
+            // Right values come from link list. Left must come from single row. Semantics: Match if at least 1
+            // linked-to-value fulfills the condition
+            REALM_ASSERT_DEBUG(left->m_values > 0);
+            for (size_t r = 0; r < right->m_values; r++) {
+                if (c(left->m_storage[0], right->m_storage[r], left->m_storage.is_null(0), right->m_storage.is_null(r)))
+                    return 0;
+            }
+        }
+        else if (left->m_from_link_list && !right->m_from_link_list) {
+            // Same as above, but with left values coming from link list.
+            REALM_ASSERT_DEBUG(right->m_values > 0);
+            for (size_t l = 0; l < left->m_values; l++) {
+                if (c(left->m_storage[l], right->m_storage[0], left->m_storage.is_null(l), right->m_storage.is_null(0)))
+                    return 0;
+            }
+        }
+
+        return not_found; // no match
+    }
+
+    std::unique_ptr<Subexpr> clone(QueryNodeHandoverPatches*) const override
+    {
+        return make_subexpr<Value<T>>(*this);
+    }
+
+    NullableVector<T> m_storage;
+};
+
+class ConstantStringValue : public Value<StringData>
+{
+public:
+    ConstantStringValue(const StringData& string) : Value(),
+        m_string(string.is_null() ? util::none : util::make_optional(std::string(string)))
+    {
+        init(false, ValueBase::default_size, m_string);
+    }
+
+    std::unique_ptr<Subexpr> clone(QueryNodeHandoverPatches*) const override
+    {
+        return std::unique_ptr<Subexpr>(new ConstantStringValue(*this));
+    }
+
+private:
+    ConstantStringValue(const ConstantStringValue& other) : Value(), m_string(other.m_string)
+    {
+        init(other.m_from_link_list, other.m_values, m_string);
+    }
+
+    util::Optional<std::string> m_string;
+};
+
+// All overloads where left-hand-side is L:
+//
+// left-hand-side       operator                              right-hand-side
+// L                    +, -, *, /, <, >, ==, !=, <=, >=      Subexpr2<R>
+//
+// For L = R = {int, int64_t, float, double, Timestamp}:
+// Compare numeric values
+template<class R>
+Query operator > (double left, const Subexpr2<R>& right) {
+    return create<double, Greater, R>(left, right);
+}
+template<class R>
+Query operator > (float left, const Subexpr2<R>& right) {
+    return create<float, Greater, R>(left, right);
+}
+template<class R>
+Query operator > (int left, const Subexpr2<R>& right) {
+    return create<int, Greater, R>(left, right);
+}
+template<class R>
+Query operator > (int64_t left, const Subexpr2<R>& right) {
+    return create<int64_t, Greater, R>(left, right);
+}
+template<class R>
+Query operator > (Timestamp left, const Subexpr2<R>& right) {
+    return create<Timestamp, Greater, R>(left, right);
+}
+
+template<class R>
+Query operator < (double left, const Subexpr2<R>& right) {
+    return create<float, Less, R>(left, right);
+}
+template<class R>
+Query operator < (float left, const Subexpr2<R>& right) {
+    return create<int, Less, R>(left, right);
+}
+template<class R>
+Query operator < (int left, const Subexpr2<R>& right) {
+    return create<int, Less, R>(left, right);
+}
+template<class R>
+Query operator < (int64_t left, const Subexpr2<R>& right) {
+    return create<int64_t, Less, R>(left, right);
+}
+template<class R>
+Query operator < (Timestamp left, const Subexpr2<R>& right) {
+    return create<Timestamp, Less, R>(left, right);
+}
+template<class R>
+Query operator == (double left, const Subexpr2<R>& right) {
+    return create<double, Equal, R>(left, right);
+}
+template<class R>
+Query operator == (float left, const Subexpr2<R>& right) {
+    return create<float, Equal, R>(left, right);
+}
+template<class R>
+Query operator == (int left, const Subexpr2<R>& right) {
+    return create<int, Equal, R>(left, right);
+}
+template<class R>
+Query operator == (int64_t left, const Subexpr2<R>& right) {
+    return create<int64_t, Equal, R>(left, right);
+}
+template<class R>
+Query operator == (Timestamp left, const Subexpr2<R>& right) {
+    return create<Timestamp, Equal, R>(left, right);
+}
+template<class R>
+Query operator >= (double left, const Subexpr2<R>& right) {
+    return create<double, GreaterEqual, R>(left, right);
+}
+template<class R>
+Query operator >= (float left, const Subexpr2<R>& right) {
+    return create<float, GreaterEqual, R>(left, right);
+}
+template<class R>
+Query operator >= (int left, const Subexpr2<R>& right) {
+    return create<int, GreaterEqual, R>(left, right);
+}
+template<class R>
+Query operator >= (int64_t left, const Subexpr2<R>& right) {
+    return create<int64_t, GreaterEqual, R>(left, right);
+}
+template<class R>
+Query operator >= (Timestamp left, const Subexpr2<R>& right) {
+    return create<Timestamp, GreaterEqual, R>(left, right);
+}
+template<class R>
+Query operator <= (double left, const Subexpr2<R>& right) {
+    return create<double, LessEqual, R>(left, right);
+}
+template<class R>
+Query operator <= (float left, const Subexpr2<R>& right) {
+    return create<float, LessEqual, R>(left, right);
+}
+template<class R>
+Query operator <= (int left, const Subexpr2<R>& right) {
+    return create<int, LessEqual, R>(left, right);
+}
+template<class R>
+Query operator <= (int64_t left, const Subexpr2<R>& right) {
+    return create<int64_t, LessEqual, R>(left, right);
+}
+template<class R>
+Query operator <= (Timestamp left, const Subexpr2<R>& right) {
+    return create<Timestamp, LessEqual, R>(left, right);
+}
+template<class R>
+Query operator != (double left, const Subexpr2<R>& right) {
+    return create<double, NotEqual, R>(left, right);
+}
+template<class R>
+Query operator != (float left, const Subexpr2<R>& right) {
+    return create<float, NotEqual, R>(left, right);
+}
+template<class R>
+Query operator != (int left, const Subexpr2<R>& right) {
+    return create<int, NotEqual, R>(left, right);
+}
+template<class R>
+Query operator != (int64_t left, const Subexpr2<R>& right) {
+    return create<int64_t, NotEqual, R>(left, right);
+}
+template<class R>
+Query operator != (Timestamp left, const Subexpr2<R>& right) {
+    return create<Timestamp, NotEqual, R>(left, right);
+}
+
+// Arithmetic
+template<class R>
+Operator<Plus<typename Common<R, double>::type>> operator + (double left, const Subexpr2<R>& right) {
+    return { make_subexpr<Value<double>>(left), right.clone() };
+}
+template<class R>
+Operator<Plus<typename Common<R, float>::type>> operator + (float left, const Subexpr2<R>& right) {
+    return { make_subexpr<Value<float>>(left), right.clone() };
+}
+template<class R>
+Operator<Plus<typename Common<R, int>::type>> operator + (int left, const Subexpr2<R>& right) {
+    return { make_subexpr<Value<int>>(left), right.clone() };
+}
+template<class R>
+Operator<Plus<typename Common<R, int64_t>::type>> operator + (int64_t left, const Subexpr2<R>& right) {
+    return { make_subexpr<Value<int64_t>>(left), right.clone() };
+}
+template<class R>
+Operator<Minus<typename Common<R, double>::type>> operator - (double left, const Subexpr2<R>& right) {
+    return { make_subexpr<Value<double>>(left), right.clone() };
+}
+template<class R>
+Operator<Minus<typename Common<R, float>::type>> operator - (float left, const Subexpr2<R>& right) {
+    return { make_subexpr<Value<float>>(left), right.clone() };
+}
+template<class R>
+Operator<Minus<typename Common<R, int>::type>> operator - (int left, const Subexpr2<R>& right) {
+    return { make_subexpr<Value<int>>(left), right.clone() };
+}
+template<class R>
+Operator<Minus<typename Common<R, int64_t>::type>> operator - (int64_t left, const Subexpr2<R>& right) {
+    return { make_subexpr<Value<int64_t>>(left), right.clone() };
+}
+template<class R>
+Operator<Mul<typename Common<R, double>::type>> operator * (double left, const Subexpr2<R>& right) {
+    return { make_subexpr<Value<double>>(left), right.clone() };
+}
+template<class R>
+Operator<Mul<typename Common<R, float>::type>> operator * (float left, const Subexpr2<R>& right) {
+    return { make_subexpr<Value<float>>(left), right.clone() };
+}
+template<class R>
+Operator<Mul<typename Common<R, int>::type>> operator * (int left, const Subexpr2<R>& right) {
+    return { make_subexpr<Value<int>>(left), right.clone() };
+}
+template<class R>
+Operator<Mul<typename Common<R, int64_t>::type>> operator * (int64_t left, const Subexpr2<R>& right) {
+    return { make_subexpr<Value<int64_t>>(left), right.clone() };
+}
+template<class R>
+Operator<Div<typename Common<R, double>::type>> operator / (double left, const Subexpr2<R>& right) {
+    return { make_subexpr<Value<double>>(left), right.clone() };
+}
+template<class R>
+Operator<Div<typename Common<R, float>::type>> operator / (float left, const Subexpr2<R>& right) {
+    return { make_subexpr<Value<float>>(left), right.clone() };
+}
+template<class R>
+Operator<Div<typename Common<R, int>::type>> operator / (int left, const Subexpr2<R>& right) {
+    return { make_subexpr<Value<int>>(left), right.clone() };
+}
+template<class R>
+Operator<Div<typename Common<R, int64_t>::type>> operator / (int64_t left, const Subexpr2<R>& right) {
+    return { make_subexpr<Value<int64_t>>(left), right.clone() };
+}
+
+// Unary operators
+template<class T>
+UnaryOperator<Pow<T>> power (const Subexpr2<T>& left) {
+    return { left.clone() };
+}
+
+
+
+// Classes used for LinkMap (see below).
+struct LinkMapFunction
+{
+    // Your consume() method is given row index of the linked-to table as argument, and you must return whether or
+    // not you want the LinkMapFunction to exit (return false) or continue (return true) harvesting the link tree
+    // for the current main table row index (it will be a link tree if you have multiple type_LinkList columns
+    // in a link()->link() query.
+    virtual bool consume(size_t row_index) = 0;
+};
+
+struct FindNullLinks : public LinkMapFunction
+{
+    FindNullLinks() : m_has_link(false) {}
+
+    bool consume(size_t row_index) override
+    {
+        static_cast<void>(row_index);
+        m_has_link = true;
+        return false; // we've found a row index, so this can't be a null-link, so exit link harvesting
+    }
+
+    bool m_has_link;
+};
+
+struct MakeLinkVector : public LinkMapFunction
+{
+    MakeLinkVector(std::vector<size_t>& result) : m_links(result) {}
+
+    bool consume(size_t row_index) override
+    {
+        m_links.push_back(row_index);
+        return true; // continue evaluation
+    }
+    std::vector<size_t> &m_links;
+};
+
+struct CountLinks : public LinkMapFunction
+{
+    bool consume(size_t) override
+    {
+        m_link_count++;
+        return true;
+    }
+
+    size_t result() const { return m_link_count; }
+
+    size_t m_link_count = 0;
+};
+
+
+/*
+The LinkMap and LinkMapFunction classes are used for query conditions on links themselves (contrary to conditions on
+the value payload they point at).
+
+MapLink::map_links() takes a row index of the link column as argument and follows any link chain stated in the query
+(through the link()->link() methods) until the final payload table is reached, and then applies LinkMapFunction on
+the linked-to row index(es).
+
+If all link columns are type_Link, then LinkMapFunction is only invoked for a single row index. If one or more
+columns are type_LinkList, then it may result in multiple row indexes.
+
+The reason we use this map pattern is that we can exit the link-tree-traversal as early as possible, e.g. when we've
+found the first link that points to row '5'. Other solutions could be a std::vector<size_t> harvest_all_links(), or an
+iterator pattern. First solution can't exit, second solution requires internal state.
+*/
+class LinkMap
+{
+public:
+    LinkMap() = default;
+    LinkMap(const Table* table, const std::vector<size_t>& columns) : m_link_column_indexes(columns)
+    {
+        set_base_table(table);
+    }
+
+    void set_base_table(const Table* table)
+    {
+        if (table == m_base_table)
+            return;
+
+        m_base_table = table;
+        m_link_columns.clear();
+        m_link_types.clear();
+        m_only_unary_links = true;
+
+        for (size_t link_column_index : m_link_column_indexes) {
+            // Link column can be either LinkList or single Link
+            ColumnType type = table->get_real_column_type(link_column_index);
+            REALM_ASSERT(Table::is_link_type(type) || type == col_type_BackLink);
+            m_link_types.push_back(type);
+
+            if (type == col_type_LinkList) {
+                const LinkListColumn& cll = table->get_column_link_list(link_column_index);
+                m_link_columns.push_back(&cll);
+                m_only_unary_links = false;
+                table = &cll.get_target_table();
+            }
+            else if (type == col_type_Link) {
+                const LinkColumn& cl = table->get_column_link(link_column_index);
+                m_link_columns.push_back(&cl);
+                table = &cl.get_target_table();
+            }
+            else if (type == col_type_BackLink) {
+                const BacklinkColumn& bl = table->get_column_backlink(link_column_index);
+                m_link_columns.push_back(&bl);
+                m_only_unary_links = false;
+                table = &bl.get_origin_table();
+            }
+        }
+
+        m_target_table = table;
+    }
+
+    std::vector<size_t> get_links(size_t index)
+    {
+        std::vector<size_t> res;
+        get_links(index, res);
+        return res;
+    }
+
+    size_t count_links(size_t row)
+    {
+        CountLinks counter;
+        map_links(row, counter);
+        return counter.result();
+    }
+
+    void map_links(size_t row, LinkMapFunction& lm)
+    {
+        map_links(0, row, lm);
+    }
+
+    bool only_unary_links() const
+    {
+        return m_only_unary_links;
+    }
+
+    const Table* base_table() const
+    {
+        return m_base_table;
+    }
+
+    const Table* target_table() const
+    {
+        return m_target_table;
+    }
+
+    std::vector<const ColumnBase*> m_link_columns;
+
+private:
+    void map_links(size_t column, size_t row, LinkMapFunction& lm)
+    {
+        bool last = (column + 1 == m_link_columns.size());
+        ColumnType type = m_link_types[column];
+        if (type == col_type_Link) {
+            const LinkColumn& cl = *static_cast<const LinkColumn*>(m_link_columns[column]);
+            size_t r = to_size_t(cl.get(row));
+            if (r == 0)
+                return;
+            r--; // LinkColumn stores link to row N as N + 1
+            if (last) {
+                bool continue2 = lm.consume(r);
+                if (!continue2)
+                    return;
+            }
+            else
+                map_links(column + 1, r, lm);
+        }
+        else if (type == col_type_LinkList) {
+            const LinkListColumn& cll = *static_cast<const LinkListColumn*>(m_link_columns[column]);
+            ConstLinkViewRef lvr = cll.get(row);
+            for (size_t t = 0; t < lvr->size(); t++) {
+                size_t r = lvr->get(t).get_index();
+                if (last) {
+                    bool continue2 = lm.consume(r);
+                    if (!continue2)
+                        return;
+                }
+                else
+                    map_links(column + 1, r, lm);
+            }
+        }
+        else if (type == col_type_BackLink) {
+            const BacklinkColumn& bl = *static_cast<const BacklinkColumn*>(m_link_columns[column]);
+            size_t count = bl.get_backlink_count(row);
+            for (size_t i = 0; i < count; ++i) {
+                size_t r = bl.get_backlink(row, i);
+                if (last) {
+                    bool continue2 = lm.consume(r);
+                    if (!continue2)
+                        return;
+                } else
+                    map_links(column + 1, r, lm);
+            }
+        }
+    }
+
+
+    void get_links(size_t row, std::vector<size_t>& result)
+    {
+        MakeLinkVector mlv = MakeLinkVector(result);
+        map_links(row, mlv);
+    }
+
+    std::vector<size_t> m_link_column_indexes;
+    std::vector<ColumnType> m_link_types;
+    const Table* m_base_table = nullptr;
+    const Table* m_target_table = nullptr;
+    bool m_only_unary_links = true;
+
+    template <class>
+    friend Query compare(const Subexpr2<Link>&, const ConstRow&);
+};
+
+template<class T, class S, class I>
+Query string_compare(const Columns<StringData>& left, T right, bool case_insensitive);
+template<class S, class I>
+Query string_compare(const Columns<StringData>& left, const Columns<StringData>& right, bool case_insensitive);
+
+template<class T>
+Value<T> make_value_for_link(bool only_unary_links, size_t size)
+{
+    Value<T> value;
+    if (only_unary_links) {
+        REALM_ASSERT(size <= 1);
+        value.init(false, 1);
+        value.m_storage.set_null(0);
+    }
+    else {
+        value.init(true, size);
+    }
+    return value;
+}
+
+
+// If we add a new Realm type T and quickly want Query support for it, then simply inherit from it like
+// `template <> class Columns<T> : public SimpleQuerySupport<T>` and you're done. Any operators of the set
+// { ==, >=, <=, !=, >, < } that are supported by T will be supported by the "query expression syntax"
+// automatically. NOTE: This method of Query support will be slow because it goes through Table::get<T>.
+// To get faster Query support, either add SequentialGetter support (faster) or create a query_engine.hpp
+// node for it (super fast).
+
+template <class T>
+class SimpleQuerySupport : public Subexpr2<T> {
+public:
+    SimpleQuerySupport(size_t column, const Table* table, const std::vector<size_t>& links = {}) :
+        m_column(column), m_link_map(table, links)
+    {
+    }
+
+    bool is_nullable() const noexcept
+    {
+        return m_link_map.base_table()->is_nullable(m_column);
+    }
+
+    const Table* get_base_table() const override
+    {
+        return m_link_map.base_table();
+    }
+
+    void set_base_table(const Table* table) override
+    {
+        m_link_map.set_base_table(table);
+    }
+
+    void evaluate(size_t index, ValueBase& destination) override
+    {
+        Value<T>& d = static_cast<Value<T>&>(destination);
+
+        if (links_exist()) {
+            std::vector<size_t> links = m_link_map.get_links(index);
+            Value<T> v = make_value_for_link<T>(m_link_map.only_unary_links(), links.size());
+
+            for (size_t t = 0; t < links.size(); t++) {
+                size_t link_to = links[t];
+                v.m_storage.set(t, m_link_map.target_table()->template get<T>(m_column, link_to));
+            }
+            destination.import(v);
+        }
+        else {
+            // Not a link column
+            const Table* target_table = m_link_map.target_table();
+            for (size_t t = 0; t < destination.m_values && index + t < target_table->size(); t++) {
+                d.m_storage.set(t, target_table->get<T>(m_column, index + t));
+            }
+        }
+    }
+
+    bool links_exist() const
+    {
+        return m_link_map.m_link_columns.size() > 0;
+    }
+
+    // Column index of payload column of m_table
+    size_t m_column;
+    LinkMap m_link_map;
+};
+
+
+template <>
+class Columns<Timestamp> : public SimpleQuerySupport<Timestamp> {
+    using SimpleQuerySupport::SimpleQuerySupport;
+    std::unique_ptr<Subexpr> clone(QueryNodeHandoverPatches*) const override
+    {
+        return make_subexpr<Columns<Timestamp>>(*this);
+    }
+};
+
+template <>
+class Columns<BinaryData> : public SimpleQuerySupport<BinaryData> {
+    using SimpleQuerySupport::SimpleQuerySupport;
+    std::unique_ptr<Subexpr> clone(QueryNodeHandoverPatches*) const override
+    {
+        return make_subexpr<Columns<BinaryData>>(*this);
+    }
+};
+
+
+template <>
+class Columns<StringData> : public SimpleQuerySupport<StringData> {
+public:
+    using SimpleQuerySupport::SimpleQuerySupport;
+    std::unique_ptr<Subexpr> clone(QueryNodeHandoverPatches* = nullptr) const override
+    {
+        return make_subexpr<Columns<StringData>>(*this);
+    }
+
+    Query equal(StringData sd, bool case_sensitive = true)
+    {
+        return string_compare<StringData, Equal, EqualIns>(*this, sd, case_sensitive);
+    }
+
+    Query equal(const Columns<StringData>& col, bool case_sensitive = true)
+    {
+        return string_compare<Equal, EqualIns>(*this, col, case_sensitive);
+    }
+
+    Query not_equal(StringData sd, bool case_sensitive = true)
+    {
+        return string_compare<StringData, NotEqual, NotEqualIns>(*this, sd, case_sensitive);
+    }
+
+    Query not_equal(const Columns<StringData>& col, bool case_sensitive = true)
+    {
+        return string_compare<NotEqual, NotEqualIns>(*this, col, case_sensitive);
+    }
+
+    Query begins_with(StringData sd, bool case_sensitive = true)
+    {
+        return string_compare<StringData, BeginsWith, BeginsWithIns>(*this, sd, case_sensitive);
+    }
+
+    Query begins_with(const Columns<StringData>& col, bool case_sensitive = true)
+    {
+        return string_compare<BeginsWith, BeginsWithIns>(*this, col, case_sensitive);
+    }
+
+    Query ends_with(StringData sd, bool case_sensitive = true)
+    {
+        return string_compare<StringData, EndsWith, EndsWithIns>(*this, sd, case_sensitive);
+    }
+
+    Query ends_with(const Columns<StringData>& col, bool case_sensitive = true)
+    {
+        return string_compare<EndsWith, EndsWithIns>(*this, col, case_sensitive);
+    }
+
+    Query contains(StringData sd, bool case_sensitive = true)
+    {
+        return string_compare<StringData, Contains, ContainsIns>(*this, sd, case_sensitive);
+    }
+
+    Query contains(const Columns<StringData>& col, bool case_sensitive = true)
+    {
+        return string_compare<Contains, ContainsIns>(*this, col, case_sensitive);
+    }
+};
+
+
+template<class T, class S, class I>
+Query string_compare(const Columns<StringData>& left, T right, bool case_sensitive)
+{
+    StringData sd(right);
+    if (case_sensitive)
+        return create<StringData, S, StringData>(sd, left);
+    else
+        return create<StringData, I, StringData>(sd, left);
+}
+
+template<class S, class I>
+Query string_compare(const Columns<StringData>& left, const Columns<StringData>& right, bool case_sensitive)
+{
+    if (case_sensitive)
+        return make_expression<Compare<S, StringData>>(right.clone(), left.clone());
+    else
+        return make_expression<Compare<I, StringData>>(right.clone(), left.clone());
+}
+
+// Columns<String> == Columns<String>
+inline Query operator == (const Columns<StringData>& left, const Columns<StringData>& right) {
+    return string_compare<Equal, EqualIns>(left, right, true);
+}
+
+// Columns<String> != Columns<String>
+inline Query operator != (const Columns<StringData>& left, const Columns<StringData>& right) {
+    return string_compare<NotEqual, NotEqualIns>(left, right, true);
+}
+
+// String == Columns<String>
+template<class T>
+Query operator == (T left, const Columns<StringData>& right) {
+    return operator==(right, left);
+}
+
+// String != Columns<String>
+template<class T>
+Query operator != (T left, const Columns<StringData>& right) {
+    return operator!=(right, left);
+}
+
+// Columns<String> == String
+template<class T>
+Query operator == (const Columns<StringData>& left, T right) {
+    return string_compare<T, Equal, EqualIns>(left, right, true);
+}
+
+// Columns<String> != String
+template<class T>
+Query operator != (const Columns<StringData>& left, T right) {
+    return string_compare<T, NotEqual, NotEqualIns>(left, right, true);
+}
+
+
+
+inline Query operator==(const Columns<BinaryData>& left, BinaryData right) {
+    return create<BinaryData, Equal, BinaryData>(right, left);
+}
+
+inline Query operator==(BinaryData left, const Columns<BinaryData>& right) {
+    return create<BinaryData, Equal, BinaryData>(left, right);
+}
+
+inline Query operator!=(const Columns<BinaryData>& left, BinaryData right) {
+    return create<BinaryData, NotEqual, BinaryData>(right, left);
+}
+
+inline Query operator!=(BinaryData left, const Columns<BinaryData>& right) {
+    return create<BinaryData, NotEqual, BinaryData>(left, right);
+}
+
+
+// This class is intended to perform queries on the *pointers* of links, contrary to performing queries on *payload*
+// in linked-to tables. Queries can be "find first link that points at row X" or "find first null-link". Currently
+// only "find first null link" and "find first non-null link" is supported. More will be added later. When we add
+// more, I propose to remove the <bool has_links> template argument from this class and instead template it by
+// a criteria-class (like the FindNullLinks class below in find_first()) in some generalized fashion.
+template<bool has_links>
+class UnaryLinkCompare : public Expression
+{
+public:
+    UnaryLinkCompare(LinkMap lm) : m_link_map(lm)
+    {
+    }
+
+    void set_base_table(const Table* table) override
+    {
+        m_link_map.set_base_table(table);
+    }
+
+    // Return main table of query (table on which table->where()... is invoked). Note that this is not the same as
+    // any linked-to payload tables
+    const Table* get_base_table() const override
+    {
+        return m_link_map.base_table();
+    }
+
+    size_t find_first(size_t start, size_t end) const override
+    {
+        for (; start < end;) {
+            std::vector<size_t> l = m_link_map.get_links(start);
+            // We have found a Link which is NULL, or LinkList with 0 entries. Return it as match.
+
+            FindNullLinks fnl;
+            m_link_map.map_links(start, fnl);
+            if (fnl.m_has_link == has_links)
+                return start;
+
+            start++;
+        }
+
+        return not_found;
+    }
+
+    std::unique_ptr<Expression> clone(QueryNodeHandoverPatches*) const override
+    {
+        return std::unique_ptr<Expression>(new UnaryLinkCompare(*this));
+    }
+
+private:
+    UnaryLinkCompare(const UnaryLinkCompare&) = default;
+
+    mutable LinkMap m_link_map;
+};
+
+class LinkCount : public Subexpr2<Int> {
+public:
+    LinkCount(LinkMap link_map): m_link_map(link_map) { }
+
+    std::unique_ptr<Subexpr> clone(QueryNodeHandoverPatches*) const override
+    {
+        return make_subexpr<LinkCount>(*this);
+    }
+
+    const Table* get_base_table() const override
+    {
+        return m_link_map.base_table();
+    }
+
+    void set_base_table(const Table* table) override
+    {
+        m_link_map.set_base_table(table);
+    }
+
+    void evaluate(size_t index, ValueBase& destination) override
+    {
+        size_t count = m_link_map.count_links(index);
+        destination.import(Value<Int>(false, 1, count));
+    }
+
+private:
+    LinkMap m_link_map;
+};
+
+struct ConstantRowValueHandoverPatch : public QueryNodeHandoverPatch {
+    std::unique_ptr<RowBaseHandoverPatch> row_patch;
+};
+
+class ConstantRowValue : public Subexpr2<Link> {
+public:
+    ConstantRowValue(const ConstRow& row) : m_row(row) { }
+
+    void set_base_table(const Table*) override { }
+    const Table* get_base_table() const override { return nullptr; }
+
+    void evaluate(size_t, ValueBase& destination) override
+    {
+        if (m_row.is_attached()) {
+            Value<RowIndex> v(RowIndex(m_row.get_index()));
+            destination.import(v);
+        } else {
+            Value<RowIndex> v(RowIndex::Detached);
+            destination.import(v);
+        }
+    }
+
+    std::unique_ptr<Subexpr> clone(QueryNodeHandoverPatches* patches) const override
+    {
+        return std::unique_ptr<Subexpr>(new ConstantRowValue(*this, patches));
+    }
+
+    void apply_handover_patch(QueryNodeHandoverPatches& patches, Group& group) override
+    {
+        REALM_ASSERT(patches.size());
+        std::unique_ptr<QueryNodeHandoverPatch> abstract_patch = std::move(patches.back());
+        patches.pop_back();
+
+        auto patch = dynamic_cast<ConstantRowValueHandoverPatch*>(abstract_patch.get());
+        REALM_ASSERT(patch);
+
+        m_row.apply_and_consume_patch(patch->row_patch, group);
+    }
+
+private:
+    ConstantRowValue(const ConstantRowValue& source, QueryNodeHandoverPatches* patches)
+    : m_row(patches ? ConstRow() : source.m_row)
+    {
+        if (!patches)
+            return;
+
+        std::unique_ptr<ConstantRowValueHandoverPatch> patch(new ConstantRowValueHandoverPatch);
+        ConstRow::generate_patch(source.m_row, patch->row_patch);
+        patches->emplace_back(patch.release());
+    }
+
+    ConstRow m_row;
+};
+
+template<typename T>
+class SubColumns;
+
+// This is for LinkList and BackLink too since they're declared as typedefs of Link.
+template <> class Columns<Link> : public Subexpr2<Link>
+{
+public:
+    Query is_null() {
+        if (m_link_map.m_link_columns.size() > 1)
+            throw std::runtime_error("Combining link() and is_null() is currently not supported");
+        // Todo, it may be useful to support the above, but we would need to figure out an intuitive behaviour
+        return make_expression<UnaryLinkCompare<false>>(m_link_map);
+    }
+
+    Query is_not_null() {
+        if (m_link_map.m_link_columns.size() > 1)
+            throw std::runtime_error("Combining link() and is_not_null() is currently not supported");
+        // Todo, it may be useful to support the above, but we would need to figure out an intuitive behaviour
+        return make_expression<UnaryLinkCompare<true>>(m_link_map);
+    }
+
+    LinkCount count() const
+    {
+        return LinkCount(m_link_map);
+    }
+
+    template<typename C>
+    SubColumns<C> column(size_t column_ndx) const
+    {
+        return SubColumns<C>(Columns<C>(column_ndx, m_link_map.target_table()), m_link_map);
+    }
+
+    LinkMap link_map() const { return m_link_map; }
+
+    const Table* get_base_table() const override { return m_link_map.base_table(); }
+    void set_base_table(const Table* table) override { m_link_map.set_base_table(table); }
+
+    std::unique_ptr<Subexpr> clone(QueryNodeHandoverPatches*) const override
+    {
+        return make_subexpr<Columns<Link>>(*this);
+    }
+
+    void evaluate(size_t index, ValueBase& destination) override
+    {
+        std::vector<size_t> links = m_link_map.get_links(index);
+        Value<RowIndex> v = make_value_for_link<RowIndex>(m_link_map.only_unary_links(), links.size());
+
+        for (size_t t = 0; t < links.size(); t++) {
+            v.m_storage.set(t, RowIndex(links[t]));
+        }
+        destination.import(v);
+    }
+
+private:
+    Columns(size_t column_ndx, const Table* table, const std::vector<size_t>& links={}) :
+        m_link_map(table, links)
+    {
+        static_cast<void>(column_ndx);
+    }
+
+    LinkMap m_link_map;
+    friend class Table;
+};
+
+
+template <class Operator>
+Query compare(const Subexpr2<Link>& left, const ConstRow& row)
+{
+    static_assert(std::is_same<Operator, Equal>::value || std::is_same<Operator, NotEqual>::value,
+                  "Links can only be compared for equality.");
+    const Columns<Link>* column = dynamic_cast<const Columns<Link>*>(&left);
+    if (column) {
+        LinkMap link_map = column->link_map();
+        REALM_ASSERT(link_map.target_table() == row.get_table() || !row.is_attached());
+#ifdef REALM_OLDQUERY_FALLBACK
+        if (link_map.m_link_columns.size() == 1) {
+            // We can fall back to Query::links_to for != and == operations on links, but only
+            // for == on link lists. This is because negating query.links_to() is equivalent to
+            // to "ALL linklist != row" rather than the "ANY linklist != row" semantics we're after.
+            if (link_map.m_link_types[0] == col_type_Link ||
+                (link_map.m_link_types[0] == col_type_LinkList && std::is_same<Operator, Equal>::value)) {
+                const Table* t = column->get_base_table();
+                Query query(*t);
+
+                if (std::is_same<Operator, NotEqual>::value) {
+                    // Negate the following `links_to`.
+                    query.Not();
+                }
+                query.links_to(link_map.m_link_column_indexes[0], row);
+                return query;
+            }
+        }
+#endif
+    }
+    return make_expression<Compare<Operator, RowIndex>>(left.clone(), make_subexpr<ConstantRowValue>(row));
+}
+
+inline Query operator == (const Subexpr2<Link>& left, const ConstRow& row) { return compare<Equal>(left, row); }
+inline Query operator != (const Subexpr2<Link>& left, const ConstRow& row) { return compare<NotEqual>(left, row); }
+inline Query operator == (const ConstRow& row, const Subexpr2<Link>& right) { return compare<Equal>(right, row); }
+inline Query operator != (const ConstRow& row, const Subexpr2<Link>& right) { return compare<NotEqual>(right, row); }
+
+template <class Operator>
+Query compare(const Subexpr2<Link>& left, null)
+{
+    static_assert(std::is_same<Operator, Equal>::value || std::is_same<Operator, NotEqual>::value,
+                  "Links can only be compared for equality.");
+    return make_expression<Compare<Operator, RowIndex>>(left.clone(), make_subexpr<Value<RowIndex>>());
+}
+
+inline Query operator == (const Subexpr2<Link>& left, null) { return compare<Equal>(left, null()); }
+inline Query operator != (const Subexpr2<Link>& left, null) { return compare<NotEqual>(left, null()); }
+inline Query operator == (null, const Subexpr2<Link>& right) { return compare<Equal>(right, null()); }
+inline Query operator != (null, const Subexpr2<Link>& right) { return compare<NotEqual>(right, null()); }
+
+
+template<class T>
+class Columns : public Subexpr2<T>
+{
+public:
+    using ColType = typename ColumnTypeTraits<T>::column_type;
+
+    Columns(size_t column, const Table* table, const std::vector<size_t>& links={}):
+        m_link_map(table, links), m_column(column), m_nullable(m_link_map.target_table()->is_nullable(m_column))
+    {
+    }
+
+    Columns(const Columns& other):
+        m_link_map(other.m_link_map), m_column(other.m_column), m_nullable(other.m_nullable)
+    {
+    }
+
+    Columns& operator=(const Columns& other)
+    {
+        if (this != &other) {
+            m_link_map = other.m_link_map;
+            m_sg.reset();
+            m_column = other.m_column;
+            m_nullable = other.m_nullable;
+        }
+        return *this;
+    }
+
+    std::unique_ptr<Subexpr> clone(QueryNodeHandoverPatches*) const override
+    {
+        return make_subexpr<Columns<T>>(*this);
+    }
+
+    // See comment in base class
+    void set_base_table(const Table* table) override
+    {
+        m_link_map.set_base_table(table);
+
+        m_nullable = m_link_map.target_table()->is_nullable(m_column);
+        const ColumnBase* c = &m_link_map.target_table()->get_column_base(m_column);
+
+        if (m_sg == nullptr) {
+            if (m_nullable && std::is_same<int64_t, T>::value) {
+                m_sg.reset(new SequentialGetter<IntNullColumn>());
+            }
+            else {
+                m_sg.reset(new SequentialGetter<ColType>());
+            }
+        }
+
+        if (m_nullable && std::is_same<int64_t, T>::value) {
+            static_cast<SequentialGetter<IntNullColumn>&>(*m_sg).init(static_cast<const IntNullColumn*>(c));
+        }
+        else {
+            static_cast<SequentialGetter<ColType>&>(*m_sg).init(static_cast<const ColType*>(c));
+        }
+    }
+
+
+    // Recursively fetch tables of columns in expression tree. Used when user first builds a stand-alone expression
+    // and binds it to a Query at a later time
+    const Table* get_base_table() const override
+    {
+        return m_link_map.base_table();
+    }
+
+    template<class ColType2 = ColType>
+    void evaluate_internal(size_t index, ValueBase& destination) {
+        using U = typename ColType2::value_type;
+        auto sgc = static_cast<SequentialGetter<ColType2>*>(m_sg.get());
+
+        if (links_exist()) {
+            // LinkList with more than 0 values. Create Value with payload for all fields
+
+            std::vector<size_t> links = m_link_map.get_links(index);
+            auto v = make_value_for_link<typename util::RemoveOptional<U>::type>(m_link_map.only_unary_links(), links.size());
+
+            for (size_t t = 0; t < links.size(); t++) {
+                size_t link_to = links[t];
+                sgc->cache_next(link_to);
+
+                if (sgc->m_column->is_null(link_to))
+                    v.m_storage.set_null(t);
+                else
+                    v.m_storage.set(t, sgc->get_next(link_to));
+            }
+            destination.import(v);
+        }
+        else {
+            // Not a Link column
+            // make sequential getter load the respective leaf to access data at column row 'index'
+            sgc->cache_next(index);
+            size_t colsize = sgc->m_column->size();
+
+            // Now load `ValueBase::default_size` rows from from the leaf into m_storage. If it's an integer
+            // leaf, then it contains the method get_chunk() which copies these values in a super fast way (first
+            // case of the `if` below. Otherwise, copy the values one by one in a for-loop (the `else` case).
+            if (std::is_same<U, int64_t>::value && index + ValueBase::default_size <= sgc->m_leaf_end) {
+                Value<int64_t> v;
+
+                // If you want to modify 'default_size' then update Array::get_chunk()
+                REALM_ASSERT_3(ValueBase::default_size, ==, 8);
+
+                auto sgc_2 = static_cast<SequentialGetter<ColType>*>(m_sg.get());
+                sgc_2->m_leaf_ptr->get_chunk(index - sgc->m_leaf_start,
+                    static_cast<Value<int64_t>*>(static_cast<ValueBase*>(&v))->m_storage.m_first);
+
+                destination.import(v);
+            }
+            else
+            {
+                size_t rows = colsize - index;
+                if (rows > ValueBase::default_size)
+                    rows = ValueBase::default_size;
+                Value<typename util::RemoveOptional<U>::type> v(false, rows);
+
+                for (size_t t = 0; t < rows; t++)
+                    v.m_storage.set(t, sgc->get_next(index + t));
+
+                destination.import(v);
+            }
+        }
+    }
+
+    // Load values from Column into destination
+    void evaluate(size_t index, ValueBase& destination) override {
+        if (m_nullable && std::is_same<typename ColType::value_type, int64_t>::value) {
+            evaluate_internal<IntNullColumn>(index, destination);
+        }
+        else {
+            evaluate_internal<ColType>(index, destination);
+        }
+    }
+
+    bool links_exist() const
+    {
+        return m_link_map.m_link_columns.size() > 0;
+    }
+
+    bool is_nullable() const
+    {
+        return m_nullable;
+    }
+
+    LinkMap m_link_map;
+
+    // Fast (leaf caching) value getter for payload column (column in table on which query condition is executed)
+    std::unique_ptr<SequentialGetterBase> m_sg;
+
+    // Column index of payload column of m_table
+    size_t m_column;
+
+private:
+    // set to false by default for stand-alone Columns declaration that are not yet associated with any table
+    // or oclumn. Call init() to update it or use a constructor that takes table + column index as argument.
+    bool m_nullable = false;
+};
+
+template<typename T, typename Operation>
+class SubColumnAggregate;
+namespace aggregate_operations {
+    template<typename T>
+    class Minimum;
+    template<typename T>
+    class Maximum;
+    template<typename T>
+    class Sum;
+    template<typename T>
+    class Average;
+}
+
+template<typename T>
+class SubColumns : public Subexpr {
+public:
+    SubColumns(Columns<T> column, LinkMap link_map)
+        : m_column(column)
+        , m_link_map(link_map)
+    {
+    }
+
+    std::unique_ptr<Subexpr> clone(QueryNodeHandoverPatches*) const override
+    {
+        return make_subexpr<SubColumns<T>>(*this);
+    }
+
+    const Table* get_base_table() const override
+    {
+        return m_link_map.base_table();
+    }
+
+    void set_base_table(const Table* table) override
+    {
+        m_link_map.set_base_table(table);
+        m_column.set_base_table(m_link_map.target_table());
+    }
+
+    void evaluate(size_t, ValueBase&) override
+    {
+        // SubColumns can only be used in an expression in conjunction with its aggregate methods.
+        REALM_ASSERT(false);
+    }
+
+    SubColumnAggregate<T, aggregate_operations::Minimum<T>> min() const
+    {
+        return { m_column, m_link_map };
+    }
+
+    SubColumnAggregate<T, aggregate_operations::Maximum<T>> max() const
+    {
+        return { m_column, m_link_map };
+    }
+
+    SubColumnAggregate<T, aggregate_operations::Sum<T>> sum() const
+    {
+        return { m_column, m_link_map };
+    }
+
+    SubColumnAggregate<T, aggregate_operations::Average<T>> average() const
+    {
+        return { m_column, m_link_map };
+    }
+
+private:
+    Columns<T> m_column;
+    LinkMap m_link_map;
+};
+
+template<typename T, typename Operation>
+class SubColumnAggregate : public Subexpr2<typename Operation::ResultType>
+{
+public:
+    SubColumnAggregate(Columns<T> column, LinkMap link_map)
+        : m_column(column)
+        , m_link_map(link_map)
+    {
+    }
+
+    std::unique_ptr<Subexpr> clone(QueryNodeHandoverPatches*) const override
+    {
+        return make_subexpr<SubColumnAggregate>(*this);
+    }
+
+    const Table* get_base_table() const override
+    {
+        return m_link_map.base_table();
+    }
+
+    void set_base_table(const Table* table) override
+    {
+        m_link_map.set_base_table(table);
+        m_column.set_base_table(m_link_map.target_table());
+    }
+
+    void evaluate(size_t index, ValueBase& destination) override
+    {
+        std::vector<size_t> links = m_link_map.get_links(index);
+        std::sort(links.begin(), links.end());
+
+        Operation op;
+        for (size_t link_index = 0; link_index < links.size(); ) {
+            Value<T> value;
+            size_t link = links[link_index];
+            m_column.evaluate(link, value);
+
+            // Columns<T>::evaluate fetches values in chunks of ValueBase::default_size. Process all values
+            // within the chunk that came from rows that we link to.
+            const auto& value_storage = value.m_storage;
+            for (size_t value_index = 0; value_index < value.m_values; ) {
+                if (!value_storage.is_null(value_index)) {
+                    op.accumulate(value_storage[value_index]);
+                }
+                if (++link_index >= links.size()) {
+                    break;
+                }
+
+                size_t previous_link = link;
+                link = links[link_index];
+                value_index += link - previous_link;
+            }
+        }
+        if (op.is_null()) {
+            destination.import(Value<null>(false, 1, null()));
+        } else {
+            destination.import(Value<typename Operation::ResultType>(false, 1, op.result()));
+        }
+    }
+
+private:
+    Columns<T> m_column;
+    LinkMap m_link_map;
+};
+
+struct SubQueryCountHandoverPatch : QueryNodeHandoverPatch {
+    QueryHandoverPatch m_query;
+};
+
+class SubQueryCount : public Subexpr2<Int> {
+public:
+    SubQueryCount(Query q, LinkMap link_map) : m_query(std::move(q)), m_link_map(std::move(link_map)) { }
+
+    const Table* get_base_table() const override
+    {
+        return m_link_map.base_table();
+    }
+
+    void set_base_table(const Table* table) override
+    {
+        m_link_map.set_base_table(table);
+    }
+
+    void evaluate(size_t index, ValueBase& destination) override
+    {
+        std::vector<size_t> links = m_link_map.get_links(index);
+        std::sort(links.begin(), links.end());
+
+        size_t count = std::accumulate(links.begin(), links.end(), 0, [this](size_t running_count, size_t link){
+            return running_count + m_query.count(link, link + 1, 1);
+        });
+
+        destination.import(Value<Int>(false, 1, count));
+    }
+
+    std::unique_ptr<Subexpr> clone(QueryNodeHandoverPatches* patches) const override
+    {
+        if (patches)
+            return std::unique_ptr<Subexpr>(new SubQueryCount(*this, patches));
+
+        return make_subexpr<SubQueryCount>(*this);
+    }
+
+    void apply_handover_patch(QueryNodeHandoverPatches& patches, Group& group) override
+    {
+        REALM_ASSERT(patches.size());
+        std::unique_ptr<QueryNodeHandoverPatch> abstract_patch = std::move(patches.back());
+        patches.pop_back();
+
+        auto patch = dynamic_cast<SubQueryCountHandoverPatch*>(abstract_patch.get());
+        REALM_ASSERT(patch);
+
+        m_query.apply_patch(patch->m_query, group);
+    }
+
+private:
+    SubQueryCount(const SubQueryCount& other, QueryNodeHandoverPatches* patches) : m_link_map(other.m_link_map)
+    {
+        std::unique_ptr<SubQueryCountHandoverPatch> patch(new SubQueryCountHandoverPatch);
+        m_query = Query(other.m_query, patch->m_query, ConstSourcePayload::Copy);
+        patches->emplace_back(patch.release());
+    }
+
+    Query m_query;
+    LinkMap m_link_map;
+};
+
+// The unused template parameter is a hack to avoid a circular dependency between table.hpp and query_expression.hpp.
+template<class>
+class SubQuery {
+public:
+    SubQuery(Columns<Link> link_column, Query query) : m_query(std::move(query)), m_link_map(link_column.link_map())
+    {
+        REALM_ASSERT(m_link_map.target_table() == m_query.get_table());
+    }
+
+    SubQueryCount count() const
+    {
+        return SubQueryCount(m_query, m_link_map);
+    }
+
+private:
+    Query m_query;
+    LinkMap m_link_map;
+};
+
+namespace aggregate_operations {
+    template<typename T, typename Derived, typename R=T>
+    class BaseAggregateOperation {
+        static_assert(std::is_same<T, Int>::value || std::is_same<T, Float>::value || std::is_same<T, Double>::value,
+                      "Numeric aggregates can only be used with subcolumns of numeric types");
+    public:
+        using ResultType = R;
+
+        void accumulate(T value)
+        {
+            m_count++;
+            m_result = Derived::apply(m_result, value);
+        }
+
+        bool is_null() const { return m_count == 0; }
+        ResultType result() const { return m_result; }
+
+    protected:
+        size_t m_count = 0;
+        ResultType m_result = Derived::initial_value();
+    };
+
+    template<typename T>
+    class Minimum : public BaseAggregateOperation<T, Minimum<T>> {
+    public:
+        static T initial_value() { return std::numeric_limits<T>::max(); }
+        static T apply(T a, T b) { return std::min(a, b); }
+    };
+
+    template<typename T>
+    class Maximum : public BaseAggregateOperation<T, Maximum<T>> {
+    public:
+        static T initial_value() { return std::numeric_limits<T>::min(); }
+        static T apply(T a, T b) { return std::max(a, b); }
+    };
+
+    template<typename T>
+    class Sum : public BaseAggregateOperation<T, Sum<T>> {
+    public:
+        static T initial_value() { return T(); }
+        static T apply(T a, T b) { return a + b; }
+        bool is_null() const { return false; }
+    };
+
+    template<typename T>
+    class Average : public BaseAggregateOperation<T, Average<T>, double> {
+        using Base = BaseAggregateOperation<T, Average<T>, double>;
+    public:
+        static double initial_value() { return 0; }
+        static double apply(double a, T b) { return a + b; }
+        double result() const { return Base::m_result / Base::m_count; }
+    };
+}
+
+template<class oper, class TLeft>
+class UnaryOperator : public Subexpr2<typename oper::type>
+{
+public:
+    UnaryOperator(std::unique_ptr<TLeft> left) : m_left(std::move(left)) {}
+
+    UnaryOperator(const UnaryOperator& other, QueryNodeHandoverPatches* patches) :
+        m_left(other.m_left->clone(patches))
+    {
+    }
+
+    UnaryOperator& operator=(const UnaryOperator& other)
+    {
+        if (this != &other) {
+            m_left = other.m_left->clone();
+        }
+        return *this;
+    }
+
+    UnaryOperator(UnaryOperator&&) = default;
+    UnaryOperator& operator=(UnaryOperator&&) = default;
+
+    // See comment in base class
+    void set_base_table(const Table* table) override
+    {
+        m_left->set_base_table(table);
+    }
+
+    // Recursively fetch tables of columns in expression tree. Used when user first builds a stand-alone expression and
+    // binds it to a Query at a later time
+    const Table* get_base_table() const override
+    {
+        return m_left->get_base_table();
+    }
+
+    // destination = operator(left)
+    void evaluate(size_t index, ValueBase& destination) override
+    {
+        Value<T> result;
+        Value<T> left;
+        m_left->evaluate(index, left);
+        result.template fun<oper>(&left);
+        destination.import(result);
+    }
+
+    std::unique_ptr<Subexpr> clone(QueryNodeHandoverPatches* patches) const override
+    {
+        return make_subexpr<UnaryOperator>(*this, patches);
+    }
+
+    void apply_handover_patch(QueryNodeHandoverPatches& patches, Group& group) override
+    {
+        m_left->apply_handover_patch(patches, group);
+    }
+
+private:
+    typedef typename oper::type T;
+    std::unique_ptr<TLeft> m_left;
+};
+
+
+template<class oper, class TLeft, class TRight>
+class Operator : public Subexpr2<typename oper::type>
+{
+public:
+    Operator(std::unique_ptr<TLeft> left, std::unique_ptr<TRight> right) :
+        m_left(std::move(left)), m_right(std::move(right))
+    {
+    }
+
+    Operator(const Operator& other, QueryNodeHandoverPatches* patches) : m_left(other.m_left->clone(patches)),
+        m_right(other.m_right->clone(patches))
+    {
+    }
+
+    Operator& operator=(const Operator& other)
+    {
+        if (this != &other) {
+            m_left = other.m_left->clone();
+            m_right = other.m_right->clone();
+        }
+        return *this;
+    }
+
+    Operator(Operator&&) = default;
+    Operator& operator=(Operator&&) = default;
+
+    // See comment in base class
+    void set_base_table(const Table* table) override
+    {
+        m_left->set_base_table(table);
+        m_right->set_base_table(table);
+    }
+
+    // Recursively fetch tables of columns in expression tree. Used when user first builds a stand-alone expression and
+    // binds it to a Query at a later time
+    const Table* get_base_table() const override
+    {
+        const Table* l = m_left->get_base_table();
+        const Table* r = m_right->get_base_table();
+
+        // Queries do not support multiple different tables; all tables must be the same.
+        REALM_ASSERT(l == nullptr || r == nullptr || l == r);
+
+        // nullptr pointer means expression which isn't yet associated with any table, or is a Value<T>
+        return l ? l : r;
+    }
+
+    // destination = operator(left, right)
+    void evaluate(size_t index, ValueBase& destination) override
+    {
+        Value<T> result;
+        Value<T> left;
+        Value<T> right;
+        m_left->evaluate(index, left);
+        m_right->evaluate(index, right);
+        result.template fun<oper>(&left, &right);
+        destination.import(result);
+    }
+
+    std::unique_ptr<Subexpr> clone(QueryNodeHandoverPatches* patches) const override
+    {
+        return make_subexpr<Operator>(*this, patches);
+    }
+
+    void apply_handover_patch(QueryNodeHandoverPatches& patches, Group& group) override
+    {
+        m_right->apply_handover_patch(patches, group);
+        m_left->apply_handover_patch(patches, group);
+    }
+
+private:
+    typedef typename oper::type T;
+    std::unique_ptr<TLeft> m_left;
+    std::unique_ptr<TRight> m_right;
+};
+
+
+template<class TCond, class T, class TLeft, class TRight>
+class Compare : public Expression
+{
+public:
+    Compare(std::unique_ptr<TLeft> left, std::unique_ptr<TRight> right) :
+        m_left(std::move(left)), m_right(std::move(right))
+    {
+    }
+
+    // See comment in base class
+    void set_base_table(const Table* table) override
+    {
+        m_left->set_base_table(table);
+        m_right->set_base_table(table);
+    }
+
+    // Recursively fetch tables of columns in expression tree. Used when user first builds a stand-alone expression and
+    // binds it to a Query at a later time
+    const Table* get_base_table() const override
+    {
+        const Table* l = m_left->get_base_table();
+        const Table* r = m_right->get_base_table();
+
+        // All main tables in each subexpression of a query (table.columns() or table.link()) must be the same.
+        REALM_ASSERT(l == nullptr || r == nullptr || l == r);
+
+        // nullptr pointer means expression which isn't yet associated with any table, or is a Value<T>
+        return l ? l : r;
+    }
+
+    size_t find_first(size_t start, size_t end) const override
+    {
+        size_t match;
+        Value<T> right;
+        Value<T> left;
+
+        for (; start < end;) {
+            m_left->evaluate(start, left);
+            m_right->evaluate(start, right);
+            match = Value<T>::template compare<TCond>(&left, &right);
+
+            if (match != not_found && match + start < end)
+                return start + match;
+
+            size_t rows = (left.m_from_link_list || right.m_from_link_list) ? 1 : minimum(right.m_values, left.m_values);
+            start += rows;
+        }
+
+        return not_found; // no match
+    }
+
+    std::unique_ptr<Expression> clone(QueryNodeHandoverPatches* patches) const override
+    {
+        return std::unique_ptr<Expression>(new Compare(*this, patches));
+    }
+
+    void apply_handover_patch(QueryNodeHandoverPatches& patches, Group& group) override
+    {
+        m_right->apply_handover_patch(patches, group);
+        m_left->apply_handover_patch(patches, group);
+    }
+
+private:
+    Compare(const Compare& other, QueryNodeHandoverPatches* patches) : m_left(other.m_left->clone(patches)),
+        m_right(other.m_right->clone(patches))
+    {
+    }
+
+    std::unique_ptr<TLeft> m_left;
+    std::unique_ptr<TRight> m_right;
+};
+
+}
+#endif // REALM_QUERY_EXPRESSION_HPP
+
diff --git a/Pods/Realm/include/core/realm/realm_nmmintrin.h b/Pods/Realm/include/core/realm/realm_nmmintrin.h
new file mode 100644
index 0000000..883f01d
--- /dev/null
+++ b/Pods/Realm/include/core/realm/realm_nmmintrin.h
@@ -0,0 +1,164 @@
+#ifndef REALM_NMMINTRIN_H
+#define REALM_NMMINTRIN_H
+
+/*
+    We must support runtime detection of CPU support of SSE when distributing Realm as a closed source library.
+
+    This is a problem on gcc and llvm: To use SSE intrinsics we need to pass -msse on the command line (to get offered
+    __builtin_ accessors used by intrinsics functions). However, the -msse flag allows gcc to emit SSE instructions
+    in its code generation/optimization. This is unwanted because the binary would crash on non-SSE CPUs.
+
+    Since there exists no flag in gcc that enables intrinsics but probits SSE in code generation, we define our
+    own intrinsics to be assembled by the back end assembler and omit passing -msse to gcc.
+*/
+
+#ifndef _MSC_VER
+
+#ifdef REALM_COMPILER_SSE
+    #include <emmintrin.h> // SSE2 (using __m128i)
+#endif
+
+namespace realm {
+
+#if 0
+#ifdef REALM_COMPILER_AVX
+typedef float __m256 __attribute__((__vector_size__(32), __may_alias__));
+typedef double __m256d __attribute__((__vector_size__(32), __may_alias__));
+
+const int _CMP_EQ_OQ = 0x00; // Equal (ordered, non-signaling)
+const int _CMP_NEQ_OQ = 0x0c; // Not-equal (ordered, non-signaling)
+const int _CMP_LT_OQ = 0x11; // Less-than (ordered, non-signaling)
+const int _CMP_LE_OQ = 0x12; // Less-than-or-equal (ordered, non-signaling)
+const int _CMP_GE_OQ = 0x1d; // Greater-than-or-equal (ordered, non-signaling)
+const int _CMP_GT_OQ = 0x1e; // Greater-than (ordered, non-signaling)
+
+
+template<int op>
+static int movemask_cmp_ps(__m256* y1, __m256* y2)
+{
+    int ret;
+    __asm__("vmovaps %0, %%ymm0"                    :                   : "m"(*y1)                      : "%xmm0"   );
+    __asm__("vmovaps %0, %%ymm1"                    :                   : "m"(*y2)                      : "%xmm1"   );
+    __asm__("vcmpps %0, %%ymm0, %%ymm1, %%ymm0"     :                   : "I"(op)                       : "%xmm0"   );
+    __asm__("vmovmskps %%ymm0, %0"                  : "=r"(ret)         :                               :           );
+    return ret;
+}
+
+template<int op>
+static inline int movemask_cmp_pd(__m256d* y1, __m256d* y2)
+{
+    int ret;
+    __asm__("vmovapd %0, %%ymm0"                    :                   : "m"(*y1)                      : "%xmm0"   );
+    __asm__("vmovapd %0, %%ymm1"                    :                   : "m"(*y2)                      : "%xmm1"   );
+    __asm__("vcmppd %0, %%ymm0, %%ymm1, %%ymm0"     :                   : "I"(op)                       : "%xmm0"   );
+    __asm__("vmovmskpd %%ymm0, %0"                  : "=r"(ret)         :                               :           );
+    return ret;
+}
+
+
+
+static inline int movemask_cmp_ps(__m256* y1, __m256* y2, int op)
+{
+    // todo, use constexpr;
+    if (op == _CMP_EQ_OQ)
+        return movemask_cmp_ps<_CMP_NEQ_OQ>(y1, y2);
+    else if (op == _CMP_NEQ_OQ)
+        return movemask_cmp_ps<_CMP_NEQ_OQ>(y1, y2);
+    else if (op == _CMP_LT_OQ)
+        return movemask_cmp_ps<_CMP_LT_OQ>(y1, y2);
+    else if (op == _CMP_LE_OQ)
+        return movemask_cmp_ps<_CMP_LE_OQ>(y1, y2);
+    else if (op == _CMP_GE_OQ)
+        return movemask_cmp_ps<_CMP_GE_OQ>(y1, y2);
+    else if (op == _CMP_GT_OQ)
+        return movemask_cmp_ps<_CMP_GT_OQ>(y1, y2);
+
+    REALM_ASSERT(false);
+    return 0;
+}
+
+static inline int movemask_cmp_pd(__m256d* y1, __m256d* y2, int op)
+{
+    // todo, use constexpr;
+    if (op == _CMP_EQ_OQ)
+        return movemask_cmp_pd<_CMP_NEQ_OQ>(y1, y2);
+    else if (op == _CMP_NEQ_OQ)
+        return movemask_cmp_pd<_CMP_NEQ_OQ>(y1, y2);
+    else if (op == _CMP_LT_OQ)
+        return movemask_cmp_pd<_CMP_LT_OQ>(y1, y2);
+    else if (op == _CMP_LE_OQ)
+        return movemask_cmp_pd<_CMP_LE_OQ>(y1, y2);
+    else if (op == _CMP_GE_OQ)
+        return movemask_cmp_pd<_CMP_GE_OQ>(y1, y2);
+    else if (op == _CMP_GT_OQ)
+        return movemask_cmp_pd<_CMP_GT_OQ>(y1, y2);
+
+    REALM_ASSERT(false);
+    return 0;
+}
+
+
+#endif
+#endif
+
+// Instructions introduced by SSE 3 and 4.2
+static inline __m128i _mm_cmpgt_epi64(__m128i xmm1, __m128i xmm2)
+{
+    __asm__("pcmpgtq %1, %0" : "+x" (xmm1) : "xm" (xmm2));
+    return xmm1;
+}
+
+static inline __m128i _mm_cmpeq_epi64(__m128i xmm1, __m128i xmm2)
+{
+    __asm__("pcmpeqq %1, %0" : "+x" (xmm1) : "xm" (xmm2));
+    return xmm1;
+}
+
+static inline __m128i __attribute__((always_inline)) _mm_min_epi8(__m128i xmm1, __m128i xmm2)
+{
+    __asm__("pminsb %1, %0" : "+x" (xmm1) : "xm" (xmm2));
+    return xmm1;
+}
+
+static inline __m128i __attribute__((always_inline)) _mm_max_epi8(__m128i xmm1, __m128i xmm2)
+{
+    __asm__("pmaxsb %1, %0" : "+x" (xmm1) : "xm" (xmm2));
+    return xmm1;
+}
+
+static inline __m128i __attribute__((always_inline)) _mm_max_epi32(__m128i xmm1, __m128i xmm2)
+{
+    __asm__("pmaxsd %1, %0" : "+x" (xmm1) : "xm" (xmm2));
+    return xmm1;
+}
+
+static inline __m128i __attribute__((always_inline)) _mm_min_epi32(__m128i xmm1, __m128i xmm2)
+{
+    __asm__("pminsd %1, %0" : "+x" (xmm1) : "xm" (xmm2));
+    return xmm1;
+}
+
+static inline __m128i __attribute__((always_inline)) _mm_cvtepi8_epi16(__m128i xmm2)
+{
+    __m128i xmm1;
+    __asm__("pmovsxbw %1, %0" : "=x" (xmm1) : "xm" (xmm2) : "xmm1");
+    return xmm1;
+}
+static inline __m128i __attribute__((always_inline)) _mm_cvtepi16_epi32(__m128i xmm2)
+{
+    __m128i xmm1;
+    asm("pmovsxwd %1, %0" : "=x" (xmm1) : "xm" (xmm2));
+    return xmm1;
+}
+
+static inline __m128i __attribute__((always_inline)) _mm_cvtepi32_epi64(__m128i xmm2)
+{
+    __m128i xmm1;
+    __asm__("pmovsxdq %1, %0" : "=x" (xmm1) : "xm" (xmm2));
+    return xmm1;
+}
+
+} // namespace realm
+
+#endif
+#endif
diff --git a/Pods/Realm/include/core/realm/replication.hpp b/Pods/Realm/include/core/realm/replication.hpp
new file mode 100644
index 0000000..76fa7c4
--- /dev/null
+++ b/Pods/Realm/include/core/realm/replication.hpp
@@ -0,0 +1,534 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_REPLICATION_HPP
+#define REALM_REPLICATION_HPP
+
+#include <algorithm>
+#include <limits>
+#include <memory>
+#include <exception>
+#include <string>
+
+#include <realm/util/assert.hpp>
+#include <realm/util/tuple.hpp>
+#include <realm/util/safe_int_ops.hpp>
+#include <realm/util/buffer.hpp>
+#include <realm/util/string_buffer.hpp>
+#include <realm/impl/continuous_transactions_history.hpp>
+#include <realm/impl/transact_log.hpp>
+
+namespace realm {
+namespace util {
+    class Logger;
+}
+
+// FIXME: Be careful about the possibility of one modification function being called by another where both do transaction logging.
+
+// FIXME: The current table/subtable selection scheme assumes that a TableRef of a subtable is not accessed after any modification of one of its ancestor tables.
+
+// FIXME: Checking on same Table* requires that ~Table checks and nullifies on match. Another option would be to store m_selected_table as a TableRef. Yet another option would be to assign unique identifiers to each Table instance via Allocator. Yet another option would be to explicitely invalidate subtables recursively when parent is modified.
+
+/// Replication is enabled by passing an instance of an implementation of this
+/// class to the SharedGroup constructor.
+class Replication:
+        public _impl::TransactLogConvenientEncoder,
+        protected _impl::TransactLogStream {
+public:
+    // Be sure to keep this type aligned with what is actually used in
+    // SharedGroup.
+    using version_type = _impl::History::version_type;
+    using InputStream = _impl::NoCopyInputStream;
+    class TransactLogApplier;
+    class Interrupted; // Exception
+    class SimpleIndexTranslator;
+
+    virtual std::string get_database_path() = 0;
+
+    /// Called during construction of the associated SharedGroup object.
+    ///
+    /// \param shared_group The assocoated SharedGroup object.
+    virtual void initialize(SharedGroup& shared_group) = 0;
+
+    /// Called by the associated SharedGroup object when a session is
+    /// initiated. A *session* is a sequence of of temporally overlapping
+    /// accesses to a specific Realm file, where each access consists of a
+    /// SharedGroup object through which the Realm file is open. Session
+    /// initiation occurs during the first opening of the Realm file within such
+    /// a session.
+    ///
+    /// Session initiation fails if this function throws.
+    ///
+    /// \param version The current version of the associated Realm. Out-of-Realm
+    /// history implementation can use this to trim off history entries that
+    /// were successfully added to the history, but for which the corresponding
+    /// subsequent commits on the Realm file failed.
+    ///
+    /// The default implementation does nothing.
+    virtual void initiate_session(version_type version) = 0;
+
+    /// Called by the associated SharedGroup object when a session is
+    /// terminated. See initiate_session() for the definition of a
+    /// session. Session termination occurs upon closing the Realm through the
+    /// last SharedGroup object within the session.
+    ///
+    /// The default implementation does nothing.
+    virtual void terminate_session() noexcept = 0;
+
+    /// Called by the associated SharedGroup to close any open files
+    /// or release similar system resources.
+    ///
+    /// This is a special purpose function that solves a problem that is
+    /// specific to the implementation available through <commit_log.hpp>. At
+    /// least for now, it is not to be considered a genuine part of the
+    /// Replication interface. The default implementation does nothing and other
+    /// implementations should not override this function.
+    virtual void commit_log_close() noexcept {}
+
+    //@{
+
+    /// From the point of view of the Replication class, a transaction is
+    /// initiated when, and only when the associated SharedGroup object calls
+    /// initiate_transact() and the call is successful. The associated
+    /// SharedGroup object must terminate every initiated transaction either by
+    /// calling finalize_commit() or by calling abort_transact(). It may only
+    /// call finalize_commit(), however, after calling prepare_commit(), and
+    /// only when prepare_commit() succeeds. If prepare_commit() fails (i.e.,
+    /// throws) abort_transact() must still be called.
+    ///
+    /// The associated SharedGroup object is supposed to terminate a transaction
+    /// as soon as possible, and is required to terminate it before attempting
+    /// to initiate a new one.
+    ///
+    /// initiate_transact() is called by the associated SharedGroup object as
+    /// part of the initiation of a transaction, and at a time where the caller
+    /// has acquired exclusive write access to the local Realm. The Replication
+    /// implementation is allowed to perform "precursor transactions" on the
+    /// local Realm at this time. During the initiated transaction, the
+    /// associated SharedGroup object must inform the Replication object of all
+    /// modifying operations by calling set_value() and friends.
+    ///
+    /// FIXME: There is currently no way for implementations to perform
+    /// precursor transactions, since a regular transaction would cause a dead
+    /// lock when it tries to acquire a write lock. Consider giving access to
+    /// special non-locking precursor transactions via an extra argument to this
+    /// function.
+    ///
+    /// prepare_commit() serves as the first phase of a two-phase commit. This
+    /// function is called by the associated SharedGroup object immediately
+    /// before the commit operation on the local Realm. The associated
+    /// SharedGroup object will then, as the second phase, either call
+    /// finalize_commit() or abort_transact() depending on whether the commit
+    /// operation succeeded or not. The Replication implementation is allowed to
+    /// modify the Realm via the associated SharedGroup object at this time
+    /// (important to in-Realm histories).
+    ///
+    /// initiate_transact() and prepare_commit() are allowed to block the
+    /// calling thread if, for example, they need to communicate over the
+    /// network. If a calling thread is blocked in one of these functions, it
+    /// must be possible to interrupt the blocking operation by having another
+    /// thread call interrupt(). The contract is as follows: When interrupt() is
+    /// called, then any execution of initiate_transact() or prepare_commit(),
+    /// initiated before the interruption, must complete without blocking, or
+    /// the execution must be aborted by throwing an Interrupted exception. If
+    /// initiate_transact() or prepare_commit() throws Interrupted, it counts as
+    /// a failed operation.
+    ///
+    /// finalize_commit() is called by the associated SharedGroup object
+    /// immediately after a successful commit operation on the local Realm. This
+    /// happens at a time where modification of the Realm is no longer possible
+    /// via the associated SharedGroup object. In the case of in-Realm
+    /// histories, the changes are automatically finalized as part of the commit
+    /// operation performed by the caller prior to the invocation of
+    /// finalize_commit(), so in that case, finalize_commit() might not need to
+    /// do anything.
+    ///
+    /// abort_transact() is called by the associated SharedGroup object to
+    /// terminate a transaction without committing. That is, any transaction
+    /// that is not terminated by finalize_commit() is terminated by
+    /// abort_transact(). This could be due to an explicit rollback, or due to a
+    /// failed commit attempt.
+    ///
+    /// Note that finalize_commit() and abort_transact() are not allowed to
+    /// throw.
+    ///
+    /// \param current_version The version of the snapshot that the current
+    /// transaction is based on.
+    ///
+    /// \param history_updated Pass true only when the history has already been
+    /// updated to reflect the currently bound snapshot, such as when
+    /// _impl::History::update_early_from_top_ref() was called during the
+    /// transition from a read transaction to the current write transaction.
+    ///
+    /// \return prepare_commit() returns the version of the new snapshot
+    /// produced by the transaction.
+    ///
+    /// \throw Interrupted Thrown by initiate_transact() and prepare_commit() if
+    /// a blocking operation was interrupted.
+
+    void initiate_transact(version_type current_version, bool history_updated);
+    version_type prepare_commit(version_type current_version);
+    void finalize_commit() noexcept;
+    void abort_transact() noexcept;
+
+    //@}
+
+
+    /// Interrupt any blocking call to a function in this class. This function
+    /// may be called asyncronously from any thread, but it may not be called
+    /// from a system signal handler.
+    ///
+    /// Some of the public function members of this class may block, but only
+    /// when it it is explicitely stated in the documention for those functions.
+    ///
+    /// FIXME: Currently we do not state blocking behaviour for all the
+    /// functions that can block.
+    ///
+    /// After any function has returned with an interruption indication, the
+    /// only functions that may safely be called are abort_transact() and the
+    /// destructor. If a client, after having received an interruption
+    /// indication, calls abort_transact() and then clear_interrupt(), it may
+    /// resume normal operation through this Replication object.
+    void interrupt() noexcept;
+
+    /// May be called by a client to reset this Replication object after an
+    /// interrupted transaction. It is not an error to call this function in a
+    /// situation where no interruption has occured.
+    void clear_interrupt() noexcept;
+
+    /// Apply a changeset to the specified group.
+    ///
+    /// \param logger If specified, and the library was compiled in debug mode,
+    /// then a line describing each individual operation is writted to the
+    /// specified logger.
+    ///
+    /// \throw BadTransactLog If the changeset could not be successfully parsed,
+    /// or ended prematurely.
+    static void apply_changeset(InputStream& changeset, Group&, util::Logger* logger = nullptr);
+
+    enum HistoryType {
+        /// No history available. No support for either continuous transactions
+        /// or inter-client synchronization.
+        hist_None = 0,
+
+        /// Out-of-Realm history supporting continuous transactions.
+        hist_OutOfRealm = 1,
+
+        /// In-Realm history supporting continuous transactions
+        /// (_impl::InRealmHistory).
+        hist_InRealm = 2,
+
+        /// In-Realm history supporting continuous transactions and inter-client
+        /// synchronization (_impl::SyncHistory).
+        hist_Sync = 3
+    };
+
+    /// Returns the type of history maintained by this Replication
+    /// implementation, or \ref hist_None if no history is maintained by it.
+    ///
+    /// This type is used to ensure that all session participants agree on
+    /// history type, and that the Realm file contains a compatible type of
+    /// history, at the beginning of a new session.
+    ///
+    /// As a special case, if there is no top array (Group::m_top) at the
+    /// beginning of a new session, then all history types (as returned by
+    /// get_history_type()) are allowed during that session. Note that this is
+    /// only possible if there was no preceding session, or if no transaction
+    /// was sucessfully comitted during any of the preceding sessions. As soon
+    /// as a transaction is successfully committed, the Realm contains at least
+    /// a top array, and from that point on, the history type is generally
+    /// fixed, although still subject to certain allowed changes (as mentioned
+    /// below).
+    ///
+    /// For the sake of backwards compatibility with older Realm files that does
+    /// not store any history type, the following rule shall apply:
+    ///
+    ///   - If the top array of a Realm file (Group::m_top) does not contain a
+    ///     history type, because it is too short, it shall be understood as
+    ///     implicitely storing the type \ref hist_None.
+    ///
+    /// Note: In what follows, the meaning of *preceding session* is: The last
+    /// preceding session that modified the Realm by sucessfully committing a
+    /// new snapshot.
+    ///
+    /// Older Realm files do not store any history type, even when they were
+    /// last used with a history of type \ref hist_OutOfRealm. Howewver, since
+    /// such histories (\ref hist_OutOfRealm) are placed outside the Realm file,
+    /// and are transient (recreated at the beginning of each new session), a
+    /// new session is not obliged to use the same type of history (\ref
+    /// hist_OutOfRealm). For this reason, and to achieve further backwards
+    /// compatibility, the following rules are adopted:
+    ///
+    ///   - At the beginning of a new session, if there is no stored history
+    ///     type (no top array), or if the stored history type is \ref
+    ///     hist_None, assume that the history type used during the preceding
+    ///     session was \ref hist_None or \ref hist_OutOfRealm, or that there
+    ///     was no preceding session. In all other cases, assume that the stored
+    ///     history type is the type used during the preceding session.
+    ///
+    ///   - When storing the history type, store \ref hist_None if the history
+    ///     type used in the current session is \ref hist_None or \ref
+    ///     hist_OutOfRealm. In all other cases, store the actual history type
+    ///     used.
+    ///
+    /// It shall be allowed to switch to a \ref hist_InRealm history if the
+    /// stored history type is either \ref hist_None or \ref
+    /// hist_OutOfRealm. Fortunately, this can be done simply by adding a
+    /// history to the Realm file (of type \ref hist_InRealm), and that is
+    /// possible because a \ref hist_InRealm history is independent of any
+    /// history used in a previous session (as long as it was session-confined),
+    /// or whether any history was used at all. Conversely, if a \ref
+    /// hist_OutOfRealm history was used in the previous session, then the
+    /// contents of that history becomes obsolete at the end of the previous
+    /// session.
+    ///
+    /// On the other hand, as soon as a history of type \ref hist_InRealm is
+    /// added to a Realm file, that history type is binding for all subsequent
+    /// sessions. In theory, this constraint is not necessary, and a later
+    /// switch to \ref hist_None or \ref hist_OutOfRealm would be possible
+    /// because of the fact that the contents of the history becomes obsolete at
+    /// the end of the session, however, because the \ref hist_InRealm history
+    /// remains in the Realm file, there are practical complications, and for
+    /// that reason, such switching shall not be supported.
+    ///
+    /// The \ref hist_Sync history type can only be used if the stored history
+    /// type is also \ref hist_Sync, or when there is no top array
+    /// yet. Additionally, when the stored history type is \ref hist_Sync, then
+    /// all subsequent sesssions must have the same type. These restrictions
+    /// apply because such a history needs to be maintained persistently across
+    /// sessions. That is, the contents of such a history is not obsolete at the
+    /// end of the session, and is in general needed during subsequent sessions.
+    ///
+    /// In general, if there is no stored history type (no top array) at the
+    /// beginning of a new session, or if the stored type disagrees with what is
+    /// returned by get_history_type() (which is possible due to particular
+    /// allowed changes of history type), the actual history type (as returned
+    /// by get_history_type()) used during that session, must be stored in the
+    /// Realm during the first successfully committed transaction of that
+    /// session, if any are sucessfully committed. But note that there is still
+    /// no need to expand the top array to store the history type \ref
+    /// hist_None, due to the rule mentioned above.
+    ///
+    /// Due to the rules listed above, a new history type only actually needs to
+    /// be stored when the history type of the session (get_history_type()) is
+    /// neither \ref hist_None nor \ref hist_OutOfRealm, and only when that
+    /// differs from the stored history type, or if there is no top array at the
+    /// beginning of the session.
+    ///
+    /// Summary of session-to-session history type change constraints:
+    ///
+    /// If there is no top array at the beginning of a new session, then all
+    /// history types (as returned by get_history_type()) are possible during
+    /// that session. Otherwise there must have been a preceding session (at
+    /// least one that adds the top array), and the following rules then apply:
+    ///
+    /// <pre>
+    ///
+    ///                      Type stored in
+    ///   Type used during   Realm file at
+    ///   preceding          beginning of     Possible history types (as returned by
+    ///   session            new session      get_history_type()) during new session
+    ///   ----------------------------------------------------------------------------
+    ///   hist_None          hist_None        hist_None, hist_OutOfRealm, hist_InRealm
+    ///   hist_OutOfRealm    hist_None        hist_None, hist_OutOfRealm, hist_InRealm
+    ///   hist_InRealm       hist_InRealm     hist_InRealm
+    ///   hist_Sync          hist_Sync        hist_Sync
+    ///
+    /// </pre>
+    ///
+    /// This function must return \ref hist_None when, and only when
+    /// get_history() returns null.
+    virtual HistoryType get_history_type() const noexcept = 0;
+
+    /// Returns an object that gives access to the history of changesets in a
+    /// way that allows for continuous transactions to work
+    /// (Group::advance_transact() in particular).
+    ///
+    /// This function must return null when, and only when get_history_type()
+    /// returns \ref hist_None.
+    virtual _impl::History* get_history() = 0;
+
+    virtual ~Replication() noexcept {}
+
+protected:
+    Replication();
+
+
+    //@{
+
+    /// do_initiate_transact() is called by initiate_transact(), and likewise
+    /// for do_prepare_commit), do_finalize_commit(), and do_abort_transact().
+    ///
+    /// With respect to exception safety, the Replication implementation has two
+    /// options: It can prepare to accept the accumulated changeset in
+    /// do_prepapre_commit() by allocating all required resources, and delay the
+    /// actual acceptance to do_finalize_commit(), which requires that the final
+    /// acceptance can be done without any risk of failure. Alternatively, the
+    /// Replication implementation can fully accept the changeset in
+    /// do_prepapre_commit() (allowing for failure), and then discard that
+    /// changeset during the next invocation of do_initiate_transact() if
+    /// `current_version` indicates that the previous transaction failed.
+
+    virtual void do_initiate_transact(version_type current_version, bool history_updated) = 0;
+    virtual version_type do_prepare_commit(version_type orig_version) = 0;
+    virtual void do_finalize_commit() noexcept = 0;
+    virtual void do_abort_transact() noexcept = 0;
+
+    //@}
+
+
+    virtual void do_interrupt() noexcept = 0;
+
+    virtual void do_clear_interrupt() noexcept = 0;
+
+    friend class _impl::TransactReverser;
+};
+
+
+class Replication::Interrupted: public std::exception {
+public:
+    const char* what() const noexcept override
+    {
+        return "Interrupted";
+    }
+};
+
+
+class TrivialReplication: public Replication {
+public:
+    ~TrivialReplication() noexcept {}
+
+protected:
+    typedef Replication::version_type version_type;
+
+    TrivialReplication(const std::string& database_file);
+
+    virtual version_type prepare_changeset(const char* data, size_t size,
+                                           version_type orig_version) = 0;
+    virtual void finalize_changeset() noexcept = 0;
+
+    static void apply_changeset(const char* data, size_t size, SharedGroup& target,
+                                util::Logger* logger = nullptr);
+
+    bool is_history_updated() const noexcept;
+
+    BinaryData get_uncommitted_changes() const noexcept;
+
+    std::string get_database_path() override;
+    void initialize(SharedGroup&) override;
+    void do_initiate_transact(version_type, bool) override;
+    version_type do_prepare_commit(version_type orig_version) override;
+    void do_finalize_commit() noexcept override;
+    void do_abort_transact() noexcept override;
+    void do_interrupt() noexcept override;
+    void do_clear_interrupt() noexcept override;
+    void transact_log_reserve(size_t n, char** new_begin, char** new_end) override;
+    void transact_log_append(const char* data, size_t size, char** new_begin,
+                             char** new_end) override;
+
+private:
+    const std::string m_database_file;
+    util::Buffer<char> m_transact_log_buffer;
+    bool m_history_updated;
+    void internal_transact_log_reserve(size_t, char** new_begin, char** new_end);
+
+    size_t transact_log_size();
+};
+
+
+
+
+// Implementation:
+
+inline Replication::Replication():
+    _impl::TransactLogConvenientEncoder(static_cast<_impl::TransactLogStream&>(*this))
+{
+}
+
+inline void Replication::initiate_transact(version_type current_version, bool history_updated)
+{
+    do_initiate_transact(current_version, history_updated);
+    reset_selection_caches();
+}
+
+inline Replication::version_type Replication::prepare_commit(version_type orig_version)
+{
+    return do_prepare_commit(orig_version);
+}
+
+inline void Replication::finalize_commit() noexcept
+{
+    do_finalize_commit();
+}
+
+inline void Replication::abort_transact() noexcept
+{
+    do_abort_transact();
+}
+
+inline void Replication::interrupt() noexcept
+{
+    do_interrupt();
+}
+
+inline void Replication::clear_interrupt() noexcept
+{
+    do_clear_interrupt();
+}
+
+inline TrivialReplication::TrivialReplication(const std::string& database_file):
+    m_database_file(database_file)
+{
+}
+
+inline bool TrivialReplication::is_history_updated() const noexcept
+{
+    return m_history_updated;
+}
+
+inline BinaryData TrivialReplication::get_uncommitted_changes() const noexcept
+{
+    const char* data = m_transact_log_buffer.data();
+    size_t size = write_position() - data;
+    return BinaryData(data, size);
+}
+
+inline size_t TrivialReplication::transact_log_size()
+{
+    return write_position() - m_transact_log_buffer.data();
+}
+
+inline void TrivialReplication::transact_log_reserve(size_t n, char** new_begin, char** new_end)
+{
+    internal_transact_log_reserve(n, new_begin, new_end);
+}
+
+inline void TrivialReplication::internal_transact_log_reserve(size_t n, char** new_begin, char** new_end)
+{
+    char* data = m_transact_log_buffer.data();
+    size_t size = write_position() - data;
+    m_transact_log_buffer.reserve_extra(size, n);
+    data = m_transact_log_buffer.data(); // May have changed
+    *new_begin = data + size;
+    *new_end = data + m_transact_log_buffer.size();
+}
+
+} // namespace realm
+
+#endif // REALM_REPLICATION_HPP
diff --git a/Pods/Realm/include/core/realm/row.hpp b/Pods/Realm/include/core/realm/row.hpp
new file mode 100644
index 0000000..6c53640
--- /dev/null
+++ b/Pods/Realm/include/core/realm/row.hpp
@@ -0,0 +1,814 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_ROW_HPP
+#define REALM_ROW_HPP
+
+#include <stdint.h>
+
+#include <realm/util/type_traits.hpp>
+#include <realm/mixed.hpp>
+#include <realm/table_ref.hpp>
+#include <realm/link_view_fwd.hpp>
+#include <realm/handover_defs.hpp>
+
+namespace realm {
+
+template<class>
+class BasicRow;
+
+
+/// This class is a "mixin" and contains the common set of functions for several
+/// distinct row-like classes.
+///
+/// There is a direct and natural correspondance between the functions in this
+/// class and functions in Table of the same name. For example:
+///
+///     table[i].get_int(j) == table.get_int(i,j)
+///
+/// The effect of calling most of the row accessor functions on a detached
+/// accessor is unspecified and may lead to general corruption, and/or a
+/// crash. The exceptions are is_attached(), detach(), get_table(), get_index(),
+/// and the destructor. Note however, that get_index() will still return an
+/// unspecified value for a deatched accessor.
+///
+/// When a row accessor is evaluated in a boolean context, it evaluates to true
+/// if, and only if it is attached.
+///
+/// \tparam T A const or non-const table type (currently either `Table` or
+/// `const Table`).
+///
+/// \tparam R A specific row accessor class (BasicRow or BasicRowExpr) providing
+/// members `T* impl_get_table() const`, `size_t impl_get_row_ndx()
+/// const`, and `void impl_detach()`. Neither are allowed to throw.
+///
+/// \sa Table
+/// \sa BasicRow
+template<class T, class R>
+class RowFuncs {
+public:
+    typedef T table_type;
+
+    typedef BasicTableRef<const T> ConstTableRef;
+    typedef BasicTableRef<T> TableRef; // Same as ConstTableRef if `T` is 'const'
+
+    typedef typename util::CopyConst<T, LinkView>::type L;
+    using ConstLinkViewRef = std::shared_ptr<const L>;
+    using LinkViewRef = std::shared_ptr<L>; // Same as ConstLinkViewRef if `T` is 'const'
+
+    int_fast64_t get_int(size_t col_ndx) const noexcept;
+    bool get_bool(size_t col_ndx) const noexcept;
+    float get_float(size_t col_ndx) const noexcept;
+    double get_double(size_t col_ndx) const noexcept;
+    StringData get_string(size_t col_ndx) const noexcept;
+    BinaryData get_binary(size_t col_ndx) const noexcept;
+    OldDateTime get_olddatetime(size_t col_ndx) const noexcept;
+    Timestamp get_timestamp(size_t col_ndx) const noexcept;
+    ConstTableRef get_subtable(size_t col_ndx) const;
+    TableRef get_subtable(size_t col_ndx);
+    size_t get_subtable_size(size_t col_ndx) const noexcept;
+    size_t get_link(size_t col_ndx) const noexcept;
+    bool is_null_link(size_t col_ndx) const noexcept;
+    bool is_null(size_t col_ndx) const noexcept;
+    ConstLinkViewRef get_linklist(size_t col_ndx) const;
+    LinkViewRef get_linklist(size_t col_ndx);
+    bool linklist_is_empty(size_t col_ndx) const noexcept;
+    size_t get_link_count(size_t col_ndx) const noexcept;
+    Mixed get_mixed(size_t col_ndx) const noexcept;
+    DataType get_mixed_type(size_t col_ndx) const noexcept;
+    template<typename U> U get(size_t col_ndx) const noexcept;
+
+    void set_int(size_t col_ndx, int_fast64_t value);
+    void set_int_unique(size_t col_ndx, int_fast64_t value);
+    void set_bool(size_t col_ndx, bool value);
+    void set_float(size_t col_ndx, float value);
+    void set_double(size_t col_ndx, double value);
+    void set_string(size_t col_ndx, StringData value);
+    void set_string_unique(size_t col_ndx, StringData value);
+    void set_binary(size_t col_ndx, BinaryData value);
+    void set_olddatetime(size_t col_ndx, OldDateTime value);
+    void set_timestamp(size_t col_ndx, Timestamp value);
+    void set_subtable(size_t col_ndx, const Table* value);
+    void set_link(size_t col_ndx, size_t value);
+    void nullify_link(size_t col_ndx);
+    void set_mixed(size_t col_ndx, Mixed value);
+    void set_mixed_subtable(size_t col_ndx, const Table* value);
+    void set_null(size_t col_ndx);
+
+    void insert_substring(size_t col_ndx, size_t pos, StringData);
+    void remove_substring(size_t col_ndx, size_t pos, size_t size);
+
+    //@{
+    /// Note that these operations will cause the row accessor to be detached.
+    void remove();
+    void move_last_over();
+    //@}
+
+    size_t get_backlink_count(const Table& src_table,
+                                   size_t src_col_ndx) const noexcept;
+    size_t get_backlink(const Table& src_table, size_t src_col_ndx,
+                             size_t backlink_ndx) const noexcept;
+
+    size_t get_column_count() const noexcept;
+    DataType get_column_type(size_t col_ndx) const noexcept;
+    StringData get_column_name(size_t col_ndx) const noexcept;
+    size_t get_column_index(StringData name) const noexcept;
+
+    /// Returns true if, and only if this accessor is currently attached to a
+    /// row.
+    ///
+    /// A row accesor may get detached from the underlying row for various
+    /// reasons (see below). When it does, it no longer refers to anything, and
+    /// can no longer be used, except for calling is_attached(), detach(),
+    /// get_table(), get_index(), and the destructor. The consequences of
+    /// calling other methods on a detached row accessor are unspecified. There
+    /// are a few Realm functions (Table::find_pkey_int()) that return a
+    /// detached row accessor to indicate a 'null' result. In all other cases,
+    /// however, row accessors obtained by calling functions in the Realm API
+    /// are always in the 'attached' state immediately upon return from those
+    /// functions.
+    ///
+    /// A row accessor becomes detached if the underlying row is removed, if the
+    /// associated table accessor becomes detached, or if the detach() method is
+    /// called. A row accessor does not become detached for any other reason.
+    bool is_attached() const noexcept;
+
+    /// Detach this accessor from the row it was attached to. This function has
+    /// no effect if the accessor was already detached (idempotency).
+    void detach() noexcept;
+
+    /// The table containing the row to which this accessor is currently
+    /// bound. For a detached accessor, the returned value is null.
+    const table_type* get_table() const noexcept;
+    table_type* get_table() noexcept;
+
+    /// The index of the row to which this accessor is currently bound. For a
+    /// detached accessor, the returned value is unspecified.
+    size_t get_index() const noexcept;
+
+    explicit operator bool() const noexcept;
+
+private:
+    const T* table() const noexcept;
+    T* table() noexcept;
+    size_t row_ndx() const noexcept;
+};
+
+
+/// This class is a special kind of row accessor. It differes from a real row
+/// accessor (BasicRow) by having a trivial and fast copy constructor and
+/// descructor. It is supposed to be used as the return type of functions such
+/// as Table::operator[](), and then to be used as a basis for constructing a
+/// real row accessor. Objects of this class are intended to only ever exist as
+/// temporaries.
+///
+/// In contrast to a real row accessor (`BasicRow`), objects of this class do
+/// not keep the parent table "alive", nor are they maintained (adjusted) across
+/// row insertions and row removals like real row accessors are.
+///
+/// \sa BasicRow
+template<class T>
+class BasicRowExpr:
+        public RowFuncs<T, BasicRowExpr<T>> {
+public:
+    BasicRowExpr() noexcept;
+
+    template<class U>
+    BasicRowExpr(const BasicRowExpr<U>&) noexcept;
+
+private:
+    T* m_table; // nullptr if detached.
+    size_t m_row_ndx; // Undefined if detached.
+
+    BasicRowExpr(T*, size_t init_row_ndx) noexcept;
+
+    T* impl_get_table() const noexcept;
+    size_t impl_get_row_ndx() const noexcept;
+    void impl_detach() noexcept;
+
+    // Make impl_get_table(), impl_get_row_ndx(), and impl_detach() accessible
+    // from RowFuncs.
+    friend class RowFuncs<T, BasicRowExpr<T>>;
+
+    // Make m_table and m_col_ndx accessible from BasicRowExpr(const
+    // BasicRowExpr<U>&) for any U.
+    template<class>
+    friend class BasicRowExpr;
+
+    // Make m_table and m_col_ndx accessible from
+    // BasicRow::BaicRow(BasicRowExpr<U>) for any U.
+    template<class>
+    friend class BasicRow;
+
+    // Make BasicRowExpr(T*, size_t) accessible from Table.
+    friend class Table;
+};
+
+// fwd decl
+class Group;
+
+class RowBase {
+protected:
+    TableRef m_table; // nullptr if detached.
+    size_t m_row_ndx; // Undefined if detached.
+
+    void attach(Table*, size_t row_ndx) noexcept;
+    void reattach(Table*, size_t row_ndx) noexcept;
+    void impl_detach() noexcept;
+    RowBase() { }
+
+    using HandoverPatch = RowBaseHandoverPatch;
+
+    RowBase(const RowBase& source, HandoverPatch& patch);
+public:
+    static void generate_patch(const RowBase& source, HandoverPatch& patch);
+    void apply_patch(HandoverPatch& patch, Group& group);
+private:
+    RowBase* m_prev = nullptr; // nullptr if first, undefined if detached.
+    RowBase* m_next = nullptr; // nullptr if last, undefined if detached.
+
+    // Table needs to be able to modify m_table and m_row_ndx.
+    friend class Table;
+
+};
+
+
+/// An accessor class for table rows (a.k.a. a "row accessor").
+///
+/// For as long as it remains attached, a row accessor will keep the parent
+/// table accessor alive. In case the lifetime of the parent table is not
+/// managed by reference counting (such as when the table is an automatic
+/// variable on the stack), the destruction of the table will cause all
+/// remaining row accessors to be detached.
+///
+/// While attached, a row accessor is bound to a particular row of the parent
+/// table. If that row is removed, the accesssor becomes detached. If rows are
+/// inserted or removed before it (at lower row index), then the accessor is
+/// automatically adjusted to account for the change in index of the row to
+/// which the accessor is bound. In other words, a row accessor is bound to the
+/// contents of a row, not to a row index. See also is_attached().
+///
+/// Row accessors are created and used as follows:
+///
+///     Row row       = table[7];  // 8th row of `table`
+///     ConstRow crow = ctable[2]; // 3rd row of const `ctable`
+///     Row first_row = table.front();
+///     Row last_row  = table.back();
+///
+///     float v = row.get_float(1); // Get the float in the 2nd column
+///     row.set_string(0, "foo");   // Update the string in the 1st column
+///
+///     Table* t = row.get_table();      // The parent table
+///     size_t i = row.get_index(); // The current row index
+///
+/// \sa RowFuncs
+template<class T>
+class BasicRow:
+        private RowBase,
+        public RowFuncs<T, BasicRow<T>> {
+public:
+    BasicRow() noexcept;
+
+    template<class U>
+    BasicRow(BasicRowExpr<U>) noexcept;
+
+    BasicRow(const BasicRow<T>&) noexcept;
+
+    template<class U>
+    BasicRow(const BasicRow<U>&) noexcept;
+
+    template<class U>
+    BasicRow& operator=(BasicRowExpr<U>) noexcept;
+
+    template<class U>
+    BasicRow& operator=(BasicRow<U>) noexcept;
+
+    BasicRow& operator=(const BasicRow<T>&) noexcept;
+
+    ~BasicRow() noexcept;
+
+private:
+    T* impl_get_table() const noexcept;
+    size_t impl_get_row_ndx() const noexcept;
+
+    // Make impl_get_table(), impl_get_row_ndx(), and impl_detach() accessible
+    // from RowFuncs.
+    friend class RowFuncs<T, BasicRow<T>>;
+
+    // Make m_table and m_col_ndx accessible from BasicRow(const BasicRow<U>&)
+    // for any U.
+    template<class>
+    friend class BasicRow;
+
+public:
+    std::unique_ptr<BasicRow<T>> clone_for_handover(std::unique_ptr<HandoverPatch>& patch) const
+    {
+        patch.reset(new HandoverPatch);
+        std::unique_ptr<BasicRow<T>> retval(new BasicRow<T>(*this, *patch));
+        return retval;
+    }
+
+    static void generate_patch(const BasicRow& row, std::unique_ptr<HandoverPatch>& patch)
+    {
+        patch.reset(new HandoverPatch);
+        RowBase::generate_patch(row, *patch);
+    }
+
+    void apply_and_consume_patch(std::unique_ptr<HandoverPatch>& patch, Group& group)
+    {
+        apply_patch(*patch, group);
+        patch.reset();
+    }
+
+    void apply_patch(HandoverPatch& patch, Group& group)
+    {
+        RowBase::apply_patch(patch, group);
+    }
+
+private:
+    BasicRow(const BasicRow<T>& source, HandoverPatch& patch)
+        : RowBase(source, patch)
+    {
+    }
+    friend class SharedGroup;
+};
+
+typedef BasicRow<Table> Row;
+typedef BasicRow<const Table> ConstRow;
+
+
+
+
+// Implementation
+
+template<class T, class R>
+inline int_fast64_t RowFuncs<T,R>::get_int(size_t col_ndx) const noexcept
+{
+    return table()->get_int(col_ndx, row_ndx());
+}
+
+template<class T, class R>
+inline bool RowFuncs<T,R>::get_bool(size_t col_ndx) const noexcept
+{
+    return table()->get_bool(col_ndx, row_ndx());
+}
+
+template<class T, class R>
+inline float RowFuncs<T,R>::get_float(size_t col_ndx) const noexcept
+{
+    return table()->get_float(col_ndx, row_ndx());
+}
+
+template<class T, class R>
+inline double RowFuncs<T,R>::get_double(size_t col_ndx) const noexcept
+{
+    return table()->get_double(col_ndx, row_ndx());
+}
+
+template<class T, class R>
+inline StringData RowFuncs<T,R>::get_string(size_t col_ndx) const noexcept
+{
+    return table()->get_string(col_ndx, row_ndx());
+}
+
+template<class T, class R>
+inline BinaryData RowFuncs<T,R>::get_binary(size_t col_ndx) const noexcept
+{
+    return table()->get_binary(col_ndx, row_ndx());
+}
+
+template<class T, class R>
+inline OldDateTime RowFuncs<T, R>::get_olddatetime(size_t col_ndx) const noexcept
+{
+    return table()->get_olddatetime(col_ndx, row_ndx());
+}
+
+template<class T, class R>
+inline Timestamp RowFuncs<T, R>::get_timestamp(size_t col_ndx) const noexcept
+{
+    return table()->get_timestamp(col_ndx, row_ndx());
+}
+
+template<class T, class R>
+inline typename RowFuncs<T,R>::ConstTableRef RowFuncs<T,R>::get_subtable(size_t col_ndx) const
+{
+    return table()->get_subtable(col_ndx, row_ndx()); // Throws
+}
+
+template<class T, class R>
+inline typename RowFuncs<T,R>::TableRef RowFuncs<T,R>::get_subtable(size_t col_ndx)
+{
+    return table()->get_subtable(col_ndx, row_ndx()); // Throws
+}
+
+template<class T, class R>
+inline size_t RowFuncs<T,R>::get_subtable_size(size_t col_ndx) const noexcept
+{
+    return table()->get_subtable_size(col_ndx, row_ndx());
+}
+
+template<class T, class R>
+inline size_t RowFuncs<T,R>::get_link(size_t col_ndx) const noexcept
+{
+    return table()->get_link(col_ndx, row_ndx());
+}
+
+template<class T, class R>
+inline bool RowFuncs<T,R>::is_null_link(size_t col_ndx) const noexcept
+{
+    return table()->is_null_link(col_ndx, row_ndx());
+}
+
+template<class T, class R>
+inline bool RowFuncs<T,R>::is_null(size_t col_ndx) const noexcept
+{
+    return table()->is_null(col_ndx, row_ndx());
+}
+
+template<class T, class R>
+inline typename RowFuncs<T,R>::ConstLinkViewRef
+RowFuncs<T,R>::get_linklist(size_t col_ndx) const
+{
+    return table()->get_linklist(col_ndx, row_ndx()); // Throws
+}
+
+template<class T, class R>
+inline typename RowFuncs<T,R>::LinkViewRef RowFuncs<T,R>::get_linklist(size_t col_ndx)
+{
+    return table()->get_linklist(col_ndx, row_ndx()); // Throws
+}
+
+template<class T, class R>
+inline bool RowFuncs<T,R>::linklist_is_empty(size_t col_ndx) const noexcept
+{
+    return table()->linklist_is_empty(col_ndx, row_ndx());
+}
+
+template<class T, class R>
+inline size_t RowFuncs<T,R>::get_link_count(size_t col_ndx) const noexcept
+{
+    return table()->get_link_count(col_ndx, row_ndx());
+}
+
+template<class T, class R>
+inline Mixed RowFuncs<T,R>::get_mixed(size_t col_ndx) const noexcept
+{
+    return table()->get_mixed(col_ndx, row_ndx());
+}
+
+template<class T, class R>
+inline DataType RowFuncs<T,R>::get_mixed_type(size_t col_ndx) const noexcept
+{
+    return table()->get_mixed_type(col_ndx, row_ndx());
+}
+
+template<class T, class R>
+template<class U>
+inline U RowFuncs<T,R>::get(size_t col_ndx) const noexcept
+{
+    return table()->template get<U>(col_ndx, row_ndx());
+}
+
+template<class T, class R>
+inline void RowFuncs<T,R>::set_int(size_t col_ndx, int_fast64_t value)
+{
+    table()->set_int(col_ndx, row_ndx(), value); // Throws
+}
+
+template<class T, class R>
+inline void RowFuncs<T,R>::set_int_unique(size_t col_ndx, int_fast64_t value)
+{
+    table()->set_int_unique(col_ndx, row_ndx(), value); // Throws
+}
+
+template<class T, class R>
+inline void RowFuncs<T,R>::set_bool(size_t col_ndx, bool value)
+{
+    table()->set_bool(col_ndx, row_ndx(), value); // Throws
+}
+
+template<class T, class R>
+inline void RowFuncs<T,R>::set_float(size_t col_ndx, float value)
+{
+    table()->set_float(col_ndx, row_ndx(), value); // Throws
+}
+
+template<class T, class R>
+inline void RowFuncs<T,R>::set_double(size_t col_ndx, double value)
+{
+    table()->set_double(col_ndx, row_ndx(), value); // Throws
+}
+
+template<class T, class R>
+inline void RowFuncs<T,R>::set_string(size_t col_ndx, StringData value)
+{
+    table()->set_string(col_ndx, row_ndx(), value); // Throws
+}
+
+template<class T, class R>
+inline void RowFuncs<T,R>::set_string_unique(size_t col_ndx, StringData value)
+{
+    table()->set_string_unique(col_ndx, row_ndx(), value); // Throws
+}
+
+template<class T, class R>
+inline void RowFuncs<T,R>::set_binary(size_t col_ndx, BinaryData value)
+{
+    table()->set_binary(col_ndx, row_ndx(), value); // Throws
+}
+
+template<class T, class R>
+inline void RowFuncs<T, R>::set_olddatetime(size_t col_ndx, OldDateTime value)
+{
+    table()->set_olddatetime(col_ndx, row_ndx(), value); // Throws
+}
+
+template<class T, class R>
+inline void RowFuncs<T, R>::set_timestamp(size_t col_ndx, Timestamp value)
+{
+    table()->set_timestamp(col_ndx, row_ndx(), value); // Throws
+}
+
+template<class T, class R>
+inline void RowFuncs<T,R>::set_subtable(size_t col_ndx, const Table* value)
+{
+    table()->set_subtable(col_ndx, row_ndx(), value); // Throws
+}
+
+template<class T, class R>
+inline void RowFuncs<T,R>::set_link(size_t col_ndx, size_t value)
+{
+    table()->set_link(col_ndx, row_ndx(), value); // Throws
+}
+
+template<class T, class R>
+inline void RowFuncs<T,R>::nullify_link(size_t col_ndx)
+{
+    table()->nullify_link(col_ndx, row_ndx()); // Throws
+}
+
+template<class T, class R>
+inline void RowFuncs<T,R>::set_mixed(size_t col_ndx, Mixed value)
+{
+    table()->set_mixed(col_ndx, row_ndx(), value); // Throws
+}
+
+template<class T, class R>
+inline void RowFuncs<T,R>::set_mixed_subtable(size_t col_ndx, const Table* value)
+{
+    table()->set_mixed_subtable(col_ndx, row_ndx(), value); // Throws
+}
+
+template<class T, class R>
+inline void RowFuncs<T,R>::set_null(size_t col_ndx)
+{
+    table()->set_null(col_ndx, row_ndx()); // Throws
+}
+
+template<class T, class R>
+inline void RowFuncs<T,R>::insert_substring(size_t col_ndx, size_t pos, StringData value)
+{
+    table()->insert_substring(col_ndx, row_ndx(), pos, value); // Throws
+}
+
+template<class T, class R>
+inline void RowFuncs<T,R>::remove_substring(size_t col_ndx, size_t pos, size_t size)
+{
+    table()->remove_substring(col_ndx, row_ndx(), pos, size); // Throws
+}
+
+template<class T, class R>
+inline void RowFuncs<T,R>::remove()
+{
+    table()->remove(row_ndx()); // Throws
+}
+
+template<class T, class R>
+inline void RowFuncs<T,R>::move_last_over()
+{
+    table()->move_last_over(row_ndx()); // Throws
+}
+
+template<class T, class R>
+inline size_t RowFuncs<T,R>::get_backlink_count(const Table& src_table, size_t src_col_ndx) const noexcept
+{
+    return table()->get_backlink_count(row_ndx(), src_table, src_col_ndx);
+}
+
+template<class T, class R>
+inline size_t RowFuncs<T,R>::get_backlink(const Table& src_table, size_t src_col_ndx,
+                                          size_t backlink_ndx) const noexcept
+{
+    return table()->get_backlink(row_ndx(), src_table, src_col_ndx, backlink_ndx);
+}
+
+template<class T, class R>
+inline size_t RowFuncs<T,R>::get_column_count() const noexcept
+{
+    return table()->get_column_count();
+}
+
+template<class T, class R>
+inline DataType RowFuncs<T,R>::get_column_type(size_t col_ndx) const noexcept
+{
+    return table()->get_column_type(col_ndx);
+}
+
+template<class T, class R>
+inline StringData RowFuncs<T,R>::get_column_name(size_t col_ndx) const noexcept
+{
+    return table()->get_column_name(col_ndx);
+}
+
+template<class T, class R>
+inline size_t RowFuncs<T,R>::get_column_index(StringData name) const noexcept
+{
+    return table()->get_column_index(name);
+}
+
+template<class T, class R>
+inline bool RowFuncs<T,R>::is_attached() const noexcept
+{
+    return static_cast<const R*>(this)->impl_get_table();
+}
+
+template<class T, class R>
+inline void RowFuncs<T,R>::detach() noexcept
+{
+    static_cast<R*>(this)->impl_detach();
+}
+
+template<class T, class R>
+inline const T* RowFuncs<T,R>::get_table() const noexcept
+{
+    return table();
+}
+
+template<class T, class R>
+inline T* RowFuncs<T,R>::get_table() noexcept
+{
+    return table();
+}
+
+template<class T, class R>
+inline size_t RowFuncs<T,R>::get_index() const noexcept
+{
+    return row_ndx();
+}
+
+template<class T, class R>
+inline RowFuncs<T,R>::operator bool() const noexcept
+{
+    return is_attached();
+}
+
+template<class T, class R>
+inline const T* RowFuncs<T,R>::table() const noexcept
+{
+    return static_cast<const R*>(this)->impl_get_table();
+}
+
+template<class T, class R>
+inline T* RowFuncs<T,R>::table() noexcept
+{
+    return static_cast<R*>(this)->impl_get_table();
+}
+
+template<class T, class R>
+inline size_t RowFuncs<T,R>::row_ndx() const noexcept
+{
+    return static_cast<const R*>(this)->impl_get_row_ndx();
+}
+
+
+template<class T>
+inline BasicRowExpr<T>::BasicRowExpr() noexcept:
+    m_table(0),
+    m_row_ndx(0)
+{
+}
+
+template<class T>
+template<class U>
+inline BasicRowExpr<T>::BasicRowExpr(const BasicRowExpr<U>& expr) noexcept:
+    m_table(expr.m_table),
+    m_row_ndx(expr.m_row_ndx)
+{
+}
+
+template<class T>
+inline BasicRowExpr<T>::BasicRowExpr(T* init_table, size_t init_row_ndx) noexcept:
+    m_table(init_table),
+    m_row_ndx(init_row_ndx)
+{
+}
+
+template<class T>
+inline T* BasicRowExpr<T>::impl_get_table() const noexcept
+{
+    return m_table;
+}
+
+template<class T>
+inline size_t BasicRowExpr<T>::impl_get_row_ndx() const noexcept
+{
+    return m_row_ndx;
+}
+
+template<class T>
+inline void BasicRowExpr<T>::impl_detach() noexcept
+{
+    m_table = nullptr;
+}
+
+
+template<class T>
+inline BasicRow<T>::BasicRow() noexcept
+{
+}
+
+template<class T>
+inline BasicRow<T>::BasicRow(const BasicRow<T>& row) noexcept:
+    RowBase(row)
+{
+    attach(const_cast<Table*>(row.m_table.get()), row.m_row_ndx);
+}
+
+template<class T>
+template<class U>
+inline BasicRow<T>::BasicRow(BasicRowExpr<U> expr) noexcept
+{
+    T* expr_table = expr.m_table; // Check that pointer types are compatible
+    attach(const_cast<Table*>(expr_table), expr.m_row_ndx);
+}
+
+template<class T>
+template<class U>
+inline BasicRow<T>::BasicRow(const BasicRow<U>& row) noexcept
+{
+    T* row_table = row.m_table.get(); // Check that pointer types are compatible
+    attach(const_cast<Table*>(row_table), row.m_row_ndx);
+}
+
+template<class T>
+template<class U>
+inline BasicRow<T>& BasicRow<T>::operator=(BasicRowExpr<U> expr) noexcept
+{
+    T* expr_table = expr.m_table; // Check that pointer types are compatible
+    reattach(const_cast<Table*>(expr_table), expr.m_row_ndx);
+    return *this;
+}
+
+template<class T>
+template<class U>
+inline BasicRow<T>& BasicRow<T>::operator=(BasicRow<U> row) noexcept
+{
+    T* row_table = row.m_table.get(); // Check that pointer types are compatible
+    reattach(const_cast<Table*>(row_table), row.m_row_ndx);
+    return *this;
+}
+
+template<class T>
+inline BasicRow<T>& BasicRow<T>::operator=(const BasicRow<T>& row) noexcept
+{
+    reattach(const_cast<Table*>(row.m_table.get()), row.m_row_ndx);
+    return *this;
+}
+
+template<class T>
+inline BasicRow<T>::~BasicRow() noexcept
+{
+    RowBase::impl_detach();
+}
+
+template<class T>
+inline T* BasicRow<T>::impl_get_table() const noexcept
+{
+    return m_table.get();
+}
+
+template<class T>
+inline size_t BasicRow<T>::impl_get_row_ndx() const noexcept
+{
+    return m_row_ndx;
+}
+
+} // namespace realm
+
+#endif // REALM_ROW_HPP
diff --git a/Pods/Realm/include/core/realm/spec.hpp b/Pods/Realm/include/core/realm/spec.hpp
new file mode 100644
index 0000000..bb16299
--- /dev/null
+++ b/Pods/Realm/include/core/realm/spec.hpp
@@ -0,0 +1,475 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_SPEC_HPP
+#define REALM_SPEC_HPP
+
+#include <realm/util/features.h>
+#include <realm/array.hpp>
+#include <realm/array_string.hpp>
+#include <realm/array_integer.hpp>
+#include <realm/data_type.hpp>
+#include <realm/column_type.hpp>
+
+namespace realm {
+
+class Table;
+class SubspecRef;
+class ConstSubspecRef;
+
+class Spec {
+public:
+    Spec(SubspecRef) noexcept;
+    ~Spec() noexcept;
+
+    Allocator& get_alloc() const noexcept;
+
+    bool has_strong_link_columns() noexcept;
+
+    void insert_column(size_t column_ndx, ColumnType type, StringData name,
+                       ColumnAttr attr = col_attr_None);
+    void rename_column(size_t column_ndx, StringData new_name);
+    void move_column(size_t from, size_t to);
+
+    /// Erase the column at the specified index, and move columns at
+    /// succeeding indexes to the next lower index.
+    ///
+    /// This function is guaranteed to *never* throw if the spec is
+    /// used in a non-transactional context, or if the spec has
+    /// already been successfully modified within the current write
+    /// transaction.
+    void erase_column(size_t column_ndx);
+
+    //@{
+    // If a new Spec is constructed from the returned subspec
+    // reference, it is the responsibility of the application that the
+    // parent Spec object (this) is kept alive for at least as long as
+    // the new Spec object.
+    SubspecRef get_subtable_spec(size_t column_ndx) noexcept;
+    ConstSubspecRef get_subtable_spec(size_t column_ndx) const noexcept;
+    //@}
+
+    // Column info
+    size_t get_column_count() const noexcept;
+    size_t get_public_column_count() const noexcept;
+    DataType get_public_column_type(size_t column_ndx) const noexcept;
+    ColumnType get_column_type(size_t column_ndx) const noexcept;
+    StringData get_column_name(size_t column_ndx) const noexcept;
+
+    /// Returns size_t(-1) if the specified column is not found.
+    size_t get_column_index(StringData name) const noexcept;
+
+    // Column Attributes
+    ColumnAttr get_column_attr(size_t column_ndx) const noexcept;
+
+    size_t get_subspec_ndx(size_t column_ndx) const noexcept;
+    ref_type get_subspec_ref(size_t subspec_ndx) const noexcept;
+    SubspecRef get_subspec_by_ndx(size_t subspec_ndx) noexcept;
+    ConstSubspecRef get_subspec_by_ndx(size_t subspec_ndx) const noexcept;
+
+    // Auto Enumerated string columns
+    void upgrade_string_to_enum(size_t column_ndx, ref_type keys_ref,
+                                ArrayParent*& keys_parent, size_t& keys_ndx);
+    size_t get_enumkeys_ndx(size_t column_ndx) const noexcept;
+    ref_type get_enumkeys_ref(size_t column_ndx, ArrayParent** keys_parent = nullptr,
+                              size_t* keys_ndx = nullptr) noexcept;
+
+    // Links
+    size_t get_opposite_link_table_ndx(size_t column_ndx) const noexcept;
+    void set_opposite_link_table_ndx(size_t column_ndx, size_t table_ndx);
+    bool has_backlinks() const noexcept;
+    void set_backlink_origin_column(size_t backlink_col_ndx, size_t origin_col_ndx);
+    size_t get_origin_column_ndx(size_t backlink_col_ndx) const noexcept;
+    size_t find_backlink_column(size_t origin_table_ndx,
+                                size_t origin_col_ndx) const noexcept;
+
+    /// Get position in `Table::m_columns` of the specified column. It may be
+    /// different from the specified logical column index due to the presence of
+    /// search indexes, since their top refs are stored in Table::m_columns as
+    /// well.
+    size_t get_column_ndx_in_parent(size_t column_ndx) const;
+
+    //@{
+    /// Compare two table specs for equality.
+    bool operator==(const Spec&) const noexcept;
+    bool operator!=(const Spec&) const noexcept;
+    //@}
+
+    void destroy() noexcept;
+
+    size_t get_ndx_in_parent() const noexcept;
+    void set_ndx_in_parent(size_t) noexcept;
+
+#ifdef REALM_DEBUG
+    void verify() const;
+    void to_dot(std::ostream&, StringData title = StringData()) const;
+#endif
+
+private:
+    // Underlying array structure.
+    //
+    // `m_subspecs` contains one entry for each subtable column, one entry for
+    // each link or link list columns, two entries for each backlink column, and
+    // zero entries for all other column types. For subtable columns the entry
+    // is a ref pointing to the subtable spec, for link and link list columns it
+    // is the group-level table index of the target table, and for backlink
+    // columns the first entry is the group-level table index of the origin
+    // table, and the second entry is the index of the origin column in the
+    // origin table.
+    Array m_top;
+    ArrayInteger m_types;// 1st slot in m_top
+    ArrayString m_names; // 2nd slot in m_top
+    ArrayInteger m_attr; // 3rd slot in m_top
+    Array m_subspecs;    // 4th slot in m_top (optional)
+    Array m_enumkeys;    // 5th slot in m_top (optional)
+    bool m_has_strong_link_columns;
+
+    Spec(Allocator&) noexcept; // Unattached
+
+    void init(ref_type) noexcept;
+    void init(MemRef) noexcept;
+    void init(SubspecRef) noexcept;
+    void update_has_strong_link_columns() noexcept;
+
+    // Similar in function to Array::init_from_parent().
+    void init_from_parent() noexcept;
+
+    ref_type get_ref() const noexcept;
+
+    /// Called in the context of Group::commit() to ensure that
+    /// attached table accessors stay valid across a commit. Please
+    /// note that this works only for non-transactional commits. Table
+    /// accessors obtained during a transaction are always detached
+    /// when the transaction ends.
+    void update_from_parent(size_t old_baseline) noexcept;
+
+    void set_parent(ArrayParent*, size_t ndx_in_parent) noexcept;
+
+    void set_column_type(size_t column_ndx, ColumnType type);
+    void set_column_attr(size_t column_ndx, ColumnAttr attr);
+
+    /// Construct an empty spec and return just the reference to the
+    /// underlying memory.
+    static MemRef create_empty_spec(Allocator&);
+
+    struct ColumnInfo {
+        size_t m_column_ref_ndx = 0; ///< Index within Table::m_columns
+        bool m_has_search_index = false;
+    };
+
+    ColumnInfo get_column_info(size_t column_ndx) const noexcept;
+
+    size_t get_subspec_ndx_after(size_t column_ndx, size_t skip_column_ndx) const noexcept;
+    bool has_subspec() const noexcept;
+
+    // Returns false if the spec has no columns, otherwise it returns
+    // true and sets `type` to the type of the first column.
+    static bool get_first_column_type_from_ref(ref_type, Allocator&,
+                                               ColumnType& type) noexcept;
+
+    friend class Replication;
+    friend class Group;
+    friend class Table;
+};
+
+
+
+class SubspecRef {
+public:
+    struct const_cast_tag {};
+    SubspecRef(const_cast_tag, ConstSubspecRef r) noexcept;
+    ~SubspecRef() noexcept {}
+    Allocator& get_alloc() const noexcept { return m_parent->get_alloc(); }
+
+private:
+    Array* const m_parent;
+    size_t const m_ndx_in_parent;
+
+    SubspecRef(Array* parent, size_t ndx_in_parent) noexcept;
+
+    friend class Spec;
+    friend class ConstSubspecRef;
+};
+
+class ConstSubspecRef {
+public:
+    ConstSubspecRef(SubspecRef r) noexcept;
+    ~ConstSubspecRef() noexcept {}
+    Allocator& get_alloc() const noexcept { return m_parent->get_alloc(); }
+
+private:
+    const Array* const m_parent;
+    size_t const m_ndx_in_parent;
+
+    ConstSubspecRef(const Array* parent, size_t ndx_in_parent) noexcept;
+
+    friend class Spec;
+    friend class SubspecRef;
+};
+
+
+
+
+
+// Implementation:
+
+inline Allocator& Spec::get_alloc() const noexcept
+{
+    return m_top.get_alloc();
+}
+
+inline bool Spec::has_strong_link_columns() noexcept
+{
+    return m_has_strong_link_columns;
+}
+
+inline ref_type Spec::get_subspec_ref(size_t subspec_ndx) const noexcept
+{
+    REALM_ASSERT(subspec_ndx < m_subspecs.size());
+
+    // Note that this addresses subspecs directly, indexing
+    // by number of sub-table columns
+    return m_subspecs.get_as_ref(subspec_ndx);
+}
+
+inline Spec::Spec(SubspecRef r) noexcept:
+    m_top(r.m_parent->get_alloc()),
+    m_types(r.m_parent->get_alloc()),
+    m_names(r.m_parent->get_alloc()),
+    m_attr(r.m_parent->get_alloc()),
+    m_subspecs(r.m_parent->get_alloc()),
+    m_enumkeys(r.m_parent->get_alloc())
+{
+    init(r);
+}
+
+// Uninitialized Spec (call init() to init)
+inline Spec::Spec(Allocator& alloc) noexcept:
+    m_top(alloc),
+    m_types(alloc),
+    m_names(alloc),
+    m_attr(alloc),
+    m_subspecs(alloc),
+    m_enumkeys(alloc)
+{
+}
+
+inline SubspecRef Spec::get_subtable_spec(size_t column_ndx) noexcept
+{
+    REALM_ASSERT(column_ndx < get_column_count());
+    REALM_ASSERT(get_column_type(column_ndx) == col_type_Table);
+    size_t subspec_ndx = get_subspec_ndx(column_ndx);
+    return SubspecRef(&m_subspecs, subspec_ndx);
+}
+
+inline ConstSubspecRef Spec::get_subtable_spec(size_t column_ndx) const noexcept
+{
+    REALM_ASSERT(column_ndx < get_column_count());
+    REALM_ASSERT(get_column_type(column_ndx) == col_type_Table);
+    size_t subspec_ndx = get_subspec_ndx(column_ndx);
+    return ConstSubspecRef(&m_subspecs, subspec_ndx);
+}
+
+inline SubspecRef Spec::get_subspec_by_ndx(size_t subspec_ndx) noexcept
+{
+    return SubspecRef(&m_subspecs, subspec_ndx);
+}
+
+inline ConstSubspecRef Spec::get_subspec_by_ndx(size_t subspec_ndx) const noexcept
+{
+    return const_cast<Spec*>(this)->get_subspec_by_ndx(subspec_ndx);
+}
+
+inline void Spec::init(ref_type ref) noexcept
+{
+    MemRef mem(ref, get_alloc());
+    init(mem);
+}
+
+inline void Spec::init(SubspecRef r) noexcept
+{
+    m_top.set_parent(r.m_parent, r.m_ndx_in_parent);
+    ref_type ref = r.m_parent->get_as_ref(r.m_ndx_in_parent);
+    init(ref);
+}
+
+inline void Spec::init_from_parent() noexcept
+{
+    ref_type ref = m_top.get_ref_from_parent();
+    init(ref);
+}
+
+inline void Spec::destroy() noexcept
+{
+    m_top.destroy_deep();
+}
+
+inline size_t Spec::get_ndx_in_parent() const noexcept
+{
+    return m_top.get_ndx_in_parent();
+}
+
+inline void Spec::set_ndx_in_parent(size_t ndx) noexcept
+{
+    m_top.set_ndx_in_parent(ndx);
+}
+
+inline ref_type Spec::get_ref() const noexcept
+{
+    return m_top.get_ref();
+}
+
+inline void Spec::set_parent(ArrayParent* parent, size_t ndx_in_parent) noexcept
+{
+    m_top.set_parent(parent, ndx_in_parent);
+}
+
+inline void Spec::rename_column(size_t column_ndx, StringData new_name)
+{
+    REALM_ASSERT(column_ndx < m_types.size());
+    m_names.set(column_ndx, new_name);
+}
+
+inline size_t Spec::get_column_count() const noexcept
+{
+    // This is the total count of columns, including backlinks (not public)
+    return m_types.size();
+}
+
+inline size_t Spec::get_public_column_count() const noexcept
+{
+    // Backlinks are the last columns, and do not have names, so getting
+    // the number of names gives us the count of user facing columns
+    return m_names.size();
+}
+
+inline ColumnType Spec::get_column_type(size_t ndx) const noexcept
+{
+    REALM_ASSERT(ndx < get_column_count());
+    return ColumnType(m_types.get(ndx));
+}
+
+inline void Spec::set_column_type(size_t column_ndx, ColumnType type)
+{
+    REALM_ASSERT(column_ndx < get_column_count());
+
+    // At this point we only support upgrading to string enum
+    REALM_ASSERT(ColumnType(m_types.get(column_ndx)) == col_type_String);
+    REALM_ASSERT(type == col_type_StringEnum);
+
+    m_types.set(column_ndx, type); // Throws
+
+    update_has_strong_link_columns();
+}
+
+inline ColumnAttr Spec::get_column_attr(size_t ndx) const noexcept
+{
+    REALM_ASSERT(ndx < get_column_count());
+    return ColumnAttr(m_attr.get(ndx));
+}
+
+inline void Spec::set_column_attr(size_t column_ndx, ColumnAttr attr)
+{
+    REALM_ASSERT(column_ndx < get_column_count());
+
+    // At this point we only allow one attr at a time
+    // so setting it will overwrite existing. In the future
+    // we will allow combinations.
+    m_attr.set(column_ndx, attr);
+
+    update_has_strong_link_columns();
+}
+
+inline StringData Spec::get_column_name(size_t ndx) const noexcept
+{
+    REALM_ASSERT(ndx < get_column_count());
+    return m_names.get(ndx);
+}
+
+inline size_t Spec::get_column_index(StringData name) const noexcept
+{
+    return m_names.find_first(name);
+}
+
+inline bool Spec::get_first_column_type_from_ref(ref_type top_ref, Allocator& alloc,
+                                                 ColumnType& type) noexcept
+{
+    const char* top_header = alloc.translate(top_ref);
+    ref_type types_ref = to_ref(Array::get(top_header, 0));
+    const char* types_header = alloc.translate(types_ref);
+    if (Array::get_size_from_header(types_header) == 0)
+        return false;
+    type = ColumnType(Array::get(types_header, 0));
+    return true;
+}
+
+inline bool Spec::has_backlinks() const noexcept
+{
+    // backlinks are always last and do not have names.
+    return m_names.size() < m_types.size();
+
+    // Fixme: It's bad design that backlinks are stored and recognized like this. Backlink columns
+    // should be a column type like any other, and we should find another way to hide them away from
+    // the user.
+}
+
+// Spec will have a subspec when it contains a column which is one of:
+// link, linklist, backlink, or subtable. It is possible for m_top.size()
+// to contain an entry for m_subspecs (at index 3) but this reference
+// may be empty if the spec contains enumkeys (at index 4) but no subspec types.
+inline bool Spec::has_subspec() const noexcept
+{
+    return (m_top.size() >= 4) && (m_top.get_as_ref(3) != 0);
+}
+
+inline bool Spec::operator!=(const Spec &s) const noexcept
+{
+    return !(*this == s);
+}
+
+
+inline SubspecRef::SubspecRef(Array* parent, size_t ndx_in_parent) noexcept:
+    m_parent(parent),
+    m_ndx_in_parent(ndx_in_parent)
+{
+}
+
+inline SubspecRef::SubspecRef(const_cast_tag, ConstSubspecRef r) noexcept:
+    m_parent(const_cast<Array*>(r.m_parent)),
+    m_ndx_in_parent(r.m_ndx_in_parent)
+{
+}
+
+inline ConstSubspecRef::ConstSubspecRef(const Array* parent,
+                                        size_t ndx_in_parent) noexcept:
+    m_parent(parent),
+    m_ndx_in_parent(ndx_in_parent)
+{
+}
+
+inline ConstSubspecRef::ConstSubspecRef(SubspecRef r) noexcept:
+        m_parent(r.m_parent),
+    m_ndx_in_parent(r.m_ndx_in_parent)
+{
+}
+
+
+} // namespace realm
+
+#endif // REALM_SPEC_HPP
diff --git a/Pods/Realm/include/core/realm/string_data.hpp b/Pods/Realm/include/core/realm/string_data.hpp
new file mode 100644
index 0000000..0b93c9a
--- /dev/null
+++ b/Pods/Realm/include/core/realm/string_data.hpp
@@ -0,0 +1,327 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_STRING_HPP
+#define REALM_STRING_HPP
+
+#include <cstddef>
+#include <algorithm>
+#include <string>
+#include <ostream>
+#include <cstring>
+
+#include <cfloat>
+#include <math.h>
+
+#include <realm/util/features.h>
+#include <realm/util/optional.hpp>
+#include <realm/utilities.hpp>
+#include <realm/null.hpp>
+#include <realm/owned_data.hpp>
+
+namespace realm {
+
+/// A reference to a chunk of character data.
+///
+/// An instance of this class can be thought of as a type tag on a region of
+/// memory. It does not own the referenced memory, nor does it in any other way
+/// attempt to manage the lifetime of it.
+///
+/// A null character inside the referenced region is considered a part of the
+/// string by Realm.
+///
+/// For compatibility with C-style strings, when a string is stored in a Realm
+/// database, it is always followed by a terminating null character, regardless
+/// of whether the string itself has internal null characters. This means that
+/// when a StringData object is extracted from Realm, the referenced region is
+/// guaranteed to be followed immediately by an extra null character, but that
+/// null character is not inside the referenced region. Therefore, all of the
+/// following forms are guaranteed to return a pointer to a null-terminated
+/// string:
+///
+/// \code{.cpp}
+///
+///   group.get_table_name(...).data()
+///   table.get_column_name().data()
+///   table.get_string(...).data()
+///   table.get_mixed(...).get_string().data()
+///
+/// \endcode
+///
+/// Note that in general, no assumptions can be made about what follows a string
+/// that is referenced by a StringData object, or whether anything follows it at
+/// all. In particular, the receiver of a StringData object cannot assume that
+/// the referenced string is followed by a null character unless there is an
+/// externally provided guarantee.
+///
+/// This class makes it possible to distinguish between a 'null' reference and a
+/// reference to the empty string (see is_null()).
+///
+/// \sa BinaryData
+/// \sa Mixed
+class StringData {
+public:
+    /// Construct a null reference.
+    StringData() noexcept;
+
+    /// If \a external_data is 'null', \a data_size must be zero.
+    StringData(const char* external_data, size_t data_size) noexcept;
+
+    template<class T, class A>
+    StringData(const std::basic_string<char, T, A>&);
+
+    template<class T, class A>
+    operator std::basic_string<char, T, A>() const;
+
+    // StringData does not store data, callers must manage their own strings.
+    template<class T, class A>
+    StringData(std::basic_string<char, T, A>&&) = delete;
+
+    template<class T, class A>
+    StringData(const util::Optional<std::basic_string<char, T, A>>&);
+
+    StringData(const null&) noexcept;
+
+    /// Initialize from a zero terminated C style string. Pass null to construct
+    /// a null reference.
+    StringData(const char* c_str) noexcept;
+
+    char operator[](size_t i) const noexcept;
+
+    const char* data() const noexcept;
+    size_t size() const noexcept;
+
+    /// Is this a null reference?
+    ///
+    /// An instance of StringData is a null reference when, and only when the
+    /// stored size is zero (size()) and the stored pointer is the null pointer
+    /// (data()).
+    ///
+    /// In the case of the empty string, the stored size is still zero, but the
+    /// stored pointer is **not** the null pointer. It could for example point
+    /// to the empty string literal. Note that the actual value of the pointer
+    /// is immaterial in this case (as long as it is not zero), because when the
+    /// size is zero, it is an error to dereference the pointer.
+    ///
+    /// Conversion of a StringData object to `bool` yields the logical negation
+    /// of the result of calling this function. In other words, a StringData
+    /// object is converted to true if it is not the null reference, otherwise
+    /// it is converted to false.
+    bool is_null() const noexcept;
+
+    friend bool operator==(const StringData&, const StringData&) noexcept;
+    friend bool operator!=(const StringData&, const StringData&) noexcept;
+
+    //@{
+    /// Trivial bytewise lexicographical comparison.
+    friend bool operator<(const StringData&, const StringData&) noexcept;
+    friend bool operator>(const StringData&, const StringData&) noexcept;
+    friend bool operator<=(const StringData&, const StringData&) noexcept;
+    friend bool operator>=(const StringData&, const StringData&) noexcept;
+    //@}
+
+    bool begins_with(StringData) const noexcept;
+    bool ends_with(StringData) const noexcept;
+    bool contains(StringData) const noexcept;
+
+    //@{
+    /// Undefined behavior if \a n, \a i, or <tt>i+n</tt> is greater than
+    /// size().
+    StringData prefix(size_t n) const noexcept;
+    StringData suffix(size_t n) const noexcept;
+    StringData substr(size_t i, size_t n) const noexcept;
+    StringData substr(size_t i) const noexcept;
+    //@}
+
+    template<class C, class T>
+    friend std::basic_ostream<C,T>& operator<<(std::basic_ostream<C,T>&, const StringData&);
+
+    explicit operator bool() const noexcept;
+
+private:
+    const char* m_data;
+    size_t m_size;
+};
+
+
+// Implementation:
+
+inline StringData::StringData() noexcept:
+    m_data(nullptr),
+    m_size(0)
+{
+}
+
+inline StringData::StringData(const char* external_data, size_t data_size) noexcept:
+    m_data(external_data),
+    m_size(data_size)
+{
+    REALM_ASSERT_DEBUG(external_data || data_size == 0);
+}
+
+template<class T, class A>
+inline StringData::StringData(const std::basic_string<char, T, A>& s):
+    m_data(s.data()),
+    m_size(s.size())
+{
+}
+
+template<class T, class A>
+inline StringData::operator std::basic_string<char, T, A>() const
+{
+    return std::basic_string<char, T, A>(m_data, m_size);
+}
+
+template<class T, class A>
+inline StringData::StringData(const util::Optional<std::basic_string<char, T, A>>& s):
+    m_data(s ? s->data() : nullptr),
+    m_size(s ? s->size() : 0)
+{
+}
+
+inline StringData::StringData(const null&) noexcept:
+    m_data(nullptr),
+    m_size(0)
+{
+
+}
+
+inline StringData::StringData(const char* c_str) noexcept:
+    m_data(c_str),
+    m_size(0)
+{
+    if (c_str)
+        m_size = std::char_traits<char>::length(c_str);
+}
+
+inline char StringData::operator[](size_t i) const noexcept
+{
+    return m_data[i];
+}
+
+inline const char* StringData::data() const noexcept
+{
+    return m_data;
+}
+
+inline size_t StringData::size() const noexcept
+{
+    return m_size;
+}
+
+inline bool StringData::is_null() const noexcept
+{
+    return !m_data;
+}
+
+inline bool operator==(const StringData& a, const StringData& b) noexcept
+{
+    return a.m_size == b.m_size && a.is_null() == b.is_null() && safe_equal(a.m_data, a.m_data + a.m_size, b.m_data);
+}
+
+inline bool operator!=(const StringData& a, const StringData& b) noexcept
+{
+    return !(a == b);
+}
+
+inline bool operator<(const StringData& a, const StringData& b) noexcept
+{
+    if (a.is_null() && !b.is_null()) {
+        // Null strings are smaller than all other strings, and not
+        // equal to empty strings.
+        return true;
+    }
+    return std::lexicographical_compare(a.m_data, a.m_data + a.m_size,
+                                        b.m_data, b.m_data + b.m_size);
+}
+
+inline bool operator>(const StringData& a, const StringData& b) noexcept
+{
+    return b < a;
+}
+
+inline bool operator<=(const StringData& a, const StringData& b) noexcept
+{
+    return !(b < a);
+}
+
+inline bool operator>=(const StringData& a, const StringData& b) noexcept
+{
+    return !(a < b);
+}
+
+inline bool StringData::begins_with(StringData d) const noexcept
+{
+    if (is_null() && !d.is_null())
+        return false;
+    return d.m_size <= m_size && safe_equal(m_data, m_data + d.m_size, d.m_data);
+}
+
+inline bool StringData::ends_with(StringData d) const noexcept
+{
+    if (is_null() && !d.is_null())
+        return false;
+    return d.m_size <= m_size && safe_equal(m_data + m_size - d.m_size, m_data + m_size, d.m_data);
+}
+
+inline bool StringData::contains(StringData d) const noexcept
+{
+    if (is_null() && !d.is_null())
+        return false;
+
+    return d.m_size == 0 ||
+        std::search(m_data, m_data + m_size, d.m_data, d.m_data + d.m_size) != m_data + m_size;
+}
+
+inline StringData StringData::prefix(size_t n) const noexcept
+{
+    return substr(0,n);
+}
+
+inline StringData StringData::suffix(size_t n) const noexcept
+{
+    return substr(m_size - n);
+}
+
+inline StringData StringData::substr(size_t i, size_t n) const noexcept
+{
+    return StringData(m_data + i, n);
+}
+
+inline StringData StringData::substr(size_t i) const noexcept
+{
+    return substr(i, m_size - i);
+}
+
+template<class C, class T>
+inline std::basic_ostream<C,T>& operator<<(std::basic_ostream<C,T>& out, const StringData& d)
+{
+    for (const char* i = d.m_data; i != d.m_data + d.m_size; ++i)
+        out << *i;
+    return out;
+}
+
+inline StringData::operator bool() const noexcept
+{
+    return !is_null();
+}
+
+} // namespace realm
+
+#endif // REALM_STRING_HPP
diff --git a/Pods/Realm/include/core/realm/table.hpp b/Pods/Realm/include/core/realm/table.hpp
new file mode 100644
index 0000000..aba3843
--- /dev/null
+++ b/Pods/Realm/include/core/realm/table.hpp
@@ -0,0 +1,2392 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_TABLE_HPP
+#define REALM_TABLE_HPP
+
+#include <algorithm>
+#include <map>
+#include <utility>
+#include <typeinfo>
+#include <memory>
+
+#include <realm/util/features.h>
+#include <realm/util/thread.hpp>
+#include <realm/util/tuple.hpp>
+#include <realm/column_fwd.hpp>
+#include <realm/table_ref.hpp>
+#include <realm/link_view_fwd.hpp>
+#include <realm/row.hpp>
+#include <realm/descriptor_fwd.hpp>
+#include <realm/spec.hpp>
+#include <realm/mixed.hpp>
+#include <realm/query.hpp>
+#include <realm/column.hpp>
+#include <realm/column_binary.hpp>
+#include <realm/column_timestamp.hpp>
+
+namespace realm {
+
+class TableView;
+class LinkView;
+class TableViewBase;
+class ConstTableView;
+class StringIndex;
+class Group;
+class LinkColumnBase;
+class LinkColumn;
+class LinkListColumn;
+class BacklinkColumn;
+template<class>
+class Columns;
+template<class>
+class SubQuery;
+struct LinkTargetInfo;
+
+struct Link {};
+typedef Link LinkList;
+typedef Link BackLink;
+
+namespace _impl { class TableFriend; }
+
+class Replication;
+
+
+/// The Table class is non-polymorphic, that is, it has no virtual
+/// functions. This is important because it ensures that there is no run-time
+/// distinction between a Table instance and an instance of any variation of
+/// BasicTable<T>, and this, in turn, makes it valid to cast a pointer from
+/// Table to BasicTable<T> even when the instance is constructed as a Table. Of
+/// course, this also assumes that BasicTable<> is non-polymorphic, has no
+/// destructor, and adds no extra data members.
+///
+/// FIXME: Table assignment (from any group to any group) could be made aliasing
+/// safe as follows: Start by cloning source table into target allocator. On
+/// success, assign, and then deallocate any previous structure at the target.
+///
+/// FIXME: It might be desirable to have a 'table move' feature between two
+/// places inside the same group (say from a subtable or a mixed column to group
+/// level). This could be done in a very efficient manner.
+///
+/// FIXME: When compiling in debug mode, all public non-static table functions
+/// should REALM_ASSERT(is_attached()).
+class Table {
+public:
+    /// Construct a new freestanding top-level table with static
+    /// lifetime.
+    ///
+    /// This constructor should be used only when placing a table
+    /// instance on the stack, and it is then the responsibility of
+    /// the application that there are no objects of type TableRef or
+    /// ConstTableRef that refer to it, or to any of its subtables,
+    /// when it goes out of scope. To create a top-level table with
+    /// dynamic lifetime, use Table::create() instead.
+    Table(Allocator& = Allocator::get_default());
+
+    /// Construct a copy of the specified table as a new freestanding
+    /// top-level table with static lifetime.
+    ///
+    /// This constructor should be used only when placing a table
+    /// instance on the stack, and it is then the responsibility of
+    /// the application that there are no objects of type TableRef or
+    /// ConstTableRef that refer to it, or to any of its subtables,
+    /// when it goes out of scope. To create a top-level table with
+    /// dynamic lifetime, use Table::copy() instead.
+    Table(const Table&, Allocator& = Allocator::get_default());
+
+    ~Table() noexcept;
+
+    Allocator& get_alloc() const;
+
+    /// Construct a new freestanding top-level table with dynamic lifetime.
+    static TableRef create(Allocator& = Allocator::get_default());
+
+    /// Construct a copy of the specified table as a new freestanding top-level
+    /// table with dynamic lifetime.
+    TableRef copy(Allocator& = Allocator::get_default()) const;
+
+    /// Returns true if, and only if this accessor is currently attached to an
+    /// underlying table.
+    ///
+    /// A table accessor may get detached from the underlying row for various
+    /// reasons (see below). When it does, it no longer refers to anything, and
+    /// can no longer be used, except for calling is_attached(). The
+    /// consequences of calling other non-static functions on a detached table
+    /// accessor are unspecified. Table accessors obtained by calling functions in
+    /// the Realm API are always in the 'attached' state immediately upon
+    /// return from those functions.
+    ///
+    /// A table accessor of a free-standing table never becomes detached (except
+    /// during its eventual destruction). A group-level table accessor becomes
+    /// detached if the underlying table is removed from the group, or when the
+    /// group accessor is destroyed. A subtable accessor becomes detached if the
+    /// underlying subtable is removed, or if the parent table accessor is
+    /// detached. A table accessor does not become detached for any other reason
+    /// than those mentioned here.
+    ///
+    /// FIXME: High level language bindings will probably want to be able to
+    /// explicitely detach a group and all tables of that group if any modifying
+    /// operation fails (e.g. memory allocation failure) (and something similar
+    /// for freestanding tables) since that leaves the group in state where any
+    /// further access is disallowed. This way they will be able to reliably
+    /// intercept any attempt at accessing such a failed group.
+    ///
+    /// FIXME: The C++ documentation must state that if any modifying operation
+    /// on a group (incl. tables, subtables, and specs) or on a free standing
+    /// table (incl. subtables and specs) fails, then any further access to that
+    /// group (except ~Group()) or freestanding table (except ~Table()) has
+    /// undefined behaviour and is considered an error on behalf of the
+    /// application. Note that even Table::is_attached() is disallowed in this
+    /// case.
+    bool is_attached() const noexcept;
+
+    /// Get the name of this table, if it has one. Only group-level tables have
+    /// names. For a table of any other kind, this function returns the empty
+    /// string.
+    StringData get_name() const noexcept;
+
+    // Whether or not elements can be null.
+    bool is_nullable(size_t col_ndx) const;
+
+    //@{
+    /// Conventience functions for inspecting the dynamic table type.
+    ///
+    /// These functions behave as if they were called on the descriptor returned
+    /// by get_descriptor().
+    size_t get_column_count() const noexcept;
+    DataType    get_column_type(size_t column_ndx) const noexcept;
+    StringData  get_column_name(size_t column_ndx) const noexcept;
+    size_t get_column_index(StringData name) const noexcept;
+    //@}
+
+    //@{
+    /// Convenience functions for manipulating the dynamic table type.
+    ///
+    /// These function must be called only for tables with independent dynamic
+    /// type. A table has independent dynamic type if the function
+    /// has_shared_type() returns false. A table that is a direct member of a
+    /// group has independent dynamic type. So does a free-standing table, and a
+    /// subtable in a column of type 'mixed'. All other tables have shared
+    /// dynamic type. The consequences of calling any of these functions for a
+    /// table with shared dynamic type are undefined.
+    ///
+    /// Apart from that, these functions behave as if they were called on the
+    /// descriptor returned by get_descriptor(). Note especially that the
+    /// `_link` suffixed functions must be used when inserting link-type
+    /// columns.
+    ///
+    /// If you need to change the shared dynamic type of the subtables in a
+    /// subtable column, consider using the API offered by the Descriptor class.
+    ///
+    /// \sa has_shared_type()
+    /// \sa get_descriptor()
+
+    size_t add_column(DataType type, StringData name, bool nullable = false, DescriptorRef* subdesc = nullptr);
+    void insert_column(size_t column_ndx, DataType type, StringData name, bool nullable = false,
+                       DescriptorRef* subdesc = nullptr);
+
+    // Todo, these prototypes only exist for backwards compatibility. We should remove them because they are error
+    // prone (optional arguments and implicit bool to null-ptr conversion)
+    size_t add_column(DataType type, StringData name, DescriptorRef* subdesc)
+    {
+        return add_column(type, name, false, subdesc);
+    }
+    void insert_column(size_t column_ndx, DataType type, StringData name, DescriptorRef* subdesc)
+    {
+        insert_column(column_ndx, type, name, false, subdesc);
+    }
+
+    size_t add_column_link(DataType type, StringData name, Table& target, LinkType link_type = link_Weak);
+    void insert_column_link(size_t column_ndx, DataType type, StringData name, Table& target,
+                            LinkType link_type = link_Weak);
+    void remove_column(size_t column_ndx);
+    void rename_column(size_t column_ndx, StringData new_name);
+    //@}
+
+    //@{
+
+    /// has_search_index() returns true if, and only if a search index has been
+    /// added to the specified column. Rather than throwing, it returns false if
+    /// the table accessor is detached or the specified index is out of range.
+    ///
+    /// add_search_index() adds a search index to the specified column of this
+    /// table. It has no effect if a search index has already been added to the
+    /// specified column (idempotency).
+    ///
+    /// remove_search_index() removes the search index from the specified column
+    /// of this table. It has no effect if the specified column has no search
+    /// index. The search index cannot be removed from the primary key of a
+    /// table.
+    ///
+    /// This table must be a root table; that is, it must have an independent
+    /// descriptor. Freestanding tables, group-level tables, and subtables in a
+    /// column of type 'mixed' are all examples of root tables. See add_column()
+    /// for more on this.
+    ///
+    /// \param column_ndx The index of a column of this table.
+
+    bool has_search_index(size_t column_ndx) const noexcept;
+    void add_search_index(size_t column_ndx);
+    void remove_search_index(size_t column_ndx);
+
+    //@}
+
+    //@{
+    /// Get the dynamic type descriptor for this table.
+    ///
+    /// Every table has an associated descriptor that specifies its dynamic
+    /// type. For simple tables, that is, tables without subtable columns, the
+    /// dynamic type can be inspected and modified directly using member
+    /// functions such as get_column_count() and add_column(). For more complex
+    /// tables, the type is best managed through the associated descriptor
+    /// object which is returned by this function.
+    ///
+    /// \sa has_shared_type()
+    DescriptorRef get_descriptor();
+    ConstDescriptorRef get_descriptor() const;
+    //@}
+
+    //@{
+    /// Get the dynamic type descriptor for the column with the
+    /// specified index. That column must have type 'table'.
+    ///
+    /// This is merely a shorthand for calling `get_subdescriptor(column_ndx)`
+    /// on the descriptor returned by `get_descriptor()`.
+    DescriptorRef get_subdescriptor(size_t column_ndx);
+    ConstDescriptorRef get_subdescriptor(size_t column_ndx) const;
+    //@}
+
+    //@{
+    /// Get access to an arbitrarily nested dynamic type descriptor.
+    ///
+    /// The returned descriptor is the one you would get by calling
+    /// Descriptor::get_subdescriptor() once for each entry in the specified
+    /// path, starting with the descriptor returned by get_descriptor(). The
+    /// path is allowed to be empty.
+    typedef std::vector<size_t> path_vec;
+    DescriptorRef get_subdescriptor(const path_vec& path);
+    ConstDescriptorRef get_subdescriptor(const path_vec& path) const;
+    //@}
+
+    //@{
+    /// Convenience functions for manipulating nested table types.
+    ///
+    /// These functions behave as if they were called on the descriptor returned
+    /// by `get_subdescriptor(path)`. These function must be called only on
+    /// tables with independent dynamic type.
+    ///
+    /// \return The value returned by add_subcolumn(), is the index of
+    /// the added column within the descriptor referenced by the
+    /// specified path.
+    ///
+    /// \sa Descriptor::add_column()
+    /// \sa has_shared_type()
+    size_t add_subcolumn(const path_vec& path, DataType type, StringData name);
+    void insert_subcolumn(const path_vec& path, size_t column_ndx,
+                          DataType type, StringData name);
+    void remove_subcolumn(const path_vec& path, size_t column_ndx);
+    void rename_subcolumn(const path_vec& path, size_t column_ndx, StringData new_name);
+    //@}
+
+    /// Does this table share its type with other tables?
+    ///
+    /// Tables that are direct members of groups have independent
+    /// dynamic types. The same is true for free-standing tables and
+    /// subtables in coulmns of type 'mixed'. For such tables, this
+    /// function returns false.
+    ///
+    /// When a table has a column of type 'table', the cells in that
+    /// column contain subtables. All those subtables have the same
+    /// dynamic type, and they share a single type descriptor. For all
+    /// such subtables, this function returns true. See
+    /// Descriptor::is_root() for more on this.
+    ///
+    /// Please note that Table functions that modify the dynamic type
+    /// directly, such as add_column(), are only allowed to be used on
+    /// tables with non-shared type. If you need to modify a shared
+    /// type, you will have to do that through the descriptor returned
+    /// by get_descriptor(), but note that it will then affect all the
+    /// tables sharing that descriptor.
+    ///
+    /// \sa get_descriptor()
+    /// \sa Descriptor::is_root()
+    bool has_shared_type() const noexcept;
+
+
+    template<class T>
+    Columns<T> column(size_t column); // FIXME: Should this one have been declared noexcept?
+    template<class T>
+    Columns<T> column(const Table& origin, size_t origin_column_ndx);
+
+    template<class T>
+    SubQuery<T> column(size_t column, Query subquery);
+    template<class T>
+    SubQuery<T> column(const Table& origin, size_t origin_column_ndx, Query subquery);
+
+    // Table size and deletion
+    bool is_empty() const noexcept;
+    size_t size() const noexcept;
+
+    typedef BasicRowExpr<Table> RowExpr;
+    typedef BasicRowExpr<const Table> ConstRowExpr;
+
+    RowExpr get(size_t row_ndx) noexcept;
+    ConstRowExpr get(size_t row_ndx) const noexcept;
+
+    RowExpr front() noexcept;
+    ConstRowExpr front() const noexcept;
+
+    RowExpr back() noexcept;
+    ConstRowExpr back() const noexcept;
+
+    RowExpr operator[](size_t row_ndx) noexcept;
+    ConstRowExpr operator[](size_t row_ndx) const noexcept;
+
+
+    //@{
+
+    /// Row handling.
+    ///
+    /// remove() removes the specified row from the table and shifts all rows at
+    /// higher index to fill the vacated slot. This operation assumes that the
+    /// table is ordered, and it is therefore allowed only on tables **without**
+    /// link columns, as link columns are only allowed in unordered tables.
+    ///
+    /// move_last_over() removes the specified row from the table, and if it is
+    /// not the last row in the table, it then moves the last row into the
+    /// vacated slot. This operation assumes that the table is unordered, and it
+    /// may therfore be used on tables with link columns.
+    ///
+    /// The removal of a row from an unordered table (move_last_over()) may
+    /// cause other linked rows to be cascade-removed. The clearing of a table
+    /// may also cause linked rows to be cascade-removed, but in this respect,
+    /// the effect is exactly as if each row had been removed individually. See
+    /// Descriptor::set_link_type() for details.
+
+    size_t add_empty_row(size_t num_rows = 1);
+    void insert_empty_row(size_t row_ndx, size_t num_rows = 1);
+    void remove(size_t row_ndx);
+    void remove_last();
+    void move_last_over(size_t row_ndx);
+    void clear();
+    void swap_rows(size_t row_ndx_1, size_t row_ndx_2);
+    //@}
+
+    /// Replaces all links to \a row_ndx with links to \a new_row_ndx.
+    ///
+    /// This operation is usually followed by Table::move_last_over()
+    /// as part of Table::set_int_unique() or Table::set_string_unique()
+    /// detecting a collision.
+    ///
+    /// \sa Table::move_last_over()
+    /// \sa Table::set_int_unique()
+    /// \sa Table::set_string_unique()
+    void change_link_targets(size_t row_ndx, size_t new_row_ndx);
+
+    // Get cell values. Will assert if the requested type does not match the column type
+    int64_t     get_int(size_t column_ndx, size_t row_ndx) const noexcept;
+    bool        get_bool(size_t column_ndx, size_t row_ndx) const noexcept;
+    OldDateTime get_olddatetime(size_t column_ndx, size_t row_ndx) const noexcept;
+    float       get_float(size_t column_ndx, size_t row_ndx) const noexcept;
+    double      get_double(size_t column_ndx, size_t row_ndx) const noexcept;
+    StringData  get_string(size_t column_ndx, size_t row_ndx) const noexcept;
+    BinaryData  get_binary(size_t column_ndx, size_t row_ndx) const noexcept;
+    Mixed       get_mixed(size_t column_ndx, size_t row_ndx) const noexcept;
+    DataType    get_mixed_type(size_t column_ndx, size_t row_ndx) const noexcept;
+    Timestamp   get_timestamp(size_t column_ndx, size_t row_ndx) const noexcept;
+
+    template<class T> T get(size_t c, size_t r) const noexcept;
+
+    size_t get_link(size_t column_ndx, size_t row_ndx) const noexcept;
+    bool is_null_link(size_t column_ndx, size_t row_ndx) const noexcept;
+    LinkViewRef get_linklist(size_t column_ndx, size_t row_ndx);
+    ConstLinkViewRef get_linklist(size_t column_ndx, size_t row_ndx) const;
+    size_t get_link_count(size_t column_ndx, size_t row_ndx) const noexcept;
+    bool linklist_is_empty(size_t column_ndx, size_t row_ndx) const noexcept;
+    bool is_null(size_t column_ndx, size_t row_ndx) const noexcept;
+
+    TableRef get_link_target(size_t column_ndx) noexcept;
+    ConstTableRef get_link_target(size_t column_ndx) const noexcept;
+
+    template<class T>
+    typename T::RowAccessor get_link_accessor(size_t column_ndx, size_t row_ndx);
+
+    //@{
+
+    /// Set cell values.
+    ///
+    /// It is an error to specify a column index, row index, or string position
+    /// that is out of range.
+    ///
+    /// The number of bytes in a string value must not exceed `max_string_size`,
+    /// and the number of bytes in a binary data value must not exceed
+    /// `max_binary_size`. String must also contain valid UTF-8 encodings. These
+    /// requirements also apply when modifying a string with insert_substring()
+    /// and remove_substring(), and for strings in a mixed columnt. Passing, or
+    /// producing an oversized string or binary data value will cause an
+    /// exception to be thrown.
+    ///
+    /// The "unique" variants (set_int_unique(), set_string_unique()) are
+    /// intended to be used in the implementation of primary key support. They
+    /// check if the given column already contains one or more values that are
+    /// equal to \a value, and if there are conflicts, it calls
+    /// Table::change_link_targets() for the conflicting row to be replaced by
+    /// \a row_ndx, followed by a Table::move_last_over() of the offending row.
+    /// Users intending to implement primary keys must therefore manually check
+    /// for duplicates if they want to raise an error instead.
+    ///
+    /// insert_substring() inserts the specified string into the currently
+    /// stored string at the specified position. The position must be less than
+    /// or equal to the size of the currently stored string.
+    ///
+    /// remove_substring() removes the specified byte range from the currently
+    /// stored string. The beginning of the range (\a pos) must be less than or
+    /// equal to the size of the currently stored string. If the specified range
+    /// extends beyond the end of the currently stored string, it will be
+    /// silently clamped.
+    ///
+    /// String level modifications performed via insert_substring() and
+    /// remove_substring() are mergable and subject to operational
+    /// trsnaformation. That is, the effect of two causally unrelated
+    /// modifications will in general both be retained during synchronization.
+
+    static const size_t max_string_size = 0xFFFFF8 - Array::header_size - 1;
+    static const size_t max_binary_size = 0xFFFFF8 - Array::header_size;
+
+    void set_int(size_t column_ndx, size_t row_ndx, int_fast64_t value);
+    void set_int_unique(size_t column_ndx, size_t row_ndx, int_fast64_t value);
+    void set_bool(size_t column_ndx, size_t row_ndx, bool value);
+    void set_olddatetime(size_t column_ndx, size_t row_ndx, OldDateTime value);
+    void set_timestamp(size_t column_ndx, size_t row_ndx, Timestamp value);
+    template<class E>
+    void set_enum(size_t column_ndx, size_t row_ndx, E value);
+    void set_float(size_t column_ndx, size_t row_ndx, float value);
+    void set_double(size_t column_ndx, size_t row_ndx, double value);
+    void set_string(size_t column_ndx, size_t row_ndx, StringData value);
+    void set_string_unique(size_t column_ndx, size_t row_ndx, StringData value);
+    void set_binary(size_t column_ndx, size_t row_ndx, BinaryData value);
+    void set_mixed(size_t column_ndx, size_t row_ndx, Mixed value);
+    void set_link(size_t column_ndx, size_t row_ndx, size_t target_row_ndx);
+    void nullify_link(size_t column_ndx, size_t row_ndx);
+    void set_null(size_t column_ndx, size_t row_ndx);
+
+    void insert_substring(size_t col_ndx, size_t row_ndx, size_t pos, StringData);
+    void remove_substring(size_t col_ndx, size_t row_ndx, size_t pos, size_t substring_size = realm::npos);
+
+    //@}
+
+    /// Assumes that the specified column is a subtable column (in
+    /// particular, not a mixed column) and that the specified table
+    /// has a spec that is compatible with that column, that is, the
+    /// number of columns must be the same, and corresponding columns
+    /// must have identical data types (as returned by
+    /// get_column_type()).
+    void set_subtable(size_t col_ndx, size_t row_ndx, const Table*);
+    void set_mixed_subtable(size_t col_ndx, size_t row_ndx, const Table*);
+
+
+    // Sub-tables (works on columns whose type is either 'subtable' or
+    // 'mixed', for a value in a mixed column that is not a subtable,
+    // get_subtable() returns null, get_subtable_size() returns zero,
+    // and clear_subtable() replaces the value with an empty table.)
+    TableRef get_subtable(size_t column_ndx, size_t row_ndx);
+    ConstTableRef get_subtable(size_t column_ndx, size_t row_ndx) const;
+    size_t get_subtable_size(size_t column_ndx, size_t row_ndx) const noexcept;
+    void clear_subtable(size_t column_ndx, size_t row_ndx);
+
+    // Backlinks
+    size_t get_backlink_count(size_t row_ndx, const Table& origin,
+                              size_t origin_col_ndx) const noexcept;
+    size_t get_backlink(size_t row_ndx, const Table& origin,
+                        size_t origin_col_ndx, size_t backlink_ndx) const noexcept;
+
+
+    //@{
+
+    /// If this accessor is attached to a subtable, then that subtable has a
+    /// parent table, and the subtable either resides in a column of type
+    /// `table` or of type `mixed` in that parent. In that case
+    /// get_parent_table() returns a reference to the accessor associated with
+    /// the parent, and get_parent_row_index() returns the index of the row in
+    /// which the subtable resides. In all other cases (free-standing and
+    /// group-level tables), get_parent_table() returns null and
+    /// get_parent_row_index() returns realm::npos.
+    ///
+    /// If this accessor is attached to a subtable, and \a column_ndx_out is
+    /// specified, then `*column_ndx_out` is set to the index of the column of
+    /// the parent table in which the subtable resides. If this accessor is not
+    /// attached to a subtable, then `*column_ndx_out` will retain its original
+    /// value upon return.
+
+    TableRef get_parent_table(size_t* column_ndx_out = nullptr) noexcept;
+    ConstTableRef get_parent_table(size_t* column_ndx_out = nullptr) const noexcept;
+    size_t get_parent_row_index() const noexcept;
+
+    //@}
+
+
+    /// Only group-level unordered tables can be used as origins or targets of
+    /// links.
+    bool is_group_level() const noexcept;
+
+    /// If this table is a group-level table, then this function returns the
+    /// index of this table within the group. Otherwise it returns realm::npos.
+    size_t get_index_in_group() const noexcept;
+
+    // Aggregate functions
+    size_t count_int(size_t column_ndx, int64_t value) const;
+    size_t count_string(size_t column_ndx, StringData value) const;
+    size_t count_float(size_t column_ndx, float value) const;
+    size_t count_double(size_t column_ndx, double value) const;
+
+    int64_t sum_int(size_t column_ndx) const;
+    double  sum_float(size_t column_ndx) const;
+    double  sum_double(size_t column_ndx) const;
+    int64_t maximum_int(size_t column_ndx, size_t* return_ndx = nullptr) const;
+    float   maximum_float(size_t column_ndx, size_t* return_ndx = nullptr) const;
+    double  maximum_double(size_t column_ndx, size_t* return_ndx = nullptr) const;
+    OldDateTime maximum_olddatetime(size_t column_ndx, size_t* return_ndx = nullptr) const;
+    Timestamp maximum_timestamp(size_t column_ndx, size_t* return_ndx = nullptr) const;
+    int64_t minimum_int(size_t column_ndx, size_t* return_ndx = nullptr) const;
+    float   minimum_float(size_t column_ndx, size_t* return_ndx = nullptr) const;
+    double  minimum_double(size_t column_ndx, size_t* return_ndx = nullptr) const;
+    OldDateTime minimum_olddatetime(size_t column_ndx, size_t* return_ndx = nullptr) const;
+    Timestamp minimum_timestamp(size_t column_ndx, size_t* return_ndx = nullptr) const;
+    double  average_int(size_t column_ndx, size_t* value_count = nullptr) const;
+    double  average_float(size_t column_ndx, size_t* value_count = nullptr) const;
+    double  average_double(size_t column_ndx, size_t* value_count = nullptr) const;
+
+    // Searching
+    size_t    find_first_link(size_t target_row_index) const;
+    size_t    find_first_int(size_t column_ndx, int64_t value) const;
+    size_t    find_first_bool(size_t column_ndx, bool value) const;
+    size_t    find_first_olddatetime(size_t column_ndx, OldDateTime value) const;
+    size_t    find_first_timestamp(size_t column_ndx, Timestamp value) const;
+    size_t    find_first_float(size_t column_ndx, float value) const;
+    size_t    find_first_double(size_t column_ndx, double value) const;
+    size_t    find_first_string(size_t column_ndx, StringData value) const;
+    size_t    find_first_binary(size_t column_ndx, BinaryData value) const;
+    size_t    find_first_null(size_t column_ndx) const;
+
+    TableView      find_all_link(size_t target_row_index);
+    ConstTableView find_all_link(size_t target_row_index) const;
+    TableView      find_all_int(size_t column_ndx, int64_t value);
+    ConstTableView find_all_int(size_t column_ndx, int64_t value) const;
+    TableView      find_all_bool(size_t column_ndx, bool value);
+    ConstTableView find_all_bool(size_t column_ndx, bool value) const;
+    TableView      find_all_olddatetime(size_t column_ndx, OldDateTime value);
+    ConstTableView find_all_olddatetime(size_t column_ndx, OldDateTime value) const;
+    TableView      find_all_float(size_t column_ndx, float value);
+    ConstTableView find_all_float(size_t column_ndx, float value) const;
+    TableView      find_all_double(size_t column_ndx, double value);
+    ConstTableView find_all_double(size_t column_ndx, double value) const;
+    TableView      find_all_string(size_t column_ndx, StringData value);
+    ConstTableView find_all_string(size_t column_ndx, StringData value) const;
+    TableView      find_all_binary(size_t column_ndx, BinaryData value);
+    ConstTableView find_all_binary(size_t column_ndx, BinaryData value) const;
+    TableView      find_all_null(size_t column_ndx);
+    ConstTableView find_all_null(size_t column_ndx) const;
+
+    /// The following column types are supported: String, Integer, OldDateTime, Bool
+    TableView      get_distinct_view(size_t column_ndx);
+    ConstTableView get_distinct_view(size_t column_ndx) const;
+
+    TableView      get_sorted_view(size_t column_ndx, bool ascending = true);
+    ConstTableView get_sorted_view(size_t column_ndx, bool ascending = true) const;
+
+    TableView      get_sorted_view(std::vector<size_t> column_ndx, std::vector<bool> ascending);
+    ConstTableView get_sorted_view(std::vector<size_t> column_ndx, std::vector<bool> ascending) const;
+
+    TableView      get_range_view(size_t begin, size_t end);
+    ConstTableView get_range_view(size_t begin, size_t end) const;
+
+    TableView      get_backlink_view(size_t row_ndx, Table *src_table,
+                                     size_t src_col_ndx);
+
+
+    // Pivot / aggregate operation types. Experimental! Please do not document method publicly.
+    enum AggrType {
+        aggr_count,
+        aggr_sum,
+        aggr_avg,
+        aggr_min,
+        aggr_max
+    };
+
+    // Simple pivot aggregate method. Experimental! Please do not document method publicly.
+    void aggregate(size_t group_by_column, size_t aggr_column, AggrType op, Table& result, const IntegerColumn* viewrefs = nullptr) const;
+
+    /// Report the current versioning counter for the table. The versioning counter is guaranteed to
+    /// change when the contents of the table changes after advance_read() or promote_to_write(), or
+    /// immediately after calls to methods which change the table. The term "change" means "change of
+    /// value": The storage layout of the table may change, for example due to optimization, but this
+    /// is not considered a change of a value. This means that you *cannot* use a non-changing version
+    /// count to indicate that object addresses (e.g. strings, binary data) remain the same.
+    /// The versioning counter *may* change (but is not required to do so) when another table linked
+    /// from this table, or linking to this table, is changed. The version counter *may* also change
+    /// without any apparent reason.
+    uint_fast64_t get_version_counter() const noexcept;
+private:
+    template<class T>
+    size_t find_first(size_t column_ndx, T value) const; // called by above methods
+    template<class T>
+    TableView find_all(size_t column_ndx, T value);
+public:
+
+
+    //@{
+    /// Find the lower/upper bound according to a column that is
+    /// already sorted in ascending order.
+    ///
+    /// For an integer column at index 0, and an integer value '`v`',
+    /// lower_bound_int(0,v) returns the index '`l`' of the first row
+    /// such that `get_int(0,l) &ge; v`, and upper_bound_int(0,v)
+    /// returns the index '`u`' of the first row such that
+    /// `get_int(0,u) &gt; v`. In both cases, if no such row is found,
+    /// the returned value is the number of rows in the table.
+    ///
+    ///     3 3 3 4 4 4 5 6 7 9 9 9
+    ///     ^     ^     ^     ^     ^
+    ///     |     |     |     |     |
+    ///     |     |     |     |      -- Lower and upper bound of 15
+    ///     |     |     |     |
+    ///     |     |     |      -- Lower and upper bound of 8
+    ///     |     |     |
+    ///     |     |      -- Upper bound of 4
+    ///     |     |
+    ///     |      -- Lower bound of 4
+    ///     |
+    ///      -- Lower and upper bound of 1
+    ///
+    /// These functions are similar to std::lower_bound() and
+    /// std::upper_bound().
+    ///
+    /// The string versions assume that the column is sorted according
+    /// to StringData::operator<().
+    size_t lower_bound_int(size_t column_ndx, int64_t value) const noexcept;
+    size_t upper_bound_int(size_t column_ndx, int64_t value) const noexcept;
+    size_t lower_bound_bool(size_t column_ndx, bool value) const noexcept;
+    size_t upper_bound_bool(size_t column_ndx, bool value) const noexcept;
+    size_t lower_bound_float(size_t column_ndx, float value) const noexcept;
+    size_t upper_bound_float(size_t column_ndx, float value) const noexcept;
+    size_t lower_bound_double(size_t column_ndx, double value) const noexcept;
+    size_t upper_bound_double(size_t column_ndx, double value) const noexcept;
+    size_t lower_bound_string(size_t column_ndx, StringData value) const noexcept;
+    size_t upper_bound_string(size_t column_ndx, StringData value) const noexcept;
+    //@}
+
+    // Queries
+    // Using where(tv) is the new method to perform queries on TableView. The 'tv' can have any order; it does not
+    // need to be sorted, and, resulting view retains its order.
+    Query where(TableViewBase* tv = nullptr) { return Query(*this, tv); }
+
+    // FIXME: We need a ConstQuery class or runtime check against modifications in read transaction.
+    Query where(TableViewBase* tv = nullptr) const { return Query(*this, tv); }
+
+    // Perform queries on a LinkView. The returned Query holds a reference to lv.
+    Query where(const LinkViewRef& lv) { return Query(*this, lv); }
+
+    Table& link(size_t link_column);
+    Table& backlink(const Table& origin, size_t origin_col_ndx);
+
+    // Optimizing. enforce == true will enforce enumeration of all string columns;
+    // enforce == false will auto-evaluate if they should be enumerated or not
+    void optimize(bool enforce = false);
+
+    /// Write this table (or a slice of this table) to the specified
+    /// output stream.
+    ///
+    /// The output will have the same format as any other Realm
+    /// database file, such as those produced by Group::write(). In
+    /// this case, however, the resulting database file will contain
+    /// exactly one table, and that table will contain only the
+    /// specified slice of the source table (this table).
+    ///
+    /// The new table will always have the same dynamic type (see
+    /// Descriptor) as the source table (this table), and unless it is
+    /// overridden (\a override_table_name), the new table will have
+    /// the same name as the source table (see get_name()). Indexes
+    /// (see add_search_index()) will not be carried over to the new
+    /// table.
+    ///
+    /// \param offset Index of first row to include (if `slice_size >
+    /// 0`). Must be less than, or equal to size().
+    ///
+    /// \param slice_size Number of rows to include. May be zero. If 
+    /// `slice_size > size() - offset`, then the effective size of 
+    /// the written slice will be `size() - offset`.
+    ///
+    /// \throw std::out_of_range If `offset > size()`.
+    ///
+    /// FIXME: While this function does provided a maximally efficient
+    /// way of serializing part of a table, it offers little in terms
+    /// of general utility. This is unfortunate, because it pulls
+    /// quite a large amount of code into the core library to support
+    /// it.
+    void write(std::ostream&, size_t offset = 0, size_t slice_size = npos,
+               StringData override_table_name = StringData()) const;
+
+    // Conversion
+    void to_json(std::ostream& out, size_t link_depth = 0, std::map<std::string,
+                 std::string>* renames = nullptr) const;
+    void to_string(std::ostream& out, size_t limit = 500) const;
+    void row_to_string(size_t row_ndx, std::ostream& out) const;
+
+    // Get a reference to this table
+    TableRef get_table_ref() { return TableRef(this); }
+    ConstTableRef get_table_ref() const { return ConstTableRef(this); }
+
+    /// \brief Compare two tables for equality.
+    ///
+    /// Two tables are equal if they have equal descriptors
+    /// (`Descriptor::operator==()`) and equal contents. Equal descriptors imply
+    /// that the two tables have the same columns in the same order. Equal
+    /// contents means that the two tables must have the same number of rows,
+    /// and that for each row index, the two rows must have the same values in
+    /// each column.
+    ///
+    /// In mixed columns, both the value types and the values are required to be
+    /// equal.
+    ///
+    /// For a particular row and column, if the two values are themselves tables
+    /// (subtable and mixed columns) value equality implies a recursive
+    /// invocation of `Table::operator==()`.
+    bool operator==(const Table&) const;
+
+    /// \brief Compare two tables for inequality.
+    ///
+    /// See operator==().
+    bool operator!=(const Table& t) const;
+
+    /// A subtable in a column of type 'table' (which shares descriptor with
+    /// other subtables in the same column) is initially in a degenerate state
+    /// where it takes up a minimal amout of space. This function returns true
+    /// if, and only if the table accessor is attached to such a subtable. This
+    /// function is mainly intended for debugging purposes.
+    bool is_degenerate() const noexcept;
+
+    // Debug
+#ifdef REALM_DEBUG
+    void verify() const;
+    void to_dot(std::ostream&, StringData title = StringData()) const;
+    void print() const;
+    MemStats stats() const;
+    void dump_node_structure() const; // To std::cerr (for GDB)
+    void dump_node_structure(std::ostream&, int level) const;
+#else
+    void verify() const {}
+#endif
+
+    class Parent;
+    using HandoverPatch = TableHandoverPatch;
+    static void generate_patch(const TableRef& ref, std::unique_ptr<HandoverPatch>& patch);
+    static TableRef create_from_and_consume_patch(std::unique_ptr<HandoverPatch>& patch, Group& group);
+
+protected:
+    /// Get a pointer to the accessor of the specified subtable. The
+    /// accessor will be created if it does not already exist.
+    ///
+    /// The returned table pointer must **always** end up being
+    /// wrapped in some instantiation of BasicTableRef<>.
+    Table* get_subtable_ptr(size_t col_ndx, size_t row_ndx);
+
+    /// See non-const get_subtable_ptr().
+    const Table* get_subtable_ptr(size_t col_ndx, size_t row_ndx) const;
+
+    /// Compare the rows of two tables under the assumption that the two tables
+    /// have the same number of columns, and the same data type at each column
+    /// index (as expressed through the DataType enum).
+    bool compare_rows(const Table&) const;
+
+    void set_into_mixed(Table* parent, size_t col_ndx, size_t row_ndx) const;
+
+private:
+    class SliceWriter;
+
+    // Number of rows in this table
+    size_t m_size;
+
+    // Underlying array structure. `m_top` is in use only for root tables; that
+    // is, for tables with independent descriptor. `m_columns` contains a ref
+    // for each column and search index in order of the columns. A search index
+    // ref always occurs immediately after the ref of the column to which the
+    // search index belongs.
+    //
+    // A subtable column (a column of type `type_table`) is essentially just a
+    // column of 'refs' pointing to the root node of each subtable.
+    //
+    // To save space in the database file, a subtable in such a column always
+    // starts out in a degenerate form where nothing is allocated on its behalf,
+    // and a null 'ref' is stored in the corresponding slot of the column. A
+    // subtable remains in this degenerate state until the first row is added to
+    // the subtable.
+    //
+    // For this scheme to work, it must be (and is) possible to create a table
+    // accessor that refers to a degenerate subtable. A table accessor (instance
+    // of `Table`) refers to a degenerate subtable if, and only if `m_columns`
+    // is unattached.
+    //
+    // FIXME: The fact that `m_columns` may be detached means that many
+    // functions (even non-modifying functions) need to check for that before
+    // accessing the contents of the table. This incurs a runtime
+    // overhead. Consider whether this overhead can be eliminated by having
+    // `Table::m_columns` always attached to something, and then detect the
+    // degenerate state in a different way.
+    Array m_top;
+    Array m_columns; // 2nd slot in m_top (for root tables)
+    Spec m_spec;     // 1st slot in m_top (for root tables)
+
+    // Is guaranteed to be empty for a detached accessor. Otherwise it is empty
+    // when the table accessor is attached to a degenerate subtable (unattached
+    // `m_columns`), otherwise it contains precisely one column accessor for
+    // each column in the table, in order.
+    //
+    // In some cases an entry may be null. This is currently possible only in
+    // connection with Group::advance_transact(), but it means that several
+    // member functions must be prepared to handle these null entries; in
+    // particular, detach(), ~Table(), functions called on behalf of detach()
+    // and ~Table(), and functiones called on behalf of
+    // Group::advance_transact().
+    typedef std::vector<ColumnBase*> column_accessors;
+    column_accessors m_cols;
+
+    mutable std::atomic<size_t> m_ref_count;
+
+    // If this table is a root table (has independent descriptor),
+    // then Table::m_descriptor refers to the accessor of its
+    // descriptor when, and only when the descriptor accessor
+    // exists. This is used to ensure that at most one descriptor
+    // accessor exists for each underlying descriptor at any given
+    // point in time. Subdescriptors are kept unique by means of a
+    // registry in the parent descriptor. Table::m_descriptor is
+    // always null for tables with shared descriptor.
+    mutable Descriptor* m_descriptor;
+
+    // Table view instances
+    // Access needs to be protected by m_accessor_mutex
+    typedef std::vector<TableViewBase*> views;
+    mutable views m_views;
+
+    // Points to first bound row accessor, or is null if there are none.
+    mutable RowBase* m_row_accessors = nullptr;
+
+    // Mutex which must be locked any time the row accessor chain or m_views is used
+    mutable util::Mutex m_accessor_mutex;
+
+    // Used for queries: Items are added with link() method during buildup of query
+    mutable std::vector<size_t> m_link_chain;
+
+    /// Used only in connection with Group::advance_transact() and
+    /// Table::refresh_accessor_tree().
+    mutable bool m_mark;
+
+    mutable uint_fast64_t m_version;
+
+    void erase_row(size_t row_ndx, bool is_move_last_over);
+    void batch_erase_rows(const IntegerColumn& row_indexes, bool is_move_last_over);
+    void do_remove(size_t row_ndx, bool broken_reciprocal_backlinks);
+    void do_move_last_over(size_t row_ndx, bool broken_reciprocal_backlinks);
+    void do_swap_rows(size_t row_ndx_1, size_t row_ndx_2);
+    void do_change_link_targets(size_t row_ndx, size_t new_row_ndx);
+    void do_clear(bool broken_reciprocal_backlinks);
+    size_t do_set_link(size_t col_ndx, size_t row_ndx, size_t target_row_ndx);
+    template<class ColType, class T>
+    size_t do_set_unique(ColType& column, size_t row_ndx, T&& value);
+
+    void upgrade_file_format();
+    
+    // Upgrades OldDateTime columns to Timestamp columns
+    void upgrade_olddatetime();
+
+    /// Update the version of this table and all tables which have links to it.
+    /// This causes all views referring to those tables to go out of sync, so that
+    /// calls to sync_if_needed() will bring the view up to date by reexecuting the
+    /// query.
+    ///
+    /// \param bump_global chooses whether the global versioning counter must be
+    /// bumped first as part of the update. This is the normal mode of operation,
+    /// when a change is made to the table. When calling recursively (following links
+    /// or going to the parent table), the parameter should be set to false to correctly
+    /// prune traversal.
+    void bump_version(bool bump_global = true) const noexcept;
+
+    /// Disable copying assignment.
+    ///
+    /// It could easily be implemented by calling assign(), but the
+    /// non-checking nature of the low-level dynamically typed API
+    /// makes it too risky to offer this feature as an
+    /// operator.
+    ///
+    /// FIXME: assign() has not yet been implemented, but the
+    /// intention is that it will copy the rows of the argument table
+    /// into this table after clearing the original contents, and for
+    /// target tables without a shared spec, it would also copy the
+    /// spec. For target tables with shared spec, it would be an error
+    /// to pass an argument table with an incompatible spec, but
+    /// assign() would not check for spec compatibility. This would
+    /// make it ideal as a basis for implementing operator=() for
+    /// typed tables.
+    Table& operator=(const Table&);
+
+    /// Used when constructing an accessor whose lifetime is going to be managed
+    /// by reference counting. The lifetime of accessors of free-standing tables
+    /// allocated on the stack by the application is not managed by reference
+    /// counting, so that is a case where this tag must **not** be specified.
+    class ref_count_tag {};
+
+    /// Create an uninitialized accessor whose lifetime is managed by reference
+    /// counting.
+    Table(ref_count_tag, Allocator&);
+
+    void init(ref_type top_ref, ArrayParent*, size_t ndx_in_parent,
+              bool skip_create_column_accessors = false);
+    void init(ConstSubspecRef shared_spec, ArrayParent* parent_column,
+              size_t parent_row_ndx);
+
+    static void do_insert_column(Descriptor&, size_t col_ndx, DataType type,
+                                 StringData name, LinkTargetInfo& link_target_info, bool nullable = false);
+    static void do_insert_column_unless_exists(Descriptor&, size_t col_ndx, DataType type,
+                                               StringData name, LinkTargetInfo& link, bool nullable = false,
+                                               bool* was_inserted = nullptr);
+    static void do_erase_column(Descriptor&, size_t col_ndx);
+    static void do_rename_column(Descriptor&, size_t col_ndx, StringData name);
+    static void do_move_column(Descriptor&, size_t col_ndx_1, size_t col_ndx_2);
+
+    struct InsertSubtableColumns;
+    struct EraseSubtableColumns;
+    struct RenameSubtableColumns;
+    struct MoveSubtableColumns;
+
+    void insert_root_column(size_t col_ndx, DataType type, StringData name,
+                            LinkTargetInfo& link_target, bool nullable = false);
+    void erase_root_column(size_t col_ndx);
+    void move_root_column(size_t from, size_t to);
+    void do_insert_root_column(size_t col_ndx, ColumnType, StringData name, bool nullable = false);
+    void do_erase_root_column(size_t col_ndx);
+    void do_move_root_column(size_t from, size_t to);
+    void do_set_link_type(size_t col_ndx, LinkType);
+    void insert_backlink_column(size_t origin_table_ndx, size_t origin_col_ndx, size_t backlink_col_ndx);
+    void erase_backlink_column(size_t origin_table_ndx, size_t origin_col_ndx);
+    void update_link_target_tables(size_t old_col_ndx_begin, size_t new_col_ndx_begin);
+    void update_link_target_tables_after_column_move(size_t moved_from, size_t moved_to);
+
+    struct SubtableUpdater {
+        virtual void update(const SubtableColumn&, Array& subcolumns) = 0;
+        virtual void update_accessor(Table&) = 0;
+        virtual ~SubtableUpdater() {}
+    };
+    static void update_subtables(Descriptor&, SubtableUpdater*);
+    void update_subtables(const size_t* col_path_begin, const size_t* col_path_end,
+                          SubtableUpdater*);
+
+    struct AccessorUpdater {
+        virtual void update(Table&) = 0;
+        virtual void update_parent(Table&) = 0;
+        virtual ~AccessorUpdater() {}
+    };
+    void update_accessors(const size_t* col_path_begin, const size_t* col_path_end,
+                          AccessorUpdater&);
+
+    void create_degen_subtab_columns();
+    ColumnBase* create_column_accessor(ColumnType, size_t col_ndx, size_t ndx_in_parent);
+    void destroy_column_accessors() noexcept;
+
+    /// Called in the context of Group::commit() to ensure that
+    /// attached table accessors stay valid across a commit. Please
+    /// note that this works only for non-transactional commits. Table
+    /// accessors obtained during a transaction are always detached
+    /// when the transaction ends.
+    void update_from_parent(size_t old_baseline) noexcept;
+
+    // Support function for conversions
+    void to_string_header(std::ostream& out, std::vector<size_t>& widths) const;
+    void to_string_row(size_t row_ndx, std::ostream& out,
+                       const std::vector<size_t>& widths) const;
+
+    // recursive methods called by to_json, to follow links
+    void to_json(std::ostream& out, size_t link_depth, std::map<std::string, std::string>& renames,
+                 std::vector<ref_type>& followed) const;
+    void to_json_row(size_t row_ndx, std::ostream& out, size_t link_depth,
+                     std::map<std::string, std::string>& renames, std::vector<ref_type>& followed) const;
+    void to_json_row(size_t row_ndx, std::ostream& out, size_t link_depth = 0,
+                     std::map<std::string, std::string>* renames = nullptr) const;
+
+    // Detach accessor from underlying table. Caller must ensure that
+    // a reference count exists upon return, for example by obtaining
+    // an extra reference count before the call.
+    //
+    // This function puts this table accessor into the detached
+    // state. This detaches it from the underlying structure of array
+    // nodes. It also recursively detaches accessors for subtables,
+    // and the type descriptor accessor. When this function returns,
+    // is_attached() will return false.
+    //
+    // This function may be called for a table accessor that is
+    // already in the detached state (idempotency).
+    //
+    // It is also valid to call this function for a table accessor
+    // that has not yet been detached, but whose underlying structure
+    // of arrays have changed in an unpredictable/unknown way. This
+    // kind of change generally happens when a modifying table
+    // operation fails, and also when one transaction is ended and a
+    // new one is started.
+    void detach() noexcept;
+
+    /// Detach and remove all attached row, link list, and subtable
+    /// accessors. This function does not discard the descriptor accessor, if
+    /// any, and it does not discard column accessors either.
+    void discard_child_accessors() noexcept;
+
+    void discard_row_accessors() noexcept;
+
+    // Detach the type descriptor accessor if it exists.
+    void discard_desc_accessor() noexcept;
+
+    void bind_ptr() const noexcept;
+    void unbind_ptr() const noexcept;
+
+    void register_view(const TableViewBase* view);
+    void unregister_view(const TableViewBase* view) noexcept;
+    void move_registered_view(const TableViewBase* old_addr,
+                              const TableViewBase* new_addr) noexcept;
+    void discard_views() noexcept;
+
+    void register_row_accessor(RowBase*) const noexcept;
+    void unregister_row_accessor(RowBase*) const noexcept;
+    void do_unregister_row_accessor(RowBase*) const noexcept;
+
+    class UnbindGuard;
+
+    ColumnType get_real_column_type(size_t column_ndx) const noexcept;
+
+    /// If this table is a group-level table, the parent group is returned,
+    /// otherwise null is returned.
+    Group* get_parent_group() const noexcept;
+
+    const ColumnBase& get_column_base(size_t column_ndx) const noexcept;
+    ColumnBase& get_column_base(size_t column_ndx);
+
+    template<class T, ColumnType col_type>
+    T& get_column(size_t ndx);
+
+    template<class T, ColumnType col_type>
+    const T& get_column(size_t ndx) const noexcept;
+
+    IntegerColumn& get_column(size_t column_ndx);
+    const IntegerColumn& get_column(size_t column_ndx) const noexcept;
+    IntNullColumn& get_column_int_null(size_t column_ndx);
+    const IntNullColumn& get_column_int_null(size_t column_ndx) const noexcept;
+    FloatColumn& get_column_float(size_t column_ndx);
+    const FloatColumn& get_column_float(size_t column_ndx) const noexcept;
+    DoubleColumn& get_column_double(size_t column_ndx);
+    const DoubleColumn& get_column_double(size_t column_ndx) const noexcept;
+    StringColumn& get_column_string(size_t column_ndx);
+    const StringColumn& get_column_string(size_t column_ndx) const noexcept;
+    BinaryColumn& get_column_binary(size_t column_ndx);
+    const BinaryColumn& get_column_binary(size_t column_ndx) const noexcept;
+    StringEnumColumn& get_column_string_enum(size_t column_ndx);
+    const StringEnumColumn& get_column_string_enum(size_t column_ndx) const noexcept;
+    SubtableColumn& get_column_table(size_t column_ndx);
+    const SubtableColumn& get_column_table(size_t column_ndx) const noexcept;
+    MixedColumn& get_column_mixed(size_t column_ndx);
+    const MixedColumn& get_column_mixed(size_t column_ndx) const noexcept;
+    TimestampColumn& get_column_timestamp(size_t column_ndx);
+    const TimestampColumn& get_column_timestamp(size_t column_ndx) const noexcept;
+    const LinkColumnBase& get_column_link_base(size_t ndx) const noexcept;
+    LinkColumnBase& get_column_link_base(size_t ndx);
+    const LinkColumn& get_column_link(size_t ndx) const noexcept;
+    LinkColumn& get_column_link(size_t ndx);
+    const LinkListColumn& get_column_link_list(size_t ndx) const noexcept;
+    LinkListColumn& get_column_link_list(size_t ndx);
+    const BacklinkColumn& get_column_backlink(size_t ndx) const noexcept;
+    BacklinkColumn& get_column_backlink(size_t ndx);
+
+    void instantiate_before_change();
+    void validate_column_type(const ColumnBase& col, ColumnType expected_type,
+                              size_t ndx) const;
+
+    static size_t get_size_from_ref(ref_type top_ref, Allocator&) noexcept;
+    static size_t get_size_from_ref(ref_type spec_ref, ref_type columns_ref,
+                                         Allocator&) noexcept;
+
+    const Table* get_parent_table_ptr(size_t* column_ndx_out = nullptr) const noexcept;
+    Table* get_parent_table_ptr(size_t* column_ndx_out = nullptr) noexcept;
+
+    /// Create an empty table with independent spec and return just
+    /// the reference to the underlying memory.
+    static ref_type create_empty_table(Allocator&);
+
+    /// Create a column of the specified type, fill it with the
+    /// specified number of default values, and return just the
+    /// reference to the underlying memory.
+    static ref_type create_column(ColumnType column_type, size_t num_default_values, bool nullable, Allocator&);
+
+    /// Construct a copy of the columns array of this table using the
+    /// specified allocator and return just the ref to that array.
+    ///
+    /// In the clone, no string column will be of the enumeration
+    /// type.
+    ref_type clone_columns(Allocator&) const;
+
+    /// Construct a complete copy of this table (including its spec)
+    /// using the specified allocator and return just the ref to the
+    /// new top array.
+    ref_type clone(Allocator&) const;
+
+    /// True for `col_type_Link` and `col_type_LinkList`.
+    static bool is_link_type(ColumnType) noexcept;
+
+    void connect_opposite_link_columns(size_t link_col_ndx, Table& target_table,
+                                       size_t backlink_col_ndx) noexcept;
+
+    size_t get_num_strong_backlinks(size_t row_ndx) const noexcept;
+
+    //@{
+
+    /// Cascading removal of strong links.
+    ///
+    /// cascade_break_backlinks_to() removes all backlinks pointing to the row
+    /// at \a row_ndx. Additionally, if this causes the number of **strong**
+    /// backlinks originating from a particular opposite row (target row of
+    /// corresponding forward link) to drop to zero, and that row is not already
+    /// in \a state.rows, then that row is added to \a state.rows, and
+    /// cascade_break_backlinks_to() is called recursively for it. This
+    /// operation is the first half of the cascading row removal operation. The
+    /// second half is performed by passing the resulting contents of \a
+    /// state.rows to remove_backlink_broken_rows().
+    ///
+    /// Operations that trigger cascading row removal due to explicit removal of
+    /// one or more rows (the *initiating rows*), should add those rows to \a
+    /// rows initially, and then call cascade_break_backlinks_to() once for each
+    /// of them in turn. This is opposed to carrying out the explicit row
+    /// removals independently, which is also possible, but does require that
+    /// any initiating rows, that end up in \a state.rows due to link cycles,
+    /// are removed before passing \a state.rows to
+    /// remove_backlink_broken_rows(). In the case of clear(), where all rows of
+    /// a table are explicitly removed, it is better to use
+    /// cascade_break_backlinks_to_all_rows(), and then carry out the table
+    /// clearing as an independent step. For operations that trigger cascading
+    /// row removal for other reasons than explicit row removal, \a state.rows
+    /// must be empty initially, but cascade_break_backlinks_to() must still be
+    /// called for each of the initiating rows.
+    ///
+    /// When the last non-recursive invocation of cascade_break_backlinks_to()
+    /// returns, all forward links originating from a row in \a state.rows have
+    /// had their reciprocal backlinks removed, so remove_backlink_broken_rows()
+    /// does not perform reciprocal backlink removal at all. Additionally, all
+    /// remaining backlinks originating from rows in \a state.rows are
+    /// guaranteed to point to rows that are **not** in \a state.rows. This is
+    /// true because any backlink that was pointing to a row in \a state.rows
+    /// has been removed by one of the invocations of
+    /// cascade_break_backlinks_to(). The set of forward links, that correspond
+    /// to these remaining backlinks, is precisely the set of forward links that
+    /// need to be removed/nullified by remove_backlink_broken_rows(), which it
+    /// does by way of reciprocal forward link removal. Note also, that while
+    /// all the rows in \a state.rows can have remaining **weak** backlinks
+    /// originating from them, only the initiating rows in \a state.rows can
+    /// have remaining **strong** backlinks originating from them. This is true
+    /// because a non-initiating row is added to \a state.rows only when the
+    /// last backlink originating from it is lost.
+    ///
+    /// Each row removal is replicated individually (as opposed to one
+    /// replication instruction for the entire cascading operation). This is
+    /// done because it provides an easy way for Group::advance_transact() to
+    /// know which tables are affected by the cascade. Note that this has
+    /// several important consequences: First of all, the replication log
+    /// receiver must execute the row removal instructions in a non-cascading
+    /// fashion, meaning that there will be an asymmetry between the two sides
+    /// in how the effect of the cascade is brought about. While this is fine
+    /// for simple 1-to-1 replication, it may end up interfering badly with
+    /// *transaction merging*, when that feature is introduced. Imagine for
+    /// example that the cascade initiating operation gets canceled during
+    /// conflict resolution, but some, or all of the induced row removals get to
+    /// stay. That would break causal consistency. It is important, however, for
+    /// transaction merging that the cascaded row removals are explicitly
+    /// mentioned in the replication log, such that they can be used to adjust
+    /// row indexes during the *operational transform*.
+    ///
+    /// cascade_break_backlinks_to_all_rows() has the same affect as calling
+    /// cascade_break_backlinks_to() once for each row in the table. When
+    /// calling this function, \a state.stop_on_table must be set to the origin
+    /// table (origin table of corresponding forward links), and \a
+    /// state.stop_on_link_list_column must be null.
+    ///
+    /// It is immaterial which table remove_backlink_broken_rows() is called on,
+    /// as long it that table is in the same group as the removed rows.
+
+    void cascade_break_backlinks_to(size_t row_ndx, CascadeState& state);
+    void cascade_break_backlinks_to_all_rows(CascadeState& state);
+    void remove_backlink_broken_rows(const CascadeState&);
+
+    //@}
+
+    /// Used by query. Follows chain of link columns and returns final target table
+    const Table* get_link_chain_target(const std::vector<size_t>& link_chain) const;
+
+    /// Remove the specified row by the 'move last over' method.
+    void do_move_last_over(size_t row_ndx);
+
+    // Precondition: 1 <= end - begin
+    size_t* record_subtable_path(size_t* begin, size_t* end) const noexcept;
+
+    /// Check if an accessor exists for the specified subtable. If it does,
+    /// return a pointer to it, otherwise return null. This function assumes
+    /// that the specified column index in a valid index into `m_cols` but does
+    /// not otherwise assume more than minimal accessor consistency (see
+    /// AccessorConsistencyLevels.)
+    Table* get_subtable_accessor(size_t col_ndx, size_t row_ndx) noexcept;
+
+    /// Unless the column accessor is missing, this function returns the
+    /// accessor for the target table of the specified link-type column. The
+    /// column accessor is said to be missing if `m_cols[col_ndx]` is null, and
+    /// this can happen only during certain operations such as the updating of
+    /// the accessor tree when a read transaction is advanced. Note that for
+    /// link type columns, the target table accessor exists when, and only when
+    /// the origin table accessor exists. This function assumes that the
+    /// specified column index in a valid index into `m_cols` and that the
+    /// column is a link-type column. Beyond that, it assume nothing more than
+    /// minimal accessor consistency (see AccessorConsistencyLevels.)
+    Table* get_link_target_table_accessor(size_t col_ndx) noexcept;
+
+    void discard_subtable_accessor(size_t col_ndx, size_t row_ndx) noexcept;
+
+    void adj_acc_insert_rows(size_t row_ndx, size_t num_rows) noexcept;
+    void adj_acc_erase_row(size_t row_ndx) noexcept;
+    void adj_acc_swap_rows(size_t row_ndx_1, size_t row_ndx_2) noexcept;
+
+    /// Adjust this table accessor and its subordinates after move_last_over()
+    /// (or its inverse).
+    ///
+    /// First, any row, subtable, or link list accessors registered as being at
+    /// \a to_row_ndx will be detached, as that row is assumed to have been
+    /// replaced. Next, any row, subtable, or link list accessors registered as
+    /// being at \a from_row_ndx, will be reregistered as being at \a
+    /// to_row_ndx, as the row at \a from_row_ndx is assumed to have been moved
+    /// to \a to_row_ndx.
+    ///
+    /// Crucially, if \a to_row_ndx is equal to \a from_row_ndx, then row,
+    /// subtable, or link list accessors at that row are **still detached**.
+    ///
+    /// Additionally, this function causes all link-adjacent tables to be marked
+    /// (dirty). Two tables are link-adjacent if one is the target table of a
+    /// link column of the other table. Note that this marking follows these
+    /// relations in both directions, but only to a depth of one.
+    ///
+    /// When this function is used in connection with move_last_over(), set \a
+    /// to_row_ndx to the index of the row to be removed, and set \a
+    /// from_row_ndx to the index of the last row in the table. As mentioned
+    /// earlier, this function can also be used in connection with the **inverse
+    /// of** move_last_over(), which is an operation that vacates a row by
+    /// moving its contents into a new last row of the table. In that case, set
+    /// \a to_row_ndx to one plus the index of the last row in the table, and
+    /// set \a from_row_ndx to the index of the row to be vacated.
+    ///
+    /// This function is used as part of Table::refresh_accessor_tree() to
+    /// promote the state of the accessors from Minimal Consistency into
+    /// Structural Correspondence, so it must be able to execute without
+    /// accessing the underlying array nodes.
+    void adj_acc_move_over(size_t from_row_ndx, size_t to_row_ndx) noexcept;
+
+    void adj_acc_clear_root_table() noexcept;
+    void adj_acc_clear_nonroot_table() noexcept;
+    void adj_row_acc_insert_rows(size_t row_ndx, size_t num_rows) noexcept;
+    void adj_row_acc_erase_row(size_t row_ndx) noexcept;
+    void adj_row_acc_swap_rows(size_t row_ndx_1, size_t row_ndx_2) noexcept;
+
+    /// Called by adj_acc_move_over() to adjust row accessors.
+    void adj_row_acc_move_over(size_t from_row_ndx, size_t to_row_ndx) noexcept;
+
+    void adj_insert_column(size_t col_ndx);
+    void adj_erase_column(size_t col_ndx) noexcept;
+    void adj_move_column(size_t col_ndx_1, size_t col_ndx_2) noexcept;
+
+    bool is_marked() const noexcept;
+    void mark() noexcept;
+    void unmark() noexcept;
+    void recursive_mark() noexcept;
+    void mark_link_target_tables(size_t col_ndx_begin) noexcept;
+    void mark_opposite_link_tables() noexcept;
+
+    Replication* get_repl() noexcept;
+
+    void set_ndx_in_parent(size_t ndx_in_parent) noexcept;
+
+    /// Refresh the part of the accessor tree that is rooted at this
+    /// table. Subtable accessors will be refreshed only if they are marked
+    /// (Table::m_mark), and this applies recursively to subtables of
+    /// subtables. All refreshed table accessors (including this one) will be
+    /// unmarked upon return.
+    ///
+    /// The following conditions are necessary and sufficient for the proper
+    /// operation of this function:
+    ///
+    ///  - This table must be a group-level table, or a subtable. It must not be
+    ///    a free-standing table (because a free-standing table has no parent).
+    ///
+    ///  - The `index in parent` property is correct. The `index in parent`
+    ///    property of the table is the `index in parent` property of
+    ///    `m_columns` for subtables with shared descriptor, and the `index in
+    ///    parent` property of `m_top` for all other tables.
+    ///
+    ///  - If this table has shared descriptor, then the `index in parent`
+    ///    property of the contained spec accessor is correct.
+    ///
+    ///  - The parent accessor is in a valid state (already refreshed). If the
+    ///    parent is a group, then the group accessor (excluding its table
+    ///    accessors) must be in a valid state. If the parent is a table, then
+    ///    the table accessor (excluding its subtable accessors) must be in a
+    ///    valid state.
+    ///
+    ///  - Every descendant subtable accessor is marked if it needs to be
+    ///    refreshed, or if it has a descendant accessor that needs to be
+    ///    refreshed.
+    ///
+    ///  - This table accessor, as well as all its descendant accessors, are in
+    ///    structural correspondence with the underlying node hierarchy whose
+    ///    root ref is stored in the parent (see AccessorConsistencyLevels).
+    void refresh_accessor_tree();
+
+    void refresh_column_accessors(size_t col_ndx_begin = 0);
+
+    // Look for link columns starting from col_ndx_begin.
+    // If a link column is found, follow the link and update it's
+    // backlink column accessor if it is in different table.
+    void refresh_link_target_accessors(size_t col_ndx_begin = 0);
+
+    bool is_cross_table_link_target() const noexcept;
+
+#ifdef REALM_DEBUG
+    void to_dot_internal(std::ostream&) const;
+#endif
+
+    friend class SubtableNode;
+    friend class _impl::TableFriend;
+    friend class Query;
+    template<class>
+    friend class util::bind_ptr;
+    template<class>
+    friend class SimpleQuerySupport;
+    friend class LangBindHelper;
+    friend class TableViewBase;
+    template<class T>
+    friend class Columns;
+    friend class Columns<StringData>;
+    friend class ParentNode;
+    template<class>
+    friend class SequentialGetter;
+    friend class RowBase;
+    friend class LinksToNode;
+    friend class LinkMap;
+    friend class LinkView;
+    friend class Group;
+};
+
+
+
+class Table::Parent: public ArrayParent {
+public:
+    ~Parent() noexcept override {}
+
+protected:
+    virtual StringData get_child_name(size_t child_ndx) const noexcept;
+
+    /// If children are group-level tables, then this function returns the
+    /// group. Otherwise it returns null.
+    virtual Group* get_parent_group() noexcept;
+
+    /// If children are subtables, then this function returns the
+    /// parent table. Otherwise it returns null.
+    ///
+    /// If \a column_ndx_out is not null, this function must assign the index of
+    /// the column within the parent table to `*column_ndx_out` when , and only
+    /// when this table parent is a column in a parent table.
+    virtual Table* get_parent_table(size_t* column_ndx_out = nullptr) noexcept;
+
+    /// Must be called whenever a child table accessor is about to be destroyed.
+    ///
+    /// Note that the argument is a pointer to the child Table rather than its
+    /// `ndx_in_parent` property. This is because only minimal accessor
+    /// consistency can be assumed by this function.
+    virtual void child_accessor_destroyed(Table* child) noexcept = 0;
+
+    virtual size_t* record_subtable_path(size_t* begin, size_t* end) noexcept;
+
+    friend class Table;
+};
+
+
+// Implementation:
+
+
+inline uint_fast64_t Table::get_version_counter() const noexcept { return m_version; }
+
+inline void Table::bump_version(bool bump_global) const noexcept
+{
+    if (bump_global) {
+        // This is only set on initial entry through an operation on the same
+        // table.  recursive calls (via parent or via backlinks) must be done
+        // with bump_global=false.
+        m_top.get_alloc().bump_global_version();
+    }
+    if (m_top.get_alloc().should_propagate_version(m_version)) {
+        if (const Table* parent = get_parent_table_ptr())
+            parent->bump_version(false);
+        // Recurse through linked tables, use m_mark to avoid infinite recursion
+        for (auto& column_ptr : m_cols) {
+            // We may meet a null pointer in place of a backlink column, pending
+            // replacement with a new one. This can happen ONLY when creation of
+            // the corresponding forward link column in the origin table is
+            // pending as well. In this case it is ok to just ignore the zeroed
+            // backlink column, because the origin table is guaranteed to also
+            // be refreshed/marked dirty and hence have it's version bumped.
+            if (column_ptr != nullptr)
+                column_ptr->bump_link_origin_table_version();
+        }
+    }
+}
+
+inline void Table::remove(size_t row_ndx)
+{
+    bool is_move_last_over = false;
+    erase_row(row_ndx, is_move_last_over); // Throws
+}
+
+inline void Table::move_last_over(size_t row_ndx)
+{
+    bool is_move_last_over = true;
+    erase_row(row_ndx, is_move_last_over); // Throws
+}
+
+inline void Table::remove_last()
+{
+    if (!is_empty())
+        remove(size()-1);
+}
+
+// A good place to start if you want to understand the memory ordering
+// chosen for the operations below is http://preshing.com/20130922/acquire-and-release-fences/
+inline void Table::bind_ptr() const noexcept
+{
+    m_ref_count.fetch_add(1, std::memory_order_relaxed);
+}
+
+inline void Table::unbind_ptr() const noexcept
+{
+    // The delete operation runs the destructor, and the destructor
+    // must always see all changes to the object being deleted.
+    // Within each thread, we know that unbind_ptr will always happen after
+    // any changes, so it is a convenient place to do a release.
+    // The release will then be observed by the acquire fence in
+    // the case where delete is actually called (the count reaches 0)
+    if (m_ref_count.fetch_sub(1, std::memory_order_release) != 1)
+        return;
+
+    std::atomic_thread_fence(std::memory_order_acquire);
+    delete this;
+}
+
+inline void Table::register_view(const TableViewBase* view)
+{
+    util::LockGuard lock(m_accessor_mutex);
+    // Casting away constness here - operations done on tableviews
+    // through m_views are all internal and preserving "some" kind
+    // of logical constness.
+    m_views.push_back(const_cast<TableViewBase*>(view));
+}
+
+inline bool Table::is_attached() const noexcept
+{
+    // Note that it is not possible to tie the state of attachment of a table to
+    // the state of attachment of m_top, because tables with shared spec do not
+    // have a 'top' array. Neither is it possible to tie it to the state of
+    // attachment of m_columns, because subtables with shared spec start out in
+    // a degenerate form where they do not have a 'columns' array. For these
+    // reasons, it is neccessary to define the notion of attachment for a table
+    // as follows: A table is attached if, and ony if m_column stores a non-null
+    // parent pointer. This works because even for degenerate subtables,
+    // m_columns is initialized with the correct parent pointer.
+    return m_columns.has_parent();
+}
+
+inline StringData Table::get_name() const noexcept
+{
+    REALM_ASSERT(is_attached());
+    const Array& real_top = m_top.is_attached() ? m_top : m_columns;
+    ArrayParent* parent = real_top.get_parent();
+    if (!parent)
+        return StringData("");
+    size_t index_in_parent = real_top.get_ndx_in_parent();
+    REALM_ASSERT(dynamic_cast<Parent*>(parent));
+    return static_cast<Parent*>(parent)->get_child_name(index_in_parent);
+}
+
+inline size_t Table::get_column_count() const noexcept
+{
+    REALM_ASSERT(is_attached());
+    return m_spec.get_public_column_count();
+}
+
+inline StringData Table::get_column_name(size_t ndx) const noexcept
+{
+    REALM_ASSERT_3(ndx, <, get_column_count());
+    return m_spec.get_column_name(ndx);
+}
+
+inline size_t Table::get_column_index(StringData name) const noexcept
+{
+    REALM_ASSERT(is_attached());
+    return m_spec.get_column_index(name);
+}
+
+inline ColumnType Table::get_real_column_type(size_t ndx) const noexcept
+{
+    REALM_ASSERT_3(ndx, <, m_spec.get_column_count());
+    return m_spec.get_column_type(ndx);
+}
+
+inline DataType Table::get_column_type(size_t ndx) const noexcept
+{
+    REALM_ASSERT_3(ndx, <, m_spec.get_column_count());
+    return m_spec.get_public_column_type(ndx);
+}
+
+template<class Col, ColumnType col_type>
+inline Col& Table::get_column(size_t ndx)
+{
+    ColumnBase& col = get_column_base(ndx);
+#ifdef REALM_DEBUG
+    validate_column_type(col, col_type, ndx);
+#endif
+    REALM_ASSERT(typeid(Col) == typeid(col));
+    return static_cast<Col&>(col);
+}
+
+template<class Col, ColumnType col_type>
+inline const Col& Table::get_column(size_t ndx) const noexcept
+{
+    const ColumnBase& col = get_column_base(ndx);
+#ifdef REALM_DEBUG
+    validate_column_type(col, col_type, ndx);
+#endif
+    REALM_ASSERT(typeid(Col) == typeid(col));
+    return static_cast<const Col&>(col);
+}
+
+inline bool Table::has_shared_type() const noexcept
+{
+    REALM_ASSERT(is_attached());
+    return !m_top.is_attached();
+}
+
+
+class Table::UnbindGuard {
+public:
+    UnbindGuard(Table* table) noexcept: m_table(table)
+    {
+    }
+
+    ~UnbindGuard() noexcept
+    {
+        if (m_table)
+            m_table->unbind_ptr();
+    }
+
+    Table& operator*() const noexcept
+    {
+        return *m_table;
+    }
+
+    Table* operator->() const noexcept
+    {
+        return m_table;
+    }
+
+    Table* get() const noexcept
+    {
+        return m_table;
+    }
+
+    Table* release() noexcept
+    {
+        Table* table = m_table;
+        m_table = nullptr;
+        return table;
+    }
+
+private:
+    Table* m_table;
+};
+
+
+inline Table::Table(Allocator& alloc):
+    m_top(alloc),
+    m_columns(alloc),
+    m_spec(alloc)
+{
+    m_ref_count = 1; // Explicitely managed lifetime
+    m_descriptor = nullptr;
+
+    ref_type ref = create_empty_table(alloc); // Throws
+    Parent* parent = nullptr;
+    size_t ndx_in_parent = 0;
+    init(ref, parent, ndx_in_parent);
+}
+
+inline Table::Table(const Table& t, Allocator& alloc):
+    m_top(alloc),
+    m_columns(alloc),
+    m_spec(alloc)
+{
+    m_ref_count = 1; // Explicitely managed lifetime
+    m_descriptor = nullptr;
+
+    ref_type ref = t.clone(alloc); // Throws
+    Parent* parent = nullptr;
+    size_t ndx_in_parent = 0;
+    init(ref, parent, ndx_in_parent);
+}
+
+inline Table::Table(ref_count_tag, Allocator& alloc):
+    m_top(alloc),
+    m_columns(alloc),
+    m_spec(alloc)
+{
+    m_ref_count = 0; // Lifetime managed by reference counting
+    m_descriptor = nullptr;
+}
+
+inline Allocator& Table::get_alloc() const
+{
+    return m_top.get_alloc();
+}
+
+inline TableRef Table::create(Allocator& alloc)
+{
+    std::unique_ptr<Table> table(new Table(ref_count_tag(), alloc)); // Throws
+    ref_type ref = create_empty_table(alloc); // Throws
+    Parent* parent = nullptr;
+    size_t ndx_in_parent = 0;
+    table->init(ref, parent, ndx_in_parent); // Throws
+    return table.release()->get_table_ref();
+}
+
+inline TableRef Table::copy(Allocator& alloc) const
+{
+    std::unique_ptr<Table> table(new Table(ref_count_tag(), alloc)); // Throws
+    ref_type ref = clone(alloc); // Throws
+    Parent* parent = nullptr;
+    size_t ndx_in_parent = 0;
+    table->init(ref, parent, ndx_in_parent); // Throws
+    return table.release()->get_table_ref();
+}
+
+// For use by queries
+template<class T>
+inline Columns<T> Table::column(size_t column_ndx)
+{
+    std::vector<size_t> link_chain = std::move(m_link_chain);
+    m_link_chain.clear();
+
+    // Check if user-given template type equals Realm type. Todo, we should clean up and reuse all our
+    // type traits (all the is_same() cases below).
+    const Table* table = get_link_chain_target(link_chain);
+
+    realm::DataType ct = table->get_column_type(column_ndx);
+    if (std::is_same<T, int64_t>::value && ct != type_Int)
+        throw(LogicError::type_mismatch);
+    else if (std::is_same<T, bool>::value && ct != type_Bool)
+        throw(LogicError::type_mismatch);
+    else if (std::is_same<T, realm::OldDateTime>::value && ct != type_OldDateTime)
+        throw(LogicError::type_mismatch);
+    else if (std::is_same<T, float>::value && ct != type_Float)
+        throw(LogicError::type_mismatch);
+    else if (std::is_same<T, double>::value && ct != type_Double)
+        throw(LogicError::type_mismatch);
+
+    if (std::is_same<T, Link>::value || std::is_same<T, LinkList>::value || std::is_same<T, BackLink>::value) {
+        link_chain.push_back(column_ndx);
+    }
+
+    return Columns<T>(column_ndx, this, std::move(link_chain));
+}
+
+template<class T>
+inline Columns<T> Table::column(const Table& origin, size_t origin_col_ndx)
+{
+    static_assert(std::is_same<T, BackLink>::value, "");
+
+    size_t origin_table_ndx = origin.get_index_in_group();
+    const Table& current_target_table = *get_link_chain_target(m_link_chain);
+    size_t backlink_col_ndx = current_target_table.m_spec.find_backlink_column(origin_table_ndx, origin_col_ndx);
+
+    std::vector<size_t> link_chain = std::move(m_link_chain);
+    m_link_chain.clear();
+    link_chain.push_back(backlink_col_ndx);
+
+    return Columns<T>(backlink_col_ndx, this, std::move(link_chain));
+}
+
+template<class T>
+SubQuery<T> Table::column(size_t column_ndx, Query subquery)
+{
+    static_assert(std::is_same<T, LinkList>::value, "A subquery must involve a link list or backlink column");
+    return SubQuery<T>(column<T>(column_ndx), std::move(subquery));
+}
+
+template<class T>
+SubQuery<T> Table::column(const Table& origin, size_t origin_col_ndx, Query subquery)
+{
+    static_assert(std::is_same<T, BackLink>::value, "A subquery must involve a link list or backlink column");
+    return SubQuery<T>(column<T>(origin, origin_col_ndx), std::move(subquery));
+}
+
+// For use by queries
+inline Table& Table::link(size_t link_column)
+{
+    m_link_chain.push_back(link_column);
+    return *this;
+}
+
+inline Table& Table::backlink(const Table& origin, size_t origin_col_ndx)
+{
+    size_t origin_table_ndx = origin.get_index_in_group();
+    const Table& current_target_table = *get_link_chain_target(m_link_chain);
+    size_t backlink_col_ndx = current_target_table.m_spec.find_backlink_column(origin_table_ndx, origin_col_ndx);
+    return link(backlink_col_ndx);
+}
+
+inline bool Table::is_empty() const noexcept
+{
+    return m_size == 0;
+}
+
+inline size_t Table::size() const noexcept
+{
+    return m_size;
+}
+
+inline Table::RowExpr Table::get(size_t row_ndx) noexcept
+{
+    REALM_ASSERT_3(row_ndx, <, size());
+    return RowExpr(this, row_ndx);
+}
+
+inline Table::ConstRowExpr Table::get(size_t row_ndx) const noexcept
+{
+    REALM_ASSERT_3(row_ndx, <, size());
+    return ConstRowExpr(this, row_ndx);
+}
+
+inline Table::RowExpr Table::front() noexcept
+{
+    return get(0);
+}
+
+inline Table::ConstRowExpr Table::front() const noexcept
+{
+    return get(0);
+}
+
+inline Table::RowExpr Table::back() noexcept
+{
+    return get(m_size-1);
+}
+
+inline Table::ConstRowExpr Table::back() const noexcept
+{
+    return get(m_size-1);
+}
+
+inline Table::RowExpr Table::operator[](size_t row_ndx) noexcept
+{
+    return get(row_ndx);
+}
+
+inline Table::ConstRowExpr Table::operator[](size_t row_ndx) const noexcept
+{
+    return get(row_ndx);
+}
+
+inline size_t Table::add_empty_row(size_t num_rows)
+{
+    size_t row_ndx = m_size;
+    insert_empty_row(row_ndx, num_rows); // Throws
+    return row_ndx; // Return index of first new row
+}
+
+inline const Table* Table::get_subtable_ptr(size_t col_ndx, size_t row_ndx) const
+{
+    return const_cast<Table*>(this)->get_subtable_ptr(col_ndx, row_ndx); // Throws
+}
+
+inline bool Table::is_null_link(size_t col_ndx, size_t row_ndx) const noexcept
+{
+    return get_link(col_ndx, row_ndx) == realm::npos;
+}
+
+inline ConstTableRef Table::get_link_target(size_t col_ndx) const noexcept
+{
+    return const_cast<Table*>(this)->get_link_target(col_ndx);
+}
+
+template<class E>
+inline void Table::set_enum(size_t column_ndx, size_t row_ndx, E value)
+{
+    set_int(column_ndx, row_ndx, value);
+}
+
+inline void Table::nullify_link(size_t col_ndx, size_t row_ndx)
+{
+    set_link(col_ndx, row_ndx, realm::npos);
+}
+
+inline TableRef Table::get_subtable(size_t column_ndx, size_t row_ndx)
+{
+    return TableRef(get_subtable_ptr(column_ndx, row_ndx));
+}
+
+inline ConstTableRef Table::get_subtable(size_t column_ndx, size_t row_ndx) const
+{
+    return ConstTableRef(get_subtable_ptr(column_ndx, row_ndx));
+}
+
+inline ConstTableRef Table::get_parent_table(size_t* column_ndx_out) const noexcept
+{
+    return ConstTableRef(get_parent_table_ptr(column_ndx_out));
+}
+
+inline TableRef Table::get_parent_table(size_t* column_ndx_out) noexcept
+{
+    return TableRef(get_parent_table_ptr(column_ndx_out));
+}
+
+inline bool Table::is_group_level() const noexcept
+{
+    return bool(get_parent_group());
+}
+
+inline bool Table::operator==(const Table& t) const
+{
+    return m_spec == t.m_spec && compare_rows(t); // Throws
+}
+
+inline bool Table::operator!=(const Table& t) const
+{
+    return !(*this == t); // Throws
+}
+
+inline bool Table::is_degenerate() const noexcept
+{
+    return !m_columns.is_attached();
+}
+
+inline void Table::set_into_mixed(Table* parent, size_t col_ndx, size_t row_ndx) const
+{
+    parent->set_mixed_subtable(col_ndx, row_ndx, this);
+}
+
+inline size_t Table::get_size_from_ref(ref_type top_ref, Allocator& alloc) noexcept
+{
+    const char* top_header = alloc.translate(top_ref);
+    std::pair<int_least64_t, int_least64_t> p = Array::get_two(top_header, 0);
+    ref_type spec_ref = to_ref(p.first), columns_ref = to_ref(p.second);
+    return get_size_from_ref(spec_ref, columns_ref, alloc);
+}
+
+inline Table* Table::get_parent_table_ptr(size_t* column_ndx_out) noexcept
+{
+    const Table* parent = const_cast<const Table*>(this)->get_parent_table_ptr(column_ndx_out);
+    return const_cast<Table*>(parent);
+}
+
+inline bool Table::is_link_type(ColumnType col_type) noexcept
+{
+    return col_type == col_type_Link || col_type == col_type_LinkList;
+}
+
+inline size_t* Table::record_subtable_path(size_t* begin, size_t* end) const noexcept
+{
+    const Array& real_top = m_top.is_attached() ? m_top : m_columns;
+    size_t index_in_parent = real_top.get_ndx_in_parent();
+    REALM_ASSERT_3(begin, <, end);
+    *begin++ = index_in_parent;
+    ArrayParent* parent = real_top.get_parent();
+    REALM_ASSERT(parent);
+    REALM_ASSERT(dynamic_cast<Parent*>(parent));
+    return static_cast<Parent*>(parent)->record_subtable_path(begin, end);
+}
+
+inline size_t* Table::Parent::record_subtable_path(size_t* begin, size_t*) noexcept
+{
+    return begin;
+}
+
+template<class T>
+typename T::RowAccessor Table::get_link_accessor(size_t column_ndx, size_t row_ndx)
+{
+    size_t row_pos_in_target = get_link(column_ndx, row_ndx);
+    TableRef target_table = get_link_target(column_ndx);
+
+    Table* table = &*target_table;
+    T* typed_table = reinterpret_cast<T*>(table);
+    return (*typed_table)[row_pos_in_target];
+}
+
+inline bool Table::is_marked() const noexcept
+{
+    return m_mark;
+}
+
+inline void Table::mark() noexcept
+{
+    m_mark = true;
+}
+
+inline void Table::unmark() noexcept
+{
+    m_mark = false;
+}
+
+inline Replication* Table::get_repl() noexcept
+{
+    return m_top.get_alloc().get_replication();
+}
+
+inline void Table::set_ndx_in_parent(size_t ndx_in_parent) noexcept
+{
+    if (m_top.is_attached()) {
+        // Root table (independent descriptor)
+        m_top.set_ndx_in_parent(ndx_in_parent);
+    }
+    else {
+        // Subtable with shared descriptor
+        m_columns.set_ndx_in_parent(ndx_in_parent);
+    }
+}
+
+// This class groups together information about the target of a link column
+// This is not a valid link if the target table == nullptr
+struct LinkTargetInfo {
+    LinkTargetInfo(Table* target = nullptr, size_t backlink_ndx = realm::npos)
+        : m_target_table(target), m_backlink_col_ndx(backlink_ndx) {}
+    bool is_valid() const { return (m_target_table != nullptr); }
+    Table* m_target_table;
+    size_t m_backlink_col_ndx; // a value of npos indicates the backlink should be appended
+};
+
+// The purpose of this class is to give internal access to some, but
+// not all of the non-public parts of the Table class.
+class _impl::TableFriend {
+public:
+    typedef Table::UnbindGuard UnbindGuard;
+
+    static ref_type create_empty_table(Allocator& alloc)
+    {
+        return Table::create_empty_table(alloc); // Throws
+    }
+
+    static ref_type clone(const Table& table, Allocator& alloc)
+    {
+        return table.clone(alloc); // Throws
+    }
+
+    static ref_type clone_columns(const Table& table, Allocator& alloc)
+    {
+        return table.clone_columns(alloc); // Throws
+    }
+
+    static Table* create_accessor(Allocator& alloc, ref_type top_ref,
+                                  Table::Parent* parent, size_t ndx_in_parent)
+    {
+        std::unique_ptr<Table> table(new Table(Table::ref_count_tag(), alloc)); // Throws
+        table->init(top_ref, parent, ndx_in_parent); // Throws
+        return table.release();
+    }
+
+    static Table* create_accessor(ConstSubspecRef shared_spec, Table::Parent* parent_column,
+                                  size_t parent_row_ndx)
+    {
+        Allocator& alloc = shared_spec.get_alloc();
+        std::unique_ptr<Table> table(new Table(Table::ref_count_tag(), alloc)); // Throws
+        table->init(shared_spec, parent_column, parent_row_ndx); // Throws
+        return table.release();
+    }
+
+    // Intended to be used only by Group::create_table_accessor()
+    static Table* create_incomplete_accessor(Allocator& alloc, ref_type top_ref,
+                                             Table::Parent* parent, size_t ndx_in_parent)
+    {
+        std::unique_ptr<Table> table(new Table(Table::ref_count_tag(), alloc)); // Throws
+        bool skip_create_column_accessors = true;
+        table->init(top_ref, parent, ndx_in_parent, skip_create_column_accessors); // Throws
+        return table.release();
+    }
+
+    // Intended to be used only by Group::create_table_accessor()
+    static void complete_accessor(Table& table)
+    {
+        table.refresh_column_accessors(); // Throws
+    }
+
+    static void set_top_parent(Table& table, ArrayParent* parent,
+                               size_t ndx_in_parent) noexcept
+    {
+        table.m_top.set_parent(parent, ndx_in_parent);
+    }
+
+    static void update_from_parent(Table& table, size_t old_baseline) noexcept
+    {
+        table.update_from_parent(old_baseline);
+    }
+
+    static void detach(Table& table) noexcept
+    {
+        table.detach();
+    }
+
+    static void discard_row_accessors(Table& table) noexcept
+    {
+        table.discard_row_accessors();
+    }
+
+    static void discard_child_accessors(Table& table) noexcept
+    {
+        table.discard_child_accessors();
+    }
+
+    static void discard_subtable_accessor(Table& table, size_t col_ndx, size_t row_ndx) noexcept
+    {
+        table.discard_subtable_accessor(col_ndx, row_ndx);
+    }
+
+    static void bind_ptr(Table& table) noexcept
+    {
+        table.bind_ptr();
+    }
+
+    static void unbind_ptr(Table& table) noexcept
+    {
+        table.unbind_ptr();
+    }
+
+    static bool compare_rows(const Table& a, const Table& b)
+    {
+        return a.compare_rows(b); // Throws
+    }
+
+    static size_t get_size_from_ref(ref_type ref, Allocator& alloc) noexcept
+    {
+        return Table::get_size_from_ref(ref, alloc);
+    }
+
+    static size_t get_size_from_ref(ref_type spec_ref, ref_type columns_ref,
+                                         Allocator& alloc) noexcept
+    {
+        return Table::get_size_from_ref(spec_ref, columns_ref, alloc);
+    }
+
+    static Spec& get_spec(Table& table) noexcept
+    {
+        return table.m_spec;
+    }
+
+    static const Spec& get_spec(const Table& table) noexcept
+    {
+        return table.m_spec;
+    }
+
+    static ColumnBase& get_column(const Table& table, size_t col_ndx)
+    {
+        return *table.m_cols[col_ndx];
+    }
+
+    static void do_remove(Table& table, size_t row_ndx)
+    {
+        bool broken_reciprocal_backlinks = false;
+        table.do_remove(row_ndx, broken_reciprocal_backlinks); // Throws
+    }
+
+    static void do_move_last_over(Table& table, size_t row_ndx)
+    {
+        bool broken_reciprocal_backlinks = false;
+        table.do_move_last_over(row_ndx, broken_reciprocal_backlinks); // Throws
+    }
+
+    static void do_swap_rows(Table& table, size_t row_ndx_1, size_t row_ndx_2)
+    {
+        table.do_swap_rows(row_ndx_1, row_ndx_2); // Throws
+    }
+
+    static void do_change_link_targets(Table& table, size_t row_ndx, size_t new_row_ndx)
+    {
+        table.do_change_link_targets(row_ndx, new_row_ndx); // Throws
+    }
+
+    static void do_clear(Table& table)
+    {
+        bool broken_reciprocal_backlinks = false;
+        table.do_clear(broken_reciprocal_backlinks); // Throws
+    }
+
+    static void do_set_link(Table& table, size_t col_ndx, size_t row_ndx,
+                            size_t target_row_ndx)
+    {
+        table.do_set_link(col_ndx, row_ndx, target_row_ndx); // Throws
+    }
+
+    static size_t get_num_strong_backlinks(const Table& table,
+                                                size_t row_ndx) noexcept
+    {
+        return table.get_num_strong_backlinks(row_ndx);
+    }
+
+    static void cascade_break_backlinks_to(Table& table, size_t row_ndx,
+                                           CascadeState& state)
+    {
+        table.cascade_break_backlinks_to(row_ndx, state); // Throws
+    }
+
+    static void remove_backlink_broken_rows(Table& table, const CascadeState& rows)
+    {
+        table.remove_backlink_broken_rows(rows); // Throws
+    }
+
+    static size_t* record_subtable_path(const Table& table, size_t* begin,
+                                             size_t* end) noexcept
+    {
+        return table.record_subtable_path(begin, end);
+    }
+
+    static void insert_column(Descriptor& desc, size_t column_ndx, DataType type,
+                              StringData name, LinkTargetInfo& link, bool nullable = false)
+    {
+        Table::do_insert_column(desc, column_ndx, type, name, link, nullable); // Throws
+    }
+
+    static void insert_column_unless_exists(Descriptor& desc, size_t column_ndx, DataType type,
+                                            StringData name, LinkTargetInfo link, bool nullable = false,
+                                            bool* was_inserted = nullptr)
+    {
+        Table::do_insert_column_unless_exists(desc, column_ndx, type, name, link, nullable, was_inserted); // Throws
+    }
+
+    static void erase_column(Descriptor& desc, size_t column_ndx)
+    {
+        Table::do_erase_column(desc, column_ndx); // Throws
+    }
+
+    static void rename_column(Descriptor& desc, size_t column_ndx, StringData name)
+    {
+        Table::do_rename_column(desc, column_ndx, name); // Throws
+    }
+
+    static void move_column(Descriptor& desc, size_t col_ndx_1, size_t col_ndx_2)
+    {
+        Table::do_move_column(desc, col_ndx_1, col_ndx_2); // Throws
+    }
+
+    static void set_link_type(Table& table, size_t column_ndx, LinkType link_type)
+    {
+        table.do_set_link_type(column_ndx, link_type); // Throws
+    }
+
+    static void erase_row(Table& table, size_t row_ndx, bool is_move_last_over)
+    {
+        table.erase_row(row_ndx, is_move_last_over); // Throws
+    }
+
+    static void batch_erase_rows(Table& table, const IntegerColumn& row_indexes,
+                                 bool is_move_last_over)
+    {
+        table.batch_erase_rows(row_indexes, is_move_last_over); // Throws
+    }
+
+    static void clear_root_table_desc(const Table& root_table) noexcept
+    {
+        REALM_ASSERT(!root_table.has_shared_type());
+        root_table.m_descriptor = nullptr;
+    }
+
+    static Table* get_subtable_accessor(Table& table, size_t col_ndx,
+                                        size_t row_ndx) noexcept
+    {
+        return table.get_subtable_accessor(col_ndx, row_ndx);
+    }
+
+    static const Table* get_link_target_table_accessor(const Table& table,
+                                                       size_t col_ndx) noexcept
+    {
+        return const_cast<Table&>(table).get_link_target_table_accessor(col_ndx);
+    }
+
+    static Table* get_link_target_table_accessor(Table& table, size_t col_ndx) noexcept
+    {
+        return table.get_link_target_table_accessor(col_ndx);
+    }
+
+    static void adj_acc_insert_rows(Table& table, size_t row_ndx,
+                                    size_t num_rows) noexcept
+    {
+        table.adj_acc_insert_rows(row_ndx, num_rows);
+    }
+
+    static void adj_acc_erase_row(Table& table, size_t row_ndx) noexcept
+    {
+        table.adj_acc_erase_row(row_ndx);
+    }
+
+    static void adj_acc_swap_rows(Table& table, size_t row_ndx_1, size_t row_ndx_2) noexcept
+    {
+        table.adj_acc_swap_rows(row_ndx_1, row_ndx_2);
+    }
+
+    static void adj_acc_move_over(Table& table, size_t from_row_ndx,
+                                  size_t to_row_ndx) noexcept
+    {
+        table.adj_acc_move_over(from_row_ndx, to_row_ndx);
+    }
+
+    static void adj_acc_clear_root_table(Table& table) noexcept
+    {
+        table.adj_acc_clear_root_table();
+    }
+
+    static void adj_acc_clear_nonroot_table(Table& table) noexcept
+    {
+        table.adj_acc_clear_nonroot_table();
+    }
+
+    static void adj_insert_column(Table& table, size_t col_ndx)
+    {
+        table.adj_insert_column(col_ndx); // Throws
+    }
+
+    static void adj_add_column(Table& table)
+    {
+        size_t num_cols = table.m_cols.size();
+        table.adj_insert_column(num_cols); // Throws
+    }
+
+    static void adj_erase_column(Table& table, size_t col_ndx) noexcept
+    {
+        table.adj_erase_column(col_ndx);
+    }
+
+    static void adj_move_column(Table& table, size_t col_ndx_1, size_t col_ndx_2) noexcept
+    {
+        table.adj_move_column(col_ndx_1, col_ndx_2);
+    }
+
+    static bool is_marked(const Table& table) noexcept
+    {
+        return table.is_marked();
+    }
+
+    static void mark(Table& table) noexcept
+    {
+        table.mark();
+    }
+
+    static void unmark(Table& table) noexcept
+    {
+        table.unmark();
+    }
+
+    static void recursive_mark(Table& table) noexcept
+    {
+        table.recursive_mark();
+    }
+
+    static void mark_link_target_tables(Table& table, size_t col_ndx_begin) noexcept
+    {
+        table.mark_link_target_tables(col_ndx_begin);
+    }
+
+    static void mark_opposite_link_tables(Table& table) noexcept
+    {
+        table.mark_opposite_link_tables();
+    }
+
+    static Descriptor* get_root_table_desc_accessor(Table& root_table) noexcept
+    {
+        return root_table.m_descriptor;
+    }
+
+    typedef Table::AccessorUpdater AccessorUpdater;
+    static void update_accessors(Table& table, const size_t* col_path_begin,
+                                 const size_t* col_path_end, AccessorUpdater& updater)
+    {
+        table.update_accessors(col_path_begin, col_path_end, updater); // Throws
+    }
+
+    static void refresh_accessor_tree(Table& table)
+    {
+        table.refresh_accessor_tree(); // Throws
+    }
+
+    static void set_ndx_in_parent(Table& table, size_t ndx_in_parent) noexcept
+    {
+        table.set_ndx_in_parent(ndx_in_parent);
+    }
+
+    static void set_shared_subspec_ndx_in_parent(Table& table, size_t spec_ndx_in_parent) noexcept
+    {
+        table.m_spec.set_ndx_in_parent(spec_ndx_in_parent);
+    }
+
+    static bool is_link_type(ColumnType type) noexcept
+    {
+        return Table::is_link_type(type);
+    }
+
+    static void bump_version(Table& table, bool bump_global = true) noexcept
+    {
+        table.bump_version(bump_global);
+    }
+
+    static bool is_cross_table_link_target(const Table& table)
+    {
+        return table.is_cross_table_link_target();
+    }
+
+    static Group* get_parent_group(const Table& table) noexcept
+    {
+        return table.get_parent_group();
+    }
+
+    static Replication* get_repl(Table& table) noexcept
+    {
+        return table.get_repl();
+    }
+
+    static void register_view(Table& table, const TableViewBase* view)
+    {
+        table.register_view(view); // Throws
+    }
+
+    static void unregister_view(Table& table, const TableViewBase* view) noexcept
+    {
+        table.unregister_view(view);
+    }
+};
+
+
+} // namespace realm
+
+#endif // REALM_TABLE_HPP
diff --git a/Pods/Realm/include/core/realm/table_accessors.hpp b/Pods/Realm/include/core/realm/table_accessors.hpp
new file mode 100644
index 0000000..3252486
--- /dev/null
+++ b/Pods/Realm/include/core/realm/table_accessors.hpp
@@ -0,0 +1,1738 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_TABLE_ACCESSORS_HPP
+#define REALM_TABLE_ACCESSORS_HPP
+
+#include <cstring>
+#include <utility>
+
+#include <realm/mixed.hpp>
+#include <realm/table.hpp>
+
+#include <realm/query_engine.hpp>
+
+namespace realm {
+
+
+/// A convenience base class for Spec classes that are to be used with
+/// BasicTable.
+///
+/// There are two reasons why you might want to derive your spec class
+/// from this one. First, it offers short hand names for each of the
+/// available column types. Second, it makes it easier when you do not
+/// want to specify colum names or convenience methods, since suitable
+/// fallbacks are defined here.
+struct SpecBase {
+    typedef int64_t             Int;
+    typedef bool                Bool;
+    typedef realm::OldDateTime   OldDateTime;
+    typedef float               Float;
+    typedef double              Double;
+    typedef realm::StringData String;
+    typedef realm::BinaryData Binary;
+    typedef realm::Mixed      Mixed;
+
+    template<class E>
+    class Enum {
+    public:
+        typedef E enum_type;
+        Enum(E v): m_value(v) {}
+        operator E() const { return m_value; }
+    private:
+        E m_value;
+    };
+
+    template<class T>
+    class Subtable {
+    public:
+        typedef T table_type;
+        Subtable(T* t): m_table(t) {}
+        operator T*() const { return m_table; }
+    private:
+        T* m_table;
+    };
+
+    /// By default, there are no static column names defined for a
+    /// BasicTable. One may define a set of column mames as follows:
+    ///
+    /// \code{.cpp}
+    ///
+    ///   struct MyTableSpec: SpecBase {
+    ///     typedef TypeAppend<void, int>::type Columns1;
+    ///     typedef TypeAppend<Columns1, bool>::type Columns;
+    ///
+    ///     template<template<int> class Col, class Init>
+    ///     struct ColNames {
+    ///       typename Col<0>::type foo;
+    ///       typename Col<1>::type bar;
+    ///       ColNames(Init i) noexcept: foo(i), bar(i) {}
+    ///     };
+    ///   };
+    ///
+    /// \endcode
+    ///
+    /// Note that 'i' in Col<i> links the name that you specify to a
+    /// particular column index. You may specify the column names in
+    /// any order. Multiple names may refer to the same column, and
+    /// you do not have to specify a name for every column.
+    template<template<int> class Col, class Init>
+    struct ColNames {
+        ColNames(Init) noexcept {}
+    };
+
+    /// FIXME: Currently we do not support absence of dynamic column
+    /// names.
+    static void dyn_col_names(StringData*) noexcept {}
+
+    /// This is the fallback class that is used when no convenience
+    /// methods are specified in the users Spec class.
+    ///
+    /// If you would like to add a more convenient add() method, here
+    /// is how you could do it:
+    ///
+    /// \code{.cpp}
+    ///
+    ///   struct MyTableSpec: SpecBase {
+    ///     typedef realm::TypeAppend<void, int>::type Columns1;
+    ///     typedef realm::TypeAppend<Columns1, bool>::type Columns;
+    ///
+    ///     struct ConvenienceMethods {
+    ///       void add(int foo, bool bar)
+    ///       {
+    ///         BasicTable<MyTableSpec>* const t = static_cast<BasicTable<MyTableSpec>*>(this);
+    ///         t->add((tuple(), name1, name2));
+    ///       }
+    ///     };
+    ///   };
+    ///
+    /// \endcode
+    ///
+    /// FIXME: ConvenienceMethods may not contain any virtual methods,
+    /// nor may it contain any data memebers. We might want to check
+    /// this by static_assert(sizeof(Derivative of
+    /// ConvenienceMethods) == 1)), however, this would not be
+    /// guaranteed by the standard, since even an empty class may add
+    /// to the size of the derived class. Fortunately, as long as
+    /// ConvenienceMethods is derived from, by BasicTable, after
+    /// deriving from Table, this cannot become a problem, nor would
+    /// it lead to a violation of the strict aliasing rule of C++03 or
+    /// C++11.
+    struct ConvenienceMethods {};
+};
+
+
+template<class>
+class BasicTable;
+template<class>
+class BasicTableView;
+
+
+namespace _impl {
+
+
+/// Get the const qualified type of the table being accessed.
+///
+/// If T matches 'BasicTableView<T2>' or 'const BasicTableView<T2>',
+/// then return T2, else simply return T.
+template<class Tab>
+struct GetTableFromView { typedef Tab type; };
+template<class Tab>
+struct GetTableFromView<BasicTableView<Tab>> { typedef Tab type; };
+template<class Tab>
+struct GetTableFromView<const BasicTableView<Tab>> { typedef Tab type; };
+
+
+/// Determine whether an accessor has const-only access to a table, so
+/// that it is not allowed to modify fields, nor return non-const
+/// subtable references.
+///
+/// Note that for Taboid = 'BasicTableView<const Tab>', a column
+/// accessor is still allowed to reorder the rows of the view, as long
+/// as it does not modify the contents of the table.
+template<class Taboid>
+struct TableIsConst { static const bool value = false; };
+template<class Taboid>
+struct TableIsConst<const Taboid> { static const bool value = true; };
+template<class Tab>
+struct TableIsConst<BasicTableView<const Tab>> {
+    static const bool value = true;
+};
+
+
+
+/// This class gives access to a field of a row of a table, or a table
+/// view.
+///
+/// \tparam Taboid Either a table or a table view, that is, any of
+/// 'BasicTable<S>', 'const BasicTable<S>',
+/// 'BasicTableView<BasicTable<S>>', 'const
+/// BasicTableView<BasicTable<S>>', 'BasicTableView<const
+/// BasicTable<S>>', or 'const BasicTableView<const BasicTable<S>
+/// >'. Note that the term 'taboid' is used here for something that is
+/// table-like, i.e., either a table of a table view.
+///
+/// \tparam const_tab Indicates whether the accessor has const-only
+/// access to the field, that is, if, and only if Taboid matches
+/// 'const T' or 'BasicTableView<const T>' for any T.
+template<class Taboid, int col_idx, class Type, bool const_tab>
+class FieldAccessor;
+
+
+/// Commmon base class for all field accessor specializations.
+template<class Taboid>
+class FieldAccessorBase {
+protected:
+    typedef std::pair<Taboid*, size_t> Init;
+    Taboid* const m_table;
+    const size_t m_row_idx;
+    FieldAccessorBase(Init i) noexcept: m_table(i.first), m_row_idx(i.second) {}
+};
+
+
+/// Field accessor specialization for integers.
+template<class Taboid, int col_idx, bool const_tab>
+class FieldAccessor<Taboid, col_idx, int64_t, const_tab>: public FieldAccessorBase<Taboid> {
+private:
+    typedef FieldAccessorBase<Taboid> Base;
+
+public:
+    int64_t get() const noexcept
+    {
+        return Base::m_table->get_impl()->get_int(col_idx, Base::m_row_idx);
+    }
+
+    void set(int64_t value) const
+    {
+        Base::m_table->get_impl()->set_int(col_idx, Base::m_row_idx, value);
+    }
+    operator int64_t() const noexcept { return get(); }
+    const FieldAccessor& operator=(int64_t value) const { set(value); return *this; }
+
+    const FieldAccessor& operator+=(int64_t value) const
+    {
+        // FIXME: Should be optimized (can be both optimized and
+        // generalized by using a form of expression templates).
+        set(get() + value);
+        return *this;
+    }
+
+    const FieldAccessor& operator-=(int64_t value) const
+    {
+        // FIXME: Should be optimized (can be both optimized and
+        // generalized by using a form of expression templates).
+        set(get() - value);
+        return *this;
+    }
+
+    const FieldAccessor& operator++() const { return *this += 1; }
+    const FieldAccessor& operator--() const { return *this -= 1; }
+
+    int64_t operator++(int) const
+    {
+        // FIXME: Should be optimized (can be both optimized and
+        // generalized by using a form of expression templates).
+        const int64_t value = get();
+        set(value + 1);
+        return value;
+    }
+
+    int64_t operator--(int) const
+    {
+        // FIXME: Should be optimized (can be both optimized and
+        // generalized by using a form of expression templates).
+        const int64_t value = get();
+        set(value - 1);
+        return value;
+    }
+
+
+    explicit FieldAccessor(typename Base::Init i) noexcept: Base(i) {}
+};
+
+
+/// Field accessor specialization for floats.
+template<class Taboid, int col_idx, bool const_tab>
+class FieldAccessor<Taboid, col_idx, float, const_tab>: public FieldAccessorBase<Taboid> {
+private:
+    typedef FieldAccessorBase<Taboid> Base;
+
+public:
+    float get() const noexcept
+    {
+        return Base::m_table->get_impl()->get_float(col_idx, Base::m_row_idx);
+    }
+
+    void set(float value) const
+    {
+        Base::m_table->get_impl()->set_float(col_idx, Base::m_row_idx, value);
+    }
+
+    operator float() const noexcept { return get(); }
+    const FieldAccessor& operator=(float value) const { set(value); return *this; }
+
+    const FieldAccessor& operator+=(float value) const
+    {
+        // FIXME: Should be optimized (can be both optimized and
+        // generalized by using a form of expression templates).
+        set(get() + value);
+        return *this;
+    }
+
+    const FieldAccessor& operator-=(float value) const
+    {
+        // FIXME: Should be optimized (can be both optimized and
+        // generalized by using a form of expression templates).
+        set(get() - value);
+        return *this;
+    }
+
+
+    explicit FieldAccessor(typename Base::Init i) noexcept: Base(i) {}
+};
+
+
+/// Field accessor specialization for doubles.
+template<class Taboid, int col_idx, bool const_tab>
+class FieldAccessor<Taboid, col_idx, double, const_tab>: public FieldAccessorBase<Taboid> {
+private:
+    typedef FieldAccessorBase<Taboid> Base;
+
+public:
+    double get() const noexcept
+    {
+        return Base::m_table->get_impl()->get_double(col_idx, Base::m_row_idx);
+    }
+
+    void set(double value) const
+    {
+        Base::m_table->get_impl()->set_double(col_idx, Base::m_row_idx, value);
+    }
+
+    operator double() const noexcept { return get(); }
+    const FieldAccessor& operator=(double value) const { set(value); return *this; }
+
+    const FieldAccessor& operator+=(double value) const
+    {
+        // FIXME: Should be optimized (can be both optimized and
+        // generalized by using a form of expression templates).
+        set(get() + value);
+        return *this;
+    }
+
+    const FieldAccessor& operator-=(double value) const
+    {
+        // FIXME: Should be optimized (can be both optimized and
+        // generalized by using a form of expression templates).
+        set(get() - value);
+        return *this;
+    }
+
+
+    explicit FieldAccessor(typename Base::Init i) noexcept: Base(i) {}
+};
+
+
+/// Field accessor specialization for booleans.
+template<class Taboid, int col_idx, bool const_tab>
+class FieldAccessor<Taboid, col_idx, bool, const_tab>: public FieldAccessorBase<Taboid> {
+private:
+    typedef FieldAccessorBase<Taboid> Base;
+
+public:
+    bool get() const noexcept
+    {
+        return Base::m_table->get_impl()->get_bool(col_idx, Base::m_row_idx);
+    }
+
+    void set(bool value) const
+    {
+        Base::m_table->get_impl()->set_bool(col_idx, Base::m_row_idx, value);
+    }
+
+    operator bool() const noexcept { return get(); }
+    const FieldAccessor& operator=(bool value) const { set(value); return *this; }
+
+
+    explicit FieldAccessor(typename Base::Init i) noexcept: Base(i) {}
+};
+
+
+/// Field accessor specialization for enumerations.
+template<class Taboid, int col_idx, class E, bool const_tab>
+class FieldAccessor<Taboid, col_idx, SpecBase::Enum<E>, const_tab>:
+    public FieldAccessorBase<Taboid> {
+private:
+    typedef FieldAccessorBase<Taboid> Base;
+
+public:
+    E get() const noexcept
+    {
+        return static_cast<E>(Base::m_table->get_impl()->get_int(col_idx, Base::m_row_idx));
+    }
+
+    void set(E value) const
+    {
+        Base::m_table->get_impl()->set_int(col_idx, Base::m_row_idx, value);
+    }
+
+    operator E() const noexcept { return get(); }
+    const FieldAccessor& operator=(E value) const { set(value); return *this; }
+
+
+    explicit FieldAccessor(typename Base::Init i) noexcept: Base(i) {}
+};
+
+
+/// Field accessor specialization for dates.
+template<class Taboid, int col_idx, bool const_tab>
+class FieldAccessor<Taboid, col_idx, OldDateTime, const_tab>: public FieldAccessorBase<Taboid> {
+private:
+    typedef FieldAccessorBase<Taboid> Base;
+
+public:
+    OldDateTime get() const noexcept
+    {
+        return Base::m_table->get_impl()->get_olddatetime(col_idx, Base::m_row_idx);
+    }
+
+    void set(OldDateTime value) const
+    {
+        Base::m_table->get_impl()->set_olddatetime(col_idx, Base::m_row_idx, value);
+    }
+
+    operator OldDateTime() const noexcept { return get(); }
+    const FieldAccessor& operator=(OldDateTime value) const { set(value); return *this; }
+
+
+    explicit FieldAccessor(typename Base::Init i) noexcept: Base(i) {}
+};
+
+/// Field accessor specialization for timestamps.
+template<class Taboid, int col_idx, bool const_tab>
+class FieldAccessor<Taboid, col_idx, Timestamp, const_tab>: public FieldAccessorBase<Taboid> {
+private:
+    typedef FieldAccessorBase<Taboid> Base;
+
+public:
+    Timestamp get() const noexcept
+    {
+        return Base::m_table->get_impl()->get_timestamp(col_idx, Base::m_row_idx);
+    }
+
+    void set(Timestamp value) const
+    {
+        Base::m_table->get_impl()->set_timestamp(col_idx, Base::m_row_idx, value);
+    }
+
+    operator Timestamp() const noexcept { return get(); }
+    const FieldAccessor& operator=(Timestamp value) const { set(value); return *this; }
+
+
+    explicit FieldAccessor(typename Base::Init i) noexcept: Base(i) {}
+};
+
+/// Field accessor specialization for strings.
+template<class Taboid, int col_idx, bool const_tab>
+class FieldAccessor<Taboid, col_idx, StringData, const_tab>: public FieldAccessorBase<Taboid> {
+private:
+    typedef FieldAccessorBase<Taboid> Base;
+
+public:
+    StringData get() const noexcept
+    {
+        return Base::m_table->get_impl()->get_string(col_idx, Base::m_row_idx);
+    }
+
+    void set(StringData value) const
+    {
+        Base::m_table->get_impl()->set_string(col_idx, Base::m_row_idx, value);
+    }
+
+    operator StringData() const noexcept { return get(); }
+    const FieldAccessor& operator=(StringData value) const { set(value); return *this; }
+
+    const char* data() const noexcept { return get().data(); }
+    size_t size() const noexcept { return get().size(); }
+
+    const char* c_str() const noexcept { return data(); }
+
+
+    explicit FieldAccessor(typename Base::Init i) noexcept: Base(i) {}
+};
+
+
+/// Field accessor specialization for binary data.
+template<class Taboid, int col_idx, bool const_tab>
+class FieldAccessor<Taboid, col_idx, BinaryData, const_tab>: public FieldAccessorBase<Taboid> {
+private:
+    typedef FieldAccessorBase<Taboid> Base;
+
+public:
+    BinaryData get() const noexcept
+    {
+        return Base::m_table->get_impl()->get_binary(col_idx, Base::m_row_idx);
+    }
+
+    void set(const BinaryData& value) const
+    {
+        Base::m_table->get_impl()->set_binary(col_idx, Base::m_row_idx, value);
+    }
+
+    operator BinaryData() const noexcept { return get(); }
+    const FieldAccessor& operator=(const BinaryData& value) const { set(value); return *this; }
+
+    const char* data() const noexcept { return get().data(); }
+    size_t size() const noexcept { return get().size(); }
+
+
+    explicit FieldAccessor(typename Base::Init i) noexcept: Base(i) {}
+};
+
+
+/// Field accessor specialization for subtables of non-const parent.
+template<class Taboid, int col_idx, class Subtab>
+class FieldAccessor<Taboid, col_idx, SpecBase::Subtable<Subtab>, false>:
+    public FieldAccessorBase<Taboid> {
+private:
+    typedef FieldAccessorBase<Taboid> Base;
+    // FIXME: Dangerous slicing posibility as long as Cursor is same as RowAccessor.
+    // FIXME: Accessors must not be publicly copyable. This requires that Spec::ColNames is made a friend of BasicTable.
+    // FIXME: Need BasicTableView::Cursor and BasicTableView::ConstCursor if Cursors should exist at all.
+    struct SubtabRowAccessor: Subtab::RowAccessor {
+    public:
+        SubtabRowAccessor(Subtab* subtable, size_t row_idx):
+            Subtab::RowAccessor(std::make_pair(subtable, row_idx)),
+            m_owner(subtable->get_table_ref()) {}
+
+    private:
+        typename Subtab::Ref const m_owner;
+    };
+
+public:
+    operator typename Subtab::Ref() const
+    {
+        Subtab* subtab =
+            Base::m_table->template get_subtable_ptr<Subtab>(col_idx, Base::m_row_idx);
+        return subtab->get_table_ref();
+    }
+
+    operator typename Subtab::ConstRef() const
+    {
+        const Subtab* subtab =
+            Base::m_table->template get_subtable_ptr<Subtab>(col_idx, Base::m_row_idx);
+        return subtab->get_table_ref();
+    }
+
+    typename Subtab::Ref operator->() const
+    {
+        Subtab* subtab =
+            Base::m_table->template get_subtable_ptr<Subtab>(col_idx, Base::m_row_idx);
+        return subtab->get_table_ref();
+    }
+
+    SubtabRowAccessor operator[](size_t row_idx) const
+    {
+        Subtab* subtab =
+            Base::m_table->template get_subtable_ptr<Subtab>(col_idx, Base::m_row_idx);
+        return SubtabRowAccessor(subtab, row_idx);
+    }
+
+
+    explicit FieldAccessor(typename Base::Init i) noexcept: Base(i) {}
+};
+
+
+/// Field accessor specialization for subtables of const parent.
+template<class Taboid, int col_idx, class Subtab>
+class FieldAccessor<Taboid, col_idx, SpecBase::Subtable<Subtab>, true>:
+    public FieldAccessorBase<Taboid> {
+private:
+    typedef FieldAccessorBase<Taboid> Base;
+    // FIXME: Dangerous slicing posibility as long as Cursor is same as RowAccessor.
+    struct SubtabRowAccessor: Subtab::ConstRowAccessor {
+    public:
+        SubtabRowAccessor(const Subtab* subtable, size_t row_idx):
+            Subtab::ConstRowAccessor(std::make_pair(subtable, row_idx)),
+            m_owner(subtable->get_table_ref()) {}
+
+    private:
+        typename Subtab::ConstRef const m_owner;
+    };
+
+public:
+    explicit FieldAccessor(typename Base::Init i) noexcept: Base(i) {}
+
+    operator typename Subtab::ConstRef() const
+    {
+        const Subtab* subtab =
+            Base::m_table->template get_subtable_ptr<Subtab>(col_idx, Base::m_row_idx);
+        return subtab->get_table_ref();
+    }
+
+    typename Subtab::ConstRef operator->() const
+    {
+        const Subtab* subtab =
+            Base::m_table->template get_subtable_ptr<Subtab>(col_idx, Base::m_row_idx);
+        return subtab->get_table_ref();
+    }
+
+    SubtabRowAccessor operator[](size_t row_idx) const
+    {
+        const Subtab* subtab =
+            Base::m_table->template get_subtable_ptr<Subtab>(col_idx, Base::m_row_idx);
+        return SubtabRowAccessor(subtab, row_idx);
+    }
+};
+
+
+/// Base for field accessor specializations for mixed type.
+template<class Taboid, int col_idx, class FieldAccessor>
+class MixedFieldAccessorBase: public FieldAccessorBase<Taboid> {
+private:
+    typedef FieldAccessorBase<Taboid> Base;
+
+public:
+    Mixed get() const noexcept
+    {
+        return Base::m_table->get_impl()->get_mixed(col_idx, Base::m_row_idx);
+    }
+
+    void set(const Mixed& value) const
+    {
+        Base::m_table->get_impl()->set_mixed(col_idx, Base::m_row_idx, value);
+    }
+
+    operator Mixed() const noexcept { return get(); }
+
+    const FieldAccessor& operator=(const Mixed& value) const
+    {
+        set(value);
+        return static_cast<FieldAccessor&>(*this);
+    }
+
+    DataType get_type() const noexcept
+    {
+        return Base::m_table->get_impl()->get_mixed_type(col_idx, Base::m_row_idx);
+    }
+
+    int64_t get_int() const noexcept { return get().get_int(); }
+
+    bool get_bool() const noexcept { return get().get_bool(); }
+
+    OldDateTime get_olddatetime() const noexcept { return get().get_olddatetime(); }
+
+    float get_float() const noexcept { return get().get_float(); }
+
+    double get_double() const noexcept { return get().get_double(); }
+
+    StringData get_string() const noexcept { return get().get_string(); }
+
+    BinaryData get_binary() const noexcept { return get().get_binary(); }
+
+    bool is_subtable() const noexcept { return get_type() == type_Table; }
+
+    /// Checks whether this value is a subtable of the specified type.
+    ///
+    /// FIXME: Consider deleting this function. It is mostly
+    /// redundant, and it is inefficient if you want to also get a
+    /// reference to the table, or if you want to check for multiple
+    /// table types.
+    template<class T>
+    bool is_subtable() const
+    {
+        // FIXME: Conversion from TableRef to ConstTableRef is relatively expensive, or is it? Check whether it involves access to the reference count!
+        ConstTableRef t = static_cast<const FieldAccessor*>(this)->get_subtable();
+        return t && T::matches_dynamic_type(TableFriend::get_spec(*t));
+    }
+
+    /// Generally more efficient that get_subtable()->size().
+    size_t get_subtable_size() const noexcept
+    {
+        return Base::m_table->get_impl()->get_subtable_size(col_idx, Base::m_row_idx);
+    }
+
+    template<class T>
+    friend bool operator==(const FieldAccessor& a, const T& b) noexcept
+    {
+        return a.get() == b;
+    }
+
+    template<class T>
+    friend bool operator!=(const FieldAccessor& a, const T& b) noexcept
+    {
+        return a.get() != b;
+    }
+
+    template<class T>
+    friend bool operator==(const T& a, const FieldAccessor& b) noexcept
+    {
+        return a == b.get();
+    }
+
+    template<class T>
+    friend bool operator!=(const T& a, const FieldAccessor& b) noexcept
+    {
+        return a != b.get();
+    }
+
+protected:
+    MixedFieldAccessorBase(typename Base::Init i) noexcept: Base(i) {}
+};
+
+
+/// Field accessor specialization for mixed type of non-const parent.
+template<class Taboid, int col_idx>
+class FieldAccessor<Taboid, col_idx, Mixed, false>:
+    public MixedFieldAccessorBase<Taboid, col_idx, FieldAccessor<Taboid, col_idx, Mixed, false>> {
+private:
+    typedef FieldAccessor<Taboid, col_idx, Mixed, false> This;
+    typedef MixedFieldAccessorBase<Taboid, col_idx, This> Base;
+
+public:
+    /// Returns null if the current value is not a subtable.
+    TableRef get_subtable() const
+    {
+        return Base::m_table->get_impl()->get_subtable(col_idx, Base::m_row_idx);
+    }
+
+    /// Overwrites the current value with an empty subtable and
+    /// returns a reference to it.
+    TableRef set_subtable() const
+    {
+        Base::m_table->get_impl()->clear_subtable(col_idx, Base::m_row_idx);
+        return get_subtable();
+    }
+
+    /// Overwrites the current value with a copy of the specified
+    /// table and returns a reference to the copy.
+    TableRef set_subtable(const Table& t) const
+    {
+        t.set_into_mixed(Base::m_table->get_impl(), col_idx, Base::m_row_idx);
+        return get_subtable();
+    }
+
+    /// This function makes the following assumption: If the current
+    /// value is a subtable, then it is a subtable of the specified
+    /// type. If this is not the case, your computer may catch fire.
+    ///
+    /// To safely and efficiently check whether the current value is a
+    /// subtable of any of a set of specific table types, you may do
+    /// as follows:
+    ///
+    /// \code{.cpp}
+    ///
+    ///   if (TableRef subtable = my_table[i].mixed.get_subtable()) {
+    ///     if (subtable->is_a<MyFirstSubtable>()) {
+    ///       MyFirstSubtable::Ref s = unchecked_cast<MyFirstSubtable>(move(subtable))) {
+    ///       // ...
+    ///     }
+    ///     else if (subtable->is_a<MySecondSubtable>()) {
+    ///       MySecondSubtable::Ref s = unchecked_cast<MySecondSubtable>(move(subtable))) {
+    ///       // ...
+    ///     }
+    ///   }
+    ///
+    /// \endcode
+    ///
+    /// \return Null if the current value is not a subtable.
+    ///
+    /// \note This function is generally unsafe because it does not
+    /// check that the specified table type matches the actual table
+    /// type.
+    ///
+    /// FIXME: Consider deleting this function, since it is both
+    /// unsafe and superfluous.
+    template<class T>
+    BasicTableRef<T> get_subtable() const
+    {
+        REALM_ASSERT(!Base::is_subtable() || Base::template is_subtable<T>());
+        return unchecked_cast<T>(get_subtable());
+    }
+
+    /// Overwrites the current value with an empty subtable and
+    /// returns a reference to it.
+    ///
+    /// \tparam T The subtable type. It must not be const-qualified.
+    template<class T>
+    BasicTableRef<T> set_subtable() const
+    {
+        BasicTableRef<T> t = unchecked_cast<T>(set_subtable());
+        T::set_dynamic_type(*t);
+        return t;
+    }
+
+    /// Overwrites the current value with a copy of the specified
+    /// table and returns a reference to the copy.
+    template<class T>
+    typename T::Ref set_subtable(const T& t) const
+    {
+        t.set_into_mixed(Base::m_table->get_impl(), col_idx, Base::m_row_idx);
+        return unchecked_cast<T>(get_subtable());
+    }
+
+
+    explicit FieldAccessor(typename Base::Init i) noexcept: Base(i) {}
+};
+
+
+/// Field accessor specialization for mixed type of const parent.
+template<class Taboid, int col_idx>
+class FieldAccessor<Taboid, col_idx, Mixed, true>:
+    public MixedFieldAccessorBase<Taboid, col_idx, FieldAccessor<Taboid, col_idx, Mixed, true>> {
+private:
+    typedef FieldAccessor<Taboid, col_idx, Mixed, true> This;
+    typedef MixedFieldAccessorBase<Taboid, col_idx, This> Base;
+
+public:
+    ConstTableRef get_subtable() const
+    {
+        return Base::m_table->get_impl()->get_subtable(col_idx, Base::m_row_idx);
+    }
+
+    /// FIXME: Consider deleting this function, since it is both
+    /// unsafe and superfluous.
+    template<class T>
+    BasicTableRef<const T> get_subtable() const
+    {
+        REALM_ASSERT(!Base::is_subtable() || Base::template is_subtable<T>());
+        return unchecked_cast<const T>(get_subtable());
+    }
+
+
+    explicit FieldAccessor(typename Base::Init i) noexcept: Base(i) {}
+};
+
+
+
+
+/// This class gives access to a column of a table.
+///
+/// \tparam Taboid Either a table or a table view. Constness of access
+/// is controlled by what is allowed to be done with/on a 'Taboid*'.
+template<class Taboid, int col_idx, class Type>
+class ColumnAccessor;
+
+
+/// Commmon base class for all column accessor specializations.
+template<class Taboid, int col_idx, class Type>
+class ColumnAccessorBase {
+protected:
+    typedef typename GetTableFromView<Taboid>::type RealTable;
+    typedef FieldAccessor<Taboid, col_idx, Type, TableIsConst<Taboid>::value> Field;
+
+public:
+    Field operator[](size_t row_idx) const
+    {
+        return Field(std::make_pair(m_table, row_idx));
+    }
+
+    bool has_search_index() const { return m_table->get_impl()->has_search_index(col_idx); }
+    void add_search_index() const { m_table->get_impl()->add_search_index(col_idx); }
+    void remove_search_index() const { m_table->get_impl()->remove_search_index(col_idx); }
+
+    BasicTableView<RealTable> get_sorted_view(bool ascending=true) const
+    {
+        return m_table->get_impl()->get_sorted_view(col_idx, ascending);
+    }
+
+    void sort(bool ascending = true) const { m_table->get_impl()->sort(col_idx, ascending); }
+
+protected:
+    Taboid* const m_table;
+
+    explicit ColumnAccessorBase(Taboid* t) noexcept: m_table(t) {}
+};
+
+namespace {
+
+// Used as base class of ColumnAccessor when Columns is not appropriate
+// (e.g., accessor of a TableView, which is not yet supported).
+struct NotARealColumns {
+    NotARealColumns(size_t, void*) { }
+};
+
+// Select whether to use Columns<T> or NotARealColumns for the given Taboid.
+template<class Taboid, class T>
+struct ColumnsForTaboid {
+    using type = typename std::conditional<std::is_base_of<Table, Taboid>::value, Columns<T>, NotARealColumns>::type;
+};
+
+} // anonymous namespace
+
+/// Column accessor specialization for integers.
+template<class Taboid, int col_idx>
+class ColumnAccessor<Taboid, col_idx, int64_t>:
+    public ColumnAccessorBase<Taboid, col_idx, int64_t>, public ColumnsForTaboid<Taboid, int64_t>::type {
+private:
+    using Base = ColumnAccessorBase<Taboid, col_idx, int64_t>;
+    using ColumnsBase = typename ColumnsForTaboid<Taboid, int64_t>::type;
+
+public:
+    explicit ColumnAccessor(Taboid* t) noexcept: Base(t), ColumnsBase(col_idx, t->get_impl())
+    {
+    }
+
+    size_t find_first(int64_t value) const
+    {
+        return Base::m_table->get_impl()->find_first_int(col_idx, value);
+    }
+
+    BasicTableView<typename Base::RealTable> find_all(int64_t value) const
+    {
+        return Base::m_table->get_impl()->find_all_int(col_idx, value);
+    }
+
+    BasicTableView<typename Base::RealTable> get_distinct_view() const
+    {
+        return Base::m_table->get_impl()->get_distinct_view(col_idx);
+    }
+
+    size_t count(int64_t target) const
+    {
+        return Base::m_table->get_impl()->count_int(col_idx, target);
+    }
+
+    int64_t sum() const
+    {
+        return Base::m_table->get_impl()->sum_int(col_idx);
+    }
+
+    int64_t maximum(size_t* return_ndx = nullptr) const
+    {
+        return Base::m_table->get_impl()->maximum_int(col_idx, return_ndx);
+    }
+
+    int64_t minimum(size_t* return_ndx = nullptr) const
+    {
+        return Base::m_table->get_impl()->minimum_int(col_idx, return_ndx);
+    }
+
+    double average() const
+    {
+        return Base::m_table->get_impl()->average_int(col_idx);
+    }
+
+    size_t lower_bound(int64_t value) const noexcept
+    {
+        return Base::m_table->lower_bound_int(col_idx, value);
+    }
+
+    size_t upper_bound(int64_t value) const noexcept
+    {
+        return Base::m_table->upper_bound_int(col_idx, value);
+    }
+};
+
+
+/// Column accessor specialization for float
+template<class Taboid, int col_idx>
+class ColumnAccessor<Taboid, col_idx, float>:
+    public ColumnAccessorBase<Taboid, col_idx, float>, public ColumnsForTaboid<Taboid, float>::type {
+private:
+    using Base = ColumnAccessorBase<Taboid, col_idx, float>;
+    using ColumnsBase = typename ColumnsForTaboid<Taboid, float>::type;
+
+public:
+    explicit ColumnAccessor(Taboid* t) noexcept: Base(t), ColumnsBase(col_idx, t->get_impl())
+    {
+    }
+
+    size_t find_first(float value) const
+    {
+        return Base::m_table->get_impl()->find_first_float(col_idx, value);
+    }
+
+    BasicTableView<typename Base::RealTable> find_all(float value) const
+    {
+        return Base::m_table->get_impl()->find_all_float(col_idx, value);
+    }
+
+    BasicTableView<typename Base::RealTable> get_distinct_view() const
+    {
+        return Base::m_table->get_impl()->get_distinct_view(col_idx);
+    }
+
+    size_t count(float target) const
+    {
+        return Base::m_table->get_impl()->count_float(col_idx, target);
+    }
+
+    double sum() const
+    {
+        return Base::m_table->get_impl()->sum_float(col_idx);
+    }
+
+    float maximum(size_t* return_ndx = nullptr) const
+    {
+        return Base::m_table->get_impl()->maximum_float(col_idx, return_ndx);
+    }
+
+    float minimum(size_t* return_ndx = nullptr) const
+    {
+        return Base::m_table->get_impl()->minimum_float(col_idx, return_ndx);
+    }
+
+    double average() const
+    {
+        return Base::m_table->get_impl()->average_float(col_idx);
+    }
+
+    const ColumnAccessor& operator+=(float value) const
+    {
+        Base::m_table->get_impl()->add_float(col_idx, value);
+        return *this;
+    }
+
+    size_t lower_bound(float value) const noexcept
+    {
+        return Base::m_table->lower_bound_float(col_idx, value);
+    }
+
+    size_t upper_bound(float value) const noexcept
+    {
+        return Base::m_table->upper_bound_float(col_idx, value);
+    }
+};
+
+
+/// Column accessor specialization for double
+template<class Taboid, int col_idx>
+class ColumnAccessor<Taboid, col_idx, double>:
+    public ColumnAccessorBase<Taboid, col_idx, double>, public ColumnsForTaboid<Taboid, double>::type {
+private:
+    using Base = ColumnAccessorBase<Taboid, col_idx, double>;
+    using ColumnsBase = typename ColumnsForTaboid<Taboid, double>::type;
+
+public:
+    explicit ColumnAccessor(Taboid* t) noexcept: Base(t), ColumnsBase(col_idx, t->get_impl())
+    {
+    }
+
+    size_t find_first(double value) const
+    {
+        return Base::m_table->get_impl()->find_first_double(col_idx, value);
+    }
+
+    BasicTableView<typename Base::RealTable> find_all(double value) const
+    {
+        return Base::m_table->get_impl()->find_all_double(col_idx, value);
+    }
+
+    BasicTableView<typename Base::RealTable> get_distinct_view() const
+    {
+        return Base::m_table->get_impl()->get_distinct_view(col_idx);
+    }
+
+    size_t count(double target) const
+    {
+        return Base::m_table->get_impl()->count_double(col_idx, target);
+    }
+
+    double sum() const
+    {
+        return Base::m_table->get_impl()->sum_double(col_idx);
+    }
+
+    double maximum(size_t* return_ndx = nullptr) const
+    {
+        return Base::m_table->get_impl()->maximum_double(col_idx, return_ndx);
+    }
+
+    double minimum(size_t* return_ndx = nullptr) const
+    {
+        return Base::m_table->get_impl()->minimum_double(col_idx, return_ndx);
+    }
+
+    double average() const
+    {
+        return Base::m_table->get_impl()->average_double(col_idx);
+    }
+
+    const ColumnAccessor& operator+=(double value) const
+    {
+        Base::m_table->get_impl()->add_double(col_idx, value);
+        return *this;
+    }
+
+    size_t lower_bound(float value) const noexcept
+    {
+        return Base::m_table->lower_bound_double(col_idx, value);
+    }
+
+    size_t upper_bound(float value) const noexcept
+    {
+        return Base::m_table->upper_bound_double(col_idx, value);
+    }
+};
+
+
+/// Column accessor specialization for booleans.
+template<class Taboid, int col_idx>
+class ColumnAccessor<Taboid, col_idx, bool>: public ColumnAccessorBase<Taboid, col_idx, bool> {
+private:
+    typedef ColumnAccessorBase<Taboid, col_idx, bool> Base;
+
+public:
+    explicit ColumnAccessor(Taboid* t) noexcept: Base(t) {}
+
+    size_t find_first(bool value) const
+    {
+        return Base::m_table->get_impl()->find_first_bool(col_idx, value);
+    }
+
+    BasicTableView<typename Base::RealTable> find_all(bool value) const
+    {
+        return Base::m_table->get_impl()->find_all_bool(col_idx, value);
+    }
+
+    size_t lower_bound(bool value) const noexcept
+    {
+        return Base::m_table->lower_bound_bool(col_idx, value);
+    }
+
+    size_t upper_bound(bool value) const noexcept
+    {
+        return Base::m_table->upper_bound_bool(col_idx, value);
+    }
+
+    BasicTableView<typename Base::RealTable> get_distinct_view() const
+    {
+        return Base::m_table->get_impl()->get_distinct_view(col_idx);
+    }
+};
+
+
+/// Column accessor specialization for enumerations.
+template<class Taboid, int col_idx, class E>
+class ColumnAccessor<Taboid, col_idx, SpecBase::Enum<E>>:
+    public ColumnAccessorBase<Taboid, col_idx, SpecBase::Enum<E>> {
+private:
+    typedef ColumnAccessorBase<Taboid, col_idx, SpecBase::Enum<E>> Base;
+
+public:
+    explicit ColumnAccessor(Taboid* t) noexcept: Base(t) {}
+
+    size_t find_first(E value) const
+    {
+        return Base::m_table->get_impl()->find_first_int(col_idx, int64_t(value));
+    }
+
+    BasicTableView<typename Base::RealTable> find_all(E value) const
+    {
+        return Base::m_table->get_impl()->find_all_int(col_idx, int64_t(value));
+    }
+
+    BasicTableView<typename Base::RealTable> get_distinct_view() const
+    {
+        return Base::m_table->get_impl()->get_distinct_view(col_idx);
+    }
+};
+
+
+/// Column accessor specialization for dates.
+template<class Taboid, int col_idx>
+class ColumnAccessor<Taboid, col_idx, OldDateTime>: public ColumnAccessorBase<Taboid, col_idx, OldDateTime> {
+private:
+    typedef ColumnAccessorBase<Taboid, col_idx, OldDateTime> Base;
+
+public:
+    explicit ColumnAccessor(Taboid* t) noexcept: Base(t) {}
+
+    OldDateTime maximum(size_t* return_ndx = nullptr) const
+    {
+        return Base::m_table->get_impl()->maximum_olddatetime(col_idx, return_ndx);
+    }
+
+    OldDateTime minimum(size_t* return_ndx = nullptr) const
+    {
+        return Base::m_table->get_impl()->minimum_olddatetime(col_idx, return_ndx);
+    }
+
+    size_t find_first(OldDateTime value) const
+    {
+        return Base::m_table->get_impl()->find_first_olddatetime(col_idx, value);
+    }
+
+    BasicTableView<typename Base::RealTable> find_all(OldDateTime value) const
+    {
+        return Base::m_table->get_impl()->find_all_olddatetime(col_idx, value);
+    }
+
+    BasicTableView<typename Base::RealTable> get_distinct_view() const
+    {
+        return Base::m_table->get_impl()->get_distinct_view(col_idx);
+    }
+};
+
+
+/// Column accessor specialization for strings.
+template<class Taboid, int col_idx>
+class ColumnAccessor<Taboid, col_idx, StringData>:
+    public ColumnAccessorBase<Taboid, col_idx, StringData>, public ColumnsForTaboid<Taboid, StringData>::type {
+private:
+    using Base = ColumnAccessorBase<Taboid, col_idx, StringData>;
+    using ColumnsBase = typename ColumnsForTaboid<Taboid, StringData>::type;
+public:
+    explicit ColumnAccessor(Taboid* t) noexcept: Base(t), ColumnsBase(col_idx, t->get_impl())
+    {
+    }
+
+    size_t count(StringData value) const
+    {
+        return Base::m_table->get_impl()->count_string(col_idx, value);
+    }
+
+    size_t find_first(StringData value) const
+    {
+        return Base::m_table->get_impl()->find_first_string(col_idx, value);
+    }
+
+    BasicTableView<typename Base::RealTable> find_all(StringData value) const
+    {
+        return Base::m_table->get_impl()->find_all_string(col_idx, value);
+    }
+
+    BasicTableView<typename Base::RealTable> get_distinct_view() const
+    {
+        return Base::m_table->get_impl()->get_distinct_view(col_idx);
+    }
+
+    size_t lower_bound(StringData value) const noexcept
+    {
+        return Base::m_table->lower_bound_string(col_idx, value);
+    }
+
+    size_t upper_bound(StringData value) const noexcept
+    {
+        return Base::m_table->upper_bound_string(col_idx, value);
+    }
+};
+
+
+/// Column accessor specialization for binary data.
+template<class Taboid, int col_idx>
+class ColumnAccessor<Taboid, col_idx, BinaryData>:
+    public ColumnAccessorBase<Taboid, col_idx, BinaryData> {
+private:
+    typedef ColumnAccessorBase<Taboid, col_idx, BinaryData> Base;
+
+public:
+    explicit ColumnAccessor(Taboid* t) noexcept: Base(t) {}
+
+    size_t find_first(const BinaryData &value) const
+    {
+        return Base::m_table->get_impl()->find_first_binary(col_idx, value.data(), value.size());
+    }
+
+    BasicTableView<typename Base::RealTable> find_all(const BinaryData &value) const
+    {
+        return Base::m_table->get_impl()->find_all_binary(col_idx, value.data(), value.size());
+    }
+};
+
+
+/// Column accessor specialization for subtables.
+template<class Taboid, int col_idx, class Subtab>
+class ColumnAccessor<Taboid, col_idx, SpecBase::Subtable<Subtab>>:
+    public ColumnAccessorBase<Taboid, col_idx, SpecBase::Subtable<Subtab>> {
+private:
+    typedef ColumnAccessorBase<Taboid, col_idx, SpecBase::Subtable<Subtab>> Base;
+
+public:
+    explicit ColumnAccessor(Taboid* t) noexcept: Base(t) {}
+};
+
+
+/// Column accessor specialization for mixed type.
+template<class Taboid, int col_idx>
+class ColumnAccessor<Taboid, col_idx, Mixed>: public ColumnAccessorBase<Taboid, col_idx, Mixed> {
+private:
+    typedef ColumnAccessorBase<Taboid, col_idx, Mixed> Base;
+
+public:
+    explicit ColumnAccessor(Taboid* t) noexcept: Base(t) {}
+};
+
+
+
+/// ***********************************************************************************************
+/// This class implements a column of a table as used in a table query.
+///
+/// \tparam Taboid Matches either 'BasicTable<Spec>' or
+/// 'BasicTableView<Tab>'. Neither may be const-qualified.
+///
+/// FIXME: These do not belong in this file!
+template<class Taboid, int col_idx, class Type>
+class QueryColumn;
+
+
+/// Commmon base class for all query column specializations.
+template<class Taboid, int col_idx, class Type>
+class QueryColumnBase {
+protected:
+    typedef typename Taboid::Query Query;
+    Query* const m_query;
+    explicit QueryColumnBase(Query* q) noexcept: m_query(q) {}
+
+    Query& equal(const Type& value) const
+    {
+        m_query->m_impl.equal(col_idx, value);
+        return *m_query;
+    }
+
+    Query& not_equal(const Type& value) const
+    {
+        m_query->m_impl.not_equal(col_idx, value);
+        return *m_query;
+    }
+};
+
+
+/// QueryColumn specialization for integers.
+template<class Taboid, int col_idx>
+class QueryColumn<Taboid, col_idx, int64_t>: public QueryColumnBase<Taboid, col_idx, int64_t> {
+private:
+    typedef QueryColumnBase<Taboid, col_idx, int64_t> Base;
+    typedef typename Taboid::Query Query;
+
+public:
+    explicit QueryColumn(Query* q) noexcept: Base(q) {}
+
+    // Todo, these do not turn up in Visual Studio 2013 intellisense
+    using Base::equal;
+    using Base::not_equal;
+
+    Query& greater(int64_t value) const
+    {
+        Base::m_query->m_impl.greater(col_idx, value);
+        return *Base::m_query;
+    }
+
+    Query& greater_equal(int64_t value) const
+    {
+        Base::m_query->m_impl.greater_equal(col_idx, value);
+        return *Base::m_query;
+    }
+
+    Query& less(int64_t value) const
+    {
+        Base::m_query->m_impl.less(col_idx, value);
+        return *Base::m_query;
+    }
+
+    Query& less_equal(int64_t value) const
+    {
+        Base::m_query->m_impl.less_equal(col_idx, value);
+        return *Base::m_query;
+    }
+
+    Query& between(int64_t from, int64_t to) const
+    {
+        Base::m_query->m_impl.between(col_idx, from, to);
+        return *Base::m_query;
+    }
+
+    int64_t sum(size_t* resultcount = nullptr, size_t start = 0,
+                size_t end = size_t(-1), size_t limit=size_t(-1)) const
+    {
+        return Base::m_query->m_impl.sum_int(col_idx, resultcount, start, end, limit);
+    }
+
+    int64_t maximum(size_t* resultcount = nullptr, size_t start = 0,
+                    size_t end = size_t(-1), size_t limit=size_t(-1),
+                    size_t* return_ndx = nullptr) const
+    {
+        return Base::m_query->m_impl.maximum_int(col_idx, resultcount, start, end, limit, return_ndx);
+    }
+
+    int64_t minimum(size_t* resultcount = nullptr, size_t start = 0,
+                    size_t end = size_t(-1), size_t limit=size_t(-1),
+                    size_t* return_ndx = nullptr) const
+    {
+        return Base::m_query->m_impl.minimum_int(col_idx, resultcount, start, end, limit, return_ndx);
+    }
+
+    double average(size_t* resultcount = nullptr, size_t start = 0,
+                   size_t end=size_t(-1), size_t limit=size_t(-1)) const
+    {
+        return Base::m_query->m_impl.average_int(col_idx, resultcount, start, end, limit);
+    }
+};
+
+
+
+/// QueryColumn specialization for floats.
+template<class Taboid, int col_idx>
+class QueryColumn<Taboid, col_idx, float>: public QueryColumnBase<Taboid, col_idx, float> {
+private:
+    typedef QueryColumnBase<Taboid, col_idx, float> Base;
+    typedef typename Taboid::Query Query;
+
+public:
+    explicit QueryColumn(Query* q) noexcept: Base(q) {}
+    using Base::equal;
+    using Base::not_equal;
+
+    Query& greater(float value) const
+    {
+        Base::m_query->m_impl.greater(col_idx, value);
+        return *Base::m_query;
+    }
+
+    Query& greater_equal(float value) const
+    {
+        Base::m_query->m_impl.greater_equal(col_idx, value);
+        return *Base::m_query;
+    }
+
+    Query& less(float value) const
+    {
+        Base::m_query->m_impl.less(col_idx, value);
+        return *Base::m_query;
+    }
+
+    Query& less_equal(float value) const
+    {
+        Base::m_query->m_impl.less_equal(col_idx, value);
+        return *Base::m_query;
+    }
+
+    Query& between(float from, float to) const
+    {
+        Base::m_query->m_impl.between(col_idx, from, to);
+        return *Base::m_query;
+    }
+
+    double sum(size_t* resultcount = nullptr, size_t start = 0,
+               size_t end = size_t(-1), size_t limit=size_t(-1)) const
+    {
+        return Base::m_query->m_impl.sum_float(col_idx, resultcount, start, end, limit);
+    }
+
+    float maximum(size_t* resultcount = nullptr, size_t start = 0,
+                    size_t end = size_t(-1), size_t limit=size_t(-1),
+                    size_t* return_ndx = nullptr) const
+    {
+        return Base::m_query->m_impl.maximum_float(col_idx, resultcount, start, end, limit, return_ndx);
+    }
+
+    float minimum(size_t* resultcount = nullptr, size_t start = 0,
+                    size_t end = size_t(-1), size_t limit=size_t(-1),
+                    size_t* return_ndx = nullptr) const
+    {
+        return Base::m_query->m_impl.minimum_float(col_idx, resultcount, start, end, limit, return_ndx);
+    }
+
+    double average(size_t* resultcount = nullptr, size_t start = 0,
+                   size_t end=size_t(-1), size_t limit=size_t(-1)) const
+    {
+        return Base::m_query->m_impl.average_float(col_idx, resultcount, start, end, limit);
+    }
+};
+
+
+
+/// QueryColumn specialization for doubles.
+template<class Taboid, int col_idx>
+class QueryColumn<Taboid, col_idx, double>: public QueryColumnBase<Taboid, col_idx, double> {
+private:
+    typedef QueryColumnBase<Taboid, col_idx, double> Base;
+    typedef typename Taboid::Query Query;
+
+public:
+    explicit QueryColumn(Query* q) noexcept: Base(q) {}
+    using Base::equal;
+    using Base::not_equal;
+
+    Query& greater(double value) const
+    {
+        Base::m_query->m_impl.greater(col_idx, value);
+        return *Base::m_query;
+    }
+
+    Query& greater_equal(double value) const
+    {
+        Base::m_query->m_impl.greater_equal(col_idx, value);
+        return *Base::m_query;
+    }
+
+    Query& less(double value) const
+    {
+        Base::m_query->m_impl.less(col_idx, value);
+        return *Base::m_query;
+    }
+
+    Query& less_equal(double value) const
+    {
+        Base::m_query->m_impl.less_equal(col_idx, value);
+        return *Base::m_query;
+    }
+
+    Query& between(double from, double to) const
+    {
+        Base::m_query->m_impl.between(col_idx, from, to);
+        return *Base::m_query;
+    }
+
+    double sum(size_t* resultcount = nullptr, size_t start = 0,
+               size_t end = size_t(-1), size_t limit=size_t(-1)) const
+    {
+        return Base::m_query->m_impl.sum_double(col_idx, resultcount, start, end, limit);
+    }
+
+    double maximum(size_t* resultcount = nullptr, size_t start = 0,
+                    size_t end = size_t(-1), size_t limit=size_t(-1),
+                    size_t* return_ndx = nullptr) const
+    {
+        return Base::m_query->m_impl.maximum_double(col_idx, resultcount, start, end, limit, return_ndx);
+    }
+
+    double minimum(size_t* resultcount = nullptr, size_t start = 0,
+                    size_t end = size_t(-1), size_t limit=size_t(-1),
+                    size_t* return_ndx = nullptr) const
+    {
+        return Base::m_query->m_impl.minimum_double(col_idx, resultcount, start, end, limit, return_ndx);
+    }
+
+    double average(size_t* resultcount = nullptr, size_t start = 0,
+                   size_t end=size_t(-1), size_t limit=size_t(-1)) const
+    {
+        return Base::m_query->m_impl.average_double(col_idx, resultcount, start, end, limit);
+    }
+};
+
+
+
+/// QueryColumn specialization for booleans.
+template<class Taboid, int col_idx>
+class QueryColumn<Taboid, col_idx, bool>: public QueryColumnBase<Taboid, col_idx, bool> {
+private:
+    typedef QueryColumnBase<Taboid, col_idx, bool> Base;
+    typedef typename Taboid::Query Query;
+
+public:
+    explicit QueryColumn(Query* q) noexcept: Base(q) {}
+    using Base::equal;
+    using Base::not_equal;
+};
+
+
+/// QueryColumn specialization for enumerations.
+template<class Taboid, int col_idx, class E>
+class QueryColumn<Taboid, col_idx, SpecBase::Enum<E>>:
+    public QueryColumnBase<Taboid, col_idx, SpecBase::Enum<E>> {
+private:
+    typedef QueryColumnBase<Taboid, col_idx, SpecBase::Enum<E>> Base;
+    typedef typename Taboid::Query Query;
+
+public:
+    explicit QueryColumn(Query* q) noexcept: Base(q) {}
+    using Base::equal;
+    using Base::not_equal;
+};
+
+
+/// QueryColumn specialization for dates.
+template<class Taboid, int col_idx>
+class QueryColumn<Taboid, col_idx, OldDateTime>: public QueryColumnBase<Taboid, col_idx, OldDateTime> {
+private:
+    typedef QueryColumnBase<Taboid, col_idx, OldDateTime> Base;
+    typedef typename Taboid::Query Query;
+
+public:
+    explicit QueryColumn(Query* q) noexcept: Base(q) {}
+
+    Query& equal(OldDateTime value) const
+    {
+        Base::m_query->m_impl.equal_olddatetime(col_idx, value);
+        return *Base::m_query;
+    }
+
+    Query& not_equal(OldDateTime value) const
+    {
+        Base::m_query->m_impl.not_equal_olddatetime(col_idx, value);
+        return *Base::m_query;
+    }
+
+    Query& greater(OldDateTime value) const
+    {
+        Base::m_query->m_impl.greater_olddatetime(col_idx, value);
+        return *Base::m_query;
+    }
+
+    Query& greater_equal(OldDateTime value) const
+    {
+        Base::m_query->m_impl.greater_equal_olddatetime(col_idx, value);
+        return *Base::m_query;
+    }
+
+    Query& less(OldDateTime value) const
+    {
+        Base::m_query->m_impl.less_olddatetime(col_idx, value);
+        return *Base::m_query;
+    }
+
+    Query& less_equal(OldDateTime value) const
+    {
+        Base::m_query->m_impl.less_equal_olddatetime(col_idx, value);
+        return *Base::m_query;
+    }
+
+    Query& between(OldDateTime from, OldDateTime to) const
+    {
+        Base::m_query->m_impl.between_olddatetime(col_idx, from, to);
+        return *Base::m_query;
+    }
+
+    OldDateTime maximum(size_t* resultcount = nullptr, size_t start = 0,
+                 size_t end = size_t(-1), size_t limit=size_t(-1),
+                 size_t* return_ndx = nullptr) const
+    {
+        return Base::m_query->m_impl.maximum_olddatetime(col_idx, resultcount, start, end, limit, return_ndx);
+    }
+
+    OldDateTime minimum(size_t* resultcount = nullptr, size_t start = 0,
+                 size_t end = size_t(-1), size_t limit=size_t(-1),
+                 size_t* return_ndx = nullptr) const
+    {
+        return Base::m_query->m_impl.minimum_olddatetime(col_idx, resultcount, start, end, limit, return_ndx);
+    }
+};
+
+
+/// QueryColumn specialization for strings.
+template<class Taboid, int col_idx>
+class QueryColumn<Taboid, col_idx, StringData>:
+    public QueryColumnBase<Taboid, col_idx, StringData> {
+private:
+    typedef QueryColumnBase<Taboid, col_idx, StringData> Base;
+    typedef typename Taboid::Query Query;
+
+public:
+    explicit QueryColumn(Query* q) noexcept: Base(q) {}
+
+    Query& equal(StringData value, bool case_sensitive=true) const
+    {
+        Base::m_query->m_impl.equal(col_idx, value, case_sensitive);
+        return *Base::m_query;
+    }
+
+    Query& not_equal(StringData value, bool case_sensitive=true) const
+    {
+        Base::m_query->m_impl.not_equal(col_idx, value, case_sensitive);
+        return *Base::m_query;
+    }
+
+    Query& begins_with(StringData value, bool case_sensitive=true) const
+    {
+        Base::m_query->m_impl.begins_with(col_idx, value, case_sensitive);
+        return *Base::m_query;
+    }
+
+    Query& ends_with(StringData value, bool case_sensitive=true) const
+    {
+        Base::m_query->m_impl.ends_with(col_idx, value, case_sensitive);
+        return *Base::m_query;
+    }
+
+    Query& contains(StringData value, bool case_sensitive=true) const
+    {
+        Base::m_query->m_impl.contains(col_idx, value, case_sensitive);
+        return *Base::m_query;
+    }
+};
+
+
+/// QueryColumn specialization for binary data.
+template<class Taboid, int col_idx>
+class QueryColumn<Taboid, col_idx, BinaryData>:
+    public QueryColumnBase<Taboid, col_idx, BinaryData> {
+private:
+    typedef QueryColumnBase<Taboid, col_idx, BinaryData> Base;
+    typedef typename Taboid::Query Query;
+
+public:
+    explicit QueryColumn(Query* q) noexcept: Base(q) {}
+
+    Query& equal(BinaryData value) const
+    {
+        Base::m_query->m_impl.equal(col_idx, value);
+        return *Base::m_query;
+    }
+
+    Query& not_equal(BinaryData value) const
+    {
+        Base::m_query->m_impl.not_equal(col_idx, value);
+        return *Base::m_query;
+    }
+
+    Query& begins_with(BinaryData value) const
+    {
+        Base::m_query->m_impl.begins_with(col_idx, value);
+        return *Base::m_query;
+    }
+
+    Query& ends_with(BinaryData value) const
+    {
+        Base::m_query->m_impl.ends_with(col_idx, value);
+        return *Base::m_query;
+    }
+
+    Query& contains(BinaryData value) const
+    {
+        Base::m_query->m_impl.contains(col_idx, value);
+        return *Base::m_query;
+    }
+};
+
+
+/// QueryColumn specialization for subtables.
+template<class Taboid, int col_idx, class Subtab>
+class QueryColumn<Taboid, col_idx, SpecBase::Subtable<Subtab>> {
+private:
+    typedef typename Taboid::Query Query;
+    Query* const m_query;
+
+public:
+    explicit QueryColumn(Query* q) noexcept: m_query(q) {}
+
+    Query& subtable()
+    {
+        m_query->m_impl.subtable(col_idx);
+        return *m_query;
+    }
+};
+
+
+/// QueryColumn specialization for mixed type.
+template<class Taboid, int col_idx>
+class QueryColumn<Taboid, col_idx, Mixed> {
+private:
+    typedef typename Taboid::Query Query;
+
+public:
+    explicit QueryColumn(Query*) noexcept {}
+};
+
+
+} // namespace _impl
+} // namespaced realm
+
+#endif // REALM_TABLE_ACCESSORS_HPP
diff --git a/Pods/Realm/include/core/realm/table_basic.hpp b/Pods/Realm/include/core/realm/table_basic.hpp
new file mode 100644
index 0000000..3a81aaf
--- /dev/null
+++ b/Pods/Realm/include/core/realm/table_basic.hpp
@@ -0,0 +1,749 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_TABLE_BASIC_HPP
+#define REALM_TABLE_BASIC_HPP
+
+#include <stdint.h> // unint8_t etc
+#include <cstddef>
+#include <utility>
+
+#include <realm/util/meta.hpp>
+#include <realm/util/tuple.hpp>
+#include <realm/table.hpp>
+#include <realm/descriptor.hpp>
+#include <realm/query.hpp>
+#include <realm/table_accessors.hpp>
+#include <realm/table_view_basic.hpp>
+
+namespace realm {
+
+
+namespace _impl {
+
+template<class Type, int col_idx>
+struct AddCol;
+template<class Type, int col_idx>
+struct CmpColType;
+template<class Type, int col_idx>
+struct AssignIntoCol;
+
+} // namespace _impl
+
+
+
+/// This class is non-polymorphic, that is, it has no virtual
+/// functions. Further more, it has no destructor, and it adds no new
+/// data-members. These properties are important, because it ensures
+/// that there is no run-time distinction between a Table instance and
+/// an instance of any variation of this class, and therefore it is
+/// valid to cast a pointer from Table to BasicTable<Spec> even when
+/// the instance is constructed as a Table. Of couse, this also
+/// assumes that Table is non-polymorphic. Further more, accessing the
+/// Table via a pointer or reference to a BasicTable is not in
+/// violation of the strict aliasing rule.
+template<class Spec>
+class BasicTable: private Table, public Spec::ConvenienceMethods {
+public:
+    typedef Spec spec_type;
+    typedef typename Spec::Columns Columns;
+
+    typedef BasicTableRef<BasicTable> Ref;
+    typedef BasicTableRef<const BasicTable> ConstRef;
+
+    typedef BasicTableView<BasicTable> View;
+    typedef BasicTableView<const BasicTable> ConstView;
+
+    using Table::is_attached;
+    using Table::has_shared_type;
+    using Table::is_empty;
+    using Table::size;
+    using Table::clear;
+    using Table::remove;
+    using Table::remove_last;
+    using Table::move_last_over;
+    using Table::optimize;
+    using Table::add_empty_row;
+    using Table::insert_empty_row;
+    using Table::aggregate;
+
+    using Table::get_backlink_count;
+    using Table::get_backlink;
+
+    using Table::is_group_level;
+    using Table::get_index_in_group;
+
+    BasicTable(Allocator& alloc = Allocator::get_default()): Table(alloc)
+    {
+        set_dynamic_type(*this);
+    }
+
+    BasicTable(const BasicTable& t, Allocator& alloc = Allocator::get_default()): Table(t, alloc) {}
+
+    ~BasicTable() noexcept {}
+
+    static Ref create(Allocator& = Allocator::get_default());
+
+    Ref copy(Allocator& = Allocator::get_default()) const;
+
+    static int get_column_count() noexcept
+    {
+        return util::TypeCount<typename Spec::Columns>::value;
+    }
+
+    Ref get_table_ref() { return Ref(this); }
+
+    ConstRef get_table_ref() const { return ConstRef(this); }
+
+private:
+    template<int col_idx>
+    struct Col {
+        typedef typename util::TypeAt<typename Spec::Columns, col_idx>::type value_type;
+        typedef _impl::ColumnAccessor<BasicTable, col_idx, value_type> type;
+    };
+    typedef typename Spec::template ColNames<Col, BasicTable*> ColsAccessor;
+
+    template<int col_idx>
+    struct ConstCol {
+        typedef typename util::TypeAt<typename Spec::Columns, col_idx>::type value_type;
+        typedef _impl::ColumnAccessor<const BasicTable, col_idx, value_type> type;
+    };
+    typedef typename Spec::template ColNames<ConstCol, const BasicTable*> ConstColsAccessor;
+
+public:
+    ColsAccessor column() noexcept { return ColsAccessor(this); }
+    ConstColsAccessor column() const noexcept { return ConstColsAccessor(this); }
+
+private:
+    template<int col_idx>
+    struct Field {
+        typedef typename util::TypeAt<typename Spec::Columns, col_idx>::type value_type;
+        typedef _impl::FieldAccessor<BasicTable, col_idx, value_type, false> type;
+    };
+    typedef std::pair<BasicTable*, size_t> FieldInit;
+
+    template<int col_idx>
+    struct ConstField {
+        typedef typename util::TypeAt<typename Spec::Columns, col_idx>::type value_type;
+        typedef _impl::FieldAccessor<const BasicTable, col_idx, value_type, true> type;
+    };
+    typedef std::pair<const BasicTable*, size_t> ConstFieldInit;
+
+public:
+    typedef typename Spec::template ColNames<Field, FieldInit> RowAccessor;
+    typedef typename Spec::template ColNames<ConstField, ConstFieldInit> ConstRowAccessor;
+
+    RowAccessor operator[](size_t row_idx) noexcept
+    {
+        return RowAccessor(std::make_pair(this, row_idx));
+    }
+
+    ConstRowAccessor operator[](size_t row_idx) const noexcept
+    {
+        return ConstRowAccessor(std::make_pair(this, row_idx));
+    }
+
+    RowAccessor front() noexcept
+    {
+        return RowAccessor(std::make_pair(this, 0));
+    }
+
+    ConstRowAccessor front() const noexcept
+    {
+        return ConstRowAccessor(std::make_pair(this, 0));
+    }
+
+    /// Access the last row, or one of its predecessors.
+    ///
+    /// \param rel_idx An optional index of the row specified relative
+    /// to the end. Thus, <tt>table.back(rel_idx)</tt> is the same as
+    /// <tt>table[table.size() + rel_idx]</tt>.
+    ///
+    RowAccessor back(int rel_idx = -1) noexcept
+    {
+        return RowAccessor(std::make_pair(this, size()+rel_idx));
+    }
+
+    ConstRowAccessor back(int rel_idx = -1) const noexcept
+    {
+        return ConstRowAccessor(std::make_pair(this, size()+rel_idx));
+    }
+
+    RowAccessor add() { return RowAccessor(std::make_pair(this, add_empty_row())); }
+
+    template<class L>
+    void add(const util::Tuple<L>& tuple)
+    {
+        size_t i = size();
+        insert(i, tuple);
+    }
+
+    void insert(size_t i) { insert_empty_row(i); }
+
+    template<class L>
+    void insert(size_t i, const util::Tuple<L>& tuple)
+    {
+        insert(i);
+        set(i, tuple);
+    }
+
+    template<class L>
+    void set(size_t i, const util::Tuple<L>& tuple)
+    {
+        using namespace realm::util;
+        static_assert(TypeCount<L>::value == TypeCount<Columns>::value,
+                      "Wrong number of tuple elements");
+        ForEachType<Columns, _impl::AssignIntoCol>::exec(static_cast<Table*>(this), i, tuple);
+    }
+
+    // FIXME: This probably fails if Spec::ConvenienceMethods has no add().
+    using Spec::ConvenienceMethods::add;
+    // FIXME: This probably fails if Spec::ConvenienceMethods has no insert().
+    using Spec::ConvenienceMethods::insert;
+    // FIXME: This probably fails if Spec::ConvenienceMethods has no set().
+    using Spec::ConvenienceMethods::set;
+
+    // FIXME: A cursor must be a distinct class that can be constructed from a RowAccessor
+    typedef RowAccessor Cursor;
+    typedef ConstRowAccessor ConstCursor;
+
+
+    class Query;
+    Query       where(typename BasicTable<Spec>::View* tv = nullptr) { return Query(*this, tv ? tv->get_impl() : nullptr); }
+    Query where(typename BasicTable<Spec>::View* tv = nullptr) const { return Query(*this, tv ? tv->get_impl() : nullptr); }
+
+    /// Compare two tables for equality. Two tables are equal if, and
+    /// only if, they contain the same rows in the same order, that
+    /// is, for each value V at column index C and row index R in one
+    /// of the tables, there is a value at column index C and row
+    /// index R in the other table that is equal to V.
+    bool operator==(const BasicTable& t) const { return compare_rows(t); }
+
+    /// Compare two tables for inequality. See operator==().
+    bool operator!=(const BasicTable& t) const { return !compare_rows(t); }
+
+    /// Checks whether the dynamic type of the specified table matches
+    /// the statically specified table type. The two types (or specs)
+    /// must have the same columns, and in the same order. Two columns
+    /// are considered equal if, and only if they have the same name
+    /// and the same type. The type is understood as the value encoded
+    /// by the DataType enumeration. This check proceeds recursively
+    /// for subtable columns.
+    ///
+    /// \tparam T The static table type. It makes no difference
+    /// whether it is const-qualified or not.
+    ///
+    /// FIXME: Consider dropping the requirement that column names
+    /// must be equal. There does not seem to be any value for the
+    /// user in that requirement. Further more, there may be cases
+    /// where it is desirable to be able to cast to a table type with
+    /// different column names. Similar changes are needed in the Java
+    /// and Objective-C language bindings.
+    template<class T>
+    friend bool is_a(const Table&) noexcept;
+
+    //@{
+    /// These functions return null if the specified table is not
+    /// compatible with the specified table type.
+    template<class T>
+    friend BasicTableRef<T> checked_cast(TableRef) noexcept;
+
+    template<class T>
+    friend BasicTableRef<const T> checked_cast(ConstTableRef) noexcept;
+    //@}
+
+    using Table::verify;
+
+#ifdef REALM_DEBUG
+    using Table::print;
+    using Table::dump_node_structure;
+#endif
+
+private:
+    template<int col_idx>
+    struct QueryCol {
+        typedef typename util::TypeAt<typename Spec::Columns, col_idx>::type value_type;
+        typedef _impl::QueryColumn<BasicTable, col_idx, value_type> type;
+    };
+
+    // These are intende to be used only by accessor classes
+    Table* get_impl() noexcept { return this; }
+    const Table* get_impl() const noexcept { return this; }
+
+    template<class Subtab>
+    Subtab* get_subtable_ptr(size_t col_idx, size_t row_idx)
+    {
+        return static_cast<Subtab*>(Table::get_subtable_ptr(col_idx, row_idx));
+    }
+
+    template<class Subtab>
+    const Subtab* get_subtable_ptr(size_t col_idx, size_t row_idx) const
+    {
+        return static_cast<const Subtab*>(Table::get_subtable_ptr(col_idx, row_idx));
+    }
+
+    static void set_dynamic_type(Table& table)
+    {
+        using namespace realm::util;
+        DescriptorRef desc = table.get_descriptor(); // Throws
+        const int num_cols = TypeCount<typename Spec::Columns>::value;
+        StringData dyn_col_names[num_cols];
+        Spec::dyn_col_names(dyn_col_names);
+        ForEachType<typename Spec::Columns, _impl::AddCol>::exec(&*desc, dyn_col_names); // Throws
+    }
+
+    static bool matches_dynamic_type(const realm::Spec& spec) noexcept
+    {
+        using namespace realm::util;
+        const int num_cols = util::TypeCount<typename Spec::Columns>::value;
+        StringData dyn_col_names[num_cols];
+        Spec::dyn_col_names(dyn_col_names);
+        return !HasType<typename Spec::Columns,
+                        _impl::CmpColType>::exec(&spec, dyn_col_names);
+    }
+
+    // This one allows a BasicTable to know that BasicTables with
+    // other Specs are also derived from Table.
+    template<class>
+    friend class BasicTable;
+
+    // This one allows util::bind_ptr to know that all BasicTable template
+    // instantiations are derived from Table.
+    template<class>
+    friend class util::bind_ptr;
+
+    // These allow BasicTableRef to refer to RowAccessor and
+    // ConstRowAccessor.
+    friend class BasicTableRef<BasicTable>;
+    friend class BasicTableRef<const BasicTable>;
+
+    // These allow BasicTableView to call get_subtable_ptr().
+    friend class BasicTableView<BasicTable>;
+    friend class BasicTableView<const BasicTable>;
+
+    template<class, int>
+    friend struct _impl::CmpColType;
+
+    template<class, int, class, bool>
+    friend class _impl::FieldAccessor;
+
+    template<class, int, class>
+    friend class _impl::MixedFieldAccessorBase;
+
+    template<class, int, class>
+    friend class _impl::ColumnAccessorBase;
+
+    template<class, int, class>
+    friend class _impl::ColumnAccessor;
+
+    template<class, int, class>
+    friend class _impl::QueryColumn;
+
+    friend class Group;
+};
+
+
+#ifdef _MSC_VER
+#pragma warning(push)
+#pragma warning(disable: 4355)
+#endif
+
+template<class Spec>
+class BasicTable<Spec>::Query:
+        public Spec::template ColNames<QueryCol, Query*> {
+public:
+    Query(const Query& q): Spec::template ColNames<QueryCol, Query*>(this), m_impl(q.m_impl) {}
+    virtual ~Query() noexcept {}
+
+    Query& group() { m_impl.group(); return *this; }
+
+    Query& end_group() { m_impl.end_group(); return *this; }
+
+    Query& end_subtable() { m_impl.end_subtable(); return *this; }
+
+    Query& Or() { m_impl.Or(); return *this; }
+
+    Query& Not() { m_impl.Not(); return *this; }
+
+    size_t find(size_t begin_at_table_row = 0)
+    {
+        return m_impl.find(begin_at_table_row);
+    }
+
+    typename BasicTable<Spec>::View find_all(size_t start = 0,
+                                             size_t end   = size_t(-1),
+                                             size_t limit = size_t(-1))
+    {
+        return m_impl.find_all(start, end, limit);
+    }
+
+    typename BasicTable<Spec>::ConstView find_all(size_t start = 0,
+                                                  size_t end   = size_t(-1),
+                                                  size_t limit = size_t(-1)) const
+    {
+        return m_impl.find_all(start, end, limit);
+    }
+
+    size_t count(size_t start = 0,
+                      size_t end   = size_t(-1),
+                      size_t limit = size_t(-1)) const
+    {
+        return m_impl.count(start, end, limit);
+    }
+
+    size_t remove(size_t start = 0,
+                       size_t end   = size_t(-1),
+                       size_t limit = size_t(-1))
+    {
+        return m_impl.remove(start, end, limit);
+    }
+
+    std::string validate() { return m_impl.validate(); }
+
+protected:
+    Query(const BasicTable<Spec>& table, TableViewBase* tv):
+        Spec::template ColNames<QueryCol, Query*>(this), m_impl(table, tv) {}
+
+    using HandoverPatch = QueryHandoverPatch;
+    Query(const Query& source, HandoverPatch& patch, ConstSourcePayload mode) :
+        Spec::template ColNames<QueryCol, Query*>(this),
+        m_impl(source.m_impl, patch, mode)
+    {
+    }
+
+    Query(Query& source, HandoverPatch& patch, MutableSourcePayload mode) :
+        Spec::template ColNames<QueryCol, Query*>(this),
+        m_impl(source.m_impl, patch, mode)
+    {
+    }
+
+    void apply_patch(HandoverPatch& patch, Group& dest_group)
+    {
+        m_impl.apply_patch(patch, dest_group);
+    }
+
+    virtual std::unique_ptr<Query>
+    clone_for_handover(std::unique_ptr<HandoverPatch>& patch, ConstSourcePayload mode) const
+    {
+        patch.reset(new HandoverPatch);
+        std::unique_ptr<Query> retval( new Query(*this, *patch, mode));
+        return retval;
+    }
+
+    virtual std::unique_ptr<Query>
+    clone_for_handover(std::unique_ptr<HandoverPatch>& patch, MutableSourcePayload mode)
+    {
+        patch.reset(new HandoverPatch);
+        std::unique_ptr<Query> retval( new Query(*this, *patch, mode));
+        return retval;
+    }
+
+    virtual void apply_and_consume_patch(std::unique_ptr<HandoverPatch>& patch, Group& dest_group)
+    {
+        apply_patch(*patch, dest_group);
+        patch.reset();
+    }
+
+private:
+    realm::Query m_impl;
+
+    friend class BasicTable;
+    friend class SharedGroup;
+
+    template<class, int, class>
+    friend class _impl::QueryColumnBase;
+
+    template<class, int, class>
+    friend class _impl::QueryColumn;
+};
+
+#ifdef _MSC_VER
+#pragma warning(pop)
+#endif
+
+
+
+
+// Implementation:
+
+namespace _impl {
+
+template<class T>
+struct GetColumnTypeId;
+
+template<>
+struct GetColumnTypeId<int64_t>
+{
+    static const DataType id = type_Int;
+};
+template<class E>
+struct GetColumnTypeId<SpecBase::Enum<E>> {
+    static const DataType id = type_Int;
+};
+template<>
+struct GetColumnTypeId<bool>
+{
+    static const DataType id = type_Bool;
+};
+template<>
+struct GetColumnTypeId<float>
+{
+    static const DataType id = type_Float;
+};
+template<>
+struct GetColumnTypeId<double>
+{
+    static const DataType id = type_Double;
+};
+template<>
+struct GetColumnTypeId<StringData>
+{
+    static const DataType id = type_String;
+};
+template<>
+struct GetColumnTypeId<BinaryData>
+{
+    static const DataType id = type_Binary;
+};
+template<>
+struct GetColumnTypeId<OldDateTime>
+{
+    static const DataType id = type_OldDateTime;
+};
+template<>
+struct GetColumnTypeId<Mixed>
+{
+    static const DataType id = type_Mixed;
+};
+template<>
+struct GetColumnTypeId<Timestamp>
+{
+        static const DataType id = type_Timestamp;
+};
+
+template<class Type, int col_idx>
+struct AddCol {
+    static void exec(Descriptor* desc, const StringData* col_names)
+    {
+        REALM_ASSERT(col_idx == desc->get_column_count());
+        desc->add_column(GetColumnTypeId<Type>::id, col_names[col_idx]); // Throws
+    }
+};
+
+// AddCol specialization for subtables
+template<class Subtab, int col_idx>
+struct AddCol<SpecBase::Subtable<Subtab>, col_idx> {
+    static void exec(Descriptor* desc, const StringData* col_names)
+    {
+        REALM_ASSERT(col_idx == desc->get_column_count());
+        DescriptorRef subdesc;
+        desc->add_column(type_Table, col_names[col_idx], &subdesc); // Throws
+        using namespace realm::util;
+        const int num_subcols = TypeCount<typename Subtab::spec_type::Columns>::value;
+        StringData subcol_names[num_subcols];
+        Subtab::spec_type::dyn_col_names(subcol_names);
+        typedef typename Subtab::Columns Subcolumns;
+        ForEachType<Subcolumns, _impl::AddCol>::exec(&*subdesc, subcol_names); // Throws
+    }
+};
+
+
+
+template<class Type, int col_idx>
+struct CmpColType {
+    static bool exec(const Spec* spec, const StringData* col_names)
+    {
+        return GetColumnTypeId<Type>::id != spec->get_public_column_type(col_idx) ||
+            col_names[col_idx] != spec->get_column_name(col_idx);
+    }
+};
+
+// CmpColType specialization for subtables
+template<class Subtab, int col_idx>
+struct CmpColType<SpecBase::Subtable<Subtab>, col_idx> {
+    static bool exec(const Spec* spec, const StringData* col_names)
+    {
+        if (spec->get_column_type(col_idx) != col_type_Table ||
+            col_names[col_idx] != spec->get_column_name(col_idx)) return true;
+        const Spec subspec = const_cast<Spec*>(spec)->get_subtable_spec(col_idx);
+        return !Subtab::matches_dynamic_type(subspec);
+    }
+};
+
+
+// AssignIntoCol specialization for integers
+template<int col_idx>
+struct AssignIntoCol<int64_t, col_idx> {
+    template<class L>
+    static void exec(Table* t, size_t row_idx, util::Tuple<L> tuple)
+    {
+        t->set_int(col_idx, row_idx, util::at<col_idx>(tuple));
+    }
+};
+
+// AssignIntoCol specialization for floats
+template<int col_idx>
+struct AssignIntoCol<float, col_idx> {
+    template<class L>
+    static void exec(Table* t, size_t row_idx, util::Tuple<L> tuple)
+    {
+        t->set_float(col_idx, row_idx, util::at<col_idx>(tuple));
+    }
+};
+
+// AssignIntoCol specialization for doubles
+template<int col_idx>
+struct AssignIntoCol<double, col_idx> {
+    template<class L>
+    static void exec(Table* t, size_t row_idx, util::Tuple<L> tuple)
+    {
+        t->set_double(col_idx, row_idx, util::at<col_idx>(tuple));
+    }
+};
+
+// AssignIntoCol specialization for booleans
+template<int col_idx>
+struct AssignIntoCol<bool, col_idx> {
+    template<class L>
+    static void exec(Table* t, size_t row_idx, util::Tuple<L> tuple)
+    {
+        t->set_bool(col_idx, row_idx, util::at<col_idx>(tuple));
+    }
+};
+
+// AssignIntoCol specialization for strings
+template<int col_idx>
+struct AssignIntoCol<StringData, col_idx> {
+    template<class L>
+    static void exec(Table* t, size_t row_idx, util::Tuple<L> tuple)
+    {
+        t->set_string(col_idx, row_idx, util::at<col_idx>(tuple));
+    }
+};
+
+// AssignIntoCol specialization for enumerations
+template<class E, int col_idx>
+struct AssignIntoCol<SpecBase::Enum<E>, col_idx> {
+    template<class L>
+    static void exec(Table* t, size_t row_idx, util::Tuple<L> tuple)
+    {
+        t->set_enum(col_idx, row_idx, util::at<col_idx>(tuple));
+    }
+};
+
+// AssignIntoCol specialization for dates
+template<int col_idx>
+struct AssignIntoCol<OldDateTime, col_idx> {
+    template<class L>
+    static void exec(Table* t, size_t row_idx, util::Tuple<L> tuple)
+    {
+        t->set_olddatetime(col_idx, row_idx, util::at<col_idx>(tuple));
+    }
+};
+
+// AssignIntoCol specialization for timestamps
+template<int col_idx>
+struct AssignIntoCol<Timestamp, col_idx> {
+    template<class L>
+    static void exec(Table* t, size_t row_idx, util::Tuple<L> tuple)
+    {
+        t->set_timestamp(col_idx, row_idx, util::at<col_idx>(tuple));
+    }
+};
+
+// AssignIntoCol specialization for binary data
+template<int col_idx>
+struct AssignIntoCol<BinaryData, col_idx> {
+    template<class L>
+    static void exec(Table* t, size_t row_idx, util::Tuple<L> tuple)
+    {
+        t->set_binary(col_idx, row_idx, util::at<col_idx>(tuple));
+    }
+};
+
+// AssignIntoCol specialization for subtables
+template<class T, int col_idx>
+struct AssignIntoCol<SpecBase::Subtable<T>, col_idx> {
+    template<class L>
+    static void exec(Table* t, size_t row_idx, util::Tuple<L> tuple)
+    {
+        // FIXME: unsafe reinterpret_cast to private base class
+        auto subtable = reinterpret_cast<const Table*>(static_cast<const T*>(util::at<col_idx>(tuple)));
+        t->set_subtable(col_idx, row_idx, subtable);
+    }
+};
+
+// AssignIntoCol specialization for mixed type
+template<int col_idx>
+struct AssignIntoCol<Mixed, col_idx> {
+    template<class L>
+    static void exec(Table* t, size_t row_idx, util::Tuple<L> tuple)
+    {
+        t->set_mixed(col_idx, row_idx, util::at<col_idx>(tuple));
+    }
+};
+
+} // namespace _impl
+
+
+template<class Spec>
+inline typename BasicTable<Spec>::Ref BasicTable<Spec>::create(Allocator& alloc)
+{
+    TableRef table = Table::create(alloc);
+    set_dynamic_type(*table);
+    return unchecked_cast<BasicTable<Spec>>(std::move(table));
+}
+
+
+template<class Spec>
+inline typename BasicTable<Spec>::Ref BasicTable<Spec>::copy(Allocator& alloc) const
+{
+    return unchecked_cast<BasicTable<Spec>>(Table::copy(alloc));
+}
+
+
+template<class T>
+inline bool is_a(const Table& t) noexcept
+{
+    typedef _impl::TableFriend tf;
+    return T::matches_dynamic_type(tf::get_spec(t));
+}
+
+
+template<class T>
+inline BasicTableRef<T> checked_cast(TableRef t) noexcept
+{
+    if (!is_a<T>(*t))
+        return BasicTableRef<T>(); // Null
+    return unchecked_cast<T>(t);
+}
+
+
+template<class T>
+inline BasicTableRef<const T> checked_cast(ConstTableRef t) noexcept
+{
+    if (!is_a<T>(*t))
+        return BasicTableRef<const T>(); // Null
+    return unchecked_cast<T>(t);
+}
+
+
+} // namespace realm
+
+#endif // REALM_TABLE_BASIC_HPP
diff --git a/Pods/Realm/include/core/realm/table_basic_fwd.hpp b/Pods/Realm/include/core/realm/table_basic_fwd.hpp
new file mode 100644
index 0000000..1f6906f
--- /dev/null
+++ b/Pods/Realm/include/core/realm/table_basic_fwd.hpp
@@ -0,0 +1,39 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_TABLE_BASIC_FWD_HPP
+#define REALM_TABLE_BASIC_FWD_HPP
+
+namespace realm {
+
+
+template<class Spec>
+class BasicTable;
+
+template<class T>
+struct IsBasicTable { static const bool value = false; };
+template<class Spec>
+struct IsBasicTable<BasicTable<Spec>> { static const bool value = true; };
+template<class Spec>
+struct IsBasicTable<const BasicTable<Spec>> { static const bool value = true; };
+
+
+} // namespace realm
+
+#endif // REALM_TABLE_BASIC_FWD_HPP
diff --git a/Pods/Realm/include/core/realm/table_macros.hpp b/Pods/Realm/include/core/realm/table_macros.hpp
new file mode 100644
index 0000000..477982a
--- /dev/null
+++ b/Pods/Realm/include/core/realm/table_macros.hpp
@@ -0,0 +1,937 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ *************************************************************************/
+
+/*************************************************************************
+ *
+ * CAUTION:  DO NOT EDIT THIS FILE -- YOUR CHANGES WILL BE LOST!
+ *
+ * This file is generated by Cheetah from the following template:
+ *
+ *     table_macros.hpp.cheetah
+ *
+ *************************************************************************/
+
+#ifndef REALM_TABLE_MACROS_HPP
+#define REALM_TABLE_MACROS_HPP
+
+#include <realm/table_basic.hpp>
+
+
+#define REALM_TABLE_1(Table, name1, type1) \
+struct Table##Spec: ::realm::SpecBase { \
+    typedef ::realm::util::TypeAppend< void,     type1 >::type Columns; \
+ \
+    template<template<int> class Col, class Init> \
+    struct ColNames { \
+        typename Col<0>::type name1; \
+        ColNames(Init i) noexcept: name1(i) {} \
+    }; \
+ \
+    static void dyn_col_names(realm::StringData* names) noexcept \
+    { \
+        names[0] = realm::StringData(#name1, sizeof #name1 - 1); \
+    } \
+ \
+    struct ConvenienceMethods { \
+        void add(type1 name1) \
+        { \
+            ::realm::BasicTable<Table##Spec>* const _realm_t = \
+                static_cast< ::realm::BasicTable<Table##Spec>* >(this); \
+            _realm_t->add((::realm::util::tuple(), name1)); \
+        } \
+        void insert(size_t _realm_i, type1 name1) \
+        { \
+            ::realm::BasicTable<Table##Spec>* const _realm_t = \
+                static_cast< ::realm::BasicTable<Table##Spec>* >(this); \
+            _realm_t->insert(_realm_i, (::realm::util::tuple(), name1)); \
+        } \
+        void set(size_t _realm_i, type1 name1) \
+        { \
+            ::realm::BasicTable<Table##Spec>* const _realm_t = \
+                static_cast< ::realm::BasicTable<Table##Spec>* >(this); \
+            _realm_t->set(_realm_i, (::realm::util::tuple(), name1)); \
+        } \
+    }; \
+}; \
+typedef ::realm::BasicTable<Table##Spec> Table;
+
+
+#define REALM_TABLE_2(Table, name1, type1, name2, type2) \
+struct Table##Spec: ::realm::SpecBase { \
+    typedef ::realm::util::TypeAppend< void,     type1 >::type Columns1; \
+    typedef ::realm::util::TypeAppend< Columns1, type2 >::type Columns; \
+ \
+    template<template<int> class Col, class Init> \
+    struct ColNames { \
+        typename Col<0>::type name1; \
+        typename Col<1>::type name2; \
+        ColNames(Init i) noexcept: name1(i), name2(i) {} \
+    }; \
+ \
+    static void dyn_col_names(realm::StringData* names) noexcept \
+    { \
+        names[0] = realm::StringData(#name1, sizeof #name1 - 1); \
+        names[1] = realm::StringData(#name2, sizeof #name2 - 1); \
+    } \
+ \
+    struct ConvenienceMethods { \
+        void add(type1 name1, type2 name2) \
+        { \
+            ::realm::BasicTable<Table##Spec>* const _realm_t = \
+                static_cast< ::realm::BasicTable<Table##Spec>* >(this); \
+            _realm_t->add((::realm::util::tuple(), name1, name2)); \
+        } \
+        void insert(size_t _realm_i, type1 name1, type2 name2) \
+        { \
+            ::realm::BasicTable<Table##Spec>* const _realm_t = \
+                static_cast< ::realm::BasicTable<Table##Spec>* >(this); \
+            _realm_t->insert(_realm_i, (::realm::util::tuple(), name1, name2)); \
+        } \
+        void set(size_t _realm_i, type1 name1, type2 name2) \
+        { \
+            ::realm::BasicTable<Table##Spec>* const _realm_t = \
+                static_cast< ::realm::BasicTable<Table##Spec>* >(this); \
+            _realm_t->set(_realm_i, (::realm::util::tuple(), name1, name2)); \
+        } \
+    }; \
+}; \
+typedef ::realm::BasicTable<Table##Spec> Table;
+
+
+#define REALM_TABLE_3(Table, name1, type1, name2, type2, name3, type3) \
+struct Table##Spec: ::realm::SpecBase { \
+    typedef ::realm::util::TypeAppend< void,     type1 >::type Columns1; \
+    typedef ::realm::util::TypeAppend< Columns1, type2 >::type Columns2; \
+    typedef ::realm::util::TypeAppend< Columns2, type3 >::type Columns; \
+ \
+    template<template<int> class Col, class Init> \
+    struct ColNames { \
+        typename Col<0>::type name1; \
+        typename Col<1>::type name2; \
+        typename Col<2>::type name3; \
+        ColNames(Init i) noexcept: name1(i), name2(i), name3(i) {} \
+    }; \
+ \
+    static void dyn_col_names(realm::StringData* names) noexcept \
+    { \
+        names[0] = realm::StringData(#name1, sizeof #name1 - 1); \
+        names[1] = realm::StringData(#name2, sizeof #name2 - 1); \
+        names[2] = realm::StringData(#name3, sizeof #name3 - 1); \
+    } \
+ \
+    struct ConvenienceMethods { \
+        void add(type1 name1, type2 name2, type3 name3) \
+        { \
+            ::realm::BasicTable<Table##Spec>* const _realm_t = \
+                static_cast< ::realm::BasicTable<Table##Spec>* >(this); \
+            _realm_t->add((::realm::util::tuple(), name1, name2, name3)); \
+        } \
+        void insert(size_t _realm_i, type1 name1, type2 name2, type3 name3) \
+        { \
+            ::realm::BasicTable<Table##Spec>* const _realm_t = \
+                static_cast< ::realm::BasicTable<Table##Spec>* >(this); \
+            _realm_t->insert(_realm_i, (::realm::util::tuple(), name1, name2, name3)); \
+        } \
+        void set(size_t _realm_i, type1 name1, type2 name2, type3 name3) \
+        { \
+            ::realm::BasicTable<Table##Spec>* const _realm_t = \
+                static_cast< ::realm::BasicTable<Table##Spec>* >(this); \
+            _realm_t->set(_realm_i, (::realm::util::tuple(), name1, name2, name3)); \
+        } \
+    }; \
+}; \
+typedef ::realm::BasicTable<Table##Spec> Table;
+
+
+#define REALM_TABLE_4(Table, name1, type1, name2, type2, name3, type3, name4, type4) \
+struct Table##Spec: ::realm::SpecBase { \
+    typedef ::realm::util::TypeAppend< void,     type1 >::type Columns1; \
+    typedef ::realm::util::TypeAppend< Columns1, type2 >::type Columns2; \
+    typedef ::realm::util::TypeAppend< Columns2, type3 >::type Columns3; \
+    typedef ::realm::util::TypeAppend< Columns3, type4 >::type Columns; \
+ \
+    template<template<int> class Col, class Init> \
+    struct ColNames { \
+        typename Col<0>::type name1; \
+        typename Col<1>::type name2; \
+        typename Col<2>::type name3; \
+        typename Col<3>::type name4; \
+        ColNames(Init i) noexcept: name1(i), name2(i), name3(i), name4(i) {} \
+    }; \
+ \
+    static void dyn_col_names(realm::StringData* names) noexcept \
+    { \
+        names[0] = realm::StringData(#name1, sizeof #name1 - 1); \
+        names[1] = realm::StringData(#name2, sizeof #name2 - 1); \
+        names[2] = realm::StringData(#name3, sizeof #name3 - 1); \
+        names[3] = realm::StringData(#name4, sizeof #name4 - 1); \
+    } \
+ \
+    struct ConvenienceMethods { \
+        void add(type1 name1, type2 name2, type3 name3, type4 name4) \
+        { \
+            ::realm::BasicTable<Table##Spec>* const _realm_t = \
+                static_cast< ::realm::BasicTable<Table##Spec>* >(this); \
+            _realm_t->add((::realm::util::tuple(), name1, name2, name3, name4)); \
+        } \
+        void insert(size_t _realm_i, type1 name1, type2 name2, type3 name3, type4 name4) \
+        { \
+            ::realm::BasicTable<Table##Spec>* const _realm_t = \
+                static_cast< ::realm::BasicTable<Table##Spec>* >(this); \
+            _realm_t->insert(_realm_i, (::realm::util::tuple(), name1, name2, name3, name4)); \
+        } \
+        void set(size_t _realm_i, type1 name1, type2 name2, type3 name3, type4 name4) \
+        { \
+            ::realm::BasicTable<Table##Spec>* const _realm_t = \
+                static_cast< ::realm::BasicTable<Table##Spec>* >(this); \
+            _realm_t->set(_realm_i, (::realm::util::tuple(), name1, name2, name3, name4)); \
+        } \
+    }; \
+}; \
+typedef ::realm::BasicTable<Table##Spec> Table;
+
+
+#define REALM_TABLE_5(Table, name1, type1, name2, type2, name3, type3, name4, type4, name5, type5) \
+struct Table##Spec: ::realm::SpecBase { \
+    typedef ::realm::util::TypeAppend< void,     type1 >::type Columns1; \
+    typedef ::realm::util::TypeAppend< Columns1, type2 >::type Columns2; \
+    typedef ::realm::util::TypeAppend< Columns2, type3 >::type Columns3; \
+    typedef ::realm::util::TypeAppend< Columns3, type4 >::type Columns4; \
+    typedef ::realm::util::TypeAppend< Columns4, type5 >::type Columns; \
+ \
+    template<template<int> class Col, class Init> \
+    struct ColNames { \
+        typename Col<0>::type name1; \
+        typename Col<1>::type name2; \
+        typename Col<2>::type name3; \
+        typename Col<3>::type name4; \
+        typename Col<4>::type name5; \
+        ColNames(Init i) noexcept: name1(i), name2(i), name3(i), name4(i), name5(i) {} \
+    }; \
+ \
+    static void dyn_col_names(realm::StringData* names) noexcept \
+    { \
+        names[0] = realm::StringData(#name1, sizeof #name1 - 1); \
+        names[1] = realm::StringData(#name2, sizeof #name2 - 1); \
+        names[2] = realm::StringData(#name3, sizeof #name3 - 1); \
+        names[3] = realm::StringData(#name4, sizeof #name4 - 1); \
+        names[4] = realm::StringData(#name5, sizeof #name5 - 1); \
+    } \
+ \
+    struct ConvenienceMethods { \
+        void add(type1 name1, type2 name2, type3 name3, type4 name4, type5 name5) \
+        { \
+            ::realm::BasicTable<Table##Spec>* const _realm_t = \
+                static_cast< ::realm::BasicTable<Table##Spec>* >(this); \
+            _realm_t->add((::realm::util::tuple(), name1, name2, name3, name4, name5)); \
+        } \
+        void insert(size_t _realm_i, type1 name1, type2 name2, type3 name3, type4 name4, type5 name5) \
+        { \
+            ::realm::BasicTable<Table##Spec>* const _realm_t = \
+                static_cast< ::realm::BasicTable<Table##Spec>* >(this); \
+            _realm_t->insert(_realm_i, (::realm::util::tuple(), name1, name2, name3, name4, name5)); \
+        } \
+        void set(size_t _realm_i, type1 name1, type2 name2, type3 name3, type4 name4, type5 name5) \
+        { \
+            ::realm::BasicTable<Table##Spec>* const _realm_t = \
+                static_cast< ::realm::BasicTable<Table##Spec>* >(this); \
+            _realm_t->set(_realm_i, (::realm::util::tuple(), name1, name2, name3, name4, name5)); \
+        } \
+    }; \
+}; \
+typedef ::realm::BasicTable<Table##Spec> Table;
+
+
+#define REALM_TABLE_6(Table, name1, type1, name2, type2, name3, type3, name4, type4, name5, type5, name6, type6) \
+struct Table##Spec: ::realm::SpecBase { \
+    typedef ::realm::util::TypeAppend< void,     type1 >::type Columns1; \
+    typedef ::realm::util::TypeAppend< Columns1, type2 >::type Columns2; \
+    typedef ::realm::util::TypeAppend< Columns2, type3 >::type Columns3; \
+    typedef ::realm::util::TypeAppend< Columns3, type4 >::type Columns4; \
+    typedef ::realm::util::TypeAppend< Columns4, type5 >::type Columns5; \
+    typedef ::realm::util::TypeAppend< Columns5, type6 >::type Columns; \
+ \
+    template<template<int> class Col, class Init> \
+    struct ColNames { \
+        typename Col<0>::type name1; \
+        typename Col<1>::type name2; \
+        typename Col<2>::type name3; \
+        typename Col<3>::type name4; \
+        typename Col<4>::type name5; \
+        typename Col<5>::type name6; \
+        ColNames(Init i) noexcept: name1(i), name2(i), name3(i), name4(i), name5(i), name6(i) {} \
+    }; \
+ \
+    static void dyn_col_names(realm::StringData* names) noexcept \
+    { \
+        names[0] = realm::StringData(#name1, sizeof #name1 - 1); \
+        names[1] = realm::StringData(#name2, sizeof #name2 - 1); \
+        names[2] = realm::StringData(#name3, sizeof #name3 - 1); \
+        names[3] = realm::StringData(#name4, sizeof #name4 - 1); \
+        names[4] = realm::StringData(#name5, sizeof #name5 - 1); \
+        names[5] = realm::StringData(#name6, sizeof #name6 - 1); \
+    } \
+ \
+    struct ConvenienceMethods { \
+        void add(type1 name1, type2 name2, type3 name3, type4 name4, type5 name5, type6 name6) \
+        { \
+            ::realm::BasicTable<Table##Spec>* const _realm_t = \
+                static_cast< ::realm::BasicTable<Table##Spec>* >(this); \
+            _realm_t->add((::realm::util::tuple(), name1, name2, name3, name4, name5, name6)); \
+        } \
+        void insert(size_t _realm_i, type1 name1, type2 name2, type3 name3, type4 name4, type5 name5, type6 name6) \
+        { \
+            ::realm::BasicTable<Table##Spec>* const _realm_t = \
+                static_cast< ::realm::BasicTable<Table##Spec>* >(this); \
+            _realm_t->insert(_realm_i, (::realm::util::tuple(), name1, name2, name3, name4, name5, name6)); \
+        } \
+        void set(size_t _realm_i, type1 name1, type2 name2, type3 name3, type4 name4, type5 name5, type6 name6) \
+        { \
+            ::realm::BasicTable<Table##Spec>* const _realm_t = \
+                static_cast< ::realm::BasicTable<Table##Spec>* >(this); \
+            _realm_t->set(_realm_i, (::realm::util::tuple(), name1, name2, name3, name4, name5, name6)); \
+        } \
+    }; \
+}; \
+typedef ::realm::BasicTable<Table##Spec> Table;
+
+
+#define REALM_TABLE_7(Table, name1, type1, name2, type2, name3, type3, name4, type4, name5, type5, name6, type6, name7, type7) \
+struct Table##Spec: ::realm::SpecBase { \
+    typedef ::realm::util::TypeAppend< void,     type1 >::type Columns1; \
+    typedef ::realm::util::TypeAppend< Columns1, type2 >::type Columns2; \
+    typedef ::realm::util::TypeAppend< Columns2, type3 >::type Columns3; \
+    typedef ::realm::util::TypeAppend< Columns3, type4 >::type Columns4; \
+    typedef ::realm::util::TypeAppend< Columns4, type5 >::type Columns5; \
+    typedef ::realm::util::TypeAppend< Columns5, type6 >::type Columns6; \
+    typedef ::realm::util::TypeAppend< Columns6, type7 >::type Columns; \
+ \
+    template<template<int> class Col, class Init> \
+    struct ColNames { \
+        typename Col<0>::type name1; \
+        typename Col<1>::type name2; \
+        typename Col<2>::type name3; \
+        typename Col<3>::type name4; \
+        typename Col<4>::type name5; \
+        typename Col<5>::type name6; \
+        typename Col<6>::type name7; \
+        ColNames(Init i) noexcept: name1(i), name2(i), name3(i), name4(i), name5(i), name6(i), name7(i) {} \
+    }; \
+ \
+    static void dyn_col_names(realm::StringData* names) noexcept \
+    { \
+        names[0] = realm::StringData(#name1, sizeof #name1 - 1); \
+        names[1] = realm::StringData(#name2, sizeof #name2 - 1); \
+        names[2] = realm::StringData(#name3, sizeof #name3 - 1); \
+        names[3] = realm::StringData(#name4, sizeof #name4 - 1); \
+        names[4] = realm::StringData(#name5, sizeof #name5 - 1); \
+        names[5] = realm::StringData(#name6, sizeof #name6 - 1); \
+        names[6] = realm::StringData(#name7, sizeof #name7 - 1); \
+    } \
+ \
+    struct ConvenienceMethods { \
+        void add(type1 name1, type2 name2, type3 name3, type4 name4, type5 name5, type6 name6, type7 name7) \
+        { \
+            ::realm::BasicTable<Table##Spec>* const _realm_t = \
+                static_cast< ::realm::BasicTable<Table##Spec>* >(this); \
+            _realm_t->add((::realm::util::tuple(), name1, name2, name3, name4, name5, name6, name7)); \
+        } \
+        void insert(size_t _realm_i, type1 name1, type2 name2, type3 name3, type4 name4, type5 name5, type6 name6, type7 name7) \
+        { \
+            ::realm::BasicTable<Table##Spec>* const _realm_t = \
+                static_cast< ::realm::BasicTable<Table##Spec>* >(this); \
+            _realm_t->insert(_realm_i, (::realm::util::tuple(), name1, name2, name3, name4, name5, name6, name7)); \
+        } \
+        void set(size_t _realm_i, type1 name1, type2 name2, type3 name3, type4 name4, type5 name5, type6 name6, type7 name7) \
+        { \
+            ::realm::BasicTable<Table##Spec>* const _realm_t = \
+                static_cast< ::realm::BasicTable<Table##Spec>* >(this); \
+            _realm_t->set(_realm_i, (::realm::util::tuple(), name1, name2, name3, name4, name5, name6, name7)); \
+        } \
+    }; \
+}; \
+typedef ::realm::BasicTable<Table##Spec> Table;
+
+
+#define REALM_TABLE_8(Table, name1, type1, name2, type2, name3, type3, name4, type4, name5, type5, name6, type6, name7, type7, name8, type8) \
+struct Table##Spec: ::realm::SpecBase { \
+    typedef ::realm::util::TypeAppend< void,     type1 >::type Columns1; \
+    typedef ::realm::util::TypeAppend< Columns1, type2 >::type Columns2; \
+    typedef ::realm::util::TypeAppend< Columns2, type3 >::type Columns3; \
+    typedef ::realm::util::TypeAppend< Columns3, type4 >::type Columns4; \
+    typedef ::realm::util::TypeAppend< Columns4, type5 >::type Columns5; \
+    typedef ::realm::util::TypeAppend< Columns5, type6 >::type Columns6; \
+    typedef ::realm::util::TypeAppend< Columns6, type7 >::type Columns7; \
+    typedef ::realm::util::TypeAppend< Columns7, type8 >::type Columns; \
+ \
+    template<template<int> class Col, class Init> \
+    struct ColNames { \
+        typename Col<0>::type name1; \
+        typename Col<1>::type name2; \
+        typename Col<2>::type name3; \
+        typename Col<3>::type name4; \
+        typename Col<4>::type name5; \
+        typename Col<5>::type name6; \
+        typename Col<6>::type name7; \
+        typename Col<7>::type name8; \
+        ColNames(Init i) noexcept: name1(i), name2(i), name3(i), name4(i), name5(i), name6(i), name7(i), name8(i) {} \
+    }; \
+ \
+    static void dyn_col_names(realm::StringData* names) noexcept \
+    { \
+        names[0] = realm::StringData(#name1, sizeof #name1 - 1); \
+        names[1] = realm::StringData(#name2, sizeof #name2 - 1); \
+        names[2] = realm::StringData(#name3, sizeof #name3 - 1); \
+        names[3] = realm::StringData(#name4, sizeof #name4 - 1); \
+        names[4] = realm::StringData(#name5, sizeof #name5 - 1); \
+        names[5] = realm::StringData(#name6, sizeof #name6 - 1); \
+        names[6] = realm::StringData(#name7, sizeof #name7 - 1); \
+        names[7] = realm::StringData(#name8, sizeof #name8 - 1); \
+    } \
+ \
+    struct ConvenienceMethods { \
+        void add(type1 name1, type2 name2, type3 name3, type4 name4, type5 name5, type6 name6, type7 name7, type8 name8) \
+        { \
+            ::realm::BasicTable<Table##Spec>* const _realm_t = \
+                static_cast< ::realm::BasicTable<Table##Spec>* >(this); \
+            _realm_t->add((::realm::util::tuple(), name1, name2, name3, name4, name5, name6, name7, name8)); \
+        } \
+        void insert(size_t _realm_i, type1 name1, type2 name2, type3 name3, type4 name4, type5 name5, type6 name6, type7 name7, type8 name8) \
+        { \
+            ::realm::BasicTable<Table##Spec>* const _realm_t = \
+                static_cast< ::realm::BasicTable<Table##Spec>* >(this); \
+            _realm_t->insert(_realm_i, (::realm::util::tuple(), name1, name2, name3, name4, name5, name6, name7, name8)); \
+        } \
+        void set(size_t _realm_i, type1 name1, type2 name2, type3 name3, type4 name4, type5 name5, type6 name6, type7 name7, type8 name8) \
+        { \
+            ::realm::BasicTable<Table##Spec>* const _realm_t = \
+                static_cast< ::realm::BasicTable<Table##Spec>* >(this); \
+            _realm_t->set(_realm_i, (::realm::util::tuple(), name1, name2, name3, name4, name5, name6, name7, name8)); \
+        } \
+    }; \
+}; \
+typedef ::realm::BasicTable<Table##Spec> Table;
+
+
+#define REALM_TABLE_9(Table, name1, type1, name2, type2, name3, type3, name4, type4, name5, type5, name6, type6, name7, type7, name8, type8, name9, type9) \
+struct Table##Spec: ::realm::SpecBase { \
+    typedef ::realm::util::TypeAppend< void,     type1 >::type Columns1; \
+    typedef ::realm::util::TypeAppend< Columns1, type2 >::type Columns2; \
+    typedef ::realm::util::TypeAppend< Columns2, type3 >::type Columns3; \
+    typedef ::realm::util::TypeAppend< Columns3, type4 >::type Columns4; \
+    typedef ::realm::util::TypeAppend< Columns4, type5 >::type Columns5; \
+    typedef ::realm::util::TypeAppend< Columns5, type6 >::type Columns6; \
+    typedef ::realm::util::TypeAppend< Columns6, type7 >::type Columns7; \
+    typedef ::realm::util::TypeAppend< Columns7, type8 >::type Columns8; \
+    typedef ::realm::util::TypeAppend< Columns8, type9 >::type Columns; \
+ \
+    template<template<int> class Col, class Init> \
+    struct ColNames { \
+        typename Col<0>::type name1; \
+        typename Col<1>::type name2; \
+        typename Col<2>::type name3; \
+        typename Col<3>::type name4; \
+        typename Col<4>::type name5; \
+        typename Col<5>::type name6; \
+        typename Col<6>::type name7; \
+        typename Col<7>::type name8; \
+        typename Col<8>::type name9; \
+        ColNames(Init i) noexcept: name1(i), name2(i), name3(i), name4(i), name5(i), name6(i), name7(i), name8(i), name9(i) {} \
+    }; \
+ \
+    static void dyn_col_names(realm::StringData* names) noexcept \
+    { \
+        names[0] = realm::StringData(#name1, sizeof #name1 - 1); \
+        names[1] = realm::StringData(#name2, sizeof #name2 - 1); \
+        names[2] = realm::StringData(#name3, sizeof #name3 - 1); \
+        names[3] = realm::StringData(#name4, sizeof #name4 - 1); \
+        names[4] = realm::StringData(#name5, sizeof #name5 - 1); \
+        names[5] = realm::StringData(#name6, sizeof #name6 - 1); \
+        names[6] = realm::StringData(#name7, sizeof #name7 - 1); \
+        names[7] = realm::StringData(#name8, sizeof #name8 - 1); \
+        names[8] = realm::StringData(#name9, sizeof #name9 - 1); \
+    } \
+ \
+    struct ConvenienceMethods { \
+        void add(type1 name1, type2 name2, type3 name3, type4 name4, type5 name5, type6 name6, type7 name7, type8 name8, type9 name9) \
+        { \
+            ::realm::BasicTable<Table##Spec>* const _realm_t = \
+                static_cast< ::realm::BasicTable<Table##Spec>* >(this); \
+            _realm_t->add((::realm::util::tuple(), name1, name2, name3, name4, name5, name6, name7, name8, name9)); \
+        } \
+        void insert(size_t _realm_i, type1 name1, type2 name2, type3 name3, type4 name4, type5 name5, type6 name6, type7 name7, type8 name8, type9 name9) \
+        { \
+            ::realm::BasicTable<Table##Spec>* const _realm_t = \
+                static_cast< ::realm::BasicTable<Table##Spec>* >(this); \
+            _realm_t->insert(_realm_i, (::realm::util::tuple(), name1, name2, name3, name4, name5, name6, name7, name8, name9)); \
+        } \
+        void set(size_t _realm_i, type1 name1, type2 name2, type3 name3, type4 name4, type5 name5, type6 name6, type7 name7, type8 name8, type9 name9) \
+        { \
+            ::realm::BasicTable<Table##Spec>* const _realm_t = \
+                static_cast< ::realm::BasicTable<Table##Spec>* >(this); \
+            _realm_t->set(_realm_i, (::realm::util::tuple(), name1, name2, name3, name4, name5, name6, name7, name8, name9)); \
+        } \
+    }; \
+}; \
+typedef ::realm::BasicTable<Table##Spec> Table;
+
+
+#define REALM_TABLE_10(Table, name1, type1, name2, type2, name3, type3, name4, type4, name5, type5, name6, type6, name7, type7, name8, type8, name9, type9, name10, type10) \
+struct Table##Spec: ::realm::SpecBase { \
+    typedef ::realm::util::TypeAppend< void,     type1 >::type Columns1; \
+    typedef ::realm::util::TypeAppend< Columns1, type2 >::type Columns2; \
+    typedef ::realm::util::TypeAppend< Columns2, type3 >::type Columns3; \
+    typedef ::realm::util::TypeAppend< Columns3, type4 >::type Columns4; \
+    typedef ::realm::util::TypeAppend< Columns4, type5 >::type Columns5; \
+    typedef ::realm::util::TypeAppend< Columns5, type6 >::type Columns6; \
+    typedef ::realm::util::TypeAppend< Columns6, type7 >::type Columns7; \
+    typedef ::realm::util::TypeAppend< Columns7, type8 >::type Columns8; \
+    typedef ::realm::util::TypeAppend< Columns8, type9 >::type Columns9; \
+    typedef ::realm::util::TypeAppend< Columns9, type10 >::type Columns; \
+ \
+    template<template<int> class Col, class Init> \
+    struct ColNames { \
+        typename Col<0>::type name1; \
+        typename Col<1>::type name2; \
+        typename Col<2>::type name3; \
+        typename Col<3>::type name4; \
+        typename Col<4>::type name5; \
+        typename Col<5>::type name6; \
+        typename Col<6>::type name7; \
+        typename Col<7>::type name8; \
+        typename Col<8>::type name9; \
+        typename Col<9>::type name10; \
+        ColNames(Init i) noexcept: name1(i), name2(i), name3(i), name4(i), name5(i), name6(i), name7(i), name8(i), name9(i), name10(i) {} \
+    }; \
+ \
+    static void dyn_col_names(realm::StringData* names) noexcept \
+    { \
+        names[0] = realm::StringData(#name1, sizeof #name1 - 1); \
+        names[1] = realm::StringData(#name2, sizeof #name2 - 1); \
+        names[2] = realm::StringData(#name3, sizeof #name3 - 1); \
+        names[3] = realm::StringData(#name4, sizeof #name4 - 1); \
+        names[4] = realm::StringData(#name5, sizeof #name5 - 1); \
+        names[5] = realm::StringData(#name6, sizeof #name6 - 1); \
+        names[6] = realm::StringData(#name7, sizeof #name7 - 1); \
+        names[7] = realm::StringData(#name8, sizeof #name8 - 1); \
+        names[8] = realm::StringData(#name9, sizeof #name9 - 1); \
+        names[9] = realm::StringData(#name10, sizeof #name10 - 1); \
+    } \
+ \
+    struct ConvenienceMethods { \
+        void add(type1 name1, type2 name2, type3 name3, type4 name4, type5 name5, type6 name6, type7 name7, type8 name8, type9 name9, type10 name10) \
+        { \
+            ::realm::BasicTable<Table##Spec>* const _realm_t = \
+                static_cast< ::realm::BasicTable<Table##Spec>* >(this); \
+            _realm_t->add((::realm::util::tuple(), name1, name2, name3, name4, name5, name6, name7, name8, name9, name10)); \
+        } \
+        void insert(size_t _realm_i, type1 name1, type2 name2, type3 name3, type4 name4, type5 name5, type6 name6, type7 name7, type8 name8, type9 name9, type10 name10) \
+        { \
+            ::realm::BasicTable<Table##Spec>* const _realm_t = \
+                static_cast< ::realm::BasicTable<Table##Spec>* >(this); \
+            _realm_t->insert(_realm_i, (::realm::util::tuple(), name1, name2, name3, name4, name5, name6, name7, name8, name9, name10)); \
+        } \
+        void set(size_t _realm_i, type1 name1, type2 name2, type3 name3, type4 name4, type5 name5, type6 name6, type7 name7, type8 name8, type9 name9, type10 name10) \
+        { \
+            ::realm::BasicTable<Table##Spec>* const _realm_t = \
+                static_cast< ::realm::BasicTable<Table##Spec>* >(this); \
+            _realm_t->set(_realm_i, (::realm::util::tuple(), name1, name2, name3, name4, name5, name6, name7, name8, name9, name10)); \
+        } \
+    }; \
+}; \
+typedef ::realm::BasicTable<Table##Spec> Table;
+
+
+#define REALM_TABLE_11(Table, name1, type1, name2, type2, name3, type3, name4, type4, name5, type5, name6, type6, name7, type7, name8, type8, name9, type9, name10, type10, name11, type11) \
+struct Table##Spec: ::realm::SpecBase { \
+    typedef ::realm::util::TypeAppend< void,     type1 >::type Columns1; \
+    typedef ::realm::util::TypeAppend< Columns1, type2 >::type Columns2; \
+    typedef ::realm::util::TypeAppend< Columns2, type3 >::type Columns3; \
+    typedef ::realm::util::TypeAppend< Columns3, type4 >::type Columns4; \
+    typedef ::realm::util::TypeAppend< Columns4, type5 >::type Columns5; \
+    typedef ::realm::util::TypeAppend< Columns5, type6 >::type Columns6; \
+    typedef ::realm::util::TypeAppend< Columns6, type7 >::type Columns7; \
+    typedef ::realm::util::TypeAppend< Columns7, type8 >::type Columns8; \
+    typedef ::realm::util::TypeAppend< Columns8, type9 >::type Columns9; \
+    typedef ::realm::util::TypeAppend< Columns9, type10 >::type Columns10; \
+    typedef ::realm::util::TypeAppend< Columns10, type11 >::type Columns; \
+ \
+    template<template<int> class Col, class Init> \
+    struct ColNames { \
+        typename Col<0>::type name1; \
+        typename Col<1>::type name2; \
+        typename Col<2>::type name3; \
+        typename Col<3>::type name4; \
+        typename Col<4>::type name5; \
+        typename Col<5>::type name6; \
+        typename Col<6>::type name7; \
+        typename Col<7>::type name8; \
+        typename Col<8>::type name9; \
+        typename Col<9>::type name10; \
+        typename Col<10>::type name11; \
+        ColNames(Init i) noexcept: name1(i), name2(i), name3(i), name4(i), name5(i), name6(i), name7(i), name8(i), name9(i), name10(i), name11(i) {} \
+    }; \
+ \
+    static void dyn_col_names(realm::StringData* names) noexcept \
+    { \
+        names[0] = realm::StringData(#name1, sizeof #name1 - 1); \
+        names[1] = realm::StringData(#name2, sizeof #name2 - 1); \
+        names[2] = realm::StringData(#name3, sizeof #name3 - 1); \
+        names[3] = realm::StringData(#name4, sizeof #name4 - 1); \
+        names[4] = realm::StringData(#name5, sizeof #name5 - 1); \
+        names[5] = realm::StringData(#name6, sizeof #name6 - 1); \
+        names[6] = realm::StringData(#name7, sizeof #name7 - 1); \
+        names[7] = realm::StringData(#name8, sizeof #name8 - 1); \
+        names[8] = realm::StringData(#name9, sizeof #name9 - 1); \
+        names[9] = realm::StringData(#name10, sizeof #name10 - 1); \
+        names[10] = realm::StringData(#name11, sizeof #name11 - 1); \
+    } \
+ \
+    struct ConvenienceMethods { \
+        void add(type1 name1, type2 name2, type3 name3, type4 name4, type5 name5, type6 name6, type7 name7, type8 name8, type9 name9, type10 name10, type11 name11) \
+        { \
+            ::realm::BasicTable<Table##Spec>* const _realm_t = \
+                static_cast< ::realm::BasicTable<Table##Spec>* >(this); \
+            _realm_t->add((::realm::util::tuple(), name1, name2, name3, name4, name5, name6, name7, name8, name9, name10, name11)); \
+        } \
+        void insert(size_t _realm_i, type1 name1, type2 name2, type3 name3, type4 name4, type5 name5, type6 name6, type7 name7, type8 name8, type9 name9, type10 name10, type11 name11) \
+        { \
+            ::realm::BasicTable<Table##Spec>* const _realm_t = \
+                static_cast< ::realm::BasicTable<Table##Spec>* >(this); \
+            _realm_t->insert(_realm_i, (::realm::util::tuple(), name1, name2, name3, name4, name5, name6, name7, name8, name9, name10, name11)); \
+        } \
+        void set(size_t _realm_i, type1 name1, type2 name2, type3 name3, type4 name4, type5 name5, type6 name6, type7 name7, type8 name8, type9 name9, type10 name10, type11 name11) \
+        { \
+            ::realm::BasicTable<Table##Spec>* const _realm_t = \
+                static_cast< ::realm::BasicTable<Table##Spec>* >(this); \
+            _realm_t->set(_realm_i, (::realm::util::tuple(), name1, name2, name3, name4, name5, name6, name7, name8, name9, name10, name11)); \
+        } \
+    }; \
+}; \
+typedef ::realm::BasicTable<Table##Spec> Table;
+
+
+#define REALM_TABLE_12(Table, name1, type1, name2, type2, name3, type3, name4, type4, name5, type5, name6, type6, name7, type7, name8, type8, name9, type9, name10, type10, name11, type11, name12, type12) \
+struct Table##Spec: ::realm::SpecBase { \
+    typedef ::realm::util::TypeAppend< void,     type1 >::type Columns1; \
+    typedef ::realm::util::TypeAppend< Columns1, type2 >::type Columns2; \
+    typedef ::realm::util::TypeAppend< Columns2, type3 >::type Columns3; \
+    typedef ::realm::util::TypeAppend< Columns3, type4 >::type Columns4; \
+    typedef ::realm::util::TypeAppend< Columns4, type5 >::type Columns5; \
+    typedef ::realm::util::TypeAppend< Columns5, type6 >::type Columns6; \
+    typedef ::realm::util::TypeAppend< Columns6, type7 >::type Columns7; \
+    typedef ::realm::util::TypeAppend< Columns7, type8 >::type Columns8; \
+    typedef ::realm::util::TypeAppend< Columns8, type9 >::type Columns9; \
+    typedef ::realm::util::TypeAppend< Columns9, type10 >::type Columns10; \
+    typedef ::realm::util::TypeAppend< Columns10, type11 >::type Columns11; \
+    typedef ::realm::util::TypeAppend< Columns11, type12 >::type Columns; \
+ \
+    template<template<int> class Col, class Init> \
+    struct ColNames { \
+        typename Col<0>::type name1; \
+        typename Col<1>::type name2; \
+        typename Col<2>::type name3; \
+        typename Col<3>::type name4; \
+        typename Col<4>::type name5; \
+        typename Col<5>::type name6; \
+        typename Col<6>::type name7; \
+        typename Col<7>::type name8; \
+        typename Col<8>::type name9; \
+        typename Col<9>::type name10; \
+        typename Col<10>::type name11; \
+        typename Col<11>::type name12; \
+        ColNames(Init i) noexcept: name1(i), name2(i), name3(i), name4(i), name5(i), name6(i), name7(i), name8(i), name9(i), name10(i), name11(i), name12(i) {} \
+    }; \
+ \
+    static void dyn_col_names(realm::StringData* names) noexcept \
+    { \
+        names[0] = realm::StringData(#name1, sizeof #name1 - 1); \
+        names[1] = realm::StringData(#name2, sizeof #name2 - 1); \
+        names[2] = realm::StringData(#name3, sizeof #name3 - 1); \
+        names[3] = realm::StringData(#name4, sizeof #name4 - 1); \
+        names[4] = realm::StringData(#name5, sizeof #name5 - 1); \
+        names[5] = realm::StringData(#name6, sizeof #name6 - 1); \
+        names[6] = realm::StringData(#name7, sizeof #name7 - 1); \
+        names[7] = realm::StringData(#name8, sizeof #name8 - 1); \
+        names[8] = realm::StringData(#name9, sizeof #name9 - 1); \
+        names[9] = realm::StringData(#name10, sizeof #name10 - 1); \
+        names[10] = realm::StringData(#name11, sizeof #name11 - 1); \
+        names[11] = realm::StringData(#name12, sizeof #name12 - 1); \
+    } \
+ \
+    struct ConvenienceMethods { \
+        void add(type1 name1, type2 name2, type3 name3, type4 name4, type5 name5, type6 name6, type7 name7, type8 name8, type9 name9, type10 name10, type11 name11, type12 name12) \
+        { \
+            ::realm::BasicTable<Table##Spec>* const _realm_t = \
+                static_cast< ::realm::BasicTable<Table##Spec>* >(this); \
+            _realm_t->add((::realm::util::tuple(), name1, name2, name3, name4, name5, name6, name7, name8, name9, name10, name11, name12)); \
+        } \
+        void insert(size_t _realm_i, type1 name1, type2 name2, type3 name3, type4 name4, type5 name5, type6 name6, type7 name7, type8 name8, type9 name9, type10 name10, type11 name11, type12 name12) \
+        { \
+            ::realm::BasicTable<Table##Spec>* const _realm_t = \
+                static_cast< ::realm::BasicTable<Table##Spec>* >(this); \
+            _realm_t->insert(_realm_i, (::realm::util::tuple(), name1, name2, name3, name4, name5, name6, name7, name8, name9, name10, name11, name12)); \
+        } \
+        void set(size_t _realm_i, type1 name1, type2 name2, type3 name3, type4 name4, type5 name5, type6 name6, type7 name7, type8 name8, type9 name9, type10 name10, type11 name11, type12 name12) \
+        { \
+            ::realm::BasicTable<Table##Spec>* const _realm_t = \
+                static_cast< ::realm::BasicTable<Table##Spec>* >(this); \
+            _realm_t->set(_realm_i, (::realm::util::tuple(), name1, name2, name3, name4, name5, name6, name7, name8, name9, name10, name11, name12)); \
+        } \
+    }; \
+}; \
+typedef ::realm::BasicTable<Table##Spec> Table;
+
+
+#define REALM_TABLE_13(Table, name1, type1, name2, type2, name3, type3, name4, type4, name5, type5, name6, type6, name7, type7, name8, type8, name9, type9, name10, type10, name11, type11, name12, type12, name13, type13) \
+struct Table##Spec: ::realm::SpecBase { \
+    typedef ::realm::util::TypeAppend< void,     type1 >::type Columns1; \
+    typedef ::realm::util::TypeAppend< Columns1, type2 >::type Columns2; \
+    typedef ::realm::util::TypeAppend< Columns2, type3 >::type Columns3; \
+    typedef ::realm::util::TypeAppend< Columns3, type4 >::type Columns4; \
+    typedef ::realm::util::TypeAppend< Columns4, type5 >::type Columns5; \
+    typedef ::realm::util::TypeAppend< Columns5, type6 >::type Columns6; \
+    typedef ::realm::util::TypeAppend< Columns6, type7 >::type Columns7; \
+    typedef ::realm::util::TypeAppend< Columns7, type8 >::type Columns8; \
+    typedef ::realm::util::TypeAppend< Columns8, type9 >::type Columns9; \
+    typedef ::realm::util::TypeAppend< Columns9, type10 >::type Columns10; \
+    typedef ::realm::util::TypeAppend< Columns10, type11 >::type Columns11; \
+    typedef ::realm::util::TypeAppend< Columns11, type12 >::type Columns12; \
+    typedef ::realm::util::TypeAppend< Columns12, type13 >::type Columns; \
+ \
+    template<template<int> class Col, class Init> \
+    struct ColNames { \
+        typename Col<0>::type name1; \
+        typename Col<1>::type name2; \
+        typename Col<2>::type name3; \
+        typename Col<3>::type name4; \
+        typename Col<4>::type name5; \
+        typename Col<5>::type name6; \
+        typename Col<6>::type name7; \
+        typename Col<7>::type name8; \
+        typename Col<8>::type name9; \
+        typename Col<9>::type name10; \
+        typename Col<10>::type name11; \
+        typename Col<11>::type name12; \
+        typename Col<12>::type name13; \
+        ColNames(Init i) noexcept: name1(i), name2(i), name3(i), name4(i), name5(i), name6(i), name7(i), name8(i), name9(i), name10(i), name11(i), name12(i), name13(i) {} \
+    }; \
+ \
+    static void dyn_col_names(realm::StringData* names) noexcept \
+    { \
+        names[0] = realm::StringData(#name1, sizeof #name1 - 1); \
+        names[1] = realm::StringData(#name2, sizeof #name2 - 1); \
+        names[2] = realm::StringData(#name3, sizeof #name3 - 1); \
+        names[3] = realm::StringData(#name4, sizeof #name4 - 1); \
+        names[4] = realm::StringData(#name5, sizeof #name5 - 1); \
+        names[5] = realm::StringData(#name6, sizeof #name6 - 1); \
+        names[6] = realm::StringData(#name7, sizeof #name7 - 1); \
+        names[7] = realm::StringData(#name8, sizeof #name8 - 1); \
+        names[8] = realm::StringData(#name9, sizeof #name9 - 1); \
+        names[9] = realm::StringData(#name10, sizeof #name10 - 1); \
+        names[10] = realm::StringData(#name11, sizeof #name11 - 1); \
+        names[11] = realm::StringData(#name12, sizeof #name12 - 1); \
+        names[12] = realm::StringData(#name13, sizeof #name13 - 1); \
+    } \
+ \
+    struct ConvenienceMethods { \
+        void add(type1 name1, type2 name2, type3 name3, type4 name4, type5 name5, type6 name6, type7 name7, type8 name8, type9 name9, type10 name10, type11 name11, type12 name12, type13 name13) \
+        { \
+            ::realm::BasicTable<Table##Spec>* const _realm_t = \
+                static_cast< ::realm::BasicTable<Table##Spec>* >(this); \
+            _realm_t->add((::realm::util::tuple(), name1, name2, name3, name4, name5, name6, name7, name8, name9, name10, name11, name12, name13)); \
+        } \
+        void insert(size_t _realm_i, type1 name1, type2 name2, type3 name3, type4 name4, type5 name5, type6 name6, type7 name7, type8 name8, type9 name9, type10 name10, type11 name11, type12 name12, type13 name13) \
+        { \
+            ::realm::BasicTable<Table##Spec>* const _realm_t = \
+                static_cast< ::realm::BasicTable<Table##Spec>* >(this); \
+            _realm_t->insert(_realm_i, (::realm::util::tuple(), name1, name2, name3, name4, name5, name6, name7, name8, name9, name10, name11, name12, name13)); \
+        } \
+        void set(size_t _realm_i, type1 name1, type2 name2, type3 name3, type4 name4, type5 name5, type6 name6, type7 name7, type8 name8, type9 name9, type10 name10, type11 name11, type12 name12, type13 name13) \
+        { \
+            ::realm::BasicTable<Table##Spec>* const _realm_t = \
+                static_cast< ::realm::BasicTable<Table##Spec>* >(this); \
+            _realm_t->set(_realm_i, (::realm::util::tuple(), name1, name2, name3, name4, name5, name6, name7, name8, name9, name10, name11, name12, name13)); \
+        } \
+    }; \
+}; \
+typedef ::realm::BasicTable<Table##Spec> Table;
+
+
+#define REALM_TABLE_14(Table, name1, type1, name2, type2, name3, type3, name4, type4, name5, type5, name6, type6, name7, type7, name8, type8, name9, type9, name10, type10, name11, type11, name12, type12, name13, type13, name14, type14) \
+struct Table##Spec: ::realm::SpecBase { \
+    typedef ::realm::util::TypeAppend< void,     type1 >::type Columns1; \
+    typedef ::realm::util::TypeAppend< Columns1, type2 >::type Columns2; \
+    typedef ::realm::util::TypeAppend< Columns2, type3 >::type Columns3; \
+    typedef ::realm::util::TypeAppend< Columns3, type4 >::type Columns4; \
+    typedef ::realm::util::TypeAppend< Columns4, type5 >::type Columns5; \
+    typedef ::realm::util::TypeAppend< Columns5, type6 >::type Columns6; \
+    typedef ::realm::util::TypeAppend< Columns6, type7 >::type Columns7; \
+    typedef ::realm::util::TypeAppend< Columns7, type8 >::type Columns8; \
+    typedef ::realm::util::TypeAppend< Columns8, type9 >::type Columns9; \
+    typedef ::realm::util::TypeAppend< Columns9, type10 >::type Columns10; \
+    typedef ::realm::util::TypeAppend< Columns10, type11 >::type Columns11; \
+    typedef ::realm::util::TypeAppend< Columns11, type12 >::type Columns12; \
+    typedef ::realm::util::TypeAppend< Columns12, type13 >::type Columns13; \
+    typedef ::realm::util::TypeAppend< Columns13, type14 >::type Columns; \
+ \
+    template<template<int> class Col, class Init> \
+    struct ColNames { \
+        typename Col<0>::type name1; \
+        typename Col<1>::type name2; \
+        typename Col<2>::type name3; \
+        typename Col<3>::type name4; \
+        typename Col<4>::type name5; \
+        typename Col<5>::type name6; \
+        typename Col<6>::type name7; \
+        typename Col<7>::type name8; \
+        typename Col<8>::type name9; \
+        typename Col<9>::type name10; \
+        typename Col<10>::type name11; \
+        typename Col<11>::type name12; \
+        typename Col<12>::type name13; \
+        typename Col<13>::type name14; \
+        ColNames(Init i) noexcept: name1(i), name2(i), name3(i), name4(i), name5(i), name6(i), name7(i), name8(i), name9(i), name10(i), name11(i), name12(i), name13(i), name14(i) {} \
+    }; \
+ \
+    static void dyn_col_names(realm::StringData* names) noexcept \
+    { \
+        names[0] = realm::StringData(#name1, sizeof #name1 - 1); \
+        names[1] = realm::StringData(#name2, sizeof #name2 - 1); \
+        names[2] = realm::StringData(#name3, sizeof #name3 - 1); \
+        names[3] = realm::StringData(#name4, sizeof #name4 - 1); \
+        names[4] = realm::StringData(#name5, sizeof #name5 - 1); \
+        names[5] = realm::StringData(#name6, sizeof #name6 - 1); \
+        names[6] = realm::StringData(#name7, sizeof #name7 - 1); \
+        names[7] = realm::StringData(#name8, sizeof #name8 - 1); \
+        names[8] = realm::StringData(#name9, sizeof #name9 - 1); \
+        names[9] = realm::StringData(#name10, sizeof #name10 - 1); \
+        names[10] = realm::StringData(#name11, sizeof #name11 - 1); \
+        names[11] = realm::StringData(#name12, sizeof #name12 - 1); \
+        names[12] = realm::StringData(#name13, sizeof #name13 - 1); \
+        names[13] = realm::StringData(#name14, sizeof #name14 - 1); \
+    } \
+ \
+    struct ConvenienceMethods { \
+        void add(type1 name1, type2 name2, type3 name3, type4 name4, type5 name5, type6 name6, type7 name7, type8 name8, type9 name9, type10 name10, type11 name11, type12 name12, type13 name13, type14 name14) \
+        { \
+            ::realm::BasicTable<Table##Spec>* const _realm_t = \
+                static_cast< ::realm::BasicTable<Table##Spec>* >(this); \
+            _realm_t->add((::realm::util::tuple(), name1, name2, name3, name4, name5, name6, name7, name8, name9, name10, name11, name12, name13, name14)); \
+        } \
+        void insert(size_t _realm_i, type1 name1, type2 name2, type3 name3, type4 name4, type5 name5, type6 name6, type7 name7, type8 name8, type9 name9, type10 name10, type11 name11, type12 name12, type13 name13, type14 name14) \
+        { \
+            ::realm::BasicTable<Table##Spec>* const _realm_t = \
+                static_cast< ::realm::BasicTable<Table##Spec>* >(this); \
+            _realm_t->insert(_realm_i, (::realm::util::tuple(), name1, name2, name3, name4, name5, name6, name7, name8, name9, name10, name11, name12, name13, name14)); \
+        } \
+        void set(size_t _realm_i, type1 name1, type2 name2, type3 name3, type4 name4, type5 name5, type6 name6, type7 name7, type8 name8, type9 name9, type10 name10, type11 name11, type12 name12, type13 name13, type14 name14) \
+        { \
+            ::realm::BasicTable<Table##Spec>* const _realm_t = \
+                static_cast< ::realm::BasicTable<Table##Spec>* >(this); \
+            _realm_t->set(_realm_i, (::realm::util::tuple(), name1, name2, name3, name4, name5, name6, name7, name8, name9, name10, name11, name12, name13, name14)); \
+        } \
+    }; \
+}; \
+typedef ::realm::BasicTable<Table##Spec> Table;
+
+
+#define REALM_TABLE_15(Table, name1, type1, name2, type2, name3, type3, name4, type4, name5, type5, name6, type6, name7, type7, name8, type8, name9, type9, name10, type10, name11, type11, name12, type12, name13, type13, name14, type14, name15, type15) \
+struct Table##Spec: ::realm::SpecBase { \
+    typedef ::realm::util::TypeAppend< void,     type1 >::type Columns1; \
+    typedef ::realm::util::TypeAppend< Columns1, type2 >::type Columns2; \
+    typedef ::realm::util::TypeAppend< Columns2, type3 >::type Columns3; \
+    typedef ::realm::util::TypeAppend< Columns3, type4 >::type Columns4; \
+    typedef ::realm::util::TypeAppend< Columns4, type5 >::type Columns5; \
+    typedef ::realm::util::TypeAppend< Columns5, type6 >::type Columns6; \
+    typedef ::realm::util::TypeAppend< Columns6, type7 >::type Columns7; \
+    typedef ::realm::util::TypeAppend< Columns7, type8 >::type Columns8; \
+    typedef ::realm::util::TypeAppend< Columns8, type9 >::type Columns9; \
+    typedef ::realm::util::TypeAppend< Columns9, type10 >::type Columns10; \
+    typedef ::realm::util::TypeAppend< Columns10, type11 >::type Columns11; \
+    typedef ::realm::util::TypeAppend< Columns11, type12 >::type Columns12; \
+    typedef ::realm::util::TypeAppend< Columns12, type13 >::type Columns13; \
+    typedef ::realm::util::TypeAppend< Columns13, type14 >::type Columns14; \
+    typedef ::realm::util::TypeAppend< Columns14, type15 >::type Columns; \
+ \
+    template<template<int> class Col, class Init> \
+    struct ColNames { \
+        typename Col<0>::type name1; \
+        typename Col<1>::type name2; \
+        typename Col<2>::type name3; \
+        typename Col<3>::type name4; \
+        typename Col<4>::type name5; \
+        typename Col<5>::type name6; \
+        typename Col<6>::type name7; \
+        typename Col<7>::type name8; \
+        typename Col<8>::type name9; \
+        typename Col<9>::type name10; \
+        typename Col<10>::type name11; \
+        typename Col<11>::type name12; \
+        typename Col<12>::type name13; \
+        typename Col<13>::type name14; \
+        typename Col<14>::type name15; \
+        ColNames(Init i) noexcept: name1(i), name2(i), name3(i), name4(i), name5(i), name6(i), name7(i), name8(i), name9(i), name10(i), name11(i), name12(i), name13(i), name14(i), name15(i) {} \
+    }; \
+ \
+    static void dyn_col_names(realm::StringData* names) noexcept \
+    { \
+        names[0] = realm::StringData(#name1, sizeof #name1 - 1); \
+        names[1] = realm::StringData(#name2, sizeof #name2 - 1); \
+        names[2] = realm::StringData(#name3, sizeof #name3 - 1); \
+        names[3] = realm::StringData(#name4, sizeof #name4 - 1); \
+        names[4] = realm::StringData(#name5, sizeof #name5 - 1); \
+        names[5] = realm::StringData(#name6, sizeof #name6 - 1); \
+        names[6] = realm::StringData(#name7, sizeof #name7 - 1); \
+        names[7] = realm::StringData(#name8, sizeof #name8 - 1); \
+        names[8] = realm::StringData(#name9, sizeof #name9 - 1); \
+        names[9] = realm::StringData(#name10, sizeof #name10 - 1); \
+        names[10] = realm::StringData(#name11, sizeof #name11 - 1); \
+        names[11] = realm::StringData(#name12, sizeof #name12 - 1); \
+        names[12] = realm::StringData(#name13, sizeof #name13 - 1); \
+        names[13] = realm::StringData(#name14, sizeof #name14 - 1); \
+        names[14] = realm::StringData(#name15, sizeof #name15 - 1); \
+    } \
+ \
+    struct ConvenienceMethods { \
+        void add(type1 name1, type2 name2, type3 name3, type4 name4, type5 name5, type6 name6, type7 name7, type8 name8, type9 name9, type10 name10, type11 name11, type12 name12, type13 name13, type14 name14, type15 name15) \
+        { \
+            ::realm::BasicTable<Table##Spec>* const _realm_t = \
+                static_cast< ::realm::BasicTable<Table##Spec>* >(this); \
+            _realm_t->add((::realm::util::tuple(), name1, name2, name3, name4, name5, name6, name7, name8, name9, name10, name11, name12, name13, name14, name15)); \
+        } \
+        void insert(size_t _realm_i, type1 name1, type2 name2, type3 name3, type4 name4, type5 name5, type6 name6, type7 name7, type8 name8, type9 name9, type10 name10, type11 name11, type12 name12, type13 name13, type14 name14, type15 name15) \
+        { \
+            ::realm::BasicTable<Table##Spec>* const _realm_t = \
+                static_cast< ::realm::BasicTable<Table##Spec>* >(this); \
+            _realm_t->insert(_realm_i, (::realm::util::tuple(), name1, name2, name3, name4, name5, name6, name7, name8, name9, name10, name11, name12, name13, name14, name15)); \
+        } \
+        void set(size_t _realm_i, type1 name1, type2 name2, type3 name3, type4 name4, type5 name5, type6 name6, type7 name7, type8 name8, type9 name9, type10 name10, type11 name11, type12 name12, type13 name13, type14 name14, type15 name15) \
+        { \
+            ::realm::BasicTable<Table##Spec>* const _realm_t = \
+                static_cast< ::realm::BasicTable<Table##Spec>* >(this); \
+            _realm_t->set(_realm_i, (::realm::util::tuple(), name1, name2, name3, name4, name5, name6, name7, name8, name9, name10, name11, name12, name13, name14, name15)); \
+        } \
+    }; \
+}; \
+typedef ::realm::BasicTable<Table##Spec> Table;
+
+
+#endif // REALM_TABLE_MACROS_HPP
diff --git a/Pods/Realm/include/core/realm/table_ref.hpp b/Pods/Realm/include/core/realm/table_ref.hpp
new file mode 100644
index 0000000..5d6990e
--- /dev/null
+++ b/Pods/Realm/include/core/realm/table_ref.hpp
@@ -0,0 +1,455 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_TABLE_REF_HPP
+#define REALM_TABLE_REF_HPP
+
+#include <cstddef>
+#include <algorithm>
+
+#include <realm/util/bind_ptr.hpp>
+
+namespace realm {
+
+
+class Table;
+template<class>
+class BasicTable;
+
+
+/// A reference-counting "smart pointer" for referring to table
+/// accessors.
+///
+/// The purpose of this smart pointer is to keep the referenced table
+/// accessor alive for as long as anybody is referring to it, however,
+/// for stack allocated table accessors, the lifetime is necessarily
+/// determined by scope (see below).
+///
+/// Please take note of the distinction between a "table" and a "table
+/// accessor" here. A table accessor is an instance of `Table` or
+/// `BasicTable<Spec>`, and it may, or may not be attached to an
+/// actual table at any specific point in time, but this state of
+/// attachment of the accessor has nothing to do with the function of
+/// the smart pointer. Also, in the rest of the documentation of this
+/// class, whenever you see `Table::foo`, you are supposed to read it
+/// as, `Table::foo` or `BasicTable<Spec>::foo`.
+///
+///
+/// Table accessors are either created directly by an application via
+/// a call to one of the public table constructors, or they are
+/// created internally by the Realm library, such as when the
+/// application calls Group::get_table(), Table::get_subtable(), or
+/// Table::create().
+///
+/// Applications can safely assume that all table accessors, created
+/// internally by the Realm library, have a lifetime that is managed
+/// by reference counting. This means that the application can prolong
+/// the lifetime of *such* table accessors indefinitely by holding on
+/// to at least one smart pointer, but note that the guarantee of the
+/// continued existence of the accessor, does not imply that the
+/// accessor remains attached to the underlying table (see
+/// Table::is_attached() for details). Accessors whose lifetime are
+/// controlled by reference counting are destroyed exactly when the
+/// reference count drops to zero.
+///
+/// When an application creates a new table accessor by a direct call
+/// to one of the public constructors, the lifetime of that table
+/// accessor is *not*, and cannot be managed by reference
+/// counting. This is true regardless of the way the accessor is
+/// created (i.e., regardless of whether it is an automatic variable
+/// on the stack, or created on the heap using `new`). However, for
+/// convenience, but with one important caveat, it is still possible
+/// to use smart pointers to refer to such accessors. The caveat is
+/// that no smart pointers are allowed to refer to the accessor at the
+/// point in time when its destructor is called. It is entirely the
+/// responsibility of the application to ensure that this requirement
+/// is met. Failing to do so, will result in undefined
+/// behavior. Finally, please note that an application is always free
+/// to use Table::create() as an alternative to creating free-standing
+/// top-level tables on the stack, and that this is indeed neccessary
+/// when fully reference counted lifetimes are required.
+///
+/// So, at any time, and for any table accessor, an application can
+/// call Table::get_table_ref() to obtain a smart pointer that refers
+/// to that table, however, while that is always possible and safe, it
+/// is not always possible to extend the lifetime of an accessor by
+/// holding on to a smart pointer. The question of whether that is
+/// possible, depends directly on the way the accessor was created.
+///
+///
+/// Apart from keeping track of the number of references, these smart
+/// pointers behaves almost exactly like regular pointers. In
+/// particular, it is possible to dereference a TableRef and get a
+/// `Table&` out of it, however, if you are not careful, this can
+/// easily lead to dangling references:
+///
+/// \code{.cpp}
+///
+///   Table& sub_1 = *(table.get_subtable(0,0));
+///   sub_1.add_empty_row(); // Oops, sub_1 may be dangling!
+///
+/// \endcode
+///
+/// Whether `sub_1` is actually dangling in the example above will
+/// depend on whether other references to the same subtable accessor
+/// already exist, but it is never wise to rely in this. Here is a
+/// safe and proper alternative:
+///
+/// \code{.cpp}
+///
+///   TableRef sub_2 = table.get_subtable(0,0);
+///   sub_2.add_empty_row(); // Safe!
+///
+///   void do_something(Table&);
+///   do_something(*(table.get_subtable(0,0))); // Also safe!
+///
+/// \endcode
+///
+///
+/// \sa Table
+/// \sa TableRef
+template<class T>
+class BasicTableRef: util::bind_ptr<T> {
+public:
+    constexpr BasicTableRef() noexcept {}
+    ~BasicTableRef() noexcept {}
+
+    // Copy construct
+    BasicTableRef(const BasicTableRef& r) noexcept: util::bind_ptr<T>(r) {}
+    template<class U>
+    BasicTableRef(const BasicTableRef<U>& r) noexcept:
+        util::bind_ptr<T>(r) {}
+
+    // Copy assign
+    BasicTableRef& operator=(const BasicTableRef&) noexcept;
+    template<class U>
+    BasicTableRef& operator=(const BasicTableRef<U>&) noexcept;
+
+    // Move construct
+    BasicTableRef(BasicTableRef&& r) noexcept: util::bind_ptr<T>(std::move(r)) {}
+    template<class U>
+    BasicTableRef(BasicTableRef<U>&& r) noexcept:
+        util::bind_ptr<T>(std::move(r)) {}
+
+    // Move assign
+    BasicTableRef& operator=(BasicTableRef&&) noexcept;
+    template<class U>
+    BasicTableRef& operator=(BasicTableRef<U>&&) noexcept;
+
+    //@{
+    /// Comparison
+    template<class U>
+    bool operator==(const BasicTableRef<U>&) const noexcept;
+
+    template<class U>
+    bool operator==(U*) const noexcept;
+
+    template<class U>
+    bool operator!=(const BasicTableRef<U>&) const noexcept;
+
+    template<class U>
+    bool operator!=(U*) const noexcept;
+
+    template<class U>
+    bool operator<(const BasicTableRef<U>&) const noexcept;
+
+    template<class U>
+    bool operator<(U*) const noexcept;
+
+    template<class U>
+    bool operator>(const BasicTableRef<U>&) const noexcept;
+
+    template<class U>
+    bool operator>(U*) const noexcept;
+
+    template<class U>
+    bool operator<=(const BasicTableRef<U>&) const noexcept;
+
+    template<class U>
+    bool operator<=(U*) const noexcept;
+
+    template<class U>
+    bool operator>=(const BasicTableRef<U>&) const noexcept;
+
+    template<class U>
+    bool operator>=(U*) const noexcept;
+    //@}
+
+    // Dereference
+#ifdef __clang__
+    // Clang has a bug that causes it to effectively ignore the 'using' declaration.
+    T& operator*() const noexcept { return util::bind_ptr<T>::operator*(); }
+#else
+    using util::bind_ptr<T>::operator*;
+#endif
+    using util::bind_ptr<T>::operator->;
+
+    using util::bind_ptr<T>::operator bool;
+
+    T* get() const noexcept { return util::bind_ptr<T>::get(); }
+    void reset() noexcept { util::bind_ptr<T>::reset(); }
+    void reset(T* t) noexcept { util::bind_ptr<T>::reset(t); }
+
+    void swap(BasicTableRef& r) noexcept { this->util::bind_ptr<T>::swap(r); }
+    friend void swap(BasicTableRef& a, BasicTableRef& b) noexcept { a.swap(b); }
+
+    template<class U>
+    friend BasicTableRef<U> unchecked_cast(BasicTableRef<Table>) noexcept;
+
+    template<class U>
+    friend BasicTableRef<const U> unchecked_cast(BasicTableRef<const Table>) noexcept;
+
+private:
+    template<class>
+    struct GetRowAccType { typedef void type; };
+
+    template<class Spec>
+    struct GetRowAccType<BasicTable<Spec>> {
+        typedef typename BasicTable<Spec>::RowAccessor type;
+    };
+    template<class Spec>
+    struct GetRowAccType<const BasicTable<Spec>> {
+        typedef typename BasicTable<Spec>::ConstRowAccessor type;
+    };
+    typedef typename GetRowAccType<T>::type RowAccessor;
+
+public:
+    /// Same as 'table[i]' where 'table' is the referenced table.
+    RowAccessor operator[](size_t i) const noexcept { return (*this->get())[i]; }
+
+private:
+    friend class SubtableColumnBase;
+    friend class Table;
+    friend class Group;
+
+    template<class>
+    friend class BasicTable;
+
+    template<class>
+    friend class BasicTableRef;
+
+    explicit BasicTableRef(T* t) noexcept: util::bind_ptr<T>(t) {}
+
+    typedef typename util::bind_ptr<T>::casting_move_tag casting_move_tag;
+    template<class U>
+    BasicTableRef(BasicTableRef<U>* r, casting_move_tag) noexcept:
+        util::bind_ptr<T>(r, casting_move_tag()) {}
+};
+
+
+typedef BasicTableRef<Table> TableRef;
+typedef BasicTableRef<const Table> ConstTableRef;
+
+
+template<class C, class T, class U>
+inline std::basic_ostream<C,T>& operator<<(std::basic_ostream<C,T>& out, const BasicTableRef<U>& p)
+{
+    out << static_cast<const void*>(&*p);
+    return out;
+}
+
+template<class T>
+inline BasicTableRef<T> unchecked_cast(TableRef t) noexcept
+{
+    return BasicTableRef<T>(&t, typename BasicTableRef<T>::casting_move_tag());
+}
+
+template<class T>
+inline BasicTableRef<const T> unchecked_cast(ConstTableRef t) noexcept
+{
+    return BasicTableRef<const T>(&t, typename BasicTableRef<T>::casting_move_tag());
+}
+
+
+//@{
+/// Comparison
+template<class T, class U>
+bool operator==(T*, const BasicTableRef<U>&) noexcept;
+template<class T, class U>
+bool operator!=(T*, const BasicTableRef<U>&) noexcept;
+template<class T, class U>
+bool operator<(T*, const BasicTableRef<U>&) noexcept;
+template<class T, class U>
+bool operator>(T*, const BasicTableRef<U>&) noexcept;
+template<class T, class U>
+bool operator<=(T*, const BasicTableRef<U>&) noexcept;
+template<class T, class U>
+bool operator>=(T*, const BasicTableRef<U>&) noexcept;
+//@}
+
+
+
+
+
+// Implementation:
+
+template<class T>
+inline BasicTableRef<T>& BasicTableRef<T>::operator=(const BasicTableRef& r) noexcept
+{
+    this->util::bind_ptr<T>::operator=(r);
+    return *this;
+}
+
+template<class T>
+template<class U>
+inline BasicTableRef<T>& BasicTableRef<T>::operator=(const BasicTableRef<U>& r) noexcept
+{
+    this->util::bind_ptr<T>::operator=(r);
+    return *this;
+}
+
+template<class T>
+inline BasicTableRef<T>& BasicTableRef<T>::operator=(BasicTableRef&& r) noexcept
+{
+    this->util::bind_ptr<T>::operator=(std::move(r));
+    return *this;
+}
+
+template<class T>
+template<class U>
+inline BasicTableRef<T>& BasicTableRef<T>::operator=(BasicTableRef<U>&& r) noexcept
+{
+    this->util::bind_ptr<T>::operator=(std::move(r));
+    return *this;
+}
+
+template<class T>
+template<class U>
+bool BasicTableRef<T>::operator==(const BasicTableRef<U>& p) const noexcept
+{
+    return get() == p.get();
+}
+
+template<class T>
+template<class U>
+bool BasicTableRef<T>::operator==(U* p) const noexcept
+{
+    return get() == p;
+}
+
+template<class T>
+template<class U>
+bool BasicTableRef<T>::operator!=(const BasicTableRef<U>& p) const noexcept
+{
+    return get() != p.get();
+}
+
+template<class T>
+template<class U>
+bool BasicTableRef<T>::operator!=(U* p) const noexcept
+{
+    return get() != p;
+}
+
+template<class T>
+template<class U>
+bool BasicTableRef<T>::operator<(const BasicTableRef<U>& p) const noexcept
+{
+    return get() < p.get();
+}
+
+template<class T>
+template<class U>
+bool BasicTableRef<T>::operator<(U* p) const noexcept
+{
+    return get() < p;
+}
+
+template<class T>
+template<class U>
+bool BasicTableRef<T>::operator>(const BasicTableRef<U>& p) const noexcept
+{
+    return get() > p.get();
+}
+
+template<class T>
+template<class U>
+bool BasicTableRef<T>::operator>(U* p) const noexcept
+{
+    return get() > p;
+}
+
+template<class T>
+template<class U>
+bool BasicTableRef<T>::operator<=(const BasicTableRef<U>& p) const noexcept
+{
+    return get() <= p.get();
+}
+
+template<class T>
+template<class U>
+bool BasicTableRef<T>::operator<=(U* p) const noexcept
+{
+    return get() <= p;
+}
+
+template<class T>
+template<class U>
+bool BasicTableRef<T>::operator>=(const BasicTableRef<U>& p) const noexcept
+{
+    return get() >= p.get();
+}
+
+template<class T>
+template<class U>
+bool BasicTableRef<T>::operator>=(U* p) const noexcept
+{
+    return get() >= p;
+}
+
+template<class T, class U>
+bool operator==(T* a, const BasicTableRef<U>& b) noexcept
+{
+    return b == a;
+}
+
+template<class T, class U>
+bool operator!=(T* a, const BasicTableRef<U>& b) noexcept
+{
+    return b != a;
+}
+
+template<class T, class U>
+bool operator<(T* a, const BasicTableRef<U>& b) noexcept
+{
+    return b > a;
+}
+
+template<class T, class U>
+bool operator>(T* a, const BasicTableRef<U>& b) noexcept
+{
+    return b < a;
+}
+
+template<class T, class U>
+bool operator<=(T* a, const BasicTableRef<U>& b) noexcept
+{
+    return b >= a;
+}
+
+template<class T, class U>
+bool operator>=(T* a, const BasicTableRef<U>& b) noexcept
+{
+    return b <= a;
+}
+
+
+} // namespace realm
+
+#endif // REALM_TABLE_REF_HPP
diff --git a/Pods/Realm/include/core/realm/table_view.hpp b/Pods/Realm/include/core/realm/table_view.hpp
new file mode 100644
index 0000000..bdcbe74
--- /dev/null
+++ b/Pods/Realm/include/core/realm/table_view.hpp
@@ -0,0 +1,1676 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_TABLE_VIEW_HPP
+#define REALM_TABLE_VIEW_HPP
+
+#include <realm/views.hpp>
+#include <realm/table.hpp>
+#include <realm/link_view.hpp>
+#include <realm/column.hpp>
+#include <realm/exceptions.hpp>
+#include <realm/util/features.h>
+#include <realm/group_shared.hpp>
+
+namespace realm {
+
+// Views, tables and synchronization between them:
+//
+// Views are built through queries against either tables or another view.
+// Views may be restricted to only hold entries provided by another view.
+// this other view is called the "restricting view".
+// Views may be sorted in ascending or descending order of values in one ore more columns.
+//
+// Views remember the query from which it was originally built.
+// Views remember the table from which it was originally built.
+// Views remember a restricting view if one was used when it was originally built.
+// Views remember the sorting criteria (columns and direction)
+//
+// A view may be operated in one of two distinct modes: *reflective* and *imperative*.
+// Sometimes the term "reactive" is used instead of "reflective" with the same meaning.
+//
+// Reflective views:
+// - A reflective view *always* *reflect* the result of running the query.
+//   If the underlying tables or tableviews change, the reflective view changes as well.
+//   A reflective view may need to rerun the query it was generated from, a potentially
+//   costly operation which happens on demand.
+// - It does not matter whether changes are explicitly done within the transaction, or
+//   occur implicitly as part of advance_read() or promote_to_write().
+//
+// Imperative views:
+// - An imperative view only *initially* holds the result of the query. An imperative
+//   view *never* reruns the query. To force the view to match it's query (by rerunning it),
+//   the view must be operated in reflective mode.
+//   An imperative view can be modified explicitly. References can be added, removed or
+//   changed.
+//
+// - In imperative mode, the references in the view tracks movement of the referenced data:
+//   If you delete an entry which is referenced from a view, said reference is detached,
+//   not removed.
+// - It does not matter whether the delete is done in-line (as part of the current transaction),
+//   or if it is done implicitly as part of advance_read() or promote_to_write().
+//
+// The choice between reflective and imperative views might eventually be represented by a
+// switch on the tableview, but isn't yet. For now, clients (bindings) must call sync_if_needed()
+// to get reflective behavior.
+//
+// Use cases:
+//
+// 1. Presenting data
+// The first use case (and primary motivator behind the reflective view) is to just track
+// and present the state of the database. In this case, the view is operated in reflective
+// mode, it is not modified within the transaction, and it is not used to modify data in
+// other parts of the database.
+//
+// 2. Handover
+// The second use case is "handover." The implicit rerun of the query in our first use case
+// may be too costly to be acceptable on the main thread. Instead you want to run the query
+// on a worker thread, but display it on the main thread. To achieve this, you need two
+// SharedGroups locked on to the same version of the database. If you have that, you can
+// *handover* a view from one thread/SharedGroup to the other.
+//
+// Handover is a two-step procedure. First, the accessors are *exported* from one SharedGroup,
+// called the sourcing group, then it is *imported* into another SharedGroup, called the
+// receiving group. The thread associated with the sourcing SharedGroup will be
+// responsible for the export operation, while the thread associated with the receiving
+// SharedGroup will do the import operation.
+//
+// 3. Iterating a view and changing data
+// The third use case (and a motivator behind the imperative view) is when you want
+// to make changes to the database in accordance with a query result. Imagine you want to
+// find all employees with a salary below a limit and raise their salaries to the limit (pseudocode):
+//
+//    promote_to_write();
+//    view = table.where().less_than(salary_column,limit).find_all();
+//    for (size_t i = 0; i < view.size(); ++i) {
+//        view.set_int(salary_column, i, limit);
+//        // add this to get reflective mode: view.sync_if_needed();
+//    }
+//    commit_and_continue_as_read();
+//
+// This is idiomatic imperative code and it works if the view is operated in imperative mode.
+//
+// If the view is operated in reflective mode, the behaviour surprises most people: When the
+// first salary is changed, the entry no longer fullfills the query, so it is dropped from the
+// view implicitly. view[0] is removed, view[1] moves to view[0] and so forth. But the next
+// loop iteration has i=1 and refers to view[1], thus skipping view[0]. The end result is that
+// every other employee get a raise, while the others don't.
+//
+// 4. Iterating intermixed with implicit updates
+// This leads us to use case 4, which is similar to use case 3, but uses promote_to_write()
+// intermixed with iterating a view. This is actually quite important to some, who do not want
+// to end up with a large write transaction.
+//
+//    view = table.where().less_than(salary_column,limit).find_all();
+//    for (size_t i = 0; i < view.size(); ++i) {
+//        promote_to_write();
+//        view.set_int(salary_column, i, limit);
+//        commit_and_continue_as_write();
+//    }
+//
+// Anything can happen at the call to promote_to_write(). The key question then becomes: how
+// do we support a safe way of realising the original goal (raising salaries) ?
+//
+// using the imperative operating mode:
+//
+//    view = table.where().less_than(salary_column,limit).find_all();
+//    for (size_t i = 0; i < view.size(); ++i) {
+//        promote_to_write();
+//        // add r.sync_if_needed(); to get reflective mode
+//        if (r.is_row_attached(i)) {
+//            Row r = view[i];
+//            r.set_int(salary_column, limit);
+//        }
+//        commit_and_continue_as_write();
+//    }
+//
+// This is safe, and we just aim for providing low level safety: is_row_attached() can tell
+// if the reference is valid, and the references in the view continue to point to the
+// same object at all times, also following implicit updates. The rest is up to the
+// application logic.
+//
+// It is important to see, that there is no guarantee that all relevant employees get
+// their raise in cases whith concurrent updates. At every call to promote_to_write() new
+// employees may be added to the underlying table, but as the view is in imperative mode,
+// these new employees are not added to the view. Also at promote_to_write() an existing
+// employee could recieve a (different, larger) raise which would then be overwritten and lost.
+// However, these are problems that you should expect, since the activity is spread over multiple
+// transactions.
+
+
+/// Common base class for TableView and ConstTableView.
+class TableViewBase : public RowIndexes {
+public:
+// - not in use / implemented yet:   ... explicit calls to sync_if_needed() must be used
+//                                       to get 'reflective' mode.
+//    enum mode { mode_Reflective, mode_Imperative };
+//    void set_operating_mode(mode);
+//    mode get_operating_mode();
+    bool is_empty() const noexcept;
+
+    // Tells if the table that this TableView points at still exists or has been deleted.
+    bool is_attached() const noexcept;
+
+    bool is_row_attached(size_t row_ndx) const noexcept;
+    size_t size() const noexcept;
+    size_t num_attached_rows() const noexcept;
+
+    // Get the query used to create this TableView
+    // The query will have a null source table if this tv was not created from
+    // a query
+    const Query& get_query() const noexcept;
+
+    // Column information
+    const ColumnBase& get_column_base(size_t index) const;
+
+    size_t      get_column_count() const noexcept;
+    StringData  get_column_name(size_t column_ndx) const noexcept;
+    size_t      get_column_index(StringData name) const;
+    DataType    get_column_type(size_t column_ndx) const noexcept;
+
+    // Getting values
+    int64_t     get_int(size_t column_ndx, size_t row_ndx) const noexcept;
+    bool        get_bool(size_t column_ndx, size_t row_ndx) const noexcept;
+    OldDateTime get_olddatetime(size_t column_ndx, size_t row_ndx) const noexcept;
+    Timestamp   get_timestamp(size_t column_ndx, size_t row_ndx) const noexcept;
+    float       get_float(size_t column_ndx, size_t row_ndx) const noexcept;
+    double      get_double(size_t column_ndx, size_t row_ndx) const noexcept;
+    StringData  get_string(size_t column_ndx, size_t row_ndx) const noexcept;
+    BinaryData  get_binary(size_t column_ndx, size_t row_ndx) const noexcept;
+    Mixed       get_mixed(size_t column_ndx, size_t row_ndx) const noexcept;
+    DataType    get_mixed_type(size_t column_ndx, size_t row_ndx) const noexcept;
+    size_t      get_link(size_t column_ndx, size_t row_ndx) const noexcept;
+
+    // Links
+    bool is_null_link(size_t column_ndx, size_t row_ndx) const noexcept;
+
+    // Subtables
+    size_t get_subtable_size(size_t column_ndx, size_t row_ndx) const noexcept;
+
+    // Searching (Int and String)
+    size_t find_first_int(size_t column_ndx, int64_t value) const;
+    size_t find_first_bool(size_t column_ndx, bool value) const;
+    size_t find_first_olddatetime(size_t column_ndx, OldDateTime value) const;
+    size_t find_first_float(size_t column_ndx, float value) const;
+    size_t find_first_double(size_t column_ndx, double value) const;
+    size_t find_first_string(size_t column_ndx, StringData value) const;
+    size_t find_first_binary(size_t column_ndx, BinaryData value) const;
+
+    // Aggregate functions. count_target is ignored by all <int
+    // function> except Count. Hack because of bug in optional
+    // arguments in clang and vs2010 (fixed in 2012)
+    template<int function, typename T, typename R, class ColType>
+    R aggregate(R (ColType::*aggregateMethod)(size_t, size_t, size_t, size_t*) const,
+        size_t column_ndx, T count_target, size_t* return_ndx = nullptr) const;
+
+    int64_t sum_int(size_t column_ndx) const;
+    int64_t maximum_int(size_t column_ndx, size_t* return_ndx = nullptr) const;
+    int64_t minimum_int(size_t column_ndx, size_t* return_ndx = nullptr) const;
+    double average_int(size_t column_ndx, size_t* value_count = nullptr) const;
+    size_t count_int(size_t column_ndx, int64_t target) const;
+
+    double sum_float(size_t column_ndx) const;
+    float maximum_float(size_t column_ndx, size_t* return_ndx = nullptr) const;
+    float minimum_float(size_t column_ndx, size_t* return_ndx = nullptr) const;
+    double average_float(size_t column_ndx, size_t* value_count = nullptr) const;
+    size_t count_float(size_t column_ndx, float target) const;
+
+    double sum_double(size_t column_ndx) const;
+    double maximum_double(size_t column_ndx, size_t* return_ndx = nullptr) const;
+    double minimum_double(size_t column_ndx, size_t* return_ndx = nullptr) const;
+    double average_double(size_t column_ndx, size_t* value_count = nullptr) const;
+    size_t count_double(size_t column_ndx, double target) const;
+
+    OldDateTime maximum_olddatetime(size_t column_ndx, size_t* return_ndx = nullptr) const;
+    OldDateTime minimum_olddatetime(size_t column_ndx, size_t* return_ndx = nullptr) const;
+
+    Timestamp minimum_timestamp(size_t column_ndx, size_t* return_ndx = nullptr) const;
+    Timestamp maximum_timestamp(size_t column_ndx, size_t* return_ndx = nullptr) const;
+    size_t count_timestamp(size_t column_ndx, Timestamp target) const;
+
+    void apply_same_order(TableViewBase& order);
+
+    // Simple pivot aggregate method. Experimental! Please do not
+    // document method publicly.
+    void aggregate(size_t group_by_column, size_t aggr_column,
+                   Table::AggrType op, Table& result) const;
+
+    // Get row index in the source table this view is "looking" at.
+    size_t get_source_ndx(size_t row_ndx) const noexcept;
+
+    /// Search this view for the specified source table row (specified by its
+    /// index in the source table). If found, the index of that row within this
+    /// view is returned, otherwise `realm::not_found` is returned.
+    size_t find_by_source_ndx(size_t source_ndx) const noexcept;
+
+    // Conversion
+    void to_json(std::ostream&) const;
+    void to_string(std::ostream&, size_t limit = 500) const;
+    void row_to_string(size_t row_ndx, std::ostream&) const;
+
+    // Determine if the view is 'in sync' with the underlying table
+    // as well as other views used to generate the view. Note that updates
+    // through views maintains synchronization between view and table.
+    // It doesnt by itself maintain other views as well. So if a view
+    // is generated from another view (not a table), updates may cause
+    // that view to be outdated, AND as the generated view depends upon
+    // it, it too will become outdated.
+    bool is_in_sync() const;
+
+    // Tells if this TableView depends on a LinkList or row that has been deleted.
+    bool depends_on_deleted_object() const;
+
+    // Synchronize a view to match a table or tableview from which it
+    // has been derived. Synchronization is achieved by rerunning the
+    // query used to generate the view. If derived from another view, that
+    // view will be synchronized as well.
+    //
+    // "live" or "reactive" views are implemented by calling sync_if_needed
+    // before any of the other access-methods whenever the view may have become
+    // outdated.
+    //
+    // This will make the TableView empty and in sync with the highest possible table version
+    // if the TableView depends on an object (LinkView or row) that has been deleted.
+    uint_fast64_t sync_if_needed() const;
+
+    // Set this undetached TableView to be a distinct view, and sync immediately.
+    void sync_distinct_view(size_t column_ndx);
+
+    // Re-sort view according to last used criterias
+    void re_sort();
+
+    // Sort m_row_indexes according to one column
+    void sort(size_t column, bool ascending = true);
+
+    // Sort m_row_indexes according to multiple columns
+    void sort(std::vector<size_t> columns, std::vector<bool> ascending);
+
+    // Remove rows that are duplicated with respect to the column set passed as argument.
+    // distinct() will preserve the original order of the row pointers, also if the order is a result of sort()
+    // If two rows are indentical (for the given set of distinct-columns), then the last row is removed.
+    // You can call sync_if_needed() to update the distinct view, just like you can for a sorted view.
+    // Each time you call distinct() it will first fetch the full original TableView contents and then apply
+    // distinct() on that. So it distinct() does not filter the result of the previous distinct().
+    void distinct(size_t column);
+    void distinct(std::vector<size_t> columns);
+
+    // Returns whether the rows are guaranteed to be in table order.
+    // This is true only of unsorted TableViews created from either:
+    // - Table::find_all()
+    // - Query::find_all() when the query is not restricted to a view.
+    bool is_in_table_order() const;
+
+    virtual ~TableViewBase() noexcept;
+
+    virtual std::unique_ptr<TableViewBase> clone() const
+    {
+        return std::unique_ptr<TableViewBase>(new TableViewBase(*this));
+    }
+
+protected:
+    // This TableView can be "born" from 5 different sources:
+    // - LinkView
+    // - Table::find_all()
+    // - Query::find_all()
+    // - Table::get_distinct_view()
+    // - Table::get_backlink_view()
+    // Return the version of the source it was created from.
+    uint64_t outside_version() const;
+
+    void do_sync();
+
+    // Actual sorting facility is provided by the base class:
+    using RowIndexes::sort;
+
+    // Null if, and only if, the view is detached.
+    mutable TableRef m_table;
+
+    // Contains a reference to the table that is the target of the link.
+    // Null unless this TableView was created using Table::get_backlink_view.
+    mutable TableRef m_linked_table;
+    // The index of the link column that this view contain backlinks for.
+    size_t m_linked_column;
+    // The target row that rows in this view link to.
+    ConstRow m_linked_row;
+
+    // If this TableView was created from a LinkView, then this reference points to it. Otherwise it's 0
+    mutable ConstLinkViewRef m_linkview_source;
+
+    // m_distinct_column_source != npos if this view was created from distinct values in a column of m_table.
+    size_t m_distinct_column_source = npos;
+
+    // If m_distinct_columns.size() > 0, it means that this TableView has had called TableView::distinct() and
+    // must only contain unique rows with respect to that column set of the parent table
+    std::vector<size_t> m_distinct_columns;
+
+    Sorter m_sorting_predicate; // Stores sorting criterias (columns + ascending)
+    bool m_auto_sort = false;
+
+
+    // A valid query holds a reference to its table which must match our m_table.
+    // hence we can use a query with a null table reference to indicate that the view
+    // was NOT generated by a query, but follows a table directly.
+    Query m_query;
+    // parameters for findall, needed to rerun the query
+    size_t m_start;
+    size_t m_end;
+    size_t m_limit;
+
+    mutable util::Optional<uint_fast64_t> m_last_seen_version;
+
+    size_t m_num_detached_refs = 0;
+    /// Construct null view (no memory allocated).
+    TableViewBase();
+
+    /// Construct empty view, ready for addition of row indices.
+    TableViewBase(Table* parent);
+    TableViewBase(Table* parent, Query& query, size_t start, size_t end, size_t limit);
+    TableViewBase(Table *parent, Table *linked_table, size_t column, BasicRowExpr<const Table> row);
+
+    /// Copy constructor.
+    TableViewBase(const TableViewBase&);
+
+    /// Move constructor.
+    TableViewBase(TableViewBase&&) noexcept;
+
+    TableViewBase& operator=(const TableViewBase&);
+    TableViewBase& operator=(TableViewBase&&) noexcept;
+
+    template<class R, class V>
+    static R find_all_integer(V*, size_t, int64_t);
+
+    template<class R, class V>
+    static R find_all_float(V*, size_t, float);
+
+    template<class R, class V>
+    static R find_all_double(V*, size_t, double);
+
+    template<class R, class V>
+    static R find_all_string(V*, size_t, StringData);
+
+    using HandoverPatch = TableViewHandoverPatch;
+
+    // handover machinery entry points based on dynamic type. These methods:
+    // a) forward their calls to the static type entry points.
+    // b) new/delete patch data structures.
+    virtual std::unique_ptr<TableViewBase> clone_for_handover(std::unique_ptr<HandoverPatch>& patch,
+                                                              ConstSourcePayload mode) const
+    {
+        patch.reset(new HandoverPatch);
+        std::unique_ptr<TableViewBase> retval(new TableViewBase(*this, *patch, mode));
+        return retval;
+    }
+
+    virtual std::unique_ptr<TableViewBase> clone_for_handover(std::unique_ptr<HandoverPatch>& patch,
+                                                              MutableSourcePayload mode)
+    {
+        patch.reset(new HandoverPatch);
+        std::unique_ptr<TableViewBase> retval(new TableViewBase(*this, *patch, mode));
+        return retval;
+    }
+
+    virtual void apply_and_consume_patch(std::unique_ptr<HandoverPatch>& patch, Group& group)
+    {
+        apply_patch(*patch, group);
+        patch.reset();
+    }
+    // handover machinery entry points based on static type
+    void apply_patch(HandoverPatch& patch, Group& group);
+    TableViewBase(const TableViewBase& source, HandoverPatch& patch,
+                  ConstSourcePayload mode);
+    TableViewBase(TableViewBase& source, HandoverPatch& patch,
+                  MutableSourcePayload mode);
+
+private:
+    void detach() const noexcept; // may have to remove const
+    size_t find_first_integer(size_t column_ndx, int64_t value) const;
+    template<class oper>
+    Timestamp minmax_timestamp(size_t column_ndx, size_t* return_ndx) const;
+
+    friend class Table;
+    friend class Query;
+    friend class SharedGroup;
+    template<class Tab, class View, class Impl>
+    friend class BasicTableViewBase;
+
+    // Called by table to adjust any row references:
+    void adj_row_acc_insert_rows(size_t row_ndx, size_t num_rows) noexcept;
+    void adj_row_acc_erase_row(size_t row_ndx) noexcept;
+    void adj_row_acc_move_over(size_t from_row_ndx, size_t to_row_ndx) noexcept;
+    void adj_row_acc_clear() noexcept;
+
+    template<typename Tab>
+    friend class BasicTableView;
+};
+
+
+inline void TableViewBase::detach() const noexcept // may have to remove const
+{
+    m_table = TableRef();
+}
+
+
+class ConstTableView;
+
+
+enum class RemoveMode {
+    ordered,
+    unordered
+};
+
+
+/// A TableView gives read and write access to the parent table.
+///
+/// A 'const TableView' cannot be changed (e.g. sorted), nor can the
+/// parent table be modified through it.
+///
+/// A TableView is both copyable and movable.
+class TableView: public TableViewBase {
+public:
+    TableView();
+    TableView(const TableView&) = default;
+    TableView(TableView&&) = default;
+    ~TableView() noexcept;
+    TableView& operator=(const TableView&) = default;
+    TableView& operator=(TableView&&) = default;
+
+    // Rows
+    typedef BasicRowExpr<Table> RowExpr;
+    typedef BasicRowExpr<const Table> ConstRowExpr;
+    RowExpr get(size_t row_ndx) noexcept;
+    ConstRowExpr get(size_t row_ndx) const noexcept;
+    RowExpr front() noexcept;
+    ConstRowExpr front() const noexcept;
+    RowExpr back() noexcept;
+    ConstRowExpr back() const noexcept;
+    RowExpr operator[](size_t row_ndx) noexcept;
+    ConstRowExpr operator[](size_t row_ndx) const noexcept;
+
+    // Setting values
+    void set_int(size_t column_ndx, size_t row_ndx, int64_t value);
+    void set_bool(size_t column_ndx, size_t row_ndx, bool value);
+    void set_olddatetime(size_t column_ndx, size_t row_ndx, OldDateTime value);
+    void set_timestamp(size_t column_ndx, size_t row_ndx, Timestamp value);
+    template<class E>
+    void set_enum(size_t column_ndx, size_t row_ndx, E value);
+    void set_float(size_t column_ndx, size_t row_ndx, float value);
+    void set_double(size_t column_ndx, size_t row_ndx, double value);
+    void set_string(size_t column_ndx, size_t row_ndx, StringData value);
+    void set_binary(size_t column_ndx, size_t row_ndx, BinaryData value);
+    void set_mixed(size_t column_ndx, size_t row_ndx, Mixed value);
+    void set_subtable(size_t column_ndx,size_t row_ndx, const Table* table);
+    void set_link(size_t column_ndx, size_t row_ndx, size_t target_row_ndx);
+
+    // Subtables
+    TableRef      get_subtable(size_t column_ndx, size_t row_ndx);
+    ConstTableRef get_subtable(size_t column_ndx, size_t row_ndx) const;
+    void          clear_subtable(size_t column_ndx, size_t row_ndx);
+
+    // Links
+    TableRef get_link_target(size_t column_ndx) noexcept;
+    ConstTableRef get_link_target(size_t column_ndx) const noexcept;
+    void nullify_link(size_t column_ndx, size_t row_ndx);
+
+    //@{
+    /// \brief Remove the specified row (or rows) from the underlying table.
+    ///
+    /// remove() removes the specified row from the underlying table,
+    /// remove_last() removes the last row in the table view from the underlying
+    /// table, and clear removes all the rows in the table view from the
+    /// underlying table.
+    ///
+    /// When rows are removed from the underlying table, they will by necessity
+    /// also be removed from the table view.
+    ///
+    /// The order of the remaining rows in the the table view will be maintained
+    /// regardless of the value passed for \a underlying_mode.
+    ///
+    /// \param row_ndx The index within this table view of the row to be
+    /// removed.
+    ///
+    /// \param underlying_mode If set to RemoveMode::ordered (the default), the
+    /// rows will be removed from the underlying table in a way that maintains
+    /// the order of the remaining rows in the underlying table. If set to
+    /// RemoveMode::unordered, the order of the remaining rows in the underlying
+    /// table will not in general be maintaind, but the operation will generally
+    /// be much faster. In any case, the order of remaining rows in the table
+    /// view will not be affected.
+    void remove(size_t row_ndx, RemoveMode underlying_mode = RemoveMode::ordered);
+    void remove_last(RemoveMode underlying_mode = RemoveMode::ordered);
+    void clear(RemoveMode underlying_mode = RemoveMode::ordered);
+    //@}
+
+    // Searching (Int and String)
+    TableView       find_all_int(size_t column_ndx, int64_t value);
+    ConstTableView  find_all_int(size_t column_ndx, int64_t value) const;
+    TableView       find_all_bool(size_t column_ndx, bool value);
+    ConstTableView  find_all_bool(size_t column_ndx, bool value) const;
+    TableView       find_all_olddatetime(size_t column_ndx, OldDateTime value);
+    ConstTableView  find_all_olddatetime(size_t column_ndx, OldDateTime value) const;
+    TableView       find_all_float(size_t column_ndx, float value);
+    ConstTableView  find_all_float(size_t column_ndx, float value) const;
+    TableView       find_all_double(size_t column_ndx, double value);
+    ConstTableView  find_all_double(size_t column_ndx, double value) const;
+    TableView       find_all_string(size_t column_ndx, StringData value);
+    ConstTableView  find_all_string(size_t column_ndx, StringData value) const;
+    // FIXME: Need: TableView find_all_binary(size_t column_ndx, BinaryData value);
+    // FIXME: Need: ConstTableView find_all_binary(size_t column_ndx, BinaryData value) const;
+
+    Table& get_parent() noexcept;
+    const Table& get_parent() const noexcept;
+
+    std::unique_ptr<TableViewBase> clone() const override
+    {
+        return std::unique_ptr<TableViewBase>(new TableView(*this));
+    }
+
+    std::unique_ptr<TableViewBase>
+    clone_for_handover(std::unique_ptr<HandoverPatch>& patch, ConstSourcePayload mode) const override
+    {
+        patch.reset(new HandoverPatch);
+        std::unique_ptr<TableViewBase> retval(new TableView(*this, *patch, mode));
+        return retval;
+    }
+
+    std::unique_ptr<TableViewBase>
+    clone_for_handover(std::unique_ptr<HandoverPatch>& patch, MutableSourcePayload mode) override
+    {
+        patch.reset(new HandoverPatch);
+        std::unique_ptr<TableViewBase> retval(new TableView(*this, *patch, mode));
+        return retval;
+    }
+
+    // this one is here to follow the general scheme, it is not really needed, the
+    // one in the base class would be sufficient
+    void apply_and_consume_patch(std::unique_ptr<HandoverPatch>& patch, Group& group) override
+    {
+        apply_patch(*patch, group);
+        patch.reset();
+    }
+
+    TableView(const TableView& src, HandoverPatch& patch, ConstSourcePayload mode)
+        : TableViewBase(src, patch, mode)
+    {
+        // empty
+    }
+
+    TableView(TableView& src, HandoverPatch& patch, MutableSourcePayload mode)
+        : TableViewBase(src, patch, mode)
+    {
+        // empty
+    }
+
+    // only here to follow the general scheme, base class method could be used instead
+    void apply_patch(HandoverPatch& patch, Group& group)
+    {
+        TableViewBase::apply_patch(patch, group);
+    }
+
+private:
+    TableView(Table& parent);
+    TableView(Table& parent, Query& query, size_t start, size_t end, size_t limit);
+    TableView(Table *parent, Table *linked_table, size_t column, ConstRowExpr row);
+
+    TableView find_all_integer(size_t column_ndx, int64_t value);
+    ConstTableView find_all_integer(size_t column_ndx, int64_t value) const;
+
+    friend class ConstTableView;
+    friend class Table;
+    friend class Query;
+    friend class TableViewBase;
+    friend class ListviewNode;
+    friend class LinkView;
+    template<typename, typename, typename>
+    friend class BasicTableViewBase;
+};
+
+
+
+
+/// A ConstTableView gives read access to the parent table, but no
+/// write access. The view itself, though, can be changed, for
+/// example, it can be sorted.
+///
+/// Note that methods are declared 'const' if, and only if they leave
+/// the view unmodified, and this is irrespective of whether they
+/// modify the parent table.
+///
+/// A ConstTableView has both copy and move semantics. See TableView
+/// for more on this.
+class ConstTableView: public TableViewBase {
+public:
+    ConstTableView();
+    ~ConstTableView() noexcept;
+    ConstTableView(const ConstTableView&) = default;
+    ConstTableView(ConstTableView&&) = default;
+    ConstTableView& operator=(const ConstTableView&) = default;
+    ConstTableView& operator=(ConstTableView&&) = default;
+
+    ConstTableView(const TableView&);
+    ConstTableView(TableView&&);
+    ConstTableView& operator=(const TableView&);
+    ConstTableView& operator=(TableView&&);
+
+    // Rows
+    typedef BasicRowExpr<const Table> ConstRowExpr;
+    ConstRowExpr get(size_t row_ndx) const noexcept;
+    ConstRowExpr front() const noexcept;
+    ConstRowExpr back() const noexcept;
+    ConstRowExpr operator[](size_t row_ndx) const noexcept;
+
+    // Subtables
+    ConstTableRef get_subtable(size_t column_ndx, size_t row_ndx) const;
+
+    // Links
+    ConstTableRef get_link_target(size_t column_ndx) const noexcept;
+
+    // Searching (Int and String)
+    ConstTableView find_all_int(size_t column_ndx, int64_t value) const;
+    ConstTableView find_all_bool(size_t column_ndx, bool value) const;
+    ConstTableView find_all_olddatetime(size_t column_ndx, OldDateTime value) const;
+    ConstTableView find_all_float(size_t column_ndx, float value) const;
+    ConstTableView find_all_double(size_t column_ndx, double value) const;
+    ConstTableView find_all_string(size_t column_ndx, StringData value) const;
+
+    const Table& get_parent() const noexcept;
+
+    std::unique_ptr<TableViewBase> clone() const override
+    {
+        return std::unique_ptr<TableViewBase>(new ConstTableView(*this));
+    }
+
+    std::unique_ptr<TableViewBase>
+    clone_for_handover(std::unique_ptr<HandoverPatch>& patch, ConstSourcePayload mode) const override
+    {
+        patch.reset(new HandoverPatch);
+        std::unique_ptr<TableViewBase> retval(new ConstTableView(*this, *patch, mode));
+        return retval;
+    }
+
+    std::unique_ptr<TableViewBase>
+    clone_for_handover(std::unique_ptr<HandoverPatch>& patch, MutableSourcePayload mode) override
+    {
+        patch.reset(new HandoverPatch);
+        std::unique_ptr<TableViewBase> retval(new ConstTableView(*this, *patch, mode));
+        return retval;
+    }
+
+    // this one is here to follow the general scheme, it is not really needed, the
+    // one in the base class would be sufficient
+    void apply_and_consume_patch(std::unique_ptr<HandoverPatch>& patch, Group& group) override
+    {
+        apply_patch(*patch, group);
+        patch.reset();
+    }
+
+    ConstTableView(const ConstTableView& src, HandoverPatch& patch, ConstSourcePayload mode)
+        : TableViewBase(src, patch, mode)
+    {
+        // empty
+    }
+
+    ConstTableView(ConstTableView& src, HandoverPatch& patch, MutableSourcePayload mode)
+        : TableViewBase(src, patch, mode)
+    {
+        // empty
+    }
+
+    // only here to follow the general scheme, base class method could be used instead
+    void apply_patch(HandoverPatch& patch, Group& group)
+    {
+        TableViewBase::apply_patch(patch, group);
+    }
+
+private:
+    ConstTableView(const Table& parent);
+
+    ConstTableView find_all_integer(size_t column_ndx, int64_t value) const;
+
+    friend class TableView;
+    friend class Table;
+    friend class Query;
+    friend class TableViewBase;
+};
+
+
+// ================================================================================================
+// TableViewBase Implementation:
+
+inline const Query& TableViewBase::get_query() const noexcept
+{
+    return m_query;
+}
+
+inline bool TableViewBase::is_empty() const noexcept
+{
+    return m_row_indexes.is_empty();
+}
+
+inline bool TableViewBase::is_attached() const noexcept
+{
+    return bool(m_table);
+}
+
+inline bool TableViewBase::is_row_attached(size_t row_ndx) const noexcept
+{
+    return m_row_indexes.get(row_ndx) != detached_ref;
+}
+
+inline size_t TableViewBase::size() const noexcept
+{
+    return m_row_indexes.size();
+}
+
+inline size_t TableViewBase::num_attached_rows() const noexcept
+{
+    return m_row_indexes.size() - m_num_detached_refs;
+}
+
+inline size_t TableViewBase::get_source_ndx(size_t row_ndx) const noexcept
+{
+    return to_size_t(m_row_indexes.get(row_ndx));
+}
+
+inline size_t TableViewBase::find_by_source_ndx(size_t source_ndx) const noexcept
+{
+    REALM_ASSERT(source_ndx < m_table->size());
+    return m_row_indexes.find_first(source_ndx);
+}
+
+inline TableViewBase::TableViewBase():
+    RowIndexes(IntegerColumn::unattached_root_tag(), Allocator::get_default()) // Throws
+{
+    ref_type ref = IntegerColumn::create(m_row_indexes.get_alloc()); // Throws
+    m_row_indexes.get_root_array()->init_from_ref(ref);
+}
+
+inline TableViewBase::TableViewBase(Table* parent):
+    RowIndexes(IntegerColumn::unattached_root_tag(), Allocator::get_default()),
+    m_table(parent->get_table_ref()), // Throws
+    m_last_seen_version(m_table ? util::make_optional(m_table->m_version) : util::none)
+{
+    // FIXME: This code is unreasonably complicated because it uses `IntegerColumn` as
+    // a free-standing container, and beause `IntegerColumn` does not conform to the
+    // RAII idiom (nor should it).
+    Allocator& alloc = m_row_indexes.get_alloc();
+    _impl::DeepArrayRefDestroyGuard ref_guard(alloc);
+    ref_guard.reset(IntegerColumn::create(alloc)); // Throws
+    parent->register_view(this); // Throws
+    m_row_indexes.get_root_array()->init_from_ref(ref_guard.release());
+}
+
+inline TableViewBase::TableViewBase(Table* parent, Query& query, size_t start, size_t end, size_t limit):
+    RowIndexes(IntegerColumn::unattached_root_tag(), Allocator::get_default()), // Throws
+    m_table(parent->get_table_ref()),
+    m_query(query),
+    m_start(start),
+    m_end(end),
+    m_limit(limit),
+    m_last_seen_version(outside_version())
+{
+    // FIXME: This code is unreasonably complicated because it uses `IntegerColumn` as
+    // a free-standing container, and beause `IntegerColumn` does not conform to the
+    // RAII idiom (nor should it).
+    Allocator& alloc = m_row_indexes.get_alloc();
+    _impl::DeepArrayRefDestroyGuard ref_guard(alloc);
+    ref_guard.reset(IntegerColumn::create(alloc)); // Throws
+    parent->register_view(this); // Throws
+    m_row_indexes.get_root_array()->init_from_ref(ref_guard.release());
+}
+
+inline TableViewBase::TableViewBase(Table *parent, Table *linked_table, size_t column, BasicRowExpr<const Table> row):
+    RowIndexes(IntegerColumn::unattached_root_tag(), Allocator::get_default()),
+    m_table(parent->get_table_ref()), // Throws
+    m_linked_table(linked_table->get_table_ref()), // Throws
+    m_linked_column(column),
+    m_linked_row(row),
+    m_last_seen_version(m_table ? util::make_optional(m_table->m_version) : util::none)
+{
+    // FIXME: This code is unreasonably complicated because it uses `IntegerColumn` as
+    // a free-standing container, and beause `IntegerColumn` does not conform to the
+    // RAII idiom (nor should it).
+    Allocator& alloc = m_row_indexes.get_alloc();
+    _impl::DeepArrayRefDestroyGuard ref_guard(alloc);
+    ref_guard.reset(IntegerColumn::create(alloc)); // Throws
+    parent->register_view(this); // Throws
+    m_row_indexes.get_root_array()->init_from_ref(ref_guard.release());
+}
+
+inline TableViewBase::TableViewBase(const TableViewBase& tv):
+    RowIndexes(IntegerColumn::unattached_root_tag(), Allocator::get_default()),
+    m_table(tv.m_table),
+    m_linked_table(tv.m_linked_table),
+    m_linked_column(tv.m_linked_column),
+    m_linked_row(tv.m_linked_row),
+    m_linkview_source(tv.m_linkview_source),
+    m_distinct_column_source(tv.m_distinct_column_source),
+    m_distinct_columns(std::move(tv.m_distinct_columns)),
+    m_sorting_predicate(std::move(tv.m_sorting_predicate)),
+    m_auto_sort(tv.m_auto_sort),
+    m_query(tv.m_query),
+    m_start(tv.m_start),
+    m_end(tv.m_end),
+    m_limit(tv.m_limit),
+    m_last_seen_version(tv.m_last_seen_version),
+    m_num_detached_refs(tv.m_num_detached_refs)
+{
+    // FIXME: This code is unreasonably complicated because it uses `IntegerColumn` as
+    // a free-standing container, and beause `IntegerColumn` does not conform to the
+    // RAII idiom (nor should it).
+    Allocator& alloc = m_row_indexes.get_alloc();
+    MemRef mem = tv.m_row_indexes.get_root_array()->clone_deep(alloc); // Throws
+    _impl::DeepArrayRefDestroyGuard ref_guard(mem.get_ref(), alloc);
+    if (m_table)
+        m_table->register_view(this); // Throws
+    m_row_indexes.get_root_array()->init_from_mem(mem);
+    ref_guard.release();
+}
+
+inline TableViewBase::TableViewBase(TableViewBase&& tv) noexcept:
+    RowIndexes(std::move(tv.m_row_indexes)),
+    m_table(std::move(tv.m_table)),
+    m_linked_table(std::move(tv.m_linked_table)),
+    m_linked_column(tv.m_linked_column),
+    m_linked_row(tv.m_linked_row),
+    m_linkview_source(std::move(tv.m_linkview_source)),
+    m_distinct_column_source(tv.m_distinct_column_source),
+    m_distinct_columns(std::move(tv.m_distinct_columns)),
+    m_sorting_predicate(std::move(tv.m_sorting_predicate)),
+    m_auto_sort(tv.m_auto_sort),
+    m_query(std::move(tv.m_query)),
+    m_start(tv.m_start),
+    m_end(tv.m_end),
+    m_limit(tv.m_limit),
+    // if we are created from a table view which is outdated, take care to use the outdated
+    // version number so that we can later trigger a sync if needed.
+    m_last_seen_version(tv.m_last_seen_version),
+    m_num_detached_refs(tv.m_num_detached_refs)
+{
+    if (m_table)
+        m_table->move_registered_view(&tv, this);
+}
+
+inline TableViewBase::~TableViewBase() noexcept
+{
+    if (m_table) {
+        m_table->unregister_view(this);
+        m_table = TableRef();
+    }
+    m_row_indexes.destroy(); // Shallow
+}
+
+inline TableViewBase& TableViewBase::operator=(TableViewBase&& tv) noexcept
+{
+    if (m_table)
+        m_table->unregister_view(this);
+    m_table = std::move(tv.m_table);
+    if (m_table)
+        m_table->move_registered_view(&tv, this);
+
+    m_row_indexes.move_assign(tv.m_row_indexes);
+    m_query = std::move(tv.m_query);
+    m_num_detached_refs = tv.m_num_detached_refs;
+    m_last_seen_version = tv.m_last_seen_version;
+    m_auto_sort = tv.m_auto_sort;
+    m_start = tv.m_start;
+    m_end = tv.m_end;
+    m_limit = tv.m_limit;
+    m_linked_table = std::move(tv.m_linked_table);
+    m_linked_column = tv.m_linked_column;
+    m_linked_row = tv.m_linked_row;
+    m_linkview_source = std::move(tv.m_linkview_source);
+    m_distinct_columns = std::move(tv.m_distinct_columns);
+    m_distinct_column_source = tv.m_distinct_column_source;
+    m_sorting_predicate = std::move(tv.m_sorting_predicate);
+
+    return *this;
+}
+
+inline TableViewBase& TableViewBase::operator=(const TableViewBase& tv)
+{
+    if (this == &tv)
+        return *this;
+
+    if (m_table != tv.m_table) {
+        if (m_table)
+            m_table->unregister_view(this);
+        m_table = tv.m_table;
+        if (m_table)
+            m_table->register_view(this);
+    }
+
+    Allocator& alloc = m_row_indexes.get_alloc();
+    MemRef mem = tv.m_row_indexes.get_root_array()->clone_deep(alloc); // Throws
+    _impl::DeepArrayRefDestroyGuard ref_guard(mem.get_ref(), alloc);
+    m_row_indexes.destroy();
+    m_row_indexes.get_root_array()->init_from_mem(mem);
+    ref_guard.release();
+
+    m_query = tv.m_query;
+    m_num_detached_refs = tv.m_num_detached_refs;
+    m_last_seen_version = tv.m_last_seen_version;
+    m_auto_sort = tv.m_auto_sort;
+    m_start = tv.m_start;
+    m_end = tv.m_end;
+    m_limit = tv.m_limit;
+    m_linked_table = tv.m_linked_table;
+    m_linked_column = tv.m_linked_column;
+    m_linked_row = tv.m_linked_row;
+    m_linkview_source = tv.m_linkview_source;
+    m_distinct_columns = tv.m_distinct_columns;
+    m_distinct_column_source = tv.m_distinct_column_source;
+    m_sorting_predicate = tv.m_sorting_predicate;
+
+    return *this;
+}
+
+#define REALM_ASSERT_COLUMN(column_ndx)                                   \
+    REALM_ASSERT(m_table);                                                \
+    REALM_ASSERT(column_ndx < m_table->get_column_count())
+
+#define REALM_ASSERT_ROW(row_ndx)                                         \
+    REALM_ASSERT(m_table);                                                \
+    REALM_ASSERT(row_ndx < m_row_indexes.size())
+
+#define REALM_ASSERT_COLUMN_AND_TYPE(column_ndx, column_type)             \
+    REALM_ASSERT_COLUMN(column_ndx);                                      \
+    REALM_DIAG_PUSH();                                                    \
+    REALM_DIAG_IGNORE_TAUTOLOGICAL_COMPARE();                             \
+    REALM_ASSERT(m_table->get_column_type(column_ndx) == column_type ||   \
+                  (m_table->get_column_type(column_ndx) == type_OldDateTime && column_type == type_Int)); \
+    REALM_DIAG_POP()
+
+#define REALM_ASSERT_INDEX(column_ndx, row_ndx)                           \
+    REALM_ASSERT_COLUMN(column_ndx);                                       \
+    REALM_ASSERT(row_ndx < m_row_indexes.size())
+
+#define REALM_ASSERT_INDEX_AND_TYPE(column_ndx, row_ndx, column_type)     \
+    REALM_ASSERT_COLUMN_AND_TYPE(column_ndx, column_type);                 \
+    REALM_ASSERT(row_ndx < m_row_indexes.size())
+
+#define REALM_ASSERT_INDEX_AND_TYPE_TABLE_OR_MIXED(column_ndx, row_ndx)   \
+    REALM_ASSERT_COLUMN(column_ndx);                                      \
+    REALM_DIAG_PUSH();                                                    \
+    REALM_DIAG_IGNORE_TAUTOLOGICAL_COMPARE();                             \
+    REALM_ASSERT(m_table->get_column_type(column_ndx) == type_Table ||    \
+                   (m_table->get_column_type(column_ndx) == type_Mixed)); \
+    REALM_DIAG_POP();                                                     \
+    REALM_ASSERT(row_ndx < m_row_indexes.size())
+
+// Column information
+
+inline const ColumnBase& TableViewBase::get_column_base(size_t index) const
+{
+    return m_table->get_column_base(index);
+}
+
+inline size_t TableViewBase::get_column_count() const noexcept
+{
+    REALM_ASSERT(m_table);
+    return m_table->get_column_count();
+}
+
+inline StringData TableViewBase::get_column_name(size_t column_ndx) const noexcept
+{
+    REALM_ASSERT(m_table);
+    return m_table->get_column_name(column_ndx);
+}
+
+inline size_t TableViewBase::get_column_index(StringData name) const
+{
+    REALM_ASSERT(m_table);
+    return m_table->get_column_index(name);
+}
+
+inline DataType TableViewBase::get_column_type(size_t column_ndx) const noexcept
+{
+    REALM_ASSERT(m_table);
+    return m_table->get_column_type(column_ndx);
+}
+
+
+// Getters
+
+
+inline int64_t TableViewBase::get_int(size_t column_ndx, size_t row_ndx) const noexcept
+{
+    REALM_ASSERT_INDEX(column_ndx, row_ndx);
+
+    const int64_t real_ndx = m_row_indexes.get(row_ndx);
+    REALM_ASSERT(real_ndx != detached_ref);
+    return m_table->get_int(column_ndx, to_size_t(real_ndx));
+}
+
+inline bool TableViewBase::get_bool(size_t column_ndx, size_t row_ndx) const noexcept
+{
+    REALM_ASSERT_INDEX_AND_TYPE(column_ndx, row_ndx, type_Bool);
+
+    const int64_t real_ndx = m_row_indexes.get(row_ndx);
+    REALM_ASSERT(real_ndx != detached_ref);
+    return m_table->get_bool(column_ndx, to_size_t(real_ndx));
+}
+
+inline OldDateTime TableViewBase::get_olddatetime(size_t column_ndx, size_t row_ndx) const noexcept
+{
+    REALM_ASSERT_INDEX_AND_TYPE(column_ndx, row_ndx, type_OldDateTime);
+
+    const int64_t real_ndx = m_row_indexes.get(row_ndx);
+    REALM_ASSERT(real_ndx != detached_ref);
+    return m_table->get_olddatetime(column_ndx, to_size_t(real_ndx));
+}
+
+inline Timestamp TableViewBase::get_timestamp(size_t column_ndx, size_t row_ndx) const noexcept
+{
+    REALM_ASSERT_INDEX_AND_TYPE(column_ndx, row_ndx, type_Timestamp);
+
+    const int64_t real_ndx = m_row_indexes.get(row_ndx);
+    REALM_ASSERT(real_ndx != detached_ref);
+    return m_table->get_timestamp(column_ndx, to_size_t(real_ndx));
+}
+
+inline float TableViewBase::get_float(size_t column_ndx, size_t row_ndx) const noexcept
+{
+    REALM_ASSERT_INDEX_AND_TYPE(column_ndx, row_ndx, type_Float);
+
+    const int64_t real_ndx = m_row_indexes.get(row_ndx);
+    REALM_ASSERT(real_ndx != detached_ref);
+    return m_table->get_float(column_ndx, to_size_t(real_ndx));
+}
+
+inline double TableViewBase::get_double(size_t column_ndx, size_t row_ndx) const noexcept
+{
+    REALM_ASSERT_INDEX_AND_TYPE(column_ndx, row_ndx, type_Double);
+
+    const int64_t real_ndx = m_row_indexes.get(row_ndx);
+    REALM_ASSERT(real_ndx != detached_ref);
+    return m_table->get_double(column_ndx, to_size_t(real_ndx));
+}
+
+inline StringData TableViewBase::get_string(size_t column_ndx, size_t row_ndx) const noexcept
+{
+    REALM_ASSERT_INDEX_AND_TYPE(column_ndx, row_ndx, type_String);
+
+    const int64_t real_ndx = m_row_indexes.get(row_ndx);
+    REALM_ASSERT(real_ndx != detached_ref);
+    return m_table->get_string(column_ndx, to_size_t(real_ndx));
+}
+
+inline BinaryData TableViewBase::get_binary(size_t column_ndx, size_t row_ndx) const noexcept
+{
+    REALM_ASSERT_INDEX_AND_TYPE(column_ndx, row_ndx, type_Binary);
+
+    const int64_t real_ndx = m_row_indexes.get(row_ndx);
+    REALM_ASSERT(real_ndx != detached_ref);
+    return m_table->get_binary(column_ndx, to_size_t(real_ndx));
+}
+
+inline Mixed TableViewBase::get_mixed(size_t column_ndx, size_t row_ndx) const noexcept
+{
+    REALM_ASSERT_INDEX_AND_TYPE(column_ndx, row_ndx, type_Mixed);
+
+    const int64_t real_ndx = m_row_indexes.get(row_ndx);
+    REALM_ASSERT(real_ndx != detached_ref);
+    return m_table->get_mixed(column_ndx, to_size_t(real_ndx));
+}
+
+inline DataType TableViewBase::get_mixed_type(size_t column_ndx, size_t row_ndx) const noexcept
+{
+    REALM_ASSERT_INDEX_AND_TYPE(column_ndx, row_ndx, type_Mixed);
+
+    const int64_t real_ndx = m_row_indexes.get(row_ndx);
+    REALM_ASSERT(real_ndx != detached_ref);
+    return m_table->get_mixed_type(column_ndx, to_size_t(real_ndx));
+}
+
+inline size_t TableViewBase::get_subtable_size(size_t column_ndx, size_t row_ndx) const noexcept
+{
+    REALM_ASSERT_INDEX_AND_TYPE_TABLE_OR_MIXED(column_ndx, row_ndx);
+
+    const int64_t real_ndx = m_row_indexes.get(row_ndx);
+    REALM_ASSERT(real_ndx != detached_ref);
+    return m_table->get_subtable_size(column_ndx, to_size_t(real_ndx));
+}
+
+inline size_t TableViewBase::get_link(size_t column_ndx, size_t row_ndx) const noexcept
+{
+    REALM_ASSERT_INDEX_AND_TYPE(column_ndx, row_ndx, type_Link);
+
+    const int64_t real_ndx = m_row_indexes.get(row_ndx);
+    REALM_ASSERT(real_ndx != detached_ref);
+    return m_table->get_link(column_ndx, to_size_t(real_ndx));
+}
+
+inline TableRef TableView::get_link_target(size_t column_ndx) noexcept
+{
+    return m_table->get_link_target(column_ndx);
+}
+
+inline ConstTableRef TableView::get_link_target(size_t column_ndx) const noexcept
+{
+    return m_table->get_link_target(column_ndx);
+}
+
+inline ConstTableRef ConstTableView::get_link_target(size_t column_ndx) const noexcept
+{
+    return m_table->get_link_target(column_ndx);
+}
+
+inline bool TableViewBase::is_null_link(size_t column_ndx, size_t row_ndx) const noexcept
+{
+    REALM_ASSERT_INDEX_AND_TYPE(column_ndx, row_ndx, type_Link);
+
+    const int64_t real_ndx = m_row_indexes.get(row_ndx);
+    REALM_ASSERT(real_ndx != detached_ref);
+    return m_table->is_null_link(column_ndx, to_size_t(real_ndx));
+}
+
+
+// Searching
+
+
+inline size_t TableViewBase::find_first_int(size_t column_ndx, int64_t value) const
+{
+    REALM_ASSERT_COLUMN_AND_TYPE(column_ndx, type_Int);
+    return find_first_integer(column_ndx, value);
+}
+
+inline size_t TableViewBase::find_first_bool(size_t column_ndx, bool value) const
+{
+    REALM_ASSERT_COLUMN_AND_TYPE(column_ndx, type_Bool);
+    return find_first_integer(column_ndx, value ? 1 : 0);
+}
+
+inline size_t TableViewBase::find_first_olddatetime(size_t column_ndx, OldDateTime value) const
+{
+    REALM_ASSERT_COLUMN_AND_TYPE(column_ndx, type_OldDateTime);
+    return find_first_integer(column_ndx, int64_t(value.get_olddatetime()));
+}
+
+
+template<class R, class V>
+R TableViewBase::find_all_integer(V* view, size_t column_ndx, int64_t value)
+{
+    typedef typename std::remove_const<V>::type TNonConst;
+    return view->m_table->where(const_cast<TNonConst*>(view)).equal(column_ndx, value).find_all();
+}
+
+template<class R, class V>
+R TableViewBase::find_all_float(V* view, size_t column_ndx, float value)
+{
+    typedef typename std::remove_const<V>::type TNonConst;
+    return view->m_table->where(const_cast<TNonConst*>(view)).equal(column_ndx, value).find_all();
+}
+
+template<class R, class V>
+R TableViewBase::find_all_double(V* view, size_t column_ndx, double value)
+{
+    typedef typename std::remove_const<V>::type TNonConst;
+    return view->m_table->where(const_cast<TNonConst*>(view)).equal(column_ndx, value).find_all();
+}
+
+template<class R, class V>
+R TableViewBase::find_all_string(V* view, size_t column_ndx, StringData value)
+{
+    typedef typename std::remove_const<V>::type TNonConst;
+    return view->m_table->where(const_cast<TNonConst*>(view)).equal(column_ndx, value).find_all();
+}
+
+
+//-------------------------- TableView, ConstTableView implementation:
+
+inline TableView::TableView()
+{
+}
+
+inline ConstTableView::ConstTableView()
+{
+}
+
+inline ConstTableView::ConstTableView(const TableView& tv):
+    TableViewBase(tv)
+{
+}
+
+inline ConstTableView::ConstTableView(TableView&& tv):
+    TableViewBase(std::move(tv))
+{
+}
+
+inline TableView::~TableView() noexcept
+{
+}
+
+inline ConstTableView::~ConstTableView() noexcept
+{
+}
+
+inline void TableView::remove_last(RemoveMode underlying_mode)
+{
+    if (!is_empty())
+        remove(size()-1, underlying_mode);
+}
+
+inline Table& TableView::get_parent() noexcept
+{
+    return *m_table;
+}
+
+inline const Table& TableView::get_parent() const noexcept
+{
+    return *m_table;
+}
+
+inline const Table& ConstTableView::get_parent() const noexcept
+{
+    return *m_table;
+}
+
+inline TableView::TableView(Table& parent):
+    TableViewBase(&parent)
+{
+}
+
+inline TableView::TableView(Table& parent, Query& query, size_t start, size_t end, size_t limit):
+    TableViewBase(&parent, query, start, end, limit)
+{
+}
+
+inline TableView::TableView(Table *parent, Table *linked_table, size_t column, ConstRowExpr row):
+    TableViewBase(parent, linked_table, column, row)
+{
+}
+
+inline ConstTableView::ConstTableView(const Table& parent):
+    TableViewBase(const_cast<Table*>(&parent))
+{
+}
+
+inline ConstTableView& ConstTableView::operator=(const TableView& tv) {
+    TableViewBase::operator=(tv);
+    return *this;
+}
+
+inline ConstTableView& ConstTableView::operator=(TableView&& tv) {
+    TableViewBase::operator=(std::move(tv));
+    return *this;
+}
+
+
+// - string
+inline TableView TableView::find_all_string(size_t column_ndx, StringData value)
+{
+    return TableViewBase::find_all_string<TableView>(this, column_ndx, value);
+}
+
+inline ConstTableView TableView::find_all_string(size_t column_ndx, StringData value) const
+{
+    return TableViewBase::find_all_string<ConstTableView>(this, column_ndx, value);
+}
+
+inline ConstTableView ConstTableView::find_all_string(size_t column_ndx, StringData value) const
+{
+    return TableViewBase::find_all_string<ConstTableView>(this, column_ndx, value);
+}
+
+// - float
+inline TableView TableView::find_all_float(size_t column_ndx, float value)
+{
+    return TableViewBase::find_all_float<TableView>(this, column_ndx, value);
+}
+
+inline ConstTableView TableView::find_all_float(size_t column_ndx, float value) const
+{
+    return TableViewBase::find_all_float<ConstTableView>(this, column_ndx, value);
+}
+
+inline ConstTableView ConstTableView::find_all_float(size_t column_ndx, float value) const
+{
+    return TableViewBase::find_all_float<ConstTableView>(this, column_ndx, value);
+}
+
+
+// - double
+inline TableView TableView::find_all_double(size_t column_ndx, double value)
+{
+    return TableViewBase::find_all_double<TableView>(this, column_ndx, value);
+}
+
+inline ConstTableView TableView::find_all_double(size_t column_ndx, double value) const
+{
+    return TableViewBase::find_all_double<ConstTableView>(this, column_ndx, value);
+}
+
+inline ConstTableView ConstTableView::find_all_double(size_t column_ndx, double value) const
+{
+    return TableViewBase::find_all_double<ConstTableView>(this, column_ndx, value);
+}
+
+
+
+// -- 3 variants of the 3 find_all_{int, bool, date} all based on integer
+
+inline TableView TableView::find_all_integer(size_t column_ndx, int64_t value)
+{
+    return TableViewBase::find_all_integer<TableView>(this, column_ndx, value);
+}
+
+inline ConstTableView TableView::find_all_integer(size_t column_ndx, int64_t value) const
+{
+    return TableViewBase::find_all_integer<ConstTableView>(this, column_ndx, value);
+}
+
+inline ConstTableView ConstTableView::find_all_integer(size_t column_ndx, int64_t value) const
+{
+    return TableViewBase::find_all_integer<ConstTableView>(this, column_ndx, value);
+}
+
+
+inline TableView TableView::find_all_int(size_t column_ndx, int64_t value)
+{
+    REALM_ASSERT_COLUMN_AND_TYPE(column_ndx, type_Int);
+    return find_all_integer(column_ndx, value);
+}
+
+inline TableView TableView::find_all_bool(size_t column_ndx, bool value)
+{
+    REALM_ASSERT_COLUMN_AND_TYPE(column_ndx, type_Bool);
+    return find_all_integer(column_ndx, value ? 1 : 0);
+}
+
+inline TableView TableView::find_all_olddatetime(size_t column_ndx, OldDateTime value)
+{
+    REALM_ASSERT_COLUMN_AND_TYPE(column_ndx, type_OldDateTime);
+    return find_all_integer(column_ndx, int64_t(value.get_olddatetime()));
+}
+
+
+inline ConstTableView TableView::find_all_int(size_t column_ndx, int64_t value) const
+{
+    REALM_ASSERT_COLUMN_AND_TYPE(column_ndx, type_Int);
+    return find_all_integer(column_ndx, value);
+}
+
+inline ConstTableView TableView::find_all_bool(size_t column_ndx, bool value) const
+{
+    REALM_ASSERT_COLUMN_AND_TYPE(column_ndx, type_Bool);
+    return find_all_integer(column_ndx, value ? 1 : 0);
+}
+
+inline ConstTableView TableView::find_all_olddatetime(size_t column_ndx, OldDateTime value) const
+{
+    REALM_ASSERT_COLUMN_AND_TYPE(column_ndx, type_OldDateTime);
+    return find_all_integer(column_ndx, int64_t(value.get_olddatetime()));
+}
+
+
+inline ConstTableView ConstTableView::find_all_int(size_t column_ndx, int64_t value) const
+{
+    REALM_ASSERT_COLUMN_AND_TYPE(column_ndx, type_Int);
+    return find_all_integer(column_ndx, value);
+}
+
+inline ConstTableView ConstTableView::find_all_bool(size_t column_ndx, bool value) const
+{
+    REALM_ASSERT_COLUMN_AND_TYPE(column_ndx, type_Bool);
+    return find_all_integer(column_ndx, value ? 1 : 0);
+}
+
+inline ConstTableView ConstTableView::find_all_olddatetime(size_t column_ndx, OldDateTime value) const
+{
+    REALM_ASSERT_COLUMN_AND_TYPE(column_ndx, type_OldDateTime);
+    return find_all_integer(column_ndx, int64_t(value.get_olddatetime()));
+}
+
+
+// Rows
+
+
+inline TableView::RowExpr TableView::get(size_t row_ndx) noexcept
+{
+    REALM_ASSERT_ROW(row_ndx);
+    const int64_t real_ndx = m_row_indexes.get(row_ndx);
+    REALM_ASSERT(real_ndx != detached_ref);
+    return m_table->get(to_size_t(real_ndx));
+}
+
+inline TableView::ConstRowExpr TableView::get(size_t row_ndx) const noexcept
+{
+    REALM_ASSERT_ROW(row_ndx);
+    const int64_t real_ndx = m_row_indexes.get(row_ndx);
+    REALM_ASSERT(real_ndx != detached_ref);
+    return m_table->get(to_size_t(real_ndx));
+}
+
+inline ConstTableView::ConstRowExpr ConstTableView::get(size_t row_ndx) const noexcept
+{
+    REALM_ASSERT_ROW(row_ndx);
+    const int64_t real_ndx = m_row_indexes.get(row_ndx);
+    REALM_ASSERT(real_ndx != detached_ref);
+    return m_table->get(to_size_t(real_ndx));
+}
+
+inline TableView::RowExpr TableView::front() noexcept
+{
+    return get(0);
+}
+
+inline TableView::ConstRowExpr TableView::front() const noexcept
+{
+    return get(0);
+}
+
+inline ConstTableView::ConstRowExpr ConstTableView::front() const noexcept
+{
+    return get(0);
+}
+
+inline TableView::RowExpr TableView::back() noexcept
+{
+    size_t last_row_ndx = size() - 1;
+    return get(last_row_ndx);
+}
+
+inline TableView::ConstRowExpr TableView::back() const noexcept
+{
+    size_t last_row_ndx = size() - 1;
+    return get(last_row_ndx);
+}
+
+inline ConstTableView::ConstRowExpr ConstTableView::back() const noexcept
+{
+    size_t last_row_ndx = size() - 1;
+    return get(last_row_ndx);
+}
+
+inline TableView::RowExpr TableView::operator[](size_t row_ndx) noexcept
+{
+    return get(row_ndx);
+}
+
+inline TableView::ConstRowExpr TableView::operator[](size_t row_ndx) const noexcept
+{
+    return get(row_ndx);
+}
+
+inline ConstTableView::ConstRowExpr
+ConstTableView::operator[](size_t row_ndx) const noexcept
+{
+    return get(row_ndx);
+}
+
+
+// Subtables
+
+
+inline TableRef TableView::get_subtable(size_t column_ndx, size_t row_ndx)
+{
+    REALM_ASSERT_INDEX_AND_TYPE_TABLE_OR_MIXED(column_ndx, row_ndx);
+
+    const int64_t real_ndx = m_row_indexes.get(row_ndx);
+    REALM_ASSERT(real_ndx != detached_ref);
+    return m_table->get_subtable(column_ndx, to_size_t(real_ndx));
+}
+
+inline ConstTableRef TableView::get_subtable(size_t column_ndx, size_t row_ndx) const
+{
+    REALM_ASSERT_INDEX_AND_TYPE_TABLE_OR_MIXED(column_ndx, row_ndx);
+
+    const int64_t real_ndx = m_row_indexes.get(row_ndx);
+    REALM_ASSERT(real_ndx != detached_ref);
+    return m_table->get_subtable(column_ndx, to_size_t(real_ndx));
+}
+
+inline ConstTableRef ConstTableView::get_subtable(size_t column_ndx, size_t row_ndx) const
+{
+    REALM_ASSERT_INDEX_AND_TYPE_TABLE_OR_MIXED(column_ndx, row_ndx);
+
+    const int64_t real_ndx = m_row_indexes.get(row_ndx);
+    REALM_ASSERT(real_ndx != detached_ref);
+    return m_table->get_subtable(column_ndx, to_size_t(real_ndx));
+}
+
+inline void TableView::clear_subtable(size_t column_ndx, size_t row_ndx)
+{
+    REALM_ASSERT_INDEX_AND_TYPE_TABLE_OR_MIXED(column_ndx, row_ndx);
+
+    const int64_t real_ndx = m_row_indexes.get(row_ndx);
+    REALM_ASSERT(real_ndx != detached_ref);
+    return m_table->clear_subtable(column_ndx, to_size_t(real_ndx));
+}
+
+
+// Setters
+
+
+inline void TableView::set_int(size_t column_ndx, size_t row_ndx, int64_t value)
+{
+    REALM_ASSERT_INDEX_AND_TYPE(column_ndx, row_ndx, type_Int);
+
+    const int64_t real_ndx = m_row_indexes.get(row_ndx);
+    REALM_ASSERT(real_ndx != detached_ref);
+    m_table->set_int(column_ndx, to_size_t(real_ndx), value);
+}
+
+inline void TableView::set_bool(size_t column_ndx, size_t row_ndx, bool value)
+{
+    REALM_ASSERT_INDEX_AND_TYPE(column_ndx, row_ndx, type_Bool);
+
+    const int64_t real_ndx = m_row_indexes.get(row_ndx);
+    REALM_ASSERT(real_ndx != detached_ref);
+    m_table->set_bool(column_ndx, to_size_t(real_ndx), value);
+}
+
+inline void TableView::set_olddatetime(size_t column_ndx, size_t row_ndx, OldDateTime value)
+{
+    REALM_ASSERT_INDEX_AND_TYPE(column_ndx, row_ndx, type_OldDateTime);
+
+    const int64_t real_ndx = m_row_indexes.get(row_ndx);
+    REALM_ASSERT(real_ndx != detached_ref);
+    m_table->set_olddatetime(column_ndx, to_size_t(real_ndx), value);
+}
+
+inline void TableView::set_timestamp(size_t column_ndx, size_t row_ndx, Timestamp value)
+{
+    REALM_ASSERT_INDEX_AND_TYPE(column_ndx, row_ndx, type_Timestamp);
+
+    const int64_t real_ndx = m_row_indexes.get(row_ndx);
+    REALM_ASSERT(real_ndx != detached_ref);
+    m_table->set_timestamp(column_ndx, to_size_t(real_ndx), value);
+}
+
+inline void TableView::set_float(size_t column_ndx, size_t row_ndx, float value)
+{
+    REALM_ASSERT_INDEX_AND_TYPE(column_ndx, row_ndx, type_Float);
+
+    const int64_t real_ndx = m_row_indexes.get(row_ndx);
+    REALM_ASSERT(real_ndx != detached_ref);
+    m_table->set_float(column_ndx, to_size_t(real_ndx), value);
+}
+
+inline void TableView::set_double(size_t column_ndx, size_t row_ndx, double value)
+{
+    REALM_ASSERT_INDEX_AND_TYPE(column_ndx, row_ndx, type_Double);
+
+    const int64_t real_ndx = m_row_indexes.get(row_ndx);
+    REALM_ASSERT(real_ndx != detached_ref);
+    m_table->set_double(column_ndx, to_size_t(real_ndx), value);
+}
+
+template<class E>
+inline void TableView::set_enum(size_t column_ndx, size_t row_ndx, E value)
+{
+    const int64_t real_ndx = m_row_indexes.get(row_ndx);
+    REALM_ASSERT(real_ndx != detached_ref);
+    m_table->set_int(column_ndx, real_ndx, value);
+}
+
+inline void TableView::set_string(size_t column_ndx, size_t row_ndx, StringData value)
+{
+    REALM_ASSERT_INDEX_AND_TYPE(column_ndx, row_ndx, type_String);
+
+    const int64_t real_ndx = m_row_indexes.get(row_ndx);
+    REALM_ASSERT(real_ndx != detached_ref);
+    m_table->set_string(column_ndx, to_size_t(real_ndx), value);
+}
+
+inline void TableView::set_binary(size_t column_ndx, size_t row_ndx, BinaryData value)
+{
+    REALM_ASSERT_INDEX_AND_TYPE(column_ndx, row_ndx, type_Binary);
+
+    const int64_t real_ndx = m_row_indexes.get(row_ndx);
+    REALM_ASSERT(real_ndx != detached_ref);
+    m_table->set_binary(column_ndx, to_size_t(real_ndx), value);
+}
+
+inline void TableView::set_mixed(size_t column_ndx, size_t row_ndx, Mixed value)
+{
+    REALM_ASSERT_INDEX_AND_TYPE(column_ndx, row_ndx, type_Mixed);
+
+    const int64_t real_ndx = m_row_indexes.get(row_ndx);
+    REALM_ASSERT(real_ndx != detached_ref);
+    m_table->set_mixed(column_ndx, to_size_t(real_ndx), value);
+}
+
+inline void TableView::set_subtable(size_t column_ndx, size_t row_ndx, const Table* value)
+{
+    REALM_ASSERT_INDEX_AND_TYPE_TABLE_OR_MIXED(column_ndx, row_ndx);
+    const int64_t real_ndx = m_row_indexes.get(row_ndx);
+    REALM_ASSERT(real_ndx != detached_ref);
+    m_table->set_subtable(column_ndx, to_size_t(real_ndx), value);
+}
+
+inline void TableView::set_link(size_t column_ndx, size_t row_ndx, size_t target_row_ndx)
+{
+    REALM_ASSERT_INDEX_AND_TYPE(column_ndx, row_ndx, type_Link);
+    const int64_t real_ndx = m_row_indexes.get(row_ndx);
+    REALM_ASSERT(real_ndx != detached_ref);
+    m_table->set_link(column_ndx, to_size_t(real_ndx), target_row_ndx);
+}
+
+inline void TableView::nullify_link(size_t column_ndx, size_t row_ndx)
+{
+    REALM_ASSERT_INDEX_AND_TYPE(column_ndx, row_ndx, type_Link);
+    const int64_t real_ndx = m_row_indexes.get(row_ndx);
+    REALM_ASSERT(real_ndx != detached_ref);
+    m_table->nullify_link(column_ndx, to_size_t(real_ndx));
+}
+
+} // namespace realm
+
+#endif // REALM_TABLE_VIEW_HPP
diff --git a/Pods/Realm/include/core/realm/table_view_basic.hpp b/Pods/Realm/include/core/realm/table_view_basic.hpp
new file mode 100644
index 0000000..66703ef
--- /dev/null
+++ b/Pods/Realm/include/core/realm/table_view_basic.hpp
@@ -0,0 +1,373 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_TABLE_VIEW_BASIC_HPP
+#define REALM_TABLE_VIEW_BASIC_HPP
+
+#include <realm/util/type_traits.hpp>
+#include <realm/table_view.hpp>
+#include <realm/table_accessors.hpp>
+
+namespace realm {
+
+
+/// Common base class for BasicTableView<Tab> and BasicTableView<const
+/// Tab>.
+///
+/// \tparam Impl Is either TableView or ConstTableView.
+template<class Tab, class View, class Impl>
+class BasicTableViewBase {
+public:
+    typedef typename Tab::spec_type spec_type;
+    typedef Tab table_type;
+
+    bool is_empty() const noexcept { return m_impl.is_empty(); }
+    bool is_attached() const noexcept { return m_impl.is_attached(); }
+    size_t size() const noexcept { return m_impl.size(); }
+
+    // Get row index in the source table this view is "looking" at.
+    size_t get_source_ndx(size_t row_ndx) const noexcept
+    {
+        return m_impl.get_source_ndx(row_ndx);
+    }
+
+    void to_json(std::ostream& out) const { m_impl.to_json(out); }
+    void to_string(std::ostream& out, size_t limit=500) const
+    {
+        m_impl.to_string(out, limit);
+    }
+    void row_to_string(size_t row_ndx, std::ostream& out) const
+    {
+        m_impl.row_to_string(row_ndx, out);
+    }
+
+private:
+    typedef typename Tab::spec_type Spec;
+
+    template<int col_idx>
+    struct Col {
+        typedef typename util::TypeAt<typename Spec::Columns, col_idx>::type value_type;
+        typedef _impl::ColumnAccessor<View, col_idx, value_type> type;
+    };
+    typedef typename Spec::template ColNames<Col, View*> ColsAccessor;
+
+    template<int col_idx>
+    struct ConstCol {
+        typedef typename util::TypeAt<typename Spec::Columns, col_idx>::type value_type;
+        typedef _impl::ColumnAccessor<const View, col_idx, value_type> type;
+    };
+    typedef typename Spec::template ColNames<ConstCol, const View*> ConstColsAccessor;
+
+public:
+    ColsAccessor column() noexcept
+    {
+        return ColsAccessor(static_cast<View*>(this));
+    }
+
+    ConstColsAccessor column() const noexcept
+    {
+        return ConstColsAccessor(static_cast<const View*>(this));
+    }
+
+private:
+    template<int col_idx>
+    struct Field {
+        typedef typename util::TypeAt<typename Spec::Columns, col_idx>::type value_type;
+        typedef _impl::FieldAccessor<View, col_idx, value_type, std::is_const<Tab>::value> type;
+    };
+    typedef std::pair<View*, size_t> FieldInit;
+    typedef typename Spec::template ColNames<Field, FieldInit> RowAccessor;
+
+    template<int col_idx>
+    struct ConstField {
+        typedef typename util::TypeAt<typename Spec::Columns, col_idx>::type value_type;
+        typedef _impl::FieldAccessor<const View, col_idx, value_type, true> type;
+    };
+    typedef std::pair<const View*, size_t> ConstFieldInit;
+    typedef typename Spec::template ColNames<ConstField, ConstFieldInit> ConstRowAccessor;
+
+public:
+    RowAccessor operator[](size_t row_idx) noexcept
+    {
+        return RowAccessor(std::make_pair(static_cast<View*>(this), row_idx));
+    }
+
+    ConstRowAccessor operator[](size_t row_idx) const noexcept
+    {
+        return ConstRowAccessor(std::make_pair(static_cast<const View*>(this), row_idx));
+    }
+
+protected:
+    template<class, int, class, bool>
+    friend class _impl::FieldAccessor;
+
+    template<class, int, class>
+    friend class _impl::MixedFieldAccessorBase;
+
+    template<class Spec>
+    friend class BasicTable;
+
+    Impl m_impl;
+
+    BasicTableViewBase() {}
+    BasicTableViewBase(const BasicTableViewBase& tv, typename Impl::HandoverPatch& patch,
+                       ConstSourcePayload mode)
+        : m_impl(tv.m_impl, patch, mode) { }
+    BasicTableViewBase(BasicTableViewBase& tv, typename Impl::HandoverPatch& patch,
+                       MutableSourcePayload mode)
+        : m_impl(tv.m_impl, patch, mode) { }
+    BasicTableViewBase(Impl i): m_impl(std::move(i)) {}
+
+    Impl* get_impl() noexcept { return &m_impl; }
+    const Impl* get_impl() const noexcept { return &m_impl; }
+};
+
+
+
+
+/// A BasicTableView wraps a TableView and provides a type and
+/// structure safe set of access methods. The TableView methods are
+/// not visible through a BasicTableView. A BasicTableView is used
+/// essentially the same way as a BasicTable.
+///
+/// Note that this class is specialized for const-qualified parent
+/// tables.
+///
+/// There are three levels of consteness to consider. A 'const
+/// BasicTableView<Tab>' prohibits any modification of the table as
+/// well as any modification of the table view, regardless of whether
+/// Tab is const-qualified or not.
+///
+/// A non-const 'BasicTableView<Tab>' where Tab is const-qualified,
+/// still does not allow any modification of the parent
+/// table. However, the view itself may be modified, for example, by
+/// reordering its rows.
+///
+/// A non-const 'BasicTableView<Tab>' where Tab is not
+/// const-qualified, gives full modification access to both the parent
+/// table and the view.
+///
+/// Just like TableView, a BasicTableView has both copy and move
+/// semantics. See TableView for more on this.
+///
+/// \tparam Tab The possibly const-qualified parent table type. This
+/// must always be an instance of the BasicTable template.
+///
+template<class Tab>
+class BasicTableView: public BasicTableViewBase<Tab, BasicTableView<Tab>, TableView> {
+private:
+    typedef BasicTableViewBase<Tab, BasicTableView<Tab>, TableView> Base;
+
+public:
+    BasicTableView() {}
+    BasicTableView& operator=(BasicTableView);
+    friend BasicTableView move(BasicTableView& tv) { return BasicTableView(&tv); }
+
+    // Deleting
+    void remove(size_t ndx, RemoveMode underlying_mode = RemoveMode::ordered);
+    void remove_last(RemoveMode underlying_mode = RemoveMode::ordered);
+    void clear(RemoveMode underlying_mode = RemoveMode::ordered);
+
+    // Resort after requery
+    void apply_same_order(BasicTableView& order) { Base::m_impl.apply_same_order(order.m_impl); }
+
+    Tab& get_parent() noexcept
+    {
+        return static_cast<Tab&>(Base::m_impl.get_parent());
+    }
+
+    const Tab& get_parent() const noexcept
+    {
+        return static_cast<const Tab&>(Base::m_impl.get_parent());
+    }
+
+
+public:
+    void move_assign(BasicTableView<Tab>& tv)
+    {
+        Base::m_impl.move_assign(tv.m_impl);
+    }
+    using HandoverPatch = TableViewHandoverPatch;
+
+    std::unique_ptr<BasicTableView<Tab>>
+    clone_for_handover(std::unique_ptr<HandoverPatch>& patch, ConstSourcePayload mode) const
+    {
+        patch.reset(new HandoverPatch);
+        std::unique_ptr<BasicTableView<Tab>> retval(new BasicTableView<Tab>(*this, *patch, mode));
+        return retval;
+    }
+
+    std::unique_ptr<BasicTableView<Tab>>
+    clone_for_handover(std::unique_ptr<HandoverPatch>& patch, MutableSourcePayload mode)
+    {
+        patch.reset(new HandoverPatch);
+        std::unique_ptr<BasicTableView<Tab>> retval(new BasicTableView<Tab>(*this, *patch, mode));
+        return retval;
+    }
+
+    void apply_and_consume_patch(std::unique_ptr<HandoverPatch>& patch, Group& group)
+    {
+        apply_patch(*patch, group);
+        patch.reset();
+    }
+
+    BasicTableView(const BasicTableView<Tab>& source, HandoverPatch& patch,
+                   ConstSourcePayload mode):
+        Base(source, patch, mode)
+    {
+    }
+
+    BasicTableView(BasicTableView<Tab>& source, HandoverPatch& patch,
+                   MutableSourcePayload mode):
+        Base(source, patch, mode)
+    {
+    }
+
+    void apply_patch(TableView::HandoverPatch& patch, Group& group)
+    {
+        Base::m_impl.apply_patch(patch, group);
+    }
+
+private:
+    BasicTableView(BasicTableView* tv): Base(move(tv->m_impl)) {}
+    BasicTableView(TableView tv): Base(std::move(tv)) {}
+
+    template<class Subtab>
+    Subtab* get_subtable_ptr(size_t column_ndx, size_t ndx)
+    {
+        return get_parent().template
+            get_subtable_ptr<Subtab>(column_ndx, Base::m_impl.get_source_ndx(ndx));
+    }
+
+    template<class Subtab>
+    const Subtab* get_subtable_ptr(size_t column_ndx, size_t ndx) const
+    {
+        return get_parent().template
+            get_subtable_ptr<Subtab>(column_ndx, Base::m_impl.get_source_ndx(ndx));
+    }
+
+    friend class BasicTableView<const Tab>;
+
+    template<class, int, class, bool>
+    friend class _impl::FieldAccessor;
+
+    template<class, int, class>
+    friend class _impl::MixedFieldAccessorBase;
+
+    template<class, int, class>
+    friend class _impl::ColumnAccessorBase;
+
+    template<class, int, class>
+    friend class _impl::ColumnAccessor;
+
+    friend class Tab::Query;
+};
+
+
+
+
+/// Specialization for 'const' access to parent table.
+///
+template<class Tab>
+class BasicTableView<const Tab>:
+    public BasicTableViewBase<const Tab, BasicTableView<const Tab>, ConstTableView> {
+private:
+    typedef BasicTableViewBase<const Tab, BasicTableView<const Tab>, ConstTableView> Base;
+
+public:
+    BasicTableView() {}
+    BasicTableView& operator=(BasicTableView tv) { Base::m_impl = move(tv.m_impl); return *this; }
+    friend BasicTableView move(BasicTableView& tv) { return BasicTableView(&tv); }
+
+    /// Construct BasicTableView<const Tab> from BasicTableView<Tab>.
+    ///
+        BasicTableView(BasicTableView<Tab> tv): Base(std::move(tv.m_impl)) {}
+
+    /// Assign BasicTableView<Tab> to BasicTableView<const Tab>.
+    ///
+    BasicTableView& operator=(BasicTableView<Tab> tv)
+    {
+        Base::m_impl = std::move(tv.m_impl);
+        return *this;
+    }
+
+    const Tab& get_parent() const noexcept
+    {
+        return static_cast<const Tab&>(Base::m_impl.get_parent());
+    }
+
+private:
+    BasicTableView(BasicTableView* tv): Base(move(tv->m_impl)) {}
+    BasicTableView(ConstTableView tv): Base(std::move(tv)) {}
+
+    template<class Subtab>
+    const Subtab* get_subtable_ptr(size_t column_ndx, size_t ndx) const
+    {
+        return get_parent().template
+            get_subtable_ptr<Subtab>(column_ndx, Base::m_impl.get_source_ndx(ndx));
+    }
+
+    template<class, int, class, bool>
+    friend class _impl::FieldAccessor;
+
+    template<class, int, class>
+    friend class _impl::MixedFieldAccessorBase;
+
+    template<class, int, class>
+    friend class _impl::ColumnAccessorBase;
+
+    template<class, int, class>
+    friend class _impl::ColumnAccessor;
+
+    friend class Tab::Query;
+};
+
+
+
+
+// Implementation
+
+template<class Tab>
+inline BasicTableView<Tab>& BasicTableView<Tab>::operator=(BasicTableView tv)
+{
+    Base::m_impl = std::move(tv.m_impl);
+    return *this;
+}
+
+template<class Tab>
+inline void BasicTableView<Tab>::remove(size_t ndx, RemoveMode underlying_mode)
+{
+    Base::m_impl.remove(ndx, underlying_mode);
+}
+
+template<class Tab>
+inline void BasicTableView<Tab>::remove_last(RemoveMode underlying_mode)
+{
+    Base::m_impl.remove_last(underlying_mode);
+}
+
+template<class Tab>
+inline void BasicTableView<Tab>::clear(RemoveMode underlying_mode)
+{
+    Base::m_impl.clear(underlying_mode);
+}
+
+} // namespace realm
+
+#endif // REALM_TABLE_VIEW_BASIC_HPP
diff --git a/Pods/Realm/include/core/realm/timestamp.hpp b/Pods/Realm/include/core/realm/timestamp.hpp
new file mode 100644
index 0000000..b7473c9
--- /dev/null
+++ b/Pods/Realm/include/core/realm/timestamp.hpp
@@ -0,0 +1,121 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_TIMESTAMP_HPP
+#define REALM_TIMESTAMP_HPP
+
+#include <stdint.h>
+#include <ostream>
+#include <realm/util/assert.hpp>
+
+namespace realm {
+
+class Timestamp {
+public:
+    // Construct from the number of seconds and nanoseconds since the UNIX epoch: 00:00:00 UTC on 1 January 1970
+    //
+    // To split a native nanosecond representation, only division and modulo are necessary:
+    //
+    //     s = native_nano / nanoseconds_per_second
+    //     n = native_nano % nanoseconds_per_second
+    //     Timestamp ts(s, n);
+    //
+    // To convert back into native nanosecond representation, simple multiply and add:
+    //
+    //     native_nano = ts.s * nanoseconds_per_second + ts.n
+    //
+    // Specifically this allows the nanosecond part to become negative (only) for Timestamps before the UNIX epoch.
+    // Usually this will not need special attention, but for reference, valid Timestamps will have one of the
+    // following sign combinations:
+    //
+    //     s | n
+    //     -----
+    //     + | +
+    //     + | 0
+    //     0 | +
+    //     0 | 0
+    //     0 | -
+    //     - | 0
+    //     - | -
+    //
+    // Examples:
+    //     The UNIX epoch is constructed by Timestamp(0, 0)
+    //     Relative times are constructed as follows:
+    //       +1 second is constructed by Timestamp(1, 0)
+    //       +1 nanosecond is constructed by Timestamp(0, 1)
+    //       +1.1 seconds (1100 milliseconds after the epoch) is constructed by Timestamp(1, 100000000)
+    //       -1.1 seconds (1100 milliseconds before the epoch) is constructed by Timestamp(-1, -100000000)
+    //
+    Timestamp(int64_t seconds, int32_t nanoseconds) : m_seconds(seconds), m_nanoseconds(nanoseconds), m_is_null(false)
+    {
+        REALM_ASSERT_EX(-nanoseconds_per_second < nanoseconds && nanoseconds < nanoseconds_per_second, nanoseconds);
+        const bool both_non_negative = seconds >= 0 && nanoseconds >= 0;
+        const bool both_non_positive = seconds <= 0 && nanoseconds <= 0;
+        REALM_ASSERT_EX(both_non_negative || both_non_positive, both_non_negative, both_non_positive);
+    }
+    Timestamp(realm::null) : m_is_null(true) { }
+    Timestamp() : Timestamp(null{}) { }
+
+    bool is_null() const { return m_is_null; }
+
+    int64_t get_seconds() const noexcept
+    {
+        REALM_ASSERT(!m_is_null);
+        return m_seconds;
+    }
+
+    int32_t get_nanoseconds() const noexcept
+    {
+        REALM_ASSERT(!m_is_null);
+        return m_nanoseconds;
+    }
+
+    // Note that these operators do not work if one of the Timestamps are null! Please use realm::Greater, realm::Equal
+    // etc instead. This is in order to collect all treatment of null behaviour in a single place for all 
+    // types (query_conditions.hpp) to ensure that all types sort and compare null vs. non-null in the same manner,
+    // especially for int/float where we cannot override operators. This design is open for discussion, though, because
+    // it has usability drawbacks
+    bool operator==(const Timestamp& rhs) const { REALM_ASSERT(!is_null()); REALM_ASSERT(!rhs.is_null()); return m_seconds == rhs.m_seconds && m_nanoseconds == rhs.m_nanoseconds; }
+    bool operator!=(const Timestamp& rhs) const { REALM_ASSERT(!is_null()); REALM_ASSERT(!rhs.is_null()); return m_seconds != rhs.m_seconds || m_nanoseconds != rhs.m_nanoseconds; }
+    bool operator>(const Timestamp& rhs) const { REALM_ASSERT(!is_null()); REALM_ASSERT(!rhs.is_null()); return (m_seconds > rhs.m_seconds) || (m_seconds == rhs.m_seconds && m_nanoseconds > rhs.m_nanoseconds); }
+    bool operator<(const Timestamp& rhs) const { REALM_ASSERT(!is_null()); REALM_ASSERT(!rhs.is_null()); return (m_seconds < rhs.m_seconds) || (m_seconds == rhs.m_seconds && m_nanoseconds < rhs.m_nanoseconds); }
+    bool operator<=(const Timestamp& rhs) const { REALM_ASSERT(!is_null()); REALM_ASSERT(!rhs.is_null()); return *this < rhs || *this == rhs; }
+    bool operator>=(const Timestamp& rhs) const { REALM_ASSERT(!is_null()); REALM_ASSERT(!rhs.is_null()); return *this > rhs || *this == rhs; }
+    Timestamp& operator=(const Timestamp& rhs) = default;
+
+    template<class Ch, class Tr>
+    friend std::basic_ostream<Ch, Tr>& operator<<(std::basic_ostream<Ch, Tr>& out, const Timestamp&);
+    static constexpr int32_t nanoseconds_per_second = 1000000000;
+
+private:
+    int64_t m_seconds;
+    int32_t m_nanoseconds;
+    bool m_is_null;
+};
+
+template<class C, class T>
+inline std::basic_ostream<C, T>& operator<<(std::basic_ostream<C, T>& out, const Timestamp& d)
+{
+    out << "Timestamp(" << d.m_seconds << ", " << d.m_nanoseconds << ")";
+    return out;
+}
+
+} // namespace realm
+
+#endif // REALM_TIMESTAMP_HPP
diff --git a/Pods/Realm/include/core/realm/unicode.hpp b/Pods/Realm/include/core/realm/unicode.hpp
new file mode 100644
index 0000000..a1c29ca
--- /dev/null
+++ b/Pods/Realm/include/core/realm/unicode.hpp
@@ -0,0 +1,157 @@
+/*************************************************************************
+*
+* REALM CONFIDENTIAL
+* __________________
+*
+*  [2011] - [2015] Realm Inc
+*  All Rights Reserved.
+*
+* NOTICE:  All information contained herein is, and remains
+* the property of Realm Incorporated and its suppliers,
+* if any.  The intellectual and technical concepts contained
+* herein are proprietary to Realm Incorporated
+* and its suppliers and may be covered by U.S. and Foreign Patents,
+* patents in process, and are protected by trade secret or copyright law.
+* Dissemination of this information or reproduction of this material
+* is strictly forbidden unless prior written permission is obtained
+* from Realm Incorporated.
+*
+**************************************************************************/
+#ifndef REALM_UNICODE_HPP
+#define REALM_UNICODE_HPP
+
+#include <locale>
+#include <stdint.h>
+#include <string>
+
+#include <realm/util/safe_int_ops.hpp>
+#include <realm/string_data.hpp>
+#include <realm/util/features.h>
+#include <realm/utilities.hpp>
+
+
+namespace realm {
+
+    enum string_compare_method_t {
+        STRING_COMPARE_CORE,
+        STRING_COMPARE_CPP11,
+        STRING_COMPARE_CALLBACK,
+        STRING_COMPARE_CORE_SIMILAR
+    };
+
+    extern StringCompareCallback string_compare_callback;
+    extern string_compare_method_t string_compare_method;
+
+    // Description for set_string_compare_method():
+    //
+    // Short summary: iOS language binding: call
+    //     set_string_compare_method() for fast but slightly inaccurate sort in some countries, or
+    //     set_string_compare_method(2, callbackptr) for slow but precise sort (see callbackptr below)
+    //
+    // Different countries ('locales') have different sorting order for strings and letters. Because there unfortunatly
+    // doesn't exist any unified standardized way to compare strings in C++ on multiple platforms, we need this method.
+    //
+    // It determins how sorting a TableView by a String column must take place. The 'method' argument can be:
+    //
+    // 0: Fast core-only compare (no OS/framework calls). LIMITATIONS: Works only upto 'Latin Extended 2' (unicodes
+    // 0...591). Also, sorting order is according to 'en_US' so it may be slightly inaccurate for some countries.
+    // 'callback' argument is ignored.
+    //
+    // Return value: Always 'true'
+    //
+    // 1: Native C++11 method if core is compiled as C++11. Gives precise sorting according
+    // to user's current locale. LIMITATIONS: Currently works only on Windows and on Linux with clang. Does NOT work on
+    // iOS (due to only 'C' locale being available in CoreFoundation, which puts 'Z' before 'a'). Unknown if works on
+    // Windows Phone / Android. Furthermore it does NOT work on Linux with gcc 4.7 or 4.8 (lack of c++11 feature that
+    // can convert utf8->wstring without calls to setlocale()).
+    //
+    // Return value: 'true' if supported, otherwise 'false' (if so, then previous setting, if any, is preserved).
+    //
+    // 2: Callback method. Language binding / C++ user must provide a utf-8 callback method of prototype:
+    // bool callback(const char* string1, const char* string2) where 'callback' must return bool(string1 < string2).
+    //
+    // Return value: Always 'true'
+    //
+    // Default is method = 0 if the function is never called
+    //
+    // NOT THREAD SAFE! Call once during initialization or make sure it's not called simultaneously with different arguments
+    // The setting is remembered per-process; it does NOT need to be called prior to each sort
+    bool set_string_compare_method(string_compare_method_t method, StringCompareCallback callback);
+
+
+    // Return size in bytes of utf8 character. No error checking
+    size_t sequence_length(char lead);
+
+    // Limitations for case insensitive string search
+    // Case insensitive search (equal, begins_with, ends_with and contains)
+    // only works for unicodes 0...0x7f which is the same as the 0...127
+    // ASCII character set (letters a-z and A-Z).
+
+    // In does *not* work for the 0...255 ANSI character set that contains
+    // characters from many European countries like Germany, France, Denmark,
+    // etc.
+
+    // It also does not work for characters from non-western countries like
+    // Japan, Russia, Arabia, etc.
+
+    // If there exists characters outside the ASCII range either in the text
+    // to be searched for, or in the Realm string column which is searched
+    // in, then the compare yields a random result such that the row may or
+    // may not be included in the result set.
+
+    // Return bool(string1 < string2)
+    bool utf8_compare(StringData string1, StringData string2);
+
+    // Return unicode value of character.
+    uint32_t utf8value(const char* character);
+
+    inline bool equal_sequence(const char*& begin, const char* end, const char* begin2);
+
+    // FIXME: The current approach to case insensitive comparison requires
+    // that case mappings can be done in a way that does not change he
+    // number of bytes used to encode the individual Unicode
+    // character. This is not generally the case, so, as far as I can see,
+    // this approach has no future.
+    //
+    // FIXME: The current approach to case insensitive comparison relies
+    // on checking each "haystack" character against the corresponding
+    // character in both a lower cased and an upper cased version of the
+    // "needle". While this leads to efficient comparison, it ignores the
+    // fact that "case folding" is the only correct approach to case
+    // insensitive comparison in a locale agnostic Unicode
+    // environment.
+    //
+    // See
+    //   http://www.w3.org/International/wiki/Case_folding
+    //   http://userguide.icu-project.org/transforms/casemappings#TOC-Case-Folding.
+    //
+    // The ideal API would probably be something like this:
+    //
+    //   case_fold:        utf_8 -> case_folded
+    //   equal_case_fold:  (needle_case_folded, single_haystack_entry_utf_8) -> found
+    //   search_case_fold: (needle_case_folded, huge_haystack_string_utf_8) -> found_at_position
+    //
+    // The case folded form would probably be using UTF-32 or UTF-16.
+
+
+    /// If successful, returns a string of the same size as \a source.
+    /// Returns none if invalid UTF-8 encoding was encountered.
+    util::Optional<std::string> case_map(StringData source, bool upper);
+
+    enum IgnoreErrorsTag { IgnoreErrors };
+    std::string case_map(StringData source, bool upper, IgnoreErrorsTag);
+
+    /// Assumes that the sizes of \a needle_upper and \a needle_lower are
+    /// identical to the size of \a haystack. Returns false if the needle
+    /// is different from the haystack.
+    bool equal_case_fold(StringData haystack, const char* needle_upper, const char* needle_lower);
+
+    /// Assumes that the sizes of \a needle_upper and \a needle_lower are
+    /// both equal to \a needle_size. Returns haystack.size() if the
+    /// needle was not found.
+    size_t search_case_fold(StringData haystack, const char* needle_upper,
+        const char* needle_lower, size_t needle_size);
+
+} // namespace realm
+
+#endif // REALM_UNICODE_HPP
diff --git a/Pods/Realm/include/core/realm/util/assert.hpp b/Pods/Realm/include/core/realm/util/assert.hpp
new file mode 100644
index 0000000..48b8972
--- /dev/null
+++ b/Pods/Realm/include/core/realm/util/assert.hpp
@@ -0,0 +1,110 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_UTIL_ASSERT_HPP
+#define REALM_UTIL_ASSERT_HPP
+
+#include <realm/util/features.h>
+#include <realm/util/terminate.hpp>
+
+#if REALM_ENABLE_ASSERTIONS || defined(REALM_DEBUG)
+#  define REALM_ASSERTIONS_ENABLED 1
+#else
+#  define REALM_ASSERTIONS_ENABLED 0
+#endif
+
+#define REALM_ASSERT_RELEASE(condition) \
+    ((condition) ? static_cast<void>(0) : \
+    realm::util::terminate("Assertion failed: " #condition, __FILE__, __LINE__))
+
+#if REALM_ASSERTIONS_ENABLED
+#  define REALM_ASSERT(condition) REALM_ASSERT_RELEASE(condition)
+#else
+#  define REALM_ASSERT(condition) static_cast<void>(sizeof bool(condition))
+#endif
+
+#ifdef REALM_DEBUG
+#  define REALM_ASSERT_DEBUG(condition) REALM_ASSERT_RELEASE(condition)
+#else
+#  define REALM_ASSERT_DEBUG(condition) static_cast<void>(sizeof bool(condition))
+#endif
+
+#define REALM_STRINGIFY(X) #X
+
+#define REALM_ASSERT_RELEASE_EX(condition, ...) \
+    ((condition) ? static_cast<void>(0) : \
+    realm::util::terminate_with_info("Assertion failed: " # condition, __LINE__, __FILE__, \
+                                     REALM_STRINGIFY((__VA_ARGS__)), __VA_ARGS__))
+
+#ifdef REALM_DEBUG
+#  define REALM_ASSERT_DEBUG_EX REALM_ASSERT_RELEASE_EX
+#else
+#  define REALM_ASSERT_DEBUG_EX(condition, ...) static_cast<void>(sizeof bool(condition))
+#endif
+
+// Becase the assert is used in noexcept methods, it's a bad idea to allocate
+// buffer space for the message so therefore we must pass it to terminate which
+// will 'cerr' it for us without needing any buffer
+#if REALM_ENABLE_ASSERTIONS || defined(REALM_DEBUG)
+
+#  define REALM_ASSERT_EX REALM_ASSERT_RELEASE_EX
+
+#  define REALM_ASSERT_3(left, cmp, right) \
+    (((left) cmp (right)) ? static_cast<void>(0) : \
+     realm::util::terminate("Assertion failed: " \
+                            "" #left " " #cmp " " #right, \
+                            __FILE__, __LINE__, left, right))
+
+#  define REALM_ASSERT_7(left1, cmp1, right1, logical, left2, cmp2, right2) \
+    ((((left1) cmp1 (right1)) logical ((left2) cmp2 (right2))) ? static_cast<void>(0) : \
+     realm::util::terminate("Assertion failed: " \
+                            "" #left1 " " #cmp1 " " #right1 " " #logical " " \
+                            "" #left2 " " #cmp2 " " #right2, \
+                            __FILE__, __LINE__, left1, right1, left2, right2))
+
+#  define REALM_ASSERT_11(left1, cmp1, right1, logical1, left2, cmp2, right2, logical2, left3, cmp3, right3) \
+    ((((left1) cmp1 (right1)) logical1 ((left2) cmp2 (right2)) logical2 ((left3) cmp3 (right3))) ? static_cast<void>(0) : \
+     realm::util::terminate("Assertion failed: " \
+                            "" #left1 " " #cmp1 " " #right1 " " #logical1 " " \
+                            "" #left2 " " #cmp2 " " #right2 " " #logical2 " " \
+                            "" #left3 " " #cmp3 " " #right3, \
+                            __FILE__, __LINE__, left1, right1, left2, right2, left3, right3))
+#else
+#  define REALM_ASSERT_EX(condition, ...) \
+    static_cast<void>(sizeof bool(condition))
+#  define REALM_ASSERT_3(left, cmp, right) \
+    static_cast<void>(sizeof bool((left) cmp (right)))
+#  define REALM_ASSERT_7(left1, cmp1, right1, logical, left2, cmp2, right2) \
+    static_cast<void>(sizeof bool(((left1) cmp1 (right1)) logical ((left2) cmp2 (right2))))
+#  define REALM_ASSERT_11(left1, cmp1, right1, logical1, left2, cmp2, right2, logical2, left3, cmp3, right3) \
+    static_cast<void>(sizeof bool(((left1) cmp1 (right1)) logical1 ((left2) cmp2 (right2)) logical2 ((left3) cmp3 (right3))))
+#endif
+
+#ifdef REALM_COVER
+#  define REALM_UNREACHABLE()
+#  define REALM_COVER_NEVER(x) false
+#  define REALM_COVER_ALWAYS(x) true
+#else
+#  define REALM_UNREACHABLE() \
+      realm::util::terminate("Unreachable code", __FILE__, __LINE__)
+#  define REALM_COVER_NEVER(x) (x)
+#  define REALM_COVER_ALWAYS(x) (x)
+#endif
+
+#endif // REALM_UTIL_ASSERT_HPP
diff --git a/Pods/Realm/include/core/realm/util/basic_system_errors.hpp b/Pods/Realm/include/core/realm/util/basic_system_errors.hpp
new file mode 100644
index 0000000..6c3f95a
--- /dev/null
+++ b/Pods/Realm/include/core/realm/util/basic_system_errors.hpp
@@ -0,0 +1,93 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_UTIL_BASIC_SYSTEM_ERRORS_HPP
+#define REALM_UTIL_BASIC_SYSTEM_ERRORS_HPP
+
+#include <cerrno>
+#include <system_error>
+
+
+namespace realm {
+namespace util {
+namespace error {
+
+enum basic_system_errors {
+    /// Address family not supported by protocol.
+    address_family_not_supported = EAFNOSUPPORT,
+
+    /// Invalid argument.
+    invalid_argument = EINVAL,
+
+    /// Cannot allocate memory.
+    no_memory = ENOMEM,
+
+    /// Operation cancelled.
+    operation_aborted = ECANCELED,
+
+    /// Connection aborted.
+    connection_aborted = ECONNABORTED,
+
+    /// Connection reset by peer
+    connection_reset = ECONNRESET,
+
+    /// Broken pipe
+    broken_pipe = EPIPE,
+
+    /// Resource temporarily unavailable
+    resource_unavailable_try_again = EAGAIN,
+};
+
+std::error_code make_error_code(basic_system_errors) noexcept;
+
+} // namespace error
+} // namespace util
+} // namespace realm
+
+namespace std {
+
+template<>
+class is_error_code_enum<realm::util::error::basic_system_errors>
+{
+public:
+    static const bool value = true;
+};
+
+} // namespace std
+
+namespace realm {
+namespace util {
+
+std::error_code make_basic_system_error_code(int) noexcept;
+
+
+
+
+// implementation
+
+inline std::error_code make_basic_system_error_code(int err) noexcept
+{
+    using namespace error;
+    return make_error_code(basic_system_errors(err));
+}
+
+} // namespace util
+} // namespace realm
+
+#endif // REALM_UTIL_BASIC_SYSTEM_ERRORS_HPP
diff --git a/Pods/Realm/include/core/realm/util/bind_ptr.hpp b/Pods/Realm/include/core/realm/util/bind_ptr.hpp
new file mode 100644
index 0000000..0e2b1ad
--- /dev/null
+++ b/Pods/Realm/include/core/realm/util/bind_ptr.hpp
@@ -0,0 +1,367 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_UTIL_BIND_PTR_HPP
+#define REALM_UTIL_BIND_PTR_HPP
+
+#include <algorithm>
+#include <atomic>
+#include <ostream>
+#include <utility>
+
+#include <realm/util/features.h>
+#include <realm/util/assert.hpp>
+
+
+namespace realm {
+namespace util {
+
+class bind_ptr_base {
+public:
+    struct adopt_tag {};
+};
+
+
+/// A generic intrusive smart pointer that binds itself explicitely to
+/// the target object.
+///
+/// This class is agnostic towards what 'binding' means for the target
+/// object, but a common use is 'reference counting'. See RefCountBase
+/// for an example of that.
+///
+/// This smart pointer implementation assumes that the target object
+/// destructor never throws.
+template<class T> class bind_ptr: public bind_ptr_base {
+public:
+    constexpr bind_ptr() noexcept: m_ptr(nullptr) {}
+    ~bind_ptr() noexcept { unbind(); }
+
+    explicit bind_ptr(T* p) noexcept { bind(p); }
+    template<class U> explicit bind_ptr(U* p) noexcept { bind(p); }
+
+    bind_ptr(T* p, adopt_tag) noexcept { m_ptr = p; }
+    template<class U> bind_ptr(U* p, adopt_tag) noexcept { m_ptr = p; }
+
+    // Copy construct
+    bind_ptr(const bind_ptr& p) noexcept { bind(p.m_ptr); }
+    template<class U>
+    bind_ptr(const bind_ptr<U>& p) noexcept { bind(p.m_ptr); }
+
+    // Copy assign
+    bind_ptr& operator=(const bind_ptr& p) noexcept { bind_ptr(p).swap(*this); return *this; }
+    template<class U>
+    bind_ptr& operator=(const bind_ptr<U>& p) noexcept { bind_ptr(p).swap(*this); return *this; }
+
+    // Move construct
+    bind_ptr(bind_ptr&& p) noexcept: m_ptr(p.release()) {}
+    template<class U>
+    bind_ptr(bind_ptr<U>&& p) noexcept: m_ptr(p.release()) {}
+
+    // Move assign
+    bind_ptr& operator=(bind_ptr&& p) noexcept { bind_ptr(std::move(p)).swap(*this); return *this; }
+    template<class U>
+    bind_ptr& operator=(bind_ptr<U>&& p) noexcept { bind_ptr(std::move(p)).swap(*this); return *this; }
+
+    //@{
+    // Comparison
+    template<class U>
+    bool operator==(const bind_ptr<U>&) const noexcept;
+
+    template<class U>
+    bool operator==(U*) const noexcept;
+
+    template<class U>
+    bool operator!=(const bind_ptr<U>&) const noexcept;
+
+    template<class U>
+    bool operator!=(U*) const noexcept;
+
+    template<class U>
+    bool operator<(const bind_ptr<U>&) const noexcept;
+
+    template<class U>
+    bool operator<(U*) const noexcept;
+
+    template<class U>
+    bool operator>(const bind_ptr<U>&) const noexcept;
+
+    template<class U>
+    bool operator>(U*) const noexcept;
+
+    template<class U>
+    bool operator<=(const bind_ptr<U>&) const noexcept;
+
+    template<class U>
+    bool operator<=(U*) const noexcept;
+
+    template<class U>
+    bool operator>=(const bind_ptr<U>&) const noexcept;
+
+    template<class U>
+    bool operator>=(U*) const noexcept;
+    //@}
+
+    // Dereference
+    T& operator*() const noexcept { return *m_ptr; }
+    T* operator->() const noexcept { return m_ptr; }
+
+    explicit operator bool() const noexcept { return m_ptr != 0; }
+
+    T* get() const noexcept { return m_ptr; }
+    void reset() noexcept { bind_ptr().swap(*this); }
+    void reset(T* p) noexcept { bind_ptr(p).swap(*this); }
+    template<class U>
+    void reset(U* p) noexcept { bind_ptr(p).swap(*this); }
+
+    T* release() noexcept { T* const p = m_ptr; m_ptr = nullptr; return p; }
+
+    void swap(bind_ptr& p) noexcept { std::swap(m_ptr, p.m_ptr); }
+    friend void swap(bind_ptr& a, bind_ptr& b) noexcept { a.swap(b); }
+
+protected:
+    struct casting_move_tag {};
+    template<class U>
+    bind_ptr(bind_ptr<U>* p, casting_move_tag) noexcept:
+        m_ptr(static_cast<T*>(p->release())) {}
+
+private:
+    T* m_ptr;
+
+    void bind(T* p) noexcept { if (p) p->bind_ptr(); m_ptr = p; }
+    void unbind() noexcept { if (m_ptr) m_ptr->unbind_ptr(); }
+
+    template<class> friend class bind_ptr;
+};
+
+
+template<class C, class T, class U>
+inline std::basic_ostream<C,T>& operator<<(std::basic_ostream<C,T>& out, const bind_ptr<U>& p)
+{
+    out << static_cast<const void*>(p.get());
+    return out;
+}
+
+
+//@{
+// Comparison
+template<class T, class U>
+bool operator==(T*, const bind_ptr<U>&) noexcept;
+template<class T, class U>
+bool operator!=(T*, const bind_ptr<U>&) noexcept;
+template<class T, class U>
+bool operator<(T*, const bind_ptr<U>&) noexcept;
+template<class T, class U>
+bool operator>(T*, const bind_ptr<U>&) noexcept;
+template<class T, class U>
+bool operator<=(T*, const bind_ptr<U>&) noexcept;
+template<class T, class U>
+bool operator>=(T*, const bind_ptr<U>&) noexcept;
+//@}
+
+
+
+/// Polymorphic convenience base class for reference counting objects.
+///
+/// Together with bind_ptr, this class delivers simple instrusive
+/// reference counting.
+///
+/// \sa bind_ptr
+class RefCountBase {
+public:
+    RefCountBase() noexcept: m_ref_count(0) {}
+    virtual ~RefCountBase() noexcept { REALM_ASSERT(m_ref_count == 0); }
+
+    RefCountBase(const RefCountBase&) = delete;
+    RefCountBase(RefCountBase&&) = delete;
+
+    void operator=(const RefCountBase&) = delete;
+    void operator=(RefCountBase&&) = delete;
+
+protected:
+    void bind_ptr() const noexcept { ++m_ref_count; }
+    void unbind_ptr() const noexcept { if (--m_ref_count == 0) delete this; }
+
+private:
+    mutable unsigned long m_ref_count;
+
+    template<class> friend class bind_ptr;
+};
+
+
+/// Same as RefCountBase, but this one makes the copying of, and the
+/// destruction of counted references thread-safe.
+///
+/// \sa RefCountBase
+/// \sa bind_ptr
+class AtomicRefCountBase {
+public:
+    AtomicRefCountBase() noexcept: m_ref_count(0) {}
+    virtual ~AtomicRefCountBase() noexcept { REALM_ASSERT(m_ref_count == 0); }
+
+    AtomicRefCountBase(const AtomicRefCountBase&) = delete;
+    AtomicRefCountBase(AtomicRefCountBase&&) = delete;
+
+    void operator=(const AtomicRefCountBase&) = delete;
+    void operator=(AtomicRefCountBase&&) = delete;
+
+protected:
+    // FIXME: Operators ++ and -- as used below use
+    // std::memory_order_seq_cst. I'm not sure whether this is the
+    // choice that leads to maximum efficiency, but at least it is
+    // safe.
+    void bind_ptr() const noexcept { ++m_ref_count; }
+    void unbind_ptr() const noexcept { if (--m_ref_count == 0) delete this; }
+
+private:
+    mutable std::atomic<unsigned long> m_ref_count;
+
+    template<class> friend class bind_ptr;
+};
+
+
+
+
+
+// Implementation:
+
+template<class T>
+template<class U>
+bool bind_ptr<T>::operator==(const bind_ptr<U>& p) const noexcept
+{
+    return m_ptr == p.m_ptr;
+}
+
+template<class T>
+template<class U>
+bool bind_ptr<T>::operator==(U* p) const noexcept
+{
+    return m_ptr == p;
+}
+
+template<class T>
+template<class U>
+bool bind_ptr<T>::operator!=(const bind_ptr<U>& p) const noexcept
+{
+    return m_ptr != p.m_ptr;
+}
+
+template<class T>
+template<class U>
+bool bind_ptr<T>::operator!=(U* p) const noexcept
+{
+    return m_ptr != p;
+}
+
+template<class T>
+template<class U>
+bool bind_ptr<T>::operator<(const bind_ptr<U>& p) const noexcept
+{
+    return m_ptr < p.m_ptr;
+}
+
+template<class T>
+template<class U>
+bool bind_ptr<T>::operator<(U* p) const noexcept
+{
+    return m_ptr < p;
+}
+
+template<class T>
+template<class U>
+bool bind_ptr<T>::operator>(const bind_ptr<U>& p) const noexcept
+{
+    return m_ptr > p.m_ptr;
+}
+
+template<class T>
+template<class U>
+bool bind_ptr<T>::operator>(U* p) const noexcept
+{
+    return m_ptr > p;
+}
+
+template<class T>
+template<class U>
+bool bind_ptr<T>::operator<=(const bind_ptr<U>& p) const noexcept
+{
+    return m_ptr <= p.m_ptr;
+}
+
+template<class T>
+template<class U>
+bool bind_ptr<T>::operator<=(U* p) const noexcept
+{
+    return m_ptr <= p;
+}
+
+template<class T>
+template<class U>
+bool bind_ptr<T>::operator>=(const bind_ptr<U>& p) const noexcept
+{
+    return m_ptr >= p.m_ptr;
+}
+
+template<class T>
+template<class U>
+bool bind_ptr<T>::operator>=(U* p) const noexcept
+{
+    return m_ptr >= p;
+}
+
+template<class T, class U>
+bool operator==(T* a, const bind_ptr<U>& b) noexcept
+{
+    return b == a;
+}
+
+template<class T, class U>
+bool operator!=(T* a, const bind_ptr<U>& b) noexcept
+{
+    return b != a;
+}
+
+template<class T, class U>
+bool operator<(T* a, const bind_ptr<U>& b) noexcept
+{
+    return b > a;
+}
+
+template<class T, class U>
+bool operator>(T* a, const bind_ptr<U>& b) noexcept
+{
+    return b < a;
+}
+
+template<class T, class U>
+bool operator<=(T* a, const bind_ptr<U>& b) noexcept
+{
+    return b >= a;
+}
+
+template<class T, class U>
+bool operator>=(T* a, const bind_ptr<U>& b) noexcept
+{
+    return b <= a;
+}
+
+
+} // namespace util
+} // namespace realm
+
+#endif // REALM_UTIL_BIND_PTR_HPP
diff --git a/Pods/Realm/include/core/realm/util/buffer.hpp b/Pods/Realm/include/core/realm/util/buffer.hpp
new file mode 100644
index 0000000..5c545af
--- /dev/null
+++ b/Pods/Realm/include/core/realm/util/buffer.hpp
@@ -0,0 +1,260 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_UTIL_BUFFER_HPP
+#define REALM_UTIL_BUFFER_HPP
+
+#include <cstddef>
+#include <algorithm>
+#include <exception>
+#include <limits>
+#include <utility>
+
+#include <realm/util/features.h>
+#include <realm/util/safe_int_ops.hpp>
+#include <memory>
+
+namespace realm {
+namespace util {
+
+
+/// A simple buffer concept that owns a region of memory and knows its
+/// size.
+template<class T>
+class Buffer {
+public:
+    Buffer() noexcept: m_size(0) {}
+    explicit Buffer(size_t initial_size);
+    Buffer(Buffer<T>&&) noexcept = default;
+    ~Buffer() noexcept {}
+
+    Buffer<T>& operator=(Buffer<T>&&) noexcept = default;
+
+    T& operator[](size_t i) noexcept { return m_data[i]; }
+    const T& operator[](size_t i) const noexcept { return m_data[i]; }
+
+    T* data() noexcept { return m_data.get(); }
+    const T* data() const noexcept { return m_data.get(); }
+    size_t size() const noexcept { return m_size; }
+
+    /// False iff the data() returns null.
+    explicit operator bool() const noexcept { return bool(m_data); }
+
+    /// Discards the original contents.
+    void set_size(size_t new_size);
+
+    /// \param copy_begin, copy_end Specifies a range of element
+    /// values to be retained. \a copy_end must be less than, or equal
+    /// to size().
+    ///
+    /// \param copy_to Specifies where the retained range should be
+    /// copied to. `\a copy_to + \a copy_end - \a copy_begin` must be
+    /// less than, or equal to \a new_size.
+    void resize(size_t new_size, size_t copy_begin, size_t copy_end,
+                size_t copy_to);
+
+    void reserve(size_t used_size, size_t min_capacity);
+
+    void reserve_extra(size_t used_size, size_t min_extra_capacity);
+
+    T* release() noexcept;
+
+    friend void swap(Buffer&a, Buffer&b) noexcept
+    {
+        using std::swap;
+        swap(a.m_data, b.m_data);
+        swap(a.m_size, b.m_size);
+    }
+
+private:
+    std::unique_ptr<T[]> m_data;
+    size_t m_size;
+};
+
+
+/// A buffer that can be efficiently resized. It acheives this by
+/// using an underlying buffer that may be larger than the logical
+/// size, and is automatically expanded in progressively larger steps.
+template<class T>
+class AppendBuffer {
+public:
+    AppendBuffer() noexcept;
+    ~AppendBuffer() noexcept {}
+
+    /// Returns the current size of the buffer.
+    size_t size() const noexcept;
+
+    /// Gives read and write access to the elements.
+    T* data() noexcept;
+
+    /// Gives read access the elements.
+    const T* data() const noexcept;
+
+    /// Append the specified elements. This increases the size of this
+    /// buffer by \a append_data_size. If the caller has previously requested
+    /// a minimum capacity that is greater than, or equal to the
+    /// resulting size, this function is guaranteed to not throw.
+    void append(const T* append_data, size_t append_data_size);
+
+    /// If the specified size is less than the current size, then the
+    /// buffer contents is truncated accordingly. If the specified
+    /// size is greater than the current size, then the extra elements
+    /// will have undefined values. If the caller has previously
+    /// requested a minimum capacity that is greater than, or equal to
+    /// the specified size, this function is guaranteed to not throw.
+    void resize(size_t new_size);
+
+    /// This operation does not change the size of the buffer as
+    /// returned by size(). If the specified capacity is less than the
+    /// current capacity, this operation has no effect.
+    void reserve(size_t min_capacity);
+
+    /// Set the size to zero. The capacity remains unchanged.
+    void clear() noexcept;
+
+private:
+    util::Buffer<char> m_buffer;
+    size_t m_size;
+};
+
+
+
+
+// Implementation:
+
+class BufferSizeOverflow: public std::exception {
+public:
+    const char* what() const noexcept override
+    {
+        return "Buffer size overflow";
+    }
+};
+
+template<class T>
+inline Buffer<T>::Buffer(size_t initial_size):
+    m_data(new T[initial_size]), // Throws
+    m_size(initial_size)
+{
+}
+
+template<class T>
+inline void Buffer<T>::set_size(size_t new_size)
+{
+    m_data.reset(new T[new_size]); // Throws
+    m_size = new_size;
+}
+
+template<class T>
+inline void Buffer<T>::resize(size_t new_size, size_t copy_begin,
+                                                size_t copy_end, size_t copy_to)
+{
+    std::unique_ptr<T[]> new_data(new T[new_size]); // Throws
+    std::copy(m_data.get() + copy_begin, m_data.get() + copy_end, new_data.get() + copy_to);
+    m_data.reset(new_data.release());
+    m_size = new_size;
+}
+
+template<class T>
+inline void Buffer<T>::reserve(size_t used_size,
+                                                 size_t min_capacity)
+{
+    size_t current_capacity = m_size;
+    if (REALM_LIKELY(current_capacity >= min_capacity))
+        return;
+    size_t new_capacity = current_capacity;
+    if (REALM_UNLIKELY(int_multiply_with_overflow_detect(new_capacity, 2)))
+        new_capacity = std::numeric_limits<size_t>::max();
+    if (REALM_UNLIKELY(new_capacity < min_capacity))
+        new_capacity = min_capacity;
+    resize(new_capacity, 0, used_size, 0); // Throws
+}
+
+template<class T>
+inline void Buffer<T>::reserve_extra(size_t used_size,
+                                                       size_t min_extra_capacity)
+{
+    size_t min_capacity = used_size;
+    if (REALM_UNLIKELY(int_add_with_overflow_detect(min_capacity, min_extra_capacity)))
+        throw BufferSizeOverflow();
+    reserve(used_size, min_capacity); // Throws
+}
+
+template<class T>
+inline T* Buffer<T>::release() noexcept
+{
+    m_size = 0;
+    return m_data.release();
+}
+
+
+template<class T>
+inline AppendBuffer<T>::AppendBuffer() noexcept: m_size(0)
+{
+}
+
+template<class T>
+inline size_t AppendBuffer<T>::size() const noexcept
+{
+    return m_size;
+}
+
+template<class T>
+inline T* AppendBuffer<T>::data() noexcept
+{
+    return m_buffer.data();
+}
+
+template<class T>
+inline const T* AppendBuffer<T>::data() const noexcept
+{
+    return m_buffer.data();
+}
+
+template<class T>
+inline void AppendBuffer<T>::append(const T* append_data, size_t append_data_size)
+{
+    m_buffer.reserve_extra(m_size, append_data_size); // Throws
+    std::copy(append_data, append_data+append_data_size, m_buffer.data()+m_size);
+    m_size += append_data_size;
+}
+
+template<class T>
+inline void AppendBuffer<T>::reserve(size_t min_capacity)
+{
+    m_buffer.reserve(m_size, min_capacity);
+}
+
+template<class T>
+inline void AppendBuffer<T>::resize(size_t new_size)
+{
+    reserve(new_size);
+    m_size = new_size;
+}
+
+template<class T>
+inline void AppendBuffer<T>::clear() noexcept
+{
+    m_size = 0;
+}
+
+
+} // namespace util
+} // namespace realm
+
+#endif // REALM_UTIL_BUFFER_HPP
diff --git a/Pods/Realm/include/core/realm/util/call_with_tuple.hpp b/Pods/Realm/include/core/realm/util/call_with_tuple.hpp
new file mode 100644
index 0000000..5605da4
--- /dev/null
+++ b/Pods/Realm/include/core/realm/util/call_with_tuple.hpp
@@ -0,0 +1,57 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_UTIL_CALL_WITH_TUPLE_HPP
+#define REALM_UTIL_CALL_WITH_TUPLE_HPP
+
+#include <stddef.h>
+#include <tuple>
+
+namespace realm {
+namespace _impl {
+
+template<size_t...> struct Indexes {};
+template<size_t N, size_t... I> struct GenIndexes: GenIndexes<N-1, N-1, I...> {};
+template<size_t... I> struct GenIndexes<0, I...> { typedef Indexes<I...> type; };
+
+template<class F, class... A, size_t... I>
+auto call_with_tuple(F func, std::tuple<A...> args, Indexes<I...>)
+    -> decltype(func(std::get<I>(args)...))
+{
+    static_cast<void>(args); // Prevent GCC warning when tuple is empty
+    return func(std::get<I>(args)...);
+}
+
+} // namespace _impl
+
+namespace util {
+
+template<class F, class... A>
+auto call_with_tuple(F func, std::tuple<A...> args)
+    -> decltype(_impl::call_with_tuple(std::move(func), std::move(args),
+                                       typename _impl::GenIndexes<sizeof... (A)>::type()))
+{
+    return _impl::call_with_tuple(std::move(func), std::move(args),
+                                  typename _impl::GenIndexes<sizeof... (A)>::type());
+}
+
+} // namespace util
+} // namespace realm
+
+#endif // REALM_UTIL_CALL_WITH_TUPLE_HPP
diff --git a/Pods/Realm/include/core/realm/util/cf_ptr.hpp b/Pods/Realm/include/core/realm/util/cf_ptr.hpp
new file mode 100644
index 0000000..29d8fe7
--- /dev/null
+++ b/Pods/Realm/include/core/realm/util/cf_ptr.hpp
@@ -0,0 +1,110 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2016] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+
+#ifndef REALM_UTIL_CF_PTR_HPP
+#define REALM_UTIL_CF_PTR_HPP
+
+#include <realm/util/assert.hpp>
+
+#if REALM_PLATFORM_APPLE
+
+#include <CoreFoundation/CoreFoundation.h>
+
+namespace realm {
+namespace util {
+
+template<class Ref>
+class CFPtr {
+public:
+    explicit CFPtr(Ref ref = nullptr) noexcept:
+        m_ref(ref)
+    {
+    }
+
+    CFPtr(CFPtr&& rg) noexcept:
+        m_ref(rg.m_ref)
+    {
+        rg.m_ref = nullptr;
+    }
+
+    ~CFPtr() noexcept
+    {
+        if (m_ref)
+            CFRelease(m_ref);
+    }
+
+    CFPtr& operator=(CFPtr&& rg) noexcept
+    {
+        REALM_ASSERT(!m_ref || m_ref != rg.m_ref);
+        if (m_ref)
+            CFRelease(m_ref);
+        m_ref = rg.m_ref;
+        rg.m_ref = nullptr;
+        return *this;
+    }
+
+    explicit operator bool() const noexcept
+    {
+        return bool(m_ref);
+    }
+
+    Ref get() const noexcept
+    {
+        return m_ref;
+    }
+
+    Ref release() noexcept
+    {
+        Ref ref = m_ref;
+        m_ref = nullptr;
+        return ref;
+    }
+
+    void reset(Ref ref = nullptr) noexcept
+    {
+        REALM_ASSERT(!m_ref || m_ref != ref);
+        if (m_ref)
+            CFRelease(m_ref);
+        m_ref = ref;
+    }
+
+private:
+    Ref m_ref;
+};
+
+template<class Ref>
+CFPtr<Ref> adoptCF(Ref ptr) {
+    return CFPtr<Ref>(ptr);
+}
+
+template<class Ref>
+CFPtr<Ref> retainCF(Ref ptr) {
+    CFRetain(ptr);
+    return CFPtr<Ref>(ptr);
+}
+
+
+}
+}
+
+
+#endif // REALM_PLATFORM_APPLE
+
+#endif // REALM_UTIL_CF_PTR_HPP
diff --git a/Pods/Realm/include/core/realm/util/config.h b/Pods/Realm/include/core/realm/util/config.h
new file mode 100644
index 0000000..2a670be
--- /dev/null
+++ b/Pods/Realm/include/core/realm/util/config.h
@@ -0,0 +1,27 @@
+/*************************************************************************
+ *
+ * CAUTION:  DO NOT EDIT THIS FILE -- YOUR CHANGES WILL BE LOST!
+ *
+ * This file is generated by config.sh
+ *
+ *************************************************************************/
+
+#define REALM_VERSION               "unknown"
+
+#define REALM_INSTALL_PREFIX        "/Users/realm/workspace/core_osx/install"
+#define REALM_INSTALL_EXEC_PREFIX   "/Users/realm/workspace/core_osx/install"
+#define REALM_INSTALL_INCLUDEDIR    "/Users/realm/workspace/core_osx/install/include"
+#define REALM_INSTALL_BINDIR        "/Users/realm/workspace/core_osx/install/bin"
+#define REALM_INSTALL_LIBDIR        "/Users/realm/workspace/core_osx/install/lib"
+#define REALM_INSTALL_LIBEXECDIR    "/Users/realm/workspace/core_osx/install/libexec"
+
+#ifdef REALM_DEBUG
+#  define REALM_MAX_BPNODE_SIZE     1000
+#else
+#  define REALM_MAX_BPNODE_SIZE     1000
+#endif
+
+#define REALM_ENABLE_ALLOC_SET_ZERO 0
+#define REALM_ENABLE_ENCRYPTION     1
+#define REALM_ENABLE_ASSERTIONS     1
+#define REALM_ENABLE_MEMDEBUG       0
diff --git a/Pods/Realm/include/core/realm/util/encrypted_file_mapping.hpp b/Pods/Realm/include/core/realm/util/encrypted_file_mapping.hpp
new file mode 100644
index 0000000..1fccb27
--- /dev/null
+++ b/Pods/Realm/include/core/realm/util/encrypted_file_mapping.hpp
@@ -0,0 +1,157 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+
+#ifndef REALM_UTIL_ENCRYPTED_FILE_MAPPING_HPP
+#define REALM_UTIL_ENCRYPTED_FILE_MAPPING_HPP
+
+#include <realm/util/file.hpp>
+#include <realm/util/thread.hpp>
+#include <realm/util/features.h>
+
+#if REALM_ENABLE_ENCRYPTION
+
+typedef size_t (*Header_to_size)(const char* addr);
+
+#include <vector>
+
+namespace realm {
+namespace util {
+
+struct SharedFileInfo;
+class EncryptedFileMapping;
+
+class EncryptedFileMapping {
+public:
+    // Adds the newly-created object to file.mappings iff it's successfully constructed
+    EncryptedFileMapping(SharedFileInfo& file, size_t file_offset,
+                         void* addr, size_t size, File::AccessMode access);
+    ~EncryptedFileMapping();
+
+    // Write all dirty pages to disk and mark them read-only
+    // Does not call fsync
+    void flush() noexcept;
+
+    // Sync this file to disk
+    void sync() noexcept;
+
+    // Make sure that memory in the specified range is synchronized with any
+    // changes made globally visible through call to write_barrier
+    void read_barrier(const void* addr, size_t size,
+                      UniqueLock& lock,
+                      Header_to_size header_to_size);
+
+    // Ensures that any changes made to memory in the specified range
+    // becomes visible to any later calls to read_barrier()
+    void write_barrier(const void* addr, size_t size) noexcept;
+
+    // Set this mapping to a new address and size
+    // Flushes any remaining dirty pages from the old mapping
+    void set(void* new_addr, size_t new_size, size_t new_file_offset);
+
+private:
+    SharedFileInfo& m_file;
+
+    size_t m_page_shift;
+    size_t m_blocks_per_page;
+
+    void* m_addr = nullptr;
+    size_t m_file_offset = 0;
+
+    uintptr_t m_first_page;
+    size_t m_page_count = 0;
+
+    std::vector<char> m_up_to_date_pages;
+    std::vector<bool> m_dirty_pages;
+
+    File::AccessMode m_access;
+
+#ifdef REALM_DEBUG
+    std::unique_ptr<char[]> m_validate_buffer;
+#endif
+
+    char* page_addr(size_t i) const noexcept;
+
+    void mark_outdated(size_t i) noexcept;
+    void mark_up_to_date(size_t i) noexcept;
+    void mark_unwritable(size_t i) noexcept;
+
+    bool copy_up_to_date_page(size_t i) noexcept;
+    void refresh_page(size_t i);
+    void write_page(size_t i) noexcept;
+
+    void validate_page(size_t i) noexcept;
+    void validate() noexcept;
+};
+
+
+
+inline void EncryptedFileMapping::read_barrier(const void* addr, size_t size,
+                                               UniqueLock& lock,
+                                               Header_to_size header_to_size)
+{
+    size_t first_accessed_page = reinterpret_cast<uintptr_t>(addr) >> m_page_shift;
+    size_t first_idx = first_accessed_page - m_first_page;
+
+    // make sure the first page is available
+    if (!m_up_to_date_pages[first_idx]) {
+        if (!lock.holds_lock())
+            lock.lock();
+        refresh_page(first_idx);
+    }
+
+    if (header_to_size) {
+
+        // We know it's an array, and array headers are 8-byte aligned, so it is
+        // included in the first page which was handled above.
+        size = header_to_size(static_cast<const char*>(addr));
+    }
+    size_t last_accessed_page = (reinterpret_cast<uintptr_t>(addr)+size-1) >> m_page_shift;
+    size_t last_idx = last_accessed_page - m_first_page;
+
+    for (size_t idx = first_idx+1; idx <= last_idx; ++idx) {
+        if (!m_up_to_date_pages[idx]) {
+            if (!lock.holds_lock())
+                lock.lock();
+            refresh_page(idx);
+        }
+    }
+}
+
+
+
+
+}
+}
+
+#endif // REALM_ENABLE_ENCRYPTION
+
+namespace realm {
+namespace util {
+
+/// Thrown by EncryptedFileMapping if a file opened is non-empty and does not
+/// contain valid encrypted data
+struct DecryptionFailed: util::File::AccessError {
+    DecryptionFailed(): util::File::AccessError("Decryption failed", std::string()) {}
+};
+
+}
+}
+
+#endif // REALM_UTIL_ENCRYPTED_FILE_MAPPING_HPP
diff --git a/Pods/Realm/include/core/realm/util/event_loop.hpp b/Pods/Realm/include/core/realm/util/event_loop.hpp
new file mode 100644
index 0000000..e826a56
--- /dev/null
+++ b/Pods/Realm/include/core/realm/util/event_loop.hpp
@@ -0,0 +1,474 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+
+#include <stddef.h>
+#include <memory>
+#include <functional>
+#include <chrono>
+#include <exception>
+#include <string>
+#include <vector>
+#include <system_error>
+
+#ifndef REALM_UTIL_EVENT_LOOP_HPP
+#define REALM_UTIL_EVENT_LOOP_HPP
+
+namespace realm {
+namespace util {
+
+class EventLoop;
+class Socket;
+class DeadlineTimer;
+
+
+/// \brief Create an event loop using the default implementation
+/// (EventLoop::Implementation::get_default()).
+std::unique_ptr<EventLoop> make_event_loop();
+
+
+/// Event Loops are an abstraction over asynchronous I/O.
+///
+/// The interface described by EventLoop is a "proactor pattern" approach to
+/// asynchronous I/O. All operations are started with a completion handler,
+/// which is invoked once the operation "completes", i.e. succeeds, fails, or is
+/// cancelled.
+///
+/// In general, completion handlers are always invoked, regardless of whether or
+/// not the operation was successful.
+///
+/// Most operations return an abstract handle through a smart pointer, which can
+/// be used to cancel the operation or reschedule a new operation. In general,
+/// if the handle (socket or timer) is destroyed and an operation is in
+/// progress, the operation is cancelled.
+///
+/// Operations on an event-loop are generally **not thread-safe** (exceptions
+/// are post(), stop(), and reset(), which are thread-safe).
+///
+/// \sa Socket
+/// \sa DeadlineTimer
+class EventLoop {
+public:
+    using PostCompletionHandler = std::function<void()>;
+
+    virtual std::unique_ptr<Socket> make_socket() = 0;
+    virtual std::unique_ptr<DeadlineTimer> make_timer() = 0;
+
+    /// \brief Submit a handler to be executed by the event loop thread.
+    ///
+    /// Register the sepcified completion handler for immediate asynchronous
+    /// execution. The specified handler object will be copied as necessary, and
+    /// will be executed by an expression on the form `handler()`.
+    ///
+    /// This function is thread-safe, that is, it may be called by any
+    /// thread. It may also be called from other completion handlers.
+    ///
+    /// The handler will never be called as part of the execution of post(). It
+    /// will always be called by a thread that is executing run(). If no thread
+    /// is currently executing run(), the handler will not be executed until a
+    /// thread starts executing run(). If post() is called while another thread
+    /// is executing run(), the handler may be called before post() returns. If
+    /// post() is called from another completion handler, the submitted handler
+    /// is guaranteed to not be called during the execution of post().
+    ///
+    /// Completion handlers added through post() will be executed in the order
+    /// that they are added. More precisely, if post() is called twice to add
+    /// two handlers, A and B, and the execution of post(A) ends before the
+    /// beginning of the execution of post(B), then A is guaranteed to execute
+    /// before B.
+    virtual void post(PostCompletionHandler) = 0;
+
+    /// \brief Execute the event loop.
+    ///
+    /// Execute completion handlers of completed asynchronous operations, or
+    /// wait for more completion handlers to become ready for
+    /// execution. Handlers submitted via post() are considered immeditely
+    /// ready. If there are no completion handlers ready for execution, and
+    /// there are no asynchronous operations in progress, run() returns.
+    ///
+    /// All completion handlers, including handlers submitted via post() will be
+    /// executed from run(), that is by the thread that executes run(). If no
+    /// thread executes run(), then the completion handlers will not be
+    /// executed.
+    ///
+    /// Exceptions thrown by completion handlers will always propagate back
+    /// through run().
+    virtual void run() = 0;
+
+    /// @{ \brief Stop event loop execution.
+    ///
+    /// stop() puts the event loop into the stopped mode. If a thread is currently
+    /// executing run(), it will be made to return in a timely fashion, that is,
+    /// without further blocking. If a thread is currently blocked in run(), it
+    /// will be unblocked. Handlers that can be executed immediately, may, or
+    /// may not be executed before run() returns, but new handlers submitted by
+    /// these, will not be executed.
+    ///
+    /// The event loop will remain in the stopped mode until reset() is
+    /// called. If reset() is called before run() returns, it may, or may not
+    /// cause run() to continue normal operation without returning.
+    ///
+    /// Both stop() and reset() are thread-safe, that is, they may be called by
+    /// any thread. Also, both of these function may be called from completion
+    /// handlers (including posted handlers).
+    virtual void stop() noexcept = 0;
+    virtual void reset() noexcept = 0;
+    /// @}
+
+    virtual ~EventLoop() {}
+
+    class Implementation;
+};
+
+
+enum class SocketSecurity {
+    None,  ///< No socket security (cleartext).
+    TLSv1, ///< Transport Layer Security v1 (encrypted).
+};
+
+
+/// Socket describes an event handler for socket operations.
+///
+/// It is also used to schedule individual I/O operations on a socket.
+class Socket {
+public:
+    using port_type = uint_fast16_t;
+    using ConnectCompletionHandler =
+        std::function<void(std::error_code)>;
+    using ReadCompletionHandler =
+        std::function<void(std::error_code, size_t num_bytes_transferred)>;
+    using WriteCompletionHandler =
+        std::function<void(std::error_code, size_t num_bytes_transferred)>;
+
+    /// \brief Perform an asynchronous connect operation.
+    ///
+    /// Initiate an asynchronous connect operation. The completion handler is
+    /// called when the operation completes. The operation completes when the
+    /// connection is established, or an error occurs.
+    ///
+    /// The completion handler is always executed by the event loop thread,
+    /// i.e., by a thread that is executing EventLoop::run(). Conversely, the
+    /// completion handler is guaranteed to not be called while no thread is
+    /// executing EventLoop::run(). The execution of the completion handler is
+    /// always deferred to the event loop, meaning that it never happens as a
+    /// synchronous side effect of the execution of async_connect(), even when
+    /// async_connect() is executed by the event loop thread. The completion
+    /// handler is guaranteed to be called eventually, as long as there is time
+    /// enough for the operation to complete or fail, and a thread is executing
+    /// EventLoop::run() for long enough.
+    ///
+    /// The operation can be canceled by calling cancel(), and will be
+    /// automatically canceled if the socket is closed. If the operation is
+    /// canceled, it will fail with `error::operation_aborted`. The operation
+    /// remains cancelable up until the point in time where the completion
+    /// handler starts to execute. This means that if cancel() is called before
+    /// the completion handler starts to execute, then the completion handler is
+    /// guaranteed to have `error::operation_aborted` passed to it. This is true
+    /// regardless of whether cancel() is called explicitly or implicitly, such
+    /// as when the socket is destroyed.
+    ///
+    /// The specified handler object will be copied as necessary, and will be
+    /// executed by an expression on the form `handler(ec)` where `ec` is the
+    /// error code.
+    ///
+    /// It is an error to start a new connect operation while another connect
+    /// operation is in progress. A connect operation is considered complete as
+    /// soon as the completion handler starts to execute.
+    virtual void async_connect(std::string host, port_type port, SocketSecurity security,
+                               ConnectCompletionHandler handler) = 0;
+
+    /// @{ \brief Perform an asynchronous read operation.
+    ///
+    /// Initiate an asynchronous buffered read operation. The completion handler
+    /// will be called when the operation completes, or an error occurs.
+    ///
+    /// async_read() will continue reading until the specified buffer is full,
+    /// or an error occurs. If the end of input is reached before the buffer is
+    /// filled, the operation fails with `network::end_of_input`.
+    ///
+    /// async_read_until() will continue reading until the specified buffer
+    /// contains the specified delimiter, or an error occurs. If the buffer is
+    /// filled before a delimiter is found, the operation fails with
+    /// `network::delim_not_found`. Otherwise, if the end of input is reached
+    /// before a delimiter is found, the operation fails with
+    /// `network::end_of_input`. Otherwise, if the operation succeeds, the last
+    /// byte placed in the buffer is the delimiter.
+    ///
+    /// The completion handler is always executed by the event loop thread,
+    /// i.e., by a thread that is executing EventLoop::run(). Conversely, the
+    /// completion handler is guaranteed to not be called while no thread is
+    /// executing EventLoop::run(). The execution of the completion handler is
+    /// always deferred to the event loop, meaning that it never happens as a
+    /// synchronous side effect of the execution of async_read() or
+    /// async_read_until(), even when async_read() or async_read_until() is
+    /// executed by the event loop thread. The completion handler is guaranteed
+    /// to be called eventually, as long as there is time enough for the
+    /// operation to complete or fail, and a thread is executing
+    /// EventLoop::run() for long enough.
+    ///
+    /// The operation can be canceled by calling cancel(), and will be
+    /// automatically canceled if the socket is closed. If the operation is
+    /// canceled, it will fail with `error::operation_aborted`. The operation
+    /// remains cancelable up until the point in time where the completion
+    /// handler starts to execute. This means that if cancel() is called before
+    /// the completion handler starts to execute, then the completion handler is
+    /// guaranteed to have `error::operation_aborted` passed to it. This is true
+    /// regardless of whether cancel() is called explicitly or implicitly, such
+    /// as when the socket is destroyed.
+    ///
+    /// The specified handler object will be copied as necessary, and will be
+    /// executed by an expression on the form `handler(ec, n)` where `ec` is the
+    /// error code, and `n` is the number of bytes placed in the buffer. `n` is
+    /// guaranteed to be less than, or equal to \a size.
+    ///
+    /// It is an error to start a read operation before the socket is connected.
+    ///
+    /// It is an error to start a new read operation while another read
+    /// operation is in progress. A read operation is considered complete as
+    /// soon as the completion handler starts executing. This means that a new
+    /// read operation can be started from the completion handler of another
+    /// read operation.
+    virtual void async_read(char* buffer, size_t size, ReadCompletionHandler handler) = 0;
+    virtual void async_read_until(char* buffer, size_t size, char delim,
+                                  ReadCompletionHandler handler) = 0;
+    /// @}
+
+    /// \brief Perform an asynchronous write operation.
+    ///
+    /// Initiate an asynchronous write operation. The completion handler is
+    /// called when the operation completes. The operation completes when all
+    /// the specified bytes have been written to the socket, or an error occurs.
+    ///
+    /// The completion handler is always executed by the event loop thread,
+    /// i.e., by a thread that is executing EventLoop::run(). Conversely, the
+    /// completion handler is guaranteed to not be called while no thread is
+    /// executing EventLoop::run(). The execution of the completion handler is
+    /// always deferred to the event loop, meaning that it never happens as a
+    /// synchronous side effect of the execution of async_write(), even when
+    /// async_write() is executed by the event loop thread. The completion
+    /// handler is guaranteed to be called eventually, as long as there is time
+    /// enough for the operation to complete or fail, and a thread is executing
+    /// EventLoop::run() for long enough.
+    ///
+    /// The operation can be canceled by calling cancel(), and will be
+    /// automatically canceled if the socket is closed. If the operation is
+    /// canceled, it will fail with `error::operation_aborted`. The operation
+    /// remains cancelable up until the point in time where the completion
+    /// handler starts to execute. This means that if cancel() is called before
+    /// the completion handler starts to execute, then the completion handler is
+    /// guaranteed to have `error::operation_aborted` passed to it. This is true
+    /// regardless of whether cancel() is called explicitly or implicitly, such
+    /// as when the socket is destroyed.
+    ///
+    /// The specified handler object will be copied as necessary, and will be
+    /// executed by an expression on the form `handler(ec, n)` where `ec` is the
+    /// error code, and `n` is the number of bytes written (of type `size_t`).
+    ///
+    /// It is an error to start a write operation before the socket is
+    /// connected.
+    ///
+    /// It is an error to start a new write operation while another write
+    /// operation is in progress. A write operation is considered complete as
+    /// soon as the completion handler starts to execute. This means that a new
+    /// write operation can be started from the completion handler of another
+    /// write operation.
+    virtual void async_write(const char* data, size_t size, WriteCompletionHandler handler) = 0;
+
+    /// \brief Close this socket.
+    ///
+    /// If the socket is connected, it will be disconnected. If it is already
+    /// disconnected (or never connected), this function does nothing
+    /// (idempotency).
+    ///
+    /// A socket is automatically closed when destroyed.
+    ///
+    /// When the socket is closed, any incomplete asynchronous operation will be
+    /// canceled (as if cancel() was called).
+    virtual void close() noexcept = 0;
+
+    /// \brief Cancel all asynchronous operations.
+    ///
+    /// Cause all incomplete asynchronous operations, that are associated with
+    /// this socket, to fail with `error::operation_aborted`. An asynchronous
+    /// operation is complete precisely when its completion handler starts
+    /// executing.
+    ///
+    /// Completion handlers of canceled operations will become immediately ready
+    /// to execute, but will never be executed directly as part of the execution
+    /// of cancel().
+    virtual void cancel() noexcept = 0;
+
+    virtual EventLoop& get_event_loop() noexcept = 0;
+
+    virtual ~Socket() {}
+};
+
+
+class DeadlineTimer {
+public:
+    using Duration = std::chrono::milliseconds;
+    using WaitCompletionHandler = std::function<void(std::error_code)>;
+
+    /// \brief Perform an asynchronous wait operation.
+    ///
+    /// Initiate an asynchronous wait operation. The completion handler becomes
+    /// ready to execute when the expiration time is reached, or an error occurs
+    /// (cancellation counts as an error here). The expiration time is the time
+    /// of initiation plus the specified delay. The error code passed to the
+    /// complition handler will **never** indicate success, unless the
+    /// expiration time was reached.
+    ///
+    /// The completion handler is always executed by the event loop thread,
+    /// i.e., by a thread that is executing EventLoop::run(). Conversely, the
+    /// completion handler is guaranteed to not be called while no thread is
+    /// executing EventLoop::run(). The execution of the completion handler is
+    /// always deferred to the event loop, meaning that it never happens as a
+    /// synchronous side effect of the execution of async_wait(), even when
+    /// async_wait() is executed by the event loop thread. The completion
+    /// handler is guaranteed to be called eventually, as long as there is time
+    /// enough for the operation to complete or fail, and a thread is executing
+    /// EventLoop::run() for long enough.
+    ///
+    /// The operation can be canceled by calling cancel(), and will be
+    /// automatically canceled if the timer is destroyed. If the operation is
+    /// canceled, it will fail with `error::operation_aborted`. The operation
+    /// remains cancelable up until the point in time where the completion
+    /// handler starts to execute. This means that if cancel() is called before
+    /// the completion handler starts to execute, then the completion handler is
+    /// guaranteed to have `error::operation_aborted` passed to it. This is true
+    /// regardless of whether cancel() is called explicitly or implicitly, such
+    /// as when the timer is destroyed.
+    ///
+    /// The specified handler object will be copied as necessary, and will be
+    /// executed by an expression on the form `handler(ec)` where `ec` is the
+    /// error code.
+    ///
+    /// It is an error to start a new wait operation while an another one is in
+    /// progress. A wait operation is in progress until its completion handler
+    /// starts to execute.
+    ///
+    /// \param delay The amount of time to wait, represented as anumber of
+    /// milliseconds. If the delay is zero or negative, the wait is considered
+    /// complete immediately.
+    virtual void async_wait(Duration delay, WaitCompletionHandler handler) = 0;
+
+    /// \brief Cancel an asynchronous wait operation.
+    ///
+    /// If an asynchronous wait operation, that is associated with this deadline
+    /// timer, is in progress, cause it to fail with
+    /// `error::operation_aborted`. An asynchronous wait operation is in
+    /// progress until its completion handler starts to execute.
+    ///
+    /// Completion handlers of canceled operations will become immediately ready
+    /// to execute, but will never be executed directly as part of the execution
+    /// of cancel().
+    virtual void cancel() noexcept = 0;
+
+    virtual EventLoop& get_event_loop() noexcept = 0;
+
+    virtual ~DeadlineTimer() {}
+};
+
+
+class EventLoop::Implementation {
+public:
+    class NotAvailable;
+
+    /// \brief Get the default event loop implementation.
+    ///
+    /// In general, the best implementation is chosen when several are
+    /// available, On Apple iOS, this will be the implementation returned by
+    /// get_apple_cf(). On most other platforms (including Linux), it will be
+    /// the implementation returned by get_posix().
+    ///
+    /// \throw NotAvailable if no implementation is available on this platform.
+    static Implementation& get_default();
+
+    /// \brief Get an implementations by name.
+    ///
+    /// \throw NotAvailable if no implementation is available with the specified
+    /// name on this platform.
+    static Implementation& get(const std::string& name);
+
+    /// \brief Get all the available implementations on this platform.
+    ///
+    /// If no implementations are available on this platform, this function
+    /// returns an empty vector.
+    static std::vector<Implementation*> get_all();
+
+    /// \brief Get an implementation base on the POSIX level networking API.
+    ///
+    /// The name of this implementation is `posix`.
+    ///
+    /// This function returns null on platforms where this implementation is not
+    /// available.
+    ///
+    /// This implementation is guaranteed to be available on Linux, Android, Mac
+    /// OS X, and iOS.
+    ///
+    /// \throw NotAvailable if this implementation is not available on this
+    /// platform.
+    static Implementation& get_posix();
+
+    /// \brief Get an implementation base on the networking API provided by the
+    /// Apple Core Foundation library (`CFRunLoop`).
+    ///
+    /// The name of this implementation is `apple-cf`.
+    ///
+    /// This implementation is guaranteed to be available on Mac OS X and
+    /// iOS. This is the default implementation on iOS, because according to
+    /// Apple's documentaion, POSIX level socket operations are not guaranteed
+    /// to properly activate the radio antenna.
+    ///
+    /// \throw NotAvailable if this implementation is not available on this
+    /// platform.
+    static Implementation& get_apple_cf();
+
+    /// \brief Get the name of this implementation.
+    virtual std::string name() const = 0;
+
+    /// \brief Create an event loop that uses this implementation.
+    virtual std::unique_ptr<EventLoop> make_event_loop() = 0;
+
+    virtual ~Implementation() {}
+};
+
+
+
+
+// Implementation
+
+inline std::unique_ptr<EventLoop> make_event_loop()
+{
+    return EventLoop::Implementation::get_default().make_event_loop(); // Throws
+}
+
+class EventLoop::Implementation::NotAvailable: public std::exception {
+    const char* what() const noexcept override
+    {
+        return "No such event loop implementation on this platform";
+    }
+};
+
+} // namespace util
+} // namespace realm
+
+
+#endif // REALM_UTIL_EVENT_LOOP_HPP
+
diff --git a/Pods/Realm/include/core/realm/util/features.h b/Pods/Realm/include/core/realm/util/features.h
new file mode 100644
index 0000000..940082c
--- /dev/null
+++ b/Pods/Realm/include/core/realm/util/features.h
@@ -0,0 +1,266 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ *************************************************************************/
+#ifndef REALM_UTIL_FEATURES_H
+#define REALM_UTIL_FEATURES_H
+
+#ifdef _MSC_VER
+#  pragma warning(disable:4800) // Visual Studio int->bool performance warnings
+#endif
+
+#ifdef REALM_HAVE_CONFIG
+#  include <realm/util/config.h>
+#else
+#  define REALM_VERSION               "unknown"
+
+// Even if we don't have config.h (generated by `build.sh config`), it is still
+// possible that the following three defines are set by another build system
+// (such as Xcode or VS).
+
+#  ifndef REALM_ENABLE_ALLOC_SET_ZERO
+#    define REALM_ENABLE_ALLOC_SET_ZERO 0
+#  endif
+
+#  ifndef REALM_ENABLE_ENCRYPTION
+#    define REALM_ENABLE_ENCRYPTION     0
+#  endif
+
+#  ifndef REALM_ENABLE_ASSERTIONS
+#    define REALM_ENABLE_ASSERTIONS     0
+#  endif
+
+#  ifndef REALM_ENABLE_MEMDEBUG
+#    define REALM_ENABLE_MEMDEBUG       0
+#  endif
+
+#  ifndef _WIN32
+#    define REALM_INSTALL_PREFIX      "/usr/local"
+#    define REALM_INSTALL_EXEC_PREFIX REALM_INSTALL_PREFIX
+#    define REALM_INSTALL_INCLUDEDIR  REALM_INSTALL_PREFIX "/include"
+#    define REALM_INSTALL_BINDIR      REALM_INSTALL_EXEC_PREFIX "/bin"
+#    define REALM_INSTALL_LIBDIR      REALM_INSTALL_EXEC_PREFIX "/lib"
+#    define REALM_INSTALL_LIBEXECDIR  REALM_INSTALL_EXEC_PREFIX "/libexec"
+#  endif
+#endif
+
+/* The maximum number of elements in a B+-tree node. Applies to inner nodes and
+ * to leaves. The minimum allowable value is 2.
+ */
+#ifndef REALM_MAX_BPNODE_SIZE
+#  define REALM_MAX_BPNODE_SIZE 1000
+#endif
+
+
+#define REALM_QUOTE_2(x) #x
+#define REALM_QUOTE(x) REALM_QUOTE_2(x)
+
+/* See these links for information about feature check macroes in GCC,
+ * Clang, and MSVC:
+ *
+ * http://gcc.gnu.org/projects/cxx0x.html
+ * http://clang.llvm.org/cxx_status.html
+ * http://clang.llvm.org/docs/LanguageExtensions.html#checks-for-standard-language-features
+ * http://msdn.microsoft.com/en-us/library/vstudio/hh567368.aspx
+ * http://sourceforge.net/p/predef/wiki/Compilers
+ */
+
+
+/* Compiler is GCC and version is greater than or equal to the specified version */
+#define REALM_HAVE_AT_LEAST_GCC(maj, min) \
+    (__GNUC__ > (maj) || __GNUC__ == (maj) && __GNUC_MINOR__ >= (min))
+
+#if defined(__clang__)
+#  define REALM_HAVE_CLANG_FEATURE(feature) __has_feature(feature)
+#  define REALM_HAVE_CLANG_WARNING(warning) __has_warning(warning)
+#else
+#  define REALM_HAVE_CLANG_FEATURE(feature) 0
+#  define REALM_HAVE_CLANG_WARNING(warning) 0
+#endif
+
+#if defined(__GNUC__) // clang or GCC
+#  define REALM_PRAGMA(v) _Pragma(REALM_QUOTE_2(v))
+#elif defined(_MSC_VER) // VS
+#  define REALM_PRAGMA(v) __pragma(v)
+#else
+#  define REALM_PRAGMA(v)
+#endif
+
+#if defined(__clang__)
+#  define  REALM_DIAG(v) REALM_PRAGMA(clang diagnostic v)
+#elif defined(__GNUC__)
+#  define REALM_DIAG(v) REALM_PRAGMA(GCC diagnostic v)
+#else
+#  define REALM_DIAG(v)
+#endif
+
+#define REALM_DIAG_PUSH() REALM_DIAG(push)
+#define REALM_DIAG_POP() REALM_DIAG(pop)
+
+#if REALM_HAVE_CLANG_WARNING("-Wtautological-compare") \
+    || REALM_HAVE_AT_LEAST_GCC(6, 0)
+#  define REALM_DIAG_IGNORE_TAUTOLOGICAL_COMPARE() \
+    REALM_DIAG(ignored "-Wtautological-compare")
+#else
+#  define REALM_DIAG_IGNORE_TAUTOLOGICAL_COMPARE()
+#endif
+
+#ifdef _MSC_VER
+#  define REALM_DIAG_IGNORE_UNSIGNED_MINUS() REALM_PRAGMA(warning(disable:4146)) 
+#else
+#  define REALM_DIAG_IGNORE_UNSIGNED_MINUS() 
+#endif
+
+/* Compiler is MSVC (Microsoft Visual C++) */
+#if defined(_MSC_VER) && _MSC_VER >= 1600
+#  define REALM_HAVE_AT_LEAST_MSVC_10_2010 1
+#endif
+#if defined(_MSC_VER) && _MSC_VER >= 1700
+#  define REALM_HAVE_AT_LEAST_MSVC_11_2012 1
+#endif
+#if defined(_MSC_VER) && _MSC_VER >= 1800
+#  define REALM_HAVE_AT_LEAST_MSVC_12_2013 1
+#endif
+
+
+/* The way to specify that a function never returns. */
+#if REALM_HAVE_AT_LEAST_GCC(4, 8) || REALM_HAVE_CLANG_FEATURE(cxx_attributes)
+#  define REALM_NORETURN [[noreturn]]
+#elif __GNUC__
+#  define REALM_NORETURN __attribute__((noreturn))
+#elif defined(_MSC_VER)
+#  define REALM_NORETURN __declspec(noreturn)
+#else
+#  define REALM_NORETURN
+#endif
+
+
+/* The way to specify that a variable or type is intended to possibly
+ * not be used. Use it to suppress a warning from the compiler. */
+#if __GNUC__
+#  define REALM_UNUSED __attribute__((unused))
+#else
+#  define REALM_UNUSED
+#endif
+
+
+#if __GNUC__ || defined __INTEL_COMPILER
+#  define REALM_UNLIKELY(expr) __builtin_expect(!!(expr), 0)
+#  define REALM_LIKELY(expr)   __builtin_expect(!!(expr), 1)
+#else
+#  define REALM_UNLIKELY(expr) (expr)
+#  define REALM_LIKELY(expr)   (expr)
+#endif
+
+
+#if defined(__GNUC__) || defined(__HP_aCC)
+#  define REALM_FORCEINLINE inline __attribute__((always_inline))
+#elif defined(_MSC_VER)
+#  define REALM_FORCEINLINE __forceinline
+#else
+#  define REALM_FORCEINLINE inline
+#endif
+
+
+#if defined(__GNUC__) || defined(__HP_aCC)
+#  define REALM_NOINLINE  __attribute__((noinline))
+#elif defined(_MSC_VER)
+#  define REALM_NOINLINE __declspec(noinline)
+#else
+#  define REALM_NOINLINE
+#endif
+
+
+/* Thread specific data (only for POD types) */
+#if defined __clang__
+#  define REALM_THREAD_LOCAL __thread
+#else
+#  define REALM_THREAD_LOCAL thread_local
+#endif
+
+
+#if defined __ANDROID__
+#  define REALM_ANDROID 1
+#else
+#  define REALM_ANDROID 0
+#endif
+
+// Some documentation of the defines provided by Apple:
+// http://developer.apple.com/library/mac/documentation/Porting/Conceptual/PortingUnix/compiling/compiling.html#//apple_ref/doc/uid/TP40002850-SW13
+#if defined __APPLE__ && defined __MACH__
+#  define REALM_PLATFORM_APPLE 1
+/* Apple OSX and iOS (Darwin). */
+#  include <TargetConditionals.h>
+#  if TARGET_OS_IPHONE == 1
+/* Device (iPhone or iPad) or simulator. */
+#    define REALM_IOS 1
+#  else
+#    define REALM_IOS 0
+#  endif
+#  if TARGET_OS_WATCH == 1
+/* Device (Apple Watch) or simulator. */
+#    define REALM_WATCHOS 1
+/* The necessary signal handling / mach exception APIs are all unavailable */
+#    undef  REALM_ENABLE_ENCRYPTION
+#    define REALM_ENABLE_ENCRYPTION 0
+#  else
+#    define REALM_WATCHOS 0
+#  endif
+#  if TARGET_OS_TV
+/* Device (Apple TV) or simulator. */
+#    define REALM_TVOS 1
+#  else
+#    define REALM_TVOS 0
+#  endif
+#else
+#  define REALM_PLATFORM_APPLE 0
+#  define REALM_IOS 0
+#  define REALM_WATCHOS 0
+#  define REALM_TVOS 0
+#endif
+
+
+#if REALM_ANDROID || REALM_IOS || REALM_WATCHOS
+#  define REALM_MOBILE 1
+#endif
+
+
+#if defined(REALM_DEBUG) && !defined(REALM_COOKIE_CHECK)
+#  define REALM_COOKIE_CHECK
+#endif
+
+#if !REALM_IOS && !REALM_WATCHOS && !REALM_TVOS && !defined(_WIN32)
+#  define REALM_ASYNC_DAEMON
+#endif
+
+// We're in i686 mode
+#if defined(__i386) || defined(__i386__) || defined(__i686__) || defined(_M_I86) || defined(_M_IX86)
+#  define REALM_ARCHITECTURE_X86_32 1
+#else
+#  define REALM_ARCHITECTURE_X86_32 0
+#endif
+
+// We're in amd64 mode
+#if defined(__amd64) || defined(__amd64__) || defined(__x86_64) || defined(__x86_64__) \
+    || defined(_M_X64) || defined(_M_AMD64)
+#  define REALM_ARCHITECTURE_X86_64 1
+#else
+#  define REALM_ARCHITECTURE_X86_64 0
+#endif
+
+#endif /* REALM_UTIL_FEATURES_H */
diff --git a/Pods/Realm/include/core/realm/util/file.hpp b/Pods/Realm/include/core/realm/util/file.hpp
new file mode 100644
index 0000000..97feb03
--- /dev/null
+++ b/Pods/Realm/include/core/realm/util/file.hpp
@@ -0,0 +1,1076 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_UTIL_FILE_HPP
+#define REALM_UTIL_FILE_HPP
+
+#include <cstddef>
+#include <stdint.h>
+#include <memory>
+#include <stdexcept>
+#include <string>
+#include <streambuf>
+
+#ifndef _WIN32
+#  include <dirent.h> // POSIX.1-2001
+#endif
+
+#include <realm/util/features.h>
+#include <realm/util/assert.hpp>
+#include <realm/util/safe_int_ops.hpp>
+
+
+namespace realm {
+namespace util {
+
+class EncryptedFileMapping;
+
+/// Create the specified directory in the file system.
+///
+/// \throw File::AccessError If the directory could not be created. If
+/// the reason corresponds to one of the exception types that are
+/// derived from File::AccessError, the derived exception type is
+/// thrown (as long as the underlying system provides the information
+/// to unambiguously distinguish that particular reason).
+void make_dir(const std::string& path);
+
+/// Same as make_dir() except that this one returns false, rather than throwing
+/// an exception, if the specified directory already existed. If the directory
+// did not already exist and was newly created, this returns true.
+bool try_make_dir(const std::string& path);
+
+/// Remove the specified directory path from the file system. If the
+/// specified path is a directory, this function is equivalent to
+/// std::remove(const char*).
+///
+/// \throw File::AccessError If the directory could not be removed. If
+/// the reason corresponds to one of the exception types that are
+/// derived from File::AccessError, the derived exception type is
+/// thrown (as long as the underlying system provides the information
+/// to unambiguously distinguish that particular reason).
+void remove_dir(const std::string& path);
+
+/// Create a new unique directory for temporary files. The absolute
+/// path to the new directory is returned without a trailing slash.
+std::string make_temp_dir();
+
+size_t page_size();
+
+
+/// This class provides a RAII abstraction over the concept of a file
+/// descriptor (or file handle).
+///
+/// Locks are automatically and immediately released when the File
+/// instance is closed.
+///
+/// You can use CloseGuard and UnlockGuard to acheive exception-safe
+/// closing or unlocking prior to the File instance being detroyed.
+///
+/// A single File instance must never be accessed concurrently by
+/// multiple threads.
+///
+/// You can write to a file via an std::ostream as follows:
+///
+/// \code{.cpp}
+///
+///   File::Streambuf my_streambuf(&my_file);
+///   std::ostream out(&my_strerambuf);
+///   out << 7945.9;
+///
+/// \endcode
+class File {
+public:
+    enum Mode {
+        mode_Read,   ///< access_ReadOnly,  create_Never             (fopen: rb)
+        mode_Update, ///< access_ReadWrite, create_Never             (fopen: rb+)
+        mode_Write,  ///< access_ReadWrite, create_Auto, flag_Trunc  (fopen: wb+)
+        mode_Append  ///< access_ReadWrite, create_Auto, flag_Append (fopen: ab+)
+    };
+
+    /// Equivalent to calling open(const std::string&, Mode) on a
+    /// default constructed instance.
+    explicit File(const std::string& path, Mode = mode_Read);
+
+    /// Create an instance that is not initially attached to an open
+    /// file.
+    File() noexcept;
+
+    ~File() noexcept;
+
+    File(File&&) noexcept;
+    File& operator=(File&&) noexcept;
+
+    /// Calling this function on an instance that is already attached
+    /// to an open file has undefined behavior.
+    ///
+    /// \throw AccessError If the file could not be opened. If the
+    /// reason corresponds to one of the exception types that are
+    /// derived from AccessError, the derived exception type is thrown
+    /// (as long as the underlying system provides the information to
+    /// unambiguously distinguish that particular reason).
+    void open(const std::string& path, Mode = mode_Read);
+
+    /// This function is idempotent, that is, it is valid to call it
+    /// regardless of whether this instance currently is attached to
+    /// an open file.
+    void close() noexcept;
+
+    /// Check whether this File instance is currently attached to an
+    /// open file.
+    bool is_attached() const noexcept;
+
+    enum AccessMode {
+        access_ReadOnly,
+        access_ReadWrite
+    };
+
+    enum CreateMode {
+        create_Auto,  ///< Create the file if it does not already exist.
+        create_Never, ///< Fail if the file does not already exist.
+        create_Must   ///< Fail if the file already exists.
+    };
+
+    enum {
+        flag_Trunc  = 1, ///< Truncate the file if it already exists.
+        flag_Append = 2  ///< Move to end of file before each write.
+    };
+
+    /// See open(const std::string&, Mode).
+    ///
+    /// Specifying access_ReadOnly together with a create mode that is
+    /// not create_Never, or together with a non-zero \a flags
+    /// argument, results in undefined behavior. Specifying flag_Trunc
+    /// together with create_Must results in undefined behavior.
+    void open(const std::string& path, AccessMode, CreateMode, int flags);
+
+    /// Same as open(path, access_ReadWrite, create_Auto, 0), except
+    /// that this one returns an indication of whether a new file was
+    /// created, or an existing file was opened.
+    void open(const std::string& path, bool& was_created);
+
+    /// Read data into the specified buffer and return the number of
+    /// bytes read. If the returned number of bytes is less than \a
+    /// size, then the end of the file has been reached.
+    ///
+    /// Calling this function on an instance, that is not currently
+    /// attached to an open file, has undefined behavior.
+    size_t read(char* data, size_t size);
+
+    /// Write the specified data to this file.
+    ///
+    /// Calling this function on an instance, that is not currently
+    /// attached to an open file, has undefined behavior.
+    ///
+    /// Calling this function on an instance, that was opened in
+    /// read-only mode, has undefined behavior.
+    void write(const char* data, size_t size);
+
+    /// Calls write(s.data(), s.size()).
+    void write(const std::string& s) { write(s.data(), s.size()); }
+
+    /// Calls read(data, N).
+    template<size_t N>
+    size_t read(char (&data)[N]) { return read(data, N); }
+
+    /// Calls write(data(), N).
+    template<size_t N>
+    void write(const char (&data)[N]) { write(data, N); }
+
+    /// Plays the same role as off_t in POSIX
+    typedef int_fast64_t SizeType;
+
+    /// Calling this function on an instance that is not attached to
+    /// an open file has undefined behavior.
+    SizeType get_size() const;
+
+    /// If this causes the file to grow, then the new section will
+    /// have undefined contents. Setting the size with this function
+    /// does not necessarily allocate space on the target device. If
+    /// you want to ensure allocation, call alloc(). Calling this
+    /// function will generally affect the read/write offset
+    /// associated with this File instance.
+    ///
+    /// Calling this function on an instance that is not attached to
+    /// an open file has undefined behavior. Calling this function on
+    /// a file that is opened in read-only mode, is an error.
+    void resize(SizeType);
+
+    /// The same as prealloc_if_supported() but when the operation is
+    /// not supported by the system, this function will still increase
+    /// the file size when the specified region extends beyond the
+    /// current end of the file. This allows you to both extend and
+    /// allocate in one operation.
+    ///
+    /// The downside is that this function is not guaranteed to have
+    /// atomic behaviour on all systems, that is, two processes, or
+    /// two threads should never call this function concurrently for
+    /// the same underlying file even though they access the file
+    /// through distinct File instances.
+    ///
+    /// \sa prealloc_if_supported()
+    void prealloc(SizeType offset, size_t size);
+
+    /// When supported by the system, allocate space on the target
+    /// device for the specified region of the file. If the region
+    /// extends beyond the current end of the file, the file size is
+    /// increased as necessary.
+    ///
+    /// On systems that do not support this operation, this function
+    /// has no effect. You may call is_prealloc_supported() to
+    /// determine if it is supported on your system.
+    ///
+    /// Calling this function on an instance, that is not attached to
+    /// an open file, has undefined behavior. Calling this function on
+    /// a file, that is opened in read-only mode, is an error.
+    ///
+    /// This function is guaranteed to have atomic behaviour, that is,
+    /// there is never any risk of the file size being reduced even
+    /// with concurrently executing invocations.
+    ///
+    /// \sa prealloc()
+    /// \sa is_prealloc_supported()
+    void prealloc_if_supported(SizeType offset, size_t size);
+
+    /// See prealloc_if_supported().
+    static bool is_prealloc_supported();
+
+    /// Reposition the read/write offset of this File
+    /// instance. Distinct File instances have separate independent
+    /// offsets, as long as the cucrrent process is not forked.
+    void seek(SizeType);
+
+    // Return file position (like ftell())
+    SizeType get_file_position();
+
+    /// Flush in-kernel buffers to disk. This blocks the caller until the
+    /// synchronization operation is complete. On POSIX systems this function
+    /// calls `fsync()`. On Apple platforms if calls `fcntl()` with command
+    /// `F_FULLFSYNC`.
+    void sync();
+
+    /// Place an exclusive lock on this file. This blocks the caller
+    /// until all other locks have been released.
+    ///
+    /// Locks acquired on distinct File instances have fully recursive
+    /// behavior, even if they are acquired in the same process (or
+    /// thread) and are attached to the same underlying file.
+    ///
+    /// Calling this function on an instance that is not attached to
+    /// an open file, or on an instance that is already locked has
+    /// undefined behavior.
+    void lock_exclusive();
+
+    /// Place an shared lock on this file. This blocks the caller
+    /// until all other exclusive locks have been released.
+    ///
+    /// Locks acquired on distinct File instances have fully recursive
+    /// behavior, even if they are acquired in the same process (or
+    /// thread) and are attached to the same underlying file.
+    ///
+    /// Calling this function on an instance that is not attached to
+    /// an open file, or on an instance that is already locked has
+    /// undefined behavior.
+    void lock_shared();
+
+    /// Non-blocking version of lock_exclusive(). Returns true iff it
+    /// succeeds.
+    bool try_lock_exclusive();
+
+    /// Non-blocking version of lock_shared(). Returns true iff it
+    /// succeeds.
+    bool try_lock_shared();
+
+    /// Release a previously acquired lock on this file. This function
+    /// is idempotent.
+    void unlock() noexcept;
+
+    /// Set the encryption key used for this file. Must be called before any
+    /// mappings are created or any data is read from or written to the file.
+    ///
+    /// \param key A 64-byte encryption key, or null to disable encryption.
+    void set_encryption_key(const char* key);
+
+    enum {
+        /// If possible, disable opportunistic flushing of dirted
+        /// pages of a memory mapped file to physical medium. On some
+        /// systems this cannot be disabled. On other systems it is
+        /// the default behavior. An explicit call to sync_map() will
+        /// flush the buffers regardless of whether this flag is
+        /// specified or not.
+        map_NoSync = 1
+    };
+
+    /// Map this file into memory. The file is mapped as shared
+    /// memory. This allows two processes to interact under exatly the
+    /// same rules as applies to the interaction via regular memory of
+    /// multiple threads inside a single process.
+    ///
+    /// This File instance does not need to remain in existence after
+    /// the mapping is established.
+    ///
+    /// Multiple concurrent mappings may be created from the same File
+    /// instance.
+    ///
+    /// Specifying access_ReadWrite for a file that is opened in
+    /// read-only mode, is an error.
+    ///
+    /// Calling this function on an instance that is not attached to
+    /// an open file, or one that is attached to an empty file has
+    /// undefined behavior.
+    ///
+    /// Calling this function with a size that is greater than the
+    /// size of the file has undefined behavior.
+    void* map(AccessMode, size_t size, int map_flags = 0, size_t offset = 0) const;
+
+    /// The same as unmap(old_addr, old_size) followed by map(a,
+    /// new_size, map_flags), but more efficient on some systems.
+    ///
+    /// The old address range must have been acquired by a call to
+    /// map() or remap() on this File instance, the specified access
+    /// mode and flags must be the same as the ones specified
+    /// previously, and this File instance must not have been reopend
+    /// in the meantime. Failing to adhere to these rules will result
+    /// in undefined behavior.
+    ///
+    /// If this function throws, the old address range will remain
+    /// mapped.
+    void* remap(void* old_addr, size_t old_size, AccessMode a, size_t new_size,
+                int map_flags = 0, size_t file_offset = 0) const;
+
+#if REALM_ENABLE_ENCRYPTION
+    void* map(AccessMode, size_t size, EncryptedFileMapping*& mapping,
+              int map_flags = 0, size_t offset = 0) const;
+#endif
+    /// Unmap the specified address range which must have been
+    /// previously returned by map().
+    static void unmap(void* addr, size_t size) noexcept;
+
+    /// Flush in-kernel buffers to disk. This blocks the caller until
+    /// the synchronization operation is complete. The specified
+    /// address range must be (a subset of) one that was previously returned by
+    /// map().
+    static void sync_map(void* addr, size_t size);
+
+    /// Check whether the specified file or directory exists. Note
+    /// that a file or directory that resides in a directory that the
+    /// calling process has no access to, will necessarily be reported
+    /// as not existing.
+    static bool exists(const std::string& path);
+
+    /// Check whether the specified path exists and refers to a directory. If
+    /// the referenced file system object resides in an inaccessible directory,
+    /// this function returns false.
+    static bool is_dir(const std::string& path);
+
+    /// Remove the specified file path from the file system. If the
+    /// specified path is not a directory, this function is equivalent
+    /// to std::remove(const char*).
+    ///
+    /// The specified file must not be open by the calling process. If
+    /// it is, this function has undefined behaviour. Note that an
+    /// open memory map of the file counts as "the file being open".
+    ///
+    /// \throw AccessError If the specified directory entry could not
+    /// be removed. If the reason corresponds to one of the exception
+    /// types that are derived from AccessError, the derived exception
+    /// type is thrown (as long as the underlying system provides the
+    /// information to unambiguously distinguish that particular
+    /// reason).
+    static void remove(const std::string& path);
+
+    /// Same as remove() except that this one returns false, rather
+    /// than thriowing an exception, if the specified file does not
+    /// exist. If the file did exist, and was deleted, this function
+    /// returns true.
+    static bool try_remove(const std::string& path);
+
+    /// Change the path of a directory entry. This can be used to
+    /// rename a file, and/or to move it from one directory to
+    /// another. This function is equivalent to std::rename(const
+    /// char*, const char*).
+    ///
+    /// \throw AccessError If the path of the directory entry could
+    /// not be changed. If the reason corresponds to one of the
+    /// exception types that are derived from AccessError, the derived
+    /// exception type is thrown (as long as the underlying system
+    /// provides the information to unambiguously distinguish that
+    /// particular reason).
+    static void move(const std::string& old_path, const std::string& new_path);
+    static bool copy(std::string source, std::string destination);
+
+    /// Check whether two open file descriptors refer to the same
+    /// underlying file, that is, if writing via one of them, will
+    /// affect what is read from the other. In UNIX this boils down to
+    /// comparing inode numbers.
+    ///
+    /// Both instances have to be attached to open files. If they are
+    /// not, this function has undefined behavior.
+    bool is_same_file(const File&) const;
+
+    // FIXME: Can we get rid of this one please!!!
+    bool is_removed() const;
+
+    /// Resolve the specified path against the specified base directory.
+    ///
+    /// If \a path is absolute, or if \a base_dir is empty, \p path is returned
+    /// unmodified, otherwise \a path is resolved against \a base_dir.
+    ///
+    /// Examples (assuming POSIX):
+    ///
+    ///    resolve("file", "dir")        -> "dir/file"
+    ///    resolve("../baz", "/foo/bar") -> "/foo/baz"
+    ///    resolve("foo", ".")           -> "./foo"
+    ///    resolve(".", "/foo/")         -> "/foo"
+    ///    resolve("..", "foo")          -> "."
+    ///    resolve("../..", "foo")       -> ".."
+    ///    resolve("..", "..")           -> "../.."
+    ///    resolve("", "")               -> "."
+    ///    resolve("", "/")              -> "/."
+    ///    resolve("..", "/")            -> "/."
+    ///    resolve("..", "foo//bar")     -> "foo"
+    ///
+    /// This function does not access the file system.
+    ///
+    /// \param path The path to be resolved. An empty string produces the same
+    /// result as as if "." was passed. The result has a trailing directory
+    /// separator (`/`) if, and only if this path has a trailing directory
+    /// separator.
+    ///
+    /// \param base_dir The base directory path, which may be relative or
+    /// absolute. A final directory separator (`/`) is optional. The empty
+    /// string is interpreted as a relative path.
+    static std::string resolve(const std::string& path, const std::string& base_dir);
+
+    class ExclusiveLock;
+    class SharedLock;
+
+    template<class>
+    class Map;
+
+    class CloseGuard;
+    class UnlockGuard;
+    class UnmapGuard;
+
+    class Streambuf;
+
+    // Exceptions
+    class AccessError;
+    class PermissionDenied;
+    class NotFound;
+    class Exists;
+
+private:
+#ifdef _WIN32
+    void* m_handle;
+    bool m_have_lock; // Only valid when m_handle is not null
+#else
+    int m_fd;
+#endif
+
+    std::unique_ptr<const char[]> m_encryption_key;
+
+    bool lock(bool exclusive, bool non_blocking);
+    void open_internal(const std::string& path, AccessMode, CreateMode, int flags, bool* success);
+
+    struct MapBase {
+        void* m_addr = nullptr;
+        size_t m_size = 0;
+
+        MapBase() noexcept;
+        ~MapBase() noexcept;
+
+        void map(const File&, AccessMode, size_t size, int map_flags, size_t offset = 0);
+        void remap(const File&, AccessMode, size_t size, int map_flags);
+        void unmap() noexcept;
+        void sync();
+#if REALM_ENABLE_ENCRYPTION
+        util::EncryptedFileMapping* m_encrypted_mapping = nullptr;
+        inline util::EncryptedFileMapping* get_encrypted_mapping() const
+        {
+            return m_encrypted_mapping;
+        }
+#else
+        inline util::EncryptedFileMapping* get_encrypted_mapping() const
+        {
+            return nullptr;
+        }
+#endif
+    };
+};
+
+
+
+class File::ExclusiveLock {
+public:
+    ExclusiveLock(File& f): m_file(f) { f.lock_exclusive(); }
+    ~ExclusiveLock() noexcept { m_file.unlock(); }
+private:
+    File& m_file;
+};
+
+class File::SharedLock {
+public:
+    SharedLock(File& f): m_file(f) { f.lock_shared(); }
+    ~SharedLock() noexcept { m_file.unlock(); }
+private:
+    File& m_file;
+};
+
+
+
+/// This class provides a RAII abstraction over the concept of a
+/// memory mapped file.
+///
+/// Once created, the Map instance makes no reference to the File
+/// instance that it was based upon, and that File instance may be
+/// destroyed before the Map instance is destroyed.
+///
+/// Multiple concurrent mappings may be created from the same File
+/// instance.
+///
+/// You can use UnmapGuard to acheive exception-safe unmapping prior
+/// to the Map instance being detroyed.
+///
+/// A single Map instance must never be accessed concurrently by
+/// multiple threads.
+template<class T>
+class File::Map: private MapBase {
+public:
+    /// Equivalent to calling map() on a default constructed instance.
+    explicit Map(const File&, AccessMode = access_ReadOnly, size_t size = sizeof (T),
+                 int map_flags = 0);
+
+    explicit Map(const File&, size_t offset, AccessMode = access_ReadOnly, size_t size = sizeof (T),
+                 int map_flags = 0);
+
+    /// Create an instance that is not initially attached to a memory
+    /// mapped file.
+    Map() noexcept;
+
+    ~Map() noexcept;
+
+    /// Move the mapping from another Map object to this Map object
+    File::Map<T>& operator=(File::Map<T>&& other)
+    {
+        if (m_addr) unmap();
+        m_addr = other.get_addr();
+        m_size = other.m_size;
+        other.m_addr = 0;
+        other.m_size = 0;
+#if REALM_ENABLE_ENCRYPTION
+        m_encrypted_mapping = other.m_encrypted_mapping;
+        other.m_encrypted_mapping = nullptr;
+#endif
+        return *this;
+    }
+
+    /// See File::map().
+    ///
+    /// Calling this function on a Map instance that is already
+    /// attached to a memory mapped file has undefined behavior. The
+    /// returned pointer is the same as what will subsequently be
+    /// returned by get_addr().
+    T* map(const File&, AccessMode = access_ReadOnly, size_t size = sizeof (T),
+           int map_flags = 0, size_t offset = 0);
+
+    /// See File::unmap(). This function is idempotent, that is, it is
+    /// valid to call it regardless of whether this instance is
+    /// currently attached to a memory mapped file.
+    void unmap() noexcept;
+
+    /// See File::remap().
+    ///
+    /// Calling this function on a Map instance that is not currently
+    /// attached to a memory mapped file has undefined behavior. The
+    /// returned pointer is the same as what will subsequently be
+    /// returned by get_addr().
+    T* remap(const File&, AccessMode = access_ReadOnly, size_t size = sizeof (T),
+             int map_flags = 0);
+
+    /// See File::sync_map().
+    ///
+    /// Calling this function on an instance that is not currently
+    /// attached to a memory mapped file, has undefined behavior.
+    void sync();
+
+    /// Check whether this Map instance is currently attached to a
+    /// memory mapped file.
+    bool is_attached() const noexcept;
+
+    /// Returns a pointer to the beginning of the memory mapped file,
+    /// or null if this instance is not currently attached.
+    T* get_addr() const noexcept;
+
+    /// Returns the size of the mapped region, or zero if this
+    /// instance does not currently refer to a memory mapped
+    /// file. When this instance refers to a memory mapped file, the
+    /// returned value will always be identical to the size passed to
+    /// the constructor or to map().
+    size_t get_size() const noexcept;
+
+    /// Release the currently attached memory mapped file from this
+    /// Map instance. The address range may then be unmapped later by
+    /// a call to File::unmap().
+    T* release() noexcept;
+
+#if REALM_ENABLE_ENCRYPTION
+    /// Get the encrypted file mapping corresponding to this mapping
+    inline EncryptedFileMapping* get_encrypted_mapping() const
+    {
+        return m_encrypted_mapping;
+    }
+#else
+    inline EncryptedFileMapping* get_encrypted_mapping() const
+    {
+        return nullptr;
+    }
+#endif
+
+    friend class UnmapGuard;
+};
+
+
+class File::CloseGuard {
+public:
+    CloseGuard(File& f) noexcept: m_file(&f) {}
+    ~CloseGuard() noexcept { if (m_file) m_file->close(); }
+    void release() noexcept { m_file = nullptr; }
+private:
+    File* m_file;
+};
+
+
+class File::UnlockGuard {
+public:
+    UnlockGuard(File& f) noexcept: m_file(&f) {}
+    ~UnlockGuard() noexcept { if (m_file) m_file->unlock(); }
+    void release() noexcept { m_file = nullptr; }
+private:
+    File* m_file;
+};
+
+
+class File::UnmapGuard {
+public:
+    template<class T>
+    UnmapGuard(Map<T>& m) noexcept: m_map(&m) {}
+    ~UnmapGuard() noexcept { if (m_map) m_map->unmap(); }
+    void release() noexcept { m_map = nullptr; }
+private:
+    MapBase* m_map;
+};
+
+
+
+/// Only output is supported at this point.
+class File::Streambuf: public std::streambuf {
+public:
+    explicit Streambuf(File*);
+    ~Streambuf() noexcept;
+
+private:
+    static const size_t buffer_size = 4096;
+
+    File& m_file;
+    std::unique_ptr<char[]> const m_buffer;
+
+    int_type overflow(int_type) override;
+    int sync() override;
+    pos_type seekpos(pos_type, std::ios_base::openmode) override;
+    void flush();
+
+    // Disable copying
+    Streambuf(const Streambuf&);
+    Streambuf& operator=(const Streambuf&);
+};
+
+
+
+/// Used for any I/O related exception. Note the derived exception
+/// types that are used for various specific types of errors.
+class File::AccessError: public std::runtime_error {
+public:
+    AccessError(const std::string& msg, const std::string& path);
+
+    /// Return the associated file system path, or the empty string if there is
+    /// no associated file system path, or if the file system path is unknown.
+    std::string get_path() const;
+
+private:
+    std::string m_path;
+};
+
+
+/// Thrown if the user does not have permission to open or create
+/// the specified file in the specified access mode.
+class File::PermissionDenied: public AccessError {
+public:
+    PermissionDenied(const std::string& msg, const std::string& path);
+};
+
+
+/// Thrown if the directory part of the specified path was not
+/// found, or create_Never was specified and the file did no
+/// exist.
+class File::NotFound: public AccessError {
+public:
+    NotFound(const std::string& msg, const std::string& path);
+};
+
+
+/// Thrown if create_Always was specified and the file did already
+/// exist.
+class File::Exists: public AccessError {
+public:
+    Exists(const std::string& msg, const std::string& path);
+};
+
+
+class DirScanner {
+public:
+    DirScanner(const std::string& path);
+    ~DirScanner() noexcept;
+    bool next(std::string& name);
+private:
+#ifndef _WIN32
+    DIR* m_dirp;
+#endif
+};
+
+
+
+
+
+// Implementation:
+
+inline File::File(const std::string& path, Mode m)
+{
+#ifdef _WIN32
+    m_handle = nullptr;
+#else
+    m_fd = -1;
+#endif
+
+    open(path, m);
+}
+
+inline File::File() noexcept
+{
+#ifdef _WIN32
+    m_handle = nullptr;
+#else
+    m_fd = -1;
+#endif
+}
+
+inline File::~File() noexcept
+{
+    close();
+}
+
+inline File::File(File&& f) noexcept
+{
+#ifdef _WIN32
+    m_handle = f.m_handle;
+    m_have_lock = f.m_have_lock;
+    f.m_handle = nullptr;
+#else
+    m_fd = f.m_fd;
+    f.m_fd = -1;
+#endif
+    m_encryption_key = std::move(f.m_encryption_key);
+}
+
+inline File& File::operator=(File&& f) noexcept
+{
+    close();
+#ifdef _WIN32
+    m_handle = f.m_handle;
+    m_have_lock = f.m_have_lock;
+    f.m_handle = nullptr;
+#else
+    m_fd = f.m_fd;
+    f.m_fd = -1;
+#endif
+    m_encryption_key = std::move(f.m_encryption_key);
+    return *this;
+}
+
+inline void File::open(const std::string& path, Mode m)
+{
+    AccessMode a = access_ReadWrite;
+    CreateMode c = create_Auto;
+    int flags = 0;
+    switch (m) {
+        case mode_Read:   a = access_ReadOnly; c = create_Never; break;
+        case mode_Update:                      c = create_Never; break;
+        case mode_Write:  flags = flag_Trunc;                    break;
+        case mode_Append: flags = flag_Append;                   break;
+    }
+    open(path, a, c, flags);
+}
+
+inline void File::open(const std::string& path, AccessMode am, CreateMode cm, int flags)
+{
+    open_internal(path, am, cm, flags, nullptr);
+}
+
+
+inline void File::open(const std::string& path, bool& was_created)
+{
+    while (1) {
+        bool success;
+        open_internal(path, access_ReadWrite, create_Must, 0, &success);
+        if (success) {
+            was_created = true;
+            return;
+        }
+        open_internal(path, access_ReadWrite, create_Never, 0, &success);
+        if (success) {
+            was_created = false;
+            return;
+        }
+    }
+}
+
+inline bool File::is_attached() const noexcept
+{
+#ifdef _WIN32
+    return (m_handle != nullptr);
+#else
+    return 0 <= m_fd;
+#endif
+}
+
+inline void File::lock_exclusive()
+{
+    lock(true, false);
+}
+
+inline void File::lock_shared()
+{
+    lock(false, false);
+}
+
+inline bool File::try_lock_exclusive()
+{
+    return lock(true, true);
+}
+
+inline bool File::try_lock_shared()
+{
+    return lock(false, true);
+}
+
+inline File::MapBase::MapBase() noexcept
+{
+    m_addr = nullptr;
+}
+
+inline File::MapBase::~MapBase() noexcept
+{
+    unmap();
+}
+
+inline void File::MapBase::map(const File& f, AccessMode a, size_t size, int map_flags, size_t offset)
+{
+    REALM_ASSERT(!m_addr);
+#if REALM_ENABLE_ENCRYPTION
+    m_addr = f.map(a, size, m_encrypted_mapping, map_flags, offset);
+#else
+    m_addr = f.map(a, size, map_flags, offset);
+#endif
+    m_size = size;
+}
+
+inline void File::MapBase::unmap() noexcept
+{
+    if (!m_addr) return;
+    File::unmap(m_addr, m_size);
+    m_addr = nullptr;
+#if REALM_ENABLE_ENCRYPTION
+    m_encrypted_mapping = nullptr;
+#endif
+}
+
+inline void File::MapBase::remap(const File& f, AccessMode a, size_t size, int map_flags)
+{
+    REALM_ASSERT(m_addr);
+
+    m_addr = f.remap(m_addr, m_size, a, size, map_flags);
+    m_size = size;
+}
+
+inline void File::MapBase::sync()
+{
+    REALM_ASSERT(m_addr);
+
+    File::sync_map(m_addr, m_size);
+}
+
+template<class T>
+inline File::Map<T>::Map(const File& f, AccessMode a, size_t size, int map_flags)
+{
+    map(f, a, size, map_flags);
+}
+
+template<class T>
+inline File::Map<T>::Map(const File& f, size_t offset, AccessMode a, size_t size, int map_flags)
+{
+    map(f, a, size, map_flags, offset);
+}
+
+template<class T>
+inline File::Map<T>::Map() noexcept {}
+
+template<class T>
+inline File::Map<T>::~Map() noexcept {}
+
+template<class T>
+inline T* File::Map<T>::map(const File& f, AccessMode a, size_t size, int map_flags, size_t offset)
+{
+    MapBase::map(f, a, size, map_flags, offset);
+    return static_cast<T*>(m_addr);
+}
+
+template<class T>
+inline void File::Map<T>::unmap() noexcept
+{
+    MapBase::unmap();
+}
+
+template<class T>
+inline T* File::Map<T>::remap(const File& f, AccessMode a, size_t size, int map_flags)
+{
+    MapBase::remap(f, a, size, map_flags);
+    return static_cast<T*>(m_addr);
+}
+
+template<class T>
+inline void File::Map<T>::sync()
+{
+    MapBase::sync();
+}
+
+template<class T>
+inline bool File::Map<T>::is_attached() const noexcept
+{
+    return (m_addr != nullptr);
+}
+
+template<class T>
+inline T* File::Map<T>::get_addr() const noexcept
+{
+    return static_cast<T*>(m_addr);
+}
+
+template<class T>
+inline size_t File::Map<T>::get_size() const noexcept
+{
+    return m_addr ? m_size : 0;
+}
+
+template<class T>
+inline T* File::Map<T>::release() noexcept
+{
+    T* addr = static_cast<T*>(m_addr);
+    m_addr = nullptr;
+    return addr;
+}
+
+
+inline File::Streambuf::Streambuf(File* f): m_file(*f), m_buffer(new char[buffer_size])
+{
+    char* b = m_buffer.get();
+    setp(b, b + buffer_size);
+}
+
+inline File::Streambuf::~Streambuf() noexcept
+{
+    try {
+        if (m_file.is_attached()) flush();
+    }
+    catch (...) {
+        // Errors deliberately ignored
+    }
+}
+
+inline File::Streambuf::int_type File::Streambuf::overflow(int_type c)
+{
+    flush();
+    if (c == traits_type::eof())
+        return traits_type::not_eof(c);
+    *pptr() = traits_type::to_char_type(c);
+    pbump(1);
+    return c;
+}
+
+inline int File::Streambuf::sync()
+{
+    flush();
+    return 0;
+}
+
+inline File::Streambuf::pos_type File::Streambuf::seekpos(pos_type pos, std::ios_base::openmode)
+{
+    flush();
+    SizeType pos2 = 0;
+    if (int_cast_with_overflow_detect(std::streamsize(pos), pos2))
+        throw std::runtime_error("Seek position overflow");
+    m_file.seek(pos2);
+    return pos;
+}
+
+inline void File::Streambuf::flush()
+{
+    size_t n = pptr() - pbase();
+    m_file.write(pbase(), n);
+    setp(m_buffer.get(), epptr());
+}
+
+inline File::AccessError::AccessError(const std::string& msg, const std::string& path):
+    std::runtime_error(msg),
+    m_path(path)
+{
+}
+
+inline std::string File::AccessError::get_path() const
+{
+    return m_path;
+}
+
+inline File::PermissionDenied::PermissionDenied(const std::string& msg, const std::string& path):
+    AccessError(msg, path)
+{
+}
+
+inline File::NotFound::NotFound(const std::string& msg, const std::string& path):
+    AccessError(msg, path)
+{
+}
+
+inline File::Exists::Exists(const std::string& msg, const std::string& path):
+    AccessError(msg, path)
+{
+}
+
+} // namespace util
+} // namespace realm
+
+#endif // REALM_UTIL_FILE_HPP
diff --git a/Pods/Realm/include/core/realm/util/file_mapper.hpp b/Pods/Realm/include/core/realm/util/file_mapper.hpp
new file mode 100644
index 0000000..2fa287e
--- /dev/null
+++ b/Pods/Realm/include/core/realm/util/file_mapper.hpp
@@ -0,0 +1,123 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_UTIL_FILE_MAPPER_HPP
+#define REALM_UTIL_FILE_MAPPER_HPP
+
+#include <realm/util/file.hpp>
+#include <realm/util/thread.hpp>
+#include <realm/util/encrypted_file_mapping.hpp>
+
+namespace realm {
+namespace util {
+
+void *mmap(int fd, size_t size, File::AccessMode access, size_t offset, const char *encryption_key);
+void munmap(void *addr, size_t size) noexcept;
+void* mremap(int fd, size_t file_offset, void* old_addr, size_t old_size, File::AccessMode a, size_t new_size);
+void msync(void *addr, size_t size);
+
+// A function which may be given to encryption_read_barrier. If present, the read barrier is a
+// a barrier for a full array. If absent, the read barrier is a barrier only for the address
+// range give as argument. If the barrier is for a full array, it will read the array header
+// and determine the address range from the header.
+using HeaderToSize = size_t (*)(const char* addr);
+class EncryptedFileMapping;
+
+#if REALM_ENABLE_ENCRYPTION
+
+
+// This variant allows the caller to obtain direct access to the encrypted file mapping
+// for optimization purposes.
+void *mmap(int fd, size_t size, File::AccessMode access, size_t offset, const char *encryption_key,
+           EncryptedFileMapping*& mapping);
+
+void do_encryption_read_barrier(const void* addr, size_t size,
+                                HeaderToSize header_to_size,
+                                EncryptedFileMapping* mapping);
+
+void do_encryption_write_barrier(const void* addr, size_t size, EncryptedFileMapping* mapping);
+
+void inline encryption_read_barrier(const void* addr, size_t size,
+                                    EncryptedFileMapping* mapping,
+                                    HeaderToSize header_to_size = nullptr)
+{
+    if (mapping)
+        do_encryption_read_barrier(addr, size, header_to_size, mapping);
+}
+
+void inline encryption_write_barrier(const void* addr, size_t size, EncryptedFileMapping* mapping)
+{
+    if (mapping)
+        do_encryption_write_barrier(addr, size, mapping);
+}
+
+
+extern util::Mutex mapping_mutex;
+
+inline void do_encryption_read_barrier(const void* addr, size_t size,
+                                       HeaderToSize header_to_size,
+                                       EncryptedFileMapping* mapping)
+{
+    UniqueLock lock(mapping_mutex, defer_lock_tag());
+    mapping->read_barrier(addr, size, lock, header_to_size);
+}
+
+inline void do_encryption_write_barrier(const void* addr, size_t size,
+                                        EncryptedFileMapping* mapping)
+{
+    LockGuard lock(mapping_mutex);
+    mapping->write_barrier(addr, size);
+}
+
+
+
+#else
+void inline encryption_read_barrier(const void*, size_t,
+                                    EncryptedFileMapping*,
+                                    HeaderToSize header_to_size = nullptr)
+{
+    static_cast<void>(header_to_size);
+}
+void inline encryption_write_barrier(const void*, size_t) {}
+void inline encryption_write_barrier(const void*, size_t, EncryptedFileMapping*) {}
+#endif
+
+// helpers for encrypted Maps
+template<typename T>
+void encryption_read_barrier(File::Map<T>& map, size_t index, size_t num_elements = 1)
+{
+    T* addr = map.get_addr();
+    encryption_read_barrier(addr+index, sizeof(T)*num_elements, map.get_encrypted_mapping());
+}
+
+template<typename T>
+void encryption_write_barrier(File::Map<T>& map, size_t index, size_t num_elements = 1)
+{
+    T* addr = map.get_addr();
+    encryption_write_barrier(addr+index, sizeof(T)*num_elements, map.get_encrypted_mapping());
+}
+
+File::SizeType encrypted_size_to_data_size(File::SizeType size) noexcept;
+File::SizeType data_size_to_encrypted_size(File::SizeType size) noexcept;
+
+size_t round_up_to_page_size(size_t size) noexcept;
+
+}
+}
+#endif
diff --git a/Pods/Realm/include/core/realm/util/hex_dump.hpp b/Pods/Realm/include/core/realm/util/hex_dump.hpp
new file mode 100644
index 0000000..88419ac
--- /dev/null
+++ b/Pods/Realm/include/core/realm/util/hex_dump.hpp
@@ -0,0 +1,56 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_UTIL_HEX_DUMP_HPP
+#define REALM_UTIL_HEX_DUMP_HPP
+
+#include <stddef.h>
+#include <type_traits>
+#include <limits>
+#include <string>
+#include <sstream>
+#include <iomanip>
+
+#include <realm/util/safe_int_ops.hpp>
+
+namespace realm {
+namespace util {
+
+template<class T>
+std::string hex_dump(const T* data, size_t size, const char* separator = " ", int min_digits = -1)
+{
+    using U = typename std::make_unsigned<T>::type;
+
+    if (min_digits < 0)
+        min_digits = (std::numeric_limits<U>::digits+3) / 4;
+
+    std::ostringstream out;
+    for (const T* i = data; i != data+size; ++i) {
+        if (i != data)
+            out << separator;
+        out << std::setw(min_digits)<<std::setfill('0')<<std::hex<<std::uppercase <<
+            util::promote(U(*i));
+    }
+    return out.str();
+}
+
+} // namespace util
+} // namespace realm
+
+#endif // REALM_UTIL_HEX_DUMP_HPP
diff --git a/Pods/Realm/include/core/realm/util/inspect.hpp b/Pods/Realm/include/core/realm/util/inspect.hpp
new file mode 100644
index 0000000..f79d43b
--- /dev/null
+++ b/Pods/Realm/include/core/realm/util/inspect.hpp
@@ -0,0 +1,78 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+
+#ifndef REALM_UTIL_INSPECT_HPP
+#define REALM_UTIL_INSPECT_HPP
+
+#include <string>
+
+namespace realm {
+namespace util {
+
+// LCOV_EXCL_START
+//
+// Because these are templated functions, every combination of output stream
+// type and value(s) type(s) generates a new function.  This makes LCOV/GCOVR
+// report over 70 functions in this file, with only 6.6% function coverage,
+// even though line coverage is at 100%.
+
+template<class OS, class T>
+void inspect_value(OS& os, const T& value)
+{
+    os << value;
+}
+
+template<class OS>
+void inspect_value(OS& os, const std::string& value)
+{
+    // FIXME: Escape the string.
+    os << "\"" << value << "\"";
+}
+
+template<class OS>
+void inspect_value(OS& os, const char* value)
+{
+    // FIXME: Escape the string.
+    os << "\"" << value << "\"";
+}
+
+template<class OS>
+void inspect_all(OS&)
+{
+    // No-op
+}
+
+/// Convert all arguments to strings, and quote string arguments.
+template<class OS, class First, class... Args>
+void inspect_all(OS& os, First&& first, Args&&... args)
+{
+    inspect_value(os, std::forward<First>(first));
+    if (sizeof...(Args) != 0) {
+        os << ", ";
+    }
+    inspect_all(os, std::forward<Args>(args)...);
+}
+
+// LCOV_EXCL_STOP
+
+} // namespace util
+} // namespace realm
+
+#endif // REALM_UTIL_INSPECT_HPP
diff --git a/Pods/Realm/include/core/realm/util/interprocess_condvar.hpp b/Pods/Realm/include/core/realm/util/interprocess_condvar.hpp
new file mode 100644
index 0000000..a3d3f72
--- /dev/null
+++ b/Pods/Realm/include/core/realm/util/interprocess_condvar.hpp
@@ -0,0 +1,132 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+
+#ifndef REALM_UTIL_INTERPROCESS_CONDVAR
+#define REALM_UTIL_INTERPROCESS_CONDVAR
+
+
+#include <realm/util/features.h>
+#include <realm/util/thread.hpp>
+#include <realm/util/interprocess_mutex.hpp>
+#include <stdint.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <semaphore.h>
+#include <mutex>
+
+// Condvar Emulation is required if RobustMutex emulation is enabled
+#ifdef REALM_ROBUST_MUTEX_EMULATION
+#define REALM_CONDVAR_EMULATION
+#endif
+
+namespace realm {
+namespace util {
+
+
+
+
+/// Condition variable for use in synchronization monitors.
+/// This condition variable uses emulation based on named pipes
+/// for the inter-process case, if enabled by REALM_CONDVAR_EMULATION.
+///
+/// FIXME: This implementation will never release/delete pipes. This is unlikely
+/// to be a problem as long as only a modest number of different database names
+/// are in use
+///
+/// A InterprocessCondVar is always process shared.
+class InterprocessCondVar {
+public:
+    InterprocessCondVar();
+    ~InterprocessCondVar() noexcept;
+
+    /// To use the InterprocessCondVar, you also must place a structure of type
+    /// InterprocessCondVar::SharedPart in memory shared by multiple processes
+    /// or in a memory mapped file, and use set_shared_part() to associate
+    /// the condition variable with it's shared part. You must initialize
+    /// the shared part using InterprocessCondVar::init_shared_part(), but only before
+    /// first use and only when you have exclusive access to the shared part.
+
+#ifdef REALM_CONDVAR_EMULATION
+    struct SharedPart {
+        uint64_t signal_counter;
+        uint64_t wait_counter;
+    };
+#else
+    typedef CondVar SharedPart;
+#endif
+
+    /// You need to bind the emulation to a SharedPart in shared/mmapped memory.
+    /// The SharedPart is assumed to have been initialized (possibly by another process)
+    /// earlier through a call to init_shared_part.
+    void set_shared_part(SharedPart& shared_part, std::string path, std::string condvar_name);
+
+    /// Initialize the shared part of a process shared condition variable.
+    /// A process shared condition variables may be represented by any number of
+    /// InterprocessCondVar instances in any number of different processes,
+    /// all sharing a common SharedPart instance, which must be in shared memory.
+    static void init_shared_part(SharedPart& shared_part);
+
+    /// Release any system resources allocated for the shared part. This should
+    /// be used *only* when you are certain, that nobody is using it.
+    void release_shared_part();
+
+    /// Wait for someone to call notify() or notify_all() on this condition
+    /// variable. The call to wait() may return spuriously, so the caller should
+    /// always re-evaluate the condition on which to wait and loop on wait()
+    /// if necessary.
+    void wait(InterprocessMutex& m, const struct timespec* tp);
+
+    /// If any threads are waiting for this condition, wake up at least one.
+    /// (Current implementation may actually wake all :-O ). The caller must
+    /// hold the lock associated with the condvar at the time of calling notify()
+    void notify() noexcept;
+
+    /// Wake up every thread that is currently waiting on this condition.
+    /// The caller must hold the lock associated with the condvar at the time
+    /// of calling notify_all().
+    void notify_all() noexcept;
+
+    /// Cleanup and release system resources if possible.
+    void close() noexcept;
+
+private:
+    // non-zero if a shared part has been registered (always 0 on process local instances)
+    SharedPart* m_shared_part = nullptr;
+#ifdef REALM_CONDVAR_EMULATION
+    // keep the path to allocated system resource so we can remove them again
+    std::string m_resource_path;
+#endif
+    bool uses_emulation = false;
+    // pipe used for emulation
+    int m_fd_read = -1;
+    int m_fd_write = -1;
+};
+
+
+
+
+// Implementation:
+
+
+} // namespace util
+} // namespace realm
+
+
+#endif
diff --git a/Pods/Realm/include/core/realm/util/interprocess_mutex.hpp b/Pods/Realm/include/core/realm/util/interprocess_mutex.hpp
new file mode 100644
index 0000000..825543e
--- /dev/null
+++ b/Pods/Realm/include/core/realm/util/interprocess_mutex.hpp
@@ -0,0 +1,197 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+
+#ifndef REALM_UTIL_INTERPROCESS_MUTEX
+#define REALM_UTIL_INTERPROCESS_MUTEX
+
+// Enable this only on platforms where it might be needed
+#if REALM_PLATFORM_APPLE || REALM_ANDROID
+#define REALM_ROBUST_MUTEX_EMULATION
+#endif
+
+#include <realm/util/features.h>
+#include <realm/util/thread.hpp>
+#include <realm/util/file.hpp>
+#include <realm/utilities.hpp>
+#include <mutex>
+
+namespace realm {
+namespace util {
+
+// fwd decl to support friend decl below
+class InterprocessCondVar;
+
+
+/// Emulation of a Robust Mutex.
+/// A Robust Mutex is an interprocess mutex which will automatically
+/// release any locks held by a process when it crashes. Contrary to
+/// Posix robust mutexes, this robust mutex is not capable of informing
+/// participants that they have been granted a lock after a crash of
+/// the process holding it (though it could be added if needed).
+
+class InterprocessMutex {
+public:
+    InterprocessMutex();
+    ~InterprocessMutex() noexcept;
+
+#ifdef REALM_ROBUST_MUTEX_EMULATION
+    struct SharedPart { };
+#else
+    using SharedPart = RobustMutex;
+#endif
+
+    /// You need to bind the emulation to a SharedPart in shared/mmapped memory.
+    /// The SharedPart is assumed to have been initialized (possibly by another process)
+    /// elsewhere.
+    void set_shared_part(SharedPart& shared_part, const std::string& path, const std::string& mutex_name);
+    void set_shared_part(SharedPart& shared_part, File&& lock_file);
+
+    /// Destroy shared object. Potentially release system resources. Caller must
+    /// ensure that the shared_part is not in use at the point of call.
+    void release_shared_part();
+
+    /// Lock the mutex. If the mutex is already locked, wait for it to be unlocked.
+    void lock();
+
+    /// Unlock the mutex
+    void unlock();
+
+    /// Attempt to check if the mutex is valid (only relevant if not emulating)
+    bool is_valid() noexcept;
+
+    static bool is_robust_on_this_platform()
+    {
+#ifdef REALM_ROBUST_MUTEX_EMULATION
+        return true;  // we're faking it!
+#else
+        return RobustMutex::is_robust_on_this_platform();
+#endif
+    }
+private:
+#ifdef REALM_ROBUST_MUTEX_EMULATION
+    std::string m_filename;
+    File m_file;
+    Mutex m_local_mutex;
+#else
+    SharedPart* m_shared_part = 0;
+#endif
+    friend class InterprocessCondVar;
+};
+
+
+inline InterprocessMutex::InterprocessMutex()
+{
+}
+
+inline InterprocessMutex::~InterprocessMutex() noexcept
+{
+#ifdef REALM_ROBUST_MUTEX_EMULATION
+    m_local_mutex.lock();
+    m_file.close();
+    m_local_mutex.unlock();
+#endif
+}
+
+inline void InterprocessMutex::set_shared_part(SharedPart& shared_part,
+                                               const std::string& path,
+                                               const std::string& mutex_name)
+{
+#ifdef REALM_ROBUST_MUTEX_EMULATION
+    static_cast<void>(shared_part);
+    if (m_file.is_attached()) {
+        m_file.close();
+    }
+    m_filename = path + "." + mutex_name + ".mx";
+    std::lock_guard<Mutex> guard(m_local_mutex);
+    m_file.open(m_filename, File::mode_Write);
+#else
+    m_shared_part = &shared_part;
+    static_cast<void>(path);
+    static_cast<void>(mutex_name);
+#endif
+}
+
+inline void InterprocessMutex::set_shared_part(SharedPart& shared_part,
+                                               File&& lock_file)
+{
+#ifdef REALM_ROBUST_MUTEX_EMULATION
+    static_cast<void>(shared_part);
+    if (m_file.is_attached()) {
+        m_file.close();
+    }
+    m_filename.clear();
+    std::lock_guard<Mutex> guard(m_local_mutex);
+    m_file = std::move(lock_file);
+#else
+    m_shared_part = &shared_part;
+    static_cast<void>(lock_file);
+#endif
+}
+
+inline void InterprocessMutex::release_shared_part()
+{
+#ifdef REALM_ROBUST_MUTEX_EMULATION
+    if (!m_filename.empty())
+        File::try_remove(m_filename);
+#else
+    m_shared_part = nullptr;
+#endif
+}
+
+inline void InterprocessMutex::lock()
+{
+#ifdef REALM_ROBUST_MUTEX_EMULATION
+    std::unique_lock<Mutex> mutex_lock(m_local_mutex);
+    m_file.lock_exclusive();
+    mutex_lock.release();
+#else
+    REALM_ASSERT(m_shared_part);
+    m_shared_part->lock([](){});
+#endif
+}
+
+
+inline void InterprocessMutex::unlock()
+{
+#ifdef REALM_ROBUST_MUTEX_EMULATION
+    m_file.unlock();
+    m_local_mutex.unlock();
+#else
+    REALM_ASSERT(m_shared_part);
+    m_shared_part->unlock();
+#endif
+}
+
+
+inline bool InterprocessMutex::is_valid() noexcept
+{
+#ifdef REALM_ROBUST_MUTEX_EMULATION
+    return true;
+#else
+    REALM_ASSERT(m_shared_part);
+    return m_shared_part->is_valid();
+#endif
+}
+
+
+} // namespace util
+} // namespace realm
+
+#endif // #ifndef REALM_UTIL_INTERPROCESS_MUTEX
diff --git a/Pods/Realm/include/core/realm/util/logger.hpp b/Pods/Realm/include/core/realm/util/logger.hpp
new file mode 100644
index 0000000..c5526bb
--- /dev/null
+++ b/Pods/Realm/include/core/realm/util/logger.hpp
@@ -0,0 +1,486 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_UTIL_LOGGER_HPP
+#define REALM_UTIL_LOGGER_HPP
+
+#include <string.h>
+#include <utility>
+#include <string>
+#include <locale>
+#include <sstream>
+#include <iostream>
+
+#include <realm/util/features.h>
+#include <realm/util/tuple.hpp>
+#include <realm/util/thread.hpp>
+#include <realm/util/file.hpp>
+
+namespace realm {
+namespace util {
+
+
+/// All Logger objects store a reference to a LevelThreshold object which it
+/// uses to efficiently query about the current log level threshold
+/// (`level_threshold.get()`). All messages logged with a level that is lower
+/// than the current threshold will be dropped. For the sake of efficiency, this
+/// test happens before the message is formatted.
+///
+/// A logger is not inherently thread-safe, but specific implementations can be
+/// (see ThreadSafeLogger). For a logger to be thread-safe, the implementation
+/// of do_log() must be thread-safe and the referenced LevelThreshold object
+/// must have a thread-safe get() method.
+///
+/// Examples:
+///
+///    logger.error("Overlong message from master coordinator");
+///    logger.info("Listening for peers on %1:%2", listen_address, listen_port);
+class Logger {
+public:
+    template<class... Params> void trace(const char* message, Params...);
+    template<class... Params> void debug(const char* message, Params...);
+    template<class... Params> void detail(const char* message, Params...);
+    template<class... Params> void info(const char* message, Params...);
+    template<class... Params> void warn(const char* message, Params...);
+    template<class... Params> void error(const char* message, Params...);
+    template<class... Params> void fatal(const char* message, Params...);
+
+    /// Specifies criticality when passed to log(). Functions as a criticality
+    /// threshold when returned from LevelThreshold::get().
+    enum class Level { all, trace, debug, detail, info, warn, error, fatal, off };
+
+    template<class... Params> void log(Level, const char* message, Params...);
+
+    /// Shorthand for `int(level) >= int(level_threshold.get())`.
+    bool would_log(Level level) const noexcept;
+
+    class LevelThreshold;
+
+    const LevelThreshold& level_threshold;
+
+    virtual ~Logger() noexcept;
+
+protected:
+    Logger(const LevelThreshold&) noexcept;
+
+    static void do_log(Logger&, std::string message);
+
+    virtual void do_log(std::string message) = 0;
+
+private:
+    struct State;
+    template<class> struct Subst;
+
+    template<class... Params> REALM_NOINLINE void do_log(Level, const char* message, Params...);
+    void log_impl(State&);
+    template<class Param, class... Params> void log_impl(State&, const Param&, Params...);
+};
+
+template<class C, class T>
+std::basic_ostream<C,T>& operator<<(std::basic_ostream<C,T>&, Logger::Level);
+
+template<class C, class T>
+std::basic_istream<C,T>& operator>>(std::basic_istream<C,T>&, Logger::Level&);
+
+class Logger::LevelThreshold {
+public:
+    virtual Level get() const noexcept = 0;
+};
+
+
+
+/// A root logger that is not thread-safe and allows for the log level threshold
+/// to be changed over time. The initial log level threshold is
+/// Logger::Level::info.
+class RootLogger: private Logger::LevelThreshold, public Logger  {
+public:
+    void set_level_threshold(Level) noexcept;
+
+protected:
+    RootLogger();
+
+private:
+    Level m_level_threshold = Level::info;
+    Level get() const noexcept override final;
+};
+
+
+/// A logger that writes to STDERR. This logger is not thread-safe.
+///
+/// Since this class is a RootLogger, it contains modifiable a log level
+/// threshold.
+class StderrLogger: public RootLogger {
+protected:
+    void do_log(std::string) override final;
+};
+
+
+
+/// A logger that writes to a stream. This logger is not thread-safe.
+///
+/// Since this class is a RootLogger, it contains modifiable a log level
+/// threshold.
+class StreamLogger: public RootLogger {
+public:
+    explicit StreamLogger(std::ostream&) noexcept;
+
+protected:
+    void do_log(std::string) override final;
+
+private:
+    std::ostream& m_out;
+};
+
+
+
+/// A logger that writes to a file. This logger is not thread-safe.
+///
+/// Since this class is a RootLogger, it contains modifiable a log level
+/// threshold.
+class FileLogger: public StreamLogger {
+public:
+    explicit FileLogger(std::string path);
+    explicit FileLogger(util::File);
+
+private:
+    util::File m_file;
+    util::File::Streambuf m_streambuf;
+    std::ostream m_out;
+};
+
+
+
+/// A thread-safe logger. This logger ignores the level threshold of the base
+/// logger. Instead, it introduces new a LevelThreshold object with a fixed
+/// value to achieve thread safety.
+class ThreadSafeLogger: private Logger::LevelThreshold, public Logger {
+public:
+    explicit ThreadSafeLogger(Logger& base_logger, Level = Level::info);
+
+protected:
+    void do_log(std::string) override final;
+
+private:
+    const Level m_level_threshold; // Immutable for thread safety
+    Logger& m_base_logger;
+    Mutex m_mutex;
+    Level get() const noexcept override final;
+};
+
+
+
+/// A logger that adds a fixed prefix to each message. This logger inherits the
+/// LevelThreshold object of the specified base logger. This logger is
+/// thread-safe if, and only if the base logger is thread-safe.
+class PrefixLogger: public Logger {
+public:
+    PrefixLogger(std::string prefix, Logger& base_logger) noexcept;
+
+protected:
+    void do_log(std::string) override final;
+
+private:
+    const std::string m_prefix;
+    Logger& m_base_logger;
+};
+
+
+
+
+// Implementation
+
+struct Logger::State {
+    std::string m_message;
+    std::string m_search;
+    int m_param_num = 1;
+    std::ostringstream m_formatter;
+    State(const char* s):
+        m_message(s),
+        m_search(m_message)
+    {
+        m_formatter.imbue(std::locale::classic());
+    }
+};
+
+template<class T> struct Logger::Subst {
+    void operator()(const T& param, State* state)
+    {
+        state->m_formatter << "%" << state->m_param_num;
+        std::string key = state->m_formatter.str();
+        state->m_formatter.str(std::string());
+        std::string::size_type j = state->m_search.find(key);
+        if (j != std::string::npos) {
+            state->m_formatter << param;
+            std::string str = state->m_formatter.str();
+            state->m_formatter.str(std::string());
+            state->m_message.replace(j, key.size(), str);
+            state->m_search.replace(j, key.size(), std::string(str.size(), '\0'));
+        }
+        ++state->m_param_num;
+    }
+};
+
+template<class... Params> inline void Logger::trace(const char* message, Params... params)
+{
+    log(Level::trace, message, params...); // Throws
+}
+
+template<class... Params> inline void Logger::debug(const char* message, Params... params)
+{
+    log(Level::debug, message, params...); // Throws
+}
+
+template<class... Params> inline void Logger::detail(const char* message, Params... params)
+{
+    log(Level::detail, message, params...); // Throws
+}
+
+template<class... Params> inline void Logger::info(const char* message, Params... params)
+{
+    log(Level::info, message, params...); // Throws
+}
+
+template<class... Params> inline void Logger::warn(const char* message, Params... params)
+{
+    log(Level::warn, message, params...); // Throws
+}
+
+template<class... Params> inline void Logger::error(const char* message, Params... params)
+{
+    log(Level::error, message, params...); // Throws
+}
+
+template<class... Params> inline void Logger::fatal(const char* message, Params... params)
+{
+    log(Level::fatal, message, params...); // Throws
+}
+
+template<class... Params>
+inline void Logger::log(Level level, const char* message, Params... params)
+{
+    if (would_log(level))
+        do_log(level, message, params...); // Throws
+}
+
+inline bool Logger::would_log(Level level) const noexcept
+{
+    return int(level) >= int(level_threshold.get());
+}
+
+inline Logger::~Logger() noexcept
+{
+}
+
+inline Logger::Logger(const LevelThreshold& lt) noexcept:
+    level_threshold(lt)
+{
+}
+
+inline void Logger::do_log(Logger& logger, std::string message)
+{
+    logger.do_log(std::move(message));
+}
+
+template<class... Params> void Logger::do_log(Level, const char* message, Params... params)
+{
+    State state(message);
+    log_impl(state, params...);
+}
+
+inline void Logger::log_impl(State& state)
+{
+    do_log(std::move(state.m_message));
+}
+
+template<class Param, class... Params>
+inline void Logger::log_impl(State& state, const Param& param, Params... params)
+{
+    Subst<Param>()(param, &state);
+    log_impl(state, params...);
+}
+
+template<class C, class T>
+std::basic_ostream<C,T>& operator<<(std::basic_ostream<C,T>& out, Logger::Level level)
+{
+    switch(level) {
+        case Logger::Level::all:
+            out << "all";
+            return out;
+        case Logger::Level::trace:
+            out << "trace";
+            return out;
+        case Logger::Level::debug:
+            out << "debug";
+            return out;
+        case Logger::Level::detail:
+            out << "detail";
+            return out;
+        case Logger::Level::info:
+            out << "info";
+            return out;
+        case Logger::Level::warn:
+            out << "warn";
+            return out;
+        case Logger::Level::error:
+            out << "error";
+            return out;
+        case Logger::Level::fatal:
+            out << "fatal";
+            return out;
+        case Logger::Level::off:
+            out << "off";
+            return out;
+    }
+    REALM_ASSERT(false);
+    return out;
+}
+
+template<class C, class T>
+std::basic_istream<C,T>& operator>>(std::basic_istream<C,T>& in, Logger::Level& level)
+{
+    std::basic_string<C,T> str;
+    auto check = [&](const char* name) {
+        size_t n = strlen(name);
+        if (n != str.size())
+            return false;
+        for (size_t i = 0; i < n; ++i) {
+            if (in.widen(name[i]) != str[i])
+                return false;
+        }
+        return true;
+    };
+    if (in >> str) {
+        if (check("all")) {
+            level = Logger::Level::all;
+        }
+        else if (check("trace")) {
+            level = Logger::Level::trace;
+        }
+        else if (check("debug")) {
+            level = Logger::Level::debug;
+        }
+        else if (check("detail")) {
+            level = Logger::Level::detail;
+        }
+        else if (check("info")) {
+            level = Logger::Level::info;
+        }
+        else if (check("warn")) {
+            level = Logger::Level::warn;
+        }
+        else if (check("error")) {
+            level = Logger::Level::error;
+        }
+        else if (check("fatal")) {
+            level = Logger::Level::fatal;
+        }
+        else if (check("off")) {
+            level = Logger::Level::off;
+        }
+        else {
+            in.setstate(std::ios_base::failbit);
+        }
+    }
+    return in;
+}
+
+inline void RootLogger::set_level_threshold(Level new_level_threshold) noexcept
+{
+    m_level_threshold = new_level_threshold;
+}
+
+inline RootLogger::RootLogger():
+    Logger::LevelThreshold(),
+    Logger(static_cast<Logger::LevelThreshold&>(*this))
+{
+}
+
+inline Logger::Level RootLogger::get() const noexcept
+{
+    return m_level_threshold;
+}
+
+inline void StderrLogger::do_log(std::string message)
+{
+    std::cerr << message << '\n'; // Throws
+    std::cerr.flush(); // Throws
+}
+
+inline StreamLogger::StreamLogger(std::ostream& out) noexcept:
+    m_out(out)
+{
+}
+
+inline void StreamLogger::do_log(std::string message)
+{
+    m_out << message << '\n'; // Throws
+    m_out.flush(); // Throws
+}
+
+inline FileLogger::FileLogger(std::string path):
+    StreamLogger(m_out),
+    m_file(path, util::File::mode_Write), // Throws
+    m_streambuf(&m_file), // Throws
+    m_out(&m_streambuf) // Throws
+{
+}
+
+inline FileLogger::FileLogger(util::File file):
+    StreamLogger(m_out),
+    m_file(std::move(file)),
+    m_streambuf(&m_file), // Throws
+    m_out(&m_streambuf) // Throws
+{
+}
+
+inline ThreadSafeLogger::ThreadSafeLogger(Logger& base_logger, Level threshold):
+    Logger::LevelThreshold(),
+    Logger(static_cast<Logger::LevelThreshold&>(*this)),
+    m_level_threshold(threshold),
+    m_base_logger(base_logger)
+{
+}
+
+inline void ThreadSafeLogger::do_log(std::string message)
+{
+    LockGuard l(m_mutex);
+    Logger::do_log(m_base_logger, message); // Throws
+}
+
+inline Logger::Level ThreadSafeLogger::get() const noexcept
+{
+    return m_level_threshold;
+}
+
+inline PrefixLogger::PrefixLogger(std::string prefix, Logger& base_logger) noexcept:
+    Logger(base_logger.level_threshold),
+    m_prefix(std::move(prefix)),
+    m_base_logger(base_logger)
+{
+}
+
+inline void PrefixLogger::do_log(std::string message)
+{
+    Logger::do_log(m_base_logger, m_prefix + message); // Throws
+}
+
+} // namespace util
+} // namespace realm
+
+#endif // REALM_UTIL_LOGGER_HPP
diff --git a/Pods/Realm/include/core/realm/util/memory_stream.hpp b/Pods/Realm/include/core/realm/util/memory_stream.hpp
new file mode 100644
index 0000000..4f51984
--- /dev/null
+++ b/Pods/Realm/include/core/realm/util/memory_stream.hpp
@@ -0,0 +1,200 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_UTIL_MEMORY_STREAM_HPP
+#define REALM_UTIL_MEMORY_STREAM_HPP
+
+#include <cstddef>
+#include <string>
+#include <istream>
+#include <ostream>
+
+#include <realm/util/features.h>
+
+namespace realm {
+namespace util {
+
+class MemoryInputStreambuf: public std::streambuf {
+public:
+    MemoryInputStreambuf();
+    ~MemoryInputStreambuf() noexcept;
+
+    void set_buffer(const char *begin, const char *end) noexcept;
+
+private:
+    int_type underflow() override;
+    int_type uflow() override;
+    int_type pbackfail(int_type ch) override;
+    std::streamsize showmanyc() override;
+
+    const char* m_begin;
+    const char* m_end;
+    const char* m_curr;
+};
+
+
+class MemoryOutputStreambuf: public std::streambuf {
+public:
+    MemoryOutputStreambuf();
+    ~MemoryOutputStreambuf() noexcept;
+
+    void set_buffer(char* begin, char* end) noexcept;
+
+    /// Returns the amount of data written to the buffer.
+    size_t size() const noexcept;
+};
+
+
+class MemoryInputStream: public std::istream {
+public:
+    MemoryInputStream();
+    ~MemoryInputStream() noexcept;
+
+    void set_buffer(const char *begin, const char *end) noexcept;
+
+    void set_string(const std::string&);
+
+    void set_c_string(const char *c_str) noexcept;
+
+private:
+    MemoryInputStreambuf m_streambuf;
+};
+
+
+class MemoryOutputStream: public std::ostream {
+public:
+    MemoryOutputStream();
+    ~MemoryOutputStream() noexcept;
+
+    void set_buffer(char *begin, char *end) noexcept;
+
+    template<size_t N>
+    void set_buffer(char (&buffer)[N]) noexcept;
+
+    /// Returns the amount of data written to the underlying buffer.
+    size_t size() const noexcept;
+
+private:
+    MemoryOutputStreambuf m_streambuf;
+};
+
+
+
+
+
+// Implementation
+
+inline MemoryInputStreambuf::MemoryInputStreambuf():
+    m_begin(nullptr),
+    m_end(nullptr),
+    m_curr(nullptr)
+{
+}
+
+inline MemoryInputStreambuf::~MemoryInputStreambuf() noexcept
+{
+}
+
+inline void MemoryInputStreambuf::set_buffer(const char *begin, const char *end) noexcept
+{
+    m_begin = begin;
+    m_end   = end;
+    m_curr  = begin;
+}
+
+
+inline MemoryOutputStreambuf::MemoryOutputStreambuf()
+{
+}
+
+inline MemoryOutputStreambuf::~MemoryOutputStreambuf() noexcept
+{
+}
+
+inline void MemoryOutputStreambuf::set_buffer(char* begin, char* end) noexcept
+{
+    setp(begin, end);
+}
+
+inline size_t MemoryOutputStreambuf::size() const noexcept
+{
+    return pptr() - pbase();
+}
+
+
+inline MemoryInputStream::MemoryInputStream():
+    std::istream(&m_streambuf)
+{
+}
+
+inline MemoryInputStream::~MemoryInputStream() noexcept
+{
+}
+
+inline void MemoryInputStream::set_buffer(const char *begin, const char *end) noexcept
+{
+    m_streambuf.set_buffer(begin, end);
+    clear();
+}
+
+inline void MemoryInputStream::set_string(const std::string& str)
+{
+    const char* begin = str.data();
+    const char* end   = begin + str.size();
+    set_buffer(begin, end);
+}
+
+inline void MemoryInputStream::set_c_string(const char *c_str) noexcept
+{
+    const char* begin = c_str;
+    const char* end   = begin + traits_type::length(c_str);
+    set_buffer(begin, end);
+}
+
+
+inline MemoryOutputStream::MemoryOutputStream():
+    std::ostream(&m_streambuf)
+{
+}
+
+inline MemoryOutputStream::~MemoryOutputStream() noexcept
+{
+}
+
+inline void MemoryOutputStream::set_buffer(char *begin, char *end) noexcept
+{
+    m_streambuf.set_buffer(begin, end);
+    clear();
+}
+
+template<size_t N>
+inline void MemoryOutputStream::set_buffer(char (&buffer)[N]) noexcept
+{
+    set_buffer(buffer, buffer+N);
+}
+
+inline size_t MemoryOutputStream::size() const noexcept
+{
+    return m_streambuf.size();
+}
+
+} // namespace util
+} // namespace realm
+
+#endif // REALM_UTIL_MEMORY_STREAM_HPP
diff --git a/Pods/Realm/include/core/realm/util/meta.hpp b/Pods/Realm/include/core/realm/util/meta.hpp
new file mode 100644
index 0000000..a014fa0
--- /dev/null
+++ b/Pods/Realm/include/core/realm/util/meta.hpp
@@ -0,0 +1,40 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_UTIL_META_HPP
+#define REALM_UTIL_META_HPP
+
+namespace realm {
+namespace util {
+
+
+template<class T, class A, class B>
+struct EitherTypeIs { static const bool value = false; };
+template<class T, class A>
+struct EitherTypeIs<T,T,A> { static const bool value = true; };
+template<class T, class A>
+struct EitherTypeIs<T,A,T> { static const bool value = true; };
+template<class T>
+struct EitherTypeIs<T,T,T> { static const bool value = true; };
+
+
+} // namespace util
+} // namespace realm
+
+#endif // REALM_UTIL_META_HPP
diff --git a/Pods/Realm/include/core/realm/util/misc_errors.hpp b/Pods/Realm/include/core/realm/util/misc_errors.hpp
new file mode 100644
index 0000000..25051e5
--- /dev/null
+++ b/Pods/Realm/include/core/realm/util/misc_errors.hpp
@@ -0,0 +1,51 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_UTIL_MISC_ERRORS_HPP
+#define REALM_UTIL_MISC_ERRORS_HPP
+
+#include <system_error>
+
+
+namespace realm {
+namespace util {
+namespace error {
+
+enum misc_errors {
+    unknown = 1
+};
+
+std::error_code make_error_code(misc_errors);
+
+} // namespace error
+} // namespace util
+} // namespace realm
+
+namespace std {
+
+template<>
+class is_error_code_enum<realm::util::error::misc_errors>
+{
+public:
+    static const bool value = true;
+};
+
+} // namespace std
+
+#endif // REALM_UTIL_MISC_ERRORS_HPP
diff --git a/Pods/Realm/include/core/realm/util/miscellaneous.hpp b/Pods/Realm/include/core/realm/util/miscellaneous.hpp
new file mode 100644
index 0000000..2039aab
--- /dev/null
+++ b/Pods/Realm/include/core/realm/util/miscellaneous.hpp
@@ -0,0 +1,50 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_UTIL_MISCELLANEOUS_HPP
+#define REALM_UTIL_MISCELLANEOUS_HPP
+
+#include <type_traits>
+
+namespace realm {
+namespace util {
+
+// FIXME: Replace this with std::add_const_t when we switch over to C++14 by
+// default.
+/// \brief Adds const qualifier, unless T already has the const qualifier
+template <class T>
+using add_const_t = typename std::add_const<T>::type;
+
+// FIXME: Replace this with std::as_const when we switch over to C++17 by
+// default.
+/// \brief Forms an lvalue reference to const T
+template <class T>
+constexpr add_const_t<T>& as_const(T& v) noexcept
+{
+    return v;
+}
+
+/// \brief Disallows rvalue arguments
+template <class T>
+add_const_t<T>& as_const(const T&&) = delete;
+
+} // namespace util
+} // namespace realm
+
+#endif // REALM_UTIL_MISCELLANEOUS_HPP
diff --git a/Pods/Realm/include/core/realm/util/network.hpp b/Pods/Realm/include/core/realm/util/network.hpp
new file mode 100644
index 0000000..1ffd863
--- /dev/null
+++ b/Pods/Realm/include/core/realm/util/network.hpp
@@ -0,0 +1,2336 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_UTIL_NETWORK_HPP
+#define REALM_UTIL_NETWORK_HPP
+
+#include <cstddef>
+#include <memory>
+#include <chrono>
+#include <tuple>
+#include <string>
+#include <system_error>
+#include <ostream>
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+#include <netdb.h>
+
+#include <realm/util/features.h>
+#include <realm/util/assert.hpp>
+#include <realm/util/buffer.hpp>
+#include <realm/util/basic_system_errors.hpp>
+#include <realm/util/call_with_tuple.hpp>
+
+namespace realm {
+namespace util {
+
+/// \brief TCP/IP networking API.
+///
+/// The design of this networking API is heavily inspired by the ASIO C++
+/// library (http://think-async.com).
+///
+/// ### Thread safety
+///
+/// A *service context* is a set of objects consisting of an instance of
+/// io_service, and all the objects that are associated with that instance (\ref
+/// resolver, \ref acceptor`, \ref socket`, \ref buffered_input_stream, and \ref
+/// deadline_timer).
+///
+/// In general, it is unsafe for two threads to call functions on the same
+/// object, or on different objects in the same service context. This also
+/// applies to destructors. Notable exceptions are the fully thread-safe
+/// functions, such as io_service::post(), io_service::stop(), and
+/// io_service::reset().
+///
+/// On the other hand, it is always safe for two threads to call functions on
+/// objects belonging to different service contexts.
+///
+/// One implication of these rules is that at most one thread must execute run()
+/// at any given time.
+///
+/// Unless otherwise specified, free-staing objects, such as \ref protocol, \ref
+/// address, \ref endpoint, and \ref endpoint::list are fully thread-safe as
+/// long as they are not mutated. If one thread is mutating such an object, no
+/// other thread may access it. Note that these free-standing objects are not
+/// associcated with an instance of io_service, and are therefore not part of a
+/// service context.
+namespace network {
+
+std::string host_name();
+
+
+class protocol;
+class address;
+class endpoint;
+class io_service;
+class resolver;
+class socket_base;
+class socket;
+class acceptor;
+class buffered_input_stream;
+class deadline_timer;
+
+
+/// \brief An IP protocol descriptor.
+class protocol {
+public:
+    static protocol ip_v4();
+    static protocol ip_v6();
+
+    bool is_ip_v4() const;
+    bool is_ip_v6() const;
+
+    protocol();
+    ~protocol() noexcept {}
+
+private:
+    int m_family;
+    int m_socktype;
+    int m_protocol;
+
+    friend class resolver;
+    friend class socket_base;
+};
+
+
+/// \brief An IP address (IPv4 or IPv6).
+class address {
+public:
+    bool is_ip_v4() const;
+    bool is_ip_v6() const;
+
+    template<class C, class T>
+    friend std::basic_ostream<C,T>& operator<<(std::basic_ostream<C,T>&, const address&);
+
+    address();
+    ~address() noexcept {}
+
+private:
+    typedef in_addr  ip_v4_type;
+    typedef in6_addr ip_v6_type;
+    union union_type {
+        ip_v4_type m_ip_v4;
+        ip_v6_type m_ip_v6;
+    };
+    union_type m_union;
+    bool m_is_ip_v6;
+
+    friend class endpoint;
+};
+
+
+/// \brief An IP endpoint.
+///
+/// An IP endpoint is a triplet (`protocol`, `address`, `port`).
+class endpoint {
+public:
+    using port_type = uint_fast16_t;
+    class list;
+
+    class protocol protocol() const;
+    class address address() const;
+    port_type port() const;
+
+    endpoint();
+    ~endpoint() noexcept {}
+
+private:
+    class protocol m_protocol;
+
+    typedef sockaddr     sockaddr_base_type;
+    typedef sockaddr_in  sockaddr_ip_v4_type;
+    typedef sockaddr_in6 sockaddr_ip_v6_type;
+    union sockaddr_union_type {
+        sockaddr_base_type  m_base;
+        sockaddr_ip_v4_type m_ip_v4;
+        sockaddr_ip_v6_type m_ip_v6;
+    };
+    sockaddr_union_type m_sockaddr_union;
+
+    friend class resolver;
+    friend class socket_base;
+    friend class socket;
+    friend class acceptor;
+};
+
+
+/// \brief A list of IP endpoints.
+class endpoint::list {
+public:
+    typedef const endpoint* iterator;
+
+    iterator begin() const;
+    iterator end() const;
+    size_t size() const;
+
+    ~list() noexcept {}
+
+private:
+    Buffer<endpoint> m_endpoints;
+
+    friend class resolver;
+};
+
+
+/// \brief TCP/IP networking service.
+class io_service {
+public:
+    io_service();
+    ~io_service() noexcept;
+
+    /// \brief Execute the event loop.
+    ///
+    /// Execute completion handlers of completed asynchronous operations, or
+    /// wait for more completion handlers to become ready for
+    /// execution. Handlers submitted via post() are considered immeditely
+    /// ready. If there are no completion handlers ready for execution, and
+    /// there are no asynchronous operations in progress, run() returns.
+    ///
+    /// All completion handlers, including handlers submitted via post() will be
+    /// executed from run(), that is by the thread that executes run(). If no
+    /// thread executes run(), then the completion handlers will not be
+    /// executed.
+    ///
+    /// Exceptions thrown by completion handlers will always propagate back
+    /// through run().
+    ///
+    /// Syncronous operations (e.g., socket::connect()) execute independently of
+    /// the event loop, and do not require that any thread calls run().
+    void run();
+
+    /// @{ \brief Stop event loop execution.
+    ///
+    /// stop() puts the event loop into the stopped mode. If a thread is currently
+    /// executing run(), it will be made to return in a timely fashion, that is,
+    /// without further blocking. If a thread is currently blocked in run(), it
+    /// will be unblocked. Handlers that can be executed immediately, may, or
+    /// may not be executed before run() returns, but new handlers submitted by
+    /// these, will not be executed.
+    ///
+    /// The event loop will remain in the stopped mode until reset() is
+    /// called. If reset() is called before run() returns, it may, or may not
+    /// cause run() to continue normal operation without returning.
+    ///
+    /// Both stop() and reset() are thread-safe, that is, they may be called by
+    /// any thread. Also, both of these function may be called from completion
+    /// handlers (including posted handlers).
+    void stop() noexcept;
+    void reset() noexcept;
+    /// @}
+
+    /// \brief Submit a handler to be executed by the event loop thread.
+    ///
+    /// Register the sepcified completion handler for immediate asynchronous
+    /// execution. The specified handler will be executed by an expression on
+    /// the form `handler()`. If the the handler object is movable, it will
+    /// never be copied. Otherwise, it will be copied as necessary.
+    ///
+    /// This function is thread-safe, that is, it may be called by any
+    /// thread. It may also be called from other completion handlers.
+    ///
+    /// The handler will never be called as part of the execution of post(). It
+    /// will always be called by a thread that is executing run(). If no thread
+    /// is currently executing run(), the handler will not be executed until a
+    /// thread starts executing run(). If post() is called while another thread
+    /// is executing run(), the handler may be called before post() returns. If
+    /// post() is called from another completion handler, the submitted handler
+    /// is guaranteed to not be called during the execution of post().
+    ///
+    /// Completion handlers added through post() will be executed in the order
+    /// that they are added. More precisely, if post() is called twice to add
+    /// two handlers, A and B, and the execution of post(A) ends before the
+    /// beginning of the execution of post(B), then A is guaranteed to execute
+    /// before B.
+    template<class H> void post(H handler);
+
+private:
+    class async_oper;
+    class wait_oper_base;
+    class post_oper_base;
+    template<class H> class post_oper;
+    class UnusedOper; // Allocated, but currently unused memory
+    class oper_queue;
+
+    struct OwnersOperDeleter {
+        void operator()(async_oper*) const noexcept;
+    };
+    struct LendersOperDeleter {
+        void operator()(async_oper*) const noexcept;
+    };
+    using OwnersOperPtr      = std::unique_ptr<async_oper, OwnersOperDeleter>;
+    using LendersOperPtr     = std::unique_ptr<async_oper, LendersOperDeleter>;
+    using LendersWaitOperPtr = std::unique_ptr<wait_oper_base, LendersOperDeleter>;
+
+    class impl;
+    const std::unique_ptr<impl> m_impl;
+
+    template<class Oper, class... Args>
+    static std::unique_ptr<Oper, LendersOperDeleter> alloc(OwnersOperPtr&, Args&&...);
+
+    template<class Oper> static void execute(std::unique_ptr<Oper, LendersOperDeleter>&);
+
+    enum io_op { io_op_Read, io_op_Write };
+    void add_io_oper(int fd, LendersOperPtr, io_op type);
+    void add_wait_oper(LendersWaitOperPtr);
+    void add_completed_oper(LendersOperPtr) noexcept;
+
+    using PostOperConstr = post_oper_base*(void* addr, size_t size, impl&, void* cookie);
+    void do_post(PostOperConstr, size_t size, void* cookie);
+    template<class H>
+    static post_oper_base* post_oper_constr(void* addr, size_t size, impl&, void* cookie);
+    static void recycle_post_oper(impl&, post_oper_base*) noexcept;
+
+    using clock = std::chrono::steady_clock;
+
+    friend class socket_base;
+    friend class socket;
+    friend class acceptor;
+    friend class buffered_input_stream;
+    friend class deadline_timer;
+};
+
+
+class resolver {
+public:
+    class query;
+
+    resolver(io_service&);
+    ~resolver() noexcept {}
+
+    io_service& service() noexcept;
+
+    /// @{ \brief Resolve the specified query to one or more endpoints.
+    void resolve(const query&, endpoint::list&);
+    std::error_code resolve(const query&, endpoint::list&, std::error_code&);
+    /// @}
+
+private:
+    io_service& m_service;
+};
+
+
+class resolver::query {
+public:
+    enum {
+        /// Locally bound socket endpoint (server side)
+        passive = AI_PASSIVE,
+
+        /// Ignore families without a configured non-loopback address
+        address_configured = AI_ADDRCONFIG
+    };
+
+    query(std::string service_port, int init_flags = passive|address_configured);
+    query(const protocol&, std::string service_port, int init_flags = passive|address_configured);
+    query(std::string host_name, std::string service_port, int init_flags = address_configured);
+    query(const protocol&, std::string host_name, std::string service_port, int init_flags = address_configured);
+
+    ~query() noexcept;
+
+    int flags() const;
+    class protocol protocol() const;
+    std::string host() const;
+    std::string service() const;
+
+private:
+    int m_flags;
+    class protocol m_protocol;
+    std::string m_host;    // hostname
+    std::string m_service; // port
+
+    friend class resolver;
+};
+
+
+class socket_base {
+public:
+    ~socket_base() noexcept;
+
+    io_service& service() noexcept;
+
+    bool is_open() const noexcept;
+
+    /// @{ \brief Open the socket for use with the specified protocol.
+    ///
+    /// It is an error to call open() on a socket that is already open.
+    void open(const protocol&);
+    std::error_code open(const protocol&, std::error_code&);
+    /// @}
+
+    /// \brief Close this socket.
+    ///
+    /// If the socket is open, it will be closed. If it is already closed (or
+    /// never opened), this function does nothing (idempotency).
+    ///
+    /// A socket is automatically closed when destroyed.
+    ///
+    /// When the socket is closed, any incomplete asynchronous operation will be
+    /// canceled (as if cancel() was called).
+    void close() noexcept;
+
+    /// \brief Cancel all asynchronous operations.
+    ///
+    /// Cause all incomplete asynchronous operations, that are associated with
+    /// this socket, to fail with `error::operation_aborted`. An asynchronous
+    /// operation is complete precisely when its completion handler starts
+    /// executing.
+    ///
+    /// Completion handlers of canceled operations will become immediately ready
+    /// to execute, but will never be executed directly as part of the execution
+    /// of cancel().
+    void cancel() noexcept;
+
+    template<class O>
+    void get_option(O& opt) const;
+
+    template<class O>
+    std::error_code get_option(O& opt, std::error_code&) const;
+
+    template<class O>
+    void set_option(const O& opt);
+
+    template<class O>
+    std::error_code set_option(const O& opt, std::error_code&);
+
+    void bind(const endpoint&);
+    std::error_code bind(const endpoint&, std::error_code&);
+
+    endpoint local_endpoint() const;
+    endpoint local_endpoint(std::error_code&) const;
+
+private:
+    enum opt_enum {
+        opt_ReuseAddr, ///< `SOL_SOCKET`, `SO_REUSEADDR`
+        opt_Linger,    ///< `SOL_SOCKET`, `SO_LINGER`
+    };
+
+    template<class, int, class> class option;
+
+public:
+    typedef option<bool, opt_ReuseAddr, int> reuse_address;
+
+    // linger struct defined by POSIX sys/socket.h.
+    struct linger_opt;
+    typedef option<linger_opt, opt_Linger, struct linger> linger;
+
+private:
+    int m_sock_fd;
+    bool m_in_blocking_mode; // Not in nonblocking mode
+
+protected:
+    io_service& m_service;
+    protocol m_protocol;
+    io_service::OwnersOperPtr m_read_oper;  // Read or accept
+    io_service::OwnersOperPtr m_write_oper; // Write or connect
+
+    socket_base(io_service&);
+
+    int get_sock_fd() noexcept;
+    void do_close() noexcept;
+
+    void get_option(opt_enum, void* value_data, size_t& value_size, std::error_code&) const;
+    void set_option(opt_enum, const void* value_data, size_t value_size, std::error_code&);
+    void map_option(opt_enum, int& level, int& option_name) const;
+
+    // `ec` untouched on success
+    std::error_code ensure_blocking_mode(std::error_code& ec) noexcept;
+    std::error_code ensure_nonblocking_mode(std::error_code& ec) noexcept;
+
+private:
+    // `ec` untouched on success
+    std::error_code set_nonblocking_mode(bool enable, std::error_code&) noexcept;
+
+    friend class acceptor;
+};
+
+
+template<class T, int opt, class U>
+class socket_base::option {
+public:
+    option(T value = T());
+    T value() const;
+
+private:
+    T m_value;
+
+    void get(const socket_base&, std::error_code&);
+    void set(socket_base&, std::error_code&) const;
+
+    friend class socket_base;
+};
+
+struct socket_base::linger_opt {
+    linger_opt(bool enable, int timeout_seconds = 0)
+    {
+        m_linger.l_onoff = enable ? 1 : 0;
+        m_linger.l_linger = timeout_seconds;
+    }
+
+    ::linger m_linger;
+
+    operator ::linger() const { return m_linger; }
+
+    bool enabled() const { return m_linger.l_onoff != 0; }
+    int  timeout() const { return m_linger.l_linger; }
+};
+
+
+class socket: public socket_base {
+public:
+    socket(io_service&);
+    ~socket() noexcept;
+
+    void connect(const endpoint&);
+    std::error_code connect(const endpoint&, std::error_code&);
+
+    /// \brief Perform an asynchronous connect operation.
+    ///
+    /// Initiate an asynchronous connect operation. The completion handler is
+    /// called when the operation completes. The operation completes when the
+    /// connection is established, or an error occurs.
+    ///
+    /// The completion handler is always executed by the event loop thread,
+    /// i.e., by a thread that is executing io_service::run(). Conversely, the
+    /// completion handler is guaranteed to not be called while no thread is
+    /// executing io_service::run(). The execution of the completion handler is
+    /// always deferred to the event loop, meaning that it never happens as a
+    /// synchronous side effect of the execution of async_connect(), even when
+    /// async_connect() is executed by the event loop thread. The completion
+    /// handler is guaranteed to be called eventually, as long as there is time
+    /// enough for the operation to complete or fail, and a thread is executing
+    /// io_service::run() for long enough.
+    ///
+    /// The operation can be canceled by calling cancel(), and will be
+    /// automatically canceled if the socket is closed. If the operation is
+    /// canceled, it will fail with `error::operation_aborted`. The operation
+    /// remains cancelable up until the point in time where the completion
+    /// handler starts to execute. This means that if cancel() is called before
+    /// the completion handler starts to execute, then the completion handler is
+    /// guaranteed to have `error::operation_aborted` passed to it. This is true
+    /// regardless of whether cancel() is called explicitly or implicitly, such
+    /// as when the socket is destroyed.
+    ///
+    /// If the socket is not already open, it will be opened as part of the
+    /// connect operation as if by calling `open(ep.protocol())`. If the opening
+    /// operation succeeds, but the connect operation fails, the socket will be
+    /// left in the opened state.
+    ///
+    /// The specified handler will be executed by an expression on the form
+    /// `handler(ec)` where `ec` is the error code. If the the handler object is
+    /// movable, it will never be copied. Otherwise, it will be copied as
+    /// necessary.
+    ///
+    /// It is an error to start a new connect operation (synchronous or
+    /// asynchronous) while an asynchronous connect operation is in progress. An
+    /// asynchronous connect operation is considered complete as soon as the
+    /// completion handler starts to execute.
+    ///
+    /// \param ep The remote endpoint of the connection to be established.
+    template<class H> void async_connect(const endpoint& ep, H handler);
+
+    /// @{ \brief Perform a synchronous write operation.
+    ///
+    /// write() will not return until all the specified bytes have been written
+    /// to the socket, or an error occurs.
+    ///
+    /// The versions of write() that does not take an `std::error_code&`
+    /// argument will throw std::system_error on failure.
+    ///
+    /// The versions that does take an `std::error_code&` argument will set \a
+    /// ec to `std::error_code()` on success, and to something else on
+    /// failure. It returns the same error code as it assigns to \a ec.
+    ///
+    void write(const char* data, size_t size);
+    std::error_code write(const char* data, size_t size, std::error_code& ec) noexcept;
+    /// @}
+
+    /// \brief Perform an asynchronous write operation.
+    ///
+    /// Initiate an asynchronous write operation. The completion handler is
+    /// called when the operation completes. The operation completes when all
+    /// the specified bytes have been written to the socket, or an error occurs.
+    ///
+    /// The completion handler is always executed by the event loop thread,
+    /// i.e., by a thread that is executing io_service::run(). Conversely, the
+    /// completion handler is guaranteed to not be called while no thread is
+    /// executing io_service::run(). The execution of the completion handler is
+    /// always deferred to the event loop, meaning that it never happens as a
+    /// synchronous side effect of the execution of async_write(), even when
+    /// async_write() is executed by the event loop thread. The completion
+    /// handler is guaranteed to be called eventually, as long as there is time
+    /// enough for the operation to complete or fail, and a thread is executing
+    /// io_service::run() for long enough.
+    ///
+    /// The operation can be canceled by calling cancel(), and will be
+    /// automatically canceled if the socket is closed. If the operation is
+    /// canceled, it will fail with `error::operation_aborted`. The operation
+    /// remains cancelable up until the point in time where the completion
+    /// handler starts to execute. This means that if cancel() is called before
+    /// the completion handler starts to execute, then the completion handler is
+    /// guaranteed to have `error::operation_aborted` passed to it. This is true
+    /// regardless of whether cancel() is called explicitly or implicitly, such
+    /// as when the socket is destroyed.
+    ///
+    /// The specified handler will be executed by an expression on the form
+    /// `handler(ec, n)` where `ec` is the error code, and `n` is the number of
+    /// bytes written (of type `size_t`). If the the handler object is movable,
+    /// it will never be copied. Otherwise, it will be copied as necessary.
+    ///
+    /// It is an error to start an asynchronous write operation before the
+    /// socket is connected.
+    ///
+    /// It is an error to start a new write operation (synchronous or
+    /// asynchronous) while an asynchronous write operation is in progress. An
+    /// asynchronous write operation is considered complete as soon as the
+    /// completion handler starts to execute. This means that a new write
+    /// operation can be started from the completion handler of another
+    /// asynchronous write operation.
+    template<class H> void async_write(const char* data, size_t size, H handler);
+
+    /// @{ \brief Read at least one byte from this socket.
+    ///
+    /// If \a size is zero, both versions of read_some() will return zero
+    /// without blocking. Read errors may or may not be detected in this case.
+    ///
+    /// Otherwise, if \a size is greater than zero, and at least one byte is
+    /// immediately available, that is, without blocking, then both versions
+    /// will read at least one byte (but generally as many immediately available
+    /// bytes as will fit into the specified buffer), and return without
+    /// blocking.
+    ///
+    /// Otherwise, both versions will block the calling thread until at least one
+    /// byte becomes available, or an error occurs.
+    ///
+    /// In this context, it counts as an error, if the end of input is reached
+    /// before at least one byte becomes available (see
+    /// `network::end_of_input`).
+    ///
+    /// If no error occurs, both versions will return the number of bytes placed
+    /// in the specified buffer, which is generally as many as are immediately
+    /// available at the time when the first byte becomes available, although
+    /// never more than \a size.
+    ///
+    /// If no error occurs, the three-argument version will set \a ec to
+    /// indicate success.
+    ///
+    /// If an error occurs, the two-argument version will throw
+    /// `std::system_error`, while the three-argument version will set \a ec to
+    /// indicate the error, and return zero.
+    ///
+    /// As long as \a size is greater than zero, the two argument version will
+    /// always return a value that is greater than zero, while the three
+    /// argument version will return a value greater than zero when, and only
+    /// when \a ec is set to indicate success (no error, and no end of input).
+    size_t read_some(char* buffer, size_t size);
+    size_t read_some(char* buffer, size_t size, std::error_code& ec) noexcept;
+    /// @}
+
+    /// @{ \brief Write at least one byte to this socket.
+    ///
+    /// If \a size is zero, both versions of write_some() will return zero
+    /// without blocking. Write errors may or may not be detected in this case.
+    ///
+    /// Otherwise, if \a size is greater than zero, and at least one byte can be
+    /// written immediately, that is, without blocking, then both versions will
+    /// write at least one byte (but generally as many as can be written
+    /// immediately), and return without blocking.
+    ///
+    /// Otherwise, both versions will block the calling thread until at least one
+    /// byte can be written, or an error occurs.
+    ///
+    /// If no error occurs, both versions will return the number of bytes
+    /// written, which is generally as many as can be written immediately at the
+    /// time when the first byte can be written.
+    ///
+    /// If no error occurs, the three-argument version will set \a ec to
+    /// indicate success.
+    ///
+    /// If an error occurs, the two-argument version will throw
+    /// `std::system_error`, while the three-argument version will set \a ec to
+    /// indicate the error, and return zero.
+    ///
+    /// As long as \a size is greater than zero, the two argument version will
+    /// always return a value that is greater than zero, while the three
+    /// argument version will return a value greater than zero when, and only
+    /// when \a ec is set to indicate success.
+    size_t write_some(const char* data, size_t size);
+    size_t write_some(const char* data, size_t size, std::error_code&) noexcept;
+    /// @}
+
+    enum shutdown_type {
+        /// Shutdown the receive side of the socket.
+        shutdown_receive = SHUT_RD,
+
+        /// Shutdown the send side of the socket.
+        shutdown_send = SHUT_WR,
+
+        /// Shutdown both send and receive on the socket.
+        shutdown_both = SHUT_RDWR
+    };
+
+    /// @{ \brief Shut down the connected sockets sending and/or receiving
+    /// side.
+    ///
+    /// It is an error to call this function when the socket is not both open
+    /// and connected.
+    void shutdown(shutdown_type);
+    std::error_code shutdown(shutdown_type, std::error_code&) noexcept;
+    /// @}
+
+private:
+    class connect_oper_base;
+    template<class H> class connect_oper;
+    class write_oper_base;
+    template<class H> class write_oper;
+
+    using LendersConnectOperPtr =
+        std::unique_ptr<connect_oper_base, io_service::LendersOperDeleter>;
+    using LendersWriteOperPtr =
+        std::unique_ptr<write_oper_base, io_service::LendersOperDeleter>;
+
+    size_t do_read_some(char* buffer, size_t size, std::error_code&) noexcept;
+    size_t do_write_some(const char* data, size_t size, std::error_code&) noexcept;
+
+    void do_async_connect(LendersConnectOperPtr);
+    // `ec` untouched on success, but no immediate completion
+    bool initiate_async_connect(const endpoint&, std::error_code& ec) noexcept;
+    // `ec` untouched on success
+    std::error_code finalize_async_connect(std::error_code& ec) noexcept;
+    void do_async_write(LendersWriteOperPtr);
+
+    friend class buffered_input_stream;
+};
+
+
+class acceptor: public socket_base {
+public:
+    acceptor(io_service&);
+    ~acceptor() noexcept;
+
+    static const int max_connections = SOMAXCONN;
+
+    void listen(int backlog = max_connections);
+    std::error_code listen(int backlog, std::error_code&);
+
+    void accept(socket&);
+    void accept(socket&, endpoint&);
+    std::error_code accept(socket&, std::error_code&);
+    std::error_code accept(socket&, endpoint&, std::error_code&);
+
+    /// @{ \brief Perform an asynchronous accept operation.
+    ///
+    /// Initiate an asynchronous accept operation. The completion handler will
+    /// be called when the operation completes. The operation completes when the
+    /// connection is accepted, or an error occurs. If the operation succeeds,
+    /// the specified local socket will have become connected to a remote
+    /// socket.
+    ///
+    /// The completion handler is always executed by the event loop thread,
+    /// i.e., by a thread that is executing io_service::run(). Conversely, the
+    /// completion handler is guaranteed to not be called while no thread is
+    /// executing io_service::run(). The execution of the completion handler is
+    /// always deferred to the event loop, meaning that it never happens as a
+    /// synchronous side effect of the execution of async_accept(), even when
+    /// async_accept() is executed by the event loop thread. The completion
+    /// handler is guaranteed to be called eventually, as long as there is time
+    /// enough for the operation to complete or fail, and a thread is executing
+    /// io_service::run() for long enough.
+    ///
+    /// The operation can be canceled by calling cancel(), and will be
+    /// automatically canceled if the acceptor is closed. If the operation is
+    /// canceled, it will fail with `error::operation_aborted`. The operation
+    /// remains cancelable up until the point in time where the completion
+    /// handler starts to execute. This means that if cancel() is called before
+    /// the completion handler starts to execute, then the completion handler is
+    /// guaranteed to have `error::operation_aborted` passed to it. This is true
+    /// regardless of whether cancel() is called explicitly or implicitly, such
+    /// as when the acceptor is destroyed.
+    ///
+    /// The specified handler will be executed by an expression on the form
+    /// `handler(ec)` where `ec` is the error code. If the the handler object is
+    /// movable, it will never be copied. Otherwise, it will be copied as
+    /// necessary.
+    ///
+    /// It is an error to start a new accept operation (synchronous or
+    /// asynchronous) while an asynchronous accept operation is in progress. An
+    /// asynchronous accept operation is considered complete as soon as the
+    /// completion handler starts executing. This means that a new accept
+    /// operation can be started from the completion handler.
+    ///
+    /// \param sock This is the local socket, that upon successful completion
+    /// will have become connected to the remote socket. It must be in the
+    /// closed state (socket::is_open()) when async_accept() is called.
+    ///
+    /// \param ep Upon completion, the remote peer endpoint will have been
+    /// assigned to this variable.
+    template<class H> void async_accept(socket& sock, H handler);
+    template<class H> void async_accept(socket& sock, endpoint& ep, H handler);
+    /// @}
+
+private:
+    std::error_code accept(socket&, endpoint*, std::error_code&);
+    std::error_code do_accept(socket&, endpoint*, std::error_code&) noexcept;
+
+    class accept_oper_base;
+    template<class H> class accept_oper;
+
+    using LendersAcceptOperPtr = std::unique_ptr<accept_oper_base, io_service::LendersOperDeleter>;
+
+    template<class H> void async_accept(socket&, endpoint*, H);
+    void do_async_accept(LendersAcceptOperPtr);
+};
+
+
+class buffered_input_stream {
+public:
+    buffered_input_stream(socket&);
+    ~buffered_input_stream() noexcept;
+
+    /// @{ \brief Perform a synchronous read operation.
+    ///
+    /// read() will not return until the specified buffer is full, or an error
+    /// occurs. Reaching the end of input before the buffer is filled, is
+    /// considered an error, and will cause the operation to fail with
+    /// `network::end_of_input`.
+    ///
+    /// read_until() will not return until the specified buffer contains the
+    /// specified delimiter, or an error occurs. If the buffer is filled before
+    /// the delimiter is found, the operation fails with
+    /// `network::delim_not_found`. Otherwise, if the end of input is reached
+    /// before the delimiter is found, the operation fails with
+    /// `network::end_of_input`. If the operation succeeds, the last byte placed
+    /// in the buffer is the delimiter.
+    ///
+    /// The versions of read() and read_until() that do not take an
+    /// `std::error_code&` argument will throw std::system_error on failure.
+    ///
+    /// The versions that do take an `std::error_code&` argument will set \a ec
+    /// to `std::error_code()` on success, and to something else on failure. On
+    /// failure they will return the number of bytes placed in the specified
+    /// buffer before the error occured.
+    ///
+    /// \return The number of bytes places in the specified buffer upon return.
+    size_t read(char* buffer, size_t size);
+    size_t read(char* buffer, size_t size, std::error_code& ec) noexcept;
+
+    size_t read_until(char* buffer, size_t size, char delim);
+    size_t read_until(char* buffer, size_t size, char delim,
+                           std::error_code& ec) noexcept;
+    /// @}
+
+    /// @{ \brief Perform an asynchronous read operation.
+    ///
+    /// Initiate an asynchronous buffered read operation on the associated
+    /// socket. The completion handler will be called when the operation
+    /// completes, or an error occurs.
+    ///
+    /// async_read() will continue reading until the specified buffer is full,
+    /// or an error occurs. If the end of input is reached before the buffer is
+    /// filled, the operation fails with `network::end_of_input`.
+    ///
+    /// async_read_until() will continue reading until the specified buffer
+    /// contains the specified delimiter, or an error occurs. If the buffer is
+    /// filled before a delimiter is found, the operation fails with
+    /// `network::delim_not_found`. Otherwise, if the end of input is reached
+    /// before a delimiter is found, the operation fails with
+    /// `network::end_of_input`. Otherwise, if the operation succeeds, the last
+    /// byte placed in the buffer is the delimiter.
+    ///
+    /// The completion handler is always executed by the event loop thread,
+    /// i.e., by a thread that is executing io_service::run(). Conversely, the
+    /// completion handler is guaranteed to not be called while no thread is
+    /// executing io_service::run(). The execution of the completion handler is
+    /// always deferred to the event loop, meaning that it never happens as a
+    /// synchronous side effect of the execution of async_read() or
+    /// async_read_until(), even when async_read() or async_read_until() is
+    /// executed by the event loop thread. The completion handler is guaranteed
+    /// to be called eventually, as long as there is time enough for the
+    /// operation to complete or fail, and a thread is executing
+    /// io_service::run() for long enough.
+    ///
+    /// The operation can be canceled by calling cancel() on the associated
+    /// socket, and will be automatically canceled if the associated socket is
+    /// closed. If the operation is canceled, it will fail with
+    /// `error::operation_aborted`. The operation remains cancelable up until
+    /// the point in time where the completion handler starts to execute. This
+    /// means that if cancel() is called before the completion handler starts to
+    /// execute, then the completion handler is guaranteed to have
+    /// `error::operation_aborted` passed to it. This is true regardless of
+    /// whether cancel() is called explicitly or implicitly, such as when the
+    /// socket is destroyed.
+    ///
+    /// The specified handler will be executed by an expression on the form
+    /// `handler(ec, n)` where `ec` is the error code, and `n` is the number of
+    /// bytes placed in the buffer (of type `size_t`). `n` is guaranteed to be
+    /// less than, or equal to \a size. If the the handler object is movable, it
+    /// will never be copied. Otherwise, it will be copied as necessary.
+    ///
+    /// It is an error to start a read operation before the associated socket is
+    /// connected.
+    ///
+    /// It is an error to start a new read operation (synchronous or
+    /// asynchronous) while an asynchronous read operation is in progress. An
+    /// asynchronous read operation is considered complete as soon as the
+    /// completion handler starts executing. This means that a new read
+    /// operation can be started from the completion handler of another
+    /// asynchronous buffered read operation.
+    ///
+    /// When an asynchronous operation is started, the caller must ensure that
+    /// one (or both) of the following events occur before the destruction of
+    /// the stream object:
+    ///
+    ///  - The completion handler is called (entry into the completion handler).
+    ///
+    ///  - The asynchronous operation is canceled (the socket is closed).
+    template<class H> void async_read(char* buffer, size_t size, H handler);
+    template<class H> void async_read_until(char* buffer, size_t size, char delim, H handler);
+    /// @}
+
+    /// Discard any buffered input.
+    void reset() noexcept;
+
+private:
+    class read_oper_base;
+    template<class H> class read_oper;
+
+    using LendersReadOperPtr = std::unique_ptr<read_oper_base, io_service::LendersOperDeleter>;
+
+    socket& m_socket;
+    static const size_t s_buffer_size = 1024;
+    std::unique_ptr<char[]> m_buffer;
+    char* m_begin;
+    char* m_end;
+
+    size_t do_read(char* buffer, size_t size, int delim, std::error_code&) noexcept;
+
+    template<class H> void async_read(char* buffer, size_t size, int delim, H);
+    void do_async_read(LendersReadOperPtr);
+};
+
+
+/// \brief A timer object supporting asynchronous wait operations.
+class deadline_timer {
+public:
+    deadline_timer(io_service&);
+    ~deadline_timer() noexcept;
+
+    io_service& service() noexcept;
+
+    /// \brief Perform an asynchronous wait operation.
+    ///
+    /// Initiate an asynchronous wait operation. The completion handler becomes
+    /// ready to execute when the expiration time is reached, or an error occurs
+    /// (cancellation counts as an error here). The expiration time is the time
+    /// of initiation plus the specified delay. The error code passed to the
+    /// complition handler will **never** indicate success, unless the
+    /// expiration time was reached.
+    ///
+    /// The completion handler is always executed by the event loop thread,
+    /// i.e., by a thread that is executing io_service::run(). Conversely, the
+    /// completion handler is guaranteed to not be called while no thread is
+    /// executing io_service::run(). The execution of the completion handler is
+    /// always deferred to the event loop, meaning that it never happens as a
+    /// synchronous side effect of the execution of async_wait(), even when
+    /// async_wait() is executed by the event loop thread. The completion
+    /// handler is guaranteed to be called eventually, as long as there is time
+    /// enough for the operation to complete or fail, and a thread is executing
+    /// io_service::run() for long enough.
+    ///
+    /// The operation can be canceled by calling cancel(), and will be
+    /// automatically canceled if the timer is destroyed. If the operation is
+    /// canceled, it will fail with `error::operation_aborted`. The operation
+    /// remains cancelable up until the point in time where the completion
+    /// handler starts to execute. This means that if cancel() is called before
+    /// the completion handler starts to execute, then the completion handler is
+    /// guaranteed to have `error::operation_aborted` passed to it. This is true
+    /// regardless of whether cancel() is called explicitly or implicitly, such
+    /// as when the timer is destroyed.
+    ///
+    /// The specified handler will be executed by an expression on the form
+    /// `handler(ec)` where `ec` is the error code. If the the handler object is
+    /// movable, it will never be copied. Otherwise, it will be copied as
+    /// necessary.
+    ///
+    /// It is an error to start a new asynchronous wait operation while an
+    /// another one is in progress. An asynchronous wait operation is in
+    /// progress until its completion handler starts executing.
+    template<class R, class P, class H>
+    void async_wait(std::chrono::duration<R,P> delay, H handler);
+
+    /// \brief Cancel an asynchronous wait operation.
+    ///
+    /// If an asynchronous wait operation, that is associated with this deadline
+    /// timer, is in progress, cause it to fail with
+    /// `error::operation_aborted`. An asynchronous wait operation is in
+    /// progress until its completion handler starts executing.
+    ///
+    /// Completion handlers of canceled operations will become immediately ready
+    /// to execute, but will never be executed directly as part of the execution
+    /// of cancel().
+    void cancel() noexcept;
+
+private:
+    template<class H> class wait_oper;
+
+    using clock = io_service::clock;
+
+    io_service& m_service;
+    io_service::OwnersOperPtr m_wait_oper;
+};
+
+
+enum errors {
+    /// End of input.
+    end_of_input = 1,
+
+    /// Delimiter not found.
+    delim_not_found,
+
+    /// Host not found (authoritative).
+    host_not_found,
+
+    /// Host not found (non-authoritative).
+    host_not_found_try_again,
+
+    /// The query is valid but does not have associated address data.
+    no_data,
+
+    /// A non-recoverable error occurred.
+    no_recovery,
+
+    /// The service is not supported for the given socket type.
+    service_not_found,
+
+    /// The socket type is not supported.
+    socket_type_not_supported
+};
+
+std::error_code make_error_code(errors);
+
+} // namespace network
+} // namespace util
+} // namespace realm
+
+namespace std {
+
+template<>
+struct is_error_code_enum<realm::util::network::errors>
+{
+public:
+    static const bool value = true;
+};
+
+} // namespace std
+
+namespace realm {
+namespace util {
+namespace network {
+
+
+
+
+
+// Implementation
+
+// ---------------- protocol ----------------
+
+inline protocol protocol::ip_v4()
+{
+    protocol prot;
+    prot.m_family = AF_INET;
+    return prot;
+}
+
+inline protocol protocol::ip_v6()
+{
+    protocol prot;
+    prot.m_family = AF_INET6;
+    return prot;
+}
+
+inline bool protocol::is_ip_v4() const
+{
+    return m_family == AF_INET;
+}
+
+inline bool protocol::is_ip_v6() const
+{
+    return m_family == AF_INET6;
+}
+
+inline protocol::protocol():
+    m_family(AF_UNSPEC),     // Allow both IPv4 and IPv6
+    m_socktype(SOCK_STREAM), // Or SOCK_DGRAM for UDP
+    m_protocol(0)            // Any protocol
+{
+}
+
+// ---------------- address ----------------
+
+inline bool address::is_ip_v4() const
+{
+    return !m_is_ip_v6;
+}
+
+inline bool address::is_ip_v6() const
+{
+    return m_is_ip_v6;
+}
+
+template<class C, class T>
+inline std::basic_ostream<C,T>& operator<<(std::basic_ostream<C,T>& out, const address& addr)
+{
+    union buffer_union {
+        char ip_v4[INET_ADDRSTRLEN];
+        char ip_v6[INET6_ADDRSTRLEN];
+    };
+    char buffer[sizeof (buffer_union)];
+    int af = addr.m_is_ip_v6 ? AF_INET6 : AF_INET;
+    const char* ret = inet_ntop(af, &addr.m_union, buffer, sizeof buffer);
+    if (ret == 0) {
+        std::error_code ec = make_basic_system_error_code(errno);
+        throw std::system_error(ec);
+    }
+    out << ret;
+    return out;
+}
+
+inline address::address():
+    m_is_ip_v6(false)
+{
+    m_union.m_ip_v4 = ip_v4_type();
+}
+
+// ---------------- endpoint ----------------
+
+inline protocol endpoint::protocol() const
+{
+    return m_protocol;
+}
+
+inline address endpoint::address() const
+{
+    class address addr;
+    if (m_protocol.is_ip_v4()) {
+        addr.m_union.m_ip_v4 = m_sockaddr_union.m_ip_v4.sin_addr;
+    }
+    else {
+        addr.m_union.m_ip_v6 = m_sockaddr_union.m_ip_v6.sin6_addr;
+        addr.m_is_ip_v6 = true;
+    }
+    return addr;
+}
+
+inline endpoint::port_type endpoint::port() const
+{
+    return ntohs(m_protocol.is_ip_v4() ? m_sockaddr_union.m_ip_v4.sin_port :
+                 m_sockaddr_union.m_ip_v6.sin6_port);
+}
+
+inline endpoint::endpoint():
+    m_protocol(protocol::ip_v4())
+{
+    m_sockaddr_union.m_ip_v4 = sockaddr_ip_v4_type();
+}
+
+inline endpoint::list::iterator endpoint::list::begin() const
+{
+    return m_endpoints.data();
+}
+
+inline endpoint::list::iterator endpoint::list::end() const
+{
+    return m_endpoints.data() + m_endpoints.size();
+}
+
+inline size_t endpoint::list::size() const
+{
+    return m_endpoints.size();
+}
+
+// ---------------- io_service ----------------
+
+class io_service::async_oper {
+public:
+    bool in_use() const noexcept;
+    bool is_complete() const noexcept;
+    bool is_uncanceled() const noexcept;
+    void cancel() noexcept;
+    virtual void proceed() noexcept = 0;
+    /// Every object of type \ref async_oper must be desroyed either by a call
+    /// to this function or to recycle(). This function recycles the operation
+    /// object (commits suicide), even if it throws.
+    virtual void recycle_and_execute() = 0;
+    /// Every object of type \ref async_oper must be destroyed either by a call
+    /// to recycle_and_execute() or to this function. This function destroys the
+    /// object (commits suicide).
+    virtual void recycle() noexcept = 0;
+    /// Must be called when the owner dies, and the object is in use (not an
+    /// instance of UnusedOper).
+    virtual void orphan()  noexcept = 0;
+protected:
+    async_oper(size_t size, bool in_use) noexcept;
+    virtual ~async_oper() noexcept {}
+    bool is_canceled() const noexcept;
+    void set_is_complete(bool value) noexcept;
+    template<class H, class... Args>
+    void do_recycle_and_execute(bool orphaned, H& handler, Args&&...);
+    void do_recycle(bool orphaned) noexcept;
+private:
+    size_t m_size; // Allocated number of bytes
+    bool m_in_use   = false;
+    bool m_complete = false;      // Always false when not in use
+    bool m_canceled = false;      // Always false when not in use
+    async_oper* m_next = nullptr; // Always null when not in use
+    friend class io_service;
+};
+
+class io_service::wait_oper_base:
+        public async_oper {
+public:
+    wait_oper_base(size_t size, deadline_timer& timer, clock::time_point expiration_time):
+        async_oper(size, true), // Second argument is `in_use`
+        m_timer(&timer),
+        m_expiration_time(expiration_time)
+    {
+    }
+    void proceed() noexcept override final
+    {
+        REALM_ASSERT(false); // Never called
+    }
+    void recycle() noexcept override final
+    {
+        bool orphaned = !m_timer;
+        // Note: do_recycle() commits suicide.
+        do_recycle(orphaned);
+    }
+    void orphan() noexcept override final
+    {
+        m_timer = 0;
+    }
+protected:
+    deadline_timer* m_timer;
+    clock::time_point m_expiration_time;
+    friend class io_service;
+};
+
+class io_service::post_oper_base:
+        public async_oper {
+public:
+    post_oper_base(size_t size, impl& serv):
+        async_oper(size, true), // Second argument is `in_use`
+        m_service(serv)
+    {
+    }
+    void proceed() noexcept override final
+    {
+        REALM_ASSERT(false); // Never called
+    }
+    void recycle() noexcept override final
+    {
+        // io_service::recycle_post_oper() destroys this operation object
+        io_service::recycle_post_oper(m_service, this);
+    }
+    void orphan() noexcept override final
+    {
+        REALM_ASSERT(false); // Never called
+    }
+protected:
+    impl& m_service;
+};
+
+template<class H>
+class io_service::post_oper:
+        public post_oper_base {
+public:
+    post_oper(size_t size, impl& serv, H handler):
+        post_oper_base(size, serv),
+        m_handler(std::move(handler))
+    {
+    }
+    void recycle_and_execute() override final
+    {
+        // Recycle the operation object before the handler is exceuted, such
+        // that the memory is available for a new post operation that might be
+        // initiated during the execution of the handler.
+        bool was_recycled = false;
+        try {
+            H handler = std::move(m_handler); // Throws
+            // io_service::recycle_post_oper() destroys this operation object
+            io_service::recycle_post_oper(m_service, this);
+            was_recycled = true;
+            handler(); // Throws
+        }
+        catch (...) {
+            if (!was_recycled) {
+                // io_service::recycle_post_oper() destroys this operation object
+                io_service::recycle_post_oper(m_service, this);
+            }
+            throw;
+        }
+    }
+private:
+    H m_handler;
+};
+
+class io_service::UnusedOper:
+        public async_oper {
+public:
+    UnusedOper(size_t size) noexcept:
+        async_oper(size, false) // Second argument is `in_use`
+    {
+    }
+    void proceed() noexcept override final
+    {
+        REALM_ASSERT(false); // Never called
+    }
+    void recycle_and_execute() override final
+    {
+        // Must never be called
+        REALM_ASSERT(false);
+    }
+    void recycle() noexcept override final
+    {
+        // Must never be called
+        REALM_ASSERT(false);
+    }
+    void orphan() noexcept override final
+    {
+        // Must never be called
+        REALM_ASSERT(false);
+    }
+};
+
+template<class H> inline void io_service::post(H handler)
+{
+    do_post(&io_service::post_oper_constr<H>, sizeof (post_oper<H>), &handler);
+}
+
+inline void io_service::OwnersOperDeleter::operator()(async_oper* op) const noexcept
+{
+    if (op->in_use()) {
+        op->orphan();
+    }
+    else {
+        void* addr = op;
+        op->~async_oper();
+        delete[] static_cast<char*>(addr);
+    }
+}
+
+inline void io_service::LendersOperDeleter::operator()(async_oper* op) const noexcept
+{
+    op->recycle(); // Suicide
+}
+
+template<class Oper, class... Args> std::unique_ptr<Oper, io_service::LendersOperDeleter>
+io_service::alloc(OwnersOperPtr& owners_ptr, Args&&... args)
+{
+    void* addr = owners_ptr.get();
+    size_t size;
+    if (REALM_LIKELY(addr)) {
+        REALM_ASSERT(!owners_ptr->in_use());
+        size = owners_ptr->m_size;
+        // We can use static dispatch in the destructor call here, since an
+        // object, that is not in use, is always an instance of UnusedOper.
+        REALM_ASSERT(dynamic_cast<UnusedOper*>(owners_ptr.get()));
+        static_cast<UnusedOper*>(owners_ptr.get())->UnusedOper::~UnusedOper();
+        if (REALM_UNLIKELY(size < sizeof (Oper))) {
+            owners_ptr.release();
+            delete[] static_cast<char*>(addr);
+            goto no_object;
+        }
+    }
+    else {
+      no_object:
+        addr = new char[sizeof (Oper)]; // Throws
+        size = sizeof (Oper);
+        owners_ptr.reset(static_cast<async_oper*>(addr));
+    }
+    std::unique_ptr<Oper, LendersOperDeleter> lenders_ptr;
+    try {
+        lenders_ptr.reset(new (addr) Oper(size, std::forward<Args>(args)...)); // Throws
+    }
+    catch (...) {
+        new (addr) UnusedOper(size); // Does not throw
+        throw;
+    }
+    return lenders_ptr;
+}
+
+template<class Oper>
+inline void io_service::execute(std::unique_ptr<Oper, LendersOperDeleter>& lenders_ptr)
+{
+    lenders_ptr.release()->recycle_and_execute(); // Throws
+}
+
+template<class H> inline io_service::post_oper_base*
+io_service::post_oper_constr(void* addr, size_t size, impl& serv, void* cookie)
+{
+    H& handler = *static_cast<H*>(cookie);
+    return new (addr) post_oper<H>(size, serv, std::move(handler)); // Throws
+}
+
+inline bool io_service::async_oper::in_use() const noexcept
+{
+    return m_in_use;
+}
+
+inline bool io_service::async_oper::is_complete() const noexcept
+{
+    return m_complete;
+}
+
+inline bool io_service::async_oper::is_uncanceled() const noexcept
+{
+    return m_in_use && !m_canceled;
+}
+
+inline void io_service::async_oper::cancel() noexcept
+{
+    REALM_ASSERT(m_in_use);
+    REALM_ASSERT(!m_canceled);
+    m_canceled = true;
+}
+
+inline io_service::async_oper::async_oper(size_t size, bool is_in_use) noexcept:
+    m_size(size),
+    m_in_use(is_in_use)
+{
+}
+
+inline bool io_service::async_oper::is_canceled() const noexcept
+{
+    return m_canceled;
+}
+
+inline void io_service::async_oper::set_is_complete(bool value) noexcept
+{
+    REALM_ASSERT(!m_complete);
+    REALM_ASSERT(!value || m_in_use);
+    m_complete = value;
+}
+
+template<class H, class... Args>
+inline void io_service::async_oper::do_recycle_and_execute(bool orphaned, H& handler,
+                                                           Args&&... args)
+{
+    // Recycle the operation object before the handler is exceuted, such that
+    // the memory is available for a new post operation that might be initiated
+    // during the execution of the handler.
+    bool was_recycled = false;
+    try {
+        H handler_2 = std::move(handler); // Throws
+        // The caller (various subclasses of `async_oper`) must not pass any
+        // arguments to the completion handler by reference if they refer to
+        // this operation object, or parts of it. Due to the recycling of the
+        // operation object (`do_recycle()`), such references would become
+        // dangling before the invocation of the completion handler. Due to
+        // `std::decay`, the following tuple will introduce a copy of all
+        // nonconst lvalue reference arguments, preventing such references from
+        // being passed through.
+        std::tuple<typename std::decay<Args>::type...> copy_of_args(args...); // Throws
+        do_recycle(orphaned);
+        was_recycled = true;
+        util::call_with_tuple(handler_2, std::move(copy_of_args)); // Throws
+    }
+    catch (...) {
+        if (!was_recycled)
+            do_recycle(orphaned);
+        throw;
+    }
+}
+
+inline void io_service::async_oper::do_recycle(bool orphaned) noexcept
+{
+    REALM_ASSERT(in_use());
+    void* addr = this;
+    size_t size = m_size;
+    this->~async_oper(); // Suicide
+    if (orphaned) {
+        delete[] static_cast<char*>(addr);
+    }
+    else {
+        new (addr) UnusedOper(size);
+    }
+}
+
+// ---------------- resolver ----------------
+
+inline resolver::resolver(io_service& serv):
+    m_service(serv)
+{
+}
+
+inline io_service& resolver::service() noexcept
+{
+    return m_service;
+}
+
+inline void resolver::resolve(const query& q, endpoint::list& l)
+{
+    std::error_code ec;
+    if (resolve(q, l, ec))
+        throw std::system_error(ec);
+}
+
+inline resolver::query::query(std::string service_port, int init_flags):
+    m_flags(init_flags),
+    m_service(service_port)
+{
+}
+
+inline resolver::query::query(const class protocol& prot, std::string service_port, int init_flags):
+    m_flags(init_flags),
+    m_protocol(prot),
+    m_service(service_port)
+{
+}
+
+inline resolver::query::query(std::string host_name, std::string service_port, int init_flags):
+    m_flags(init_flags),
+    m_host(host_name),
+    m_service(service_port)
+{
+}
+
+inline resolver::query::query(const class protocol& prot, std::string host_name, std::string service_port,
+                              int init_flags):
+    m_flags(init_flags),
+    m_protocol(prot),
+    m_host(host_name),
+    m_service(service_port)
+{
+}
+
+inline resolver::query::~query() noexcept
+{
+}
+
+inline int resolver::query::flags() const
+{
+    return m_flags;
+}
+
+inline class protocol resolver::query::protocol() const
+{
+    return m_protocol;
+}
+
+inline std::string resolver::query::host() const
+{
+    return m_host;
+}
+
+inline std::string resolver::query::service() const
+{
+    return m_service;
+}
+
+// ---------------- socket_base ----------------
+
+inline socket_base::socket_base(io_service& s):
+    m_sock_fd(-1),
+    m_service(s)
+{
+}
+
+inline socket_base::~socket_base() noexcept
+{
+    close();
+}
+
+inline io_service& socket_base::service() noexcept
+{
+    return m_service;
+}
+
+inline bool socket_base::is_open() const noexcept
+{
+    return m_sock_fd != -1;
+}
+
+inline void socket_base::open(const protocol& prot)
+{
+    std::error_code ec;
+    if (open(prot, ec))
+        throw std::system_error(ec);
+}
+
+inline void socket_base::close() noexcept
+{
+    if (!is_open())
+        return;
+    cancel();
+    do_close();
+}
+
+template<class O>
+inline void socket_base::get_option(O& opt) const
+{
+    std::error_code ec;
+    if (get_option(opt, ec))
+        throw std::system_error(ec);
+}
+
+template<class O>
+inline std::error_code socket_base::get_option(O& opt, std::error_code& ec) const
+{
+    opt.get(*this, ec);
+    return ec;
+}
+
+template<class O>
+inline void socket_base::set_option(const O& opt)
+{
+    std::error_code ec;
+    if (set_option(opt, ec))
+        throw std::system_error(ec);
+}
+
+template<class O>
+inline std::error_code socket_base::set_option(const O& opt, std::error_code& ec)
+{
+    opt.set(*this, ec);
+    return ec;
+}
+
+inline void socket_base::bind(const endpoint& ep)
+{
+    std::error_code ec;
+    if (bind(ep, ec))
+        throw std::system_error(ec);
+}
+
+inline endpoint socket_base::local_endpoint() const
+{
+    std::error_code ec;
+    endpoint ep = local_endpoint(ec);
+    if (ec)
+        throw std::system_error(ec);
+    return ep;
+}
+
+inline int socket_base::get_sock_fd() noexcept
+{
+    return m_sock_fd;
+}
+
+inline std::error_code socket_base::ensure_blocking_mode(std::error_code& ec) noexcept
+{
+    // Assuming that sockets are either used mostly in blocking mode, or mostly
+    // in nonblocking mode.
+    if (REALM_UNLIKELY(!m_in_blocking_mode)) {
+        bool enable = false;
+        if (set_nonblocking_mode(enable, ec))
+            return ec;
+        m_in_blocking_mode = true;
+    }
+    return std::error_code(); // Success
+}
+
+inline std::error_code socket_base::ensure_nonblocking_mode(std::error_code& ec) noexcept
+{
+    // Assuming that sockets are either used mostly in blocking mode, or mostly
+    // in nonblocking mode.
+    if (REALM_UNLIKELY(m_in_blocking_mode)) {
+        bool enable = true;
+        if (set_nonblocking_mode(enable, ec))
+            return ec;
+        m_in_blocking_mode = false;
+    }
+    return std::error_code(); // Success
+}
+
+template<class T, int opt, class U>
+inline socket_base::option<T, opt, U>::option(T init_value):
+    m_value(init_value)
+{
+}
+
+template<class T, int opt, class U>
+inline T socket_base::option<T, opt, U>::value() const
+{
+    return m_value;
+}
+
+template<class T, int opt, class U>
+inline void socket_base::option<T, opt, U>::get(const socket_base& sock, std::error_code& ec)
+{
+    union {
+        U value;
+        char strut[sizeof (U) + 1];
+    };
+    size_t value_size = sizeof strut;
+    sock.get_option(opt_enum(opt), &value, value_size, ec);
+    if (!ec) {
+        REALM_ASSERT(value_size == sizeof value);
+        m_value = T(value);
+    }
+}
+
+template<class T, int opt, class U>
+inline void socket_base::option<T, opt, U>::set(socket_base& sock, std::error_code& ec) const
+{
+    U value_to_set = U(m_value);
+    sock.set_option(opt_enum(opt), &value_to_set, sizeof value_to_set, ec);
+}
+
+// ---------------- socket ----------------
+
+class socket::connect_oper_base:
+        public io_service::async_oper {
+public:
+    connect_oper_base(size_t size, socket& sock, const endpoint& ep):
+        async_oper(size, true), // Second argument is `in_use`
+        m_socket(&sock)
+    {
+        if (m_socket->initiate_async_connect(ep, m_error_code))
+            set_is_complete(true); // Failure, or immediate completion
+    }
+    void proceed() noexcept override final
+    {
+        REALM_ASSERT(!is_complete());
+        REALM_ASSERT(!is_canceled());
+        REALM_ASSERT(!m_error_code);
+        m_socket->finalize_async_connect(m_error_code);
+        set_is_complete(true);
+    }
+    void recycle() noexcept override final
+    {
+        bool orphaned = !m_socket;
+        // Note: do_recycle() commits suicide.
+        do_recycle(orphaned);
+    }
+    void orphan() noexcept override final
+    {
+        m_socket = nullptr;
+    }
+protected:
+    socket* m_socket;
+    std::error_code m_error_code;
+};
+
+template<class H>
+class socket::connect_oper:
+        public connect_oper_base {
+public:
+    connect_oper(size_t size, socket& sock, const endpoint& ep, H handler):
+        connect_oper_base(size, sock, ep),
+        m_handler(std::move(handler))
+    {
+    }
+    void recycle_and_execute() override final
+    {
+        REALM_ASSERT(is_complete() || (is_canceled() && !m_error_code));
+        bool orphaned = !m_socket;
+        std::error_code ec = m_error_code;
+        if (is_canceled())
+            ec = error::operation_aborted;
+        // Note: do_recycle_and_execute() commits suicide.
+        do_recycle_and_execute<H>(orphaned, m_handler, ec); // Throws
+    }
+private:
+    H m_handler;
+};
+
+class socket::write_oper_base:
+        public io_service::async_oper {
+public:
+    write_oper_base(size_t size_1, socket& sock, const char* data, size_t size_2):
+        async_oper(size_1, true), // Second argument is `in_use`
+        m_socket(&sock),
+        m_begin(data),
+        m_end(data + size_2),
+        m_curr(data)
+    {
+    }
+    void initiate() noexcept
+    {
+        REALM_ASSERT(!is_complete());
+        REALM_ASSERT(m_curr <= m_end);
+        if (m_curr == m_end) {
+            set_is_complete(true); // Success
+        }
+        else if (m_socket->ensure_nonblocking_mode(m_error_code)) {
+            set_is_complete(true); // Failure
+        }
+    }
+    void proceed() noexcept override final
+    {
+        REALM_ASSERT(!is_complete());
+        REALM_ASSERT(!is_canceled());
+        REALM_ASSERT(!m_error_code);
+        REALM_ASSERT(m_curr <= m_end);
+        size_t n_1 = size_t(m_end - m_curr);
+        size_t n_2 = m_socket->do_write_some(m_curr, n_1, m_error_code);
+        REALM_ASSERT(n_2 <= n_1);
+        m_curr += n_2;
+        // During asynchronous operation the socket is in nonblocking mode, and
+        // proceed() will only be called when the socket is reported ready for
+        // writing (by poll() or select()). Even then, it may still occasionally
+        // happen that write() (the system call) fails with EAGAIN
+        // (error::resource_unavailable_try_again). The Linux man page for
+        // select() notes that such a situation might occur. This has been
+        // observed to occur on Mac OSX when writing large amounts of data
+        // quickly.
+        //
+        // The best way to deal with a situation like this, seems to be to
+        // ignore the incidence and go back to waiting for the socket to become
+        // ready for writing again. It is hoped (and assumed) that these
+        // incidences are sufficiently rare, that it does not lead to an
+        // effective busy wait for the socket to become truly ready for writing.
+        if (REALM_UNLIKELY(m_error_code == error::resource_unavailable_try_again)) {
+            m_error_code = std::error_code(); // Clear
+        }
+        else {
+            set_is_complete(m_error_code || m_curr == m_end);
+        }
+    }
+    void recycle() noexcept override final
+    {
+        bool orphaned = !m_socket;
+        // Note: do_recycle() commits suicide.
+        do_recycle(orphaned);
+    }
+    void orphan() noexcept override final
+    {
+        m_socket = 0;
+    }
+protected:
+    socket* m_socket;
+    const char* const m_begin; // May be dangling after cancellation
+    const char* const m_end;   // May be dangling after cancellation
+    const char* m_curr;        // May be dangling after cancellation
+    std::error_code m_error_code;
+};
+
+template<class H>
+class socket::write_oper:
+        public write_oper_base {
+public:
+    write_oper(size_t size_1, socket& sock, const char* data, size_t size_2, H handler):
+        write_oper_base(size_1, sock, data, size_2),
+        m_handler(std::move(handler))
+    {
+    }
+    void recycle_and_execute() override final
+    {
+        REALM_ASSERT(is_complete() || is_canceled());
+        REALM_ASSERT(is_complete() == (m_error_code || m_curr == m_end));
+        REALM_ASSERT(m_curr >= m_begin);
+        bool orphaned = !m_socket;
+        std::error_code ec = m_error_code;
+        if (is_canceled())
+            ec = error::operation_aborted;
+        size_t num_bytes_transferred = size_t(m_curr - m_begin);
+        // Note: do_recycle_and_execute() commits suicide.
+        do_recycle_and_execute<H>(orphaned, m_handler, ec, num_bytes_transferred); // Throws
+    }
+private:
+    H m_handler;
+};
+
+inline socket::socket(io_service& s):
+    socket_base(s)
+{
+}
+
+inline socket::~socket() noexcept
+{
+}
+
+inline void socket::connect(const endpoint& ep)
+{
+    std::error_code ec;
+    if (connect(ep, ec))
+        throw std::system_error(ec);
+}
+
+template<class H>
+inline void socket::async_connect(const endpoint& ep, H handler)
+{
+    LendersConnectOperPtr op =
+        io_service::alloc<connect_oper<H>>(m_write_oper, *this, ep, std::move(handler)); // Throws
+    do_async_connect(std::move(op)); // Throws
+}
+
+inline void socket::write(const char* data, size_t size)
+{
+    std::error_code ec;
+    if (write(data, size, ec))
+        throw std::system_error(ec);
+}
+
+template<class H>
+inline void socket::async_write(const char* data, size_t size, H handler)
+{
+    LendersWriteOperPtr op =
+        io_service::alloc<write_oper<H>>(m_write_oper, *this, data, size,
+                                         std::move(handler)); // Throws
+    do_async_write(std::move(op)); // Throws
+}
+
+inline size_t socket::read_some(char* buffer, size_t size)
+{
+    std::error_code ec;
+    size_t n = read_some(buffer, size, ec);
+    if (ec)
+        throw std::system_error(ec);
+    return n;
+}
+
+inline size_t socket::read_some(char* buffer, size_t size, std::error_code& ec) noexcept
+{
+    if (ensure_blocking_mode(ec))
+        return 0;
+    return do_read_some(buffer, size, ec);
+}
+
+inline size_t socket::write_some(const char* data, size_t size)
+{
+    std::error_code ec;
+    size_t n = write_some(data, size, ec);
+    if (ec)
+        throw std::system_error(ec);
+    return n;
+}
+
+inline size_t socket::write_some(const char* data, size_t size, std::error_code& ec) noexcept
+{
+    if (ensure_blocking_mode(ec))
+        return 0;
+    return do_write_some(data, size, ec);
+}
+
+inline void socket::shutdown(shutdown_type what)
+{
+    std::error_code ec;
+    if (shutdown(what, ec))
+        throw std::system_error(ec);
+}
+
+inline void socket::do_async_connect(LendersConnectOperPtr op)
+{
+    if (op->is_complete()) {
+        m_service.add_completed_oper(std::move(op));
+    }
+    else {
+        REALM_ASSERT(op == m_write_oper);
+        m_service.add_io_oper(get_sock_fd(), std::move(op), io_service::io_op_Write); // Throws
+    }
+}
+
+inline void socket::do_async_write(LendersWriteOperPtr op)
+{
+    op->initiate();
+    if (op->is_complete()) {
+        m_service.add_completed_oper(std::move(op));
+    }
+    else {
+        REALM_ASSERT(op == m_write_oper);
+        m_service.add_io_oper(get_sock_fd(), std::move(op), io_service::io_op_Write); // Throws
+    }
+}
+
+// ---------------- acceptor ----------------
+
+class acceptor::accept_oper_base:
+        public io_service::async_oper {
+public:
+    accept_oper_base(size_t size, acceptor& a, socket& s, endpoint* e):
+        async_oper(size, true), // Second argument is `in_use`
+        m_acceptor(&a),
+        m_socket(s),
+        m_endpoint(e)
+    {
+    }
+    void initiate() noexcept
+    {
+        REALM_ASSERT(!is_complete());
+        if (m_acceptor->ensure_nonblocking_mode(m_error_code))
+            set_is_complete(true); // Failure
+    }
+    void proceed() noexcept override final
+    {
+        REALM_ASSERT(!is_complete());
+        REALM_ASSERT(!is_canceled());
+        REALM_ASSERT(!m_error_code);
+        REALM_ASSERT(!m_socket.is_open());
+        m_acceptor->do_accept(m_socket, m_endpoint, m_error_code);
+        // During asynchronous operation the listening socket is in nonblocking
+        // mode, and proceed() will only be called when the socket is reported
+        // ready for reading (by poll() or select()). Even then, it may still
+        // occasionally happen that accept() (the system call) fails with EAGAIN
+        // (error::resource_unavailable_try_again). The Linux man page for
+        // select() notes that such a situation might occur.
+        //
+        // The best way to deal with a situation like this, seems to be to
+        // ignore the incidence and go back to waiting for the socket to become
+        // ready for reading again. It is hoped (and assumed) that these
+        // incidences are sufficiently rare, that it does not lead to an
+        // effective busy wait for the socket to become truly ready for reading.
+        if (REALM_UNLIKELY(m_error_code == error::resource_unavailable_try_again)) {
+            m_error_code = std::error_code(); // Clear
+        }
+        else {
+            set_is_complete(true);
+        }
+    }
+    void recycle() noexcept override final
+    {
+        bool orphaned = !m_acceptor;
+        // Note: do_recycle() commits suicide.
+        do_recycle(orphaned);
+    }
+    void orphan() noexcept override final
+    {
+        m_acceptor = 0;
+    }
+protected:
+    acceptor* m_acceptor;
+    socket& m_socket;           // May be dangling after cancellation
+    endpoint* const m_endpoint; // May be dangling after cancellation
+    std::error_code m_error_code;
+};
+
+template<class H>
+class acceptor::accept_oper:
+        public accept_oper_base {
+public:
+    accept_oper(size_t size, acceptor& a, socket& s, endpoint* e, H handler):
+        accept_oper_base(size, a, s, e),
+        m_handler(std::move(handler))
+    {
+    }
+    void recycle_and_execute() override final
+    {
+        REALM_ASSERT(is_complete() || (is_canceled() && !m_error_code));
+        REALM_ASSERT(is_canceled() || m_error_code || m_socket.is_open());
+        bool orphaned = !m_acceptor;
+        std::error_code ec = m_error_code;
+        if (is_canceled())
+            ec = error::operation_aborted;
+        // Note: do_recycle_and_execute() commits suicide.
+        do_recycle_and_execute<H>(orphaned, m_handler, ec); // Throws
+    }
+private:
+    H m_handler;
+};
+
+inline acceptor::acceptor(io_service& s):
+    socket_base(s)
+{
+}
+
+inline acceptor::~acceptor() noexcept
+{
+}
+
+inline void acceptor::listen(int backlog)
+{
+    std::error_code ec;
+    if (listen(backlog, ec))
+        throw std::system_error(ec);
+}
+
+inline void acceptor::accept(socket& sock)
+{
+    std::error_code ec;
+    if (accept(sock, ec)) // Throws
+        throw std::system_error(ec);
+}
+
+inline void acceptor::accept(socket& sock, endpoint& ep)
+{
+    std::error_code ec;
+    if (accept(sock, ep, ec)) // Throws
+        throw std::system_error(ec);
+}
+
+inline std::error_code acceptor::accept(socket& sock, std::error_code& ec)
+{
+    endpoint* ep = nullptr;
+    return accept(sock, ep, ec); // Throws
+}
+
+inline std::error_code acceptor::accept(socket& sock, endpoint& ep, std::error_code& ec)
+{
+    return accept(sock, &ep, ec); // Throws
+}
+
+template<class H> inline void acceptor::async_accept(socket& sock, H handler)
+{
+    endpoint* ep = nullptr;
+    async_accept(sock, ep, std::move(handler)); // Throws
+}
+
+template<class H> inline void acceptor::async_accept(socket& sock, endpoint& ep, H handler)
+{
+    async_accept(sock, &ep, std::move(handler)); // Throws
+}
+
+inline std::error_code acceptor::accept(socket& sock, endpoint* ep, std::error_code& ec)
+{
+    REALM_ASSERT(!m_read_oper || !m_read_oper->in_use());
+    if (REALM_UNLIKELY(sock.is_open()))
+        throw std::runtime_error("Socket is already open");
+    if (ensure_blocking_mode(ec))
+        return ec;
+    return do_accept(sock, ep, ec);
+}
+
+template<class H> inline void acceptor::async_accept(socket& sock, endpoint* ep, H handler)
+{
+    if (REALM_UNLIKELY(sock.is_open()))
+        throw std::runtime_error("Socket is already open");
+    LendersAcceptOperPtr op =
+        io_service::alloc<accept_oper<H>>(m_read_oper, *this, sock, ep,
+                                          std::move(handler)); // Throws
+    do_async_accept(std::move(op)); // Throws
+}
+
+inline void acceptor::do_async_accept(LendersAcceptOperPtr op)
+{
+    op->initiate();
+    if (op->is_complete()) {
+        m_service.add_completed_oper(std::move(op));
+    }
+    else {
+        REALM_ASSERT(op == m_read_oper);
+        m_service.add_io_oper(get_sock_fd(), std::move(op), io_service::io_op_Read); // Throws
+    }
+}
+
+// ---------------- buffered_input_stream ----------------
+
+class buffered_input_stream::read_oper_base:
+        public io_service::async_oper {
+public:
+    read_oper_base(size_t size_1, buffered_input_stream& s, char* buffer, size_t size_2,
+                   int delim):
+        async_oper(size_1, true), // Second argument is `in_use`
+        m_stream(&s),
+        m_out_begin(buffer),
+        m_out_end(buffer + size_2),
+        m_out_curr(buffer),
+        m_delim(delim)
+    {
+    }
+    void initiate() noexcept
+    {
+        REALM_ASSERT(!is_complete());
+        process_buffered_input();
+        if (!is_complete()) {
+            if (m_stream->m_socket.ensure_nonblocking_mode(m_error_code))
+                set_is_complete(true); // Failure
+        }
+    }
+    void process_buffered_input() noexcept;
+    void proceed() noexcept override final;
+    void recycle() noexcept override final
+    {
+        bool orphaned = !m_stream;
+        // Note: do_recycle() commits suicide.
+        do_recycle(orphaned);
+    }
+    void orphan() noexcept override final
+    {
+        m_stream = 0;
+    }
+protected:
+    buffered_input_stream* m_stream;
+    char* const m_out_begin; // May be dangling after cancellation
+    char* const m_out_end;   // May be dangling after cancellation
+    char* m_out_curr;        // May be dangling after cancellation
+    const int m_delim;
+    std::error_code m_error_code;
+};
+
+template<class H>
+class buffered_input_stream::read_oper:
+        public read_oper_base {
+public:
+    read_oper(size_t size_1, buffered_input_stream& stream, char* buffer, size_t size_2, int delim,
+              H handler):
+        read_oper_base(size_1, stream, buffer, size_2, delim),
+        m_handler(std::move(handler))
+    {
+    }
+    void recycle_and_execute() override final
+    {
+        REALM_ASSERT(is_complete() || (is_canceled() && !m_error_code));
+        REALM_ASSERT(is_canceled() || m_error_code ||
+                     (m_delim != std::char_traits<char>::eof() ?
+                      m_out_curr > m_out_begin && m_out_curr[-1] ==
+                      std::char_traits<char>::to_char_type(m_delim) :
+                      m_out_curr == m_out_end));
+        REALM_ASSERT(m_out_curr >= m_out_begin);
+        bool orphaned = !m_stream;
+        std::error_code ec = m_error_code;
+        if (is_canceled())
+            ec = error::operation_aborted;
+        size_t num_bytes_transferred = size_t(m_out_curr - m_out_begin);
+        // Note: do_recycle_and_execute() commits suicide.
+        do_recycle_and_execute<H>(orphaned, m_handler, ec, num_bytes_transferred); // Throws
+    }
+private:
+    H m_handler;
+};
+
+inline buffered_input_stream::buffered_input_stream(socket& sock):
+    m_socket(sock),
+    m_buffer(new char[s_buffer_size]) // Throws
+{
+    reset();
+}
+
+inline buffered_input_stream::~buffered_input_stream() noexcept
+{
+}
+
+inline size_t buffered_input_stream::read(char* buffer, size_t size)
+{
+    std::error_code ec;
+    size_t n = read(buffer, size, ec);
+    if (ec)
+        throw std::system_error(ec);
+    return n;
+}
+
+inline size_t buffered_input_stream::read(char* buffer, size_t size, std::error_code& ec) noexcept
+{
+    return do_read(buffer, size, std::char_traits<char>::eof(), ec);
+}
+
+inline size_t buffered_input_stream::read_until(char* buffer, size_t size, char delim)
+{
+    std::error_code ec;
+    size_t n = read_until(buffer, size, delim, ec);
+    if (ec)
+        throw std::system_error(ec);
+    return n;
+}
+
+inline size_t buffered_input_stream::read_until(char* buffer, size_t size, char delim,
+                                                std::error_code& ec) noexcept
+{
+    return do_read(buffer, size, std::char_traits<char>::to_int_type(delim), ec);
+}
+
+template<class H>
+inline void buffered_input_stream::async_read(char* buffer, size_t size, H handler)
+{
+    async_read(buffer, size, std::char_traits<char>::eof(), std::move(handler));
+}
+
+template<class H>
+inline void buffered_input_stream::async_read_until(char* buffer, size_t size, char delim,
+                                                    H handler)
+{
+    async_read(buffer, size, std::char_traits<char>::to_int_type(delim), std::move(handler));
+}
+
+inline void buffered_input_stream::reset() noexcept
+{
+    m_begin = m_buffer.get();
+    m_end   = m_buffer.get();
+}
+
+template<class H>
+inline void buffered_input_stream::async_read(char* buffer, size_t size, int delim, H handler)
+{
+    LendersReadOperPtr op =
+        io_service::alloc<read_oper<H>>(m_socket.m_read_oper, *this, buffer, size, delim,
+                                        std::move(handler)); // Throws
+    do_async_read(std::move(op)); // Throws
+}
+
+inline void buffered_input_stream::do_async_read(LendersReadOperPtr op)
+{
+    op->initiate();
+    if (op->is_complete()) {
+        m_socket.m_service.add_completed_oper(std::move(op));
+    }
+    else {
+        REALM_ASSERT(op == m_socket.m_read_oper);
+        m_socket.m_service.add_io_oper(m_socket.get_sock_fd(), std::move(op),
+                                       io_service::io_op_Read); // Throws
+    }
+}
+
+// ---------------- deadline_timer ----------------
+
+template<class H>
+class deadline_timer::wait_oper:
+        public io_service::wait_oper_base {
+public:
+    wait_oper(size_t size, deadline_timer& timer, clock::time_point expiration_time, H handler):
+        io_service::wait_oper_base(size, timer, expiration_time),
+        m_handler(std::move(handler))
+    {
+    }
+    void recycle_and_execute() override final
+    {
+        bool orphaned = !m_timer;
+        std::error_code ec;
+        if (is_canceled())
+            ec = error::operation_aborted;
+        // Note: do_recycle_and_execute() commits suicide.
+        do_recycle_and_execute<H>(orphaned, m_handler, ec); // Throws
+    }
+private:
+    H m_handler;
+};
+
+inline deadline_timer::deadline_timer(io_service& serv):
+    m_service(serv)
+{
+}
+
+inline deadline_timer::~deadline_timer() noexcept
+{
+    cancel();
+}
+
+inline io_service& deadline_timer::service() noexcept
+{
+    return m_service;
+}
+
+template<class R, class P, class H>
+inline void deadline_timer::async_wait(std::chrono::duration<R,P> delay, H handler)
+{
+    clock::time_point now = clock::now();
+    auto max_add = clock::time_point::max() - now;
+    if (delay > max_add)
+        throw std::runtime_error("Expiration time overflow");
+    clock::time_point expiration_time = now + delay;
+    io_service::LendersWaitOperPtr op =
+        io_service::alloc<wait_oper<H>>(m_wait_oper, *this, expiration_time,
+                                        std::move(handler)); // Throws
+    m_service.add_wait_oper(std::move(op)); // Throws
+}
+
+} // namespace network
+} // namespace util
+} // namespace realm
+
+#endif // REALM_UTIL_NETWORK_HPP
diff --git a/Pods/Realm/include/core/realm/util/optional.hpp b/Pods/Realm/include/core/realm/util/optional.hpp
new file mode 100644
index 0000000..36c46c0
--- /dev/null
+++ b/Pods/Realm/include/core/realm/util/optional.hpp
@@ -0,0 +1,651 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+
+#pragma once
+#ifndef REALM_UTIL_OPTIONAL_HPP
+#define REALM_UTIL_OPTIONAL_HPP
+
+#include <realm/util/features.h>
+
+#include <stdexcept> // std::logic_error
+#include <functional> // std::less
+
+namespace realm {
+namespace util {
+
+template<class T>
+class Optional;
+
+// some() should be the equivalent of the proposed C++17 `make_optional`.
+template<class T, class... Args>
+Optional<T> some(Args&&...);
+template<class T>
+struct Some;
+
+// Note: Should conform with the future std::nullopt_t and std::in_place_t.
+struct None { constexpr explicit None(int) {} };
+static constexpr None none { 0 };
+struct InPlace { constexpr InPlace() {} };
+static constexpr InPlace in_place;
+
+// Note: Should conform with the future std::bad_optional_access.
+struct BadOptionalAccess : std::logic_error {
+    explicit BadOptionalAccess(const std::string& what_arg) : std::logic_error(what_arg) {}
+    explicit BadOptionalAccess(const char* what_arg) : std::logic_error(what_arg) {}
+};
+
+} // namespace util
+
+namespace _impl {
+
+template<class T, bool=std::is_trivially_destructible<T>::value>
+struct OptionalStorage;
+
+// FIXME: Callers should switch to std::move when we adopt C++14
+template<class T>
+inline constexpr typename std::remove_reference<T>::type&& constexpr_move(T&& t) noexcept
+{
+    return static_cast<typename std::remove_reference<T>::type&&>(t);
+}
+
+// FIXME: Callers should switch to std::forward when we adopt C++14
+template<class T>
+inline constexpr T&& constexpr_forward(typename std::remove_reference<T>::type& t) noexcept
+{
+    return static_cast<T&&>(t);
+}
+
+// FIXME: Callers should switch to std::forward when we adopt C++14
+template<class T>
+inline constexpr T&& constexpr_forward(typename std::remove_reference<T>::type&& t) noexcept
+{
+    static_assert(!std::is_lvalue_reference<T>::value, "Can't forward rvalue as lvalue.");
+    return static_cast<T&&>(t);
+}
+
+template<class T, class U>
+struct TypeIsAssignableToOptional {
+    // Constraints from [optional.object.assign.18]
+    static const bool value = (std::is_same<typename std::remove_reference<U>::type, T>::value
+                               && std::is_constructible<T, U>::value
+                               && std::is_assignable<T&, U>::value);
+};
+
+} // namespace _impl
+
+namespace util {
+
+// Note: Should conform with the future std::optional.
+template<class T>
+class Optional : private _impl::OptionalStorage<T> {
+public:
+    using value_type = T;
+
+    constexpr Optional();
+    constexpr Optional(None);
+    Optional(Optional<T>&& other);
+    Optional(const Optional<T>& other);
+
+    constexpr Optional(T&& value);
+    constexpr Optional(const T& value);
+
+    template<class... Args>
+    constexpr Optional(InPlace tag, Args&&...);
+    // FIXME: std::optional specifies an std::initializer_list constructor overload as well.
+
+    Optional<T>& operator=(None);
+    Optional<T>& operator=(Optional<T>&& other);
+    Optional<T>& operator=(const Optional<T>& other);
+
+    template<class U, class = typename std::enable_if<_impl::TypeIsAssignableToOptional<T, U>::value>::type>
+    Optional<T>& operator=(U&& value);
+
+    explicit constexpr operator bool() const;
+    constexpr const T& value() const; // Throws
+    T& value(); // Throws, FIXME: Can be constexpr with C++14
+    constexpr const T& operator*() const; // Throws
+    T& operator*(); // Throws, FIXME: Can be constexpr with C++14
+    constexpr const T* operator->() const; // Throws
+    T* operator->(); // Throws, FIXME: Can be constexpr with C++14
+
+    template<class U>
+    constexpr T value_or(U&& value) const&;
+
+    template<class U>
+    T value_or(U&& value) &&;
+
+    void swap(Optional<T>& other); // FIXME: Add noexcept() clause
+
+    template<class... Args>
+    void emplace(Args&&...);
+    // FIXME: std::optional specifies an std::initializer_list overload for `emplace` as well.
+private:
+    using Storage = _impl::OptionalStorage<T>;
+    using Storage::m_engaged;
+    using Storage::m_value;
+
+    constexpr bool is_engaged() const { return m_engaged; }
+    void set_engaged(bool b) { m_engaged = b; }
+    void clear();
+};
+
+/// An Optional<void> is functionally equivalent to a bool.
+/// Note: C++17 does not (yet) specify this specialization, but it is convenient
+/// as a "safer bool", especially in the presence of `fmap`.
+/// Disabled for compliance with std::optional.
+// template<>
+// class Optional<void> {
+// public:
+//     Optional() {}
+//     Optional(None) {}
+//     Optional(Optional<void>&&) = default;
+//     Optional(const Optional<void>&) = default;
+//     explicit operator bool() const { return m_engaged; }
+// private:
+//     bool m_engaged = false;
+//     friend struct Some<void>;
+// };
+
+/// An Optional<T&> is a non-owning nullable pointer that throws on dereference.
+// FIXME: Visual Studio 2015's constexpr support isn't sufficient to allow Optional<T&> to compile
+// in constexpr contexts.
+template<class T>
+class Optional<T&> {
+public:
+    using value_type = T&;
+    using target_type = typename std::decay<T>::type;
+
+    constexpr Optional() {}
+    constexpr Optional(None) {} // FIXME: Was a delegating constructor, but not fully supported in VS2015
+    Optional(const Optional<T&>& other) = default;
+    template<class U>
+    Optional(const Optional<U&>& other) : m_ptr(other.m_ptr) {}
+    template<class U>
+    Optional(std::reference_wrapper<U> ref) : m_ptr(&ref.get()) {}
+
+    constexpr Optional(T& init_value) : m_ptr(&init_value) {}
+    Optional(T&& value) = delete; // Catches accidental references to rvalue temporaries.
+
+    Optional<T&>& operator=(None) { m_ptr = nullptr; return *this; }
+    Optional<T&>& operator=(const Optional<T&>& other) { m_ptr = other.m_ptr; return *this; }
+
+    template<class U>
+    Optional<T&>& operator=(std::reference_wrapper<U> ref) { m_ptr = &ref.get(); return *this; }
+
+    explicit constexpr operator bool() const { return m_ptr; }
+    constexpr const target_type& value() const; // Throws
+    target_type& value(); // Throws
+    constexpr const target_type& operator*() const { return value(); }
+    target_type& operator*() { return value(); }
+    constexpr const target_type* operator->() const { return &value(); }
+    target_type* operator->() { return &value(); }
+
+    void swap(Optional<T&> other); // FIXME: Add noexcept() clause
+private:
+    T* m_ptr = nullptr;
+
+    template<class U>
+    friend class Optional;
+};
+
+
+template<class T> struct RemoveOptional {
+    using type = T;
+};
+template<class T> struct RemoveOptional<Optional<T>> {
+    using type = typename RemoveOptional<T>::type; // Remove recursively
+};
+
+
+/// Implementation:
+
+template<class T>
+struct Some {
+    template<class... Args>
+    static Optional<T> some(Args&&... args)
+    {
+        return Optional<T>{std::forward<Args>(args)...};
+    }
+};
+
+/// Disabled for compliance with std::optional.
+// template<>
+// struct Some<void> {
+//     static Optional<void> some()
+//     {
+//         Optional<void> opt;
+//         opt.m_engaged = true;
+//         return opt;
+//     }
+// };
+
+template<class T, class... Args>
+Optional<T> some(Args&&... args)
+{
+    return Some<T>::some(std::forward<Args>(args)...);
+}
+
+
+template<class T>
+constexpr Optional<T>::Optional(): Storage(none)
+{
+}
+
+template<class T>
+constexpr Optional<T>::Optional(None): Storage(none)
+{
+}
+
+template<class T>
+Optional<T>::Optional(Optional<T>&& other): Storage(none)
+{
+    if (other.m_engaged) {
+        new(&m_value) T(std::move(other.m_value));
+        m_engaged = true;
+    }
+}
+
+template<class T>
+Optional<T>::Optional(const Optional<T>& other): Storage(none)
+{
+    if (other.m_engaged) {
+        new(&m_value) T(other.m_value);
+        m_engaged = true;
+    }
+}
+
+template<class T>
+constexpr Optional<T>::Optional(T&& r_value): Storage(_impl::constexpr_move(r_value))
+{
+}
+
+template<class T>
+constexpr Optional<T>::Optional(const T& l_value): Storage(l_value)
+{
+}
+
+template<class T>
+template<class... Args>
+constexpr Optional<T>::Optional(InPlace, Args&&... args): Storage(std::forward<Args>(args)...)
+{
+}
+
+template<class T>
+void Optional<T>::clear()
+{
+    if (m_engaged) {
+        m_value.~T();
+        m_engaged = false;
+    }
+}
+
+template<class T>
+Optional<T>& Optional<T>::operator=(None)
+{
+    clear();
+    return *this;
+}
+
+template<class T>
+Optional<T>& Optional<T>::operator=(Optional<T>&& other)
+{
+    if (m_engaged) {
+        if (other.m_engaged) {
+            m_value = std::move(other.m_value);
+        }
+        else {
+            clear();
+        }
+    }
+    else {
+        if (other.m_engaged) {
+            new(&m_value) T(std::move(other.m_value));
+            m_engaged = true;
+        }
+    }
+    return *this;
+}
+
+template<class T>
+Optional<T>& Optional<T>::operator=(const Optional<T>& other)
+{
+    if (m_engaged) {
+        if (other.m_engaged) {
+            m_value = other.m_value;
+        }
+        else {
+            clear();
+        }
+    }
+    else {
+        if (other.m_engaged) {
+            new(&m_value) T(other.m_value);
+            m_engaged = true;
+        }
+    }
+    return *this;
+}
+
+template<class T>
+template<class U, class>
+Optional<T>& Optional<T>::operator=(U&& r_value)
+{
+    if (m_engaged) {
+        m_value = std::forward<U>(r_value);
+    }
+    else {
+        new(&m_value) T(std::forward<U>(r_value));
+        m_engaged = true;
+    }
+    return *this;
+}
+
+template<class T>
+constexpr Optional<T>::operator bool() const
+{
+    return m_engaged;
+}
+
+template<class T>
+constexpr const T& Optional<T>::value() const
+{
+    return m_engaged ? m_value : (throw BadOptionalAccess{"bad optional access"}, m_value);
+}
+
+template<class T>
+T& Optional<T>::value()
+{
+    if (!m_engaged) {
+        throw BadOptionalAccess{"bad optional access"};
+    }
+    return m_value;
+}
+
+template<class T>
+constexpr const typename Optional<T&>::target_type& Optional<T&>::value() const
+{
+    return m_ptr ? *m_ptr : (throw BadOptionalAccess{"bad optional access"}, *m_ptr);
+}
+
+template<class T>
+typename Optional<T&>::target_type& Optional<T&>::value()
+{
+    if (!m_ptr) {
+        throw BadOptionalAccess{"bad optional access"};
+    }
+    return *m_ptr;
+}
+
+template<class T>
+constexpr const T& Optional<T>::operator*() const
+{
+    // Note: This differs from std::optional, which doesn't throw.
+    return value();
+}
+
+template<class T>
+T& Optional<T>::operator*()
+{
+    // Note: This differs from std::optional, which doesn't throw.
+    return value();
+}
+
+template<class T>
+constexpr const T* Optional<T>::operator->() const
+{
+    // Note: This differs from std::optional, which doesn't throw.
+    return &value();
+}
+
+template<class T>
+T* Optional<T>::operator->()
+{
+    // Note: This differs from std::optional, which doesn't throw.
+    return &value();
+}
+
+template<class T>
+template<class U>
+constexpr T Optional<T>::value_or(U&& otherwise) const&
+{
+    return m_engaged ? T{m_value} : T{_impl::constexpr_forward<U>(otherwise)};
+}
+
+template<class T>
+template<class U>
+T Optional<T>::value_or(U&& otherwise) &&
+{
+    if (is_engaged()) {
+        return T(std::move(m_value));
+    }
+    else {
+        return T(std::forward<U>(otherwise));
+    }
+}
+
+template<class T>
+void Optional<T>::swap(Optional<T>& other)
+{
+    // FIXME: This might be optimizable.
+    Optional<T> tmp = std::move(other);
+    other = std::move(*this);
+    *this = std::move(tmp);
+}
+
+template<class T>
+template<class... Args>
+void Optional<T>::emplace(Args&&... args)
+{
+    clear();
+    new(&m_value) T(std::forward<Args>(args)...);
+    m_engaged = true;
+}
+
+
+template<class T>
+constexpr Optional<typename std::decay<T>::type>
+make_optional(T&& value)
+{
+    using Type = typename std::decay<T>::type;
+    return some<Type>(std::forward<T>(value));
+}
+
+template<class T>
+bool operator==(const Optional<T>& lhs, const Optional<T>& rhs)
+{
+    if (!lhs && !rhs) { return true; }
+    if (lhs && rhs) { return *lhs == *rhs; }
+    return false;
+}
+
+template<class T>
+bool operator!=(const Optional<T>& lhs, const Optional<T>& rhs)
+{
+    return !(lhs == rhs);
+}
+
+template<class T>
+bool operator<(const Optional<T>& lhs, const Optional<T>& rhs)
+{
+    if (!rhs) { return false; }
+    if (!lhs) { return true; }
+    return std::less<T>{}(*lhs, *rhs);
+}
+
+template<class T>
+bool operator>(const util::Optional<T>& lhs, const util::Optional<T>& rhs)
+{
+    if (!lhs) { return false; }
+    if (!rhs) { return true; }
+    return std::greater<T>{}(*lhs, *rhs);
+}
+
+template<class T>
+bool operator==(const Optional<T>& lhs, None)
+{
+    return !bool(lhs);
+}
+
+template<class T>
+bool operator!=(const Optional<T>& lhs, None)
+{
+    return bool(lhs);
+}
+
+template<class T>
+bool operator<(const Optional<T>& lhs, None)
+{
+    static_cast<void>(lhs);
+    return false;
+}
+
+template<class T>
+bool operator==(None, const Optional<T>& rhs)
+{
+    return !bool(rhs);
+}
+
+template<class T>
+bool operator!=(None, const Optional<T>& rhs)
+{
+    return bool(rhs);
+}
+
+template<class T>
+bool operator<(None, const Optional<T>& rhs)
+{
+    return bool(rhs);
+}
+
+template<class T, class U>
+bool operator==(const Optional<T>& lhs, const U& rhs)
+{
+    return lhs ? *lhs == rhs : false;
+}
+
+template<class T>
+bool operator<(const Optional<T>& lhs, const T& rhs)
+{
+    return lhs ? std::less<T>{}(*lhs, rhs) : true;
+}
+
+template<class T, class U>
+bool operator==(const T& lhs, const Optional<U>& rhs)
+{
+    return rhs ? lhs == *rhs : false;
+}
+
+template<class T>
+bool operator<(const T& lhs, const Optional<T>& rhs)
+{
+    return rhs ? std::less<T>{}(lhs, *rhs) : false;
+}
+
+template<class T, class F>
+auto operator>>(Optional<T> lhs, F&& rhs) -> decltype(fmap(lhs, std::forward<F>(rhs)))
+{
+    return fmap(lhs, std::forward<F>(rhs));
+}
+
+template<class OS, class T>
+OS& operator<<(OS& os, const Optional<T>& rhs)
+{
+    if (rhs) {
+        os << "some(" << *rhs << ")";
+    }
+    else {
+        os << "none";
+    }
+    return os;
+}
+
+template<class T>
+T unwrap(T&& value)
+{
+    return value;
+}
+
+template<class T>
+T unwrap(util::Optional<T>&& value)
+{
+    return *value;
+}
+
+template<class T>
+T unwrap(const util::Optional<T>& value)
+{
+    return *value;
+}
+
+template<class T>
+T unwrap(util::Optional<T>& value)
+{
+    return *value;
+}
+
+} // namespace util
+
+namespace _impl {
+
+// T is trivially destructible.
+template<class T>
+struct OptionalStorage<T, true> {
+    union {
+        T m_value;
+        char m_null_state;
+    };
+    bool m_engaged = false;
+
+    constexpr OptionalStorage(realm::util::None) : m_null_state() { }
+    constexpr OptionalStorage(T&& value) : m_value(constexpr_move(value)), m_engaged(true) { }
+
+    template<class... Args>
+    constexpr OptionalStorage(Args&&... args): m_value(args...), m_engaged(true) { }
+};
+
+// T is not trivially destructible.
+template<class T>
+struct OptionalStorage<T, false> {
+    union {
+        T m_value;
+        char m_null_state;
+    };
+    bool m_engaged = false;
+
+    constexpr OptionalStorage(realm::util::None) : m_null_state() { }
+    constexpr OptionalStorage(T&& value) : m_value(constexpr_move(value)), m_engaged(true) { }
+
+    template<class... Args>
+    constexpr OptionalStorage(Args&&... args): m_value(args...), m_engaged(true) { }
+
+    ~OptionalStorage()
+    {
+        if (m_engaged)
+            m_value.~T();
+    }
+};
+
+} // namespace _impl
+
+using util::none;
+
+} // namespace realm
+
+#endif // REALM_UTIL_OPTIONAL_HPP
diff --git a/Pods/Realm/include/core/realm/util/priority_queue.hpp b/Pods/Realm/include/core/realm/util/priority_queue.hpp
new file mode 100644
index 0000000..af5e5df
--- /dev/null
+++ b/Pods/Realm/include/core/realm/util/priority_queue.hpp
@@ -0,0 +1,312 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+
+
+#pragma once
+#ifndef REALM_UTIL_PRIORITY_QUEUE_HPP
+#define REALM_UTIL_PRIORITY_QUEUE_HPP
+
+#include <vector>
+#include <functional>
+#include <algorithm>
+
+namespace realm {
+namespace util {
+
+
+/// PriorityQueue corresponds exactly to `std::priority_queue`, but has the extra feature
+/// of allowing iteration and erasure of elements in the queue.
+///
+/// PriorityQueue only allows const access to its elements, because non-const access
+/// would open up the risk of changing the ordering of the elements.
+///
+/// Note: As opposed to `std::priority_queue`, this does not store elements in a heap
+/// internally. Instead, elements are stored in sorted order. Users of this class are
+/// allowed to operate on this assumption.
+template<class T, class Container = std::vector<T>,
+    class Compare = std::less<typename Container::value_type>>
+class PriorityQueue : private Compare {
+public:
+    using container_type  = Container;
+    using value_type      = typename Container::value_type;
+    using size_type       = typename Container::size_type;
+    using reference       = typename Container::reference;
+    using const_reference = typename Container::const_reference;
+    using const_reverse_iterator = typename Container::const_reverse_iterator;
+    using const_iterator         = typename Container::const_iterator;
+
+    //{@
+    /// Construct a PriorityQueue, optionally providing a comparator object.
+    PriorityQueue(const Compare& comparator, const Container& cont);
+
+    explicit PriorityQueue(const Compare& comparator = Compare{}, Container&& cont = Container{});
+
+    template<class InputIt>
+    PriorityQueue(InputIt first, InputIt last, const Compare& comparator, const Container& cont);
+
+    template<class InputIt>
+    PriorityQueue(InputIt first, InputIt last, const Compare& comparator = Compare{},
+                  Container&& cont = Container{});
+    //@}
+    // Skipping Allocator-specific template constructors.
+
+    PriorityQueue(const PriorityQueue&) = default;
+    PriorityQueue(PriorityQueue&&) = default;
+    PriorityQueue& operator=(const PriorityQueue&) = default;
+    PriorityQueue& operator=(PriorityQueue&&) = default;
+
+    bool empty() const;
+    size_type size() const;
+
+    //{@
+    /// Push an element to the priority queue.
+    ///
+    /// If insertion to the underlying `Container` invalidates
+    /// iterators and references, any iterators and references into this
+    /// priority queue are also invalidated. By default, this is the case.
+    void push(const T& value);
+    void push(T&& value);
+    //@}
+
+    /// Pop the largest element from the priority queue.
+    ///
+    /// If `pop_back` on the underlying `Container` invalidates
+    /// iterators and references, any iterators and reference into this
+    /// priority queue are also invalidated. By default, this is *NOT* the case.
+    ///
+    /// Calling `pop()` on an empty priority queue is undefined.
+    void pop();
+
+    /// Return a reference to the largest element of the priority queue.
+    ///
+    /// Calling `top()` on an empty priority queue is undefined.
+    const_reference top() const;
+
+    /// Pop the top of the queue and return it by moving it out of the queue.
+    ///
+    /// Note: This method does not exist in `std::priority_queue`.
+    ///
+    /// Calling `pop_top()` on an empty priorty queue is undefined.
+    value_type pop_top();
+
+    // FIXME: emplace() deliberately omitted for simplicity.
+
+    /// Swap the contents of this priority queue with the contents of \a other.
+    void swap(PriorityQueue& other);
+
+    // Not in std::priority_queue:
+
+    /// Return an iterator to the beginning of the queue (smallest element first).
+    const_iterator begin() const;
+
+    /// Return an iterator to the end of the queue (largest element last);
+    const_iterator end() const;
+
+    /// Return a reverse iterator into the priority queue (largest element first).
+    const_reverse_iterator rbegin() const;
+
+    /// Return a reverse iterator representing the end of the priority queue (smallest element last).
+    const_reverse_iterator rend() const;
+
+    /// Erase element pointed to by \a it.
+    ///
+    /// Note: This function differs from `std::priority_queue` by returning the erased
+    /// element using move semantics.
+    ///
+    /// Calling `erase()` with a beyond-end iterator (such as what is returned by `end()`)
+    /// is undefined.
+    value_type erase(const_iterator it);
+
+    /// Remove all elements from the priority queue.
+    void clear();
+
+    /// Calls `reserve()` on the underlying `Container`.
+    void reserve(size_type);
+
+private:
+    Container m_queue;
+
+    const Compare& compare() const;
+    Compare& compare();
+};
+
+
+/// Implementation
+
+template<class T, class Container, class Compare>
+PriorityQueue<T, Container, Compare>::PriorityQueue(const Compare& comparator, const Container& cont):
+    Compare(comparator), m_queue(cont)
+{
+}
+
+template<class T, class Container, class Compare>
+PriorityQueue<T, Container, Compare>::PriorityQueue(const Compare& comparator, Container&& cont):
+    Compare(comparator), m_queue(std::move(cont))
+{
+}
+
+template<class T, class Container, class Compare>
+template<class InputIt>
+PriorityQueue<T, Container, Compare>::PriorityQueue(InputIt first, InputIt last,
+                                                    const Compare& comparator, const Container& cont):
+    Compare(comparator), m_queue(cont)
+{
+    for (auto it = first; it != last; ++it) {
+        push(*it);
+    }
+}
+
+template<class T, class Container, class Compare>
+template<class InputIt>
+PriorityQueue<T, Container, Compare>::PriorityQueue(InputIt first, InputIt last,
+                                                    const Compare& comparator, Container&& cont):
+    Compare(comparator), m_queue(std::move(cont))
+{
+    for (auto it = first; it != last; ++it) {
+        push(*it);
+    }
+}
+
+template<class T, class Container, class Compare>
+typename PriorityQueue<T, Container, Compare>::size_type
+PriorityQueue<T, Container, Compare>::size() const
+{
+    return m_queue.size();
+}
+
+template<class T, class Container, class Compare>
+bool PriorityQueue<T, Container, Compare>::empty() const
+{
+    return m_queue.empty();
+}
+
+template<class T, class Container, class Compare>
+void PriorityQueue<T, Container, Compare>::push(const T& element)
+{
+    auto it = std::lower_bound(m_queue.begin(), m_queue.end(), element, compare());
+    m_queue.insert(it, element);
+}
+
+template<class T, class Container, class Compare>
+void PriorityQueue<T, Container, Compare>::push(T&& element)
+{
+    auto it = std::lower_bound(m_queue.begin(), m_queue.end(), element, compare());
+    m_queue.insert(it, std::move(element));
+}
+
+template<class T, class Container, class Compare>
+void PriorityQueue<T, Container, Compare>::pop()
+{
+    m_queue.pop_back();
+}
+
+template<class T, class Container, class Compare>
+typename PriorityQueue<T, Container, Compare>::const_reference
+PriorityQueue<T, Container, Compare>::top() const
+{
+    return m_queue.back();
+}
+
+template<class T, class Container, class Compare>
+typename PriorityQueue<T, Container, Compare>::value_type
+PriorityQueue<T, Container, Compare>::pop_top()
+{
+    value_type value = std::move(m_queue.back());
+    m_queue.pop_back();
+    return value;
+}
+
+template<class T, class Container, class Compare>
+Compare& PriorityQueue<T, Container, Compare>::compare()
+{
+    return *this;
+}
+
+template<class T, class Container, class Compare>
+const Compare& PriorityQueue<T, Container, Compare>::compare() const
+{
+    return *this;
+}
+
+template<class T, class Container, class Compare>
+typename PriorityQueue<T, Container, Compare>::const_iterator
+PriorityQueue<T, Container, Compare>::begin() const
+{
+    return m_queue.begin();
+}
+
+template<class T, class Container, class Compare>
+typename PriorityQueue<T, Container, Compare>::const_iterator
+PriorityQueue<T, Container, Compare>::end() const
+{
+    return m_queue.end();
+}
+
+template<class T, class Container, class Compare>
+typename PriorityQueue<T, Container, Compare>::const_reverse_iterator
+PriorityQueue<T, Container, Compare>::rbegin() const
+{
+    return m_queue.rbegin();
+}
+
+template<class T, class Container, class Compare>
+typename PriorityQueue<T, Container, Compare>::const_reverse_iterator
+PriorityQueue<T, Container, Compare>::rend() const
+{
+    return m_queue.rend();
+}
+
+template<class T, class Container, class Compare>
+typename PriorityQueue<T, Container, Compare>::value_type
+PriorityQueue<T, Container, Compare>::erase(const_iterator it)
+{
+    // Convert to non-const iterator:
+    auto non_const_iterator = m_queue.begin() + (it - m_queue.begin());
+    value_type value = std::move(*non_const_iterator);
+    m_queue.erase(non_const_iterator);
+    return value;
+}
+
+template<class T, class Container, class Compare>
+void PriorityQueue<T, Container, Compare>::clear()
+{
+    m_queue.clear();
+}
+
+template<class T, class Container, class Compare>
+void PriorityQueue<T, Container, Compare>::reserve(size_type sz)
+{
+    m_queue.reserve(sz);
+}
+
+template<class T, class Container, class Compare>
+void PriorityQueue<T, Container, Compare>::swap(PriorityQueue& other)
+{
+    using std::swap;
+    swap(m_queue, other.m_queue);
+    swap(compare(), other.compare());
+}
+
+
+}
+}
+
+#endif // REALM_UTIL_PRIORITY_QUEUE_HPP
+
diff --git a/Pods/Realm/include/core/realm/util/safe_int_ops.hpp b/Pods/Realm/include/core/realm/util/safe_int_ops.hpp
new file mode 100644
index 0000000..9a94b0d
--- /dev/null
+++ b/Pods/Realm/include/core/realm/util/safe_int_ops.hpp
@@ -0,0 +1,633 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_UTIL_SAFE_INT_OPS_HPP
+#define REALM_UTIL_SAFE_INT_OPS_HPP
+
+#include <limits>
+
+#include <realm/util/features.h>
+#include <realm/util/assert.hpp>
+#include <realm/util/meta.hpp>
+#include <realm/util/type_traits.hpp>
+
+namespace realm {
+namespace util {
+
+
+/// Perform integral or floating-point promotion on the argument. This
+/// is useful for example when printing a number of arbitrary numeric
+/// type to 'stdout', since it will convert values of character-like
+/// types to regular integer types, which will then be printed as
+/// numbers rather characters.
+template<class T>
+typename Promote<T>::type promote(T value) noexcept;
+
+
+/// This function allows you to test for a negative value in any
+/// numeric type, even when the type is unsigned. Normally, when the
+/// type is unsigned, such a test will produce a compiler warning.
+template<class T>
+bool is_negative(T value) noexcept;
+
+
+/// Cast the specified value to the specified unsigned type reducing
+/// the value (or in case of negative values, the two's complement
+/// representation) modulo `2**N` where `N` is the number of value
+/// bits (or digits) in the unsigned target type. This is usefull in
+/// cases where the target type may be `bool`, but need not be `bool`.
+template<class To, class From>
+To cast_to_unsigned(From) noexcept;
+
+
+//@{
+
+/// Compare two integers of the same, or of different type, and
+/// produce the expected result according to the natural
+/// interpretation of the operation.
+///
+/// Note that in general a standard comparison between a signed and an
+/// unsigned integer type is unsafe, and it often generates a compiler
+/// warning. An example is a 'less than' comparison between a negative
+/// value of type 'int' and a small positive value of type
+/// 'unsigned'. In this case the negative value will be converted to
+/// 'unsigned' producing a large positive value which, in turn, will
+/// lead to the counter intuitive result of 'false'.
+///
+/// Please note that these operation incur absolutely no overhead when
+/// the two types have the same signedness.
+///
+/// These functions check at compile time that both types have valid
+/// specializations of std::numeric_limits<> and that both are indeed
+/// integers.
+///
+/// These functions make absolutely no assumptions about the platform
+/// except that it complies with at least C++03.
+
+template<class A, class B>
+inline bool int_equal_to(A,B) noexcept;
+template<class A, class B>
+inline bool int_not_equal_to(A,B) noexcept;
+template<class A, class B>
+inline bool int_less_than(A,B) noexcept;
+template<class A, class B>
+inline bool int_less_than_or_equal(A,B) noexcept;
+template<class A, class B>
+inline bool int_greater_than(A,B) noexcept;
+template<class A, class B>
+inline bool int_greater_than_or_equal(A,B) noexcept;
+
+//@}
+
+
+//@{
+
+/// Check for overflow in integer variable `lval` while adding integer
+/// `rval` to it, or while subtracting integer `rval` from it. Returns
+/// true on positive or negative overflow.
+///
+/// Both `lval` and `rval` must be of an integer type for which a
+/// specialization of std::numeric_limits<> exists. The two types need
+/// not be the same, in particular, one can be signed and the other
+/// one can be unsigned.
+///
+/// These functions are especially well suited for cases where \a rval
+/// is a compile-time constant.
+///
+/// These functions check at compile time that both types have valid
+/// specializations of std::numeric_limits<> and that both are indeed
+/// integers.
+///
+/// These functions make absolutely no assumptions about the platform
+/// except that it complies with at least C++03.
+
+template<class L, class R>
+inline bool int_add_with_overflow_detect(L& lval, R rval) noexcept;
+
+template<class L, class R>
+inline bool int_subtract_with_overflow_detect(L& lval, R rval) noexcept;
+
+//@}
+
+
+/// Check for positive overflow when multiplying two positive integers
+/// of the same, or of different type. Returns true on overflow.
+///
+/// \param lval Must not be negative. Both signed and unsigned types
+/// can be used.
+///
+/// \param rval Must be stricly greater than zero. Both signed and
+/// unsigned types can be used.
+///
+/// This function is especially well suited for cases where \a rval is
+/// a compile-time constant.
+///
+/// This function checks at compile time that both types have valid
+/// specializations of std::numeric_limits<> and that both are indeed
+/// integers.
+///
+/// This function makes absolutely no assumptions about the platform
+/// except that it complies with at least C++03.
+template<class L, class R>
+inline bool int_multiply_with_overflow_detect(L& lval, R rval) noexcept;
+
+
+/// Checks for positive overflow when performing a bitwise shift to
+/// the left on a non-negative value of arbitrary integer
+/// type. Returns true on overflow.
+///
+/// \param lval Must not be negative. Both signed and unsigned types
+/// can be used.
+///
+/// \param i Must be non-negative and such that <tt>L(1)>>i</tt> has a
+/// value that is defined by the C++03 standard.
+///
+/// This function makes absolutely no assumptions about the platform
+/// except that it complies with at least C++03.
+template<class T>
+inline bool int_shift_left_with_overflow_detect(T& lval, int i) noexcept;
+
+
+//@{
+
+/// Check for overflow when casting an integer value from one type to
+/// another. While the first function is a mere check, the second one
+/// also carries out the cast, but only when there is no
+/// overflow. Both return true on overflow.
+///
+/// These functions check at compile time that both types have valid
+/// specializations of std::numeric_limits<> and that both are indeed
+/// integers.
+///
+/// These functions make absolutely no assumptions about the platform
+/// except that it complies with at least C++03.
+
+template<class To, class From>
+bool int_cast_has_overflow(From from) noexcept;
+
+template<class To, class From>
+bool int_cast_with_overflow_detect(From from, To& to) noexcept;
+
+//@}
+
+
+/// Convert negative values from two's complement representation to the
+/// platforms native representation.
+///
+/// If `To` is an unsigned type, this function does nothing beyond casting the
+/// specified value to `To`. Otherwise, `To` is a signed type, and negative
+/// values will be converted from two's complement representation in unsigned
+/// `From` to the platforms native representation in `To`.
+///
+/// For signed `To` the result is well-defined if, and only if the value with
+/// the specified two's complement representation is representable in the
+/// specified signed type. While this is generally the case when using
+/// corresponding signed/unsigned type pairs, it is not guaranteed by the
+/// standard. However, if you know that the signed type has at least as many
+/// value bits as the unsigned type, then the result is always
+/// well-defined. Note that a 'value bit' in this context is the same as a
+/// 'digit' from the point of view of `std::numeric_limits`.
+///
+/// On platforms that use two's complement representation of negative values,
+/// this function is expected to be completely optimized away. This has been
+/// observed to be true with both GCC 4.8 and Clang 3.2.
+///
+/// Note that the **opposite** direction (from the platforms native
+/// representation to two's complement) is trivially handled by casting the
+/// signed value to a value of a sufficiently wide unsigned integer type. An
+/// unsigned type will be sufficiently wide if it has at least one more value
+/// bit than the signed type.
+///
+/// Interestingly, the C++ language offers no direct way of doing what this
+/// function does, yet, this function is implemented in a way that makes no
+/// assumption about the underlying platform except what is guaranteed by C++11.
+///
+/// \tparam From The unsigned type used to store the two's complement
+/// representation.
+///
+/// \tparam To A signed or unsigned integer type.
+template<class To, class From>
+To from_twos_compl(From twos_compl) noexcept;
+
+
+
+
+
+
+// Implementation:
+
+template<class T>
+inline typename Promote<T>::type promote(T value) noexcept
+{
+    typedef typename Promote<T>::type promoted_type;
+    promoted_type value_2 = promoted_type(value);
+    return value_2;
+}
+
+} // namespace util
+
+namespace _impl {
+
+template<class T, bool is_signed>
+struct IsNegative {
+    static bool test(T value) noexcept
+    {
+        return value < 0;
+    }
+};
+template<class T>
+struct IsNegative<T, false> {
+    static bool test(T) noexcept
+    {
+        return false;
+    }
+};
+
+template<class To>
+struct CastToUnsigned {
+    template<class From>
+    static To cast(From value) noexcept
+    {
+        return To(value);
+    }
+};
+template<>
+struct CastToUnsigned<bool>
+{
+    template<class From>
+    static bool cast(From value) noexcept
+    {
+        return bool(unsigned(value) & 1);
+    }
+};
+
+template<class L, class R, bool l_signed, bool r_signed>
+struct SafeIntBinopsImpl {};
+
+// (unsigned, unsigned) (all size combinations)
+//
+// This implementation utilizes the fact that overflow in unsigned
+// arithmetic is guaranteed to be handled by reduction modulo 2**N
+// where N is the number of bits in the unsigned type. The purpose of
+// the bitwise 'and' with lim_l::max() is to make a cast to bool
+// behave the same way as casts to other unsigned integer types.
+// Finally, this implementation uses the fact that if modular addition
+// overflows, then the result must be a value that is less than both
+// operands. Also, if modular subtraction overflows, then the result
+// must be a value that is greater than the first operand.
+template<class L, class R>
+struct SafeIntBinopsImpl<L, R, false, false> {
+    typedef std::numeric_limits<L> lim_l;
+    typedef std::numeric_limits<R> lim_r;
+    static const int needed_bits_l = lim_l::digits;
+    static const int needed_bits_r = lim_r::digits;
+    static const int needed_bits = needed_bits_l >= needed_bits_r ? needed_bits_l : needed_bits_r;
+    typedef typename util::FastestUnsigned<needed_bits>::type common_unsigned;
+    static bool equal(L l, R r) noexcept
+    {
+        return common_unsigned(l) == common_unsigned(r);
+    }
+    static bool less(L l, R r) noexcept
+    {
+        return common_unsigned(l) < common_unsigned(r);
+    }
+    static bool add(L& lval, R rval) noexcept
+    {
+        L lval_2 = util::cast_to_unsigned<L>(lval + rval);
+        bool overflow = common_unsigned(lval_2) < common_unsigned(rval);
+        if (REALM_UNLIKELY(overflow))
+            return true;
+        lval = lval_2;
+        return false;
+    }
+    static bool sub(L& lval, R rval) noexcept
+    {
+        common_unsigned lval_2 = common_unsigned(lval) - common_unsigned(rval);
+        bool overflow = lval_2 > common_unsigned(lval);
+        if (REALM_UNLIKELY(overflow))
+            return true;
+        lval = util::cast_to_unsigned<L>(lval_2);
+        return false;
+    }
+};
+
+// (unsigned, signed) (all size combinations)
+template<class L, class R>
+struct SafeIntBinopsImpl<L, R, false, true> {
+    typedef std::numeric_limits<L> lim_l;
+    typedef std::numeric_limits<R> lim_r;
+    static const int needed_bits_l = lim_l::digits;
+    static const int needed_bits_r = lim_r::digits + 1;
+    static const int needed_bits = needed_bits_l >= needed_bits_r ? needed_bits_l : needed_bits_r;
+    typedef typename util::FastestUnsigned<needed_bits>::type common_unsigned;
+    typedef std::numeric_limits<common_unsigned> lim_cu;
+    static bool equal(L l, R r) noexcept
+    {
+        return (lim_l::digits > lim_r::digits) ?
+            r >= 0 && l == util::cast_to_unsigned<L>(r) : R(l) == r;
+    }
+    static bool less(L l, R r) noexcept
+    {
+        return (lim_l::digits > lim_r::digits) ?
+            r >= 0 && l < util::cast_to_unsigned<L>(r) : R(l) < r;
+    }
+    static bool add(L& lval, R rval) noexcept
+    {
+        common_unsigned lval_2 = lval + common_unsigned(rval);
+        bool overflow;
+        if (lim_l::digits < lim_cu::digits) {
+            overflow = common_unsigned(lval_2) > common_unsigned(lim_l::max());
+        }
+        else {
+            overflow = (lval_2 < common_unsigned(lval)) == (rval >= 0);
+        }
+        if (REALM_UNLIKELY(overflow))
+            return true;
+        lval = util::cast_to_unsigned<L>(lval_2);
+        return false;
+    }
+    static bool sub(L& lval, R rval) noexcept
+    {
+        common_unsigned lval_2 = lval - common_unsigned(rval);
+        bool overflow;
+        if (lim_l::digits < lim_cu::digits) {
+            overflow = common_unsigned(lval_2) > common_unsigned(lim_l::max());
+        }
+        else {
+            overflow = (common_unsigned(lval_2) > common_unsigned(lval)) == (rval >= 0);
+        }
+        if (REALM_UNLIKELY(overflow))
+            return true;
+        lval = util::cast_to_unsigned<L>(lval_2);
+        return false;
+    }
+};
+
+// (signed, unsigned) (all size combinations)
+template<class L, class R>
+struct SafeIntBinopsImpl<L, R, true, false> {
+    typedef std::numeric_limits<L> lim_l;
+    typedef std::numeric_limits<R> lim_r;
+    static const int needed_bits_l = lim_l::digits + 1;
+    static const int needed_bits_r = lim_r::digits;
+    static const int needed_bits = needed_bits_l >= needed_bits_r ? needed_bits_l : needed_bits_r;
+    typedef typename util::FastestUnsigned<needed_bits>::type common_unsigned;
+    static bool equal(L l, R r) noexcept
+    {
+        return (lim_l::digits < lim_r::digits) ?
+            l >= 0 && util::cast_to_unsigned<R>(l) == r : l == L(r);
+    }
+    static bool less(L l, R r) noexcept
+    {
+        return (lim_l::digits < lim_r::digits) ?
+            l < 0 || util::cast_to_unsigned<R>(l) < r : l < L(r);
+    }
+    static bool add(L& lval, R rval) noexcept
+    {
+        common_unsigned max_add = common_unsigned(lim_l::max()) - common_unsigned(lval);
+        bool overflow = common_unsigned(rval) > max_add;
+        if (REALM_UNLIKELY(overflow))
+            return true;
+        lval = util::from_twos_compl<L>(common_unsigned(lval) + rval);
+        return false;
+    }
+    static bool sub(L& lval, R rval) noexcept
+    {
+        common_unsigned max_sub = common_unsigned(lval) - common_unsigned(lim_l::min());
+        bool overflow = common_unsigned(rval) > max_sub;
+        if (REALM_UNLIKELY(overflow))
+            return true;
+        lval = util::from_twos_compl<L>(common_unsigned(lval) - rval);
+        return false;
+    }
+};
+
+// (signed, signed) (all size combinations)
+template<class L, class R>
+struct SafeIntBinopsImpl<L, R, true, true> {
+    typedef std::numeric_limits<L> lim_l;
+    static bool equal(L l, R r) noexcept
+    {
+        return l == r;
+    }
+    static bool less(L l, R r) noexcept
+    {
+        return l < r;
+    }
+    static bool add(L& lval, R rval) noexcept
+    {
+        // Note that both subtractions below occur in a signed type
+        // that is at least as wide as both of the two types. Note
+        // also that any signed type guarantees that there is no
+        // overflow when subtracting two negative values or two
+        // non-negative value. See C99 (adopted as subset of C++11)
+        // section 6.2.6.2 "Integer types" paragraph 2.
+        if (rval < 0) {
+            if (REALM_UNLIKELY(lval < lim_l::min() - rval))
+                return true;
+        }
+        else {
+            if (REALM_UNLIKELY(lval > lim_l::max() - rval))
+                return true;
+        }
+        // The following statement has exactly the same effect as
+        // `lval += rval`.
+        lval = L(lval + rval);
+        return false;
+    }
+    static bool sub(L& lval, R rval) noexcept
+    {
+        // Note that both subtractions below occur in a signed type
+        // that is at least as wide as both of the two types. Note
+        // also that there can be no overflow when adding a negative
+        // value to a non-negative value, or when adding a
+        // non-negative value to a negative one.
+        if (rval < 0) {
+            if (REALM_UNLIKELY(lval > lim_l::max() + rval))
+                return true;
+        }
+        else {
+            if (REALM_UNLIKELY(lval < lim_l::min() + rval))
+                return true;
+        }
+        // The following statement has exactly the same effect as
+        // `lval += rval`.
+        lval = L(lval - rval);
+        return false;
+    }
+};
+
+template<class L, class R>
+struct SafeIntBinops: SafeIntBinopsImpl<L, R, std::numeric_limits<L>::is_signed,
+                                        std::numeric_limits<R>::is_signed>
+{
+    typedef std::numeric_limits<L> lim_l;
+    typedef std::numeric_limits<R> lim_r;
+    static_assert(lim_l::is_specialized && lim_r::is_specialized,
+                  "std::numeric_limits<> must be specialized for both types");
+    static_assert(lim_l::is_integer && lim_r::is_integer,
+                  "Both types must be integers");
+};
+
+} // namespace _impl
+
+namespace util {
+
+template<class T>
+inline bool is_negative(T value) noexcept
+{
+    return _impl::IsNegative<T, std::numeric_limits<T>::is_signed>::test(value);
+}
+
+template<class To, class From>
+inline To cast_to_unsigned(From value) noexcept
+{
+    return _impl::CastToUnsigned<To>::cast(value);
+}
+
+template<class A, class B>
+inline bool int_equal_to(A a, B b) noexcept
+{
+    return _impl::SafeIntBinops<A,B>::equal(a,b);
+}
+
+template<class A, class B>
+inline bool int_not_equal_to(A a, B b) noexcept
+{
+    return !_impl::SafeIntBinops<A,B>::equal(a,b);
+}
+
+template<class A, class B>
+inline bool int_less_than(A a, B b) noexcept
+{
+    return _impl::SafeIntBinops<A,B>::less(a,b);
+}
+
+template<class A, class B>
+inline bool int_less_than_or_equal(A a, B b) noexcept
+{
+    return !_impl::SafeIntBinops<B,A>::less(b,a); // Not greater than
+}
+
+template<class A, class B>
+inline bool int_greater_than(A a, B b) noexcept
+{
+    return _impl::SafeIntBinops<B,A>::less(b,a);
+}
+
+template<class A, class B>
+inline bool int_greater_than_or_equal(A a, B b) noexcept
+{
+    return !_impl::SafeIntBinops<A,B>::less(a,b); // Not less than
+}
+
+template<class L, class R>
+inline bool int_add_with_overflow_detect(L& lval, R rval) noexcept
+{
+    return _impl::SafeIntBinops<L,R>::add(lval, rval);
+}
+
+template<class L, class R>
+inline bool int_subtract_with_overflow_detect(L& lval, R rval) noexcept
+{
+    return _impl::SafeIntBinops<L,R>::sub(lval, rval);
+}
+
+template<class L, class R>
+inline bool int_multiply_with_overflow_detect(L& lval, R rval) noexcept
+{
+    // FIXME: Check if the following optimizes better (if it works at all):
+    // L lval_2 = L(lval * rval);
+    // bool overflow  =  rval != 0  &&  (lval_2 / rval) != lval;
+    typedef std::numeric_limits<L> lim_l;
+    typedef std::numeric_limits<R> lim_r;
+    static_assert(lim_l::is_specialized && lim_r::is_specialized,
+                  "std::numeric_limits<> must be specialized for both types");
+    static_assert(lim_l::is_integer && lim_r::is_integer,
+                  "Both types must be integers");
+    REALM_ASSERT(int_greater_than_or_equal(lval, 0));
+    REALM_ASSERT(int_greater_than(rval, 0));
+    if (int_less_than(lim_r::max() / rval, lval))
+        return true;
+    lval = L(lval * rval);
+    return false;
+}
+
+template<class T>
+inline bool int_shift_left_with_overflow_detect(T& lval, int i) noexcept
+{
+    typedef std::numeric_limits<T> lim;
+    static_assert(lim::is_specialized,
+                  "std::numeric_limits<> must be specialized for T");
+    static_assert(lim::is_integer,
+                  "T must be an integer type");
+    REALM_ASSERT(int_greater_than_or_equal(lval, 0));
+    if ((lim::max() >> i) < lval)
+        return true;
+    lval <<= i;
+    return false;
+}
+
+template<class To, class From>
+inline bool int_cast_has_overflow(From from) noexcept
+{
+    typedef std::numeric_limits<To> lim_to;
+    return int_less_than(from, lim_to::min()) || int_less_than(lim_to::max(), from);
+}
+
+template<class To, class From>
+inline bool int_cast_with_overflow_detect(From from, To& to) noexcept
+{
+    if (REALM_LIKELY(!int_cast_has_overflow<To>(from))) {
+        to = To(from);
+        return false;
+    }
+    return true;
+}
+
+template<class To, class From>
+inline To from_twos_compl(From twos_compl) noexcept
+{
+    typedef std::numeric_limits<From> lim_f;
+    typedef std::numeric_limits<To>   lim_t;
+    static_assert(lim_f::is_specialized && lim_t::is_specialized,
+                  "std::numeric_limits<> must be specialized for both types");
+    static_assert(lim_f::is_integer && lim_t::is_integer,
+                  "Both types must be integers");
+    static_assert(!lim_f::is_signed, "`From` must be unsigned");
+    To native;
+    int sign_bit_pos = lim_f::digits - 1;
+    From sign_bit = From(1) << sign_bit_pos;
+    bool non_negative = !lim_t::is_signed || (twos_compl & sign_bit) == 0;
+    if (non_negative) {
+        // Non-negative value
+        native = To(twos_compl);
+    }
+    else {
+        // Negative value
+        native = To(-1 - To(From(-1) - twos_compl));
+    }
+    return native;
+}
+
+
+} // namespace util
+} // namespace realm
+
+#endif // REALM_UTIL_SAFE_INT_OPS_HPP
diff --git a/Pods/Realm/include/core/realm/util/scope_exit.hpp b/Pods/Realm/include/core/realm/util/scope_exit.hpp
new file mode 100644
index 0000000..d17359c
--- /dev/null
+++ b/Pods/Realm/include/core/realm/util/scope_exit.hpp
@@ -0,0 +1,73 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_UTIL_SCOPE_EXIT_HPP
+#define REALM_UTIL_SCOPE_EXIT_HPP
+
+#include <type_traits>
+#include <utility>
+
+#include <realm/util/optional.hpp>
+
+namespace realm {
+namespace util {
+
+template<class H>
+class ScopeExit {
+public:
+    explicit ScopeExit(const H& handler) noexcept(std::is_nothrow_copy_constructible<H>::value):
+        m_handler(handler)
+    {
+    }
+
+    explicit ScopeExit(H&& handler) noexcept(std::is_nothrow_move_constructible<H>::value):
+        m_handler(std::move(handler))
+    {
+    }
+
+    ScopeExit(ScopeExit&& se) noexcept(std::is_nothrow_move_constructible<H>::value):
+        m_handler(std::move(se.m_handler))
+    {
+        se.m_handler = none;
+    }
+
+    ~ScopeExit() noexcept
+    {
+        if (m_handler)
+            (*m_handler)();
+    }
+
+    static_assert(noexcept(std::declval<H>()()), "Handler must be nothrow executable");
+    static_assert(std::is_nothrow_destructible<H>::value, "Handler must be nothrow destructible");
+
+private:
+    util::Optional<H> m_handler;
+};
+
+template<class H>
+ScopeExit<typename std::remove_reference<H>::type> make_scope_exit(H&& handler)
+    noexcept(noexcept(ScopeExit<typename std::remove_reference<H>::type>(std::forward<H>(handler))))
+{
+    return ScopeExit<typename std::remove_reference<H>::type>(std::forward<H>(handler));
+}
+
+} // namespace util
+} // namespace realm
+
+#endif // REALM_UTIL_SCOPE_EXIT_HPP
diff --git a/Pods/Realm/include/core/realm/util/shared_ptr.hpp b/Pods/Realm/include/core/realm/util/shared_ptr.hpp
new file mode 100644
index 0000000..88faa15
--- /dev/null
+++ b/Pods/Realm/include/core/realm/util/shared_ptr.hpp
@@ -0,0 +1,111 @@
+#ifndef REALM_SHARED_PTR_HPP
+#define REALM_SHARED_PTR_HPP
+
+#include <cstdlib> // size_t
+
+namespace realm {
+namespace util {
+
+template<class T>
+class SharedPtr
+{
+public:
+    SharedPtr(T* p)
+    {
+        init(p);
+    }
+
+    SharedPtr()
+    {
+        init(0);
+    }
+
+    ~SharedPtr()
+    {
+        decref();
+    }
+
+    SharedPtr(const SharedPtr<T>& o) : m_ptr(o.m_ptr), m_count(o.m_count)
+    {
+        incref();
+    }
+
+    SharedPtr<T>& operator=(const SharedPtr<T>& o) {
+        if (m_ptr == o.m_ptr)
+            return *this;
+        decref();
+        m_ptr = o.m_ptr;
+        m_count = o.m_count;
+        incref();
+        return *this;
+    }
+
+    T* operator->() const
+    {
+        return m_ptr;
+    }
+
+    T& operator*() const
+    {
+        return *m_ptr;
+    }
+
+    T* get() const
+    {
+        return m_ptr;
+    }
+
+    bool operator==(const SharedPtr<T>& o) const
+    {
+        return m_ptr == o.m_ptr;
+    }
+
+    bool operator!=(const SharedPtr<T>& o) const
+    {
+        return m_ptr != o.m_ptr;
+    }
+
+    bool operator<(const SharedPtr<T>& o) const
+    {
+        return m_ptr < o.m_ptr;
+    }
+
+    size_t ref_count() const
+    {
+        return *m_count;
+    }
+
+private:
+    void init(T* p)
+    {
+        m_ptr = p;
+        try {
+            m_count = new size_t(1);
+        }
+        catch (...) {
+            delete p;
+            throw;
+        }
+    }
+
+    void decref()
+    {
+        if (--(*m_count) == 0) {
+            delete m_ptr;
+            delete m_count;
+        }
+    }
+
+    void incref()
+    {
+        ++(*m_count);
+    }
+
+    T* m_ptr;
+    size_t* m_count;
+};
+
+}
+}
+
+#endif
diff --git a/Pods/Realm/include/core/realm/util/string_buffer.hpp b/Pods/Realm/include/core/realm/util/string_buffer.hpp
new file mode 100644
index 0000000..4741a4f
--- /dev/null
+++ b/Pods/Realm/include/core/realm/util/string_buffer.hpp
@@ -0,0 +1,187 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_UTIL_STRING_BUFFER_HPP
+#define REALM_UTIL_STRING_BUFFER_HPP
+
+#include <cstddef>
+#include <cstring>
+#include <string>
+
+#include <realm/util/features.h>
+#include <realm/util/buffer.hpp>
+
+namespace realm {
+namespace util {
+
+
+// FIXME: Check whether this class provides anything that a C++03
+// std::string does not already provide. In particular, can a C++03
+// std::string be used as a contiguous mutable buffer?
+class StringBuffer {
+public:
+    StringBuffer() noexcept;
+    ~StringBuffer() noexcept {}
+
+    std::string str() const;
+
+    /// Returns the current size of the string in this buffer. This
+    /// size does not include the terminating zero.
+    size_t size() const noexcept;
+
+    /// Gives read and write access to the bytes of this buffer. The
+    /// caller may read and write from *c_str() up to, but not
+    /// including, *(c_str()+size()).
+    char* data() noexcept;
+
+    /// Gives read access to the bytes of this buffer. The caller may
+    /// read from *c_str() up to, but not including,
+    /// *(c_str()+size()).
+    const char* data() const noexcept;
+
+    /// Guarantees that the returned string is zero terminated, that
+    /// is, *(c_str()+size()) is zero. The caller may read from
+    /// *c_str() up to and including *(c_str()+size()), the caller may
+    /// write from *c_str() up to, but not including,
+    /// *(c_str()+size()).
+    char* c_str() noexcept;
+
+    /// Guarantees that the returned string is zero terminated, that
+    /// is, *(c_str()+size()) is zero. The caller may read from
+    /// *c_str() up to and including *(c_str()+size()).
+    const char* c_str() const noexcept;
+
+    void append(const std::string&);
+
+    void append(const char* append_data, size_t append_size);
+
+    /// Append a zero-terminated string to this buffer.
+    void append_c_str(const char* c_string);
+
+    /// The specified size is understood as not including the
+    /// terminating zero. If the specified size is less than the
+    /// current size, then the string is truncated accordingly. If the
+    /// specified size is greater than the current size, then the
+    /// extra characters will have undefined values, however, there
+    /// will be a terminating zero at *(c_str()+size()), and the
+    /// original terminating zero will also be left in place such that
+    /// from the point of view of c_str(), the size of the string is
+    /// unchanged.
+    void resize(size_t new_size);
+
+    /// The specified minimum capacity is understood as not including
+    /// the terminating zero. This operation does not change the size
+    /// of the string in the buffer as returned by size(). If the
+    /// specified capacity is less than the current capacity, this
+    /// operation has no effect.
+    void reserve(size_t min_capacity);
+
+    /// Set size to zero. The capacity remains unchanged.
+    void clear() noexcept;
+
+private:
+    util::Buffer<char> m_buffer;
+    size_t m_size; // Excluding the terminating zero
+    static char m_zero;
+
+    void reallocate(size_t min_capacity);
+};
+
+
+
+
+
+// Implementation:
+
+inline StringBuffer::StringBuffer() noexcept: m_size(0)
+{
+}
+
+inline std::string StringBuffer::str() const
+{
+    return std::string(m_buffer.data(), m_size);
+}
+
+inline size_t StringBuffer::size() const noexcept
+{
+    return m_size;
+}
+
+inline char* StringBuffer::data() noexcept
+{
+    return m_buffer.data();
+}
+
+inline const char* StringBuffer::data() const noexcept
+{
+    return m_buffer.data();
+}
+
+inline char* StringBuffer::c_str() noexcept
+{
+    char* d = data();
+    return d ? d : &m_zero;
+}
+
+inline const char* StringBuffer::c_str() const noexcept
+{
+    const char* d = data();
+    return d ? d : &m_zero;
+}
+
+inline void StringBuffer::append(const std::string& s)
+{
+    return append(s.data(), s.size());
+}
+
+inline void StringBuffer::append_c_str(const char* c_string)
+{
+    append(c_string, std::strlen(c_string));
+}
+
+inline void StringBuffer::reserve(size_t min_capacity)
+{
+    size_t capacity = m_buffer.size();
+    if (capacity == 0 || capacity-1 < min_capacity)
+        reallocate(min_capacity);
+}
+
+inline void StringBuffer::resize(size_t new_size)
+{
+    reserve(new_size);
+    // Note that even reserve(0) will attempt to allocate a
+    // buffer, so we can safely write the truncating zero at this
+    // time.
+    m_size = new_size;
+    m_buffer[new_size] = 0;
+}
+
+inline void StringBuffer::clear() noexcept
+{
+    if (m_buffer.size() == 0)
+        return;
+    m_size = 0;
+    m_buffer[0] = 0;
+}
+
+
+} // namespace util
+} // namespace realm
+
+#endif // REALM_UTIL_STRING_BUFFER_HPP
diff --git a/Pods/Realm/include/core/realm/util/terminate.hpp b/Pods/Realm/include/core/realm/util/terminate.hpp
new file mode 100644
index 0000000..fe6356d
--- /dev/null
+++ b/Pods/Realm/include/core/realm/util/terminate.hpp
@@ -0,0 +1,73 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_UTIL_TERMINATE_HPP
+#define REALM_UTIL_TERMINATE_HPP
+
+#include <cstdlib>
+
+#include <realm/util/features.h>
+#include <realm/util/to_string.hpp>
+#include <realm/version.hpp>
+
+#define REALM_TERMINATE(msg) realm::util::terminate((msg), __FILE__, __LINE__)
+
+namespace realm {
+namespace util {
+/// Install a custom termination notification callback. This will only be called as a result of
+/// Realm crashing internally, i.e. a failed assertion or an otherwise irrecoverable error
+/// condition. The termination notification callback is supplied with a zero-terminated string
+/// containing information relevant for debugging the issue leading to the crash.
+///
+/// The termination notification callback is shared by all threads, which is another way of saying
+/// that it must be reentrant, in case multiple threads crash simultaneously.
+///
+/// Furthermore, the provided callback must be `noexcept`, indicating that if an exception
+/// is thrown in the callback, the process is terminated with a call to `std::terminate`.
+void set_termination_notification_callback(void(*callback)(const char* message) noexcept) noexcept;
+
+REALM_NORETURN void terminate(const char* message, const char* file, long line,
+                              std::initializer_list<Printable>&&={}) noexcept;
+REALM_NORETURN void terminate_with_info(const char* message, const char* file, long line,
+                                        const char* interesting_names,
+                                        std::initializer_list<Printable>&&={}) noexcept;
+
+// LCOV_EXCL_START
+template<class... Ts>
+REALM_NORETURN void terminate(const char* message, const char* file, long line, Ts... infos) noexcept
+{
+    static_assert(sizeof...(infos) == 2 || sizeof...(infos) == 4 || sizeof...(infos) == 6,
+                  "Called realm::util::terminate() with wrong number of arguments");
+    terminate(message, file, line, {Printable(infos)...});
+}
+
+template<class... Args>
+REALM_NORETURN void terminate_with_info(const char* assert_message, int line, const char* file,
+                                        const char* interesting_names,
+                                        Args&&... interesting_values) noexcept
+{
+    terminate_with_info(assert_message, file, line, interesting_names, {Printable(interesting_values)...});
+
+}
+// LCOV_EXCL_STOP
+
+} // namespace util
+} // namespace realm
+
+#endif // REALM_UTIL_TERMINATE_HPP
diff --git a/Pods/Realm/include/core/realm/util/thread.hpp b/Pods/Realm/include/core/realm/util/thread.hpp
new file mode 100644
index 0000000..f91b9eb
--- /dev/null
+++ b/Pods/Realm/include/core/realm/util/thread.hpp
@@ -0,0 +1,589 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_UTIL_THREAD_HPP
+#define REALM_UTIL_THREAD_HPP
+
+#include <exception>
+
+#include <pthread.h>
+
+// Use below line to enable a thread bug detection tool. Note: Will make program execution slower.
+// #include <../test/pthread_test.hpp>
+
+#include <cerrno>
+#include <cstddef>
+#include <string>
+
+#include <realm/util/features.h>
+#include <realm/util/assert.hpp>
+#include <realm/util/terminate.hpp>
+#include <memory>
+#include <realm/util/meta.hpp>
+
+#include <atomic>
+
+namespace realm {
+namespace util {
+
+
+/// A separate thread of execution.
+///
+/// This class is a C++03 compatible reproduction of a subset of
+/// std::thread from C++11 (when discounting Thread::start()).
+class Thread {
+public:
+    Thread();
+    ~Thread() noexcept;
+
+    template<class F>
+    explicit Thread(F func);
+
+    /// This method is an extension of the API provided by
+    /// std::thread. This method exists because proper move semantics
+    /// is unavailable in C++03. If move semantics had been available,
+    /// calling `start(func)` would have been equivalent to `*this =
+    /// Thread(func)`. Please see std::thread::operator=() for
+    /// details.
+    template<class F>
+    void start(F func);
+
+    bool joinable() noexcept;
+
+    void join();
+
+private:
+    pthread_t m_id;
+    bool m_joinable;
+
+    typedef void* (*entry_func_type)(void*);
+
+    void start(entry_func_type, void* arg);
+
+    template<class>
+    static void* entry_point(void*) noexcept;
+
+    REALM_NORETURN static void create_failed(int);
+    REALM_NORETURN static void join_failed(int);
+};
+
+
+/// Low-level mutual exclusion device.
+class Mutex {
+public:
+    Mutex();
+    ~Mutex() noexcept;
+
+    struct process_shared_tag {};
+
+    /// Initialize this mutex for use across multiple processes. When
+    /// constructed this way, the instance may be placed in memory
+    /// shared by multiple processes, as well as in a memory mapped
+    /// file. Such a mutex remains valid even after the constructing
+    /// process terminates. Deleting the instance (freeing the memory
+    /// or deleting the file) without first calling the destructor is
+    /// legal and will not cause any system resources to be leaked.
+    Mutex(process_shared_tag);
+
+    friend class LockGuard;
+    friend class UniqueLock;
+
+    void lock() noexcept;
+    void unlock() noexcept;
+
+protected:
+    pthread_mutex_t m_impl;
+
+    struct no_init_tag {};
+    Mutex(no_init_tag) {}
+
+    void init_as_regular();
+    void init_as_process_shared(bool robust_if_available);
+
+    REALM_NORETURN static void init_failed(int);
+    REALM_NORETURN static void attr_init_failed(int);
+    REALM_NORETURN static void destroy_failed(int) noexcept;
+    REALM_NORETURN static void lock_failed(int) noexcept;
+
+    friend class CondVar;
+};
+
+
+/// A simple mutex ownership wrapper.
+class LockGuard {
+public:
+    LockGuard(Mutex&) noexcept;
+    ~LockGuard() noexcept;
+
+private:
+    Mutex& m_mutex;
+    friend class CondVar;
+};
+
+
+/// See UniqueLock.
+struct defer_lock_tag {};
+
+/// A general-purpose mutex ownership wrapper supporting deferred
+/// locking as well as repeated unlocking and relocking.
+class UniqueLock {
+public:
+    UniqueLock(Mutex&) noexcept;
+    UniqueLock(Mutex&, defer_lock_tag) noexcept;
+    ~UniqueLock() noexcept;
+
+    void lock() noexcept;
+    void unlock() noexcept;
+    bool holds_lock() noexcept;
+private:
+    Mutex* m_mutex;
+    bool m_is_locked;
+};
+
+
+/// A robust version of a process-shared mutex.
+///
+/// A robust mutex is one that detects whether a thread (or process)
+/// has died while holding a lock on the mutex.
+///
+/// When the present platform does not offer support for robust
+/// mutexes, this mutex class behaves as a regular process-shared
+/// mutex, which means that if a thread dies while holding a lock, any
+/// future attempt at locking will block indefinitely.
+class RobustMutex: private Mutex {
+public:
+    RobustMutex();
+    ~RobustMutex() noexcept;
+
+    static bool is_robust_on_this_platform() noexcept;
+
+    class NotRecoverable;
+
+    /// \param recover_func If the present platform does not support
+    /// robust mutexes, this function is never called. Otherwise it is
+    /// called if, and only if a thread has died while holding a
+    /// lock. The purpose of the function is to reestablish a
+    /// consistent shared state. If it fails to do this by throwing an
+    /// exception, the mutex enters the 'unrecoverable' state where
+    /// any future attempt at locking it will fail and cause
+    /// NotRecoverable to be thrown. This function is advised to throw
+    /// NotRecoverable when it fails, but it may throw any exception.
+    ///
+    /// \throw NotRecoverable If thrown by the specified recover
+    /// function, or if the mutex has entered the 'unrecoverable'
+    /// state due to a different thread throwing from its recover
+    /// function.
+    template<class Func>
+    void lock(Func recover_func);
+
+    void unlock() noexcept;
+
+    /// Low-level locking of robust mutex.
+    ///
+    /// If the present platform does not support robust mutexes, this
+    /// function always returns true. Otherwise it returns false if,
+    /// and only if a thread has died while holding a lock.
+    ///
+    /// \note Most application should never call this function
+    /// directly. It is called automatically when using the ordinary
+    /// lock() function.
+    ///
+    /// \throw NotRecoverable If this mutex has entered the "not
+    /// recoverable" state. It enters this state if
+    /// mark_as_consistent() is not called between a call to
+    /// robust_lock() that returns false and the corresponding call to
+    /// unlock().
+    bool low_level_lock();
+
+    /// Pull this mutex out of the 'inconsistent' state.
+    ///
+    /// Must be called only after low_level_lock() has returned false.
+    ///
+    /// \note Most application should never call this function
+    /// directly. It is called automatically when using the ordinary
+    /// lock() function.
+    void mark_as_consistent() noexcept;
+
+    /// Attempt to check if this mutex is a valid object.
+    ///
+    /// This attempts to trylock() the mutex, and if that fails returns false if
+    /// the return value indicates that the low-level mutex is invalid (which is
+    /// distinct from 'inconsistent'). Although pthread_mutex_trylock() may
+    /// return EINVAL if the argument is not an initialized mutex object, merely
+    /// attempting to check if an arbitrary blob of memory is a mutex object may
+    /// involve undefined behavior, so it is only safe to assume that this
+    /// function will run correctly when it is known that the mutex object is
+    /// valid.
+    bool is_valid() noexcept;
+
+    friend class CondVar;
+};
+
+class RobustMutex::NotRecoverable: public std::exception {
+public:
+    const char* what() const noexcept override
+    {
+        return "Failed to recover consistent state of shared memory";
+    }
+};
+
+
+/// A simple robust mutex ownership wrapper.
+class RobustLockGuard {
+public:
+    /// \param recover_func See RobustMutex::lock().
+    template<class TFunc>
+    RobustLockGuard(RobustMutex&, TFunc func);
+    ~RobustLockGuard() noexcept;
+
+private:
+    RobustMutex& m_mutex;
+    friend class CondVar;
+};
+
+
+
+
+/// Condition variable for use in synchronization monitors.
+class CondVar {
+public:
+    CondVar();
+    ~CondVar() noexcept;
+
+    struct process_shared_tag {};
+
+    /// Initialize this condition variable for use across multiple
+    /// processes. When constructed this way, the instance may be
+    /// placed in memory shared by multimple processes, as well as in
+    /// a memory mapped file. Such a condition variable remains valid
+    /// even after the constructing process terminates. Deleting the
+    /// instance (freeing the memory or deleting the file) without
+    /// first calling the destructor is legal and will not cause any
+    /// system resources to be leaked.
+    CondVar(process_shared_tag);
+
+    /// Wait for another thread to call notify() or notify_all().
+    void wait(LockGuard& l) noexcept;
+    template<class Func>
+    void wait(RobustMutex& m, Func recover_func, const struct timespec* tp = nullptr);
+
+    /// If any threads are wating for this condition, wake up at least
+    /// one.
+    void notify() noexcept;
+
+    /// Wake up every thread that is currently wating on this
+    /// condition.
+    void notify_all() noexcept;
+
+private:
+    pthread_cond_t m_impl;
+
+    REALM_NORETURN static void init_failed(int);
+    REALM_NORETURN static void attr_init_failed(int);
+    REALM_NORETURN static void destroy_failed(int) noexcept;
+    void handle_wait_error(int error);
+};
+
+
+
+
+
+
+
+
+// Implementation:
+
+inline Thread::Thread(): m_joinable(false)
+{
+}
+
+template<class F>
+inline Thread::Thread(F func): m_joinable(true)
+{
+    std::unique_ptr<F> func2(new F(func)); // Throws
+    start(&Thread::entry_point<F>, func2.get()); // Throws
+    func2.release();
+}
+
+template<class F>
+inline void Thread::start(F func)
+{
+    if (m_joinable)
+        std::terminate();
+    std::unique_ptr<F> func2(new F(func)); // Throws
+    start(&Thread::entry_point<F>, func2.get()); // Throws
+    func2.release();
+    m_joinable = true;
+}
+
+inline Thread::~Thread() noexcept
+{
+    if (m_joinable)
+        REALM_TERMINATE("Destruction of joinable thread");
+}
+
+inline bool Thread::joinable() noexcept
+{
+    return m_joinable;
+}
+
+inline void Thread::start(entry_func_type entry_func, void* arg)
+{
+    const pthread_attr_t* attr = nullptr; // Use default thread attributes
+    int r = pthread_create(&m_id, attr, entry_func, arg);
+    if (REALM_UNLIKELY(r != 0))
+        create_failed(r); // Throws
+}
+
+template<class F>
+inline void* Thread::entry_point(void* cookie) noexcept
+{
+    std::unique_ptr<F> func(static_cast<F*>(cookie));
+    try {
+        (*func)();
+    }
+    catch (...) {
+        std::terminate();
+    }
+    return 0;
+}
+
+
+inline Mutex::Mutex()
+{
+    init_as_regular();
+}
+
+inline Mutex::Mutex(process_shared_tag)
+{
+    bool robust_if_available = false;
+    init_as_process_shared(robust_if_available);
+}
+
+inline Mutex::~Mutex() noexcept
+{
+    int r = pthread_mutex_destroy(&m_impl);
+    if (REALM_UNLIKELY(r != 0))
+        destroy_failed(r);
+}
+
+inline void Mutex::init_as_regular()
+{
+    int r = pthread_mutex_init(&m_impl, 0);
+    if (REALM_UNLIKELY(r != 0))
+        init_failed(r);
+}
+
+inline void Mutex::lock() noexcept
+{
+    int r = pthread_mutex_lock(&m_impl);
+    if (REALM_LIKELY(r == 0))
+        return;
+    lock_failed(r);
+}
+
+inline void Mutex::unlock() noexcept
+{
+    int r = pthread_mutex_unlock(&m_impl);
+    REALM_ASSERT(r == 0);
+}
+
+
+inline LockGuard::LockGuard(Mutex& m) noexcept:
+    m_mutex(m)
+{
+    m_mutex.lock();
+}
+
+inline LockGuard::~LockGuard() noexcept
+{
+    m_mutex.unlock();
+}
+
+
+inline UniqueLock::UniqueLock(Mutex& m) noexcept:
+    m_mutex(&m)
+{
+    m_mutex->lock();
+    m_is_locked = true;
+}
+
+inline UniqueLock::UniqueLock(Mutex& m, defer_lock_tag) noexcept:
+    m_mutex(&m)
+{
+    m_is_locked = false;
+}
+
+inline UniqueLock::~UniqueLock() noexcept
+{
+    if (m_is_locked)
+        m_mutex->unlock();
+}
+
+inline bool UniqueLock::holds_lock() noexcept
+{
+    return m_is_locked;
+}
+
+inline void UniqueLock::lock() noexcept
+{
+    m_mutex->lock();
+    m_is_locked = true;
+}
+
+inline void UniqueLock::unlock() noexcept
+{
+    m_mutex->unlock();
+    m_is_locked = false;
+}
+
+template<typename TFunc>
+inline RobustLockGuard::RobustLockGuard(RobustMutex& m, TFunc func) :
+    m_mutex(m)
+{
+    m_mutex.lock(func);
+}
+
+inline RobustLockGuard::~RobustLockGuard() noexcept
+{
+    m_mutex.unlock();
+}
+
+
+
+inline RobustMutex::RobustMutex():
+    Mutex(no_init_tag())
+{
+    bool robust_if_available = true;
+    init_as_process_shared(robust_if_available);
+}
+
+inline RobustMutex::~RobustMutex() noexcept
+{
+}
+
+template<class Func>
+inline void RobustMutex::lock(Func recover_func)
+{
+    bool no_thread_has_died = low_level_lock(); // Throws
+    if (REALM_LIKELY(no_thread_has_died))
+        return;
+    try {
+        recover_func(); // Throws
+        mark_as_consistent();
+        // If we get this far, the protected memory has been
+        // brought back into a consistent state, and the mutex has
+        // been notified aboit this. This means that we can safely
+        // enter the applications critical section.
+    }
+    catch (...) {
+        // Unlocking without first calling mark_as_consistent()
+        // means that the mutex enters the "not recoverable"
+        // state, which will cause all future attempts at locking
+        // to fail.
+        unlock();
+        throw;
+    }
+}
+
+inline void RobustMutex::unlock() noexcept
+{
+    Mutex::unlock();
+}
+
+
+
+
+
+inline CondVar::CondVar()
+{
+    int r = pthread_cond_init(&m_impl, 0);
+    if (REALM_UNLIKELY(r != 0))
+        init_failed(r);
+}
+
+inline CondVar::~CondVar() noexcept
+{
+    int r = pthread_cond_destroy(&m_impl);
+    if (REALM_UNLIKELY(r != 0))
+        destroy_failed(r);
+}
+
+inline void CondVar::wait(LockGuard& l) noexcept
+{
+    int r = pthread_cond_wait(&m_impl, &l.m_mutex.m_impl);
+    if (REALM_UNLIKELY(r != 0))
+        REALM_TERMINATE("pthread_cond_wait() failed");
+}
+
+template<class Func>
+inline void CondVar::wait(RobustMutex& m, Func recover_func, const struct timespec* tp)
+{
+    int r;
+
+    if (!tp) {
+        r = pthread_cond_wait(&m_impl, &m.m_impl);
+    }
+    else {
+        r = pthread_cond_timedwait(&m_impl, &m.m_impl, tp);
+        if (r == ETIMEDOUT)
+            return;
+    }
+
+    if (REALM_LIKELY(r == 0))
+        return;
+
+    handle_wait_error(r);
+
+    try {
+        recover_func(); // Throws
+        m.mark_as_consistent();
+        // If we get this far, the protected memory has been
+        // brought back into a consistent state, and the mutex has
+        // been notified aboit this. This means that we can safely
+        // enter the applications critical section.
+    }
+    catch (...) {
+        // Unlocking without first calling mark_as_consistent()
+        // means that the mutex enters the "not recoverable"
+        // state, which will cause all future attempts at locking
+        // to fail.
+        m.unlock();
+        throw;
+    }
+}
+
+inline void CondVar::notify() noexcept
+{
+    int r = pthread_cond_signal(&m_impl);
+    REALM_ASSERT(r == 0);
+}
+
+inline void CondVar::notify_all() noexcept
+{
+    int r = pthread_cond_broadcast(&m_impl);
+    REALM_ASSERT(r == 0);
+}
+
+
+
+} // namespace util
+} // namespace realm
+
+#endif // REALM_UTIL_THREAD_HPP
diff --git a/Pods/Realm/include/core/realm/util/to_string.hpp b/Pods/Realm/include/core/realm/util/to_string.hpp
new file mode 100644
index 0000000..5548803
--- /dev/null
+++ b/Pods/Realm/include/core/realm/util/to_string.hpp
@@ -0,0 +1,72 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2016] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_UTIL_TO_STRING_HPP
+#define REALM_UTIL_TO_STRING_HPP
+
+#include <iosfwd>
+#include <string>
+
+namespace realm {
+namespace util {
+
+class Printable {
+public:
+    Printable(bool value) : m_type(Type::Bool), m_uint(value) { }
+    Printable(unsigned char value) : m_type(Type::Uint), m_uint(value) { }
+    Printable(unsigned int value) : m_type(Type::Uint), m_uint(value) { }
+    Printable(unsigned long value) : m_type(Type::Uint), m_uint(value) { }
+    Printable(unsigned long long value) : m_type(Type::Uint), m_uint(value) { }
+    Printable(char value) : m_type(Type::Int), m_int(value) { }
+    Printable(int value) : m_type(Type::Int), m_int(value) { }
+    Printable(long value) : m_type(Type::Int), m_int(value) { }
+    Printable(long long value) : m_type(Type::Int), m_int(value) { }
+    Printable(const char* value) : m_type(Type::String), m_string(value) { }
+
+    void print(std::ostream& out, bool quote) const;
+    std::string str() const;
+
+    static void print_all(std::ostream& out, const std::initializer_list<Printable>& values, bool quote);
+
+private:
+    enum class Type {
+        Bool,
+        Int,
+        Uint,
+        String
+    } m_type;
+
+    union {
+        uintmax_t m_uint;
+        intmax_t m_int;
+        const char* m_string;
+    };
+};
+
+
+template<class T>
+std::string to_string(const T& v)
+{
+    return Printable(v).str();
+}
+
+} // namespace util
+} // namespace realm
+
+#endif // REALM_UTIL_TO_STRING_HPP
diff --git a/Pods/Realm/include/core/realm/util/tuple.hpp b/Pods/Realm/include/core/realm/util/tuple.hpp
new file mode 100644
index 0000000..a12b2cf
--- /dev/null
+++ b/Pods/Realm/include/core/realm/util/tuple.hpp
@@ -0,0 +1,186 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_UTIL_TUPLE_HPP
+#define REALM_UTIL_TUPLE_HPP
+
+#include <ostream>
+
+#include <realm/util/type_list.hpp>
+
+namespace realm {
+namespace util {
+
+
+template<class L>
+struct Tuple {
+    typedef typename L::head head_type;
+    typedef Tuple<typename L::tail> tail_type;
+    head_type m_head;
+    tail_type m_tail;
+    Tuple(const head_type& h, const tail_type& t): m_head(h), m_tail(t) {}
+};
+template<>
+struct Tuple<void> {};
+
+
+template<class H, class T>
+inline Tuple<TypeCons<H,T>> cons(const H& h, const Tuple<T>& t)
+{
+    return Tuple<TypeCons<H,T>>(h,t);
+}
+
+
+inline Tuple<void> tuple() { return Tuple<void>(); }
+
+template<class A>
+inline Tuple<TypeCons<A, void>> tuple(const A& a)
+{
+    return cons(a, tuple());
+}
+
+template<class A, class B>
+inline Tuple<TypeCons<A, TypeCons<B, void>>> tuple(const A& a, const B& b)
+{
+    return cons(a, tuple(b));
+}
+
+template<class A, class B, class C>
+inline Tuple<TypeCons<A, TypeCons<B, TypeCons<C, void>>>>
+tuple(const A& a, const B& b, const C& c)
+{
+    return cons(a, tuple(b,c));
+}
+
+template<class A, class B, class C, class D>
+inline Tuple<TypeCons<A, TypeCons<B, TypeCons<C, TypeCons<D, void>>>>>
+tuple(const A& a, const B& b, const C& c, const D& d)
+{
+    return cons(a, tuple(b,c,d));
+}
+
+template<class A, class B, class C, class D, class E>
+inline Tuple<TypeCons<A, TypeCons<B, TypeCons<C, TypeCons<D, TypeCons<E, void>>>>>>
+tuple(const A& a, const B& b, const C& c, const D& d, const E& e)
+{
+    return cons(a, tuple(b,c,d,e));
+}
+
+template<class A, class B, class C, class D, class E, class F>
+inline Tuple<TypeCons<A, TypeCons<B, TypeCons<C, TypeCons<D, TypeCons<E, TypeCons<F, void>>>>>>>
+tuple(const A& a, const B& b, const C& c, const D& d, const E& e, const F& f)
+{
+    return cons(a, tuple(b,c,d,e,f));
+}
+
+template<class A, class B, class C, class D, class E, class F, class G>
+inline Tuple<TypeCons<A, TypeCons<B, TypeCons<C, TypeCons<D, TypeCons<E, TypeCons<F, TypeCons<G, void>>>>>>>>
+tuple(const A& a, const B& b, const C& c, const D& d, const E& e, const F& f, const G& g)
+{
+    return cons(a, tuple(b,c,d,e,f,g));
+}
+
+
+template<class L, class V>
+inline Tuple<typename TypeAppend<L,V>::type> append(const Tuple<L>& t, const V& v)
+{
+    return cons(t.m_head, append(t.m_tail, v));
+}
+template<class V>
+inline Tuple<TypeCons<V, void>> append(const Tuple<void>&, const V& v)
+{
+    return tuple(v);
+}
+template<class L, class V>
+inline Tuple<typename TypeAppend<L,V>::type> operator,(const Tuple<L>& t, const V& v)
+{
+    return append(t,v);
+}
+
+} // namespace util
+
+namespace _impl {
+    template<class L, int i>
+    struct TupleAt {
+        static typename util::TypeAt<L,i>::type exec(const util::Tuple<L>& t)
+        {
+            return TupleAt<typename L::tail, i-1>::exec(t.m_tail);
+        }
+    };
+    template<class L>
+    struct TupleAt<L,0> {
+        static typename L::head exec(const util::Tuple<L>& t) { return t.m_head; }
+    };
+
+    template<class Ch, class Tr, class T>
+    inline void write(std::basic_ostream<Ch, Tr>& out,
+                      const util::Tuple<util::TypeCons<T, void>>& t)
+    {
+        out << t.m_head;
+    }
+    template<class Ch, class Tr>
+    inline void write(std::basic_ostream<Ch, Tr>&, const util::Tuple<void>&) {}
+    template<class Ch, class Tr, class L>
+    inline void write(std::basic_ostream<Ch, Tr>& out, const util::Tuple<L>& t)
+    {
+        out << t.m_head << ',';
+        write(out, t.m_tail);
+    }
+}
+
+namespace util {
+
+template<int i, class L>
+inline typename TypeAt<L,i>::type at(const Tuple<L>& tuple)
+{
+    return _impl::TupleAt<L,i>::exec(tuple);
+}
+
+template<template<class T> class Op, class L>
+inline void for_each(const Tuple<L>& tuple)
+{
+    Op<typename L::head>()(tuple.head);
+    for_each<Op>(tuple.m_tail);
+}
+template<template<class T> class Op>
+inline void for_each(const Tuple<void>&) {}
+
+template<template<class T> class Op, class L, class A>
+inline void for_each(const Tuple<L>& tuple, const A& a)
+{
+    Op<typename L::head>()(tuple.m_head, a);
+    for_each<Op>(tuple.m_tail, a);
+}
+template<template<class T> class Op, class A>
+inline void for_each(const Tuple<void>&, const A&) {}
+
+template<class Ch, class Tr, class L>
+inline std::basic_ostream<Ch, Tr>& operator<<(std::basic_ostream<Ch, Tr>& out, const Tuple<L>& t)
+{
+    out << '(';
+    _impl::write(out, t);
+    out << ')';
+    return out;
+}
+
+
+} // namespace util
+} // namespace realm
+
+#endif // REALM_UTIL_TUPLE_HPP
diff --git a/Pods/Realm/include/core/realm/util/type_list.hpp b/Pods/Realm/include/core/realm/util/type_list.hpp
new file mode 100644
index 0000000..59fb75c
--- /dev/null
+++ b/Pods/Realm/include/core/realm/util/type_list.hpp
@@ -0,0 +1,230 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_UTIL_TYPE_LIST_HPP
+#define REALM_UTIL_TYPE_LIST_HPP
+
+#include <realm/util/meta.hpp>
+
+namespace realm {
+namespace util {
+
+
+/// The 'cons' operator for building lists of types.
+///
+/// \tparam H The head of the list, that is, the first type in the
+/// list.
+///
+/// \tparam T The tail of the list, that is, the list of types
+/// following the head. It is 'void' if nothing follows the head,
+/// otherwise it matches TypeCons<H2,T2>.
+///
+/// Note that 'void' is interpreted as a zero-length list.
+template<class H, class T>
+struct TypeCons {
+    typedef H head;
+    typedef T tail;
+};
+
+
+/// Append a type the the end of a type list. The resulting type list
+/// is available as TypeAppend<List, T>::type.
+///
+/// \tparam List A list of types constructed using TypeCons<>. Note
+/// that 'void' is interpreted as a zero-length list.
+///
+/// \tparam T The new type to be appended.
+template<class List, class T>
+struct TypeAppend {
+    typedef TypeCons<typename List::head, typename TypeAppend<typename List::tail, T>::type> type;
+};
+/// Base case for empty type list.
+template<class T>
+struct TypeAppend<void, T> {
+    typedef TypeCons<T, void> type;
+};
+
+
+/// Get an element from the specified list of types. The result is
+/// available as TypeAt<List, i>::type.
+///
+/// \tparam List A list of types constructed using TypeCons<>. Note
+/// that 'void' is interpreted as a zero-length list.
+///
+/// \tparam i The index of the list element to get.
+template<class List, int i>
+struct TypeAt {
+    typedef typename TypeAt<typename List::tail, i-1>::type type;
+};
+/// Base case for empty type list.
+template<class List>
+struct TypeAt<List, 0> {
+    typedef typename List::head type;
+};
+
+
+/// Count the number of elements in the specified list of types. The
+/// result is available as TypeCount<List>::value.
+///
+/// \tparam List The list of types, constructed using TypeCons<>. Note
+/// that 'void' is interpreted as a zero-length list.
+template<class List>
+struct TypeCount {
+    static const int value = 1 + TypeCount<typename List::tail>::value;
+};
+/// Base case for empty type list.
+template<>
+struct TypeCount<void>
+{
+    static const int value = 0;
+};
+
+
+/// Find the first type in the specified list that satisfies the
+/// specified predicate.
+///
+/// \tparam List The list of types, constructed using TypeCons<>. Note
+/// that 'void' is interpreted as a zero-length list.
+///
+/// \tparam Pred Must be such that `Pred<T>::value` is true if, and
+/// only if the predicate is satisfied for `T`.
+template<class List, template<class> class Pred>
+struct FindType {
+private:
+    typedef typename List::head                                type_1;
+    typedef typename FindType<typename List::tail, Pred>::type type_2;
+public:
+    typedef typename std::conditional<Pred<type_1>::value, type_1, type_2>::type type;
+};
+/// Base case for empty type list.
+template<template<class> class Pred>
+struct FindType<void, Pred> {
+    typedef void type;
+};
+
+
+/// Execute an action for each element in the specified list of types.
+///
+/// \tparam List The list of types, constructed using TypeCons<>. Note
+/// that 'void' is interpreted as a zero-length list.
+template<class List, template<class T, int i> class Op, int i=0>
+struct ForEachType {
+    /// Execute the `Op<T,i>::exec()` for each type `T` at index `i`
+    /// in `List`.
+    static void exec()
+    {
+        Op<typename List::head, i>::exec();
+        ForEachType<typename List::tail, Op, i+1>::exec();
+    }
+    /// Execute the `Op<T,i>::exec(a)` for each type `T` at index `i`
+    /// in `List`.
+    template<class A>
+    static void exec(const A& a)
+    {
+        Op<typename List::head, i>::exec(a);
+        ForEachType<typename List::tail, Op, i+1>::exec(a);
+    }
+    /// Execute the `Op<T,i>::exec(a,b)` for each type `T` at index
+    /// `i` in `List`.
+    template<class A, class B>
+    static void exec(const A& a, const B& b)
+    {
+        Op<typename List::head, i>::exec(a,b);
+        ForEachType<typename List::tail, Op, i+1>::exec(a,b);
+    }
+    /// Execute the `Op<T,i>::exec(a,b,c)` for each type `T` at index
+    /// `i` in `List`.
+    template<class A, class B, class C>
+    static void exec(const A& a, const B& b, const C& c)
+    {
+        Op<typename List::head, i>::exec(a,b,c);
+        ForEachType<typename List::tail, Op, i+1>::exec(a,b,c);
+    }
+};
+/// Base case for empty type list.
+template<template<class T, int i>
+class Op, int i> struct ForEachType<void, Op, i> {
+    static void exec() {}
+    template<class A>
+    static void exec(const A&) {}
+    template<class A, class B>
+    static void exec(const A&, const B&) {}
+    template<class A, class B, class C>
+    static void exec(const A&, const B&, const C&) {}
+};
+
+
+/// Execute a predicate for each element in the specified list of
+/// types, and return true if, and only if the predicate returns true
+/// for at least one of those elements. Iteration over the type list
+/// is terminated as soon as a predicate returns true.
+///
+/// \tparam List The list of types, constructed using TypeCons<>. Note
+/// that 'void' is interpreted as a zero-length list.
+template<class List, template<class T, int i> class Pred, int i=0>
+struct HasType {
+    /// Execute the `Op<T,i>::exec()` for each type `T` at index `i`
+    /// in `List`.
+    static bool exec()
+    {
+        return Pred<typename List::head, i>::exec() ||
+            HasType<typename List::tail, Pred, i+1>::exec();
+    }
+    /// Execute the `Op<T,i>::exec(a)` for each type `T` at index `i`
+    /// in `List`.
+    template<class A>
+    static bool exec(const A& a)
+    {
+        return Pred<typename List::head, i>::exec(a) ||
+            HasType<typename List::tail, Pred, i+1>::exec(a);
+    }
+    /// Execute the `Op<T,i>::exec(a,b)` for each type `T` at index
+    /// `i` in `List`.
+    template<class A, class B>
+    static bool exec(const A& a, const B& b)
+    {
+        return Pred<typename List::head, i>::exec(a,b) ||
+            HasType<typename List::tail, Pred, i+1>::exec(a,b);
+    }
+    /// Execute the `Op<T,i>::exec(a,b,c)` for each type `T` at index
+    /// `i` in `List`.
+    template<class A, class B, class C>
+    static bool exec(const A& a, const B& b, const C& c)
+    {
+        return Pred<typename List::head, i>::exec(a,b,c) ||
+            HasType<typename List::tail, Pred, i+1>::exec(a,b,c);
+    }
+};
+/// Base case for empty type list.
+template<template<class T, int i> class Pred, int i>
+struct HasType<void, Pred, i> {
+    static bool exec() { return false; }
+    template<class A>
+    static bool exec(const A&) { return false; }
+    template<class A, class B>
+    static bool exec(const A&, const B&) { return false; }
+    template<class A, class B, class C>
+    static bool exec(const A&, const B&, const C&) { return false; }
+};
+
+
+} // namespace util
+} // namespace realm
+
+#endif // REALM_UTIL_TYPE_LIST_HPP
diff --git a/Pods/Realm/include/core/realm/util/type_traits.hpp b/Pods/Realm/include/core/realm/util/type_traits.hpp
new file mode 100644
index 0000000..d78cad2
--- /dev/null
+++ b/Pods/Realm/include/core/realm/util/type_traits.hpp
@@ -0,0 +1,160 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_UTIL_TYPE_TRAITS_HPP
+#define REALM_UTIL_TYPE_TRAITS_HPP
+
+#include <stdint.h>
+#include <climits>
+#include <cwchar>
+#include <limits>
+#include <type_traits>
+
+#include <realm/util/features.h>
+#include <realm/util/assert.hpp>
+#include <realm/util/meta.hpp>
+#include <realm/util/type_list.hpp>
+
+namespace realm {
+namespace util {
+
+template<class From, class To>
+struct CopyConst {
+private:
+    typedef typename std::remove_const<To>::type type_1;
+public:
+    typedef typename std::conditional<std::is_const<From>::value, const type_1, type_1>::type type;
+};
+
+
+/// Member `type` is the type resulting from integral or
+/// floating-point promotion of a value of type `T`.
+///
+/// \note Enum types are supported only when the compiler supports the
+/// C++11 'decltype' feature.
+template<class T>
+struct Promote;
+
+
+/// Member `type` is the type of the result of a binary arithmetic (or
+/// bitwise) operation (+, -, *, /, %, |, &, ^) when applied to
+/// operands of type `A` and `B` respectively. The type of the result
+/// of a shift operation (<<, >>) can instead be found as the type
+/// resulting from integral promotion of the left operand. The type of
+/// the result of a unary arithmetic (or bitwise) operation can be
+/// found as the type resulting from integral promotion of the
+/// operand.
+///
+/// \note Enum types are supported only when the compiler supports the
+/// C++11 'decltype' feature.
+template<class A, class B>
+struct ArithBinOpType;
+
+
+/// Member `type` is `B` if `B` has more value bits than `A`,
+/// otherwise is is `A`.
+template<class A, class B>
+struct ChooseWidestInt;
+
+
+/// Member `type` is the first of `unsigned char`, `unsigned short`,
+/// `unsigned int`, `unsigned long`, and `unsigned long long` that has
+/// at least `bits` value bits.
+template<int bits>
+struct LeastUnsigned;
+
+
+/// Member `type` is `unsigned` if `unsigned` has at least `bits`
+/// value bits, otherwise it is the same as
+/// `LeastUnsigned<bits>::type`.
+template<int bits>
+struct FastestUnsigned;
+
+
+// Implementation
+
+
+template<class T>
+struct Promote {
+    typedef decltype(+T()) type; // FIXME: This is not performing floating-point promotion.
+};
+
+
+template<class A, class B>
+struct ArithBinOpType {
+    typedef decltype(A()+B()) type;
+};
+
+
+template<class A, class B>
+struct ChooseWidestInt {
+private:
+    typedef std::numeric_limits<A> lim_a;
+    typedef std::numeric_limits<B> lim_b;
+    static_assert(lim_a::is_specialized && lim_b::is_specialized,
+                  "std::numeric_limits<> must be specialized for both types");
+    static_assert(lim_a::is_integer && lim_b::is_integer,
+                  "Both types must be integers");
+public:
+    typedef typename std::conditional<(lim_a::digits >= lim_b::digits), A, B>::type type;
+};
+
+
+template<int bits>
+struct LeastUnsigned {
+private:
+    typedef void                                          types_0;
+    typedef TypeAppend<types_0, unsigned char>::type      types_1;
+    typedef TypeAppend<types_1, unsigned short>::type     types_2;
+    typedef TypeAppend<types_2, unsigned int>::type       types_3;
+    typedef TypeAppend<types_3, unsigned long>::type      types_4;
+    typedef TypeAppend<types_4, unsigned long long>::type types_5;
+    typedef types_5 types;
+    // The `dummy<>` template is there to work around a bug in
+    // VisualStudio (seen in versions 2010 and 2012). Without the
+    // `dummy<>` template, The C++ compiler in Visual Studio would
+    // attempt to instantiate `FindType<type, pred>` before the
+    // instantiation of `LeastUnsigned<>` which obviously fails
+    // because `pred` depends on `bits`.
+    template<int>
+    struct dummy {
+        template<class T>
+    struct pred {
+            static const bool value = std::numeric_limits<T>::digits >= bits;
+        };
+    };
+public:
+    typedef typename FindType<types, dummy<bits>::template pred>::type type;
+    static_assert(!(std::is_same<type, void>::value), "No unsigned type is that wide");
+};
+
+
+template<int bits>
+struct FastestUnsigned {
+private:
+    typedef typename util::LeastUnsigned<bits>::type least_unsigned;
+public:
+    typedef typename util::ChooseWidestInt<unsigned, least_unsigned>::type type;
+};
+
+
+} // namespace util
+} // namespace realm
+
+#endif // REALM_UTIL_TYPE_TRAITS_HPP
diff --git a/Pods/Realm/include/core/realm/util/uri.hpp b/Pods/Realm/include/core/realm/util/uri.hpp
new file mode 100644
index 0000000..4275899
--- /dev/null
+++ b/Pods/Realm/include/core/realm/util/uri.hpp
@@ -0,0 +1,235 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_UTIL_URI_HPP
+#define REALM_UTIL_URI_HPP
+
+#include <string>
+
+namespace realm {
+namespace util {
+
+
+/// \brief A decomposed URI reference.
+///
+/// A Uri object contains a URI reference decomposed into its 5 main component
+/// parts (scheme, authority, path, query, and fragment identifier).
+///
+/// The decomposition process (as carried out by the constructor) performs a
+/// maximally lenient parsing of the specified URI reference. It does that
+/// according to the following regular expression (copied verbatimly from
+/// http://tools.ietf.org/html/rfc3986#appendix-B):
+///
+///     ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?
+///      12            3  4          5       6  7        8 9
+///
+///     Group
+///     ------------------------
+///     1       Scheme part
+///     3       Authority part
+///     5       Path part
+///     6       Query part
+///     8       Fragment identifier part
+///
+/// NOTE: Since this regular expression maches every string, every string is
+/// decomposable.
+///
+/// NOTE: This class does not attempt to perform any level of validation of URI
+/// references against the grammer specified in the RFC. Such validation could
+/// be added later, for example through a new `Uri::validate()`.
+///
+/// For example, the decomposition of
+/// "http://www.ietf.org/rfc/rfc2396.txt?foo=bar#chp3" is:
+///
+/// <pre>
+///
+///   scheme -> "http:"
+///   auth   -> "//www.ietf.org"
+///   path   -> "/rfc/rfc2396.txt"
+///   query  -> "?foo=bar"
+///   frag   -> "#chp3"
+///
+/// </pre>
+///
+/// This class also provides recomposition of a URI references from their
+/// component parts, where the parts can be specified individually, or be a
+/// result of URI resoultion.
+///
+/// It is important to understand, however, that certain restrictions need to
+/// apply to each component part in order that the URI reference as a whole is
+/// self consistent. More concretely, it is necessary to require that the
+/// component parts at any time must have values that will be preserved across a
+/// recomposition -> decomposition cycle.
+///
+/// The actual restrictions on each component part is specified for the
+/// corresponding setter-method (e.g., set_scheme()).
+///
+/// Note that component parts resulting from decomposition, canonicalize, or
+/// from resolution (resolve()) will automatically (by design of the underlying
+/// algorithm) adhere to these rules.
+///
+/// Decomposition, recomposition, conanonicalization, and resolution algorithms
+/// are taken from RFC 3986.
+///
+/// \sa http://tools.ietf.org/html/rfc3986
+class Uri {
+public:
+    Uri();
+
+    /// Decompose the specified URI reference into its five main parts.
+    Uri(const std::string&);
+
+    /// Reconstruct a URI reference from its 5 components.
+    std::string recompose() const;
+
+/*
+    /// Resolve this URI reference against the specified base URI reference
+    /// according to the rules described in section 5.2 of RFC 3986.
+    ///
+    /// Be aware that a fragment identifier on the base URI reference is never
+    /// carried over to the result. This is in accordance with the RFC.
+    void resolve(const Uri& base, bool strict = true);
+*/
+
+    /// Remove empty URI components. Also, for URI references having either a
+    /// scheme part or an authority part, replace an absent path with "/".
+    void canonicalize();
+
+    /// Get the scheme part of this URI reference including the trailing ":", or
+    /// the empty tring if there is no scheme part.
+    const std::string& get_scheme() const;
+
+    /// Get the authority part of this URI reference including the leading "//",
+    /// or the empty tring if there is no authority part.
+    const std::string& get_auth() const;
+
+    /// Same as get_auth() (with no arguments), but parse the authority component
+    /// into userinfo, host, and port subcomponents.
+    ///
+    /// \return True if, and only if the authority component was present (i.e.,
+    /// not the empty string). When false is returned, none of the specified
+    /// strings will have been modified.
+    bool get_auth(std::string& userinfo, std::string& host, std::string& port) const;
+
+    /// Get the path part of this URI reference, or the empty tring if there is
+    /// no path part.
+    const std::string& get_path() const;
+
+    /// Get the query part of this URI reference including the leading "?", or
+    /// the empty tring if there is no query part.
+    const std::string& get_query() const;
+
+    /// Get the fragment identifier of this URI reference including the leading
+    /// "#", or the empty tring if there is no fragment identifier.
+    const std::string& get_frag() const;
+
+    /// The specified string must either be empty or have a final ":". Also, it
+    /// must not contain "/", "?", or "#", nor may it contain more than one ":".
+    ///
+    /// \throw std::invalid_argument If the specified string is not valid
+    /// according to the specified rules.
+    void set_scheme(const std::string&);
+
+    /// The specified string must either be empty or have "//" as a
+    /// prefix. Also, it must not contain "?" or "#", nor may it contain "/"
+    /// beyond the first two.
+    ///
+    /// \throw std::invalid_argument If the specified string is not valid
+    /// according to the specified rules.
+    void set_auth(const std::string&);
+
+    /// The specified string must not contain "?" or "#".
+    ///
+    /// \throw std::invalid_argument If the specified string is not valid
+    /// according to the specified rules.
+    void set_path(const std::string&);
+
+    /// The specified string must either be empty or have a leading "?". Also,
+    /// it must not contain "#".
+    ///
+    /// \throw std::invalid_argument If the specified string is not valid
+    /// according to the specified rules.
+    void set_query(const std::string&);
+
+/*
+    /// Set the query string to the serialized form of the specified set of
+    /// query parameters. This is slightly faster than set_query(q.encode())
+    /// because it avoids the validity check on the string.
+    void set_query(const Params&);
+*/
+
+    /// The specified string must either be empty or have a leading "#".
+    ///
+    /// \throw std::invalid_argument If the specified string is not valid
+    /// according to the specified rules.
+    void set_frag(const std::string&);
+
+    bool is_absolute() const;
+
+private:
+    std::string m_scheme, m_auth, m_path, m_query, m_frag;
+};
+
+
+
+// Implementation
+
+inline Uri::Uri()
+{
+}
+
+inline std::string Uri::recompose() const
+{
+    return m_scheme + m_auth + m_path + m_query + m_frag;
+}
+
+inline const std::string& Uri::get_scheme() const
+{
+    return m_scheme;
+}
+
+inline const std::string& Uri::get_auth() const
+{
+    return m_auth;
+}
+
+inline const std::string& Uri::get_path() const
+{
+    return m_path;
+}
+
+inline const std::string& Uri::get_query() const
+{
+    return m_query;
+}
+
+inline const std::string& Uri::get_frag() const
+{
+    return m_frag;
+}
+
+inline bool Uri::is_absolute() const
+{
+    return !m_scheme.empty();
+}
+
+} // namespace util
+} // namespace realm
+
+#endif // REALM_UTIL_URI_HPP
diff --git a/Pods/Realm/include/core/realm/util/utf8.hpp b/Pods/Realm/include/core/realm/util/utf8.hpp
new file mode 100644
index 0000000..770f375
--- /dev/null
+++ b/Pods/Realm/include/core/realm/util/utf8.hpp
@@ -0,0 +1,394 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_UTIL_UTF8_HPP
+#define REALM_UTIL_UTF8_HPP
+
+#include <stdint.h>
+#include <string>
+
+#include <realm/util/safe_int_ops.hpp>
+#include <realm/string_data.hpp>
+#include <realm/util/features.h>
+#include <realm/utilities.hpp>
+
+namespace realm {
+namespace util {
+
+
+/// Transcode between UTF-8 and UTF-16.
+///
+/// \tparam Char16 Must be an integral type with at least 16 bits.
+///
+/// \tparam Traits16 Must define to_int_type() and to_char_type() for
+/// \a Char16.
+template<class Char16, class Traits16 = std::char_traits<Char16>>
+struct Utf8x16 {
+    /// Transcode as much as possible of the specified UTF-8 input, to
+    /// UTF-16. Returns true if all input characters were transcoded, or
+    /// transcoding stopped because the next character did not fit into the
+    /// output buffer. Returns false if transcoding stopped due to invalid
+    /// input. It is not specified whether this function returns true or false
+    /// if invalid input occurs at the same time as the output buffer runs
+    /// full. In any case, upon return, \a in_begin and \a out_begin are
+    /// advanced to the position where transcoding stopped.
+    ///
+    /// Throws only if Traits16::to_char_type() throws.
+    static bool to_utf16(const char*& in_begin, const char* in_end,
+                         Char16*& out_begin, Char16* out_end);
+
+    /// Same as to_utf16(), but in reverse.
+    ///
+    /// Throws only if Traits16::to_int_type() throws.
+    static bool to_utf8(const Char16*& in_begin, const Char16* in_end,
+                        char*& out_begin, char* out_end);
+
+    /// Summarize the number of UTF-16 elements needed to hold the result of
+    /// transcoding the specified UTF-8 string. Upon return, if \a in_begin !=
+    /// \a in_end, then the summation stopped due to invalid UTF-8 input. The
+    /// returned size then reflects the number of UTF-16 elements needed to hold
+    /// the result of transcoding the part of the input that was examined. This
+    /// function will only detect a few UTF-8 validity issues, and can therefore
+    /// not be used for general UTF-8 validation.
+    static size_t find_utf16_buf_size(const char*& in_begin, const char* in_end);
+
+    /// Summarize the number of UTF-8 bytes needed to hold the result of
+    /// transcoding the specified UTF-16 string. Upon return, if \a in_begin !=
+    /// \a in_end, then the summation stopped due to invalid UTF-16 input, or to
+    /// prevent the returned \c size_t value from overflowing. The returned size
+    /// then reflects the number of UTF-8 bytes needed to hold the result of
+    /// transcoding the part of the input that was examined. This function will
+    /// only detect a few UTF-16 validity issues, and can therefore not be used
+    /// for general UTF-16 validation.
+    static size_t find_utf8_buf_size(const Char16*& in_begin, const Char16* in_end);
+};
+
+
+
+
+
+// Implementation:
+
+// Adapted from reference implementation.
+// http://www.unicode.org/resources/utf8.html
+// http://www.bsdua.org/files/unicode.tar.gz
+template<class Char16, class Traits16>
+inline bool Utf8x16<Char16, Traits16>::to_utf16(const char*& in_begin, const char* const in_end,
+                                                Char16*& out_begin, Char16* const out_end)
+{
+        typedef std::char_traits<char> traits8;
+    bool invalid = false;
+    const char* in = in_begin;
+    Char16* out = out_begin;
+    while (in != in_end) {
+        if (REALM_UNLIKELY(out == out_end)) {
+            break; // Need space in output buffer
+        }
+        REALM_ASSERT(&in[0] >= in_begin && &in[0] < in_end);
+        uint_fast16_t v1 = uint_fast16_t(traits8::to_int_type(in[0]));
+        if (REALM_LIKELY(v1 < 0x80)) { // One byte
+            // UTF-8 layout: 0xxxxxxx
+            *out++ = Traits16::to_char_type(v1);
+            in += 1;
+            continue;
+        }
+        if (REALM_UNLIKELY(v1 < 0xC0)) {
+            invalid = true;
+            break; // Invalid first byte of UTF-8 sequence
+        }
+        if (REALM_LIKELY(v1 < 0xE0)) { // Two bytes
+            if (REALM_UNLIKELY(in_end - in < 2)) {
+                invalid = true;
+                break; // Incomplete UTF-8 sequence
+            }
+            REALM_ASSERT(&in[1] >= in_begin && &in[1] < in_end);
+            uint_fast16_t v2 = uint_fast16_t(traits8::to_int_type(in[1]));
+            // UTF-8 layout: 110xxxxx 10xxxxxx
+            if (REALM_UNLIKELY((v2 & 0xC0) != 0x80)) {
+                invalid = true;
+                break; // Invalid continuation byte
+            }
+            uint_fast16_t v = uint_fast16_t(((v1 & 0x1F) << 6) |
+                                            ((v2 & 0x3F) << 0));
+            if (REALM_UNLIKELY(v < 0x80)) {
+                invalid = true;
+                break; // Overlong encoding is invalid
+            }
+            *out++ = Traits16::to_char_type(v);
+            in += 2;
+            continue;
+        }
+        if (REALM_LIKELY(v1 < 0xF0)) { // Three bytes
+            if (REALM_UNLIKELY(in_end - in < 3)) {
+                invalid = true;
+                break; // Incomplete UTF-8 sequence
+            }
+            REALM_ASSERT(&in[1] >= in_begin && &in[2] < in_end);
+            uint_fast16_t v2 = uint_fast16_t(traits8::to_int_type(in[1]));
+            uint_fast16_t v3 = uint_fast16_t(traits8::to_int_type(in[2]));
+            // UTF-8 layout: 1110xxxx 10xxxxxx 10xxxxxx
+            if (REALM_UNLIKELY((v2 & 0xC0) != 0x80 || (v3 & 0xC0) != 0x80)) {
+                invalid = true;
+                break; // Invalid continuation byte
+            }
+            uint_fast16_t v = uint_fast16_t(((v1 & 0x0F) << 12) |
+                                            ((v2 & 0x3F) <<  6) |
+                                            ((v3 & 0x3F) <<  0));
+            if (REALM_UNLIKELY(v < 0x800)) {
+                invalid = true;
+                break; // Overlong encoding is invalid
+            }
+            if (REALM_UNLIKELY(0xD800 <= v && v < 0xE000)) {
+                invalid = true;
+                break; // Illegal code point range (reserved for UTF-16 surrogate pairs)
+            }
+            *out++ = Traits16::to_char_type(v);
+            in += 3;
+            continue;
+        }
+        if (REALM_UNLIKELY(out + 1 == out_end)) {
+            break; // Need space in output buffer for surrogate pair
+        }
+        if (REALM_LIKELY(v1 < 0xF8)) { // Four bytes
+            if (REALM_UNLIKELY(in_end - in < 4)) {
+                invalid = true;
+                break; // Incomplete UTF-8 sequence
+            }
+            uint_fast32_t w1 = uint_fast32_t(v1); // 16 bit -> 32 bit
+            REALM_ASSERT(&in[1] >= in_begin && &in[3] < in_end);
+            uint_fast32_t v2 = uint_fast32_t(traits8::to_int_type(in[1])); // 32 bit intended
+            uint_fast16_t v3 = uint_fast16_t(traits8::to_int_type(in[2])); // 16 bit intended
+            uint_fast16_t v4 = uint_fast16_t(traits8::to_int_type(in[3])); // 16 bit intended
+            // UTF-8 layout: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
+            if (REALM_UNLIKELY((v2 & 0xC0) != 0x80 || (v3 & 0xC0) != 0x80 ||
+                                 (v4 & 0xC0) != 0x80)) {
+                invalid = true;
+                break; // Invalid continuation byte
+            }
+            uint_fast32_t v =
+                uint_fast32_t(((w1 & 0x07) << 18) | // Parenthesis is 32 bit partial result
+                              ((v2 & 0x3F) << 12) | // Parenthesis is 32 bit partial result
+                              ((v3 & 0x3F) <<  6) | // Parenthesis is 16 bit partial result
+                              ((v4 & 0x3F) <<  0)); // Parenthesis is 16 bit partial result
+            if (REALM_UNLIKELY(v < 0x10000)) {
+                invalid = true;
+                break; // Overlong encoding is invalid
+            }
+            if (REALM_UNLIKELY(0x110000 <= v)) {
+                invalid = true;
+                break; // Code point too big for UTF-16
+            }
+            v -= 0x10000l;
+            *out++ = Traits16::to_char_type(0xD800 + (v / 0x400));
+            *out++ = Traits16::to_char_type(0xDC00 + (v % 0x400));
+            in += 4;
+            continue;
+        }
+        // Invalid first byte of UTF-8 sequence, or code point too big for UTF-16
+        invalid = true;
+        break;
+    }
+
+    REALM_ASSERT(in >= in_begin && in <= in_end);
+    REALM_ASSERT(out >= out_begin && out <= out_end);
+    in_begin = in;
+    out_begin = out;
+    return !invalid;
+}
+
+
+template<class Char16, class Traits16>
+inline size_t Utf8x16<Char16, Traits16>::find_utf16_buf_size(const char*& in_begin,
+                                                                  const char* const in_end)
+{
+        typedef std::char_traits<char> traits8;
+    size_t num_out = 0;
+    const char* in = in_begin;
+    while (in != in_end) {
+        REALM_ASSERT(&in[0] >= in_begin && &in[0] < in_end);
+        uint_fast16_t v1 = uint_fast16_t(traits8::to_int_type(in[0]));
+        if (REALM_LIKELY(v1 < 0x80)) { // One byte
+            num_out += 1;
+            in += 1;
+            continue;
+        }
+        if (REALM_UNLIKELY(v1 < 0xC0)) {
+            break; // Invalid first byte of UTF-8 sequence
+        }
+        if (REALM_LIKELY(v1 < 0xE0)) { // Two bytes
+            if (REALM_UNLIKELY(in_end - in < 2)) {
+                break; // Incomplete UTF-8 sequence
+            }
+            num_out += 1;
+            in += 2;
+            continue;
+        }
+        if (REALM_LIKELY(v1 < 0xF0)) { // Three bytes
+            if (REALM_UNLIKELY(in_end - in < 3)) {
+                break; // Incomplete UTF-8 sequence
+            }
+            num_out += 1;
+            in += 3;
+            continue;
+        }
+        if (REALM_LIKELY(v1 < 0xF8)) { // Four bytes
+            if (REALM_UNLIKELY(in_end - in < 4)) {
+                break; // Incomplete UTF-8 sequence
+            }
+            num_out += 2; // Surrogate pair
+            in += 4;
+            continue;
+        }
+        // Invalid first byte of UTF-8 sequence, or code point too big for UTF-16
+        break;
+    }
+
+    REALM_ASSERT(in >= in_begin && in <= in_end);
+    in_begin  = in;
+    return num_out;
+}
+
+
+
+// Adapted from reference implementation.
+// http://www.unicode.org/resources/utf8.html
+// http://www.bsdua.org/files/unicode.tar.gz
+template<class Char16, class Traits16>
+inline bool Utf8x16<Char16, Traits16>::to_utf8(const Char16*& in_begin, const Char16* const in_end,
+                                               char*& out_begin, char* const out_end)
+{
+        typedef std::char_traits<char> traits8;
+    typedef typename traits8::int_type traits8_int_type;
+    bool invalid = false;
+    const Char16* in = in_begin;
+    char* out = out_begin;
+    while (in != in_end) {
+        REALM_ASSERT(&in[0] >= in_begin && &in[0] < in_end);
+        uint_fast16_t v1 = uint_fast16_t(Traits16::to_int_type(in[0]));
+        if (REALM_LIKELY(v1 < 0x80)) {
+            if (REALM_UNLIKELY(out == out_end)) {
+                break; // Not enough output buffer space
+            }
+            // UTF-8 layout: 0xxxxxxx
+            REALM_ASSERT(out >= out_begin && out < out_end);
+            *out++ = traits8::to_char_type(traits8_int_type(v1));
+            in += 1;
+            continue;
+        }
+        if (REALM_LIKELY(v1 < 0x800)) {
+            if (REALM_UNLIKELY(out_end - out < 2)) {
+                break; // Not enough output buffer space
+            }
+            // UTF-8 layout: 110xxxxx 10xxxxxx
+            *out++ = traits8::to_char_type(traits8_int_type(0xC0 + v1 / 0x40));
+            REALM_ASSERT(out >= out_begin && out < out_end);
+            *out++ = traits8::to_char_type(traits8_int_type(0x80 + v1 % 0x40));
+            in += 1;
+            continue;
+        }
+        if (REALM_LIKELY(v1 < 0xD800 || 0xE000 <= v1)) {
+            if (REALM_UNLIKELY(out_end - out < 3)) {
+                break; // Not enough output buffer space
+            }
+            // UTF-8 layout: 1110xxxx 10xxxxxx 10xxxxxx
+            REALM_ASSERT(out >= out_begin && out + 2 < out_end);
+            *out++ = traits8::to_char_type(traits8_int_type(0xE0 + v1 / 0x1000));
+            *out++ = traits8::to_char_type(traits8_int_type(0x80 + v1 / 0x40 % 0x40));
+            *out++ = traits8::to_char_type(traits8_int_type(0x80 + v1 % 0x40));
+            in += 1;
+            continue;
+        }
+
+        // Surrogate pair
+        if (REALM_UNLIKELY(out_end - out < 4)) {
+            break; // Not enough output buffer space
+        }
+        if (REALM_UNLIKELY(0xDC00 <= v1)) {
+            invalid = true;
+            break; // Invalid first half of surrogate pair
+        }
+        if (REALM_UNLIKELY(in + 1 == in_end)) {
+            invalid = true;
+            break; // Incomplete surrogate pair
+        }
+        REALM_ASSERT(&in[1] >= in_begin && &in[1] < in_end);
+        uint_fast16_t v2 = uint_fast16_t(Traits16::to_int_type(in[1]));
+        if (REALM_UNLIKELY(v2 < 0xDC00 || 0xE000 <= v2)) {
+            invalid = true;
+            break; // Invalid second half of surrogate pair
+        }
+        uint_fast32_t v = 0x10000l + (uint_fast32_t(v1 - 0xD800) * 0x400 + (v2 - 0xDC00));
+        // UTF-8 layout: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
+        REALM_ASSERT(out >= out_begin && out + 3 < out_end);
+        *out++ = traits8::to_char_type(traits8_int_type(0xF0 + v / 0x40000));
+        *out++ = traits8::to_char_type(traits8_int_type(0x80 + v / 0x1000 % 0x40));
+        *out++ = traits8::to_char_type(traits8_int_type(0x80 + v / 0x40 % 0x40));
+        *out++ = traits8::to_char_type(traits8_int_type(0x80 + v % 0x40));
+        in += 2;
+    }
+
+    REALM_ASSERT(in >= in_begin && in <= in_end);
+    REALM_ASSERT(out >= out_begin && out <= out_end);
+    in_begin = in;
+    out_begin = out;
+    return !invalid;
+}
+
+
+template<class Char16, class Traits16>
+inline size_t Utf8x16<Char16, Traits16>::find_utf8_buf_size(const Char16*& in_begin,
+                                                                 const Char16* const in_end)
+{
+        size_t num_out = 0;
+    const Char16* in = in_begin;
+    while (in != in_end) {
+        REALM_ASSERT(&in[0] >= in_begin && &in[0] < in_end);
+        uint_fast16_t v = uint_fast16_t(Traits16::to_int_type(in[0]));
+        if (REALM_LIKELY(v < 0x80)) {
+            if (REALM_UNLIKELY(int_add_with_overflow_detect(num_out, 1)))
+                break; // Avoid overflow
+            in += 1;
+        }
+        else if (REALM_LIKELY(v < 0x800)) {
+            if (REALM_UNLIKELY(int_add_with_overflow_detect(num_out, 2)))
+                break; // Avoid overflow
+            in += 1;
+        }
+        else if (REALM_LIKELY(v < 0xD800 || 0xE000 <= v)) {
+            if (REALM_UNLIKELY(int_add_with_overflow_detect(num_out, 3)))
+                break; // Avoid overflow
+            in += 1;
+        }
+        else {
+            if (REALM_UNLIKELY(in + 1 == in_end)) {
+                break; // Incomplete surrogate pair
+            }
+            if (REALM_UNLIKELY(int_add_with_overflow_detect(num_out, 4)))
+                break; // Avoid overflow
+            in += 2;
+        }
+    }
+    REALM_ASSERT(in >= in_begin && in <= in_end);
+    in_begin  = in;
+    return num_out;
+}
+} // namespace util
+} // namespace realm
+
+#endif // REALM_UTIL_UTF8_HPP
diff --git a/Pods/Realm/include/core/realm/utilities.hpp b/Pods/Realm/include/core/realm/utilities.hpp
new file mode 100644
index 0000000..9e4075f
--- /dev/null
+++ b/Pods/Realm/include/core/realm/utilities.hpp
@@ -0,0 +1,233 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_UTILITIES_HPP
+#define REALM_UTILITIES_HPP
+
+#include <stdint.h>
+#include <cstdlib>
+#include <cstdlib> // size_t
+#include <cstdio>
+#include <algorithm>
+#include <functional>
+
+#ifdef _MSC_VER
+#  include <intrin.h>
+#endif
+
+#include <realm/util/features.h>
+#include <realm/util/assert.hpp>
+#include <realm/util/safe_int_ops.hpp>
+
+// GCC defines __i386__ and __x86_64__
+#if (defined(__X86__) || defined(__i386__) || defined(i386) || defined(_M_IX86) || defined(__386__) || defined(__x86_64__) || defined(_M_X64))
+#  define REALM_X86_OR_X64
+#  define REALM_X86_OR_X64_TRUE true
+#else
+#  define REALM_X86_OR_X64_TRUE false
+#endif
+
+// GCC defines __arm__
+#ifdef __arm__
+#  define REALM_ARCH_ARM
+#endif
+
+#if defined _LP64 || defined __LP64__ || defined __64BIT__ || defined _ADDR64 || defined _WIN64 || defined __arch64__ || (defined(__WORDSIZE) && __WORDSIZE == 64) || (defined __sparc && defined __sparcv9) || defined __x86_64 || defined __amd64 || defined __x86_64__ || defined _M_X64 || defined _M_IA64 || defined __ia64 || defined __IA64__
+#  define REALM_PTR_64
+#endif
+
+
+#if defined(REALM_PTR_64) && defined(REALM_X86_OR_X64)
+#  define REALM_COMPILER_SSE  // Compiler supports SSE 4.2 through __builtin_ accessors or back-end assembler
+#  define REALM_COMPILER_AVX
+#endif
+
+namespace realm {
+
+using StringCompareCallback = std::function<bool(const char* string1, const char* string2)>;
+
+extern signed char sse_support;
+extern signed char avx_support;
+
+template<int version>
+REALM_FORCEINLINE bool sseavx()
+{
+/*
+    Return whether or not SSE 3.0 (if version = 30) or 4.2 (for version = 42) is supported. Return value
+    is based on the CPUID instruction.
+
+    sse_support = -1: No SSE support
+    sse_support = 0: SSE3
+    sse_support = 1: SSE42
+
+    avx_support = -1: No AVX support
+    avx_support = 0: AVX1 supported
+    sse_support = 1: AVX2 supported (not yet implemented for detection in our cpuid_init(), todo)
+
+    This lets us test very rapidly at runtime because we just need 1 compare instruction (with 0) to test both for
+    SSE 3 and 4.2 by caller (compiler optimizes if calls are concecutive), and can decide branch with ja/jl/je because
+    sse_support is signed type. Also, 0 requires no immediate operand. Same for AVX.
+
+    We runtime-initialize sse_support in a constructor of a static variable which is not guaranteed to be called
+    prior to cpu_sse(). So we compile-time initialize sse_support to -2 as fallback.
+*/
+    static_assert(version == 1 || version == 2 || version == 30 || version == 42,
+                  "Only version == 1 (AVX), 2 (AVX2), 30 (SSE 3) and 42 (SSE 4.2) are supported for detection");
+#ifdef REALM_COMPILER_SSE
+    if (version == 30)
+        return (sse_support >= 0);
+    else if (version == 42)
+        return (sse_support > 0);   // faster than == 1 (0 requres no immediate operand)
+    else if (version == 1) // avx
+        return (avx_support >= 0);
+    else if (version == 2) // avx2
+        return (avx_support > 0);
+
+#else
+    return false;
+#endif
+}
+
+void cpuid_init();
+void* round_up(void* p, size_t align);
+void* round_down(void* p, size_t align);
+size_t round_up(size_t p, size_t align);
+size_t round_down(size_t p, size_t align);
+void millisleep(size_t milliseconds);
+
+// popcount
+int fast_popcount32(int32_t x);
+int fast_popcount64(int64_t x);
+uint64_t fastrand(uint64_t max = 0xffffffffffffffffULL, bool is_seed = false);
+
+// log2 - returns -1 if x==0, otherwise log2(x)
+inline int log2(size_t x) {
+    if (x == 0)
+        return -1;
+#if defined(__GNUC__)
+#   ifdef REALM_PTR_64
+    return 63 - __builtin_clzll(x); // returns int
+#   else
+    return 31 - __builtin_clz(x); // returns int
+#   endif
+#elif defined(_WIN32)
+    unsigned long index = 0;
+#   ifdef REALM_PTR_64
+    unsigned char c = _BitScanReverse64(&index, x); // outputs unsigned long
+#   else
+    unsigned char c = _BitScanReverse(&index, x); // outputs unsigned long
+#   endif
+    return static_cast<int>(index);
+#else // not __GNUC__ and not _WIN32
+    int r = 0;
+    while (x >>= 1) {
+        r++;
+    }
+    return r;
+#endif
+}
+
+// Implementation:
+
+// Safe cast from 64 to 32 bits on 32 bit architecture. Differs from to_ref() by not testing alignment and REF-bitflag.
+inline size_t to_size_t(int_fast64_t v) noexcept
+{
+    REALM_ASSERT_DEBUG(!util::int_cast_has_overflow<size_t>(v));
+    return size_t(v);
+}
+
+
+template<typename ReturnType, typename OriginalType>
+ReturnType type_punning(OriginalType variable) noexcept
+{
+    union Both {
+        OriginalType in;
+        ReturnType out;
+    };
+    Both both;
+    both.out = ReturnType(); // Clear all bits in case ReturnType is larger than OriginalType
+    both.in = variable;
+    return both.out;
+}
+
+enum FindRes {
+    FindRes_not_found,
+    FindRes_single,
+    FindRes_column
+};
+
+enum IndexMethod {
+    index_FindFirst,
+    index_FindAll,
+    index_FindAll_nocopy,
+    index_Count
+};
+
+
+// realm::is_any<T, U1, U2, U3, ...> ==
+// std::is_same<T, U1>::value || std::is_same<T, U2>::value || std::is_same<T, U3>::value ...
+template<typename... T>
+struct is_any : std::false_type { };
+
+template<typename T, typename... Ts>
+struct is_any<T, T, Ts...> : std::true_type { };
+
+template<typename T, typename U, typename... Ts>
+struct is_any<T, U, Ts...> : is_any<T, Ts...> { };
+
+
+// Use safe_equal() instead of std::equal() when comparing sequences which can have a 0 elements.
+template<class InputIterator1, class InputIterator2>
+bool safe_equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2)
+{
+#if defined(_MSC_VER) && defined(_DEBUG)
+
+    // Windows has a special check in debug mode against passing realm::null()
+    // pointer to std::equal(). It's uncertain if this is allowed by the C++ standard. For details, see
+    // http://stackoverflow.com/questions/19120779/is-char-p-0-stdequalp-p-p-well-defined-according-to-the-c-standard.
+    // Below check 'first1==last1' is to prevent failure in debug mode.
+    return (first1 == last1 || std::equal(first1, last1, first2));
+#else
+    return std::equal(first1, last1, first2);
+#endif
+}
+
+
+template<class T>
+struct Wrap {
+    Wrap(const T& v): m_value(v) {}
+    operator T() const { return m_value; }
+private:
+    T m_value;
+};
+
+// PlacementDelete is intended for use with std::unique_ptr when it holds an object allocated with
+// placement new. It simply calls the object's destructor without freeing the memory.
+struct PlacementDelete {
+    template<class T>
+    void operator()(T* v) const
+    {
+        v->~T();
+    }
+};
+
+} // namespace realm
+
+#endif // REALM_UTILITIES_HPP
+
diff --git a/Pods/Realm/include/core/realm/version.hpp b/Pods/Realm/include/core/realm/version.hpp
new file mode 100644
index 0000000..8430aaf
--- /dev/null
+++ b/Pods/Realm/include/core/realm/version.hpp
@@ -0,0 +1,55 @@
+/*************************************************************************
+ *
+ * REALM CONFIDENTIAL
+ * __________________
+ *
+ *  [2011] - [2015] Realm Inc
+ *  All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains
+ * the property of Realm Incorporated and its suppliers,
+ * if any.  The intellectual and technical concepts contained
+ * herein are proprietary to Realm Incorporated
+ * and its suppliers and may be covered by U.S. and Foreign Patents,
+ * patents in process, and are protected by trade secret or copyright law.
+ * Dissemination of this information or reproduction of this material
+ * is strictly forbidden unless prior written permission is obtained
+ * from Realm Incorporated.
+ *
+ **************************************************************************/
+#ifndef REALM_VERSION_HPP
+#define REALM_VERSION_HPP
+
+#include <string>
+
+#include <realm/util/features.h>
+
+#define REALM_VER_MAJOR 1
+#define REALM_VER_MINOR 3
+#define REALM_VER_PATCH 1
+#define REALM_PRODUCT_NAME "realm-core"
+
+#define REALM_VER_STRING REALM_QUOTE(REALM_VER_MAJOR) "." REALM_QUOTE(REALM_VER_MINOR) "." REALM_QUOTE(REALM_VER_PATCH)
+#define REALM_VER_CHUNK "[" REALM_PRODUCT_NAME "-" REALM_VER_STRING "]"
+
+namespace realm {
+
+enum Feature {
+    feature_Debug,
+    feature_Replication
+};
+
+class Version {
+public:
+    static int get_major() { return REALM_VER_MAJOR; }
+    static int get_minor() { return REALM_VER_MINOR; }
+    static int get_patch() { return REALM_VER_PATCH; }
+    static std::string get_version();
+    static bool is_at_least(int major, int minor, int patch);
+    static bool has_feature(Feature feature);
+};
+
+
+} // namespace realm
+
+#endif // REALM_VERSION_HPP
diff --git a/Pods/Realm/include/core/realm/views.hpp b/Pods/Realm/include/core/realm/views.hpp
new file mode 100644
index 0000000..85aabb7
--- /dev/null
+++ b/Pods/Realm/include/core/realm/views.hpp
@@ -0,0 +1,121 @@
+#ifndef REALM_VIEWS_HPP
+#define REALM_VIEWS_HPP
+
+#include <realm/column.hpp>
+#include <realm/column_string_enum.hpp>
+#include <realm/handover_defs.hpp>
+#include <realm/index_string.hpp>
+
+namespace realm {
+
+const int64_t detached_ref = -1;
+
+// This class is for common functionality of ListView and LinkView which inherit from it. Currently it only
+// supports sorting.
+class RowIndexes
+{
+public:
+    RowIndexes(IntegerColumn::unattached_root_tag urt, realm::Allocator& alloc) :
+#ifdef REALM_COOKIE_CHECK
+        cookie(cookie_expected),
+#endif
+        m_row_indexes(urt, alloc)
+    {}
+
+    RowIndexes(IntegerColumn&& col) :
+#ifdef REALM_COOKIE_CHECK
+        cookie(cookie_expected),
+#endif
+        m_row_indexes(std::move(col))
+    {}
+
+    RowIndexes(const RowIndexes& source, ConstSourcePayload mode);
+    RowIndexes(RowIndexes& source, MutableSourcePayload mode);
+
+    virtual ~RowIndexes()
+    {
+#ifdef REALM_COOKIE_CHECK
+        cookie = 0x7765697633333333; // 0x77656976 = 'view'; 0x33333333 = '3333' = destructed
+#endif
+    }
+
+    // Return a column of the table that m_row_indexes are pointing at (which is the target table for LinkList and
+    // parent table for TableView)
+    virtual const ColumnBase& get_column_base(size_t index) const = 0;
+
+    virtual size_t size() const = 0;
+
+    // These two methods are overridden by TableView and LinkView.
+    virtual uint_fast64_t sync_if_needed() const = 0;
+    virtual bool is_in_sync() const { return true; }
+
+    void check_cookie() const
+    {
+#ifdef REALM_COOKIE_CHECK
+        REALM_ASSERT_RELEASE(cookie == cookie_expected);
+#endif
+    }
+
+    // Predicate for std::sort
+    struct Sorter
+    {
+        Sorter(){}
+        Sorter(const std::vector<size_t>& columns, const std::vector<bool>& ascending)
+            : m_column_indexes(columns), m_ascending(ascending) {}
+        bool operator()(size_t i, size_t j) const
+        {
+            for (size_t t = 0; t < m_columns.size(); t++) {
+                // todo/fixme, special treatment of StringEnumColumn by calling StringEnumColumn::compare_values()
+                // instead of the general ColumnTemplate::compare_values() becuse it cannot overload inherited
+                // `int64_t get_val()` of Column. Such column inheritance needs to be cleaned up
+                int c;
+                if (const StringEnumColumn* cse = m_string_enum_columns[t])
+                    c = cse->compare_values(i, j);
+                else
+                    c = m_columns[t]->compare_values(i, j);
+
+                if (c != 0)
+                    return m_ascending[t] ? c > 0 : c < 0;
+            }
+            return false; // row i == row j
+        }
+
+        void init(RowIndexes* row_indexes)
+        {
+            m_columns.clear();
+            m_string_enum_columns.clear();
+            m_columns.resize(m_column_indexes.size(), 0);
+            m_string_enum_columns.resize(m_column_indexes.size(), 0);
+
+            for (size_t i = 0; i < m_column_indexes.size(); i++) {
+                const ColumnBase& cb = row_indexes->get_column_base(m_column_indexes[i]);
+                const ColumnTemplateBase* ctb = dynamic_cast<const ColumnTemplateBase*>(&cb);
+                REALM_ASSERT(ctb);
+                if (const StringEnumColumn* cse = dynamic_cast<const StringEnumColumn*>(&cb))
+                    m_string_enum_columns[i] = cse;
+                else
+                    m_columns[i] = ctb;
+            }
+        }
+
+        explicit operator bool() const { return !m_column_indexes.empty(); }
+
+        std::vector<size_t> m_column_indexes;
+        std::vector<bool> m_ascending;
+        std::vector<const ColumnTemplateBase*> m_columns;
+        std::vector<const StringEnumColumn*> m_string_enum_columns;
+    };
+
+    void sort(Sorter& sorting_predicate);
+
+#ifdef REALM_COOKIE_CHECK
+    static const uint64_t cookie_expected = 0x7765697677777777ull; // 0x77656976 = 'view'; 0x77777777 = '7777' = alive
+    uint64_t cookie;
+#endif
+
+    IntegerColumn m_row_indexes;
+};
+
+} // namespace realm
+
+#endif // REALM_VIEWS_HPP
diff --git a/Pods/Realm/include/impl/apple/external_commit_helper.hpp b/Pods/Realm/include/impl/apple/external_commit_helper.hpp
new file mode 100644
index 0000000..c87d8b2
--- /dev/null
+++ b/Pods/Realm/include/impl/apple/external_commit_helper.hpp
@@ -0,0 +1,80 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2015 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#include <future>
+
+namespace realm {
+class Realm;
+
+namespace _impl {
+class RealmCoordinator;
+
+class ExternalCommitHelper {
+public:
+    ExternalCommitHelper(RealmCoordinator& parent);
+    ~ExternalCommitHelper();
+
+    void notify_others();
+
+private:
+    // A RAII holder for a file descriptor which automatically closes the wrapped
+    // fd when it's deallocated
+    class FdHolder {
+    public:
+        FdHolder() = default;
+        ~FdHolder() { close(); }
+        operator int() const { return m_fd; }
+
+        FdHolder& operator=(int newFd) {
+            close();
+            m_fd = newFd;
+            return *this;
+        }
+
+    private:
+        int m_fd = -1;
+        void close();
+
+        FdHolder& operator=(FdHolder const&) = delete;
+        FdHolder(FdHolder const&) = delete;
+    };
+
+    void listen();
+
+    RealmCoordinator& m_parent;
+
+    // The listener thread
+    std::future<void> m_thread;
+
+    // Pipe which is waited on for changes and written to when there is a new
+    // commit to notify others of. When using a named pipe m_notify_fd is
+    // read-write and m_notify_fd_write is unused; when using an anonymous pipe
+    // (on tvOS) m_notify_fd is read-only and m_notify_fd_write is write-only.
+    FdHolder m_notify_fd;
+    FdHolder m_notify_fd_write;
+
+    // File descriptor for the kqueue
+    FdHolder m_kq;
+
+    // The two ends of an anonymous pipe used to notify the kqueue() thread that
+    // it should be shut down.
+    FdHolder m_shutdown_read_fd;
+    FdHolder m_shutdown_write_fd;
+};
+} // namespace _impl
+} // namespace realm
diff --git a/Pods/Realm/include/impl/apple/weak_realm_notifier.hpp b/Pods/Realm/include/impl/apple/weak_realm_notifier.hpp
new file mode 100644
index 0000000..be940dc
--- /dev/null
+++ b/Pods/Realm/include/impl/apple/weak_realm_notifier.hpp
@@ -0,0 +1,50 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2015 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#include "impl/weak_realm_notifier_base.hpp"
+
+#include <CoreFoundation/CFRunLoop.h>
+
+namespace realm {
+class Realm;
+
+namespace _impl {
+
+class WeakRealmNotifier : public WeakRealmNotifierBase {
+public:
+    WeakRealmNotifier(const std::shared_ptr<Realm>& realm, bool cache);
+    ~WeakRealmNotifier();
+
+    WeakRealmNotifier(WeakRealmNotifier&&);
+    WeakRealmNotifier& operator=(WeakRealmNotifier&&);
+
+    WeakRealmNotifier(const WeakRealmNotifier&) = delete;
+    WeakRealmNotifier& operator=(const WeakRealmNotifier&) = delete;
+
+    // Asynchronously call notify() on the Realm on the appropriate thread
+    void notify();
+
+private:
+    void invalidate();
+
+    CFRunLoopRef m_runloop;
+    CFRunLoopSourceRef m_signal;
+};
+
+} // namespace _impl
+} // namespace realm
diff --git a/Pods/Realm/include/impl/collection_change_builder.hpp b/Pods/Realm/include/impl/collection_change_builder.hpp
new file mode 100644
index 0000000..6e9f78c
--- /dev/null
+++ b/Pods/Realm/include/impl/collection_change_builder.hpp
@@ -0,0 +1,67 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2016 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#ifndef REALM_COLLECTION_CHANGE_BUILDER_HPP
+#define REALM_COLLECTION_CHANGE_BUILDER_HPP
+
+#include "collection_notifications.hpp"
+
+#include <unordered_map>
+
+namespace realm {
+namespace _impl {
+class CollectionChangeBuilder : public CollectionChangeSet {
+public:
+    CollectionChangeBuilder(CollectionChangeBuilder const&) = default;
+    CollectionChangeBuilder(CollectionChangeBuilder&&) = default;
+    CollectionChangeBuilder& operator=(CollectionChangeBuilder const&) = default;
+    CollectionChangeBuilder& operator=(CollectionChangeBuilder&&) = default;
+
+    CollectionChangeBuilder(IndexSet deletions = {},
+                            IndexSet insertions = {},
+                            IndexSet modification = {},
+                            std::vector<Move> moves = {});
+
+    // Calculate where rows need to be inserted or deleted from old_rows to turn
+    // it into new_rows, and check all matching rows for modifications
+    static CollectionChangeBuilder calculate(std::vector<size_t> const& old_rows,
+                                             std::vector<size_t> const& new_rows,
+                                             std::function<bool (size_t)> row_did_change,
+                                             bool sort);
+
+    void merge(CollectionChangeBuilder&&);
+    void clean_up_stale_moves();
+
+    void insert(size_t ndx, size_t count=1, bool track_moves=true);
+    void modify(size_t ndx);
+    void erase(size_t ndx);
+    void move_over(size_t ndx, size_t last_ndx, bool track_moves=true);
+    void clear(size_t old_size);
+    void move(size_t from, size_t to);
+
+    void parse_complete();
+
+private:
+    std::unordered_map<size_t, size_t> m_move_mapping;
+
+    void verify();
+};
+} // namespace _impl
+} // namespace realm
+
+#endif // REALM_COLLECTION_CHANGE_BUILDER_HPP
diff --git a/Pods/Realm/include/impl/collection_notifier.hpp b/Pods/Realm/include/impl/collection_notifier.hpp
new file mode 100644
index 0000000..34a133f
--- /dev/null
+++ b/Pods/Realm/include/impl/collection_notifier.hpp
@@ -0,0 +1,247 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2016 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#ifndef REALM_BACKGROUND_COLLECTION_HPP
+#define REALM_BACKGROUND_COLLECTION_HPP
+
+#include "impl/collection_change_builder.hpp"
+
+#include <realm/group_shared.hpp>
+
+#include <array>
+#include <atomic>
+#include <exception>
+#include <functional>
+#include <mutex>
+#include <unordered_map>
+
+namespace realm {
+class Realm;
+
+namespace _impl {
+struct ListChangeInfo {
+    size_t table_ndx;
+    size_t row_ndx;
+    size_t col_ndx;
+    CollectionChangeBuilder* changes;
+};
+
+struct TransactionChangeInfo {
+    std::vector<bool> table_modifications_needed;
+    std::vector<bool> table_moves_needed;
+    std::vector<ListChangeInfo> lists;
+    std::vector<CollectionChangeBuilder> tables;
+};
+
+class DeepChangeChecker {
+public:
+    struct OutgoingLink {
+        size_t col_ndx;
+        bool is_list;
+    };
+    struct RelatedTable {
+        size_t table_ndx;
+        std::vector<OutgoingLink> links;
+    };
+
+    DeepChangeChecker(TransactionChangeInfo const& info, Table const& root_table,
+                      std::vector<RelatedTable> const& related_tables);
+
+    bool operator()(size_t row_ndx);
+
+    // Recursively add `table` and all tables it links to to `out`, along with
+    // information about the links from them
+    static void find_related_tables(std::vector<RelatedTable>& out, Table const& table);
+
+private:
+    TransactionChangeInfo const& m_info;
+    Table const& m_root_table;
+    const size_t m_root_table_ndx;
+    IndexSet const* const m_root_modifications;
+    std::vector<IndexSet> m_not_modified;
+    std::vector<RelatedTable> const& m_related_tables;
+
+    struct Path {
+        size_t table;
+        size_t row;
+        size_t col;
+        bool depth_exceeded;
+    };
+    std::array<Path, 16> m_current_path;
+
+    bool check_row(Table const& table, size_t row_ndx, size_t depth = 0);
+    bool check_outgoing_links(size_t table_ndx, Table const& table,
+                              size_t row_ndx, size_t depth = 0);
+};
+
+// A base class for a notifier that keeps a collection up to date and/or
+// generates detailed change notifications on a background thread. This manages
+// most of the lifetime-management issues related to sharing an object between
+// the worker thread and the collection on the target thread, along with the
+// thread-safe callback collection.
+class CollectionNotifier {
+public:
+    CollectionNotifier(std::shared_ptr<Realm>);
+    virtual ~CollectionNotifier();
+
+    // ------------------------------------------------------------------------
+    // Public API for the collections using this to get notifications:
+
+    // Stop receiving notifications from this background worker
+    // This must be called in the destructor of the collection
+    void unregister() noexcept;
+
+    // Add a callback to be called each time the collection changes
+    // This can only be called from the target collection's thread
+    // Returns a token which can be passed to remove_callback()
+    size_t add_callback(CollectionChangeCallback callback);
+    // Remove a previously added token. The token is no longer valid after
+    // calling this function and must not be used again. This function can be
+    // called from any thread.
+    void remove_callback(size_t token);
+
+    // ------------------------------------------------------------------------
+    // API for RealmCoordinator to manage running things and calling callbacks
+
+    Realm* get_realm() const noexcept { return m_realm.get(); }
+
+    // Get the SharedGroup version which this collection can attach to (if it's
+    // in handover mode), or can deliver to (if it's been handed over to the BG worker alredad)
+    SharedGroup::VersionID version() const noexcept { return m_sg_version; }
+
+    // Release references to all core types
+    // This is called on the worker thread to ensure that non-thread-safe things
+    // can be destroyed on the correct thread, even if the last reference to the
+    // CollectionNotifier is released on a different thread
+    virtual void release_data() noexcept = 0;
+
+    // Call each of the currently registered callbacks, if there have been any
+    // changes since the last time each of those callbacks was called
+    void call_callbacks();
+
+    bool is_alive() const noexcept;
+
+    // Attach the handed-over query to `sg`. Must not be already attached to a SharedGroup.
+    void attach_to(SharedGroup& sg);
+    // Create a new query handover object and stop using the previously attached
+    // SharedGroup
+    void detach();
+
+    // Set `info` as the new ChangeInfo that will be populated by the next
+    // transaction advance, and register all required information in it
+    void add_required_change_info(TransactionChangeInfo& info);
+
+    virtual void run() = 0;
+    void prepare_handover();
+    bool deliver(Realm&, SharedGroup&, std::exception_ptr);
+
+    template <typename T>
+    class Handle;
+
+protected:
+    bool have_callbacks() const noexcept { return m_have_callbacks; }
+    void add_changes(CollectionChangeBuilder change) { m_accumulated_changes.merge(std::move(change)); }
+    void set_table(Table const& table);
+    std::unique_lock<std::mutex> lock_target();
+
+    std::function<bool (size_t)> get_modification_checker(TransactionChangeInfo const&, Table const&);
+
+private:
+    virtual void do_attach_to(SharedGroup&) = 0;
+    virtual void do_detach_from(SharedGroup&) = 0;
+    virtual void do_prepare_handover(SharedGroup&) = 0;
+    virtual bool do_deliver(SharedGroup&) { return true; }
+    virtual bool do_add_required_change_info(TransactionChangeInfo&) = 0;
+
+    mutable std::mutex m_realm_mutex;
+    std::shared_ptr<Realm> m_realm;
+
+    SharedGroup::VersionID m_sg_version;
+    SharedGroup* m_sg = nullptr;
+
+    std::exception_ptr m_error;
+    CollectionChangeBuilder m_accumulated_changes;
+    CollectionChangeSet m_changes_to_deliver;
+
+    std::vector<DeepChangeChecker::RelatedTable> m_related_tables;
+
+    struct Callback {
+        CollectionChangeCallback fn;
+        size_t token;
+        bool initial_delivered;
+    };
+
+    // Currently registered callbacks and a mutex which must always be held
+    // while doing anything with them or m_callback_index
+    std::mutex m_callback_mutex;
+    std::vector<Callback> m_callbacks;
+
+    // Cached value for if m_callbacks is empty, needed to avoid deadlocks in
+    // run() due to lock-order inversion between m_callback_mutex and m_target_mutex
+    // It's okay if this value is stale as at worst it'll result in us doing
+    // some extra work.
+    std::atomic<bool> m_have_callbacks = {false};
+
+    // Iteration variable for looping over callbacks
+    // remove_callback() updates this when needed
+    size_t m_callback_index = npos;
+
+    CollectionChangeCallback next_callback();
+};
+
+// A smart pointer to a CollectionNotifier that unregisters the notifier when
+// the pointer is destroyed. Movable. Copying will produce a null Handle.
+template <typename T>
+class CollectionNotifier::Handle : public std::shared_ptr<T> {
+public:
+    using std::shared_ptr<T>::shared_ptr;
+
+    Handle() = default;
+    ~Handle() { reset(); }
+
+    // Copying a Handle produces a null Handle.
+    Handle(const Handle&) : Handle() { }
+    Handle& operator=(const Handle& other)
+    {
+        if (this != &other) {
+            reset();
+        }
+        return *this;
+    }
+
+    Handle(Handle&&) = default;
+    Handle& operator=(Handle&& other)
+    {
+        reset();
+        std::shared_ptr<T>::shared_ptr::operator=(std::move(other));
+        return *this;
+    }
+
+    void reset()
+    {
+        if (*this) {
+            this->get()->unregister();
+            std::shared_ptr<T>::reset();
+        }
+    }
+};
+
+} // namespace _impl
+} // namespace realm
+
+#endif /* REALM_BACKGROUND_COLLECTION_HPP */
diff --git a/Pods/Realm/include/impl/external_commit_helper.hpp b/Pods/Realm/include/impl/external_commit_helper.hpp
new file mode 100644
index 0000000..0abbd56
--- /dev/null
+++ b/Pods/Realm/include/impl/external_commit_helper.hpp
@@ -0,0 +1,32 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2016 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#ifndef REALM_EXTERNAL_COMMIT_HELPER_HPP
+#define REALM_EXTERNAL_COMMIT_HELPER_HPP
+
+#include <realm/util/features.h>
+
+#if REALM_PLATFORM_APPLE
+#include "impl/apple/external_commit_helper.hpp"
+#elif REALM_ANDROID
+#include "impl/android/external_commit_helper.hpp"
+#else
+#include "impl/generic/external_commit_helper.hpp"
+#endif
+
+#endif // REALM_EXTERNAL_COMMIT_HELPER_HPP
diff --git a/Pods/Realm/include/impl/list_notifier.hpp b/Pods/Realm/include/impl/list_notifier.hpp
new file mode 100644
index 0000000..82b4e41
--- /dev/null
+++ b/Pods/Realm/include/impl/list_notifier.hpp
@@ -0,0 +1,62 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2016 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#ifndef REALM_LIST_NOTIFIER_HPP
+#define REALM_LIST_NOTIFIER_HPP
+
+#include "impl/collection_notifier.hpp"
+
+#include <realm/group_shared.hpp>
+
+namespace realm {
+namespace _impl {
+class ListNotifier : public CollectionNotifier {
+public:
+    ListNotifier(LinkViewRef lv, std::shared_ptr<Realm> realm);
+
+private:
+    // The linkview, in handover form if this has not been attached to the main
+    // SharedGroup yet
+    LinkViewRef m_lv;
+    std::unique_ptr<SharedGroup::Handover<LinkView>> m_lv_handover;
+
+    // The last-seen size of the LinkView so that we can report row deletions
+    // when the LinkView itself is deleted
+    size_t m_prev_size;
+
+    // The column index of the LinkView
+    size_t m_col_ndx;
+
+    // The actual change, calculated in run() and delivered in prepare_handover()
+    CollectionChangeBuilder m_change;
+    TransactionChangeInfo* m_info;
+
+    void run() override;
+
+    void do_prepare_handover(SharedGroup&) override;
+
+    void do_attach_to(SharedGroup& sg) override;
+    void do_detach_from(SharedGroup& sg) override;
+
+    void release_data() noexcept override;
+    bool do_add_required_change_info(TransactionChangeInfo& info) override;
+};
+}
+}
+
+#endif // REALM_LIST_NOTIFIER_HPP
diff --git a/Pods/Realm/include/impl/realm_coordinator.hpp b/Pods/Realm/include/impl/realm_coordinator.hpp
new file mode 100644
index 0000000..2a6f74b
--- /dev/null
+++ b/Pods/Realm/include/impl/realm_coordinator.hpp
@@ -0,0 +1,127 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2015 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#ifndef REALM_COORDINATOR_HPP
+#define REALM_COORDINATOR_HPP
+
+#include "shared_realm.hpp"
+
+#include <mutex>
+
+namespace realm {
+class Replication;
+class Schema;
+class SharedGroup;
+class StringData;
+
+namespace _impl {
+class CollectionNotifier;
+class ExternalCommitHelper;
+class WeakRealmNotifier;
+
+// RealmCoordinator manages the weak cache of Realm instances and communication
+// between per-thread Realm instances for a given file
+class RealmCoordinator : public std::enable_shared_from_this<RealmCoordinator> {
+public:
+    // Get the coordinator for the given path, creating it if neccesary
+    static std::shared_ptr<RealmCoordinator> get_coordinator(StringData path);
+    // Get the coordinator for the given path, or null if there is none
+    static std::shared_ptr<RealmCoordinator> get_existing_coordinator(StringData path);
+
+    // Get a thread-local shared Realm with the given configuration
+    // If the Realm is already open on another thread, validates that the given
+    // configuration is compatible with the existing one
+    std::shared_ptr<Realm> get_realm(Realm::Config config);
+    std::shared_ptr<Realm> get_realm();
+
+    const Schema* get_schema() const noexcept;
+    uint64_t get_schema_version() const noexcept { return m_config.schema_version; }
+    const std::string& get_path() const noexcept { return m_config.path; }
+    const std::vector<char>& get_encryption_key() const noexcept { return m_config.encryption_key; }
+    bool is_in_memory() const noexcept { return m_config.in_memory; }
+
+    // Asynchronously call notify() on every Realm instance for this coordinator's
+    // path, including those in other processes
+    void send_commit_notifications();
+
+    // Clear the weak Realm cache for all paths
+    // Should only be called in test code, as continuing to use the previously
+    // cached instances will have odd results
+    static void clear_cache();
+
+    // Clears all caches on existing coordinators
+    static void clear_all_caches();
+
+    // Explicit constructor/destructor needed for the unique_ptrs to forward-declared types
+    RealmCoordinator();
+    ~RealmCoordinator();
+
+    // Called by Realm's destructor to ensure the cache is cleaned up promptly
+    // Do not call directly
+    void unregister_realm(Realm* realm);
+
+    // Called by m_notifier when there's a new commit to send notifications for
+    void on_change();
+
+    // Update the schema in the cached config
+    void update_schema(Schema const& new_schema);
+
+    static void register_notifier(std::shared_ptr<CollectionNotifier> notifier);
+
+    // Advance the Realm to the most recent transaction version which all async
+    // work is complete for
+    void advance_to_ready(Realm& realm);
+    void process_available_async(Realm& realm);
+
+private:
+    Realm::Config m_config;
+
+    std::mutex m_realm_mutex;
+    std::vector<WeakRealmNotifier> m_weak_realm_notifiers;
+
+    std::mutex m_notifier_mutex;
+    std::vector<std::shared_ptr<_impl::CollectionNotifier>> m_new_notifiers;
+    std::vector<std::shared_ptr<_impl::CollectionNotifier>> m_notifiers;
+
+    // SharedGroup used for actually running async notifiers
+    // Will have a read transaction iff m_notifiers is non-empty
+    std::unique_ptr<Replication> m_notifier_history;
+    std::unique_ptr<SharedGroup> m_notifier_sg;
+
+    // SharedGroup used to advance notifiers in m_new_notifiers to the main shared
+    // group's transaction version
+    // Will have a read transaction iff m_new_notifiers is non-empty
+    std::unique_ptr<Replication> m_advancer_history;
+    std::unique_ptr<SharedGroup> m_advancer_sg;
+    std::exception_ptr m_async_error;
+
+    std::unique_ptr<_impl::ExternalCommitHelper> m_notifier;
+
+    // must be called with m_notifier_mutex locked
+    void pin_version(uint_fast64_t version, uint_fast32_t index);
+
+    void run_async_notifiers();
+    void open_helper_shared_group();
+    void advance_helper_shared_group_to_latest();
+    void clean_up_dead_notifiers();
+};
+
+} // namespace _impl
+} // namespace realm
+
+#endif /* REALM_COORDINATOR_HPP */
diff --git a/Pods/Realm/include/impl/results_notifier.hpp b/Pods/Realm/include/impl/results_notifier.hpp
new file mode 100644
index 0000000..2321292
--- /dev/null
+++ b/Pods/Realm/include/impl/results_notifier.hpp
@@ -0,0 +1,83 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2015 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#ifndef REALM_RESULTS_NOTIFIER_HPP
+#define REALM_RESULTS_NOTIFIER_HPP
+
+#include "collection_notifier.hpp"
+#include "results.hpp"
+
+#include <realm/group_shared.hpp>
+
+namespace realm {
+namespace _impl {
+class ResultsNotifier : public CollectionNotifier {
+public:
+    ResultsNotifier(Results& target);
+
+    void target_results_moved(Results& old_target, Results& new_target);
+
+private:
+    // Target Results to update
+    // Can only be used with lock_target() held
+    Results* m_target_results;
+
+    const SortOrder m_sort;
+    bool m_target_is_in_table_order;
+
+    // The source Query, in handover form iff m_sg is null
+    std::unique_ptr<SharedGroup::Handover<Query>> m_query_handover;
+    std::unique_ptr<Query> m_query;
+
+    // The TableView resulting from running the query. Will be detached unless
+    // the query was (re)run since the last time the handover object was created
+    TableView m_tv;
+    std::unique_ptr<SharedGroup::Handover<TableView>> m_tv_handover;
+
+    // The table version from the last time the query was run. Used to avoid
+    // rerunning the query when there's no chance of it changing.
+    uint_fast64_t m_last_seen_version = -1;
+
+    // The rows from the previous run of the query, for calculating diffs
+    std::vector<size_t> m_previous_rows;
+
+    // The changeset calculated during run() and delivered in do_prepare_handover()
+    CollectionChangeBuilder m_changes;
+    TransactionChangeInfo* m_info = nullptr;
+
+    // Flag for whether or not the query has been run at all, as goofy timing
+    // can lead to deliver() being called before that
+    bool m_initial_run_complete = false;
+
+    bool need_to_run();
+    void calculate_changes();
+
+    void run() override;
+    void do_prepare_handover(SharedGroup&) override;
+    bool do_deliver(SharedGroup& sg) override;
+    bool do_add_required_change_info(TransactionChangeInfo& info) override;
+
+    void release_data() noexcept override;
+    void do_attach_to(SharedGroup& sg) override;
+    void do_detach_from(SharedGroup& sg) override;
+};
+
+} // namespace _impl
+} // namespace realm
+
+#endif /* REALM_RESULTS_NOTIFIER_HPP */
diff --git a/Pods/Realm/include/impl/transact_log_handler.hpp b/Pods/Realm/include/impl/transact_log_handler.hpp
new file mode 100644
index 0000000..96dbbfd
--- /dev/null
+++ b/Pods/Realm/include/impl/transact_log_handler.hpp
@@ -0,0 +1,57 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2015 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#ifndef REALM_TRANSACT_LOG_HANDLER_HPP
+#define REALM_TRANSACT_LOG_HANDLER_HPP
+
+#include <realm/group_shared.hpp>
+
+namespace realm {
+class BindingContext;
+
+namespace _impl {
+struct TransactionChangeInfo;
+
+namespace transaction {
+// Advance the read transaction version, with change notifications sent to delegate
+// Must not be called from within a write transaction.
+void advance(SharedGroup& sg, BindingContext* binding_context,
+             SharedGroup::VersionID version=SharedGroup::VersionID{});
+
+// Begin a write transaction
+// If the read transaction version is not up to date, will first advance to the
+// most recent read transaction and sent notifications to delegate
+void begin(SharedGroup& sg, BindingContext* binding_context,
+           bool validate_schema_changes=true);
+
+// Commit a write transaction
+void commit(SharedGroup& sg, BindingContext* binding_context);
+
+// Cancel a write transaction and roll back all changes, with change notifications
+// for reverting to the old values sent to delegate
+void cancel(SharedGroup& sg, BindingContext* binding_context);
+
+// Advance the read transaction version, with change information gathered in info
+void advance(SharedGroup& sg,
+             TransactionChangeInfo& info,
+             SharedGroup::VersionID version=SharedGroup::VersionID{});
+} // namespace transaction
+} // namespace _impl
+} // namespace realm
+
+#endif /* REALM_TRANSACT_LOG_HANDLER_HPP */
diff --git a/Pods/Realm/include/impl/weak_realm_notifier.hpp b/Pods/Realm/include/impl/weak_realm_notifier.hpp
new file mode 100644
index 0000000..fe575d5
--- /dev/null
+++ b/Pods/Realm/include/impl/weak_realm_notifier.hpp
@@ -0,0 +1,34 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2016 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#ifndef REALM_WEAK_REALM_NOTIFIER_HPP
+#define REALM_WEAK_REALM_NOTIFIER_HPP
+
+#include <realm/util/features.h>
+
+#if REALM_PLATFORM_NODE
+#include "impl/node/weak_realm_notifier.hpp"
+#elif REALM_PLATFORM_APPLE
+#include "impl/apple/weak_realm_notifier.hpp"
+#elif REALM_ANDROID
+#include "impl/android/weak_realm_notifier.hpp"
+#else
+#include "impl/generic/weak_realm_notifier.hpp"
+#endif
+
+#endif // REALM_WEAK_REALM_NOTIFIER_HPP
diff --git a/Pods/Realm/include/impl/weak_realm_notifier_base.hpp b/Pods/Realm/include/impl/weak_realm_notifier_base.hpp
new file mode 100644
index 0000000..b72636f
--- /dev/null
+++ b/Pods/Realm/include/impl/weak_realm_notifier_base.hpp
@@ -0,0 +1,70 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2015 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#ifndef REALM_WEAK_REALM_NOTIFIER_BASE_HPP
+#define REALM_WEAK_REALM_NOTIFIER_BASE_HPP
+
+#include <memory>
+#include <thread>
+
+namespace realm {
+class Realm;
+
+namespace _impl {
+
+// WeakRealmNotifierBase stores a weak reference to a Realm instance, along with all of
+// the information about a Realm that needs to be accessed from other threads.
+// This is needed to avoid forming strong references to the Realm instances on
+// other threads, which can produce deadlocks when the last strong reference to
+// a Realm instance is released from within a function holding the cache lock.
+class WeakRealmNotifierBase {
+public:
+    WeakRealmNotifierBase(const std::shared_ptr<Realm>& realm, bool cache);
+
+    // Get a strong reference to the cached realm
+    std::shared_ptr<Realm> realm() const { return m_realm.lock(); }
+
+    // Does this WeakRealmNotifierBase store a Realm instance that should be used on the current thread?
+    bool is_cached_for_current_thread() const { return m_cache && is_for_current_thread(); }
+
+    // Has the Realm instance been destroyed?
+    bool expired() const { return m_realm.expired(); }
+
+    // Is this a WeakRealmNotifierBase for the given Realm instance?
+    bool is_for_realm(Realm* realm) const { return realm == m_realm_key; }
+
+    bool is_for_current_thread() const { return m_thread_id == std::this_thread::get_id(); }
+
+private:
+    std::weak_ptr<Realm> m_realm;
+    std::thread::id m_thread_id = std::this_thread::get_id();
+    void* m_realm_key;
+    bool m_cache = false;
+};
+
+inline WeakRealmNotifierBase::WeakRealmNotifierBase(const std::shared_ptr<Realm>& realm, bool cache)
+: m_realm(realm)
+, m_realm_key(realm.get())
+, m_cache(cache)
+{
+}
+
+} // namespace _impl
+} // namespace realm
+
+#endif // REALM_WEAK_REALM_NOTIFIER_BASE_HPP
diff --git a/Pods/Realm/include/index_set.hpp b/Pods/Realm/include/index_set.hpp
new file mode 100644
index 0000000..0cf00fd
--- /dev/null
+++ b/Pods/Realm/include/index_set.hpp
@@ -0,0 +1,326 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2015 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#ifndef REALM_INDEX_SET_HPP
+#define REALM_INDEX_SET_HPP
+
+#include <cstddef>
+#include <cstdlib>
+#include <initializer_list>
+#include <iterator>
+#include <type_traits>
+#include <utility>
+#include <vector>
+
+namespace realm {
+namespace _impl {
+template<typename OuterIterator>
+class MutableChunkedRangeVectorIterator;
+
+// An iterator for ChunkedRangeVector, templated on the vector iterator/const_iterator
+template<typename OuterIterator>
+class ChunkedRangeVectorIterator {
+public:
+    using iterator_category = std::bidirectional_iterator_tag;
+    using value_type = typename std::remove_reference<decltype(*OuterIterator()->data.begin())>::type;
+    using difference_type = ptrdiff_t;
+    using pointer = const value_type*;
+    using reference = const value_type&;
+
+    ChunkedRangeVectorIterator(OuterIterator outer, OuterIterator end, value_type* inner)
+    : m_outer(outer), m_end(end), m_inner(inner) { }
+
+    reference operator*() const { return *m_inner; }
+    pointer operator->() const { return m_inner; }
+
+    template<typename Other> bool operator==(Other const& it) const;
+    template<typename Other> bool operator!=(Other const& it) const;
+
+    ChunkedRangeVectorIterator& operator++();
+    ChunkedRangeVectorIterator operator++(int);
+
+    ChunkedRangeVectorIterator& operator--();
+    ChunkedRangeVectorIterator operator--(int);
+
+    // Advance directly to the next outer block
+    void next_chunk();
+
+    OuterIterator outer() const { return m_outer; }
+    size_t offset() const { return m_inner - &m_outer->data[0]; }
+
+private:
+    OuterIterator m_outer;
+    OuterIterator m_end;
+    value_type* m_inner;
+    friend struct ChunkedRangeVector;
+    friend class MutableChunkedRangeVectorIterator<OuterIterator>;
+};
+
+// A mutable iterator that adds some invariant-preserving mutation methods
+template<typename OuterIterator>
+class MutableChunkedRangeVectorIterator : public ChunkedRangeVectorIterator<OuterIterator> {
+public:
+    using ChunkedRangeVectorIterator<OuterIterator>::ChunkedRangeVectorIterator;
+
+    // Set this iterator to the given range and update the parent if needed
+    void set(size_t begin, size_t end);
+    // Adjust the begin and end of this iterator by the given amounts and
+    // update the parent if needed
+    void adjust(ptrdiff_t front, ptrdiff_t back);
+    // Shift this iterator by the given amount and update the parent if needed
+    void shift(ptrdiff_t distance);
+};
+
+// A vector which stores ranges in chunks with a maximum size
+struct ChunkedRangeVector {
+    struct Chunk {
+        std::vector<std::pair<size_t, size_t>> data;
+        size_t begin;
+        size_t end;
+        size_t count;
+    };
+    std::vector<Chunk> m_data;
+
+    using value_type = std::pair<size_t, size_t>;
+    using iterator = MutableChunkedRangeVectorIterator<typename decltype(m_data)::iterator>;
+    using const_iterator = ChunkedRangeVectorIterator<typename decltype(m_data)::const_iterator>;
+
+#ifdef REALM_DEBUG
+    static const size_t max_size = 4;
+#else
+    static const size_t max_size = 4096 / sizeof(std::pair<size_t, size_t>);
+#endif
+
+    iterator begin() { return empty() ? end() : iterator(m_data.begin(), m_data.end(), &m_data[0].data[0]); }
+    iterator end() { return iterator(m_data.end(), m_data.end(), nullptr); }
+    const_iterator begin() const { return cbegin(); }
+    const_iterator end() const { return cend(); }
+    const_iterator cbegin() const { return empty() ? cend() : const_iterator(m_data.cbegin(), m_data.end(), &m_data[0].data[0]); }
+    const_iterator cend() const { return const_iterator(m_data.end(), m_data.end(), nullptr); }
+
+    bool empty() const noexcept { return m_data.empty(); }
+
+    iterator insert(iterator pos, value_type value);
+    iterator erase(iterator pos);
+    void push_back(value_type value);
+    iterator ensure_space(iterator pos);
+
+    void verify() const noexcept;
+};
+} // namespace _impl
+
+class IndexSet : private _impl::ChunkedRangeVector {
+public:
+    static const size_t npos = -1;
+
+    using ChunkedRangeVector::value_type;
+    using ChunkedRangeVector::iterator;
+    using ChunkedRangeVector::const_iterator;
+    using ChunkedRangeVector::begin;
+    using ChunkedRangeVector::end;
+    using ChunkedRangeVector::empty;
+    using ChunkedRangeVector::verify;
+
+    IndexSet() = default;
+    IndexSet(std::initializer_list<size_t>);
+
+    // Check if the index set contains the given index
+    bool contains(size_t index) const;
+
+    // Counts the number of indices in the set in the given range
+    size_t count(size_t start_index=0, size_t end_index=-1) const;
+
+    // Add an index to the set, doing nothing if it's already present
+    void add(size_t index);
+    void add(IndexSet const& is);
+
+    // Add an index which has had all of the ranges in the set before it removed
+    // Returns the unshifted index
+    size_t add_shifted(size_t index);
+    // Add indexes which have had the ranges in `shifted_by` added and the ranges
+    // in the current set removed
+    void add_shifted_by(IndexSet const& shifted_by, IndexSet const& values);
+
+    // Remove all indexes from the set and then add a single range starting from
+    // zero with the given length
+    void set(size_t len);
+
+    // Insert an index at the given position, shifting existing indexes at or
+    // after that point back by one
+    void insert_at(size_t index, size_t count=1);
+    void insert_at(IndexSet const&);
+
+    // Shift indexes at or after the given point back by one
+    void shift_for_insert_at(size_t index, size_t count=1);
+    void shift_for_insert_at(IndexSet const&);
+
+    // Delete an index at the given position, shifting indexes after that point
+    // forward by one
+    void erase_at(size_t index);
+    void erase_at(IndexSet const&);
+
+    // If the given index is in the set remove it and return npos; otherwise unshift() it
+    size_t erase_or_unshift(size_t index);
+
+    // Remove the indexes at the given index from the set, without shifting
+    void remove(size_t index, size_t count=1);
+    void remove(IndexSet const&);
+
+    // Shift an index by inserting each of the indexes in this set
+    size_t shift(size_t index) const;
+    // Shift an index by deleting each of the indexes in this set
+    size_t unshift(size_t index) const;
+
+    // Remove all indexes from the set
+    void clear();
+
+    // An iterator over the individual indices in the set rather than the ranges
+    class IndexIterator : public std::iterator<std::forward_iterator_tag, size_t> {
+    public:
+        IndexIterator(IndexSet::const_iterator it) : m_iterator(it) { }
+        size_t operator*() const { return m_iterator->first + m_offset; }
+        bool operator==(IndexIterator const& it) const { return m_iterator == it.m_iterator; }
+        bool operator!=(IndexIterator const& it) const { return m_iterator != it.m_iterator; }
+
+        IndexIterator& operator++()
+        {
+            ++m_offset;
+            if (m_iterator->first + m_offset == m_iterator->second) {
+                ++m_iterator;
+                m_offset = 0;
+            }
+            return *this;
+        }
+
+        IndexIterator operator++(int)
+        {
+            auto value = *this;
+            ++*this;
+            return value;
+        }
+
+    private:
+        IndexSet::const_iterator m_iterator;
+        size_t m_offset = 0;
+    };
+
+    class IndexIteratableAdaptor {
+    public:
+        using value_type = size_t;
+        using iterator = IndexIterator;
+        using const_iterator = iterator;
+
+        const_iterator begin() const { return m_index_set.begin(); }
+        const_iterator end() const { return m_index_set.end(); }
+
+        IndexIteratableAdaptor(IndexSet const& is) : m_index_set(is) { }
+    private:
+        IndexSet const& m_index_set;
+    };
+
+    IndexIteratableAdaptor as_indexes() const { return *this; }
+
+private:
+    // Find the range which contains the index, or the first one after it if
+    // none do
+    iterator find(size_t index);
+    iterator find(size_t index, iterator it);
+    // Insert the index before the given position, combining existing ranges as
+    // applicable
+    // returns inserted position
+    iterator do_add(iterator pos, size_t index);
+    void do_erase(iterator it, size_t index);
+    iterator do_remove(iterator it, size_t index, size_t count);
+
+    void shift_until_end_by(iterator begin, ptrdiff_t shift);
+};
+
+namespace util {
+// This was added in C++14 but is missing from libstdc++ 4.9
+template<typename Iterator>
+std::reverse_iterator<Iterator> make_reverse_iterator(Iterator it)
+{
+    return std::reverse_iterator<Iterator>(it);
+}
+} // namespace util
+
+
+namespace _impl {
+template<typename T>
+template<typename OtherIterator>
+inline bool ChunkedRangeVectorIterator<T>::operator==(OtherIterator const& it) const
+{
+    return m_outer == it.outer() && m_inner == it.operator->();
+}
+
+template<typename T>
+template<typename OtherIterator>
+inline bool ChunkedRangeVectorIterator<T>::operator!=(OtherIterator const& it) const
+{
+    return !(*this == it);
+}
+
+template<typename T>
+inline ChunkedRangeVectorIterator<T>& ChunkedRangeVectorIterator<T>::operator++()
+{
+    ++m_inner;
+    if (offset() == m_outer->data.size())
+        next_chunk();
+    return *this;
+}
+
+template<typename T>
+inline ChunkedRangeVectorIterator<T> ChunkedRangeVectorIterator<T>::operator++(int)
+{
+    auto value = *this;
+    ++*this;
+    return value;
+}
+
+template<typename T>
+inline ChunkedRangeVectorIterator<T>& ChunkedRangeVectorIterator<T>::operator--()
+{
+    if (!m_inner || m_inner == &m_outer->data.front()) {
+        --m_outer;
+        m_inner = &m_outer->data.back();
+    }
+    else {
+        --m_inner;
+    }
+    return *this;
+}
+
+template<typename T>
+inline ChunkedRangeVectorIterator<T> ChunkedRangeVectorIterator<T>::operator--(int)
+{
+    auto value = *this;
+    --*this;
+    return value;
+}
+
+template<typename T>
+inline void ChunkedRangeVectorIterator<T>::next_chunk()
+{
+    ++m_outer;
+    m_inner = m_outer != m_end ? &m_outer->data[0] : nullptr;
+}
+} // namespace _impl
+
+} // namespace realm
+
+#endif // REALM_INDEX_SET_HPP
diff --git a/Pods/Realm/include/list.hpp b/Pods/Realm/include/list.hpp
new file mode 100644
index 0000000..f6570b4
--- /dev/null
+++ b/Pods/Realm/include/list.hpp
@@ -0,0 +1,122 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2015 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#ifndef REALM_LIST_HPP
+#define REALM_LIST_HPP
+
+#include "collection_notifications.hpp"
+#include "impl/collection_notifier.hpp"
+
+#include <realm/link_view_fwd.hpp>
+#include <realm/row.hpp>
+
+#include <functional>
+#include <memory>
+
+namespace realm {
+using RowExpr = BasicRowExpr<Table>;
+
+class ObjectSchema;
+class Query;
+class Realm;
+class Results;
+struct SortOrder;
+
+class List {
+public:
+    List() noexcept;
+    List(std::shared_ptr<Realm> r, LinkViewRef l) noexcept;
+    ~List();
+
+    List(const List&);
+    List& operator=(const List&);
+    List(List&&);
+    List& operator=(List&&);
+
+    const std::shared_ptr<Realm>& get_realm() const { return m_realm; }
+    Query get_query() const;
+    size_t get_origin_row_index() const;
+
+    bool is_valid() const;
+    void verify_attached() const;
+    void verify_in_transaction() const;
+
+    size_t size() const;
+    RowExpr get(size_t row_ndx) const;
+    size_t get_unchecked(size_t row_ndx) const noexcept;
+    size_t find(ConstRow const& row) const;
+
+    void add(size_t target_row_ndx);
+    void insert(size_t list_ndx, size_t target_row_ndx);
+    void move(size_t source_ndx, size_t dest_ndx);
+    void remove(size_t list_ndx);
+    void remove_all();
+    void set(size_t row_ndx, size_t target_row_ndx);
+    void swap(size_t ndx1, size_t ndx2);
+
+    void delete_all();
+
+    Results sort(SortOrder order);
+    Results filter(Query q);
+
+    bool operator==(List const& rgt) const noexcept;
+
+    NotificationToken add_notification_callback(CollectionChangeCallback cb);
+
+    // These are implemented in object_accessor.hpp
+    template <typename ValueType, typename ContextType>
+    void add(ContextType ctx, ValueType value);
+
+    template <typename ValueType, typename ContextType>
+    void insert(ContextType ctx, ValueType value, size_t list_ndx);
+
+    template <typename ValueType, typename ContextType>
+    void set(ContextType ctx, ValueType value, size_t list_ndx);
+
+    // The List object has been invalidated (due to the Realm being invalidated,
+    // or the containing object being deleted)
+    // All non-noexcept functions can throw this
+    struct InvalidatedException : public std::runtime_error {
+        InvalidatedException() : std::runtime_error("Access to invalidated List object") {}
+    };
+
+    // The input index parameter was out of bounds
+    struct OutOfBoundsIndexException : public std::out_of_range {
+        OutOfBoundsIndexException(size_t r, size_t c);
+        size_t requested;
+        size_t valid_count;
+    };
+
+private:
+    std::shared_ptr<Realm> m_realm;
+    LinkViewRef m_link_view;
+    _impl::CollectionNotifier::Handle<_impl::CollectionNotifier> m_notifier;
+
+    void verify_valid_row(size_t row_ndx, bool insertion = false) const;
+
+    friend struct std::hash<List>;
+};
+} // namespace realm
+
+namespace std {
+template<> struct hash<realm::List> {
+    size_t operator()(realm::List const&) const;
+};
+}
+
+#endif /* REALM_LIST_HPP */
diff --git a/Pods/Realm/include/object_schema.hpp b/Pods/Realm/include/object_schema.hpp
new file mode 100644
index 0000000..71d56d6
--- /dev/null
+++ b/Pods/Realm/include/object_schema.hpp
@@ -0,0 +1,60 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2015 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#ifndef REALM_OBJECT_SCHEMA_HPP
+#define REALM_OBJECT_SCHEMA_HPP
+
+#include <realm/string_data.hpp>
+
+#include <string>
+#include <vector>
+
+namespace realm {
+class Group;
+struct Property;
+
+class ObjectSchema {
+public:
+    ObjectSchema();
+    ObjectSchema(std::string name, std::string primary_key, std::initializer_list<Property> persisted_properties);
+    ~ObjectSchema();
+
+    // create object schema from existing table
+    // if no table is provided it is looked up in the group
+    ObjectSchema(const Group *group, const std::string &name);
+
+    std::string name;
+    std::vector<Property> persisted_properties;
+    std::vector<Property> computed_properties;
+    std::string primary_key;
+
+    Property *property_for_name(StringData name);
+    const Property *property_for_name(StringData name) const;
+    Property *primary_key_property() {
+        return property_for_name(primary_key);
+    }
+    const Property *primary_key_property() const {
+        return property_for_name(primary_key);
+    }
+
+private:
+    void set_primary_key_property();
+};
+}
+
+#endif /* defined(REALM_OBJECT_SCHEMA_HPP) */
diff --git a/Pods/Realm/include/object_store.hpp b/Pods/Realm/include/object_store.hpp
new file mode 100644
index 0000000..28d2a7c
--- /dev/null
+++ b/Pods/Realm/include/object_store.hpp
@@ -0,0 +1,322 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2015 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#ifndef REALM_OBJECT_STORE_HPP
+#define REALM_OBJECT_STORE_HPP
+
+#include "property.hpp"
+
+#include <realm/table_ref.hpp>
+
+#include <functional>
+#include <string>
+#include <vector>
+
+namespace realm {
+    class Group;
+    class ObjectSchema;
+    class ObjectSchemaValidationException;
+    class Schema;
+    class StringData;
+
+    class ObjectStore {
+      public:
+        // Schema version used for uninitialized Realms
+        static const uint64_t NotVersioned;
+
+        // get the last set schema version
+        static uint64_t get_schema_version(const Group *group);
+
+        // checks if the schema in the group is at the given version
+        static bool is_schema_at_version(const Group *group, uint64_t version);
+
+        // verify that schema from a group and a target schema are compatible
+        // updates the column mapping on all ObjectSchema properties of the target schema
+        // throws if the schema is invalid or does not match
+        static void verify_schema(Schema const& actual_schema, Schema& target_schema, bool allow_missing_tables = false);
+
+        // determines if a realm with the given old schema needs non-migration
+        // changes to make it compatible with the given target schema
+        static bool needs_update(Schema const& old_schema, Schema const& schema);
+
+        // updates a Realm from old_schema to the given target schema, creating and updating tables as needed
+        // passed in target schema is updated with the correct column mapping
+        // optionally runs migration function if schema is out of date
+        // NOTE: must be performed within a write transaction
+        typedef std::function<void(Group *, Schema &)> MigrationFunction;
+        static void update_realm_with_schema(Group *group, Schema const& old_schema, uint64_t version,
+                                             Schema &schema, MigrationFunction migration);
+
+        // get a table for an object type
+        static realm::TableRef table_for_object_type(Group *group, StringData object_type);
+        static realm::ConstTableRef table_for_object_type(const Group *group, StringData object_type);
+
+        // get existing Schema from a group
+        static Schema schema_from_group(const Group *group);
+
+        // deletes the table for the given type
+        static void delete_data_for_object(Group *group, StringData object_type);
+
+        // renames the object_type's column of the old_name to the new name
+        static void rename_property(Group *group, Schema& passed_schema, StringData object_type, StringData old_name, StringData new_name);
+
+        // indicates if this group contains any objects
+        static bool is_empty(const Group *group);
+
+        static std::string table_name_for_object_type(StringData class_name);
+        static StringData object_type_for_table_name(StringData table_name);
+
+    private:
+        // set a new schema version
+        static void set_schema_version(Group *group, uint64_t version);
+
+        // check if the realm already has all metadata tables
+        static bool has_metadata_tables(const Group *group);
+
+        // create any metadata tables that don't already exist
+        // must be in write transaction to set
+        // returns true if it actually did anything
+        static void create_metadata_tables(Group *group);
+
+        // set references to tables on targetSchema and create/update any missing or out-of-date tables
+        // if update existing is true, updates existing tables, otherwise only adds and initializes new tables
+        // returns pairs of object names & properties that should be deleted after the migration process
+        static std::vector<std::pair<std::string, Property>> create_tables(realm::Group *group, Schema &target_schema, bool update_existing);
+
+        // verify to see if there are any renamed properties that don't align with the target schema 
+        static void verify_missing_renamed_properties(Schema const& actual_schema, Schema& target_schema);
+
+        // remove properties marked for deletion by create_tables
+        static void remove_properties(Group *group, Schema &target_schema, std::vector<std::pair<std::string, Property>> to_delete);
+
+        // verify a target schema against an expected schema, setting the table_column property on each schema object
+        // updates the column mapping on the target_schema
+        // returns array of validation errors
+        static std::vector<ObjectSchemaValidationException> verify_object_schema(ObjectSchema const& expected,
+                                                                                 ObjectSchema &target_schema);
+
+        // get primary key property name for object type
+        static StringData get_primary_key_for_object(const Group *group, StringData object_type);
+
+        // sets primary key property for object type
+        // must be in write transaction to set
+        static void set_primary_key_for_object(Group *group, StringData object_type, StringData primary_key);
+
+        static TableRef table_for_object_type_create_if_needed(Group *group, StringData object_type, bool &created);
+
+        // returns if any indexes were changed
+        static bool update_indexes(Group *group, Schema &schema);
+
+        // validates that all primary key properties have unique values
+        static void validate_primary_column_uniqueness(const Group *group, Schema const& schema);
+
+        friend ObjectSchema;
+    };
+
+    // Base exception
+    class ObjectStoreException : public std::exception {
+      public:
+        ObjectStoreException() = default;
+        ObjectStoreException(const std::string &what) : m_what(what) {}
+        const char* what() const noexcept override { return m_what.c_str(); }
+      protected:
+        std::string m_what;
+    };
+
+    // Migration exceptions
+    class MigrationException : public ObjectStoreException {};
+
+    class PropertyRenameMissingObjectTypeException : public MigrationException {
+      public:
+        PropertyRenameMissingObjectTypeException(std::string object_type);
+        std::string object_type() const { return m_object_type; }
+      private:
+        std::string m_object_type;
+    };
+
+    class PropertyRenameMissingOldObjectTypeException : public PropertyRenameMissingObjectTypeException {
+      public:
+        PropertyRenameMissingOldObjectTypeException(std::string object_type);
+    };
+
+    class PropertyRenameMissingNewObjectTypeException : public PropertyRenameMissingObjectTypeException {
+      public:
+        PropertyRenameMissingNewObjectTypeException(std::string object_type);
+    };
+
+    class PropertyRenameException : public MigrationException {
+      public:
+        PropertyRenameException(std::string old_property_name, std::string new_property_name);
+        std::string old_property_name() const { return m_old_property_name; }
+        std::string new_property_name() const { return m_new_property_name; }
+      private:
+        std::string m_old_property_name, m_new_property_name;
+    };
+
+    class PropertyRenameMissingOldPropertyException : public PropertyRenameException {
+      public:
+        PropertyRenameMissingOldPropertyException(std::string old_property_name, std::string new_property_name);
+    };
+
+    class PropertyRenameMissingNewPropertyException : public MigrationException {
+    public:
+        std::string new_property_name() const { return m_new_property_name; }
+        PropertyRenameMissingNewPropertyException(std::string new_property_name);
+    private:
+        std::string m_new_property_name;
+    };
+
+    class PropertyRenameOldStillExistsException : public PropertyRenameException {
+      public:
+        PropertyRenameOldStillExistsException(std::string old_property_name, std::string new_property_name);
+    };
+
+    class PropertyRenameTypeMismatchException : public MigrationException {
+      public:
+        PropertyRenameTypeMismatchException(Property const& old_property, Property const& new_property);
+        Property const& old_property() const { return m_old_property; }
+        Property const& new_property() const { return m_new_property; }
+      private:
+        Property m_old_property, m_new_property;
+    };
+
+    class InvalidSchemaVersionException : public MigrationException {
+      public:
+        InvalidSchemaVersionException(uint64_t old_version, uint64_t new_version);
+        uint64_t old_version() const { return m_old_version; }
+        uint64_t new_version() const { return m_new_version; }
+      private:
+        uint64_t m_old_version, m_new_version;
+    };
+
+    class DuplicatePrimaryKeyValueException : public MigrationException {
+      public:
+        DuplicatePrimaryKeyValueException(std::string const& object_type, Property const& property);
+        DuplicatePrimaryKeyValueException(std::string const& object_type, Property const& property, const std::string message);
+
+        std::string object_type() const { return m_object_type; }
+        Property const& property() const { return m_property; }
+      private:
+        std::string m_object_type;
+        Property m_property;
+    };
+
+    // Schema validation exceptions
+    class SchemaValidationException : public ObjectStoreException {
+      public:
+        SchemaValidationException(std::vector<ObjectSchemaValidationException> const& errors);
+        std::vector<ObjectSchemaValidationException> const& validation_errors() const { return m_validation_errors; }
+      private:
+        std::vector<ObjectSchemaValidationException> m_validation_errors;
+    };
+
+    class SchemaMismatchException : public ObjectStoreException {
+    public:
+        SchemaMismatchException(std::vector<ObjectSchemaValidationException> const& errors);
+        std::vector<ObjectSchemaValidationException> const& validation_errors() const { return m_validation_errors; }
+    private:
+        std::vector<ObjectSchemaValidationException> m_validation_errors;
+    };
+
+    class ObjectSchemaValidationException : public ObjectStoreException {
+      public:
+        ObjectSchemaValidationException(std::string const& object_type) : m_object_type(object_type) {}
+        ObjectSchemaValidationException(std::string const& object_type, std::string const& message) :
+            m_object_type(object_type) { m_what = message; }
+        std::string object_type() const { return m_object_type; }
+      protected:
+        std::string m_object_type;
+    };
+
+    class ObjectSchemaPropertyException : public ObjectSchemaValidationException {
+      public:
+        ObjectSchemaPropertyException(std::string const& object_type, Property const& property) :
+            ObjectSchemaValidationException(object_type), m_property(property) {}
+        Property const& property() const { return m_property; }
+      private:
+        Property m_property;
+    };
+
+    class PropertyTypeNotIndexableException : public ObjectSchemaPropertyException {
+      public:
+        PropertyTypeNotIndexableException(std::string const& object_type, Property const& property);
+    };
+
+    class ExtraPropertyException : public ObjectSchemaPropertyException {
+      public:
+        ExtraPropertyException(std::string const& object_type, Property const& property);
+    };
+
+    class MissingPropertyException : public ObjectSchemaPropertyException {
+      public:
+        MissingPropertyException(std::string const& object_type, Property const& property);
+    };
+
+    class InvalidNullabilityException : public ObjectSchemaPropertyException {
+      public:
+        InvalidNullabilityException(std::string const& object_type, Property const& property);
+    };
+
+    class MissingObjectTypeException : public ObjectSchemaPropertyException {
+    public:
+        MissingObjectTypeException(std::string const& object_type, Property const& property);
+    };
+
+    class DuplicatePrimaryKeysException : public ObjectSchemaValidationException {
+    public:
+        DuplicatePrimaryKeysException(std::string const& object_type);
+    };
+
+    class MismatchedPropertiesException : public ObjectSchemaValidationException {
+      public:
+        MismatchedPropertiesException(std::string const& object_type, Property const& old_property, Property const& new_property);
+        Property const& old_property() const { return m_old_property; }
+        Property const& new_property() const { return m_new_property; }
+      private:
+        Property m_old_property, m_new_property;
+    };
+
+    class ChangedPrimaryKeyException : public ObjectSchemaValidationException {
+      public:
+        ChangedPrimaryKeyException(std::string const& object_type, std::string const& old_primary, std::string const& new_primary);
+        std::string old_primary() const { return m_old_primary; }
+        std::string new_primary() const { return m_new_primary; }
+      private:
+        std::string m_old_primary, m_new_primary;
+    };
+
+    class InvalidPrimaryKeyException : public ObjectSchemaValidationException {
+      public:
+        InvalidPrimaryKeyException(std::string const& object_type, std::string const& primary_key);
+        std::string primary_key() const { return m_primary_key; }
+      private:
+        std::string m_primary_key;
+    };
+
+    class InvalidLinkingObjectsPropertyException : public ObjectSchemaPropertyException {
+    public:
+        enum class Type {
+            OriginPropertyDoesNotExist,
+            OriginPropertyIsNotALink,
+            OriginPropertyInvalidLinkTarget,
+        };
+        InvalidLinkingObjectsPropertyException(Type error_type, std::string const& object_type, Property const& property);
+    };
+}
+
+#endif /* defined(REALM_OBJECT_STORE_HPP) */
diff --git a/Pods/Realm/include/property.hpp b/Pods/Realm/include/property.hpp
new file mode 100644
index 0000000..12c7fc5
--- /dev/null
+++ b/Pods/Realm/include/property.hpp
@@ -0,0 +1,105 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2015 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#ifndef REALM_PROPERTY_HPP
+#define REALM_PROPERTY_HPP
+
+#include <string>
+
+namespace realm {
+    enum class PropertyType {
+        Int    = 0,
+        Bool   = 1,
+        Float  = 9,
+        Double = 10,
+        String = 2,
+        Data   = 4,
+        Any    = 6, // Deprecated
+        Date   = 8,
+        Object = 12,
+        Array  = 13,
+        LinkingObjects = 14,
+    };
+
+    static inline const char *string_for_property_type(PropertyType type) {
+        switch (type) {
+            case PropertyType::String:
+                return "string";
+            case PropertyType::Int:
+                return "int";
+            case PropertyType::Bool:
+                return "bool";
+            case PropertyType::Date:
+                return "date";
+            case PropertyType::Data:
+                return "data";
+            case PropertyType::Double:
+                return "double";
+            case PropertyType::Float:
+                return "float";
+            case PropertyType::Any:
+                return "any";
+            case PropertyType::Object:
+                return "object";
+            case PropertyType::Array:
+                return "array";
+            case PropertyType::LinkingObjects:
+                return "linking objects";
+        }
+    }
+
+    struct Property {
+        std::string name;
+        PropertyType type;
+        std::string object_type;
+        std::string link_origin_property_name;
+        bool is_primary = false;
+        bool is_indexed = false;
+        bool is_nullable = false;
+
+        size_t table_column = -1;
+        bool requires_index() const { return is_primary || is_indexed; }
+        bool is_indexable() const {
+            return type == PropertyType::Int
+                || type == PropertyType::Bool
+                || type == PropertyType::String
+                || type == PropertyType::Date;
+        }
+        std::string type_string() const {
+            switch(type) {
+                case PropertyType::String:
+                case PropertyType::Int:
+                case PropertyType::Bool:
+                case PropertyType::Date:
+                case PropertyType::Data:
+                case PropertyType::Double:
+                case PropertyType::Float:
+                case PropertyType::Any:
+                    return string_for_property_type(type);
+                case PropertyType::Object:
+                    return "<" + object_type + ">";
+                case PropertyType::Array:
+                    return "array<" + object_type + ">";
+                case PropertyType::LinkingObjects:
+                    return "linking objects<" + object_type + ">";
+            }
+        }
+    };
+}
+
+#endif /* REALM_PROPERTY_HPP */
diff --git a/Pods/Realm/include/results.hpp b/Pods/Realm/include/results.hpp
new file mode 100644
index 0000000..670b75c
--- /dev/null
+++ b/Pods/Realm/include/results.hpp
@@ -0,0 +1,218 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2015 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#ifndef REALM_RESULTS_HPP
+#define REALM_RESULTS_HPP
+
+#include "collection_notifications.hpp"
+#include "shared_realm.hpp"
+#include "impl/collection_notifier.hpp"
+
+#include <realm/table_view.hpp>
+#include <realm/util/optional.hpp>
+
+namespace realm {
+template<typename T> class BasicRowExpr;
+using RowExpr = BasicRowExpr<Table>;
+class Mixed;
+
+namespace _impl {
+    class ResultsNotifier;
+}
+
+struct SortOrder {
+    std::vector<size_t> column_indices;
+    std::vector<bool> ascending;
+
+    explicit operator bool() const { return !column_indices.empty(); }
+};
+
+class Results {
+public:
+    // Results can be either be backed by nothing, a thin wrapper around a table,
+    // or a wrapper around a query and a sort order which creates and updates
+    // the tableview as needed
+    Results();
+    Results(SharedRealm r, SortOrder s, TableView tv);
+    Results(SharedRealm r, Table& table);
+    Results(SharedRealm r, Query q, SortOrder s = {});
+    Results(SharedRealm r, LinkViewRef lv, util::Optional<Query> q = {}, SortOrder s = {});
+    ~Results();
+
+    // Results is copyable and moveable
+    Results(Results const&);
+    Results(Results&&);
+    Results& operator=(Results const&);
+    Results& operator=(Results&&);
+
+    // Get a query which will match the same rows as is contained in this Results
+    // Returned query will not be valid if the current mode is Empty
+    Query get_query() const;
+
+    // Get the currently applied sort order for this Results
+    SortOrder const& get_sort() const noexcept { return m_sort; }
+
+    // Get a tableview containing the same rows as this Results
+    TableView get_tableview();
+
+    // Get the object type which will be returned by get()
+    StringData get_object_type() const noexcept;
+
+    // Get the LinkView this Results is derived from, if any
+    LinkViewRef get_linkview() const { return m_link_view; }
+
+    // Get the size of this results
+    // Can be either O(1) or O(N) depending on the state of things
+    size_t size();
+
+    // Get the row accessor for the given index
+    // Throws OutOfBoundsIndexException if index >= size()
+    RowExpr get(size_t index);
+
+    // Get a row accessor for the first/last row, or none if the results are empty
+    // More efficient than calling size()+get()
+    util::Optional<RowExpr> first();
+    util::Optional<RowExpr> last();
+
+    // Get the first index of the given row in this results, or not_found
+    // Throws DetachedAccessorException if row is not attached
+    // Throws IncorrectTableException if row belongs to a different table
+    size_t index_of(size_t row_ndx);
+    size_t index_of(Row const& row);
+
+    // Delete all of the rows in this Results from the Realm
+    // size() will always be zero afterwards
+    // Throws InvalidTransactionException if not in a write transaction
+    void clear();
+
+    // Create a new Results by further filtering or sorting this Results
+    Results filter(Query&& q) const;
+    Results sort(SortOrder&& sort) const;
+
+    // Get the min/max/average/sum of the given column
+    // All but sum() returns none when there are zero matching rows
+    // sum() returns 0, except for when it returns none
+    // Throws UnsupportedColumnTypeException for sum/average on timestamp or non-numeric column
+    // Throws OutOfBoundsIndexException for an out-of-bounds column
+    util::Optional<Mixed> max(size_t column);
+    util::Optional<Mixed> min(size_t column);
+    util::Optional<Mixed> average(size_t column);
+    util::Optional<Mixed> sum(size_t column);
+
+    enum class Mode {
+        Empty, // Backed by nothing (for missing tables)
+        Table, // Backed directly by a Table
+        Query, // Backed by a query that has not yet been turned into a TableView
+        LinkView, // Backed directly by a LinkView
+        TableView // Backed by a TableView created from a Query
+    };
+    // Get the currrent mode of the Results
+    // Ideally this would not be public but it's needed for some KVO stuff
+    Mode get_mode() const { return m_mode; }
+
+    // Is this Results associated with a Realm that has not been invalidated?
+    bool is_valid() const;
+
+    // The Results object has been invalidated (due to the Realm being invalidated)
+    // All non-noexcept functions can throw this
+    struct InvalidatedException : public std::runtime_error {
+        InvalidatedException() : std::runtime_error("Access to invalidated Results objects") {}
+    };
+
+    // The input index parameter was out of bounds
+    struct OutOfBoundsIndexException : public std::out_of_range {
+        OutOfBoundsIndexException(size_t r, size_t c);
+        const size_t requested;
+        const size_t valid_count;
+    };
+
+    // The input Row object is not attached
+    struct DetatchedAccessorException : public std::runtime_error {
+        DetatchedAccessorException() : std::runtime_error("Atempting to access an invalid object") {}
+    };
+
+    // The input Row object belongs to a different table
+    struct IncorrectTableException : public std::runtime_error {
+        IncorrectTableException(StringData e, StringData a, const std::string &error)
+        : std::runtime_error(error), expected(e), actual(a) {}
+        const StringData expected;
+        const StringData actual;
+    };
+
+    // The requested aggregate operation is not supported for the column type
+    struct UnsupportedColumnTypeException : public std::runtime_error {
+        size_t column_index;
+        StringData column_name;
+        DataType column_type;
+
+        UnsupportedColumnTypeException(size_t column, const Table* table, const char* operation);
+    };
+
+    SharedRealm get_realm() const { return m_realm; }
+
+    // Create an async query from this Results
+    // The query will be run on a background thread and delivered to the callback,
+    // and then rerun after each commit (if needed) and redelivered if it changed
+    NotificationToken async(std::function<void (std::exception_ptr)> target);
+    NotificationToken add_notification_callback(CollectionChangeCallback cb);
+
+    bool wants_background_updates() const { return m_wants_background_updates; }
+
+    // Returns whether the rows are guaranteed to be in table order.
+    bool is_in_table_order() const;
+
+    // Helper type to let ResultsNotifier update the tableview without giving access
+    // to any other privates or letting anyone else do so
+    class Internal {
+        friend class _impl::ResultsNotifier;
+        static void set_table_view(Results& results, TableView&& tv);
+    };
+
+private:
+    SharedRealm m_realm;
+    Query m_query;
+    TableView m_table_view;
+    LinkViewRef m_link_view;
+    Table* m_table = nullptr;
+    SortOrder m_sort;
+
+    _impl::CollectionNotifier::Handle<_impl::ResultsNotifier> m_notifier;
+
+    Mode m_mode = Mode::Empty;
+    bool m_has_used_table_view = false;
+    bool m_wants_background_updates = true;
+
+    void update_tableview();
+    bool update_linkview();
+
+    void validate_read() const;
+    void validate_write() const;
+
+    void prepare_async();
+
+    template<typename Int, typename Float, typename Double, typename Timestamp>
+    util::Optional<Mixed> aggregate(size_t column, bool return_none_for_empty,
+                                    const char* name,
+                                    Int agg_int, Float agg_float,
+                                    Double agg_double, Timestamp agg_timestamp);
+
+    void set_table_view(TableView&& tv);
+};
+}
+
+#endif /* REALM_RESULTS_HPP */
diff --git a/Pods/Realm/include/schema.hpp b/Pods/Realm/include/schema.hpp
new file mode 100644
index 0000000..30ee153
--- /dev/null
+++ b/Pods/Realm/include/schema.hpp
@@ -0,0 +1,57 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2015 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#ifndef REALM_SCHEMA_HPP
+#define REALM_SCHEMA_HPP
+
+#include <string>
+#include <vector>
+
+namespace realm {
+class ObjectSchema;
+
+class Schema : private std::vector<ObjectSchema> {
+private:
+    using base = std::vector<ObjectSchema>;
+public:
+    // Create a schema from a vector of ObjectSchema
+    Schema(base types);
+    Schema(std::initializer_list<ObjectSchema> types);
+
+    // find an ObjectSchema by name
+    iterator find(std::string const& name);
+    const_iterator find(std::string const& name) const;
+
+    // find an ObjectSchema with the same name as the passed in one
+    iterator find(ObjectSchema const& object) noexcept;
+    const_iterator find(ObjectSchema const& object) const noexcept;
+
+    // Verify that this schema is internally consistent (i.e. all properties are
+    // valid, links link to types that actually exist, etc.)
+    void validate() const;
+
+    using base::iterator;
+    using base::const_iterator;
+    using base::begin;
+    using base::end;
+    using base::empty;
+    using base::size;
+};
+}
+
+#endif /* defined(REALM_SCHEMA_HPP) */
diff --git a/Pods/Realm/include/shared_realm.hpp b/Pods/Realm/include/shared_realm.hpp
new file mode 100644
index 0000000..8111bd4
--- /dev/null
+++ b/Pods/Realm/include/shared_realm.hpp
@@ -0,0 +1,256 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2015 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#ifndef REALM_REALM_HPP
+#define REALM_REALM_HPP
+
+#include <memory>
+#include <string>
+#include <thread>
+#include <vector>
+
+namespace realm {
+    class BinaryData;
+    class BindingContext;
+    class Group;
+    class Realm;
+    class Replication;
+    class Schema;
+    class SharedGroup;
+    class StringData;
+    typedef std::shared_ptr<Realm> SharedRealm;
+    typedef std::weak_ptr<Realm> WeakRealm;
+
+    namespace _impl {
+        class CollectionNotifier;
+        class ListNotifier;
+        class RealmCoordinator;
+        class ResultsNotifier;
+    }
+
+    namespace util {
+        template<typename T> class Optional;
+    }
+
+    class Realm : public std::enable_shared_from_this<Realm> {
+      public:
+        typedef std::function<void(SharedRealm old_realm, SharedRealm realm)> MigrationFunction;
+
+        struct Config {
+            std::string path;
+            // User-supplied encryption key. Must be either empty or 64 bytes.
+            std::vector<char> encryption_key;
+
+            // Optional schema for the file. If nullptr, the existing schema
+            // from the file opened will be used. If present, the file will be
+            // migrated to the schema if needed.
+            std::unique_ptr<Schema> schema;
+            uint64_t schema_version;
+
+            MigrationFunction migration_function;
+            bool delete_realm_if_migration_needed = false;
+
+            bool read_only = false;
+            bool in_memory = false;
+
+            // The following are intended for internal/testing purposes and
+            // should not be publicly exposed in binding APIs
+
+            // If false, always return a new Realm instance, and don't return
+            // that Realm instance for other requests for a cached Realm. Useful
+            // for dynamic Realms and for tests that need multiple instances on
+            // one thread
+            bool cache = true;
+            // Throw an exception rather than automatically upgrading the file
+            // format. Used by the browser to warn the user that it'll modify
+            // the file.
+            bool disable_format_upgrade = false;
+            // Disable the background worker thread for producing change
+            // notifications. Useful for tests for those notifications so that
+            // everything can be done deterministically on one thread, and
+            // speeds up tests that don't need notifications.
+            bool automatic_change_notifications = true;
+
+            Config();
+            Config(Config&&);
+            Config(const Config& c);
+            ~Config();
+
+            Config& operator=(Config const&);
+            Config& operator=(Config&&) = default;
+        };
+
+        // Get a cached Realm or create a new one if no cached copies exists
+        // Caching is done by path - mismatches for in_memory and read_only
+        // Config properties will raise an exception
+        // If schema/schema_version is specified, update_schema is called
+        // automatically on the realm and a migration is performed. If not
+        // specified, the schema version and schema are dynamically read from
+        // the the existing Realm.
+        static SharedRealm get_shared_realm(Config config);
+
+        // Updates a Realm to a given target schema/version creating tables and
+        // updating indexes as necessary. Uses the existing migration function
+        // on the Config, and the resulting Schema and version with updated
+        // column mappings are set on the realms config upon success.
+        void update_schema(std::unique_ptr<Schema> schema, uint64_t version);
+
+        static uint64_t get_schema_version(Config const& config);
+
+        const Config &config() const { return m_config; }
+
+        void begin_transaction();
+        void commit_transaction();
+        void cancel_transaction();
+        bool is_in_transaction() const noexcept;
+        bool is_in_read_transaction() const { return !!m_group; }
+
+        bool refresh();
+        void set_auto_refresh(bool auto_refresh) { m_auto_refresh = auto_refresh; }
+        bool auto_refresh() const { return m_auto_refresh; }
+        void notify();
+
+        void invalidate();
+        bool compact();
+        void write_copy(StringData path, BinaryData encryption_key);
+
+        std::thread::id thread_id() const { return m_thread_id; }
+        void verify_thread() const;
+        void verify_in_write() const;
+
+        bool can_deliver_notifications() const noexcept;
+
+        // Close this Realm and remove it from the cache. Continuing to use a
+        // Realm after closing it will produce undefined behavior.
+        void close();
+
+        bool is_closed() { return !m_read_only_group && !m_shared_group; }
+
+        // returns the file format version upgraded from if an upgrade took place
+        util::Optional<int> file_format_upgraded_from_version() const;
+
+        ~Realm();
+
+        void init(std::shared_ptr<_impl::RealmCoordinator> coordinator);
+        Realm(Config config);
+
+        // Expose some internal functionality to other parts of the ObjectStore
+        // without making it public to everyone
+        class Internal {
+            friend class _impl::CollectionNotifier;
+            friend class _impl::ListNotifier;
+            friend class _impl::RealmCoordinator;
+            friend class _impl::ResultsNotifier;
+
+            // ResultsNotifier and ListNotifier need access to the SharedGroup
+            // to be able to call the handover functions, which are not very wrappable
+            static SharedGroup& get_shared_group(Realm& realm) { return *realm.m_shared_group; }
+
+            // CollectionNotifier needs to be able to access the owning
+            // coordinator to wake up the worker thread when a callback is
+            // added, and coordinators need to be able to get themselves from a Realm
+            static _impl::RealmCoordinator& get_coordinator(Realm& realm) { return *realm.m_coordinator; }
+        };
+
+        static void open_with_config(const Config& config,
+                                     std::unique_ptr<Replication>& history,
+                                     std::unique_ptr<SharedGroup>& shared_group,
+                                     std::unique_ptr<Group>& read_only_group,
+                                     Realm *realm = nullptr);
+
+      private:
+        Config m_config;
+        std::thread::id m_thread_id = std::this_thread::get_id();
+        bool m_auto_refresh = true;
+
+        std::unique_ptr<Replication> m_history;
+        std::unique_ptr<SharedGroup> m_shared_group;
+        std::unique_ptr<Group> m_read_only_group;
+
+        Group *m_group = nullptr;
+
+        std::shared_ptr<_impl::RealmCoordinator> m_coordinator;
+
+        // File format versions populated when a file format upgrade takes place during realm opening
+        int upgrade_initial_version = 0, upgrade_final_version = 0;
+
+      public:
+        std::unique_ptr<BindingContext> m_binding_context;
+
+        // FIXME private
+        Group *read_group();
+    };
+
+    class RealmFileException : public std::runtime_error {
+    public:
+        enum class Kind {
+            /** Thrown for any I/O related exception scenarios when a realm is opened. */
+            AccessError,
+            /** Thrown if the user does not have permission to open or create
+             the specified file in the specified access mode when the realm is opened. */
+            PermissionDenied,
+            /** Thrown if create_Always was specified and the file did already exist when the realm is opened. */
+            Exists,
+            /** Thrown if no_create was specified and the file was not found when the realm is opened. */
+            NotFound,
+            /** Thrown if the database file is currently open in another
+             process which cannot share with the current process due to an
+             architecture mismatch. */
+            IncompatibleLockFile,
+            /** Thrown if the file needs to be upgraded to a new format, but upgrades have been explicitly disabled. */
+            FormatUpgradeRequired,
+        };
+        RealmFileException(Kind kind, std::string path, std::string message, std::string underlying) :
+            std::runtime_error(std::move(message)), m_kind(kind), m_path(std::move(path)), m_underlying(std::move(underlying)) {}
+        Kind kind() const { return m_kind; }
+        const std::string& path() const { return m_path; }
+        const std::string& underlying() const { return m_underlying; }
+
+    private:
+        Kind m_kind;
+        std::string m_path;
+        std::string m_underlying;
+    };
+
+    class MismatchedConfigException : public std::runtime_error {
+    public:
+        MismatchedConfigException(StringData message, StringData path);
+    };
+
+    class InvalidTransactionException : public std::runtime_error {
+    public:
+        InvalidTransactionException(std::string message) : std::runtime_error(move(message)) {}
+    };
+
+    class IncorrectThreadException : public std::runtime_error {
+    public:
+        IncorrectThreadException() : std::runtime_error("Realm accessed from incorrect thread.") {}
+    };
+
+    class UninitializedRealmException : public std::runtime_error {
+    public:
+        UninitializedRealmException(std::string message) : std::runtime_error(move(message)) {}
+    };
+
+    class InvalidEncryptionKeyException : public std::runtime_error {
+    public:
+        InvalidEncryptionKeyException() : std::runtime_error("Encryption key must be 64 bytes.") {}
+    };
+}
+
+#endif /* defined(REALM_REALM_HPP) */
diff --git a/Pods/Realm/include/util/atomic_shared_ptr.hpp b/Pods/Realm/include/util/atomic_shared_ptr.hpp
new file mode 100644
index 0000000..0ec541e
--- /dev/null
+++ b/Pods/Realm/include/util/atomic_shared_ptr.hpp
@@ -0,0 +1,137 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2016 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#ifndef REALM_ATOMIC_SHARED_PTR_HPP
+#define REALM_ATOMIC_SHARED_PTR_HPP
+
+#include <atomic>
+#include <memory>
+#include <mutex>
+
+namespace realm {
+namespace _impl {
+
+// Check if std::atomic_load has an overload taking a std::shared_ptr, and set
+// HasAtomicPtrOps to either true_type or false_type
+
+template<typename... Ts> struct make_void { typedef void type; };
+template<typename... Ts> using void_t = typename make_void<Ts...>::type;
+
+template<typename, typename = void_t<>>
+struct HasAtomicPtrOps : std::false_type { };
+
+template<class T>
+struct HasAtomicPtrOps<T, void_t<decltype(std::atomic_load(std::declval<T*>()))>> : std::true_type { };
+} // namespace _impl
+
+namespace util {
+// A wrapper for std::shared_ptr that enables sharing a shared_ptr instance
+// (and not just a thing *pointed to* by a shared_ptr) between threads. Is
+// lock-free iff the underlying shared_ptr implementation supports atomic
+// operations. Currently the only implemented operation other than copy/move
+// construction/assignment is exchange().
+template<typename T, bool = _impl::HasAtomicPtrOps<std::shared_ptr<T>>::value>
+class AtomicSharedPtr;
+
+template<typename T>
+class AtomicSharedPtr<T, true> {
+public:
+    AtomicSharedPtr() = default;
+    AtomicSharedPtr(std::shared_ptr<T> ptr) : m_ptr(std::move(ptr)) { }
+
+    AtomicSharedPtr(AtomicSharedPtr const& ptr) : m_ptr(std::atomic_load(&ptr.m_ptr)) { }
+    AtomicSharedPtr(AtomicSharedPtr&& ptr) : m_ptr(std::atomic_exchange(&ptr.m_ptr, {})) { }
+
+    AtomicSharedPtr& operator=(AtomicSharedPtr const& ptr)
+    {
+        if (&ptr != this) {
+            std::atomic_store(&m_ptr, std::atomic_load(&ptr.m_ptr));
+        }
+        return *this;
+    }
+
+    AtomicSharedPtr& operator=(AtomicSharedPtr&& ptr)
+    {
+        std::atomic_store(&m_ptr, std::atomic_exchange(&ptr.m_ptr, {}));
+        return *this;
+    }
+
+    std::shared_ptr<T> exchange(std::shared_ptr<T> ptr)
+    {
+        return std::atomic_exchange(&m_ptr, std::move(ptr));
+    }
+
+private:
+    std::shared_ptr<T> m_ptr = nullptr;
+};
+
+template<typename T>
+class AtomicSharedPtr<T, false> {
+public:
+    AtomicSharedPtr() = default;
+    AtomicSharedPtr(std::shared_ptr<T> ptr) : m_ptr(std::move(ptr)) { }
+
+    AtomicSharedPtr(AtomicSharedPtr const& ptr)
+    {
+        std::lock_guard<std::mutex> lock(ptr.m_mutex);
+        m_ptr = ptr.m_ptr;
+    }
+    AtomicSharedPtr(AtomicSharedPtr&& ptr)
+    {
+        std::lock_guard<std::mutex> lock(ptr.m_mutex);
+        m_ptr = std::move(ptr.m_ptr);
+    }
+
+    AtomicSharedPtr& operator=(AtomicSharedPtr const& ptr)
+    {
+        if (&ptr != this) {
+            // std::lock() ensures that these are locked in a consistent order
+            // to avoid deadlock
+            std::lock(m_mutex, ptr.m_mutex);
+            m_ptr = ptr.m_ptr;
+            m_mutex.unlock();
+            ptr.m_mutex.unlock();
+        }
+        return *this;
+    }
+
+    AtomicSharedPtr& operator=(AtomicSharedPtr&& ptr)
+    {
+        std::lock(m_mutex, ptr.m_mutex);
+        m_ptr = std::move(ptr.m_ptr);
+        m_mutex.unlock();
+        ptr.m_mutex.unlock();
+        return *this;
+    }
+
+    std::shared_ptr<T> exchange(std::shared_ptr<T> ptr)
+    {
+        std::lock_guard<std::mutex> lock(m_mutex);
+        m_ptr.swap(ptr);
+        return ptr;
+    }
+
+private:
+    std::mutex m_mutex;
+    std::shared_ptr<T> m_ptr = nullptr;
+};
+
+}
+}
+
+#endif // REALM_ASYNC_QUERY_HPP
diff --git a/Pods/Realm/include/util/format.hpp b/Pods/Realm/include/util/format.hpp
new file mode 100644
index 0000000..8bf9a5d
--- /dev/null
+++ b/Pods/Realm/include/util/format.hpp
@@ -0,0 +1,75 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2016 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+#ifndef REALM_UTIL_FORMAT_HPP
+#define REALM_UTIL_FORMAT_HPP
+
+#include <cstdint>
+#include <iosfwd>
+#include <initializer_list>
+#include <string>
+
+namespace realm {
+class StringData;
+
+namespace _impl {
+class Printable {
+public:
+    Printable(bool value) : m_type(Type::Bool), m_uint(value) { }
+    Printable(unsigned char value) : m_type(Type::Uint), m_uint(value) { }
+    Printable(unsigned int value) : m_type(Type::Uint), m_uint(value) { }
+    Printable(unsigned long value) : m_type(Type::Uint), m_uint(value) { }
+    Printable(unsigned long long value) : m_type(Type::Uint), m_uint(value) { }
+    Printable(char value) : m_type(Type::Int), m_int(value) { }
+    Printable(int value) : m_type(Type::Int), m_int(value) { }
+    Printable(long value) : m_type(Type::Int), m_int(value) { }
+    Printable(long long value) : m_type(Type::Int), m_int(value) { }
+    Printable(const char* value) : m_type(Type::String), m_string(value) { }
+    Printable(std::string const& value) : m_type(Type::String), m_string(value.c_str()) { }
+    Printable(StringData value);
+
+    void print(std::ostream& out) const;
+
+private:
+    enum class Type {
+        Bool,
+        Int,
+        Uint,
+        String
+    } m_type;
+
+    union {
+        uintmax_t m_uint;
+        intmax_t m_int;
+        const char* m_string;
+    };
+};
+std::string format(const char* fmt, std::initializer_list<Printable>);
+} // namespace _impl
+
+namespace util {
+template<typename... Args>
+std::string format(const char* fmt, Args&&... args)
+{
+    return _impl::format(fmt, {_impl::Printable(args)...});
+}
+
+} // namespace util
+} // namespace realm
+
+#endif // REALM_UTIL_FORMAT_HPP
diff --git a/Pods/RealmSwift/LICENSE b/Pods/RealmSwift/LICENSE
new file mode 100644
index 0000000..a194346
--- /dev/null
+++ b/Pods/RealmSwift/LICENSE
@@ -0,0 +1,269 @@
+TABLE OF CONTENTS
+
+1. Apache License version 2.0
+2. Realm Components
+3. Export Compliance
+
+-------------------------------------------------------------------------------
+
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "{}"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright {yyyy} {name of copyright owner}
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+
+REALM COMPONENTS
+
+This software contains components with separate copyright and license terms.
+Your use of these components is subject to the terms and conditions of the
+following licenses.
+
+For the Realm Core component
+
+  Realm Core Binary License
+
+  Copyright (c) 2011-2014 Realm Inc All rights reserved
+
+  Redistribution and use in binary form, with or without modification, is
+  permitted provided that the following conditions are met:
+
+  1. You agree not to attempt to decompile, disassemble, reverse engineer or
+  otherwise discover the source code from which the binary code was derived.
+  You may, however, access and obtain a separate license for most of the
+  source code from which this Software was created, at
+  http://realm.io/pricing/.
+
+  2. Redistributions in binary form must reproduce the above copyright notice,
+  this list of conditions and the following disclaimer in the documentation
+  and/or other materials provided with the distribution.
+
+  3. Neither the name of the copyright holder nor the names of its
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+  POSSIBILITY OF SUCH DAMAGE.
+
+EXPORT COMPLIANCE
+
+You understand that the Software may contain cryptographic functions that may be
+subject to export restrictions, and you represent and warrant that you are not
+located in a country that is subject to United States export restriction or embargo,
+including Cuba, Iran, North Korea, Sudan, Syria or the Crimea region, and that you
+are not on the Department of Commerce list of Denied Persons, Unverified Parties,
+or affiliated with a Restricted Entity.
+
+You agree to comply with all export, re-export and import restrictions and
+regulations of the Department of Commerce or other agency or authority of the
+United States or other applicable countries. You also agree not to transfer, or
+authorize the transfer of, directly or indirectly, the Software to any prohibited
+country, including Cuba, Iran, North Korea, Sudan, Syria or the Crimea region,
+or to any person or organization on or affiliated with the Department of
+Commerce lists of Denied Persons, Unverified Parties or Restricted Entities, or
+otherwise in violation of any such restrictions or regulations.
diff --git a/Pods/RealmSwift/README.md b/Pods/RealmSwift/README.md
new file mode 100644
index 0000000..322ac2d
--- /dev/null
+++ b/Pods/RealmSwift/README.md
@@ -0,0 +1,72 @@
+![Realm](https://github.com/realm/realm-cocoa/raw/master/logo.png)
+
+Realm is a mobile database that runs directly inside phones, tablets or wearables.
+This repository holds the source code for the iOS, OS X, watchOS & tvOS versions of Realm Swift & Realm Objective-C.
+
+## Features
+
+* **Mobile-first:** Realm is the first database built from the ground up to run directly inside phones, tablets and wearables.
+* **Simple:** Data is directly [exposed as objects](https://realm.io/docs/objc/latest/#models) and [queryable by code](https://realm.io/docs/objc/latest/#queries), removing the need for ORM's riddled with performance & maintenance issues. Most of our users pick it up intuitively, getting simple apps up & running in minutes.
+* **Modern:** Realm supports relationships, generics, vectorization and even Swift.
+* **Fast:** Realm is faster than even raw SQLite on common operations, while maintaining an extremely rich feature set.
+
+## Getting Started
+
+Please see the detailed instructions in our docs to add [Realm Objective-C](https://realm.io/docs/objc/latest/#installation) _or_ [Realm Swift](https://realm.io/docs/swift/latest/#installation) to your Xcode project.
+
+## Documentation
+
+### Realm Objective-C
+
+The documentation can be found at [realm.io/docs/objc/latest](https://realm.io/docs/objc/latest).  
+The API reference is located at [realm.io/docs/objc/latest/api](https://realm.io/docs/objc/latest/api).
+
+### Realm Swift
+
+The documentation can be found at [realm.io/docs/swift/latest](https://realm.io/docs/swift/latest).  
+The API reference is located at [realm.io/docs/swift/latest/api](https://realm.io/docs/swift/latest/api).
+
+## Getting Help
+
+- **Need help with your code?**: Look for previous questions on the  [#realm tag](https://stackoverflow.com/questions/tagged/realm?sort=newest) — or [ask a new question](https://stackoverflow.com/questions/ask?tags=realm). We actively monitor & answer questions on SO!
+- **Have a bug to report?** [Open an issue](https://github.com/realm/realm-cocoa/issues/new). If possible, include the version of Realm, a full log, the Realm file, and a project that shows the issue.
+- **Have a feature request?** [Open an issue](https://github.com/realm/realm-cocoa/issues/new). Tell us what the feature should do, and why you want the feature.
+- Sign up for our [**Community Newsletter**](http://eepurl.com/VEKCn) to get regular tips, learn about other use-cases and get alerted of blogposts and tutorials about Realm.
+
+## Building Realm
+
+In case you don't want to use the precompiled version, you can build Realm yourself from source.
+
+Prerequisites:
+
+* Building Realm requires Xcode 7.3.
+* Building Realm documentation requires [jazzy](https://github.com/realm/jazzy)
+
+Once you have all the necessary prerequisites, building Realm.framework just takes a single command: `sh build.sh build`. You'll need an internet connection the first time you build Realm to download the core binary.
+
+Run `sh build.sh help` to see all the actions you can perform (build ios/osx, generate docs, test, etc.).
+
+## Contributing
+
+See [CONTRIBUTING.md](CONTRIBUTING.md) for more details!
+
+This project adheres to the [Contributor Covenant Code of Conduct](https://realm.io/conduct).
+By participating, you are expected to uphold this code. Please report
+unacceptable behavior to [info@realm.io](mailto:info@realm.io).
+
+## License
+
+Realm Objective-C & Realm Swift are published under the Apache 2.0 license.  
+The underlying core is available under the [Realm Core Binary License](https://github.com/realm/realm-cocoa/blob/master/LICENSE#L210-L243) while we [work to open-source it under the Apache 2.0 license](https://realm.io/docs/objc/latest/#faq).
+
+**This product is not being made available to any person located in Cuba, Iran,
+North Korea, Sudan, Syria or the Crimea region, or to any other person that is
+not eligible to receive the product under U.S. law.**
+
+## Feedback
+
+**_If you use Realm and are happy with it, all we ask is that you please consider sending out a tweet mentioning [@realm](https://twitter.com/realm) or email [help@realm.io](mailto:help@realm.io) to share your thoughts!_**
+
+**_And if you don't like it, please let us know what you would like improved, so we can fix it!_**
+
+![analytics](https://ga-beacon.appspot.com/UA-50247013-2/realm-cocoa/README?pixel)
diff --git a/Pods/RealmSwift/RealmSwift/Aliases.swift b/Pods/RealmSwift/RealmSwift/Aliases.swift
new file mode 100644
index 0000000..a232b90
--- /dev/null
+++ b/Pods/RealmSwift/RealmSwift/Aliases.swift
@@ -0,0 +1,57 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+import Foundation
+import Realm
+
+// These types don't change when wrapping in Swift
+// so we just typealias them to remove the 'RLM' prefix
+
+// MARK: Aliases
+
+/**
+ `PropertyType` is an enum describing all property types supported in Realm models.
+
+ For more information, see [Realm Models](https://realm.io/docs/swift/latest/#models).
+
+ ### Primitive types
+
+ * `Int`
+ * `Bool`
+ * `Float`
+ * `Double`
+
+ ### Object types
+
+ * `String`
+ * `Data`
+ * `Date`
+
+ ### Relationships: Array (in Swift, `List`) and `Object` types
+
+ * `Object`
+ * `Array`
+*/
+public typealias PropertyType = RLMPropertyType
+
+/**
+ An opaque token which is returned from methods which subscribe to changes to a Realm.
+
+ - see: `addNotificationBlock(_:)`
+ */
+public typealias NotificationToken = RLMNotificationToken
diff --git a/Pods/RealmSwift/RealmSwift/Error.swift b/Pods/RealmSwift/RealmSwift/Error.swift
new file mode 100644
index 0000000..b9f553b
--- /dev/null
+++ b/Pods/RealmSwift/RealmSwift/Error.swift
@@ -0,0 +1,243 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+import Realm
+
+#if swift(>=3.0)
+
+/**
+Enumeration that describes the error codes within the Realm error domain.
+The values can be used to catch a variety of _recoverable_ errors, especially those
+happening when initializing a Realm instance.
+
+    let realm: Realm?
+    do {
+        realm = Realm()
+    } catch RealmSwift.Error.IncompatibleLockFile() {
+        print("Realm Browser app may be attached to Realm on device?")
+    }
+
+*/
+public enum Error: ErrorProtocol {
+    // swiftlint:disable variable_name
+    /// :nodoc:
+    public var _code: Int {
+        return rlmError.rawValue
+    }
+
+    /// :nodoc:
+    public var _domain: String {
+        return RLMErrorDomain
+    }
+    // swiftlint:enable variable_name
+
+    /// The RLMError value, which can be used to derive the error's code.
+    private var rlmError: RLMError {
+        switch self {
+        case .Fail:
+            return .fail
+        case .FileAccess:
+            return .fileAccess
+        case .FilePermissionDenied:
+            return .filePermissionDenied
+        case .FileExists:
+            return .fileExists
+        case .FileNotFound:
+            return .fileNotFound
+        case .IncompatibleLockFile:
+            return .incompatibleLockFile
+        case .FileFormatUpgradeRequired:
+            return .fileFormatUpgradeRequired
+        case .AddressSpaceExhausted:
+            return .addressSpaceExhausted
+        case .SchemaMismatch:
+            return .schemaMismatch
+        }
+    }
+
+    /// Error thrown by Realm if no other specific error is returned when a realm is opened.
+    case Fail
+
+    /// Error thrown by Realm for any I/O related exception scenarios when a realm is opened.
+    case FileAccess
+
+    /// Error thrown by Realm if the user does not have permission to open or create
+    /// the specified file in the specified access mode when the realm is opened.
+    case FilePermissionDenied
+
+    /// Error thrown by Realm if the file already exists when a copy should be written.
+    case FileExists
+
+    /// Error thrown by Realm if no file was found when a realm was opened as
+    /// read-only or if the directory part of the specified path was not found
+    /// when a copy should be written.
+    case FileNotFound
+
+    /// Error thrown by Realm if the database file is currently open in another process which
+    /// cannot share with the current process due to an architecture mismatch.
+    case IncompatibleLockFile
+
+    /// Error thrown by Realm if a file format upgrade is required to open the file,
+    /// but upgrades were explicitly disabled.
+    case FileFormatUpgradeRequired
+
+    /// Error thrown by Realm if there is insufficient available address space.
+    case AddressSpaceExhausted
+
+    /** Error thrown by Realm if there is a schema version mismatch, so that a migration is required. */
+    case SchemaMismatch
+}
+
+// MARK: Equatable
+
+extension Error: Equatable {}
+
+/// Returns whether the two errors are identical
+public func == (lhs: ErrorProtocol, rhs: ErrorProtocol) -> Bool { // swiftlint:disable:this valid_docs
+    return lhs._code == rhs._code
+        && lhs._domain == rhs._domain
+}
+
+// MARK: Pattern Matching
+
+/**
+Explicitly implement pattern matching for `Realm.Error`, so that the instances can be used in the
+`do … syntax`.
+*/
+public func ~= (lhs: Error, rhs: ErrorProtocol) -> Bool { // swiftlint:disable:this valid_docs
+    return lhs == rhs
+}
+
+#else
+
+/**
+ `Error` is an enum representing all recoverable errors. It is associated with the
+ Realm error domain specified in `RLMErrorDomain`.
+
+ `Error` is a Swift `ErrorType`:
+
+ ```swift
+ let realm: Realm?
+ do {
+     realm = try Realm()
+ } catch RealmSwift.Error.IncompatibleLockFile() {
+     print("Incompatible lock file. The Realm Browser app might be attached to a Realm on the device.")
+ }
+ ```
+*/
+public enum Error: ErrorType {
+    // swiftlint:disable variable_name
+    /// :nodoc:
+    public var _code: Int {
+        return rlmError.rawValue
+    }
+
+    /// :nodoc:
+    public var _domain: String {
+        return RLMErrorDomain
+    }
+    // swiftlint:enable variable_name
+
+    /// The `RLMError` value, which can be used to derive the error code.
+    private var rlmError: RLMError {
+        switch self {
+        case .Fail:
+            return RLMError.Fail
+        case .FileAccess:
+            return RLMError.FileAccess
+        case .FilePermissionDenied:
+            return RLMError.FilePermissionDenied
+        case .FileExists:
+            return RLMError.FileExists
+        case .FileNotFound:
+            return RLMError.FileNotFound
+        case .IncompatibleLockFile:
+            return RLMError.IncompatibleLockFile
+        case .FileFormatUpgradeRequired:
+            return RLMError.FileFormatUpgradeRequired
+        case .AddressSpaceExhausted:
+            return RLMError.AddressSpaceExhausted
+        case .SchemaMismatch:
+            return RLMError.SchemaMismatch
+        }
+    }
+
+    /// Denotes a general error that occurred when trying to open a Realm.
+    case Fail
+
+    /// Denotes a file I/O error that occurred when trying to open a Realm.
+    case FileAccess
+
+    /// Denotes a file permission error that ocurred when trying to open a Realm.
+    ///
+    /// This error can occur if the user does not have permission to open or create
+    /// the specified file in the specified access mode when opening a Realm.
+    case FilePermissionDenied
+
+    /// Denotes an error where a file was to be written to disk, but another file with the same name
+    /// already exists.
+    case FileExists
+
+    /// Denotes an error that occurs if a file could not be found.
+    ///
+    /// This error may occur if a Realm file could not be found on disk when trying to open a
+    /// Realm as read-only, or if the directory part of the specified path was not found when
+    /// trying to write a copy.
+    case FileNotFound
+
+    /// Denotes an error that occurs if the database file is currently open in another
+    /// process which cannot share with the current process due to an
+    /// architecture mismatch.
+    ///
+    /// This error may occur if trying to share a Realm file between an i386 (32-bit) iOS
+    /// Simulator and the Realm Browser application. In this case, please use the 64-bit
+    /// version of the iOS Simulator.
+    case IncompatibleLockFile
+
+    /// Denotes an error that occurs if a file format upgrade is required to open the file,
+    /// but upgrades were explicitly disabled.
+    case FileFormatUpgradeRequired
+
+    /// Denotes an error that occurs when there is insufficient available address space.
+    case AddressSpaceExhausted
+
+    /// Denotes an error that occurs if there is a schema version mismatch, so that a migration is required.
+    case SchemaMismatch
+}
+
+// MARK: Equatable
+
+extension Error: Equatable {}
+
+/// Returns a Boolean indicating whether the errors are identical.
+public func == (lhs: ErrorType, rhs: ErrorType) -> Bool { // swiftlint:disable:this valid_docs
+    return lhs._code == rhs._code
+        && lhs._domain == rhs._domain
+}
+
+// MARK: Pattern Matching
+
+/**
+ Pattern matching matching for `Realm.Error`, so that the instances can be used with Swift's
+ `do { ... } catch { ... }` syntax.
+*/
+public func ~= (lhs: Error, rhs: ErrorType) -> Bool { // swiftlint:disable:this valid_docs
+    return lhs == rhs
+}
+
+#endif
diff --git a/Pods/RealmSwift/RealmSwift/LinkingObjects.swift b/Pods/RealmSwift/RealmSwift/LinkingObjects.swift
new file mode 100644
index 0000000..95104e2
--- /dev/null
+++ b/Pods/RealmSwift/RealmSwift/LinkingObjects.swift
@@ -0,0 +1,864 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2016 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+import Foundation
+import Realm
+
+#if swift(>=3.0)
+
+/// :nodoc:
+/// Internal class. Do not use directly. Used for reflection and initialization
+public class LinkingObjectsBase: NSObject, NSFastEnumeration {
+    internal let objectClassName: String
+    internal let propertyName: String
+
+    private var cachedRLMResults: RLMResults<RLMObject>?
+    private var object: RLMWeakObjectHandle?
+    private var property: RLMProperty?
+
+    internal func attachTo(object: RLMObjectBase, property: RLMProperty) {
+        self.object = RLMWeakObjectHandle(object: object)
+        self.property = property
+        self.cachedRLMResults = nil
+    }
+
+    internal var rlmResults: RLMResults<RLMObject> {
+        if cachedRLMResults == nil {
+            if let object = self.object, property = self.property {
+                cachedRLMResults = RLMDynamicGet(object.object, property)! as? RLMResults
+                self.object = nil
+                self.property = nil
+            } else {
+                cachedRLMResults = RLMResults.emptyDetached()
+            }
+        }
+        return cachedRLMResults!
+    }
+
+    init(fromClassName objectClassName: String, property propertyName: String) {
+        self.objectClassName = objectClassName
+        self.propertyName = propertyName
+    }
+
+    // MARK: Fast Enumeration
+    public func countByEnumerating(with state: UnsafeMutablePointer<NSFastEnumerationState>,
+                                   objects buffer: AutoreleasingUnsafeMutablePointer<AnyObject?>!,
+                                   count len: Int) -> Int {
+        return Int(rlmResults.countByEnumerating(with: state,
+                                                 objects: buffer,
+                                                 count: UInt(len)))
+    }
+}
+
+/**
+ LinkingObjects is an auto-updating container type that represents a collection of objects that
+ link to a given object.
+
+ LinkingObjects can be queried with the same predicates as `List<T>` and `Results<T>`.
+
+ LinkingObjects always reflect the current state of the Realm on the current thread,
+ including during write transactions on the current thread. The one exception to
+ this is when using `for...in` enumeration, which will always enumerate over the
+ linking objects when the enumeration is begun, even if some of them are deleted or
+ modified to no longer link to the target object during the enumeration.
+
+ LinkingObjects can only be used as a property on `Object` models. The property must
+ be declared as `let` and cannot be `dynamic`.
+ */
+public final class LinkingObjects<T: Object>: LinkingObjectsBase {
+    /// Element type contained in this collection.
+    public typealias Element = T
+
+    // MARK: Properties
+
+    /// Returns the Realm these linking objects are associated with.
+    public var realm: Realm? { return rlmResults.isAttached ? Realm(rlmResults.realm) : nil }
+
+    /// Indicates if the linking objects can no longer be accessed.
+    ///
+    /// Linking objects can no longer be accessed if `invalidate` is called on the containing `Realm`.
+    public var isInvalidated: Bool { return rlmResults.isInvalidated }
+
+    /// Returns the number of objects in these linking objects.
+    public var count: Int { return Int(rlmResults.count) }
+
+    // MARK: Initializers
+
+    /**
+     Creates a LinkingObjects. This initializer should only be called when
+     declaring a property on a Realm model.
+
+     - parameter type:         The originating type linking to this object type.
+     - parameter propertyName: The property name of the incoming relationship
+                               this LinkingObjects should refer to.
+    */
+    public init(fromType type: T.Type, property propertyName: String) {
+        let className = (T.self as Object.Type).className()
+        super.init(fromClassName: className, property: propertyName)
+    }
+
+    /// Returns a human-readable description of the objects contained in these linking objects.
+    public override var description: String {
+        let type = "LinkingObjects<\(rlmResults.objectClassName)>"
+        return gsub(pattern: "RLMResults <0x[a-z0-9]+>", template: type, string: rlmResults.description) ?? type
+    }
+
+    // MARK: Index Retrieval
+
+    /**
+     Returns the index of the given object, or `nil` if the object is not present.
+
+     - parameter object: The object whose index is being queried.
+
+     - returns: The index of the given object, or `nil` if the object is not present.
+     */
+    public func index(of object: T) -> Int? {
+        return notFoundToNil(index: rlmResults.index(of: unsafeBitCast(object, to: RLMObject.self)))
+    }
+
+    /**
+     Returns the index of the first object matching the given predicate,
+     or `nil` if no objects match.
+
+     - parameter predicate: The predicate to filter the objects.
+
+     - returns: The index of the first matching object, or `nil` if no objects match.
+     */
+    public func indexOfObject(for predicate: Predicate) -> Int? {
+        return notFoundToNil(index: rlmResults.indexOfObject(with: predicate))
+    }
+
+    /**
+     Returns the index of the first object matching the given predicate,
+     or `nil` if no objects match.
+
+     - parameter predicateFormat: The predicate format string which can accept variable arguments.
+
+     - returns: The index of the first matching object, or `nil` if no objects match.
+     */
+    public func indexOfObject(for predicateFormat: String, _ args: AnyObject...) -> Int? {
+        return notFoundToNil(index: rlmResults.indexOfObject(with: Predicate(format: predicateFormat,
+                                                                             argumentArray: args)))
+    }
+
+    // MARK: Object Retrieval
+
+    /**
+     Returns the object at the given `index`.
+
+     - parameter index: The index.
+
+     - returns: The object at the given `index`.
+     */
+    public subscript(index: Int) -> T {
+        get {
+            throwForNegativeIndex(index)
+            return unsafeBitCast(rlmResults[UInt(index)], to: T.self)
+        }
+    }
+
+    /// Returns the first object in the collection, or `nil` if empty.
+    public var first: T? { return unsafeBitCast(rlmResults.firstObject(), to: Optional<T>.self) }
+
+    /// Returns the last object in the collection, or `nil` if empty.
+    public var last: T? { return unsafeBitCast(rlmResults.lastObject(), to: Optional<T>.self) }
+
+    // MARK: KVC
+
+    /**
+     Returns an Array containing the results of invoking `valueForKey(_:)` using key on each of the
+     collection's objects.
+
+     - parameter key: The name of the property.
+
+     - returns: Array containing the results of invoking `valueForKey(_:)` using key on each of the
+       collection's objects.
+     */
+    public override func value(forKey key: String) -> AnyObject? {
+        return value(forKeyPath: key)
+    }
+
+    /**
+     Returns an Array containing the results of invoking `valueForKeyPath(_:)` using keyPath on each of the
+     collection's objects.
+
+     - parameter keyPath: The key path to the property.
+
+     - returns: Array containing the results of invoking `valueForKeyPath(_:)` using keyPath on each of the
+       collection's objects.
+     */
+    public override func value(forKeyPath keyPath: String) -> AnyObject? {
+        return rlmResults.value(forKeyPath: keyPath)
+    }
+
+    /**
+     Invokes `setValue(_:forKey:)` on each of the collection's objects using the specified value and key.
+
+     - warning: This method can only be called during a write transaction.
+
+     - parameter value: The object value.
+     - parameter key:   The name of the property.
+     */
+    public override func setValue(_ value: AnyObject?, forKey key: String) {
+        return rlmResults.setValue(value, forKeyPath: key)
+    }
+
+    // MARK: Filtering
+
+    /**
+     Filters the collection to the objects that match the given predicate.
+
+     - parameter predicateFormat: The predicate format string which can accept variable arguments.
+
+     - returns: Results containing objects that match the given predicate.
+     */
+    public func filter(using predicateFormat: String, _ args: AnyObject...) -> Results<T> {
+        return Results<T>(rlmResults.objects(with: Predicate(format: predicateFormat, argumentArray: args)))
+    }
+
+    /**
+     Filters the collection to the objects that match the given predicate.
+
+     - parameter predicate: The predicate to filter the objects.
+
+     - returns: Results containing objects that match the given predicate.
+     */
+    public func filter(using predicate: Predicate) -> Results<T> {
+        return Results<T>(rlmResults.objects(with: predicate))
+    }
+
+    // MARK: Sorting
+
+    /**
+     Returns `Results` with elements sorted by the given property name.
+
+     - parameter property:  The property name to sort by.
+     - parameter ascending: The direction to sort by.
+
+     - returns: `Results` with elements sorted by the given property name.
+     */
+    public func sorted(onProperty property: String, ascending: Bool = true) -> Results<T> {
+        return sorted(with: [SortDescriptor(property: property, ascending: ascending)])
+    }
+
+    /**
+     Returns `Results` with elements sorted by the given sort descriptors.
+
+     - parameter sortDescriptors: `SortDescriptor`s to sort by.
+
+     - returns: `Results` with elements sorted by the given sort descriptors.
+     */
+    public func sorted<S: Sequence where S.Iterator.Element == SortDescriptor>(with sortDescriptors: S) -> Results<T> {
+        return Results<T>(rlmResults.sortedResults(using: sortDescriptors.map { $0.rlmSortDescriptorValue }))
+    }
+
+    // MARK: Aggregate Operations
+
+    /**
+     Returns the minimum value of the given property.
+
+     - warning: Only names of properties of a type conforming to the `MinMaxType` protocol can be used.
+
+     - parameter property: The name of a property conforming to `MinMaxType` to look for a minimum on.
+
+     - returns: The minimum value for the property amongst objects in the collection, or `nil` if the collection
+       is empty.
+     */
+    public func minimumValue<U: MinMaxType>(ofProperty property: String) -> U? {
+        return rlmResults.min(ofProperty: property) as! U?
+    }
+
+    /**
+     Returns the maximum value of the given property.
+
+     - warning: Only names of properties of a type conforming to the `MinMaxType` protocol can be used.
+
+     - parameter property: The name of a property conforming to `MinMaxType` to look for a maximum on.
+
+     - returns: The maximum value for the property amongst objects in the collection, or `nil` if the collection
+       is empty.
+     */
+    public func maximumValue<U: MinMaxType>(ofProperty property: String) -> U? {
+        return rlmResults.max(ofProperty: property) as! U?
+    }
+
+    /**
+     Returns the sum of the given property for objects in the collection.
+
+     - warning: Only names of properties of a type conforming to the `AddableType` protocol can be used.
+
+     - parameter property: The name of a property conforming to `AddableType` to calculate sum on.
+
+     - returns: The sum of the given property over all objects in the collection.
+     */
+    public func sum<U: AddableType>(ofProperty property: String) -> U {
+        return rlmResults.sum(ofProperty: property) as AnyObject as! U
+    }
+
+    /**
+     Returns the average of the given property for objects in the collection.
+
+     - warning: Only names of properties of a type conforming to the `AddableType` protocol can be used.
+
+     - parameter property: The name of a property conforming to `AddableType` to calculate average on.
+
+     - returns: The average of the given property over all objects in the collection, or `nil` if the collection
+       is empty.
+     */
+    public func average<U: AddableType>(ofProperty property: String) -> U? {
+        return rlmResults.average(ofProperty: property) as! U?
+    }
+
+    // MARK: Notifications
+
+    /**
+     Register a block to be called each time the LinkingObjects changes.
+
+     The block will be asynchronously called with the initial set of objects, and then
+     called again after each write transaction which changes either any of the
+     objects in the collection, or which objects are in the collection.
+
+     This version of this method reports which of the objects in the collection were
+     added, removed, or modified in each write transaction as indices within the
+     collection. See the RealmCollectionChange documentation for more information on
+     the change information supplied and an example of how to use it to update
+     a UITableView.
+
+     At the time when the block is called, the LinkingObjects object will be fully
+     evaluated and up-to-date, and as long as you do not perform a write transaction
+     on the same thread or explicitly call realm.refresh(), accessing it will never
+     perform blocking work.
+
+     Notifications are delivered via the standard run loop, and so can't be
+     delivered while the run loop is blocked by other activity. When
+     notifications can't be delivered instantly, multiple notifications may be
+     coalesced into a single notification. This can include the notification
+     with the initial set of objects. For example, the following code performs a write
+     transaction immediately after adding the notification block, so there is no
+     opportunity for the initial notification to be delivered first. As a
+     result, the initial notification will reflect the state of the Realm after
+     the write transaction.
+
+         let dog = realm.objects(Dog).first!
+         let owners = dog.owners
+         print("owners.count: \(owners.count)") // => 0
+         let token = owners.addNotificationBlock { (changes: RealmCollectionChange) in
+             switch changes {
+                 case .Initial(let owners):
+                     // Will print "owners.count: 1"
+                     print("owners.count: \(owners.count)")
+                     break
+                 case .Update:
+                     // Will not be hit in this example
+                     break
+                 case .Error:
+                     break
+             }
+         }
+         try! realm.write {
+             realm.add(Person.self, value: ["name": "Mark", dogs: [dog]])
+         }
+         // end of runloop execution context
+
+     You must retain the returned token for as long as you want updates to continue
+     to be sent to the block. To stop receiving updates, call stop() on the token.
+
+     - warning: This method cannot be called during a write transaction, or when
+     the source realm is read-only.
+
+     - parameter block: The block to be called with the evaluated linking objects and change information.
+     - returns: A token which must be held for as long as you want updates to be delivered.
+     */
+    public func addNotificationBlock(block: ((RealmCollectionChange<LinkingObjects>) -> Void)) -> NotificationToken {
+        return rlmResults.addNotificationBlock { results, change, error in
+            block(RealmCollectionChange.fromObjc(value: self, change: change, error: error))
+        }
+    }
+}
+
+extension LinkingObjects : RealmCollection {
+    // MARK: Sequence Support
+
+    /// Returns a `GeneratorOf<T>` that yields successive elements in the results.
+    public func makeIterator() -> RLMIterator<T> {
+        return RLMIterator(collection: rlmResults)
+    }
+
+    // MARK: Collection Support
+
+    /// The position of the first element in a non-empty collection.
+    /// Identical to endIndex in an empty collection.
+    public var startIndex: Int { return 0 }
+
+    /// The collection's "past the end" position.
+    /// endIndex is not a valid argument to subscript, and is always reachable from startIndex by
+    /// zero or more applications of successor().
+    public var endIndex: Int { return count }
+
+    public func index(after: Int) -> Int {
+      return after + 1
+    }
+
+    public func index(before: Int) -> Int {
+      return before - 1
+    }
+
+    /// :nodoc:
+    public func _addNotificationBlock(block: (RealmCollectionChange<AnyRealmCollection<T>>) -> Void) ->
+        NotificationToken {
+            let anyCollection = AnyRealmCollection(self)
+            return rlmResults.addNotificationBlock { _, change, error in
+                block(RealmCollectionChange.fromObjc(value: anyCollection, change: change, error: error))
+            }
+    }
+}
+
+// MARK: Unavailable
+
+extension LinkingObjects {
+    @available(*, unavailable, renamed:"isInvalidated")
+    public var invalidated : Bool { fatalError() }
+
+    @available(*, unavailable, renamed:"indexOfObject(for:)")
+    public func index(of predicate: Predicate) -> Int? { fatalError() }
+
+    @available(*, unavailable, renamed:"indexOfObject(for:_:)")
+    public func index(of predicateFormat: String, _ args: AnyObject...) -> Int? { fatalError() }
+
+    @available(*, unavailable, renamed:"filter(using:)")
+    public func filter(_ predicate: Predicate) -> Results<T> { fatalError() }
+
+    @available(*, unavailable, renamed:"filter(using:_:)")
+    public func filter(_ predicateFormat: String, _ args: AnyObject...) -> Results<T> { fatalError() }
+
+    @available(*, unavailable, renamed:"sorted(onProperty:ascending:)")
+    public func sorted(_ property: String, ascending: Bool = true) -> Results<T> { fatalError() }
+
+    @available(*, unavailable, renamed:"sorted(with:)")
+    public func sorted<S: Sequence where S.Iterator.Element == SortDescriptor>(_ sortDescriptors: S) -> Results<T> {
+        fatalError()
+    }
+
+    @available(*, unavailable, renamed:"minimumValue(ofProperty:)")
+    public func min<U: MinMaxType>(_ property: String) -> U? { fatalError() }
+
+    @available(*, unavailable, renamed:"maximumValue(ofProperty:)")
+    public func max<U: MinMaxType>(_ property: String) -> U? { fatalError() }
+
+    @available(*, unavailable, renamed:"sum(ofProperty:)")
+    public func sum<U: AddableType>(_ property: String) -> U { fatalError() }
+
+    @available(*, unavailable, renamed:"average(ofProperty:)")
+    public func average<U: AddableType>(_ property: String) -> U? { fatalError() }
+}
+
+#else
+
+/// :nodoc:
+/// Internal class. Do not use directly. Used for reflection and initialization
+public class LinkingObjectsBase: NSObject, NSFastEnumeration {
+    internal let objectClassName: String
+    internal let propertyName: String
+
+    private var cachedRLMResults: RLMResults?
+    private var object: RLMWeakObjectHandle?
+    private var property: RLMProperty?
+
+    internal func attachTo(object object: RLMObjectBase, property: RLMProperty) {
+        self.object = RLMWeakObjectHandle(object: object)
+        self.property = property
+        self.cachedRLMResults = nil
+    }
+
+    internal var rlmResults: RLMResults {
+        if cachedRLMResults == nil {
+            if let object = self.object, property = self.property {
+                cachedRLMResults = RLMDynamicGet(object.object, property)! as? RLMResults
+                self.object = nil
+                self.property = nil
+            } else {
+                cachedRLMResults = RLMResults.emptyDetachedResults()
+            }
+        }
+        return cachedRLMResults!
+    }
+
+    init(fromClassName objectClassName: String, property propertyName: String) {
+        self.objectClassName = objectClassName
+        self.propertyName = propertyName
+    }
+
+    // MARK: Fast Enumeration
+    public func countByEnumeratingWithState(state: UnsafeMutablePointer<NSFastEnumerationState>,
+                                            objects buffer: AutoreleasingUnsafeMutablePointer<AnyObject?>,
+                                                    count len: Int) -> Int {
+        return Int(rlmResults.countByEnumeratingWithState(state,
+            objects: buffer,
+            count: UInt(len)))
+    }
+}
+
+/**
+ `LinkingObjects` is an auto-updating container type. It represents a collection of objects that
+ link to its parent object.
+
+ `LinkingObjects` can be queried with the same predicates as `List<T>` and `Results<T>`.
+
+ `LinkingObjects` always reflects the current state of the Realm on the current thread,
+ including during write transactions on the current thread. The one exception to
+ this is when using `for...in` enumeration, which will always enumerate over the
+ linking objects that were present when the enumeration is begun, even if some of them
+ are deleted or modified to no longer link to the target object during the enumeration.
+
+ `LinkingObjects` can only be used as a property on `Object` models. Properties of this type must
+ be declared as `let` and cannot be `dynamic`.
+ */
+public final class LinkingObjects<T: Object>: LinkingObjectsBase {
+    /// The element type contained in this collection.
+    public typealias Element = T
+
+    // MARK: Properties
+
+    /// The Realm which manages this linking objects collection, or `nil` if the collection is unmanaged.
+    public var realm: Realm? { return rlmResults.attached ? Realm(rlmResults.realm) : nil }
+
+    /// Indicates if the linking objects collection is no longer valid.
+    ///
+    /// The linking objects collection becomes invalid if `invalidate` is called on the containing `realm`.
+    ///
+    /// An invalidated linking objects can be accessed, but will always be empty.
+    public var invalidated: Bool { return rlmResults.invalidated }
+
+    /// The number of objects in the linking objects.
+    public var count: Int { return Int(rlmResults.count) }
+
+    // MARK: Initializers
+
+    /**
+     Creates an instance of a `LinkingObjects`. This initializer should only be called when
+     declaring a property on a Realm model.
+
+     - parameter type:         The type of the object owning the property this `LinkingObjects` should refer to.
+     - parameter propertyName: The property name of the property this `LinkingObjects` should refer to.
+    */
+    public init(fromType type: T.Type, property propertyName: String) {
+        let className = (T.self as Object.Type).className()
+        super.init(fromClassName: className, property: propertyName)
+    }
+
+    /// Returns a description of the objects contained within the linking objects.
+    public override var description: String {
+        let type = "LinkingObjects<\(rlmResults.objectClassName)>"
+        return gsub("RLMResults <0x[a-z0-9]+>", template: type, string: rlmResults.description) ?? type
+    }
+
+    // MARK: Index Retrieval
+
+    /**
+     Returns the index of an object in the linking objects collection, or `nil` if the object is not present.
+
+     - parameter object: The object whose index is being queried.
+     */
+    public func indexOf(object: T) -> Int? {
+        return notFoundToNil(rlmResults.indexOfObject(unsafeBitCast(object, RLMObject.self)))
+    }
+
+    /**
+     Returns the index of the first object matching the given predicate, or `nil` if no objects match.
+
+     - parameter predicate: The predicate with which to filter the objects.
+     */
+    public func indexOf(predicate: NSPredicate) -> Int? {
+        return notFoundToNil(rlmResults.indexOfObjectWithPredicate(predicate))
+    }
+
+    /**
+     Returns the index of the first object matching the given predicate, or `nil` if no objects match.
+
+     - parameter predicateFormat: A predicate format string, optionally followed by a variable number of arguments.
+     */
+    public func indexOf(predicateFormat: String, _ args: AnyObject...) -> Int? {
+        return notFoundToNil(rlmResults.indexOfObjectWithPredicate(NSPredicate(format: predicateFormat,
+            argumentArray: args)))
+    }
+
+    // MARK: Object Retrieval
+
+    /**
+     Returns the object at the given `index`.
+
+     - parameter index: The index.
+
+     - returns: The object at the given `index`.
+     */
+    public subscript(index: Int) -> T {
+        get {
+            throwForNegativeIndex(index)
+            return unsafeBitCast(rlmResults[UInt(index)], T.self)
+        }
+    }
+
+    /// Returns the first object in the linking objects collection, or `nil` if the collection is empty.
+    public var first: T? { return unsafeBitCast(rlmResults.firstObject(), Optional<T>.self) }
+
+    /// Returns the last object in the linking objects collection, or `nil` if collection is empty.
+    public var last: T? { return unsafeBitCast(rlmResults.lastObject(), Optional<T>.self) }
+
+    // MARK: KVC
+
+    /**
+     Returns an `Array` containing the results of invoking `valueForKey(_:)` with `key` on each of the linking objects
+     collection's objects.
+
+     - parameter key: The name of the property whose values are desired.
+     */
+    public override func valueForKey(key: String) -> AnyObject? {
+        return rlmResults.valueForKey(key)
+    }
+
+    /**
+     Returns an `Array` containing the results of invoking `valueForKeyPath(_:)` with `keyPath` on each of the linking
+     objects collection's objects.
+
+     - parameter keyPath: The key path to the property whose values are desired.
+     */
+    public override func valueForKeyPath(keyPath: String) -> AnyObject? {
+        return rlmResults.valueForKeyPath(keyPath)
+    }
+
+    /**
+     Invokes `setValue(_:forKey:)` on each of the linking objects collection's objects using the specified `value` and
+     `key`.
+
+     - warning: This method may only be called during a write transaction.
+
+     - parameter value: The value to set the property to.
+     - parameter key:   The name of the property whose value should be set on each object.
+     */
+    public override func setValue(value: AnyObject?, forKey key: String) {
+        return rlmResults.setValue(value, forKey: key)
+    }
+
+    // MARK: Filtering
+
+    /**
+     Returns a `Results` containing all objects matching the given predicate in the linking objects collection.
+
+     - parameter predicateFormat: A predicate format string, optionally followed by a variable number of arguments.
+     */
+    public func filter(predicateFormat: String, _ args: AnyObject...) -> Results<T> {
+        return Results<T>(rlmResults.objectsWithPredicate(NSPredicate(format: predicateFormat, argumentArray: args)))
+    }
+
+    /**
+     Returns a `Results` containing all objects matching the given predicate in the linking objects collection.
+
+     - parameter predicate: The predicate with which to filter the objects.
+     */
+    public func filter(predicate: NSPredicate) -> Results<T> {
+        return Results<T>(rlmResults.objectsWithPredicate(predicate))
+    }
+
+    // MARK: Sorting
+
+    /**
+     Returns a `Results` containing the objects in the linking objects collection, but sorted.
+
+     Objects are sorted based on the values of the given property. For example, to sort a collection of `Student`s from
+     youngest to oldest based on their `age` property, you might call `students.sorted("age", ascending: true)`.
+
+     - warning: Collections may only be sorted by properties of boolean, `NSDate`, single and double-precision floating
+                point, integer, and string types.
+
+     - parameter property:  The name of the property to sort by.
+     - parameter ascending: The direction to sort in.
+     */
+    public func sorted(property: String, ascending: Bool = true) -> Results<T> {
+        return sorted([SortDescriptor(property: property, ascending: ascending)])
+    }
+
+    /**
+     Returns a `Results` containing the objects in the linking objects collection, but sorted.
+
+     - warning: Collections may only be sorted by properties of boolean, `NSDate`, single and double-precision floating
+                point, integer, and string types.
+
+     - see: `sorted(_:ascending:)`
+
+     - parameter sortDescriptors: A sequence of `SortDescriptor`s to sort by.
+     */
+    public func sorted<S: SequenceType where S.Generator.Element == SortDescriptor>(sortDescriptors: S) -> Results<T> {
+        return Results<T>(rlmResults.sortedResultsUsingDescriptors(sortDescriptors.map { $0.rlmSortDescriptorValue }))
+    }
+
+    // MARK: Aggregate Operations
+
+    /**
+     Returns the minimum (lowest) value of the given property among all the objects represented by the linking objects
+     collection.
+
+     - warning: Only a property whose type conforms to the `MinMaxType` protocol can be specified.
+
+     - parameter property: The name of a property whose minimum value is desired.
+
+     - returns: The minimum value of the property, or `nil` if the collection is empty.
+     */
+    public func min<U: MinMaxType>(property: String) -> U? {
+        return rlmResults.minOfProperty(property) as! U?
+    }
+
+    /**
+     Returns the maximum (highest) value of the given property among all the objects represented by the linking objects
+     collection.
+
+     - warning: Only a property whose type conforms to the `MinMaxType` protocol can be specified.
+
+     - parameter property: The name of a property whose minimum value is desired.
+
+     - returns: The maximum value of the property, or `nil` if the collection is empty.
+     */
+    public func max<U: MinMaxType>(property: String) -> U? {
+        return rlmResults.maxOfProperty(property) as! U?
+    }
+
+    /**
+     Returns the sum of the values of a given property over all the objects represented by the linking objects
+     collection.
+
+     - warning: Only a property whose type conforms to the `AddableType` protocol can be specified.
+
+     - parameter property: The name of a property whose values should be summed.
+
+     - returns: The sum of the given property.
+     */
+    public func sum<U: AddableType>(property: String) -> U {
+        return rlmResults.sumOfProperty(property) as AnyObject as! U
+    }
+
+    /**
+     Returns the average value of a given property over all the objects represented by the linking objects collection.
+
+     - warning: Only the name of a property whose type conforms to the `AddableType` protocol can be specified.
+
+     - parameter property: The name of a property whose average value should be calculated.
+
+     - returns: The average value of the given property, or `nil` if the collection is empty.
+     */
+    public func average<U: AddableType>(property: String) -> U? {
+        return rlmResults.averageOfProperty(property) as! U?
+    }
+
+    // MARK: Notifications
+
+    /**
+     Registers a block to be called each time the linking objects collection changes.
+
+     The block will be asynchronously called with the initial linking objects collection,
+     and then called again after each write transaction which changes either any
+     of the objects in the collection, or which objects are in the collection.
+
+     The `change` parameter that is passed to the block reports, in the form of indices within the
+     collection, which of the objects were added, removed, or modified during each write transaction. See the
+     `RealmCollectionChange` documentation for more information on the change information supplied and an example of how
+     to use it to update a `UITableView`.
+
+     At the time when the block is called, the linking objects collection will be fully
+     evaluated and up-to-date, and as long as you do not perform a write transaction
+     on the same thread or explicitly call `realm.refresh()`, accessing it will never
+     perform blocking work.
+
+     Notifications are delivered via the standard run loop, and so can't be
+     delivered while the run loop is blocked by other activity. When
+     notifications can't be delivered instantly, multiple notifications may be
+     coalesced into a single notification. This can include the notification
+     with the initial set of objects. For example, the following code performs a write
+     transaction immediately after adding the notification block, so there is no
+     opportunity for the initial notification to be delivered first. As a
+     result, the initial notification will reflect the state of the Realm after
+     the write transaction.
+
+     ```swift
+     let dog = realm.objects(Dog.self).first!
+     let owners = dog.owners
+     print("owners.count: \(owners.count)") // => 0
+     let token = owners.addNotificationBlock { changes in
+         switch changes {
+             case .Initial(let owners):
+                 // Will print "owners.count: 1"
+                 print("owners.count: \(owners.count)")
+                 break
+             case .Update:
+                 // Will not be hit in this example
+                 break
+             case .Error:
+                 break
+         }
+     }
+     try! realm.write {
+         realm.add(Person.self, value: ["name": "Mark", dogs: [dog]])
+     }
+     // end of runloop execution context
+     ```
+
+     You must retain the returned token for as long as you want updates to be sent to the block. To stop receiving
+     updates, call `stop()` on the token.
+
+     - warning: This method cannot be called during a write transaction, or when
+     the containing Realm is read-only.
+
+     - parameter block: The block to be called whenever a change occurs.
+     - returns: A token which must be retained for as long as you want updates to be delivered.
+     */
+    @warn_unused_result(message="You must hold on to the NotificationToken returned from addNotificationBlock")
+    public func addNotificationBlock(block: (RealmCollectionChange<LinkingObjects> -> Void)) -> NotificationToken {
+        return rlmResults.addNotificationBlock { results, change, error in
+            block(RealmCollectionChange.fromObjc(self, change: change, error: error))
+        }
+    }
+}
+
+extension LinkingObjects: RealmCollectionType {
+    // MARK: Sequence Support
+
+    /// Returns an `RLMGenerator` that yields successive elements in the results.
+    public func generate() -> RLMGenerator<T> {
+        return RLMGenerator(collection: rlmResults)
+    }
+
+    // MARK: Collection Support
+
+    /// The position of the first element in a non-empty collection.
+    /// Identical to `endIndex` in an empty collection.
+    public var startIndex: Int { return 0 }
+
+    /// The collection's "past the end" position.
+    /// `endIndex` is not a valid argument to subscript, and is always reachable from `startIndex` by
+    /// zero or more applications of `successor()`.
+    public var endIndex: Int { return count }
+
+    /// :nodoc:
+    public func _addNotificationBlock(block: (RealmCollectionChange<AnyRealmCollection<T>>) -> Void) ->
+        NotificationToken {
+            let anyCollection = AnyRealmCollection(self)
+            return rlmResults.addNotificationBlock { _, change, error in
+                block(RealmCollectionChange.fromObjc(anyCollection, change: change, error: error))
+            }
+    }
+}
+
+#endif
diff --git a/Pods/RealmSwift/RealmSwift/List.swift b/Pods/RealmSwift/RealmSwift/List.swift
new file mode 100644
index 0000000..fae4003
--- /dev/null
+++ b/Pods/RealmSwift/RealmSwift/List.swift
@@ -0,0 +1,1064 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+import Foundation
+import Realm
+import Realm.Private
+
+#if swift(>=3.0)
+
+/// :nodoc:
+/// Internal class. Do not use directly.
+public class ListBase: RLMListBase {
+    // Printable requires a description property defined in Swift (and not obj-c),
+    // and it has to be defined as @objc override, which can't be done in a
+    // generic class.
+    /// Returns a human-readable description of the objects contained in the List.
+    @objc public override var description: String {
+        return descriptionWithMaxDepth(RLMDescriptionMaxDepth)
+    }
+
+    @objc private func descriptionWithMaxDepth(_ depth: UInt) -> String {
+        let type = "List<\(_rlmArray.objectClassName)>"
+        return gsub(pattern: "RLMArray <0x[a-z0-9]+>", template: type, string: _rlmArray.description(withMaxDepth: depth)) ?? type
+    }
+
+    /// Returns the number of objects in this List.
+    public var count: Int { return Int(_rlmArray.count) }
+}
+
+/**
+`List<T>` is the container type in Realm used to define to-many relationships.
+
+Lists hold a single `Object` subclass (`T`) which defines the "type" of the List.
+
+Lists can be filtered and sorted with the same predicates as `Results<T>`.
+
+When added as a property on `Object` models, the property must be declared as `let` and cannot be `dynamic`.
+*/
+public final class List<T: Object>: ListBase {
+
+    /// Element type contained in this collection.
+    public typealias Element = T
+
+    // MARK: Properties
+
+    /// The Realm the objects in this List belong to, or `nil` if the List's
+    /// owning object does not belong to a Realm (the List is standalone).
+    public var realm: Realm? {
+        return _rlmArray.realm.map { Realm($0) }
+    }
+
+    /// Indicates if the List can no longer be accessed.
+    public var isInvalidated: Bool { return _rlmArray.isInvalidated }
+
+    // MARK: Initializers
+
+    /// Creates a `List` that holds objects of type `T`.
+    public override init() {
+        super.init(array: RLMArray(objectClassName: (T.self as Object.Type).className()))
+    }
+
+    // MARK: Index Retrieval
+
+    /**
+    Returns the index of the given object, or `nil` if the object is not in the List.
+
+    - parameter object: The object whose index is being queried.
+
+    - returns: The index of the given object, or `nil` if the object is not in the List.
+    */
+    public func index(of object: T) -> Int? {
+        return notFoundToNil(index: _rlmArray.index(of: unsafeBitCast(object, to: RLMObject.self)))
+    }
+
+    /**
+    Returns the index of the first object matching the given predicate,
+    or `nil` no objects match.
+
+    - parameter predicate: The `NSPredicate` used to filter the objects.
+
+    - returns: The index of the first matching object, or `nil` if no objects match.
+    */
+    public func indexOfObject(for predicate: Predicate) -> Int? {
+        return notFoundToNil(index: _rlmArray.indexOfObject(with: predicate))
+    }
+
+    /**
+    Returns the index of the first object matching the given predicate,
+    or `nil` if no objects match.
+
+    - parameter predicateFormat: The predicate format string, optionally
+                                 followed by a variable number of arguments.
+
+    - returns: The index of the first matching object, or `nil` if no objects match.
+    */
+    public func indexOfObject(for predicateFormat: String, _ args: AnyObject...) -> Int? {
+        return indexOfObject(for: Predicate(format: predicateFormat, argumentArray: args))
+    }
+
+    // MARK: Object Retrieval
+
+    /**
+    Returns the object at the given `index` on get.
+    Replaces the object at the given `index` on set.
+
+    - warning: You can only set an object during a write transaction.
+
+    - parameter index: The index.
+
+    - returns: The object at the given `index`.
+    */
+    public subscript(position: Int) -> T {
+        get {
+            throwForNegativeIndex(position)
+            return unsafeBitCast(_rlmArray.object(at: UInt(position)), to: T.self)
+        }
+        set {
+            throwForNegativeIndex(position)
+            _rlmArray.replaceObject(at: UInt(position), with: unsafeBitCast(newValue, to: RLMObject.self))
+        }
+    }
+
+    /// Returns the first object in the List, or `nil` if empty.
+    public var first: T? { return _rlmArray.firstObject() as! T? }
+
+    /// Returns the last object in the List, or `nil` if empty.
+    public var last: T? { return _rlmArray.lastObject() as! T? }
+
+    // MARK: KVC
+
+    /**
+    Returns an Array containing the results of invoking `valueForKey(_:)` using key on each of the collection's objects.
+
+    - parameter key: The name of the property.
+
+    - returns: Array containing the results of invoking `valueForKey(_:)` using key on each of the collection's objects.
+    */
+    public override func value(forKey key: String) -> AnyObject? {
+        return value(forKeyPath: key)
+    }
+
+    /**
+     Returns an Array containing the results of invoking `valueForKeyPath(_:)` using keyPath on each of the
+     collection's objects.
+
+     - parameter keyPath: The key path to the property.
+
+     - returns: Array containing the results of invoking `valueForKeyPath(_:)` using keyPath on each of the
+     collection's objects.
+     */
+    public override func value(forKeyPath keyPath: String) -> AnyObject? {
+        return _rlmArray.value(forKeyPath: keyPath)
+    }
+
+    /**
+    Invokes `setValue(_:forKey:)` on each of the collection's objects using the specified value and key.
+
+    - warning: This method can only be called during a write transaction.
+
+    - parameter value: The object value.
+    - parameter key:   The name of the property.
+    */
+    public override func setValue(_ value: AnyObject?, forKey key: String) {
+        return _rlmArray.setValue(value, forKeyPath: key)
+    }
+
+    // MARK: Filtering
+
+    /**
+    Returns `Results` containing elements that match the given predicate.
+
+    - parameter predicateFormat: The predicate format string which can accept variable arguments.
+
+    - returns: `Results` containing elements that match the given predicate.
+    */
+    public func filter(using predicateFormat: String, _ args: AnyObject...) -> Results<T> {
+        return Results<T>(_rlmArray.objects(with: Predicate(format: predicateFormat, argumentArray: args)))
+    }
+
+    /**
+    Returns `Results` containing elements that match the given predicate.
+
+    - parameter predicate: The predicate to filter the objects.
+
+    - returns: `Results` containing elements that match the given predicate.
+    */
+    public func filter(using predicate: Predicate) -> Results<T> {
+        return Results<T>(_rlmArray.objects(with: predicate))
+    }
+
+    // MARK: Sorting
+
+    /**
+    Returns `Results` containing elements sorted by the given property.
+
+    - parameter property:  The property name to sort by.
+    - parameter ascending: The direction to sort by.
+
+    - returns: `Results` containing elements sorted by the given property.
+    */
+    public func sorted(onProperty property: String, ascending: Bool = true) -> Results<T> {
+        return sorted(with: [SortDescriptor(property: property, ascending: ascending)])
+    }
+
+    /**
+    Returns `Results` with elements sorted by the given sort descriptors.
+
+    - parameter sortDescriptors: `SortDescriptor`s to sort by.
+
+    - returns: `Results` with elements sorted by the given sort descriptors.
+    */
+    public func sorted<S: Sequence where S.Iterator.Element == SortDescriptor>(with sortDescriptors: S) -> Results<T> {
+        return Results<T>(_rlmArray.sortedResults(using: sortDescriptors.map { $0.rlmSortDescriptorValue }))
+    }
+
+    // MARK: Aggregate Operations
+
+    /**
+    Returns the minimum value of the given property.
+
+    - warning: Only names of properties of a type conforming to the `MinMaxType` protocol can be used.
+
+    - parameter property: The name of a property conforming to `MinMaxType` to look for a minimum on.
+
+    - returns: The minimum value for the property amongst objects in the List, or `nil` if the List is empty.
+    */
+    public func minimumValue<U: MinMaxType>(ofProperty property: String) -> U? {
+        return filter(using: Predicate(value: true)).minimumValue(ofProperty: property)
+    }
+
+    /**
+    Returns the maximum value of the given property.
+
+    - warning: Only names of properties of a type conforming to the `MinMaxType` protocol can be used.
+
+    - parameter property: The name of a property conforming to `MinMaxType` to look for a maximum on.
+
+    - returns: The maximum value for the property amongst objects in the List, or `nil` if the List is empty.
+    */
+    public func maximumValue<U: MinMaxType>(ofProperty property: String) -> U? {
+        return filter(using: Predicate(value: true)).maximumValue(ofProperty: property)
+    }
+
+    /**
+    Returns the sum of the given property for objects in the List.
+
+    - warning: Only names of properties of a type conforming to the `AddableType` protocol can be used.
+
+    - parameter property: The name of a property conforming to `AddableType` to calculate sum on.
+
+    - returns: The sum of the given property over all objects in the List.
+    */
+    public func sum<U: AddableType>(ofProperty property: String) -> U {
+        return filter(using: Predicate(value: true)).sum(ofProperty: property)
+    }
+
+    /**
+    Returns the average of the given property for objects in the List.
+
+    - warning: Only names of properties of a type conforming to the `AddableType` protocol can be used.
+
+    - parameter property: The name of a property conforming to `AddableType` to calculate average on.
+
+    - returns: The average of the given property over all objects in the List, or `nil` if the List is empty.
+    */
+    public func average<U: AddableType>(ofProperty property: String) -> U? {
+        return filter(using: Predicate(value: true)).average(ofProperty: property)
+    }
+
+    // MARK: Mutation
+
+    /**
+    Appends the given object to the end of the List. If the object is from a
+    different Realm it is copied to the List's Realm.
+
+    - warning: This method can only be called during a write transaction.
+
+    - parameter object: An object.
+    */
+    public func append(_ object: T) {
+        _rlmArray.add(unsafeBitCast(object, to: RLMObject.self))
+    }
+
+    /**
+    Appends the objects in the given sequence to the end of the List.
+
+    - warning: This method can only be called during a write transaction.
+
+    - parameter objects: A sequence of objects.
+    */
+    public func append<S: Sequence where S.Iterator.Element == T>(objectsIn objects: S) {
+        for obj in objects {
+            _rlmArray.add(unsafeBitCast(obj, to: RLMObject.self))
+        }
+    }
+
+    /**
+    Inserts the given object at the given index.
+
+    - warning: This method can only be called during a write transaction.
+    - warning: Throws an exception when called with an index smaller than zero
+               or greater than or equal to the number of objects in the List.
+
+    - parameter object: An object.
+    - parameter index:  The index at which to insert the object.
+    */
+    public func insert(_ object: T, at index: Int) {
+        throwForNegativeIndex(index)
+        _rlmArray.insert(unsafeBitCast(object, to: RLMObject.self), at: UInt(index))
+    }
+
+    /**
+    Removes the object at the given index from the List. Does not remove the object from the Realm.
+
+    - warning: This method can only be called during a write transaction.
+    - warning: Throws an exception when called with an index smaller than zero
+               or greater than or equal to the number of objects in the List.
+
+    - parameter index: The index at which to remove the object.
+    */
+    public func remove(objectAtIndex index: Int) {
+        throwForNegativeIndex(index)
+        _rlmArray.removeObject(at: UInt(index))
+    }
+
+    /**
+    Removes the last object in the List. Does not remove the object from the Realm.
+
+    - warning: This method can only be called during a write transaction.
+    */
+    public func removeLastObject() {
+        _rlmArray.removeLastObject()
+    }
+
+    /**
+    Removes all objects from the List. Does not remove the objects from the Realm.
+
+    - warning: This method can only be called during a write transaction.
+    */
+    public func removeAllObjects() {
+        _rlmArray.removeAllObjects()
+    }
+
+    /**
+    Replaces an object at the given index with a new object.
+
+    - warning: This method can only be called during a write transaction.
+    - warning: Throws an exception when called with an index smaller than zero
+               or greater than or equal to the number of objects in the List.
+
+    - parameter index:  The index of the object to be replaced.
+    - parameter object: An object to replace at the specified index.
+    */
+    public func replace(index: Int, object: T) {
+        throwForNegativeIndex(index)
+        _rlmArray.replaceObject(at: UInt(index), with: unsafeBitCast(object, to: RLMObject.self))
+    }
+
+    /**
+    Moves the object at the given source index to the given destination index.
+
+    - warning: This method can only be called during a write transaction.
+    - warning: Throws an exception when called with an index smaller than zero or greater than
+               or equal to the number of objects in the List.
+
+    - parameter from:  The index of the object to be moved.
+    - parameter to:    index to which the object at `from` should be moved.
+    */
+    public func move(from: Int, to: Int) { // swiftlint:disable:this variable_name
+        throwForNegativeIndex(from)
+        throwForNegativeIndex(to)
+        _rlmArray.moveObject(at: UInt(from), to: UInt(to))
+    }
+
+    /**
+    Exchanges the objects in the List at given indexes.
+
+    - warning: Throws an exception when either index exceeds the bounds of the List.
+    - warning: This method can only be called during a write transaction.
+
+    - parameter index1: The index of the object with which to replace the object at index `index2`.
+    - parameter index2: The index of the object with which to replace the object at index `index1`.
+    */
+    public func swap(index1: Int, _ index2: Int) {
+        throwForNegativeIndex(index1, parameterName: "index1")
+        throwForNegativeIndex(index2, parameterName: "index2")
+        _rlmArray.exchangeObject(at: UInt(index1), withObjectAt: UInt(index2))
+    }
+
+    // MARK: Notifications
+
+    /**
+    Register a block to be called each time the List changes.
+
+    The block will be asynchronously called with the initial list, and then
+    called again after each write transaction which changes the list or any of
+    the items in the list.
+
+    This version of this method reports which of the objects in the List were
+    added, removed, or modified in each write transaction as indices within the
+    List. See the RealmCollectionChange documentation for more information on
+    the change information supplied and an example of how to use it to update
+    a UITableView.
+
+    The block is called on the same thread as it was added on, and can only
+    be added on threads which are currently within a run loop. Unless you are
+    specifically creating and running a run loop on a background thread, this
+    will normally only be the main thread.
+
+    Notifications can't be delivered as long as the run loop is blocked by
+    other activity. When notifications can't be delivered instantly, multiple
+    notifications may be coalesced into a single notification. This can include
+    the notification with the initial list. For example, the following code
+    performs a write transaction immediately after adding the notification block,
+    so there is no opportunity for the initial notification to be delivered first.
+    As a result, the initial notification will reflect the state of the Realm
+    after the write transaction, and will not include change information.
+
+        let person = realm.objects(Person).first!
+        print("dogs.count: \(person.dogs.count)") // => 0
+        let token = person.dogs.addNotificationBlock { (changes: RealmCollectionChange) in
+            switch changes {
+                case .Initial(let dogs):
+                    // Will print "dogs.count: 1"
+                    print("dogs.count: \(dogs.count)")
+                    break
+                case .Update:
+                    // Will not be hit in this example
+                    break
+                case .Error:
+                    break
+            }
+        }
+        try! realm.write {
+            let dog = Dog()
+            dog.name = "Rex"
+            person.dogs.append(dog)
+        }
+        // end of run loop execution context
+
+    You must retain the returned token for as long as you want updates to continue
+    to be sent to the block. To stop receiving updates, call stop() on the token.
+
+     - warning: This method cannot be called during a write transaction, or when
+                the source realm is read-only.
+     - warning: This method can only be called on Lists which are stored on an
+                Object which has been added to or retrieved from a Realm.
+
+    - parameter block: The block to be called each time the list changes.
+    - returns: A token which must be held for as long as you want notifications to be delivered.
+    */
+    public func addNotificationBlock(block: (RealmCollectionChange<List>) -> ()) -> NotificationToken {
+        return _rlmArray.addNotificationBlock { list, change, error in
+            block(RealmCollectionChange.fromObjc(value: self, change: change, error: error))
+        }
+    }
+}
+
+extension List : RealmCollection, RangeReplaceableCollection {
+    // MARK: Sequence Support
+
+    /// Returns a `RLMIterator` that yields successive elements in the `List`.
+    public func makeIterator() -> RLMIterator<T> {
+        return RLMIterator(collection: _rlmArray)
+    }
+
+    // MARK: RangeReplaceableCollection Support
+
+    /**
+    Replace the given `subRange` of elements with `newElements`.
+
+    - parameter subRange:    The range of elements to be replaced.
+    - parameter newElements: The new elements to be inserted into the List.
+    */
+    public func replaceSubrange<C : Collection where C.Iterator.Element == T>(_ subrange: Range<Int>,
+                                                                              with newElements: C) {
+        for _ in subrange.lowerBound..<subrange.upperBound {
+            remove(objectAtIndex: subrange.lowerBound)
+        }
+        for x in newElements.reversed() {
+            insert(x, at: subrange.lowerBound)
+        }
+    }
+
+    /// The position of the first element in a non-empty collection.
+    /// Identical to endIndex in an empty collection.
+    public var startIndex: Int { return 0 }
+
+    /// The collection's "past the end" position.
+    /// endIndex is not a valid argument to subscript, and is always reachable from startIndex by
+    /// zero or more applications of successor().
+    public var endIndex: Int { return count }
+
+    public func index(after i: Int) -> Int { return i + 1 }
+    public func index(before i: Int) -> Int { return i - 1 }
+
+    /// :nodoc:
+    public func _addNotificationBlock(block: (RealmCollectionChange<AnyRealmCollection<T>>) -> Void) ->
+        NotificationToken {
+        let anyCollection = AnyRealmCollection(self)
+        return _rlmArray.addNotificationBlock { _, change, error in
+            block(RealmCollectionChange.fromObjc(value: anyCollection, change: change, error: error))
+        }
+    }
+}
+
+// MARK: Unavailable
+
+extension List {
+    @available(*, unavailable, renamed:"append(objectsIn:)")
+    public func appendContentsOf<S: Sequence where S.Iterator.Element == T>(_ objects: S) { fatalError() }
+
+    @available(*, unavailable, renamed:"removeAllObjects()")
+    public func removeAll() { }
+
+    @available(*, unavailable, renamed:"removeLastObject()")
+    public func removeLast() { }
+
+    @available(*, unavailable, renamed: "remove(objectAtIndex:)")
+    public func remove(at index: Int) { }
+
+    @available(*, unavailable, renamed:"isInvalidated")
+    public var invalidated : Bool { fatalError() }
+
+    @available(*, unavailable, renamed:"indexOfObject(for:)")
+    public func index(of predicate: Predicate) -> Int? { fatalError() }
+
+    @available(*, unavailable, renamed:"indexOfObject(for:_:)")
+    public func index(of predicateFormat: String, _ args: AnyObject...) -> Int? { fatalError() }
+
+    @available(*, unavailable, renamed:"filter(using:)")
+    public func filter(_ predicate: Predicate) -> Results<T> { fatalError() }
+
+    @available(*, unavailable, renamed:"filter(using:_:)")
+    public func filter(_ predicateFormat: String, _ args: AnyObject...) -> Results<T> { fatalError() }
+
+    @available(*, unavailable, renamed:"sorted(onProperty:ascending:)")
+    public func sorted(_ property: String, ascending: Bool = true) -> Results<T> { fatalError() }
+
+    @available(*, unavailable, renamed:"sorted(with:)")
+    public func sorted<S: Sequence where S.Iterator.Element == SortDescriptor>(_ sortDescriptors: S) -> Results<T> {
+        fatalError()
+    }
+
+    @available(*, unavailable, renamed:"minimumValue(ofProperty:)")
+    public func min<U: MinMaxType>(_ property: String) -> U? { fatalError() }
+
+    @available(*, unavailable, renamed:"maximumValue(ofProperty:)")
+    public func max<U: MinMaxType>(_ property: String) -> U? { fatalError() }
+
+    @available(*, unavailable, renamed:"sum(ofProperty:)")
+    public func sum<U: AddableType>(_ property: String) -> U { fatalError() }
+
+    @available(*, unavailable, renamed:"average(ofProperty:)")
+    public func average<U: AddableType>(_ property: String) -> U? { fatalError() }
+}
+
+#else
+
+/// :nodoc:
+/// Internal class. Do not use directly.
+public class ListBase: RLMListBase {
+    // Printable requires a description property defined in Swift (and not obj-c),
+    // and it has to be defined as @objc override, which can't be done in a
+    // generic class.
+    /// Returns a human-readable description of the objects contained in the List.
+    @objc public override var description: String {
+        return descriptionWithMaxDepth(RLMDescriptionMaxDepth)
+    }
+
+    @objc private func descriptionWithMaxDepth(depth: UInt) -> String {
+        let type = "List<\(_rlmArray.objectClassName)>"
+        return gsub("RLMArray <0x[a-z0-9]+>", template: type, string: _rlmArray.descriptionWithMaxDepth(depth)) ?? type
+    }
+
+    /// Returns the number of objects in this List.
+    public var count: Int { return Int(_rlmArray.count) }
+}
+
+/**
+ `List` is the container type in Realm used to define to-many relationships.
+
+ Like Swift's `Array`, `List` is a generic type that is parameterized on the type of `Object` it stores.
+
+ Unlike Swift's native collections, `List`s are reference types, and are only immutable if the Realm that manages them
+ is opened as read-only.
+
+ Lists can be filtered and sorted with the same predicates as `Results<T>`.
+
+ Properties of `List` type defined on `Object` subclasses must be declared as `let` and cannot be `dynamic`.
+*/
+public final class List<T: Object>: ListBase {
+
+    /// The type of the elements contained within the collection.
+    public typealias Element = T
+
+    // MARK: Properties
+
+    /// The Realm which manages the list. Returns `nil` for unmanaged lists.
+    public var realm: Realm? {
+        return _rlmArray.realm.map { Realm($0) }
+    }
+
+    /// Indicates if the list can no longer be accessed.
+    public var invalidated: Bool { return _rlmArray.invalidated }
+
+    // MARK: Initializers
+
+    /// Creates a `List` that holds Realm model objects of type `T`.
+    public override init() {
+        super.init(array: RLMArray(objectClassName: (T.self as Object.Type).className()))
+    }
+
+    // MARK: Index Retrieval
+
+    /**
+     Returns the index of an object in the list, or `nil` if the object is not present.
+
+     - parameter object: An object to find.
+     */
+    public func indexOf(object: T) -> Int? {
+        return notFoundToNil(_rlmArray.indexOfObject(unsafeBitCast(object, RLMObject.self)))
+    }
+
+    /**
+     Returns the index of the first object in the list matching the predicate, or `nil` if no objects match.
+
+     - parameter predicate: The predicate with which to filter the objects.
+     */
+    public func indexOf(predicate: NSPredicate) -> Int? {
+        return notFoundToNil(_rlmArray.indexOfObjectWithPredicate(predicate))
+    }
+
+    /**
+     Returns the index of the first object in the list matching the predicate, or `nil` if no objects match.
+
+     - parameter predicateFormat: A predicate format string, optionally followed by a variable number of arguments.
+     */
+    public func indexOf(predicateFormat: String, _ args: AnyObject...) -> Int? {
+        return indexOf(NSPredicate(format: predicateFormat, argumentArray: args))
+    }
+
+    // MARK: Object Retrieval
+
+    /**
+     Returns the object at the given index (get), or replaces the object at the given index (set).
+
+     - warning: You can only set an object during a write transaction.
+
+     - parameter index: The index of the object to retrieve or replace.
+
+     - returns: The object at the given index.
+     */
+    public subscript(index: Int) -> T {
+        get {
+            throwForNegativeIndex(index)
+            return _rlmArray[UInt(index)] as! T
+        }
+        set {
+            throwForNegativeIndex(index)
+            return _rlmArray[UInt(index)] = unsafeBitCast(newValue, RLMObject.self)
+        }
+    }
+
+    /// Returns the first object in the list, or `nil` if the list is empty.
+    public var first: T? { return _rlmArray.firstObject() as! T? }
+
+    /// Returns the last object in the list, or `nil` if the list is empty.
+    public var last: T? { return _rlmArray.lastObject() as! T? }
+
+    // MARK: KVC
+
+    /**
+     Returns an `Array` containing the results of invoking `valueForKey(_:)` using `key` on each of the collection's
+     objects.
+
+     - parameter key: The name of the property whose values are desired.
+     */
+    public override func valueForKey(key: String) -> AnyObject? {
+        return _rlmArray.valueForKey(key)
+    }
+
+    /**
+     Returns an `Array` containing the results of invoking `valueForKeyPath(_:)` using `keyPath` on each of the
+     collection's objects.
+
+     - parameter keyPath: The key path to the property whose values are desired.
+     */
+    public override func valueForKeyPath(keyPath: String) -> AnyObject? {
+        return _rlmArray.valueForKeyPath(keyPath)
+    }
+
+    /**
+     Invokes `setValue(_:forKey:)` on each of the collection's objects using the specified `value` and `key`.
+
+     - warning: This method can only be called during a write transaction.
+
+     - parameter value: The object value.
+     - parameter key:   The name of the property whose value should be set on each object.
+     */
+    public override func setValue(value: AnyObject?, forKey key: String) {
+        return _rlmArray.setValue(value, forKey: key)
+    }
+
+    // MARK: Filtering
+
+    /**
+     Returns a `Results` containing all objects matching the given predicate in the list.
+
+     - parameter predicateFormat: A predicate format string; variable arguments are supported.
+    */
+    public func filter(predicateFormat: String, _ args: AnyObject...) -> Results<T> {
+        return Results<T>(_rlmArray.objectsWithPredicate(NSPredicate(format: predicateFormat, argumentArray: args)))
+    }
+
+    /**
+     Returns a `Results` containing all objects matching the given predicate in the list.
+
+     - parameter predicate: The predicate with which to filter the objects.
+     */
+    public func filter(predicate: NSPredicate) -> Results<T> {
+        return Results<T>(_rlmArray.objectsWithPredicate(predicate))
+    }
+
+    // MARK: Sorting
+
+    /**
+     Returns a `Results` containing the objects in the list, but sorted.
+
+     Objects are sorted based on the values of the given property. For example, to sort a list of `Student`s from
+     youngest to oldest based on their `age` property, you might call `students.sorted("age", ascending: true)`.
+
+     - warning: Lists may only be sorted by properties of boolean, `NSDate`, single and double-precision floating point,
+                integer, and string types.
+
+     - parameter property:  The name of the property to sort by.
+     - parameter ascending: The direction to sort in.
+     */
+    public func sorted(property: String, ascending: Bool = true) -> Results<T> {
+        return sorted([SortDescriptor(property: property, ascending: ascending)])
+    }
+
+    /**
+     Returns a `Results` containing the objects in the list, but sorted.
+
+     - warning: Lists may only be sorted by properties of boolean, `NSDate`, single and double-precision floating point,
+                integer, and string types.
+
+     - see: `sorted(_:ascending:)`
+
+     - parameter sortDescriptors: A sequence of `SortDescriptor`s to sort by.
+     */
+    public func sorted<S: SequenceType where S.Generator.Element == SortDescriptor>(sortDescriptors: S) -> Results<T> {
+        return Results<T>(_rlmArray.sortedResultsUsingDescriptors(sortDescriptors.map { $0.rlmSortDescriptorValue }))
+    }
+
+    // MARK: Aggregate Operations
+
+    /**
+     Returns the minimum (lowest) value of the given property among all the objects in the list.
+
+    - warning: Only a property whose type conforms to the `MinMaxType` protocol can be specified.
+
+    - parameter property: The name of a property whose minimum value is desired.
+
+    - returns: The minimum value of the property, or `nil` if the list is empty.
+    */
+    public func min<U: MinMaxType>(property: String) -> U? {
+        return filter(NSPredicate(value: true)).min(property)
+    }
+
+    /**
+     Returns the maximum (highest) value of the given property among all the objects in the list.
+
+     - warning: Only a property whose type conforms to the `MinMaxType` protocol can be specified.
+
+     - parameter property: The name of a property whose maximum value is desired.
+
+     - returns: The maximum value of the property, or `nil` if the list is empty.
+     */
+    public func max<U: MinMaxType>(property: String) -> U? {
+        return filter(NSPredicate(value: true)).max(property)
+    }
+
+    /**
+     Returns the sum of the values of a given property over all the objects in the list.
+
+     - warning: Only a property whose type conforms to the `AddableType` protocol can be specified.
+
+     - parameter property: The name of a property whose values should be summed.
+
+     - returns: The sum of the given property.
+     */
+    public func sum<U: AddableType>(property: String) -> U {
+        return filter(NSPredicate(value: true)).sum(property)
+    }
+
+    /**
+     Returns the average value of a given property over all the objects in the list.
+
+     - warning: Only a property whose type conforms to the `AddableType` protocol can be specified.
+
+     - parameter property: The name of a property whose average value should be calculated.
+
+     - returns: The average value of the given property, or `nil` if the list is empty.
+     */
+    public func average<U: AddableType>(property: String) -> U? {
+        return filter(NSPredicate(value: true)).average(property)
+    }
+
+    // MARK: Mutation
+
+    /**
+     Appends the given object to the end of the list.
+
+     If the object is managed by a different Realm than the receiver, a copy is made and added to the Realm managing
+     the receiver.
+
+     - warning: This method may only be called during a write transaction.
+
+     - parameter object: An object.
+     */
+    public func append(object: T) {
+        _rlmArray.addObject(unsafeBitCast(object, RLMObject.self))
+    }
+
+    /**
+     Appends the objects in the given sequence to the end of the list.
+
+     - warning: This method may only be called during a write transaction.
+
+     - parameter objects: A sequence of objects.
+    */
+    public func appendContentsOf<S: SequenceType where S.Generator.Element == T>(objects: S) {
+        for obj in objects {
+            _rlmArray.addObject(unsafeBitCast(obj, RLMObject.self))
+        }
+    }
+
+    /**
+     Inserts an object at the given index.
+
+     - warning: This method may only be called during a write transaction.
+
+     - warning: This method will throw an exception if called with an invalid index.
+
+     - parameter object: An object.
+     - parameter index:  The index at which to insert the object.
+     */
+    public func insert(object: T, atIndex index: Int) {
+        throwForNegativeIndex(index)
+        _rlmArray.insertObject(unsafeBitCast(object, RLMObject.self), atIndex: UInt(index))
+    }
+
+    /**
+     Removes an object at the given index. The object is not removed from the Realm that manages it.
+
+     - warning: This method may only be called during a write transaction.
+
+     - warning: This method will throw an exception if called with an invalid index.
+
+     - parameter index: The index at which to remove the object.
+    */
+    public func removeAtIndex(index: Int) {
+        throwForNegativeIndex(index)
+        _rlmArray.removeObjectAtIndex(UInt(index))
+    }
+
+    /**
+     Removes the last object in the list. The object is not removed from the Realm that manages it.
+
+     - warning: This method may only be called during a write transaction.
+     */
+    public func removeLast() {
+        _rlmArray.removeLastObject()
+    }
+
+    /**
+     Removes all objects from the list. The objects are not removed from the Realm that manages them.
+
+     - warning: This method may only be called during a write transaction.
+     */
+    public func removeAll() {
+        _rlmArray.removeAllObjects()
+    }
+
+    /**
+     Replaces an object at the given index with a new object.
+
+     - warning: This method may only be called during a write transaction.
+
+     - warning: This method will throw an exception if called with an invalid index.
+
+     - parameter index:  The index of the object to be replaced.
+     - parameter object: An object.
+     */
+    public func replace(index: Int, object: T) {
+        throwForNegativeIndex(index)
+        _rlmArray.replaceObjectAtIndex(UInt(index), withObject: unsafeBitCast(object, RLMObject.self))
+    }
+
+    /**
+     Moves the object at the given source index to the given destination index.
+
+     - warning: This method may only be called during a write transaction.
+
+     - warning: This method will throw an exception if called with invalid indices.
+
+     - parameter from:  The index of the object to be moved.
+     - parameter to:    index to which the object at `from` should be moved.
+     */
+    public func move(from from: Int, to: Int) { // swiftlint:disable:this variable_name
+        throwForNegativeIndex(from)
+        throwForNegativeIndex(to)
+        _rlmArray.moveObjectAtIndex(UInt(from), toIndex: UInt(to))
+    }
+
+    /**
+     Exchanges the objects in the list at given indices.
+
+     - warning: This method may only be called during a write transaction.
+
+     - warning: This method will throw an exception if called with invalid indices.
+
+     - parameter index1: The index of the object which should replace the object at index `index2`.
+     - parameter index2: The index of the object which should replace the object at index `index1`.
+    */
+    public func swap(index1: Int, _ index2: Int) {
+        throwForNegativeIndex(index1, parameterName: "index1")
+        throwForNegativeIndex(index2, parameterName: "index2")
+        _rlmArray.exchangeObjectAtIndex(UInt(index1), withObjectAtIndex: UInt(index2))
+    }
+
+    // MARK: Notifications
+
+    /**
+     Registers a block to be called each time the list changes.
+
+     The block will be asynchronously called with the initial list, and then
+     called again after each write transaction which changes the list or any of
+     the items in the list.
+
+     The `change` parameter that is passed to the block reports, in the form of indices within the
+     list, which of the objects were added, removed, or modified during each write transaction. See the
+     `RealmCollectionChange` documentation for more information on the change information supplied and an example of how
+     to use it to update a `UITableView`.
+
+     The block is called on the same thread as it was added on, and can only
+     be added on threads which are currently within a run loop. Unless you are
+     specifically creating and running a run loop on a background thread, this
+     will normally only be the main thread.
+
+     Notifications can't be delivered as long as the run loop is blocked by
+     other activity. When notifications can't be delivered instantly, multiple
+     notifications may be coalesced into a single notification. This can include
+     the notification with the initial list. For example, the following code
+     performs a write transaction immediately after adding the notification block,
+     so there is no opportunity for the initial notification to be delivered first.
+     As a result, the initial notification will reflect the state of the Realm
+     after the write transaction, and will not include change information.
+
+     ```swift
+     let person = realm.objects(Person.self).first!
+     print("dogs.count: \(person.dogs.count)") // => 0
+     let token = person.dogs.addNotificationBlock { changes in
+         switch changes {
+             case .Initial(let dogs):
+                 // Will print "dogs.count: 1"
+                 print("dogs.count: \(dogs.count)")
+                 break
+             case .Update:
+                 // Will not be hit in this example
+                 break
+             case .Error:
+                 break
+         }
+     }
+     try! realm.write {
+         let dog = Dog()
+         dog.name = "Rex"
+         person.dogs.append(dog)
+     }
+     // end of run loop execution context
+     ```
+
+     You must retain the returned token for as long as you want updates to be sent to the block. To stop receiving
+     updates, call `stop()` on the token.
+
+     - warning: This method cannot be called during a write transaction, or when
+     the containing Realm is read-only.
+     - warning: This method may only be called on a managed list.
+
+     - parameter block: The block to be called each time the list changes.
+     - returns: A token which must be held for as long as you want updates to be delivered.
+     */
+    @warn_unused_result(message="You must hold on to the NotificationToken returned from addNotificationBlock")
+    public func addNotificationBlock(block: (RealmCollectionChange<List>) -> ()) -> NotificationToken {
+        return _rlmArray.addNotificationBlock { list, change, error in
+            block(RealmCollectionChange.fromObjc(self, change: change, error: error))
+        }
+    }
+}
+
+extension List: RealmCollectionType, RangeReplaceableCollectionType {
+    // MARK: Sequence Support
+
+    /// Returns an `RLMGenerator` that yields successive elements in the list.
+    public func generate() -> RLMGenerator<T> {
+        return RLMGenerator(collection: _rlmArray)
+    }
+
+    // MARK: RangeReplaceableCollection Support
+
+    /**
+     Replace the given `subRange` of elements with `newElements`.
+
+     - parameter subRange:    The range of elements to be replaced.
+     - parameter newElements: The new elements to be inserted into the list.
+    */
+    public func replaceRange<C: CollectionType where C.Generator.Element == T>(subRange: Range<Int>,
+                                                                               with newElements: C) {
+        for _ in subRange {
+            removeAtIndex(subRange.startIndex)
+        }
+        for x in newElements.reverse() {
+            insert(x, atIndex: subRange.startIndex)
+        }
+    }
+
+    /// The position of the first element in a non-empty collection.
+    /// Identical to `endIndex` in an empty collection.
+    public var startIndex: Int { return 0 }
+
+    /// The collection's "past the end" position.
+    /// `endIndex` is not a valid argument to subscript, and is always reachable from `startIndex` by
+    /// zero or more applications of `successor()`.
+    public var endIndex: Int { return count }
+
+    /// :nodoc:
+    public func _addNotificationBlock(block: (RealmCollectionChange<AnyRealmCollection<T>>) -> Void) ->
+        NotificationToken {
+        let anyCollection = AnyRealmCollection(self)
+        return _rlmArray.addNotificationBlock { _, change, error in
+            block(RealmCollectionChange.fromObjc(anyCollection, change: change, error: error))
+        }
+    }
+}
+
+#endif
diff --git a/Pods/RealmSwift/RealmSwift/Migration.swift b/Pods/RealmSwift/RealmSwift/Migration.swift
new file mode 100644
index 0000000..231be03
--- /dev/null
+++ b/Pods/RealmSwift/RealmSwift/Migration.swift
@@ -0,0 +1,406 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+import Foundation
+import Realm
+import Realm.Private
+
+#if swift(>=3.0)
+
+/**
+Migration block used to migrate a Realm.
+
+- parameter migration: `Migration` object used to perform the migration. The
+                       migration object allows you to enumerate and alter any
+                       existing objects which require migration.
+- parameter oldSchemaVersion: The schema version of the `Realm` being migrated.
+*/
+public typealias MigrationBlock = (migration: Migration, oldSchemaVersion: UInt64) -> Void
+
+/// Object class used during migrations.
+public typealias MigrationObject = DynamicObject
+
+/**
+Provides both the old and new versions of an object in this Realm. Object properties can only be
+accessed using subscripting.
+
+- parameter oldObject: Object in original `Realm` (read-only).
+- parameter newObject: Object in migrated `Realm` (read-write).
+*/
+public typealias MigrationObjectEnumerateBlock = (oldObject: MigrationObject?, newObject: MigrationObject?) -> Void
+
+/**
+Get the schema version for a Realm at a given local URL.
+
+- parameter fileURL:       Local URL to a Realm file.
+- parameter encryptionKey: Optional 64-byte encryption key for encrypted Realms.
+
+- throws: An NSError that describes the problem.
+
+- returns: The version of the Realm at `fileURL`.
+*/
+public func schemaVersionAtURL(_ fileURL: URL, encryptionKey: Data? = nil) throws -> UInt64 {
+    var error: NSError?
+    let version = RLMRealm.__schemaVersion(at: fileURL, encryptionKey: encryptionKey, error: &error)
+    guard version != RLMNotVersioned else {
+        throw error!
+    }
+    return version
+}
+
+/**
+Performs the configuration's migration block on the Realm created by the given
+configuration.
+
+This method is called automatically when opening a Realm for the first time and does
+not need to be called explicitly. You can choose to call this method to control
+exactly when and how migrations are performed.
+
+- parameter configuration: The Realm.Configuration used to create the Realm to be
+                           migrated, and containing the schema version and migration
+                           block used to perform the migration.
+
+- returns: `nil` if the migration was successful, or an `NSError` object that describes the problem
+           that occurred otherwise.
+*/
+@discardableResult
+public func migrateRealm(_ configuration: Realm.Configuration = Realm.Configuration.defaultConfiguration) throws {
+    if let error = RLMRealm.migrateRealm(configuration.rlmConfiguration) {
+        throw error
+    }
+}
+
+
+/**
+`Migration` is the object passed into a user-defined `MigrationBlock` when updating the version
+of a `Realm` instance.
+
+This object provides access to the previous and current `Schema`s for this migration.
+*/
+public final class Migration {
+
+    // MARK: Properties
+
+    /// The migration's old `Schema`, describing the `Realm` before applying a migration.
+    public var oldSchema: Schema { return Schema(rlmMigration.oldSchema) }
+
+    /// The migration's new `Schema`, describing the `Realm` after applying a migration.
+    public var newSchema: Schema { return Schema(rlmMigration.newSchema) }
+
+    internal var rlmMigration: RLMMigration
+
+    // MARK: Altering Objects During a Migration
+
+    /**
+    Enumerates objects of a given type in this Realm, providing both the old and new versions of
+    each object. Object properties can be accessed using subscripting.
+
+    - parameter objectClassName: The name of the `Object` class to enumerate.
+    - parameter block:           The block providing both the old and new versions of an object in this Realm.
+    */
+    public func enumerateObjects(ofType typeName: String, _ block: MigrationObjectEnumerateBlock) {
+        rlmMigration.enumerateObjects(typeName) {
+            block(oldObject: unsafeBitCast($0, to: MigrationObject.self),
+                  newObject: unsafeBitCast($1, to: MigrationObject.self))
+        }
+    }
+
+    /**
+    Create an `Object` of type `className` in the Realm being migrated.
+
+    - parameter className: The name of the `Object` class to create.
+    - parameter value:     The object used to populate the new `Object`. This can be any key/value coding
+                           compliant object, or a JSON object such as those returned from the methods in
+                           `NSJSONSerialization`, or an `Array` with one object for each persisted
+                           property. An exception will be thrown if any required properties are not
+                           present and no default is set.
+
+    - returns: The created object.
+    */
+    @discardableResult
+    public func createObject(ofType typeName: String, populatedWith value: AnyObject = [:]) -> MigrationObject {
+        return unsafeBitCast(rlmMigration.createObject(typeName, withValue: value), to: MigrationObject.self)
+    }
+
+    /**
+    Delete an object from a Realm during a migration. This can be called within
+    `enumerate(_:block:)`.
+
+    - parameter object: Object to be deleted from the Realm being migrated.
+    */
+    public func delete(_ object: MigrationObject) {
+        RLMDeleteObjectFromRealm(object, RLMObjectBaseRealm(object))
+    }
+
+    /**
+    Deletes the data for the class with the given name.
+    This deletes all objects of the given class, and if the Object subclass no longer exists in your program,
+    cleans up any remaining metadata for the class in the Realm file.
+
+    - parameter objectClassName: The name of the Object class to delete.
+
+    - returns: `true` if there was any data to delete.
+    */
+    @discardableResult
+    public func deleteData(forType typeName: String) -> Bool {
+        return rlmMigration.deleteData(forClassName: typeName)
+    }
+
+    /**
+    Rename property of the given class from `oldName` to `newName`.
+
+    - parameter className: Class for which the property is to be renamed. Must be present
+                           in both the old and new Realm schemas.
+    - parameter oldName:   Old name for the property to be renamed. Must not be present
+                           in the new Realm.
+    - parameter newName:   New name for the property to be renamed. Must not be present
+                           in the old Realm.
+    */
+    public func renameProperty(onType typeName: String, from oldName: String, to newName: String) {
+        rlmMigration.renameProperty(forClass: typeName, oldName: oldName, newName: newName)
+    }
+
+    private init(_ rlmMigration: RLMMigration) {
+        self.rlmMigration = rlmMigration
+    }
+}
+
+
+// MARK: Private Helpers
+
+internal func accessorMigrationBlock(_ migrationBlock: MigrationBlock) -> RLMMigrationBlock {
+    return { migration, oldVersion in
+        // set all accessor classes to MigrationObject
+        for objectSchema in migration.oldSchema.objectSchema {
+            objectSchema.accessorClass = MigrationObject.self
+            // isSwiftClass is always `false` for object schema generated
+            // from the table, but we need to pretend it's from a swift class
+            // (even if it isn't) for the accessors to be initialized correctly.
+            objectSchema.isSwiftClass = true
+        }
+        for objectSchema in migration.newSchema.objectSchema {
+            objectSchema.accessorClass = MigrationObject.self
+        }
+
+        // run migration
+        migrationBlock(migration: Migration(migration), oldSchemaVersion: oldVersion)
+    }
+}
+
+// MARK: Unavailable
+
+extension Migration {
+    @available(*, unavailable, renamed:"enumerateObjects(ofType:_:)")
+    public func enumerate(_ objectClassName: String, _ block: MigrationObjectEnumerateBlock) { }
+
+    @available(*, unavailable, renamed:"createObject(ofType:populatedWith:)")
+    public func create(_ className: String, value: AnyObject = [:]) -> MigrationObject {
+        fatalError()
+    }
+
+    @available(*, unavailable, renamed:"deleteData(forType:)")
+    public func deleteData(_ objectClassName: String) -> Bool {
+        fatalError()
+    }
+
+    @available(*, unavailable, renamed: "renameProperty(onType:from:to:)")
+    public func renamePropertyForClass(_ className: String, oldName: String, newName: String) { }
+}
+
+#else
+
+/**
+ The type of a migration block used to migrate a Realm.
+
+ - parameter migration:  A `RLMMigration` object used to perform the migration. The
+                         migration object allows you to enumerate and alter any
+                         existing objects which require migration.
+
+ - parameter oldSchemaVersion: The schema version of the Realm being migrated.
+*/
+public typealias MigrationBlock = (migration: Migration, oldSchemaVersion: UInt64) -> Void
+
+/// An object class used during migrations.
+public typealias MigrationObject = DynamicObject
+
+/**
+ A block type which provides both the old and new versions of an object in the Realm. Object
+ properties can only be accessed using subscripting.
+
+ - parameter oldObject: The object from the original Realm (read-only).
+ - parameter newObject: The object from the migrated Realm (read-write).
+*/
+public typealias MigrationObjectEnumerateBlock = (oldObject: MigrationObject?, newObject: MigrationObject?) -> Void
+
+/**
+ Returns the schema version for a Realm at a given local URL.
+
+ - parameter fileURL:       Local URL to a Realm file.
+ - parameter encryptionKey: 64-byte key used to encrypt the file, or `nil` if it is unencrypted.
+
+ - throws: An `NSError` that describes the problem.
+
+ - returns: The version of the Realm at `fileURL`.
+*/
+public func schemaVersionAtURL(fileURL: NSURL, encryptionKey: NSData? = nil) throws -> UInt64 {
+    var error: NSError?
+    let version = RLMRealm.__schemaVersionAtURL(fileURL, encryptionKey: encryptionKey, error: &error)
+    guard version != RLMNotVersioned else {
+        throw error!
+    }
+    return version
+}
+
+/**
+ Performs the given Realm configuration's migration block on a Realm at the given path.
+
+ This method is called automatically when opening a Realm for the first time and does
+ not need to be called explicitly. You can choose to call this method to control
+ exactly when and how migrations are performed.
+
+ - parameter configuration: The Realm configuration used to open and migrate the Realm.
+
+ - returns: An `NSError` that describes an error that occurred while applying the migration, if any.
+*/
+public func migrateRealm(configuration: Realm.Configuration = Realm.Configuration.defaultConfiguration) -> NSError? {
+    return RLMRealm.migrateRealm(configuration.rlmConfiguration)
+}
+
+
+/**
+ `Migration` instances encapsulate information intended to facilitate a schema migration.
+
+ A `Migration` instance is passed into a user-defined `MigrationBlock` block when updating
+ the version of a Realm. This instance provides access to the old and new database schemas, the
+ objects in the Realm, and provides functionality for modifying the Realm during the migration.
+*/
+public final class Migration {
+
+    // MARK: Properties
+
+    /// Returns the old schema, describing the Realm before applying a migration.
+    public var oldSchema: Schema { return Schema(rlmMigration.oldSchema) }
+
+    /// Returns the new schema, describing the Realm after applying a migration.
+    public var newSchema: Schema { return Schema(rlmMigration.newSchema) }
+
+    internal var rlmMigration: RLMMigration
+
+    // MARK: Altering Objects During a Migration
+
+    /**
+     Enumerates all the objects of a given type in this Realm, providing both the old and new versions of
+     each object. Object properties can be accessed using subscripting.
+
+     - parameter objectClassName: The name of the `Object` class to enumerate.
+     - parameter block:           The block providing both the old and new versions of an object in this Realm.
+     */
+    public func enumerate(objectClassName: String, _ block: MigrationObjectEnumerateBlock) {
+        rlmMigration.enumerateObjects(objectClassName) {
+            block(oldObject: unsafeBitCast($0, MigrationObject.self),
+                  newObject: unsafeBitCast($1, MigrationObject.self))
+        }
+    }
+
+    /**
+     Creates and returns an `Object` of type `className` in the Realm being migrated.
+
+     The `value` argument is used to populate the object. It can be a key-value coding compliant object, an array or
+     dictionary returned from the methods in `NSJSONSerialization`, or an `Array` containing one element for each
+     managed property. An exception will be thrown if any required properties are not present and those properties were
+     not defined with default values.
+
+     When passing in an `Array` as the `value` argument, all properties must be present, valid and in the same order as
+     the properties defined in the model.
+
+     - parameter className: The name of the `Object` class to create.
+     - parameter value:     The value used to populate the created object.
+
+     - returns: The newly created object.
+     */
+    public func create(className: String, value: AnyObject = [:]) -> MigrationObject {
+        return unsafeBitCast(rlmMigration.createObject(className, withValue: value), MigrationObject.self)
+    }
+
+    /**
+     Deletes an object from a Realm during a migration.
+
+     It is permitted to call this method from within the block passed to `enumerate(_:block:)`.
+
+     - parameter object: An object to be deleted from the Realm being migrated.
+     */
+    public func delete(object: MigrationObject) {
+        RLMDeleteObjectFromRealm(object, RLMObjectBaseRealm(object))
+    }
+
+    /**
+     Deletes the data for the class with the given name.
+
+     All objects of the given class will be deleted. If the `Object` subclass no longer exists in your program, any
+     remaining metadata for the class will be removed from the Realm file.
+
+     - parameter objectClassName: The name of the `Object` class to delete.
+
+     - returns: A Boolean value indicating whether there was any data to delete.
+     */
+    public func deleteData(objectClassName: String) -> Bool {
+        return rlmMigration.deleteDataForClassName(objectClassName)
+    }
+
+    /**
+     Renames a property of the given class from `oldName` to `newName`.
+
+     - parameter className: The name of the class whose property should be renamed. This class must be present
+                            in both the old and new Realm schemas.
+     - parameter oldName:   The old name for the property to be renamed. There must not be a property with this name in
+                            the class as defined by the new Realm schema.
+     - parameter newName:   The new name for the property to be renamed. There must not be a property with this name in
+                            the class as defined by the old Realm schema.
+    */
+    public func renamePropertyForClass(className: String, oldName: String, newName: String) {
+        rlmMigration.renamePropertyForClass(className, oldName: oldName, newName: newName)
+    }
+
+    private init(_ rlmMigration: RLMMigration) {
+        self.rlmMigration = rlmMigration
+    }
+}
+
+
+// MARK: Private Helpers
+
+internal func accessorMigrationBlock(migrationBlock: MigrationBlock) -> RLMMigrationBlock {
+    return { migration, oldVersion in
+        // set all accessor classes to MigrationObject
+        for objectSchema in migration.oldSchema.objectSchema {
+            objectSchema.accessorClass = MigrationObject.self
+            // isSwiftClass is always `false` for object schema generated
+            // from the table, but we need to pretend it's from a swift class
+            // (even if it isn't) for the accessors to be initialized correctly.
+            objectSchema.isSwiftClass = true
+        }
+        for objectSchema in migration.newSchema.objectSchema {
+            objectSchema.accessorClass = MigrationObject.self
+        }
+
+        // run migration
+        migrationBlock(migration: Migration(migration), oldSchemaVersion: oldVersion)
+    }
+}
+
+#endif
diff --git a/Pods/RealmSwift/RealmSwift/Object.swift b/Pods/RealmSwift/RealmSwift/Object.swift
new file mode 100644
index 0000000..80849f1
--- /dev/null
+++ b/Pods/RealmSwift/RealmSwift/Object.swift
@@ -0,0 +1,833 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+import Foundation
+import Realm
+import Realm.Private
+
+#if swift(>=3.0)
+
+/**
+In Realm you define your model classes by subclassing `Object` and adding properties to be persisted.
+You then instantiate and use your custom subclasses instead of using the Object class directly.
+
+```swift
+class Dog: Object {
+    dynamic var name: String = ""
+    dynamic var adopted: Bool = false
+    let siblings = List<Dog>()
+}
+```
+
+### Supported property types
+
+- `String`, `NSString`
+- `Int`
+- `Int8`, `Int16`, `Int32`, `Int64`
+- `Float`
+- `Double`
+- `Bool`
+- `NSDate`
+- `NSData`
+- `RealmOptional<T>` for optional numeric properties
+- `Object` subclasses for to-one relationships
+- `List<T: Object>` for to-many relationships
+
+`String`, `NSString`, `NSDate`, `NSData` and `Object` subclass properties can be
+optional. `Int`, `Int8`, Int16`, Int32`, `Int64`, `Float`, `Double`, `Bool`
+and `List` properties cannot. To store an optional number, instead use
+`RealmOptional<Int>`, `RealmOptional<Float>`, `RealmOptional<Double>`, or
+`RealmOptional<Bool>` instead, which wraps an optional value of the generic type.
+
+All property types except for `List` and `RealmOptional` *must* be declared as
+`dynamic var`. `List` and `RealmOptional` properties must be declared as
+non-dynamic `let` properties.
+
+### Querying
+
+You can gets `Results` of an Object subclass via the `objects(_:)` instance
+method on `Realm`.
+
+### Relationships
+
+See our [Cocoa guide](http://realm.io/docs/cocoa) for more details.
+*/
+@objc(RealmSwiftObject)
+public class Object: RLMObjectBase {
+
+    // MARK: Initializers
+
+    /**
+    Initialize a standalone (unpersisted) `Object`.
+    Call `add(_:)` on a `Realm` to add standalone objects to a realm.
+
+    - see: Realm().add(_:)
+    */
+    public override required init() {
+        super.init()
+    }
+
+    /**
+    Initialize a standalone (unpersisted) `Object` with values from an `Array<AnyObject>` or
+    `Dictionary<String, AnyObject>`.
+    Call `add(_:)` on a `Realm` to add standalone objects to a realm.
+
+    - parameter value: The value used to populate the object. This can be any key/value coding compliant
+                       object, or a JSON object such as those returned from the methods in `NSJSONSerialization`,
+                       or an `Array` with one object for each persisted property. An exception will be
+                       thrown if any required properties are not present and no default is set.
+    */
+    public init(value: AnyObject) {
+        self.dynamicType.sharedSchema() // ensure this class' objectSchema is loaded in the partialSharedSchema
+        super.init(value: value, schema: RLMSchema.partialShared())
+    }
+
+
+    // MARK: Properties
+
+    /// The `Realm` this object belongs to, or `nil` if the object
+    /// does not belong to a realm (the object is standalone).
+    public var realm: Realm? {
+        if let rlmReam = RLMObjectBaseRealm(self) {
+            return Realm(rlmReam)
+        }
+        return nil
+    }
+
+    /// The `ObjectSchema` which lists the persisted properties for this object.
+    public var objectSchema: ObjectSchema {
+        return ObjectSchema(RLMObjectBaseObjectSchema(self))
+    }
+
+    /// Indicates if an object can no longer be accessed.
+    ///
+    /// An object can no longer be accessed if the object has been deleted from the containing
+    /// `realm` or if `invalidate` is called on the containing `realm`.
+    public override var isInvalidated: Bool { return super.isInvalidated }
+
+    /// Returns a human-readable description of this object.
+    public override var description: String { return super.description }
+
+    #if os(OSX)
+    /// Helper to return the class name for an Object subclass.
+    public final override var className: String { return "" }
+    #else
+    /// Helper to return the class name for an Object subclass.
+    public final var className: String { return "" }
+    #endif
+
+    /**
+    WARNING: This is an internal helper method not intended for public use.
+    :nodoc:
+    */
+    public override class func objectUtilClass(_ isSwift: Bool) -> AnyClass {
+        return ObjectUtil.self
+    }
+
+
+    // MARK: Object Customization
+
+    /**
+    Override to designate a property as the primary key for an `Object` subclass. Only properties of
+    type String and Int can be designated as the primary key. Primary key
+    properties enforce uniqueness for each value whenever the property is set which incurs some overhead.
+    Indexes are created automatically for primary key properties.
+
+    - returns: Name of the property designated as the primary key, or `nil` if the model has no primary key.
+    */
+    public class func primaryKey() -> String? { return nil }
+
+    /**
+    Override to return an array of property names to ignore. These properties will not be persisted
+    and are treated as transient.
+
+    - returns: `Array` of property names to ignore.
+    */
+    public class func ignoredProperties() -> [String] { return [] }
+
+    /**
+    Return an array of property names for properties which should be indexed.
+    Only supported for string, integer, boolean and NSDate properties.
+
+    - returns: `Array` of property names to index.
+    */
+    public class func indexedProperties() -> [String] { return [] }
+
+
+    // MARK: Key-Value Coding & Subscripting
+
+    /// Returns or sets the value of the property with the given name.
+    public subscript(key: String) -> AnyObject? {
+        get {
+            if realm == nil {
+                return value(forKey: key)
+            }
+            let property = RLMValidatedGetProperty(self, key)
+            if property.type == .array {
+                return listForProperty(prop: property)
+            }
+            // No special logic is needed for optional numbers here because the NSNumber returned by RLMDynamicGet
+            // is better for callers than the RealmOptional that optionalForProperty would give us.
+            return RLMDynamicGet(self, property)
+        }
+        set(value) {
+            if realm == nil {
+                setValue(value, forKey: key)
+            } else {
+                RLMDynamicValidatedSet(self, key, value)
+            }
+        }
+    }
+
+    // MARK: Dynamic list
+
+    /**
+    This method is useful only in specialized circumstances, for example, when building
+    components that integrate with Realm. If you are simply building an app on Realm, it is
+    recommended to use instance variables or cast the KVC returns.
+
+    Returns a List of DynamicObjects for a property name
+
+    - warning: This method is useful only in specialized circumstances
+
+    - parameter propertyName: The name of the property to get a List<DynamicObject>
+
+    - returns: A List of DynamicObjects
+
+    :nodoc:
+    */
+    public func dynamicList(_ propertyName: String) -> List<DynamicObject> {
+        return unsafeBitCast(listForProperty(prop: RLMValidatedGetProperty(self, propertyName)), to: List<DynamicObject>.self)
+    }
+
+    // MARK: Equatable
+
+    /**
+    Returns whether both objects are equal.
+
+    Objects are considered equal when they are both from the same Realm and point to the same
+    underlying object in the database.
+
+    - parameter object: Object to compare for equality.
+    */
+    public override func isEqual(_ object: AnyObject?) -> Bool {
+        return RLMObjectBaseAreEqual(self as RLMObjectBase?, object as? RLMObjectBase)
+    }
+
+    // MARK: Private functions
+
+    // FIXME: None of these functions should be exposed in the public interface.
+
+    /**
+    WARNING: This is an internal initializer not intended for public use.
+    :nodoc:
+    */
+    public override required init(realm: RLMRealm, schema: RLMObjectSchema) {
+        super.init(realm: realm, schema: schema)
+    }
+
+    /**
+    WARNING: This is an internal initializer not intended for public use.
+    :nodoc:
+    */
+    public override required init(value: AnyObject, schema: RLMSchema) {
+        super.init(value: value, schema: schema)
+    }
+
+    // Helper for getting the list object for a property
+    internal func listForProperty(prop: RLMProperty) -> RLMListBase {
+        return object_getIvar(self, prop.swiftIvar) as! RLMListBase
+    }
+
+    // Helper for getting the optional object for a property
+    internal func optionalForProperty(prop: RLMProperty) -> RLMOptionalBase {
+        return object_getIvar(self, prop.swiftIvar) as! RLMOptionalBase
+    }
+
+    // Helper for getting the linking objects object for a property
+    internal func linkingObjectsForProperty(prop: RLMProperty) -> LinkingObjectsBase? {
+        return object_getIvar(self, prop.swiftIvar) as? LinkingObjectsBase
+    }
+}
+
+
+
+/// Object interface which allows untyped getters and setters for Objects.
+/// :nodoc:
+public final class DynamicObject: Object {
+    private var listProperties = [String: List<DynamicObject>]()
+    private var optionalProperties = [String: RLMOptionalBase]()
+
+    // Override to create List<DynamicObject> on access
+    internal override func listForProperty(prop: RLMProperty) -> RLMListBase {
+        if let list = listProperties[prop.name] {
+            return list
+        }
+        let list = List<DynamicObject>()
+        listProperties[prop.name] = list
+        return list
+    }
+
+    // Override to create RealmOptional on access
+    internal override func optionalForProperty(prop: RLMProperty) -> RLMOptionalBase {
+        if let optional = optionalProperties[prop.name] {
+            return optional
+        }
+        let optional = RLMOptionalBase()
+        optional?.property = prop
+        optionalProperties[prop.name] = optional
+        return optional!
+    }
+
+    // Dynamic objects never have linking objects properties
+    internal override func linkingObjectsForProperty(prop: RLMProperty) -> LinkingObjectsBase? {
+        return nil
+    }
+
+    /// :nodoc:
+    public override func value(forUndefinedKey key: String) -> AnyObject? {
+        return self[key]
+    }
+
+    /// :nodoc:
+    public override func setValue(_ value: AnyObject?, forUndefinedKey key: String) {
+        self[key] = value
+    }
+
+    /// :nodoc:
+    public override class func shouldIncludeInDefaultSchema() -> Bool {
+        return false
+    }
+}
+
+/// :nodoc:
+/// Internal class. Do not use directly.
+@objc(RealmSwiftObjectUtil)
+public class ObjectUtil: NSObject {
+    @objc private class func swiftVersion() -> NSString {
+        return swiftLanguageVersion as NSString
+    }
+
+    @objc private class func ignoredPropertiesForClass(_ type: AnyClass) -> NSArray? {
+        if let type = type as? Object.Type {
+            return type.ignoredProperties() as NSArray?
+        }
+        return nil
+    }
+
+    @objc private class func indexedPropertiesForClass(_ type: AnyClass) -> NSArray? {
+        if let type = type as? Object.Type {
+            return type.indexedProperties() as NSArray?
+        }
+        return nil
+    }
+
+    @objc private class func linkingObjectsPropertiesForClass(_ type: AnyClass) -> NSDictionary? {
+        // Not used for Swift. getLinkingObjectsProperties(_:) is used instead.
+        return nil
+    }
+
+    // Get the names of all properties in the object which are of type List<>.
+    @objc private class func getGenericListPropertyNames(_ object: AnyObject) -> NSArray {
+        return Mirror(reflecting: object).children.filter { (prop: Mirror.Child) in
+            return prop.value.dynamicType is RLMListBase.Type
+        }.flatMap { (prop: Mirror.Child) in
+            return prop.label
+        } as NSArray
+    }
+
+    @objc private class func initializeListProperty(_ object: RLMObjectBase, property: RLMProperty, array: RLMArray<RLMObject>) {
+        (object as! Object).listForProperty(prop: property)._rlmArray = array
+    }
+
+    @objc private class func initializeOptionalProperty(_ object: RLMObjectBase, property: RLMProperty) {
+        let optional = (object as! Object).optionalForProperty(prop: property)
+        optional.property = property
+        optional.object = object
+    }
+
+    // swiftlint:disable:next cyclomatic_complexity
+    @objc private class func getOptionalProperties(_ object: AnyObject) -> NSDictionary {
+        let children = Mirror(reflecting: object).children
+        return children.reduce([String: AnyObject]()) { (properties: [String:AnyObject], prop: Mirror.Child) in
+            guard let name = prop.label else { return properties }
+            let mirror = Mirror(reflecting: prop.value)
+            let type = mirror.subjectType
+            var properties = properties
+            if type is Optional<String>.Type || type is Optional<NSString>.Type {
+                properties[name] = NSNumber(value: PropertyType.string.rawValue)
+            } else if type is Optional<NSDate>.Type {
+                properties[name] = NSNumber(value: PropertyType.date.rawValue)
+            } else if type is Optional<NSData>.Type {
+                properties[name] = NSNumber(value: PropertyType.data.rawValue)
+            } else if type is Optional<Object>.Type {
+                properties[name] = NSNumber(value: PropertyType.object.rawValue)
+            } else if type is RealmOptional<Int>.Type ||
+                      type is RealmOptional<Int8>.Type ||
+                      type is RealmOptional<Int16>.Type ||
+                      type is RealmOptional<Int32>.Type ||
+                      type is RealmOptional<Int64>.Type {
+                properties[name] = NSNumber(value: PropertyType.int.rawValue)
+            } else if type is RealmOptional<Float>.Type {
+                properties[name] = NSNumber(value: PropertyType.float.rawValue)
+            } else if type is RealmOptional<Double>.Type {
+                properties[name] = NSNumber(value: PropertyType.double.rawValue)
+            } else if type is RealmOptional<Bool>.Type {
+                properties[name] = NSNumber(value: PropertyType.bool.rawValue)
+            } else if prop.value as? RLMOptionalBase != nil {
+                throwRealmException("'\(type)' is not a a valid RealmOptional type.")
+            } else if mirror.displayStyle == .optional || type is NilLiteralConvertible.Type {
+                properties[name] = NSNull()
+            }
+            return properties
+        } as NSDictionary
+    }
+
+    @objc private class func requiredPropertiesForClass(_: AnyClass) -> NSArray? {
+        return nil
+    }
+
+    // Get information about each of the linking objects properties.
+    @objc private class func getLinkingObjectsProperties(_ object: AnyObject) -> NSDictionary {
+        let properties = Mirror(reflecting: object).children.filter { (prop: Mirror.Child) in
+            return prop.value as? LinkingObjectsBase != nil
+        }.flatMap { (prop: Mirror.Child) in
+            (prop.label!, prop.value as! LinkingObjectsBase)
+        }
+        return properties.reduce([String : [String: String ]]()) { (dictionary, property) in
+            var d = dictionary
+            let (name, results) = property
+            d[name] = ["class": results.objectClassName, "property": results.propertyName]
+            return d
+        } as NSDictionary
+    }
+
+    @objc private class func initializeLinkingObjectsProperty(_ object: RLMObjectBase, property: RLMProperty) {
+        guard let linkingObjects = (object as! Object).linkingObjectsForProperty(prop: property) else { return }
+        linkingObjects.attachTo(object: object, property: property)
+    }
+}
+
+#else
+
+/**
+ `Object` is a class used to define Realm model objects.
+
+ In Realm you define your model classes by subclassing `Object` and adding properties to be managed.
+ You then instantiate and use your custom subclasses instead of using the `Object` class directly.
+
+ ```swift
+ class Dog: Object {
+     dynamic var name: String = ""
+     dynamic var adopted: Bool = false
+     let siblings = List<Dog>()
+ }
+ ```
+
+ ### Supported property types
+
+ - `String`, `NSString`
+ - `Int`
+ - `Int8`, `Int16`, `Int32`, `Int64`
+ - `Float`
+ - `Double`
+ - `Bool`
+ - `NSDate`
+ - `NSData`
+ - `RealmOptional<T>` for optional numeric properties
+ - `Object` subclasses, to model many-to-one relationships
+ - `List<T>`, to model many-to-many relationships
+
+ `String`, `NSString`, `NSDate`, `NSData` and `Object` subclass properties can be declared as optional. `Int`, `Int8`,
+ Int16`, Int32`, `Int64`, `Float`, `Double`, `Bool`, and `List` properties cannot. To store an optional number, use
+ `RealmOptional<Int>`, `RealmOptional<Float>`, `RealmOptional<Double>`, or `RealmOptional<Bool>` instead, which wraps an
+ optional numeric value.
+
+ All property types except for `List` and `RealmOptional` *must* be declared as `dynamic var`. `List` and
+ `RealmOptional` properties must be declared as non-dynamic `let` properties.
+
+ ### Querying
+
+ You can retrieve all objects of a given type from a Realm by calling the `objects(_:)` instance method.
+
+ ### Relationships
+
+ See our [Cocoa guide](http://realm.io/docs/cocoa) for more details.
+*/
+@objc(RealmSwiftObject)
+public class Object: RLMObjectBase {
+
+    // MARK: Initializers
+
+    /**
+     Initializes an unmanaged instance of a Realm object.
+
+     Call `add(_:)` on a `Realm` instance to add an unmanaged object into that Realm.
+
+     - see: `Realm().add(_:)`
+    */
+    public override required init() {
+        super.init()
+    }
+
+    /**
+     Initializes an unmanaged instance of a Realm object.
+
+     The `value` argument is used to populate the object. It can be a key-value coding compliant object, an array or
+     dictionary returned from the methods in `NSJSONSerialization`, or an `Array` containing one element for each
+     managed property. An exception will be thrown if any required properties are not present and those properties were
+     not defined with default values.
+
+     When passing in an `Array` as the `value` argument, all properties must be present, valid and in the same order as
+     the properties defined in the model.
+
+     Call `add(_:)` on a `Realm` instance to add an unmanaged object into that Realm.
+
+     - parameter value:  The value used to populate the object.
+    */
+    public init(value: AnyObject) {
+        self.dynamicType.sharedSchema() // ensure this class' objectSchema is loaded in the partialSharedSchema
+        super.init(value: value, schema: RLMSchema.partialSharedSchema())
+    }
+
+
+    // MARK: Properties
+
+    /// The Realm which manages the object, or `nil` if the object is unmanaged.
+    public var realm: Realm? {
+        if let rlmReam = RLMObjectBaseRealm(self) {
+            return Realm(rlmReam)
+        }
+        return nil
+    }
+
+    /// The object schema which lists the managed properties for the object.
+    public var objectSchema: ObjectSchema {
+        return ObjectSchema(RLMObjectBaseObjectSchema(self))
+    }
+
+    /// Indicates if the object can no longer be accessed because it is now invalid.
+    ///
+    /// An object can no longer be accessed if the object has been deleted from the Realm that manages it, or if
+    /// `invalidate` is called on that Realm.
+    public override var invalidated: Bool { return super.invalidated }
+
+    /// Returns a human-readable description of the object.
+    public override var description: String { return super.description }
+
+    #if os(OSX)
+    /// A helper property that returns the class name for an `Object` subclass.
+    public final override var className: String { return "" }
+    #else
+    /// A helper property that returns the class name for an `Object` subclass.
+    public final var className: String { return "" }
+    #endif
+
+    /**
+    WARNING: This is an internal helper method not intended for public use.
+    :nodoc:
+    */
+    public override class func objectUtilClass(isSwift: Bool) -> AnyClass {
+        return ObjectUtil.self
+    }
+
+
+    // MARK: Object Customization
+
+    /**
+     Override this method to specify the name of a property to be used as the primary key.
+
+     Only properties of types `String` and `Int` can be designated as the primary key. Primary key properties enforce
+     uniqueness for each value whenever the property is set, which incurs minor overhead. Indexes are created
+     automatically for primary key properties.
+
+     - returns: The name of the property designated as the primary key, or `nil` if the model has no primary key.
+    */
+    public class func primaryKey() -> String? { return nil }
+
+    /**
+     Override this method to specify the names of properties to ignore. These properties will not be managed by
+     the Realm that manages the object.
+
+     - returns: An array of property names to ignore.
+    */
+    public class func ignoredProperties() -> [String] { return [] }
+
+    /**
+     Returns an array of property names for properties which should be indexed.
+
+     Only string, integer, boolean, and `NSDate` properties are supported.
+
+     - returns: An array of property names.
+    */
+    public class func indexedProperties() -> [String] { return [] }
+
+
+    // MARK: Key-Value Coding & Subscripting
+
+    /// Returns or sets the value of the property with the given name.
+    public subscript(key: String) -> AnyObject? {
+        get {
+            if realm == nil {
+                return valueForKey(key)
+            }
+            let property = RLMValidatedGetProperty(self, key)
+            if property.type == .Array {
+                return listForProperty(property)
+            }
+            // No special logic is needed for optional numbers here because the NSNumber returned by RLMDynamicGet
+            // is better for callers than the RealmOptional that optionalForProperty would give us.
+            return RLMDynamicGet(self, property)
+        }
+        set(value) {
+            if realm == nil {
+                setValue(value, forKey: key)
+            } else {
+                RLMDynamicValidatedSet(self, key, value)
+            }
+        }
+    }
+
+    // MARK: Dynamic list
+
+    /**
+     Returns a list of `DynamicObject`s for a given property name.
+
+     - warning:  This method is useful only in specialized circumstances, for example, when building
+                 components that integrate with Realm. If you are simply building an app on Realm, it is
+                 recommended to use instance variables or cast the values returned from key-value coding.
+
+    - parameter propertyName: The name of the property.
+
+    - returns: A list of `DynamicObject`s.
+
+    :nodoc:
+    */
+    public func dynamicList(propertyName: String) -> List<DynamicObject> {
+        return unsafeBitCast(listForProperty(RLMValidatedGetProperty(self, propertyName)), List<DynamicObject>.self)
+    }
+
+    // MARK: Equatable
+
+    /**
+     Returns whether two Realm objects are equal.
+
+     Objects are considered equal if and only if they are both managed by the same Realm and point to the same
+     underlying object in the database.
+
+     - parameter object: The object to compare the receiver to.
+    */
+    public override func isEqual(object: AnyObject?) -> Bool {
+        return RLMObjectBaseAreEqual(self as RLMObjectBase?, object as? RLMObjectBase)
+    }
+
+    // MARK: Private functions
+
+    // FIXME: None of these functions should be exposed in the public interface.
+
+    /**
+    WARNING: This is an internal initializer not intended for public use.
+    :nodoc:
+    */
+    public override required init(realm: RLMRealm, schema: RLMObjectSchema) {
+        super.init(realm: realm, schema: schema)
+    }
+
+    /**
+    WARNING: This is an internal initializer not intended for public use.
+    :nodoc:
+    */
+    public override required init(value: AnyObject, schema: RLMSchema) {
+        super.init(value: value, schema: schema)
+    }
+
+    // Helper for getting the list object for a property
+    internal func listForProperty(prop: RLMProperty) -> RLMListBase {
+        return object_getIvar(self, prop.swiftIvar) as! RLMListBase
+    }
+
+    // Helper for getting the optional object for a property
+    internal func optionalForProperty(prop: RLMProperty) -> RLMOptionalBase {
+        return object_getIvar(self, prop.swiftIvar) as! RLMOptionalBase
+    }
+
+    // Helper for getting the linking objects object for a property
+    internal func linkingObjectsForProperty(prop: RLMProperty) -> LinkingObjectsBase? {
+        return object_getIvar(self, prop.swiftIvar) as? LinkingObjectsBase
+    }
+}
+
+
+
+/// Object interface which allows untyped getters and setters for Objects.
+/// :nodoc:
+public final class DynamicObject: Object {
+    private var listProperties = [String: List<DynamicObject>]()
+    private var optionalProperties = [String: RLMOptionalBase]()
+
+    // Override to create List<DynamicObject> on access
+    internal override func listForProperty(prop: RLMProperty) -> RLMListBase {
+        if let list = listProperties[prop.name] {
+            return list
+        }
+        let list = List<DynamicObject>()
+        listProperties[prop.name] = list
+        return list
+    }
+
+    // Override to create RealmOptional on access
+    internal override func optionalForProperty(prop: RLMProperty) -> RLMOptionalBase {
+        if let optional = optionalProperties[prop.name] {
+            return optional
+        }
+        let optional = RLMOptionalBase()
+        optional.property = prop
+        optionalProperties[prop.name] = optional
+        return optional
+    }
+
+    // Dynamic objects never have linking objects properties
+    internal override func linkingObjectsForProperty(prop: RLMProperty) -> LinkingObjectsBase? {
+        return nil
+    }
+
+    /// :nodoc:
+    public override func valueForUndefinedKey(key: String) -> AnyObject? {
+        return self[key]
+    }
+
+    /// :nodoc:
+    public override func setValue(value: AnyObject?, forUndefinedKey key: String) {
+        self[key] = value
+    }
+
+    /// :nodoc:
+    public override class func shouldIncludeInDefaultSchema() -> Bool {
+        return false
+    }
+}
+
+/// :nodoc:
+/// Internal class. Do not use directly.
+@objc(RealmSwiftObjectUtil)
+public class ObjectUtil: NSObject {
+    @objc private class func swiftVersion() -> NSString {
+        return swiftLanguageVersion
+    }
+
+    @objc private class func ignoredPropertiesForClass(type: AnyClass) -> NSArray? {
+        if let type = type as? Object.Type {
+            return type.ignoredProperties() as NSArray?
+        }
+        return nil
+    }
+
+    @objc private class func indexedPropertiesForClass(type: AnyClass) -> NSArray? {
+        if let type = type as? Object.Type {
+            return type.indexedProperties() as NSArray?
+        }
+        return nil
+    }
+
+    @objc private class func linkingObjectsPropertiesForClass(type: AnyClass) -> NSDictionary? {
+        // Not used for Swift. getLinkingObjectsProperties(_:) is used instead.
+        return nil
+    }
+
+    // Get the names of all properties in the object which are of type List<>.
+    @objc private class func getGenericListPropertyNames(object: AnyObject) -> NSArray {
+        return Mirror(reflecting: object).children.filter { (prop: Mirror.Child) in
+            return prop.value.dynamicType is RLMListBase.Type
+        }.flatMap { (prop: Mirror.Child) in
+            return prop.label
+        }
+    }
+
+    @objc private class func initializeListProperty(object: RLMObjectBase, property: RLMProperty, array: RLMArray) {
+        (object as! Object).listForProperty(property)._rlmArray = array
+    }
+
+    @objc private class func initializeOptionalProperty(object: RLMObjectBase, property: RLMProperty) {
+        let optional = (object as! Object).optionalForProperty(property)
+        optional.property = property
+        optional.object = object
+    }
+
+    // swiftlint:disable:next cyclomatic_complexity
+    @objc private class func getOptionalProperties(object: AnyObject) -> NSDictionary {
+        let children = Mirror(reflecting: object).children
+        return children.reduce([String: AnyObject]()) { ( properties: [String:AnyObject], prop: Mirror.Child) in
+            guard let name = prop.label else { return properties }
+            let mirror = Mirror(reflecting: prop.value)
+            let type = mirror.subjectType
+            var properties = properties
+            if type is Optional<String>.Type || type is Optional<NSString>.Type {
+                properties[name] = Int(PropertyType.String.rawValue)
+            } else if type is Optional<NSDate>.Type {
+                properties[name] = Int(PropertyType.Date.rawValue)
+            } else if type is Optional<NSData>.Type {
+                properties[name] = Int(PropertyType.Data.rawValue)
+            } else if type is Optional<Object>.Type {
+                properties[name] = Int(PropertyType.Object.rawValue)
+            } else if type is RealmOptional<Int>.Type ||
+                      type is RealmOptional<Int8>.Type ||
+                      type is RealmOptional<Int16>.Type ||
+                      type is RealmOptional<Int32>.Type ||
+                      type is RealmOptional<Int64>.Type {
+                properties[name] = Int(PropertyType.Int.rawValue)
+            } else if type is RealmOptional<Float>.Type {
+                properties[name] = Int(PropertyType.Float.rawValue)
+            } else if type is RealmOptional<Double>.Type {
+                properties[name] = Int(PropertyType.Double.rawValue)
+            } else if type is RealmOptional<Bool>.Type {
+                properties[name] = Int(PropertyType.Bool.rawValue)
+            } else if prop.value as? RLMOptionalBase != nil {
+                throwRealmException("'\(type)' is not a a valid RealmOptional type.")
+            } else if mirror.displayStyle == .Optional {
+                properties[name] = NSNull()
+            }
+            return properties
+        }
+    }
+
+    @objc private class func requiredPropertiesForClass(_: AnyClass) -> NSArray? {
+        return nil
+    }
+
+    // Get information about each of the linking objects properties.
+    @objc private class func getLinkingObjectsProperties(object: AnyObject) -> NSDictionary {
+        let properties = Mirror(reflecting: object).children.filter { (prop: Mirror.Child) in
+            return prop.value as? LinkingObjectsBase != nil
+        }.flatMap { (prop: Mirror.Child) in
+            (prop.label!, prop.value as! LinkingObjectsBase)
+        }
+        return properties.reduce([:] as [String : [String: String ]]) { (dictionary, property) in
+            var d = dictionary
+            let (name, results) = property
+            d[name] = ["class": results.objectClassName, "property": results.propertyName]
+            return d
+        }
+    }
+
+    @objc private class func initializeLinkingObjectsProperty(object: RLMObjectBase, property: RLMProperty) {
+        guard let linkingObjects = (object as! Object).linkingObjectsForProperty(property) else { return }
+        linkingObjects.attachTo(object: object, property: property)
+    }
+}
+
+#endif
diff --git a/Pods/RealmSwift/RealmSwift/ObjectSchema.swift b/Pods/RealmSwift/RealmSwift/ObjectSchema.swift
new file mode 100644
index 0000000..83ce311
--- /dev/null
+++ b/Pods/RealmSwift/RealmSwift/ObjectSchema.swift
@@ -0,0 +1,148 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+import Foundation
+import Realm
+
+#if swift(>=3.0)
+
+/**
+This class represents Realm model object schemas.
+
+When using Realm, `ObjectSchema` objects allow performing migrations and
+introspecting the database's schema.
+
+`ObjectSchema`s map to tables in the core database.
+*/
+public final class ObjectSchema: CustomStringConvertible {
+
+    // MARK: Properties
+
+    internal let rlmObjectSchema: RLMObjectSchema
+
+    /// Array of persisted `Property` objects for an object.
+    public var properties: [Property] {
+        return rlmObjectSchema.properties.map { Property($0) }
+    }
+
+    /// The name of the class this schema describes.
+    public var className: String { return rlmObjectSchema.className }
+
+    /// The property that serves as the primary key, if there is a primary key.
+    public var primaryKeyProperty: Property? {
+        if let rlmProperty = rlmObjectSchema.primaryKeyProperty {
+            return Property(rlmProperty)
+        }
+        return nil
+    }
+
+    /// Returns a human-readable description of the properties contained in this object schema.
+    public var description: String { return rlmObjectSchema.description }
+
+    // MARK: Initializers
+
+    internal init(_ rlmObjectSchema: RLMObjectSchema) {
+        self.rlmObjectSchema = rlmObjectSchema
+    }
+
+    // MARK: Property Retrieval
+
+    /// Returns the property with the given name, if it exists.
+    public subscript(propertyName: String) -> Property? {
+        if let rlmProperty = rlmObjectSchema[propertyName as NSString] {
+            return Property(rlmProperty)
+        }
+        return nil
+    }
+}
+
+// MARK: Equatable
+
+extension ObjectSchema: Equatable {}
+
+/// Returns whether the two object schemas are equal.
+public func == (lhs: ObjectSchema, rhs: ObjectSchema) -> Bool { // swiftlint:disable:this valid_docs
+    return lhs.rlmObjectSchema.isEqual(to: rhs.rlmObjectSchema)
+}
+
+#else
+
+/**
+ This class represents Realm model object schemas.
+
+ When using Realm, `ObjectSchema` instances allow performing migrations and
+ introspecting the database's schema.
+
+ Object schemas map to tables in the core database.
+*/
+public final class ObjectSchema: CustomStringConvertible {
+
+    // MARK: Properties
+
+    internal let rlmObjectSchema: RLMObjectSchema
+
+    /**
+     An array of `Property` instances representing the managed properties of a class described by the schema.
+
+     - see: `Property`
+     */
+    public var properties: [Property] {
+        return rlmObjectSchema.properties.map { Property($0) }
+    }
+
+    /// The name of the class the schema describes.
+    public var className: String { return rlmObjectSchema.className }
+
+    /// The property which serves as the primary key for the class the schema describes, if any.
+    public var primaryKeyProperty: Property? {
+        if let rlmProperty = rlmObjectSchema.primaryKeyProperty {
+            return Property(rlmProperty)
+        }
+        return nil
+    }
+
+    /// Returns a human-readable description of the properties contained in the object schema.
+    public var description: String { return rlmObjectSchema.description }
+
+    // MARK: Initializers
+
+    internal init(_ rlmObjectSchema: RLMObjectSchema) {
+        self.rlmObjectSchema = rlmObjectSchema
+    }
+
+    // MARK: Property Retrieval
+
+    /// Returns the property with the given name, if it exists.
+    public subscript(propertyName: String) -> Property? {
+        if let rlmProperty = rlmObjectSchema[propertyName] {
+            return Property(rlmProperty)
+        }
+        return nil
+    }
+}
+
+// MARK: Equatable
+
+extension ObjectSchema: Equatable {}
+
+/// Returns whether the two object schemas are equal.
+public func == (lhs: ObjectSchema, rhs: ObjectSchema) -> Bool { // swiftlint:disable:this valid_docs
+    return lhs.rlmObjectSchema.isEqualToObjectSchema(rhs.rlmObjectSchema)
+}
+
+#endif
diff --git a/Pods/RealmSwift/RealmSwift/Optional.swift b/Pods/RealmSwift/RealmSwift/Optional.swift
new file mode 100644
index 0000000..ce9dce5
--- /dev/null
+++ b/Pods/RealmSwift/RealmSwift/Optional.swift
@@ -0,0 +1,164 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2015 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+import Realm
+
+#if swift(>=3.0)
+
+/// Types that can be represented in a `RealmOptional`.
+public protocol RealmOptionalType {}
+extension Int: RealmOptionalType {}
+extension Int8: RealmOptionalType {}
+extension Int16: RealmOptionalType {}
+extension Int32: RealmOptionalType {}
+extension Int64: RealmOptionalType {}
+extension Float: RealmOptionalType {}
+extension Double: RealmOptionalType {}
+extension Bool: RealmOptionalType {}
+
+// Not all RealmOptionalType's can be cast to AnyObject, so handle casting logic here.
+private func realmOptionalToAnyObject<T: RealmOptionalType>(value: T?) -> AnyObject? {
+    if let anyObjectValue: AnyObject = value as? AnyObject {
+        return anyObjectValue
+    } else if let int8Value = value as? Int8 {
+        return NSNumber(value: int8Value)
+    } else if let int16Value = value as? Int16 {
+        return NSNumber(value: int16Value)
+    } else if let int32Value = value as? Int32 {
+        return NSNumber(value: int32Value)
+    } else if let int64Value = value as? Int64 {
+        return NSNumber(value: int64Value)
+    }
+    return nil
+}
+
+// Not all RealmOptionalType's can be cast from AnyObject, so handle casting logic here.
+private func anyObjectToRealmOptional<T: RealmOptionalType>(anyObject: AnyObject?) -> T? {
+    if T.self is Int8.Type {
+        return (anyObject as! NSNumber?)?.int8Value as! T?
+    } else if T.self is Int16.Type {
+        return (anyObject as! NSNumber?)?.int16Value as! T?
+    } else if T.self is Int32.Type {
+        return (anyObject as! NSNumber?)?.int32Value as! T?
+    } else if T.self is Int64.Type {
+        return (anyObject as! NSNumber?)?.int64Value as! T?
+    }
+    return anyObject as! T?
+}
+
+/**
+A `RealmOptional` represents a optional value for types that can't be directly
+declared as `dynamic` in Swift, such as `Int`s, `Float`, `Double`, and `Bool`.
+
+It encapsulates a value in its `value` property, which is the only way to mutate
+a `RealmOptional` property on an `Object`.
+*/
+public final class RealmOptional<T: RealmOptionalType>: RLMOptionalBase {
+    /// The value this optional represents.
+    public var value: T? {
+        get {
+            return anyObjectToRealmOptional(anyObject: underlyingValue)
+        }
+        set {
+            underlyingValue = realmOptionalToAnyObject(value: newValue)
+        }
+    }
+
+    /**
+    Creates a `RealmOptional` with the given default value (defaults to `nil`).
+
+    - parameter value: The default value for this optional.
+    */
+    public init(_ value: T? = nil) {
+        super.init()
+        self.value = value
+    }
+}
+
+#else
+
+/// A protocol describing types that can parameterize a `RealmOptional`.
+public protocol RealmOptionalType {}
+extension Int: RealmOptionalType {}
+extension Int8: RealmOptionalType {}
+extension Int16: RealmOptionalType {}
+extension Int32: RealmOptionalType {}
+extension Int64: RealmOptionalType {}
+extension Float: RealmOptionalType {}
+extension Double: RealmOptionalType {}
+extension Bool: RealmOptionalType {}
+
+// Not all RealmOptionalType's can be cast to AnyObject, so handle casting logic here.
+private func realmOptionalToAnyObject<T: RealmOptionalType>(value: T?) -> AnyObject? {
+    if let anyObjectValue: AnyObject = value as? AnyObject {
+        return anyObjectValue
+    } else if let int8Value = value as? Int8 {
+        return NSNumber(long: Int(int8Value))
+    } else if let int16Value = value as? Int16 {
+        return NSNumber(long: Int(int16Value))
+    } else if let int32Value = value as? Int32 {
+        return NSNumber(long: Int(int32Value))
+    } else if let int64Value = value as? Int64 {
+        return NSNumber(longLong: int64Value)
+    }
+    return nil
+}
+
+// Not all RealmOptionalType's can be cast from AnyObject, so handle casting logic here.
+private func anyObjectToRealmOptional<T: RealmOptionalType>(anyObject: AnyObject?) -> T? {
+    if T.self is Int8.Type {
+        return ((anyObject as! NSNumber?)?.longValue).map { Int8($0) } as! T?
+    } else if T.self is Int16.Type {
+        return ((anyObject as! NSNumber?)?.longValue).map { Int16($0) } as! T?
+    } else if T.self is Int32.Type {
+        return ((anyObject as! NSNumber?)?.longValue).map { Int32($0) } as! T?
+    } else if T.self is Int64.Type {
+        return (anyObject as! NSNumber?)?.longLongValue as! T?
+    }
+    return anyObject as! T?
+}
+
+/**
+ A `RealmOptional` instance represents a optional value for types that can't be directly declared as `dynamic` in Swift,
+ such as `Int`, `Float`, `Double`, and `Bool`.
+
+ To change the underlying value stored by a `RealmOptional` instance, mutate the instance's `value` property.
+*/
+public final class RealmOptional<T: RealmOptionalType>: RLMOptionalBase {
+    /// The value this optional represents.
+    public var value: T? {
+        get {
+            return anyObjectToRealmOptional(underlyingValue)
+        }
+        set {
+            underlyingValue = realmOptionalToAnyObject(newValue)
+        }
+    }
+
+    /**
+     Creates a `RealmOptional` instance encapsulating the given default value.
+
+     - parameter value: The value to store in the optional, or `nil` if not specified.
+     */
+    public init(_ value: T? = nil) {
+        super.init()
+        self.value = value
+    }
+}
+
+#endif
diff --git a/Pods/RealmSwift/RealmSwift/Property.swift b/Pods/RealmSwift/RealmSwift/Property.swift
new file mode 100644
index 0000000..cd69f65
--- /dev/null
+++ b/Pods/RealmSwift/RealmSwift/Property.swift
@@ -0,0 +1,133 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+import Foundation
+import Realm
+
+#if swift(>=3.0)
+
+/**
+This class represents properties persisted to Realm in an `ObjectSchema`.
+
+When using Realm, `Property` objects allow performing migrations and
+introspecting the database's schema.
+
+These properties map to columns in the core database.
+*/
+public final class Property: CustomStringConvertible {
+
+    // MARK: Properties
+
+    internal let rlmProperty: RLMProperty
+
+    /// Property name.
+    public var name: String { return rlmProperty.name }
+
+    /// Property type.
+    public var type: PropertyType { return rlmProperty.type }
+
+    /// Whether this property is indexed.
+    public var isIndexed: Bool { return rlmProperty.indexed }
+
+    /// Whether this property is optional (can contain `nil` values).
+    public var isOptional: Bool { return rlmProperty.optional }
+
+    /// Object class name - specify object types for `Object` and `List` properties.
+    public var objectClassName: String? { return rlmProperty.objectClassName }
+
+    /// Returns a human-readable description of this property.
+    public var description: String { return rlmProperty.description }
+
+    // MARK: Initializers
+
+    internal init(_ rlmProperty: RLMProperty) {
+        self.rlmProperty = rlmProperty
+    }
+}
+
+// MARK: Equatable
+
+extension Property: Equatable {}
+
+/// Returns whether the two properties are equal.
+public func == (lhs: Property, rhs: Property) -> Bool { // swiftlint:disable:this valid_docs
+    return lhs.rlmProperty.isEqual(to: rhs.rlmProperty)
+}
+
+// MARK: Unavailable
+
+extension Property {
+    @available(*, unavailable, renamed:"isIndexed")
+    public var indexed : Bool { fatalError() }
+
+    @available(*, unavailable, renamed:"isOptional")
+    public var optional : Bool { fatalError() }
+}
+
+#else
+
+/**
+ `Property` instances represent properties managed by a Realm in the context of an object schema. Such properties may be
+ persisted to a Realm file or computed from other data from the Realm.
+
+ When using Realm, `Property` instances allow performing migrations and introspecting the database's schema.
+
+ These property instances map to columns in the core database.
+*/
+public final class Property: CustomStringConvertible {
+
+    // MARK: Properties
+
+    internal let rlmProperty: RLMProperty
+
+    /// The name of the property.
+    public var name: String { return rlmProperty.name }
+
+    /// The type of the property.
+    public var type: PropertyType { return rlmProperty.type }
+
+    /// Indicates whether this property is indexed.
+    public var indexed: Bool { return rlmProperty.indexed }
+
+    /// Indicates whether this property is optional. (Note that certain numeric types must be wrapped in a
+    /// `RealmOptional` instance in order to be declared as optional.)
+    public var optional: Bool { return rlmProperty.optional }
+
+    /// For `Object` and `List` properties, the name of the class of object stored in the property.
+    public var objectClassName: String? { return rlmProperty.objectClassName }
+
+    /// Returns a human-readable description of this property.
+    public var description: String { return rlmProperty.description }
+
+    // MARK: Initializers
+
+    internal init(_ rlmProperty: RLMProperty) {
+        self.rlmProperty = rlmProperty
+    }
+}
+
+// MARK: Equatable
+
+extension Property: Equatable {}
+
+/// Returns whether the two property objects are equal.
+public func == (lhs: Property, rhs: Property) -> Bool { // swiftlint:disable:this valid_docs
+    return lhs.rlmProperty.isEqualToProperty(rhs.rlmProperty)
+}
+
+#endif
diff --git a/Pods/RealmSwift/RealmSwift/Realm.swift b/Pods/RealmSwift/RealmSwift/Realm.swift
new file mode 100644
index 0000000..3660239
--- /dev/null
+++ b/Pods/RealmSwift/RealmSwift/Realm.swift
@@ -0,0 +1,1288 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+import Foundation
+import Realm
+import Realm.Private
+
+#if swift(>=3.0)
+
+/**
+A Realm instance (also referred to as "a realm") represents a Realm
+database.
+
+Realms can either be stored on disk (see `init(path:)`) or in
+memory (see `Configuration`).
+
+Realm instances are cached internally, and constructing equivalent Realm
+objects (with the same path or identifier) produces limited overhead.
+
+If you specifically want to ensure a Realm object is
+destroyed (for example, if you wish to open a realm, check some property, and
+then possibly delete the realm file and re-open it), place the code which uses
+the realm within an `autoreleasepool {}` and ensure you have no other
+strong references to it.
+
+- warning: Realm instances are not thread safe and can not be shared across
+           threads or dispatch queues. You must construct a new instance on each thread you want
+           to interact with the realm on. For dispatch queues, this means that you must
+           call it in each block which is dispatched, as a queue is not guaranteed to run
+           on a consistent thread.
+*/
+public final class Realm {
+
+    // MARK: Properties
+
+    /// The Schema used by this realm.
+    public var schema: Schema { return Schema(rlmRealm.schema) }
+
+    /// Returns the `Configuration` that was used to create this `Realm` instance.
+    public var configuration: Configuration { return Configuration.fromRLMRealmConfiguration(rlmConfiguration: rlmRealm.configuration) }
+
+    /// Indicates if this Realm contains any objects.
+    public var isEmpty: Bool { return rlmRealm.isEmpty }
+
+    // MARK: Initializers
+
+    /**
+    Obtains a Realm instance with the default Realm configuration, which can be
+    changed by setting `Realm.Configuration.defaultConfiguration`.
+
+    - throws: An NSError if the Realm could not be initialized.
+    */
+    public convenience init() throws {
+        let rlmRealm = try RLMRealm(configuration: RLMRealmConfiguration.default())
+        self.init(rlmRealm)
+    }
+
+    /**
+    Obtains a Realm instance with the given configuration.
+
+    - parameter configuration: The configuration to use when creating the Realm instance.
+
+    - throws: An NSError if the Realm could not be initialized.
+    */
+    public convenience init(configuration: Configuration) throws {
+        let rlmRealm = try RLMRealm(configuration: configuration.rlmConfiguration)
+        self.init(rlmRealm)
+    }
+
+    /**
+    Obtains a Realm instance persisted at the specified file URL.
+
+    - parameter fileURL: Local URL to the realm file.
+
+    - throws: An NSError if the Realm could not be initialized.
+    */
+    public convenience init(fileURL: URL) throws {
+        var configuration = Configuration.defaultConfiguration
+        configuration.fileURL = fileURL
+        try self.init(configuration: configuration)
+    }
+
+    // MARK: Transactions
+
+    /**
+    Performs actions contained within the given block inside a write transaction.
+
+    Write transactions cannot be nested, and trying to execute a write transaction
+    on a `Realm` which is already in a write transaction will throw an exception.
+    Calls to `write` from `Realm` instances in other threads will block
+    until the current write transaction completes.
+
+    Before executing the write transaction, `write` updates the `Realm` to the
+    latest Realm version, as if `refresh()` was called, and generates notifications
+    if applicable. This has no effect if the `Realm` was already up to date.
+
+    - parameter block: The block to be executed inside a write transaction.
+
+    - throws: An NSError if the transaction could not be written.
+    */
+    public func write(block: @noescape () -> Void) throws {
+        try rlmRealm.transaction(block)
+    }
+
+    /**
+    Begins a write transaction in a `Realm`.
+
+    Only one write transaction can be open at a time. Write transactions cannot be
+    nested, and trying to begin a write transaction on a `Realm` which is
+    already in a write transaction will throw an exception. Calls to
+    `beginWrite` from `Realm` instances in other threads will block
+    until the current write transaction completes.
+
+    Before beginning the write transaction, `beginWrite` updates the
+    `Realm` to the latest Realm version, as if `refresh()` was called, and
+    generates notifications if applicable. This has no effect if the `Realm`
+    was already up to date.
+
+    It is rarely a good idea to have write transactions span multiple cycles of
+    the run loop, but if you do wish to do so you will need to ensure that the
+    `Realm` in the write transaction is kept alive until the write transaction
+    is committed.
+    */
+    public func beginWrite() {
+        rlmRealm.beginWriteTransaction()
+    }
+
+    /**
+    Commits all writes operations in the current write transaction, and ends
+    the transaction.
+
+    Calling this when not in a write transaction will throw an exception.
+
+    - throws: An NSError if the transaction could not be written.
+    */
+    public func commitWrite() throws {
+        try rlmRealm.commitWriteTransaction()
+    }
+
+    /**
+    Reverts all writes made in the current write transaction and end the transaction.
+
+    This rolls back all objects in the Realm to the state they were in at the
+    beginning of the write transaction, and then ends the transaction.
+
+    This restores the data for deleted objects, but does not revive invalidated
+    object instances. Any `Object`s which were added to the Realm will be
+    invalidated rather than switching back to standalone objects.
+    Given the following code:
+
+    ```swift
+    let oldObject = objects(ObjectType).first!
+    let newObject = ObjectType()
+
+    realm.beginWrite()
+    realm.add(newObject)
+    realm.delete(oldObject)
+    realm.cancelWrite()
+    ```
+
+    Both `oldObject` and `newObject` will return `true` for `invalidated`,
+    but re-running the query which provided `oldObject` will once again return
+    the valid object.
+
+    Calling this when not in a write transaction will throw an exception.
+    */
+    public func cancelWrite() {
+        rlmRealm.cancelWriteTransaction()
+    }
+
+    /**
+    Indicates if this Realm is currently in a write transaction.
+
+    - warning: Wrapping mutating operations in a write transaction if this property returns `false`
+               may cause a large number of write transactions to be created, which could negatively
+               impact Realm's performance. Always prefer performing multiple mutations in a single
+               transaction when possible.
+    */
+    public var isInWriteTransaction: Bool {
+        return rlmRealm.inWriteTransaction
+    }
+
+    // MARK: Adding and Creating objects
+
+    /**
+    Adds or updates an object to be persisted it in this Realm.
+
+    When 'update' is 'true', the object must have a primary key. If no objects exist in
+    the Realm instance with the same primary key value, the object is inserted. Otherwise,
+    the existing object is updated with any changed values.
+
+    When added, all (child) relationships referenced by this object will also be
+    added to the Realm if they are not already in it. If the object or any related
+    objects already belong to a different Realm an exception will be thrown. Use one
+    of the `create` functions to insert a copy of a persisted object into a different
+    Realm.
+
+    The object to be added must be valid and cannot have been previously deleted
+    from a Realm (i.e. `invalidated` must be false).
+
+    - parameter object: Object to be added to this Realm.
+    - parameter update: If true will try to update existing objects with the same primary key.
+    */
+    public func add(_ object: Object, update: Bool = false) {
+        if update && object.objectSchema.primaryKeyProperty == nil {
+            throwRealmException("'\(object.objectSchema.className)' does not have a primary key and can not be updated")
+        }
+        RLMAddObjectToRealm(object, rlmRealm, update)
+    }
+
+    /**
+    Adds or updates objects in the given sequence to be persisted it in this Realm.
+
+    - see: add(_:update:)
+
+    - warning: This method can only be called during a write transaction.
+
+    - parameter objects: A sequence which contains objects to be added to this Realm.
+    - parameter update: If true will try to update existing objects with the same primary key.
+    */
+    public func add<S: Sequence where S.Iterator.Element: Object>(_ objects: S, update: Bool = false) {
+        for obj in objects {
+            add(obj, update: update)
+        }
+    }
+
+    /**
+    Create an `Object` with the given value.
+
+    Creates or updates an instance of this object and adds it to the `Realm` populating
+    the object with the given value.
+
+    When 'update' is 'true', the object must have a primary key. If no objects exist in
+    the Realm instance with the same primary key value, the object is inserted. Otherwise,
+    the existing object is updated with any changed values.
+
+    - warning: This method can only be called during a write transaction.
+
+    - parameter type:   The object type to create.
+    - parameter value:  The value used to populate the object. This can be any key/value coding compliant
+                        object, or a JSON dictionary such as those returned from the methods in `NSJSONSerialization`,
+                        or an `Array` with one object for each persisted property. An exception will be
+                        thrown if any required properties are not present and no default is set.
+                        When passing in an `Array`, all properties must be present,
+                        valid and in the same order as the properties defined in the model.
+    - parameter update: If true will try to update existing objects with the same primary key.
+
+    - returns: The created object.
+    */
+    @discardableResult
+    public func createObject<T: Object>(ofType type: T.Type, populatedWith value: AnyObject = [:], update: Bool = false) -> T {
+        let typeName = (type as Object.Type).className()
+        if update && schema[typeName]?.primaryKeyProperty == nil {
+            throwRealmException("'\(typeName)' does not have a primary key and can not be updated")
+        }
+        return unsafeBitCast(RLMCreateObjectInRealmWithValue(rlmRealm, typeName, value, update), to: T.self)
+    }
+
+    /**
+    This method is useful only in specialized circumstances, for example, when building
+    components that integrate with Realm. If you are simply building an app on Realm, it is
+    recommended to use the typed method `create(_:value:update:)`.
+
+    Creates or updates an object with the given class name and adds it to the `Realm`, populating
+    the object with the given value.
+
+    When 'update' is 'true', the object must have a primary key. If no objects exist in
+    the Realm instance with the same primary key value, the object is inserted. Otherwise,
+    the existing object is updated with any changed values.
+
+    - warning: This method can only be called during a write transaction.
+
+    - parameter className:  The class name of the object to create.
+    - parameter value:      The value used to populate the object. This can be any key/value coding compliant
+    object, or a JSON dictionary such as those returned from the methods in `NSJSONSerialization`,
+    or an `Array` with one object for each persisted property. An exception will be
+    thrown if any required properties are not present and no default is set.
+
+    When passing in an `Array`, all properties must be present,
+    valid and in the same order as the properties defined in the model.
+    - parameter update:     If true will try to update existing objects with the same primary key.
+
+    - returns: The created object.
+
+    :nodoc:
+    */
+    @discardableResult
+    public func createDynamicObject(ofType typeName: String, populatedWith value: AnyObject = [:], update: Bool = false) -> DynamicObject {
+        if update && schema[typeName]?.primaryKeyProperty == nil {
+            throwRealmException("'\(typeName)' does not have a primary key and can not be updated")
+        }
+        return unsafeBitCast(RLMCreateObjectInRealmWithValue(rlmRealm, typeName, value, update), to: DynamicObject.self)
+    }
+
+    // MARK: Deleting objects
+
+    /**
+    Deletes the given object from this Realm.
+
+    - warning: This method can only be called during a write transaction.
+
+    - parameter object: The object to be deleted.
+    */
+    public func delete(_ object: Object) {
+        RLMDeleteObjectFromRealm(object, rlmRealm)
+    }
+
+    /**
+    Deletes the given objects from this Realm.
+
+    - warning: This method can only be called during a write transaction.
+
+    - parameter objects: The objects to be deleted. This can be a `List<Object>`, `Results<Object>`,
+                         or any other enumerable SequenceType which generates Object.
+    */
+    public func delete<S: Sequence where S.Iterator.Element: Object>(_ objects: S) {
+        for obj in objects {
+            delete(obj)
+        }
+    }
+
+    /**
+    Deletes the given objects from this Realm.
+
+    - warning: This method can only be called during a write transaction.
+
+    - parameter objects: The objects to be deleted. Must be `List<Object>`.
+
+    :nodoc:
+    */
+    public func delete<T: Object>(_ objects: List<T>) {
+        rlmRealm.deleteObjects(objects._rlmArray)
+    }
+
+    /**
+    Deletes the given objects from this Realm.
+
+    - warning: This method can only be called during a write transaction.
+
+    - parameter objects: The objects to be deleted. Must be `Results<Object>`.
+
+    :nodoc:
+    */
+    public func delete<T: Object>(_ objects: Results<T>) {
+        rlmRealm.deleteObjects(objects.rlmResults)
+    }
+
+    /**
+    Deletes all objects from this Realm.
+
+    - warning: This method can only be called during a write transaction.
+    */
+    public func deleteAllObjects() {
+        RLMDeleteAllObjectsFromRealm(rlmRealm)
+    }
+
+    // MARK: Object Retrieval
+
+    /**
+    Returns all objects of the given type in the Realm.
+
+    - parameter type: The type of the objects to be returned.
+
+    - returns: All objects of the given type in Realm.
+    */
+    public func allObjects<T: Object>(ofType type: T.Type) -> Results<T> {
+        return Results<T>(RLMGetObjects(rlmRealm, (type as Object.Type).className(), nil))
+    }
+
+    /**
+    This method is useful only in specialized circumstances, for example, when building
+    components that integrate with Realm. If you are simply building an app on Realm, it is
+    recommended to use the typed method `objects(type:)`.
+
+    Returns all objects for a given class name in the Realm.
+
+    - warning: This method is useful only in specialized circumstances.
+
+    - parameter className: The class name of the objects to be returned.
+
+    - returns: All objects for the given class name as dynamic objects
+
+    :nodoc:
+    */
+    public func allDynamicObjects(ofType typeName: String) -> Results<DynamicObject> {
+        return Results<DynamicObject>(RLMGetObjects(rlmRealm, typeName, nil))
+    }
+
+    /**
+    Get an object with the given primary key.
+
+    Returns `nil` if no object exists with the given primary key.
+
+    This method requires that `primaryKey()` be overridden on the given subclass.
+
+    - see: Object.primaryKey()
+
+    - parameter type: The type of the objects to be returned.
+    - parameter key:  The primary key of the desired object.
+
+    - returns: An object of type `type` or `nil` if an object with the given primary key does not exist.
+    */
+    public func object<T: Object>(ofType type: T.Type, forPrimaryKey key: AnyObject) -> T? {
+        return unsafeBitCast(RLMGetObject(rlmRealm, (type as Object.Type).className(), key), to: Optional<T>.self)
+    }
+
+    /**
+    This method is useful only in specialized circumstances, for example, when building
+    components that integrate with Realm. If you are simply building an app on Realm, it is
+    recommended to use the typed method `objectForPrimaryKey(_:key:)`.
+
+    Get a dynamic object with the given class name and primary key.
+
+    Returns `nil` if no object exists with the given class name and primary key.
+
+    This method requires that `primaryKey()` be overridden on the given subclass.
+
+    - see: Object.primaryKey()
+
+    - warning: This method is useful only in specialized circumstances.
+
+    - parameter className:  The class name of the object to be returned.
+    - parameter key:        The primary key of the desired object.
+
+    - returns: An object of type `DynamicObject` or `nil` if an object with the given primary key does not exist.
+
+    :nodoc:
+    */
+    public func dynamicObject(ofType typeName: String, forPrimaryKey key: AnyObject) -> DynamicObject? {
+        return unsafeBitCast(RLMGetObject(rlmRealm, typeName, key), to: Optional<DynamicObject>.self)
+    }
+
+    // MARK: Notifications
+
+    /**
+    Add a notification handler for changes in this Realm.
+
+    Notification handlers are called after each write transaction is committed,
+    independent from the thread or process.
+
+    The block is called on the same thread as it was added on, and can only
+    be added on threads which are currently within a run loop. Unless you are
+    specifically creating and running a run loop on a background thread, this
+    normally will only be the main thread.
+
+    Notifications can't be delivered as long as the runloop is blocked by
+    other activity. When notifications can't be delivered instantly, multiple
+    notifications may be coalesced.
+
+    You must retain the returned token for as long as you want updates to continue
+    to be sent to the block. To stop receiving updates, call stop() on the token.
+
+    - parameter block: A block which is called to process Realm notifications.
+                       It receives the following parameters:
+
+                       - `Notification`: The incoming notification.
+                       - `Realm`:        The realm for which this notification occurred.
+
+    - returns: A token which must be held for as long as you want notifications to be delivered.
+    */
+    public func addNotificationBlock(block: NotificationBlock) -> NotificationToken {
+        return rlmRealm.addNotificationBlock { rlmNotification, _ in
+            switch rlmNotification {
+            case RLMNotification.DidChange:
+                block(notification: .DidChange, realm: self)
+            case RLMNotification.RefreshRequired:
+                block(notification: .RefreshRequired, realm: self)
+            default:
+                fatalError("Unhandled notification type: \(rlmNotification)")
+            }
+        }
+    }
+
+    // MARK: Autorefresh and Refresh
+
+    /**
+    Whether this Realm automatically updates when changes happen in other threads.
+
+    If set to `true` (the default), changes made on other threads will be reflected
+    in this Realm on the next cycle of the run loop after the changes are
+    committed.  If set to `false`, you must manually call `refresh()` on the Realm to
+    update it to get the latest version.
+
+    Note that by default, background threads do not have an active run loop and you
+    will need to manually call `refresh()` in order to update to the latest version,
+    even if `autorefresh` is set to `true`.
+
+    Even with this enabled, you can still call `refresh()` at any time to update the
+    Realm before the automatic refresh would occur.
+
+    Notifications are sent when a write transaction is committed whether or not
+    this is enabled.
+
+    Disabling this on a `Realm` without any strong references to it will not
+    have any effect, and it will switch back to YES the next time the `Realm`
+    object is created. This is normally irrelevant as it means that there is
+    nothing to refresh (as persisted `Object`s, `List`s, and `Results` have strong
+    references to the containing `Realm`), but it means that setting
+    `Realm().autorefresh = false` in
+    `application(_:didFinishLaunchingWithOptions:)` and only later storing Realm
+    objects will not work.
+
+    Defaults to true.
+    */
+    public var shouldAutorefresh: Bool {
+        get {
+            return rlmRealm.autorefresh
+        }
+        set {
+            rlmRealm.autorefresh = newValue
+        }
+    }
+
+    /**
+    Update a `Realm` and outstanding objects to point to the most recent
+    data for this `Realm`.
+
+    - returns: Whether the realm had any updates.
+               Note that this may return true even if no data has actually changed.
+    */
+    @discardableResult
+    public func refresh() -> Bool {
+        return rlmRealm.refresh()
+    }
+
+    // MARK: Invalidation
+
+    /**
+    Invalidate all `Object`s and `Results` read from this Realm.
+
+    A Realm holds a read lock on the version of the data accessed by it, so
+    that changes made to the Realm on different threads do not modify or delete the
+    data seen by this Realm. Calling this method releases the read lock,
+    allowing the space used on disk to be reused by later write transactions rather
+    than growing the file. This method should be called before performing long
+    blocking operations on a background thread on which you previously read data
+    from the Realm which you no longer need.
+
+    All `Object`, `Results` and `List` instances obtained from this
+    `Realm` on the current thread are invalidated, and can not longer be used.
+    The `Realm` itself remains valid, and a new read transaction is implicitly
+    begun the next time data is read from the Realm.
+
+    Calling this method multiple times in a row without reading any data from the
+    Realm, or before ever reading any data from the Realm is a no-op. This method
+    cannot be called on a read-only Realm.
+    */
+    public func invalidate() {
+        rlmRealm.invalidate()
+    }
+
+    // MARK: Writing a Copy
+
+    /**
+    Write an encrypted and compacted copy of the Realm to the given local URL.
+
+    The destination file cannot already exist.
+
+    Note that if this is called from within a write transaction it writes the
+    *current* data, and not data when the last write transaction was committed.
+
+    - parameter fileURL:       Local URL to save the Realm to.
+    - parameter encryptionKey: Optional 64-byte encryption key to encrypt the new file with.
+
+    - throws: An NSError if the copy could not be written.
+    */
+    public func writeCopy(toFileURL url: URL, encryptionKey: Data? = nil) throws {
+        try rlmRealm.writeCopy(to: url, encryptionKey: encryptionKey)
+    }
+
+    // MARK: Internal
+
+    internal var rlmRealm: RLMRealm
+
+    internal init(_ rlmRealm: RLMRealm) {
+        self.rlmRealm = rlmRealm
+    }
+}
+
+// MARK: Equatable
+
+extension Realm: Equatable { }
+
+/// Returns whether the two realms are equal.
+public func == (lhs: Realm, rhs: Realm) -> Bool { // swiftlint:disable:this valid_docs
+    return lhs.rlmRealm == rhs.rlmRealm
+}
+
+// MARK: Notifications
+
+/// A notification due to changes to a realm.
+public enum Notification: String {
+    /**
+    Posted when the data in a realm has changed.
+
+    DidChange is posted after a realm has been refreshed to reflect a write transaction, i.e. when
+    an autorefresh occurs, `refresh()` is called, after an implicit refresh from
+    `write(_:)`/`beginWrite()`, and after a local write transaction is committed.
+    */
+    case DidChange = "RLMRealmDidChangeNotification"
+
+    /**
+    Posted when a write transaction has been committed to a Realm on a different thread for the same
+    file. This is not posted if `autorefresh` is enabled or if the Realm is refreshed before the
+    notification has a chance to run.
+
+    Realms with autorefresh disabled should normally have a handler for this notification which
+    calls `refresh()` after doing some work.
+    While not refreshing is allowed, it may lead to large Realm files as Realm has to keep an extra
+    copy of the data for the un-refreshed Realm.
+    */
+    case RefreshRequired = "RLMRealmRefreshRequiredNotification"
+}
+
+/// Closure to run when the data in a Realm was modified.
+public typealias NotificationBlock = (notification: Notification, realm: Realm) -> Void
+
+
+// MARK: Unavailable
+
+extension Realm {
+
+    @available(*, unavailable, renamed:"isInWriteTransaction")
+    public var inWriteTransaction : Bool { fatalError() }
+
+    @available(*, unavailable, renamed:"createObject(ofType:populatedWith:update:)")
+    public func create<T: Object>(_ type: T.Type, value: AnyObject = [:], update: Bool = false) -> T { fatalError() }
+
+    @available(*, unavailable, renamed:"createDynamicObject(ofType:populatedWith:update:)")
+    public func dynamicCreate(_ className: String, value: AnyObject = [:], update: Bool = false) -> DynamicObject {
+        fatalError()
+    }
+
+    @available(*, unavailable, renamed:"delete(_:)")
+    public func delete<T: Object>(objects: List<T>) { }
+
+    @available(*, unavailable, renamed:"delete(_:)")
+    public func delete<T: Object>(objects: Results<T>) { }
+
+    @available(*, unavailable, renamed:"deleteAllObjects()")
+    public func deleteAll() { }
+
+    @available(*, unavailable, renamed:"allObjects(ofType:)")
+    public func objects<T: Object>(_ type: T.Type) -> Results<T> { fatalError() }
+
+    @available(*, unavailable, renamed:"allDynamicObjects(ofType:)")
+    public func dynamicObjects(_ className: String) -> Results<DynamicObject> { fatalError() }
+
+    @available(*, unavailable, renamed:"object(ofType:forPrimaryKey:)")
+    public func objectForPrimaryKey<T: Object>(_ type: T.Type, key: AnyObject) -> T? { fatalError() }
+
+    @available(*, unavailable, renamed:"dynamicObject(ofType:forPrimaryKey:)")
+    public func dynamicObjectForPrimaryKey(_ className: String, key: AnyObject) -> DynamicObject? { fatalError() }
+
+    @available(*, unavailable, renamed:"shouldAutorefresh")
+    public var autorefresh : Bool { get { fatalError() } set { fatalError() } }
+
+    @available(*, unavailable, renamed:"writeCopy(toFileURL:encryptionKey:)")
+    public func writeCopyToURL(_ fileURL: NSURL, encryptionKey: NSData? = nil) throws { fatalError() }
+}
+
+#else
+
+/**
+ A `Realm` instance (also referred to as "a Realm") represents a Realm database.
+
+ Realms can either be stored on disk (see `init(path:)`) or in memory (see `Configuration`).
+
+ `Realm` instances are cached internally, and constructing equivalent `Realm` objects (for example, by using the same
+ path or identifier) produces limited overhead.
+
+ If you specifically want to ensure a `Realm` instance is destroyed (for example, if you wish to open a Realm, check
+ some property, and then possibly delete the Realm file and re-open it), place the code which uses the Realm within an
+ `autoreleasepool {}` and ensure you have no other strong references to it.
+
+ - warning: `Realm` instances are not thread safe and cannot be shared across threads or dispatch queues. You must
+            construct a new instance for each thread in which a Realm will be accessed. For dispatch queues, this means
+            that you must construct a new instance in each block which is dispatched, as a queue is not guaranteed to
+            run all of its blocks on the same thread.
+*/
+public final class Realm {
+
+    // MARK: Properties
+
+    /// The `Schema` used by the Realm.
+    public var schema: Schema { return Schema(rlmRealm.schema) }
+
+    /// The `Configuration` value that was used to create this `Realm` instance.
+    public var configuration: Configuration { return Configuration.fromRLMRealmConfiguration(rlmRealm.configuration) }
+
+    /// Indicates if this Realm contains any objects.
+    public var isEmpty: Bool { return rlmRealm.isEmpty }
+
+    // MARK: Initializers
+
+    /**
+     Obtains an instance of the default Realm.
+
+     The default Realm is persisted as *default.realm* under the *Documents* directory of your Application on iOS, and
+     in your application's *Application Support* directory on OS X.
+
+     The default Realm is created using the default `Configuration`, which can be changed by setting the
+     `Realm.Configuration.defaultConfiguration` property to a new value.
+
+     - throws: An `NSError` if the Realm could not be initialized.
+     */
+    public convenience init() throws {
+        let rlmRealm = try RLMRealm(configuration: RLMRealmConfiguration.defaultConfiguration())
+        self.init(rlmRealm)
+    }
+
+    /**
+     Obtains a `Realm` instance with the given configuration.
+
+     - parameter configuration: A configuration value to use when creating the Realm.
+
+     - throws: An `NSError` if the Realm could not be initialized.
+     */
+    public convenience init(configuration: Configuration) throws {
+        let rlmRealm = try RLMRealm(configuration: configuration.rlmConfiguration)
+        self.init(rlmRealm)
+    }
+
+    /**
+     Obtains a `Realm` instance persisted at a specified file URL.
+
+     - parameter fileURL: The local URL of the file the Realm should be saved at.
+
+     - throws: An `NSError` if the Realm could not be initialized.
+     */
+    public convenience init(fileURL: NSURL) throws {
+        var configuration = Configuration.defaultConfiguration
+        configuration.fileURL = fileURL
+        try self.init(configuration: configuration)
+    }
+
+    // MARK: Transactions
+
+    /**
+     Performs actions contained within the given block inside a write transaction.
+
+     If the block throws an error, the transaction will be canceled, reverting any writes made in the block before
+     the error was thrown.
+
+     Write transactions cannot be nested, and trying to execute a write transaction on a Realm which is already
+     participating in a write transaction will throw an error. Calls to `write` from `Realm` instances in other threads
+     will block until the current write transaction completes.
+
+     Before executing the write transaction, `write` updates the `Realm` instance to the
+     latest Realm version, as if `refresh()` had been called, and generates notifications
+     if applicable. This has no effect if the Realm was already up to date.
+
+     - parameter block: The block containing actions to perform.
+
+     - throws: An `NSError` if the transaction could not be completed successfully.
+               If `block` throws, the propagated `ErrorType`.
+     */
+    public func write(@noescape block: (() throws -> Void)) throws {
+        beginWrite()
+        do {
+            try block()
+        } catch let error {
+            if inWriteTransaction { cancelWrite() }
+            throw error
+        }
+        if inWriteTransaction { try commitWrite() }
+    }
+
+    /**
+     Begins a write transaction on the Realm.
+
+     Only one write transaction can be open at a time. Write transactions cannot be
+     nested, and trying to begin a write transaction on a Realm which is
+     already in a write transaction will throw an error. Calls to
+     `beginWrite` from `Realm` instances in other threads will block
+     until the current write transaction completes.
+
+     Before beginning the write transaction, `beginWrite` updates the
+     `Realm` instance to the latest Realm version, as if `refresh()` had been called, and
+     generates notifications if applicable. This has no effect if the Realm
+     was already up to date.
+
+     It is rarely a good idea to have write transactions span multiple cycles of
+     the run loop, but if you do wish to do so you will need to ensure that the
+     Realm in the write transaction is kept alive until the write transaction
+     is committed.
+     */
+    public func beginWrite() {
+        rlmRealm.beginWriteTransaction()
+    }
+
+    /**
+     Commits all write operations in the current write transaction, and ends the transaction.
+
+     - warning: This method may only be called during a write transaction.
+
+     - throws: An `NSError` if the transaction could not be written.
+     */
+    public func commitWrite() throws {
+        try rlmRealm.commitWriteTransaction()
+    }
+
+    /**
+     Reverts all writes made in the current write transaction and ends the transaction.
+
+     This rolls back all objects in the Realm to the state they were in at the
+     beginning of the write transaction, and then ends the transaction.
+
+     This restores the data for deleted objects, but does not revive invalidated
+     object instances. Any `Object`s which were added to the Realm will be
+     invalidated rather than becoming unmanaged.
+     Given the following code:
+
+     ```swift
+     let oldObject = objects(ObjectType).first!
+     let newObject = ObjectType()
+
+     realm.beginWrite()
+     realm.add(newObject)
+     realm.delete(oldObject)
+     realm.cancelWrite()
+     ```
+
+     Both `oldObject` and `newObject` will return `true` for `invalidated`,
+     but re-running the query which provided `oldObject` will once again return
+     the valid object.
+
+     - warning: This method may only be called during a write transaction.
+     */
+    public func cancelWrite() {
+        rlmRealm.cancelWriteTransaction()
+    }
+
+    /**
+     Indicates whether this Realm is currently in a write transaction.
+
+     - warning: Do not simply check this property and then start a write transaction whenever an object needs to be
+                created, updated, or removed. Doing so might cause a large number of write transactions to be created,
+                degrading performance. Instead, always prefer performing multiple updates during a single transaction.
+     */
+    public var inWriteTransaction: Bool {
+        return rlmRealm.inWriteTransaction
+    }
+
+    // MARK: Adding and Creating objects
+
+    /**
+     Adds or updates an existing object into the Realm.
+
+     Only pass `true` to `update` if the object has a primary key. If no objects exist in
+     the Realm with the same primary key value, the object is inserted. Otherwise,
+     the existing object is updated with any changed values.
+
+     When added, all child relationships referenced by this object will also be added to
+     the Realm if they are not already in it. If the object or any related
+     objects are already being managed by a different Realm an error will be thrown. Use one
+     of the `create` functions to insert a copy of a managed object into a different
+     Realm.
+
+     The object to be added must be valid and cannot have been previously deleted
+     from a Realm (i.e. `invalidated` must be `false`).
+
+     - parameter object: The object to be added to this Realm.
+     - parameter update: If `true`, the Realm will try to find an existing copy of the object (with the same primary
+                         key), and update it. Otherwise, the object will be added.
+     */
+    public func add(object: Object, update: Bool = false) {
+        if update && object.objectSchema.primaryKeyProperty == nil {
+            throwRealmException("'\(object.objectSchema.className)' does not have a primary key and can not be updated")
+        }
+        RLMAddObjectToRealm(object, rlmRealm, update)
+    }
+
+    /**
+     Adds or updates all the objects in a collection into the Realm.
+
+     - see: `add(_:update:)`
+
+     - warning: This method may only be called during a write transaction.
+
+     - parameter objects: A sequence which contains objects to be added to the Realm.
+     - parameter update: If `true`, objects that are already in the Realm will be updated instead of added anew.
+     */
+    public func add<S: SequenceType where S.Generator.Element: Object>(objects: S, update: Bool = false) {
+        for obj in objects {
+            add(obj, update: update)
+        }
+    }
+
+    /**
+     Creates or updates a Realm object with a given value, adding it to the Realm and returning it.
+
+     Only pass `true` to `update` if the object has a primary key. If no objects exist in
+     the Realm with the same primary key value, the object is inserted. Otherwise,
+     the existing object is updated with any changed values.
+
+     The `value` argument can be a key-value coding compliant object, an array or dictionary returned from the methods
+     in `NSJSONSerialization`, or an `Array` containing one element for each managed property. An exception will be
+     thrown if any required properties are not present and those properties were not defined with default values. Do not
+     pass in a `LinkingObjects` instance, either by itself or as a member of a collection.
+
+     When passing in an `Array` as the `value` argument, all properties must be present, valid and in the same order as
+     the properties defined in the model.
+
+     - warning: This method may only be called during a write transaction.
+
+     - parameter type:   The type of the object to create.
+     - parameter value:  The value used to populate the object.
+     - parameter update: If `true`, the Realm will try to find an existing copy of the object (with the same primary
+                         key), and update it. Otherwise, the object will be added.
+
+     - returns: The newly created object.
+     */
+    public func create<T: Object>(type: T.Type, value: AnyObject = [:], update: Bool = false) -> T {
+        let className = (type as Object.Type).className()
+        if update && schema[className]?.primaryKeyProperty == nil {
+            throwRealmException("'\(className)' does not have a primary key and can not be updated")
+        }
+        return unsafeBitCast(RLMCreateObjectInRealmWithValue(rlmRealm, className, value, update), T.self)
+    }
+
+    /**
+     This method is useful only in specialized circumstances, for example, when building
+     components that integrate with Realm. If you are simply building an app on Realm, it is
+     recommended to use the typed method `create(_:value:update:)`.
+
+     Creates or updates an object with the given class name and adds it to the `Realm`, populating
+     the object with the given value.
+
+     When 'update' is 'true', the object must have a primary key. If no objects exist in
+     the Realm instance with the same primary key value, the object is inserted. Otherwise,
+     the existing object is updated with any changed values.
+
+     The `value` argument is used to populate the object. It can be a key-value coding compliant object, an array or
+     dictionary returned from the methods in `NSJSONSerialization`, or an `Array` containing one element for each
+     managed property. An exception will be thrown if any required properties are not present and those properties were
+     not defined with default values.
+
+     When passing in an `Array` as the `value` argument, all properties must be present, valid and in the same order as
+     the properties defined in the model.
+
+     - warning: This method can only be called during a write transaction.
+
+     - parameter className:  The class name of the object to create.
+     - parameter value:      The value used to populate the object.
+     - parameter update:     If true will try to update existing objects with the same primary key.
+
+     - returns: The created object.
+
+     :nodoc:
+     */
+    public func dynamicCreate(className: String, value: AnyObject = [:], update: Bool = false) -> DynamicObject {
+        if update && schema[className]?.primaryKeyProperty == nil {
+            throwRealmException("'\(className)' does not have a primary key and can not be updated")
+        }
+        return unsafeBitCast(RLMCreateObjectInRealmWithValue(rlmRealm, className, value, update), DynamicObject.self)
+    }
+
+    // MARK: Deleting objects
+
+    /**
+     Deletes an object from the Realm. Once the object is deleted it is considered invalidated.
+
+     - warning: This method may only be called during a write transaction.
+
+     - parameter object: The object to be deleted.
+     */
+    public func delete(object: Object) {
+        RLMDeleteObjectFromRealm(object, rlmRealm)
+    }
+
+    /**
+     Deletes one or more objects from the Realm.
+
+     - warning: This method may only be called during a write transaction.
+
+     - parameter objects:   The objects to be deleted. This can be a `List<Object>`, `Results<Object>`,
+                            or any other enumerable `SequenceType` whose elements are `Object`s.
+     */
+    public func delete<S: SequenceType where S.Generator.Element: Object>(objects: S) {
+        for obj in objects {
+            delete(obj)
+        }
+    }
+
+    /**
+     Deletes one or more objects from the Realm.
+
+     - warning: This method may only be called during a write transaction.
+
+     - parameter objects: A list of objects to delete.
+
+     :nodoc:
+     */
+    public func delete<T: Object>(objects: List<T>) {
+        rlmRealm.deleteObjects(objects._rlmArray)
+    }
+
+    /**
+     Deletes one or more objects from the Realm.
+
+     - warning: This method may only be called during a write transaction.
+
+     - parameter objects: A `Results` containing the objects to be deleted.
+
+     :nodoc:
+     */
+    public func delete<T: Object>(objects: Results<T>) {
+        rlmRealm.deleteObjects(objects.rlmResults)
+    }
+
+    /**
+     Deletes all objects from the Realm.
+
+     - warning: This method may only be called during a write transaction.
+     */
+    public func deleteAll() {
+        RLMDeleteAllObjectsFromRealm(rlmRealm)
+    }
+
+    // MARK: Object Retrieval
+
+    /**
+     Returns all objects of the given type stored in the Realm.
+
+     - parameter type: The type of the objects to be returned.
+
+     - returns: A `Results` containing the objects.
+    */
+    public func objects<T: Object>(type: T.Type) -> Results<T> {
+        return Results<T>(RLMGetObjects(rlmRealm, (type as Object.Type).className(), nil))
+    }
+
+    /**
+     This method is useful only in specialized circumstances, for example, when building
+     components that integrate with Realm. If you are simply building an app on Realm, it is
+     recommended to use the typed method `objects(type:)`.
+
+     Returns all objects for a given class name in the Realm.
+
+     - warning: This method is useful only in specialized circumstances.
+
+     - parameter className: The class name of the objects to be returned.
+
+     - returns: All objects for the given class name as dynamic objects
+
+     :nodoc:
+    */
+    public func dynamicObjects(className: String) -> Results<DynamicObject> {
+        return Results<DynamicObject>(RLMGetObjects(rlmRealm, className, nil))
+    }
+
+    /**
+     Retrieves the single instance of a given object type with the given primary key from the Realm.
+
+     This method requires that `primaryKey()` be overridden on the given object class.
+
+     - see: `Object.primaryKey()`
+
+     - parameter type: The type of the object to be returned.
+     - parameter key:  The primary key of the desired object.
+
+     - returns: An object of type `type`, or `nil` if no instance with the given primary key exists.
+     */
+    public func objectForPrimaryKey<T: Object>(type: T.Type, key: AnyObject?) -> T? {
+        return unsafeBitCast(RLMGetObject(rlmRealm, (type as Object.Type).className(), key), Optional<T>.self)
+    }
+
+    /**
+     This method is useful only in specialized circumstances, for example, when building
+     components that integrate with Realm. If you are simply building an app on Realm, it is
+     recommended to use the typed method `objectForPrimaryKey(_:key:)`.
+
+     Get a dynamic object with the given class name and primary key.
+
+     Returns `nil` if no object exists with the given class name and primary key.
+
+     This method requires that `primaryKey()` be overridden on the given subclass.
+
+     - see: Object.primaryKey()
+
+     - warning: This method is useful only in specialized circumstances.
+
+     - parameter className:  The class name of the object to be returned.
+     - parameter key:        The primary key of the desired object.
+
+     - returns: An object of type `DynamicObject` or `nil` if an object with the given primary key does not exist.
+
+     :nodoc:
+     */
+    public func dynamicObjectForPrimaryKey(className: String, key: AnyObject?) -> DynamicObject? {
+        return unsafeBitCast(RLMGetObject(rlmRealm, className, key), Optional<DynamicObject>.self)
+    }
+
+    // MARK: Notifications
+
+    /**
+     Adds a notification handler for changes made to this Realm, and returns a notification token.
+
+     Notification handlers are called after each write transaction is committed, independent of the thread or process.
+
+     Handler blocks are called on the same thread that they were added on, and may only be added on threads which are
+     currently within a run loop. Unless you are specifically creating and running a run loop on a background thread,
+     this will normally only be the main thread.
+
+     Notifications can't be delivered as long as the run loop is blocked by other activity. When notifications can't be
+     delivered instantly, multiple notifications may be coalesced.
+
+     You must retain the returned token for as long as you want updates to be sent to the block. To stop receiving
+     updates, call `stop()` on the token.
+
+     - parameter block: A block which is called to process Realm notifications. It receives the following parameters:
+                        `notification`: the incoming notification; `realm`: the Realm for which the notification
+                        occurred.
+
+     - returns: A token which must be retained for as long as you wish to continue receiving change notifications.
+     */
+    @warn_unused_result(message="You must hold on to the NotificationToken returned from addNotificationBlock")
+    public func addNotificationBlock(block: NotificationBlock) -> NotificationToken {
+        return rlmRealm.addNotificationBlock { rlmNotification, _ in
+            switch rlmNotification {
+            case RLMRealmDidChangeNotification:
+                block(notification: .DidChange, realm: self)
+            case RLMRealmRefreshRequiredNotification:
+                block(notification: .RefreshRequired, realm: self)
+            default:
+                fatalError("Unhandled notification type: \(rlmNotification)")
+            }
+        }
+    }
+
+    // MARK: Autorefresh and Refresh
+
+    /**
+     Set this property to `true` to automatically update this Realm when changes happen in other threads.
+
+     If set to `true` (the default), changes made on other threads will be reflected
+     in this Realm on the next cycle of the run loop after the changes are
+     committed.  If set to `false`, you must manually call `refresh()` on the Realm to
+     update it to get the latest data.
+
+     Note that by default, background threads do not have an active run loop and you
+     will need to manually call `refresh()` in order to update to the latest version,
+     even if `autorefresh` is set to `true`.
+
+     Even with this property enabled, you can still call `refresh()` at any time to update the
+     Realm before the automatic refresh would occur.
+
+     Notifications are sent when a write transaction is committed whether or not
+     automatic refreshing is enabled.
+
+     Disabling `autorefresh` on a `Realm` without any strong references to it will not
+     have any effect, and `autorefresh` will revert back to `true` the next time the Realm is created. This is normally
+     irrelevant as it means that there is nothing to refresh (as managed `Object`s, `List`s, and `Results` have strong
+     references to the `Realm` that manages them), but it means that setting
+     `Realm().autorefresh = false` in
+     `application(_:didFinishLaunchingWithOptions:)` and only later storing Realm
+     objects will not work.
+
+     Defaults to `true`.
+     */
+    public var autorefresh: Bool {
+        get {
+            return rlmRealm.autorefresh
+        }
+        set {
+            rlmRealm.autorefresh = newValue
+        }
+    }
+
+    /**
+     Updates the Realm and outstanding objects managed by the Realm to point to the most recent data.
+
+     - returns: Whether there were any updates for the Realm. Note that `true` may be returned even if no data actually
+                changed.
+     */
+    public func refresh() -> Bool {
+        return rlmRealm.refresh()
+    }
+
+    // MARK: Invalidation
+
+    /**
+     Invalidates all `Object`s, `Results`, `LinkingObjects`, and `List`s managed by the Realm.
+
+     A Realm holds a read lock on the version of the data accessed by it, so
+     that changes made to the Realm on different threads do not modify or delete the
+     data seen by this Realm. Calling this method releases the read lock,
+     allowing the space used on disk to be reused by later write transactions rather
+     than growing the file. This method should be called before performing long
+     blocking operations on a background thread on which you previously read data
+     from the Realm which you no longer need.
+
+     All `Object`, `Results` and `List` instances obtained from this `Realm` instance on the current thread are
+     invalidated. `Object`s and `Array`s cannot be used. `Results` will become empty. The Realm itself remains valid,
+     and a new read transaction is implicitly begun the next time data is read from the Realm.
+
+     Calling this method multiple times in a row without reading any data from the
+     Realm, or before ever reading any data from the Realm, is a no-op. This method
+     may not be called on a read-only Realm.
+     */
+    public func invalidate() {
+        rlmRealm.invalidate()
+    }
+
+    // MARK: Writing a Copy
+
+    /**
+     Writes a compacted and optionally encrypted copy of the Realm to the given local URL.
+
+     The destination file cannot already exist.
+
+     Note that if this method is called from within a write transaction, the *current* data is written, not the data
+     from the point when the previous write transaction was committed.
+
+     - parameter fileURL:       Local URL to save the Realm to.
+     - parameter encryptionKey: Optional 64-byte encryption key to encrypt the new file with.
+
+     - throws: An `NSError` if the copy could not be written.
+     */
+    public func writeCopyToURL(fileURL: NSURL, encryptionKey: NSData? = nil) throws {
+        try rlmRealm.writeCopyToURL(fileURL, encryptionKey: encryptionKey)
+    }
+
+    // MARK: Internal
+
+    internal var rlmRealm: RLMRealm
+
+    internal init(_ rlmRealm: RLMRealm) {
+        self.rlmRealm = rlmRealm
+    }
+}
+
+// MARK: Equatable
+
+extension Realm: Equatable { }
+
+/// Returns a Boolean indicating whether two `Realm` instances are equal.
+public func == (lhs: Realm, rhs: Realm) -> Bool { // swiftlint:disable:this valid_docs
+    return lhs.rlmRealm == rhs.rlmRealm
+}
+
+// MARK: Notifications
+
+/// A notification indicating that changes were made to a Realm.
+public enum Notification: String {
+    /**
+     This notification is posted when the data in a Realm has changed.
+
+     `DidChange` is posted after a Realm has been refreshed to reflect a write transaction, This can happen when
+     an autorefresh occurs, `refresh()` is called, after an implicit refresh from
+     `write(_:)`/`beginWrite()`, or after a local write transaction is committed.
+    */
+    case DidChange = "RLMRealmDidChangeNotification"
+
+    /**
+     This notification is posted when a write transaction has been committed to a Realm on a different thread for the
+     same file.
+
+     It is not posted if `autorefresh` is enabled, or if the Realm is refreshed before the
+     notification has a chance to run.
+
+     Realms with autorefresh disabled should normally install a handler for this notification which calls `refresh()`
+     after doing some work. Refreshing the Realm is optional, but not refreshing the Realm may lead to large Realm
+     files. This is because Realm must keep an extra copy of the data for the stale Realm.
+    */
+    case RefreshRequired = "RLMRealmRefreshRequiredNotification"
+}
+
+/// The type of a block to run for notification purposes when the data in a Realm is modified.
+public typealias NotificationBlock = (notification: Notification, realm: Realm) -> Void
+
+#endif
diff --git a/Pods/RealmSwift/RealmSwift/RealmCollectionType.swift b/Pods/RealmSwift/RealmSwift/RealmCollectionType.swift
new file mode 100644
index 0000000..4a37cb9
--- /dev/null
+++ b/Pods/RealmSwift/RealmSwift/RealmCollectionType.swift
@@ -0,0 +1,1882 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+import Foundation
+import Realm
+
+#if swift(>=3.0)
+
+/**
+Encapsulates iteration state and interface for iteration over a `RealmCollection`.
+*/
+public final class RLMIterator<T: Object>: IteratorProtocol {
+    private var i: UInt = 0
+    private let generatorBase : NSFastEnumerationIterator
+
+    init(collection: RLMCollection) {
+        generatorBase = NSFastEnumerationIterator(collection)
+    }
+
+    /// Advance to the next element and return it, or `nil` if no next element exists.
+    public func next() -> T? { // swiftlint:disable:this valid_docs
+        let accessor = generatorBase.next() as! T?
+        if let accessor = accessor {
+            RLMInitializeSwiftAccessorGenerics(accessor)
+        }
+        return accessor
+    }
+}
+
+/**
+ RealmCollectionChange is passed to the notification blocks for Realm
+ collections, and reports the current state of the collection and what changes
+ were made to the collection since the last time the notification was called.
+
+ The arrays of indices in the .Update case follow UITableView's batching
+ conventions, and can be passed as-is to a table view's batch update functions
+ after converting to index paths in the appropriate section. For example, for a
+ simple one-section table view, you can do the following:
+
+    self.notificationToken = results.addNotificationBlock { changes
+        switch changes {
+        case .Initial:
+            // Results are now populated and can be accessed without blocking the UI
+            self.tableView.reloadData()
+            break
+        case .Update(_, let deletions, let insertions, let modifications):
+            // Query results have changed, so apply them to the TableView
+            self.tableView.beginUpdates()
+            self.tableView.insertRowsAtIndexPaths(insertions.map { NSIndexPath(forRow: $0, inSection: 0) },
+                withRowAnimation: .Automatic)
+            self.tableView.deleteRowsAtIndexPaths(deletions.map { NSIndexPath(forRow: $0, inSection: 0) },
+                withRowAnimation: .Automatic)
+            self.tableView.reloadRowsAtIndexPaths(modifications.map { NSIndexPath(forRow: $0, inSection: 0) },
+                withRowAnimation: .Automatic)
+            self.tableView.endUpdates()
+            break
+        case .Error(let err):
+            // An error occurred while opening the Realm file on the background worker thread
+            fatalError("\(err)")
+            break
+        }
+    }
+ */
+public enum RealmCollectionChange<T> {
+    /// The initial run of the query has completed (if applicable), and the
+    /// collection can now be used without performing any blocking work.
+    case Initial(T)
+
+    /// A write transaction has been committed which either changed which objects
+    /// are in the collection and/or modified one or more of the objects in the
+    /// collection.
+    ///
+    /// All three of the change arrays are always sorted in ascending order.
+    ///
+    /// - parameter deletions:     The indices in the previous version of the collection
+    ///                            which were removed from this one.
+    /// - parameter insertions:    The indices in the new collection which were added in
+    ///                            this version.
+    /// - parameter modifications: The indices of the objects in the new collection which
+    ///                            were modified in this version.
+    case Update(T, deletions: [Int], insertions: [Int], modifications: [Int])
+
+    /// If an error occurs, notification blocks are called one time with a
+    /// .Error result and an NSError with details. Currently the only thing
+    /// that can fail is opening the Realm on a background worker thread to
+    /// calculate the change set.
+    case Error(NSError)
+
+    static func fromObjc(value: T, change: RLMCollectionChange?, error: NSError?) -> RealmCollectionChange {
+        if let error = error {
+            return .Error(error)
+        }
+        if let change = change {
+            return .Update(value,
+                deletions: change.deletions as! [Int],
+                insertions: change.insertions as! [Int],
+                modifications: change.modifications as! [Int])
+        }
+        return .Initial(value)
+    }
+}
+
+/**
+A homogenous collection of `Object`s which can be retrieved, filtered, sorted,
+and operated upon.
+*/
+public protocol RealmCollection: RandomAccessCollection, CustomStringConvertible {
+
+    /// Element type contained in this collection.
+    associatedtype Element: Object
+
+
+    // MARK: Properties
+
+    /// The Realm the objects in this collection belong to, or `nil` if the
+    /// collection's owning object does not belong to a realm (the collection is
+    /// standalone).
+    var realm: Realm? { get }
+
+    /// Indicates if the collection can no longer be accessed.
+    ///
+    /// The collection can no longer be accessed if `invalidate` is called on the containing `Realm`.
+    var isInvalidated: Bool { get }
+
+    /// Returns the number of objects in this collection.
+    var count: Int { get }
+
+    /// Returns a human-readable description of the objects contained in this collection.
+    var description: String { get }
+
+
+    // MARK: Index Retrieval
+
+    /**
+    Returns the index of the given object, or `nil` if the object is not in the collection.
+
+    - parameter object: The object whose index is being queried.
+
+    - returns: The index of the given object, or `nil` if the object is not in the collection.
+    */
+    func index(of object: Element) -> Int?
+
+    /**
+    Returns the index of the first object matching the given predicate,
+    or `nil` no objects match.
+
+    - parameter predicate: The `NSPredicate` used to filter the objects.
+
+    - returns: The index of the first matching object, or `nil` if no objects match.
+    */
+    func indexOfObject(for predicate: Predicate) -> Int?
+
+    /**
+    Returns the index of the first object matching the given predicate,
+    or `nil` if no objects match.
+
+    - parameter predicateFormat: The predicate format string, optionally followed by a variable number
+    of arguments.
+
+    - returns: The index of the first matching object, or `nil` if no objects match.
+    */
+    func indexOfObject(for predicateFormat: String, _ args: AnyObject...) -> Int?
+
+
+    // MARK: Filtering
+
+    /**
+    Returns `Results` containing collection elements that match the given predicate.
+
+    - parameter predicateFormat: The predicate format string which can accept variable arguments.
+
+    - returns: `Results` containing collection elements that match the given predicate.
+    */
+    func filter(using predicateFormat: String, _ args: AnyObject...) -> Results<Element>
+
+    /**
+    Returns `Results` containing collection elements that match the given predicate.
+
+    - parameter predicate: The predicate to filter the objects.
+
+    - returns: `Results` containing collection elements that match the given predicate.
+    */
+    func filter(using predicate: Predicate) -> Results<Element>
+
+
+    // MARK: Sorting
+
+    /**
+    Returns `Results` containing collection elements sorted by the given property.
+
+    - parameter property:  The property name to sort by.
+    - parameter ascending: The direction to sort by.
+
+    - returns: `Results` containing collection elements sorted by the given property.
+    */
+    func sorted(onProperty property: String, ascending: Bool) -> Results<Element>
+
+    /**
+    Returns `Results` with elements sorted by the given sort descriptors.
+
+    - parameter sortDescriptors: `SortDescriptor`s to sort by.
+
+    - returns: `Results` with elements sorted by the given sort descriptors.
+    */
+    func sorted<S: Sequence where S.Iterator.Element == SortDescriptor>(with sortDescriptors: S) -> Results<Element>
+
+
+    // MARK: Aggregate Operations
+
+    /**
+    Returns the minimum value of the given property.
+
+    - warning: Only names of properties of a type conforming to the `MinMaxType` protocol can be used.
+
+    - parameter property: The name of a property conforming to `MinMaxType` to look for a minimum on.
+
+    - returns: The minimum value for the property amongst objects in the collection, or `nil` if the
+               collection is empty.
+    */
+    func minimumValue<U: MinMaxType>(ofProperty property: String) -> U?
+
+    /**
+    Returns the maximum value of the given property.
+
+    - warning: Only names of properties of a type conforming to the `MinMaxType` protocol can be used.
+
+    - parameter property: The name of a property conforming to `MinMaxType` to look for a maximum on.
+
+    - returns: The maximum value for the property amongst objects in the collection, or `nil` if the
+               collection is empty.
+    */
+    func maximumValue<U: MinMaxType>(ofProperty property: String) -> U?
+
+    /**
+    Returns the sum of the given property for objects in the collection.
+
+    - warning: Only names of properties of a type conforming to the `AddableType` protocol can be used.
+
+    - parameter property: The name of a property conforming to `AddableType` to calculate sum on.
+
+    - returns: The sum of the given property over all objects in the collection.
+    */
+    func sum<U: AddableType>(ofProperty property: String) -> U
+
+    /**
+    Returns the average of the given property for objects in the collection.
+
+    - warning: Only names of properties of a type conforming to the `AddableType` protocol can be used.
+
+    - parameter property: The name of a property conforming to `AddableType` to calculate average on.
+
+    - returns: The average of the given property over all objects in the collection, or `nil` if the
+               collection is empty.
+    */
+    func average<U: AddableType>(ofProperty property: String) -> U?
+
+
+    // MARK: Key-Value Coding
+
+    /**
+    Returns an Array containing the results of invoking `valueForKey(_:)` using key on each of the collection's objects.
+
+    - parameter key: The name of the property.
+
+    - returns: Array containing the results of invoking `valueForKey(_:)` using key on each of the collection's objects.
+    */
+    func value(forKey key: String) -> AnyObject?
+
+    /**
+     Returns an Array containing the results of invoking `valueForKeyPath(_:)` using keyPath on each of the
+     collection's objects.
+
+     - parameter keyPath: The key path to the property.
+
+     - returns: Array containing the results of invoking `valueForKeyPath(_:)` using keyPath on each of the
+     collection's objects.
+     */
+    func value(forKeyPath keyPath: String) -> AnyObject?
+
+    /**
+    Invokes `setValue(_:forKey:)` on each of the collection's objects using the specified value and key.
+
+    - warning: This method can only be called during a write transaction.
+
+    - parameter value: The object value.
+    - parameter key:   The name of the property.
+    */
+    func setValue(_ value: AnyObject?, forKey key: String)
+
+    // MARK: Notifications
+
+    /**
+     Register a block to be called each time the collection changes.
+
+     The block will be asynchronously called with the initial results, and then
+     called again after each write transaction which changes either any of the
+     objects in the collection, or which objects are in the collection.
+
+     At the time when the block is called, the collection object will be fully
+     evaluated and up-to-date, and as long as you do not perform a write
+     transaction on the same thread or explicitly call realm.refresh(),
+     accessing it will never perform blocking work.
+
+     Notifications are delivered via the standard run loop, and so can't be
+     delivered while the run loop is blocked by other activity. When
+     notifications can't be delivered instantly, multiple notifications may be
+     coalesced into a single notification. This can include the notification
+     with the initial collection. For example, the following code performs a write
+     transaction immediately after adding the notification block, so there is no
+     opportunity for the initial notification to be delivered first. As a
+     result, the initial notification will reflect the state of the Realm after
+     the write transaction.
+
+         let results = realm.objects(Dog)
+         print("dogs.count: \(dogs?.count)") // => 0
+         let token = dogs.addNotificationBlock { (changes: RealmCollectionChange) in
+             switch changes {
+                 case .Initial(let dogs):
+                     // Will print "dogs.count: 1"
+                     print("dogs.count: \(dogs.count)")
+                     break
+                 case .Update:
+                     // Will not be hit in this example
+                     break
+                 case .Error:
+                     break
+             }
+         }
+         try! realm.write {
+             let dog = Dog()
+             dog.name = "Rex"
+             person.dogs.append(dog)
+         }
+         // end of run loop execution context
+
+     You must retain the returned token for as long as you want updates to continue
+     to be sent to the block. To stop receiving updates, call stop() on the token.
+
+     - warning: This method cannot be called during a write transaction, or when
+                the source realm is read-only.
+
+     - parameter block: The block to be called with the evaluated collection and change information.
+     - returns: A token which must be held for as long as you want updates to be delivered.
+     */
+    func addNotificationBlock(block: (RealmCollectionChange<Self>) -> Void) -> NotificationToken
+
+    /// :nodoc:
+    func _addNotificationBlock(block: (RealmCollectionChange<AnyRealmCollection<Element>>) -> Void) -> NotificationToken
+}
+
+private class _AnyRealmCollectionBase<T: Object> {
+    typealias Wrapper = AnyRealmCollection<Element>
+    typealias Element = T
+    var realm: Realm? { fatalError() }
+    var isInvalidated: Bool { fatalError() }
+    var count: Int { fatalError() }
+    var description: String { fatalError() }
+    func index(of object: Element) -> Int? { fatalError() }
+    func indexOfObject(for predicate: Predicate) -> Int? { fatalError() }
+    func indexOfObject(for predicateFormat: String, _ args: AnyObject...) -> Int? { fatalError() }
+    func filter(using predicateFormat: String, _ args: AnyObject...) -> Results<Element> { fatalError() }
+    func filter(using predicate: Predicate) -> Results<Element> { fatalError() }
+    func sorted(onProperty property: String, ascending: Bool) -> Results<Element> { fatalError() }
+    func sorted<S: Sequence where S.Iterator.Element == SortDescriptor>(with sortDescriptors: S) -> Results<Element> {
+        fatalError()
+    }
+    func minimumValue<U: MinMaxType>(ofProperty property: String) -> U? { fatalError() }
+    func maximumValue<U: MinMaxType>(ofProperty property: String) -> U? { fatalError() }
+    func sum<U: AddableType>(ofProperty property: String) -> U { fatalError() }
+    func average<U: AddableType>(ofProperty property: String) -> U? { fatalError() }
+    subscript(position: Int) -> Element { fatalError() }
+    func makeIterator() -> RLMIterator<T> { fatalError() }
+    var startIndex: Int { fatalError() }
+    var endIndex: Int { fatalError() }
+    func value(forKey key: String) -> AnyObject? { fatalError() }
+    func value(forKeyPath keyPath: String) -> AnyObject? { fatalError() }
+    func setValue(_ value: AnyObject?, forKey key: String) { fatalError() }
+    func _addNotificationBlock(block: (RealmCollectionChange<Wrapper>) -> Void)
+        -> NotificationToken { fatalError() }
+}
+
+private final class _AnyRealmCollection<C: RealmCollection>: _AnyRealmCollectionBase<C.Element> {
+    let base: C
+    init(base: C) {
+        self.base = base
+    }
+
+    // MARK: Properties
+
+    /// The Realm the objects in this collection belong to, or `nil` if the
+    /// collection's owning object does not belong to a realm (the collection is
+    /// standalone).
+    override var realm: Realm? { return base.realm }
+
+    /// Indicates if the collection can no longer be accessed.
+    ///
+    /// The collection can no longer be accessed if `invalidate` is called on the containing `Realm`.
+    override var isInvalidated: Bool { return base.isInvalidated }
+
+    /// Returns the number of objects in this collection.
+    override var count: Int { return base.count }
+
+    /// Returns a human-readable description of the objects contained in this collection.
+    override var description: String { return base.description }
+
+
+    // MARK: Index Retrieval
+
+    /**
+    Returns the index of the given object, or `nil` if the object is not in the collection.
+
+    - parameter object: The object whose index is being queried.
+
+    - returns: The index of the given object, or `nil` if the object is not in the collection.
+    */
+    override func index(of object: C.Element) -> Int? { return base.index(of: object) }
+
+    /**
+    Returns the index of the first object matching the given predicate,
+    or `nil` no objects match.
+
+    - parameter predicate: The `NSPredicate` used to filter the objects.
+
+    - returns: The index of the first matching object, or `nil` if no objects match.
+    */
+    override func indexOfObject(for predicate: Predicate) -> Int? { return base.indexOfObject(for: predicate) }
+
+    /**
+    Returns the index of the first object matching the given predicate,
+    or `nil` if no objects match.
+
+    - parameter predicateFormat: The predicate format string, optionally followed by a variable number
+    of arguments.
+
+    - returns: The index of the first matching object, or `nil` if no objects match.
+    */
+    override func indexOfObject(for predicateFormat: String, _ args: AnyObject...) -> Int? {
+        return base.indexOfObject(for: Predicate(format: predicateFormat, argumentArray: args))
+    }
+
+    // MARK: Filtering
+
+    /**
+    Returns `Results` containing collection elements that match the given predicate.
+
+    - parameter predicateFormat: The predicate format string which can accept variable arguments.
+
+    - returns: `Results` containing collection elements that match the given predicate.
+    */
+    override func filter(using predicateFormat: String, _ args: AnyObject...) -> Results<C.Element> {
+        return base.filter(using: Predicate(format: predicateFormat, argumentArray: args))
+    }
+
+    /**
+    Returns `Results` containing collection elements that match the given predicate.
+
+    - parameter predicate: The predicate to filter the objects.
+
+    - returns: `Results` containing collection elements that match the given predicate.
+    */
+    override func filter(using predicate: Predicate) -> Results<C.Element> { return base.filter(using: predicate) }
+
+
+    // MARK: Sorting
+
+    /**
+    Returns `Results` containing collection elements sorted by the given property.
+
+    - parameter property:  The property name to sort by.
+    - parameter ascending: The direction to sort by.
+
+    - returns: `Results` containing collection elements sorted by the given property.
+    */
+    override func sorted(onProperty property: String, ascending: Bool) -> Results<C.Element> {
+        return base.sorted(onProperty: property, ascending: ascending)
+    }
+
+    /**
+    Returns `Results` with elements sorted by the given sort descriptors.
+
+    - parameter sortDescriptors: `SortDescriptor`s to sort by.
+
+    - returns: `Results` with elements sorted by the given sort descriptors.
+    */
+    override func sorted<S: Sequence where S.Iterator.Element == SortDescriptor>
+                        (with sortDescriptors: S) -> Results<C.Element> {
+        return base.sorted(with: sortDescriptors)
+    }
+
+
+    // MARK: Aggregate Operations
+
+    /**
+    Returns the minimum value of the given property.
+
+    - warning: Only names of properties of a type conforming to the `MinMaxType` protocol can be used.
+
+    - parameter property: The name of a property conforming to `MinMaxType` to look for a minimum on.
+
+    - returns: The minimum value for the property amongst objects in the collection, or `nil` if the
+               collection is empty.
+    */
+    override func minimumValue<U: MinMaxType>(ofProperty property: String) -> U? {
+        return base.minimumValue(ofProperty: property)
+    }
+
+    /**
+    Returns the maximum value of the given property.
+
+    - warning: Only names of properties of a type conforming to the `MinMaxType` protocol can be used.
+
+    - parameter property: The name of a property conforming to `MinMaxType` to look for a maximum on.
+
+    - returns: The maximum value for the property amongst objects in the collection, or `nil` if the
+               collection is empty.
+    */
+    override func maximumValue<U: MinMaxType>(ofProperty property: String) -> U? {
+        return base.maximumValue(ofProperty: property)
+    }
+
+    /**
+    Returns the sum of the given property for objects in the collection.
+
+    - warning: Only names of properties of a type conforming to the `AddableType` protocol can be used.
+
+    - parameter property: The name of a property conforming to `AddableType` to calculate sum on.
+
+    - returns: The sum of the given property over all objects in the collection.
+    */
+    override func sum<U: AddableType>(ofProperty property: String) -> U {
+        return base.sum(ofProperty: property)
+    }
+
+    /**
+    Returns the average of the given property for objects in the collection.
+
+    - warning: Only names of properties of a type conforming to the `AddableType` protocol can be used.
+
+    - parameter property: The name of a property conforming to `AddableType` to calculate average on.
+
+    - returns: The average of the given property over all objects in the collection, or `nil` if the
+               collection is empty.
+    */
+    override func average<U: AddableType>(ofProperty property: String) -> U? {
+        return base.average(ofProperty: property)
+    }
+
+
+    // MARK: Sequence Support
+
+    /**
+    Returns the object at the given `index`.
+
+    - parameter index: The index.
+
+    - returns: The object at the given `index`.
+    */
+    override subscript(position: Int) -> C.Element {
+        // FIXME: it should be possible to avoid this force-casting
+        return unsafeBitCast(base[position as! C.Index], to: C.Element.self)
+    }
+
+    /// Returns a `RLMIterator` that yields successive elements in the collection.
+    override func makeIterator() -> RLMIterator<Element> {
+        // FIXME: it should be possible to avoid this force-casting
+        return base.makeIterator() as! RLMIterator<Element>
+    }
+
+
+    // MARK: Collection Support
+
+    /// The position of the first element in a non-empty collection.
+    /// Identical to endIndex in an empty collection.
+    override var startIndex: Int {
+        // FIXME: it should be possible to avoid this force-casting
+        return base.startIndex as! Int
+    }
+
+    /// The collection's "past the end" position.
+    /// endIndex is not a valid argument to subscript, and is always reachable from startIndex by
+    /// zero or more applications of successor().
+    override var endIndex: Int {
+        // FIXME: it should be possible to avoid this force-casting
+        return base.endIndex as! Int
+    }
+
+
+    // MARK: Key-Value Coding
+
+    /**
+    Returns an Array containing the results of invoking `valueForKey(_:)` using key on each of the collection's objects.
+
+    - parameter key: The name of the property.
+
+    - returns: Array containing the results of invoking `valueForKey(_:)` using key on each of the collection's objects.
+    */
+    override func value(forKey key: String) -> AnyObject? { return base.value(forKey: key) }
+
+    /**
+     Returns an Array containing the results of invoking `valueForKeyPath(_:)` using keyPath on each of the
+     collection's objects.
+
+     - parameter keyPath: The key path to the property.
+
+     - returns: Array containing the results of invoking `valueForKeyPath(_:)` using keyPath on each of the
+       collection's objects.
+     */
+    override func value(forKeyPath keyPath: String) -> AnyObject? { return base.value(forKeyPath: keyPath) }
+
+    /**
+    Invokes `setValue(_:forKey:)` on each of the collection's objects using the specified value and key.
+
+    - warning: This method can only be called during a write transaction.
+
+    - parameter value: The object value.
+    - parameter key:   The name of the property.
+    */
+    override func setValue(_ value: AnyObject?, forKey key: String) { base.setValue(value, forKey: key) }
+
+    // MARK: Notifications
+
+    /// :nodoc:
+    override func _addNotificationBlock(block: (RealmCollectionChange<Wrapper>) -> Void)
+        -> NotificationToken { return base._addNotificationBlock(block: block) }
+}
+
+/**
+A type-erased `RealmCollection`.
+
+Forwards operations to an arbitrary underlying collection having the same
+Element type, hiding the specifics of the underlying `RealmCollection`.
+*/
+public final class AnyRealmCollection<T: Object>: RealmCollection {
+
+    public func index(after i: Int) -> Int { return i + 1 }
+    public func index(before i: Int) -> Int { return i - 1 }
+
+    /// Element type contained in this collection.
+    public typealias Element = T
+    private let base: _AnyRealmCollectionBase<T>
+
+    /// Creates an AnyRealmCollection wrapping `base`.
+    public init<C: RealmCollection where C.Element == T>(_ base: C) {
+        self.base = _AnyRealmCollection(base: base)
+    }
+
+    // MARK: Properties
+
+    /// The Realm the objects in this collection belong to, or `nil` if the
+    /// collection's owning object does not belong to a realm (the collection is
+    /// standalone).
+    public var realm: Realm? { return base.realm }
+
+    /// Indicates if the collection can no longer be accessed.
+    ///
+    /// The collection can no longer be accessed if `invalidate` is called on the containing `Realm`.
+    public var isInvalidated: Bool { return base.isInvalidated }
+
+    /// Returns the number of objects in this collection.
+    public var count: Int { return base.count }
+
+    /// Returns a human-readable description of the objects contained in this collection.
+    public var description: String { return base.description }
+
+
+    // MARK: Index Retrieval
+
+    /**
+    Returns the index of the given object, or `nil` if the object is not in the collection.
+
+    - parameter object: The object whose index is being queried.
+
+    - returns: The index of the given object, or `nil` if the object is not in the collection.
+    */
+    public func index(of object: Element) -> Int? { return base.index(of: object) }
+
+    /**
+    Returns the index of the first object matching the given predicate,
+    or `nil` no objects match.
+
+    - parameter predicate: The `NSPredicate` used to filter the objects.
+
+    - returns: The index of the first matching object, or `nil` if no objects match.
+    */
+    public func indexOfObject(for predicate: Predicate) -> Int? { return base.indexOfObject(for: predicate) }
+
+    /**
+    Returns the index of the first object matching the given predicate,
+    or `nil` if no objects match.
+
+    - parameter predicateFormat: The predicate format string, optionally followed by a variable number
+    of arguments.
+
+    - returns: The index of the first matching object, or `nil` if no objects match.
+    */
+    public func indexOfObject(for predicateFormat: String, _ args: AnyObject...) -> Int? {
+        return base.indexOfObject(for: Predicate(format: predicateFormat, argumentArray: args))
+    }
+
+    // MARK: Filtering
+
+    /**
+    Returns `Results` containing collection elements that match the given predicate.
+
+    - parameter predicateFormat: The predicate format string which can accept variable arguments.
+
+    - returns: `Results` containing collection elements that match the given predicate.
+    */
+    public func filter(using predicateFormat: String, _ args: AnyObject...) -> Results<Element> {
+        return base.filter(using: Predicate(format: predicateFormat, argumentArray: args))
+    }
+
+    /**
+    Returns `Results` containing collection elements that match the given predicate.
+
+    - parameter predicate: The predicate to filter the objects.
+
+    - returns: `Results` containing collection elements that match the given predicate.
+    */
+    public func filter(using predicate: Predicate) -> Results<Element> { return base.filter(using: predicate) }
+
+
+    // MARK: Sorting
+
+    /**
+    Returns `Results` containing collection elements sorted by the given property.
+
+    - parameter property:  The property name to sort by.
+    - parameter ascending: The direction to sort by.
+
+    - returns: `Results` containing collection elements sorted by the given property.
+    */
+    public func sorted(onProperty property: String, ascending: Bool) -> Results<Element> {
+        return base.sorted(onProperty: property, ascending: ascending)
+    }
+
+    /**
+    Returns `Results` with elements sorted by the given sort descriptors.
+
+    - parameter sortDescriptors: `SortDescriptor`s to sort by.
+
+    - returns: `Results` with elements sorted by the given sort descriptors.
+    */
+    public func sorted<S: Sequence where S.Iterator.Element == SortDescriptor>
+                      (with sortDescriptors: S) -> Results<Element> {
+        return base.sorted(with: sortDescriptors)
+    }
+
+
+    // MARK: Aggregate Operations
+
+    /**
+    Returns the minimum value of the given property.
+
+    - warning: Only names of properties of a type conforming to the `MinMaxType` protocol can be used.
+
+    - parameter property: The name of a property conforming to `MinMaxType` to look for a minimum on.
+
+    - returns: The minimum value for the property amongst objects in the collection, or `nil` if the
+               collection is empty.
+    */
+    public func minimumValue<U: MinMaxType>(ofProperty property: String) -> U? {
+        return base.minimumValue(ofProperty: property)
+    }
+
+    /**
+    Returns the maximum value of the given property.
+
+    - warning: Only names of properties of a type conforming to the `MinMaxType` protocol can be used.
+
+    - parameter property: The name of a property conforming to `MinMaxType` to look for a maximum on.
+
+    - returns: The maximum value for the property amongst objects in the collection, or `nil` if the
+               collection is empty.
+    */
+    public func maximumValue<U: MinMaxType>(ofProperty property: String) -> U? {
+        return base.maximumValue(ofProperty: property)
+    }
+
+    /**
+    Returns the sum of the given property for objects in the collection.
+
+    - warning: Only names of properties of a type conforming to the `AddableType` protocol can be used.
+
+    - parameter property: The name of a property conforming to `AddableType` to calculate sum on.
+
+    - returns: The sum of the given property over all objects in the collection.
+    */
+    public func sum<U: AddableType>(ofProperty property: String) -> U { return base.sum(ofProperty: property) }
+
+    /**
+    Returns the average of the given property for objects in the collection.
+
+    - warning: Only names of properties of a type conforming to the `AddableType` protocol can be used.
+
+    - parameter property: The name of a property conforming to `AddableType` to calculate average on.
+
+    - returns: The average of the given property over all objects in the collection, or `nil` if the
+               collection is empty.
+    */
+    public func average<U: AddableType>(ofProperty property: String) -> U? { return base.average(ofProperty: property) }
+
+
+    // MARK: Sequence Support
+
+    /**
+    Returns the object at the given `index`.
+
+    - parameter index: The index.
+
+    - returns: The object at the given `index`.
+    */
+    public subscript(position: Int) -> T { return base[position] }
+
+    /// Returns a `RLMIterator` that yields successive elements in the collection.
+    public func makeIterator() -> RLMIterator<T> { return base.makeIterator() }
+
+
+    // MARK: Collection Support
+
+    /// The position of the first element in a non-empty collection.
+    /// Identical to endIndex in an empty collection.
+    public var startIndex: Int { return base.startIndex }
+
+    /// The collection's "past the end" position.
+    /// endIndex is not a valid argument to subscript, and is always reachable from startIndex by
+    /// zero or more applications of successor().
+    public var endIndex: Int { return base.endIndex }
+
+
+    // MARK: Key-Value Coding
+
+    /**
+    Returns an Array containing the results of invoking `valueForKey(_:)` using key on each of the collection's objects.
+
+    - parameter key: The name of the property.
+
+    - returns: Array containing the results of invoking `valueForKey(_:)` using key on each of the collection's objects.
+    */
+    public func value(forKey key: String) -> AnyObject? { return base.value(forKey: key) }
+
+    /**
+     Returns an Array containing the results of invoking `valueForKeyPath(_:)` using keyPath on each of the
+     collection's objects.
+
+     - parameter keyPath: The key path to the property.
+
+     - returns: Array containing the results of invoking `valueForKeyPath(_:)` using keyPath on each of the
+     collection's objects.
+     */
+    public func value(forKeyPath keyPath: String) -> AnyObject? { return base.value(forKeyPath: keyPath) }
+
+    /**
+    Invokes `setValue(_:forKey:)` on each of the collection's objects using the specified value and key.
+
+    - warning: This method can only be called during a write transaction.
+
+    - parameter value: The object value.
+    - parameter key:   The name of the property.
+    */
+    public func setValue(_ value: AnyObject?, forKey key: String) { base.setValue(value, forKey: key) }
+
+    // MARK: Notifications
+
+    /**
+     Register a block to be called each time the collection changes.
+
+     The block will be asynchronously called with the initial results, and then
+     called again after each write transaction which changes either any of the
+     objects in the collection, or which objects are in the collection.
+
+     At the time when the block is called, the collection object will be fully
+     evaluated and up-to-date, and as long as you do not perform a write
+     transaction on the same thread or explicitly call realm.refresh(),
+     accessing it will never perform blocking work.
+
+     Notifications are delivered via the standard run loop, and so can't be
+     delivered while the run loop is blocked by other activity. When
+     notifications can't be delivered instantly, multiple notifications may be
+     coalesced into a single notification. This can include the notification
+     with the initial collection. For example, the following code performs a write
+     transaction immediately after adding the notification block, so there is no
+     opportunity for the initial notification to be delivered first. As a
+     result, the initial notification will reflect the state of the Realm after
+     the write transaction.
+
+         let results = realm.objects(Dog)
+         print("dogs.count: \(dogs?.count)") // => 0
+         let token = dogs.addNotificationBlock { (changes: RealmCollectionChange) in
+             switch changes {
+                 case .Initial(let dogs):
+                     // Will print "dogs.count: 1"
+                     print("dogs.count: \(dogs.count)")
+                     break
+                 case .Update:
+                     // Will not be hit in this example
+                     break
+                 case .Error:
+                     break
+             }
+         }
+         try! realm.write {
+             let dog = Dog()
+             dog.name = "Rex"
+             person.dogs.append(dog)
+         }
+         // end of run loop execution context
+
+     You must retain the returned token for as long as you want updates to continue
+     to be sent to the block. To stop receiving updates, call stop() on the token.
+
+     - warning: This method cannot be called during a write transaction, or when
+                the source realm is read-only.
+
+     - parameter block: The block to be called with the evaluated collection and change information.
+     - returns: A token which must be held for as long as you want updates to be delivered.
+     */
+    public func addNotificationBlock(block: (RealmCollectionChange<AnyRealmCollection>) -> ())
+        -> NotificationToken { return base._addNotificationBlock(block: block) }
+
+    /// :nodoc:
+    public func _addNotificationBlock(block: (RealmCollectionChange<AnyRealmCollection>) -> ())
+        -> NotificationToken { return base._addNotificationBlock(block: block) }
+}
+
+
+// MARK: Unavailable
+
+extension AnyRealmCollection {
+    @available(*, unavailable, renamed:"isInvalidated")
+    public var invalidated : Bool { fatalError() }
+
+    @available(*, unavailable, renamed:"indexOfObject(for:)")
+    public func index(of predicate: Predicate) -> Int? { fatalError() }
+
+    @available(*, unavailable, renamed:"indexOfObject(for:_:)")
+    public func index(of predicateFormat: String, _ args: AnyObject...) -> Int? { fatalError() }
+
+    @available(*, unavailable, renamed:"filter(using:)")
+    public func filter(_ predicate: Predicate) -> Results<T> { fatalError() }
+
+    @available(*, unavailable, renamed:"filter(using:_:)")
+    public func filter(_ predicateFormat: String, _ args: AnyObject...) -> Results<T> { fatalError() }
+
+    @available(*, unavailable, renamed:"sorted(onProperty:ascending:)")
+    public func sorted(_ property: String, ascending: Bool = true) -> Results<T> { fatalError() }
+
+    @available(*, unavailable, renamed:"sorted(with:)")
+    public func sorted<S: Sequence where S.Iterator.Element == SortDescriptor>(_ sortDescriptors: S) -> Results<T> {
+        fatalError()
+    }
+
+    @available(*, unavailable, renamed:"minimumValue(ofProperty:)")
+    public func min<U: MinMaxType>(_ property: String) -> U? { fatalError() }
+
+    @available(*, unavailable, renamed:"maximumValue(ofProperty:)")
+    public func max<U: MinMaxType>(_ property: String) -> U? { fatalError() }
+
+    @available(*, unavailable, renamed:"sum(ofProperty:)")
+    public func sum<U: AddableType>(_ property: String) -> U { fatalError() }
+
+    @available(*, unavailable, renamed:"average(ofProperty:)")
+    public func average<U: AddableType>(_ property: String) -> U? { fatalError() }
+}
+
+#else
+
+/**
+ An iterator for a `RealmCollectionType` instance.
+*/
+public final class RLMGenerator<T: Object>: GeneratorType {
+    private let generatorBase: NSFastGenerator
+
+    internal init(collection: RLMCollection) {
+        generatorBase = NSFastGenerator(collection)
+    }
+
+    /// Advance to the next element and return it, or `nil` if no next element exists.
+    public func next() -> T? { // swiftlint:disable:this valid_docs
+        let accessor = generatorBase.next() as! T?
+        if let accessor = accessor {
+            RLMInitializeSwiftAccessorGenerics(accessor)
+        }
+        return accessor
+    }
+}
+
+/**
+ A `RealmCollectionChange` value encapsulates information about changes to collections
+ that are reported by Realm notifications.
+
+ The change information is available in two formats: a simple array of row
+ indices in the collection for each type of change, and an array of index paths
+ in a requested section suitable for passing directly to `UITableView`'s batch
+ update methods.
+
+ The arrays of indices in the `.Update` case follow `UITableView`'s batching
+ conventions, and can be passed as-is to a table view's batch update functions after being converted to index paths.
+ For example, for a simple one-section table view, you can do the following:
+
+ ```swift
+ self.notificationToken = results.addNotificationBlock { changes in
+     switch changes {
+     case .Initial:
+         // Results are now populated and can be accessed without blocking the UI
+         self.tableView.reloadData()
+         break
+     case .Update(_, let deletions, let insertions, let modifications):
+         // Query results have changed, so apply them to the TableView
+         self.tableView.beginUpdates()
+         self.tableView.insertRowsAtIndexPaths(insertions.map { NSIndexPath(forRow: $0, inSection: 0) },
+             withRowAnimation: .Automatic)
+         self.tableView.deleteRowsAtIndexPaths(deletions.map { NSIndexPath(forRow: $0, inSection: 0) },
+             withRowAnimation: .Automatic)
+         self.tableView.reloadRowsAtIndexPaths(modifications.map { NSIndexPath(forRow: $0, inSection: 0) },
+             withRowAnimation: .Automatic)
+         self.tableView.endUpdates()
+         break
+     case .Error(let err):
+         // An error occurred while opening the Realm file on the background worker thread
+         fatalError("\(err)")
+         break
+     }
+ }
+ ```
+ */
+public enum RealmCollectionChange<T> {
+    /// `.Initial` indicates that the initial run of the query has completed (if applicable), and the
+    /// collection can now be used without performing any blocking work.
+    case Initial(T)
+
+    /// `.Update` indicates that a write transaction has been committed which either changed which objects
+    /// are in the collection, and/or modified one or more of the objects in the collection.
+    ///
+    /// All three of the change arrays are always sorted in ascending order.
+    ///
+    /// - parameter deletions:     The indices in the previous version of the collection
+    ///                            which were removed from this one.
+    /// - parameter insertions:    The indices in the new collection which were added in
+    ///                            this version.
+    /// - parameter modifications: The indices of the objects in the new collection which
+    ///                            were modified in this version.
+    case Update(T, deletions: [Int], insertions: [Int], modifications: [Int])
+
+    /// If an error occurs, notification blocks are called one time with a
+    /// `.Error` result and an `NSError` containing details about the error. This can only currently happen if the
+    /// Realm is opened on a background worker thread to calculate the change set.
+    case Error(NSError)
+
+    static func fromObjc(value: T, change: RLMCollectionChange?, error: NSError?) -> RealmCollectionChange {
+        if let error = error {
+            return .Error(error)
+        }
+        if let change = change {
+            return .Update(value,
+                deletions: change.deletions as! [Int],
+                insertions: change.insertions as! [Int],
+                modifications: change.modifications as! [Int])
+        }
+        return .Initial(value)
+    }
+}
+
+/**
+ A homogenous collection of `Object`s which can be retrieved, filtered, sorted,
+ and operated upon.
+*/
+public protocol RealmCollectionType: CollectionType, CustomStringConvertible {
+
+    /// The type of the objects contained in the collection.
+    associatedtype Element: Object
+
+
+    // MARK: Properties
+
+    /// The Realm which manages the collection, or `nil` for unmanaged collections.
+    var realm: Realm? { get }
+
+    /// Indicates if the collection can no longer be accessed.
+    ///
+    /// The collection can no longer be accessed if `invalidate` is called on the `Realm` that manages the collection.
+    var invalidated: Bool { get }
+
+    /// The number of objects in the collection.
+    var count: Int { get }
+
+    /// A human-readable description of the objects contained in the collection.
+    var description: String { get }
+
+
+    // MARK: Index Retrieval
+
+    /**
+     Returns the index of an object in the collection, or `nil` if the object is not present.
+
+     - parameter object: An object.
+     */
+    func indexOf(object: Element) -> Int?
+
+    /**
+     Returns the index of the first object matching the predicate, or `nil` if no objects match.
+
+     - parameter predicate: The predicate to use to filter the objects.
+     */
+    func indexOf(predicate: NSPredicate) -> Int?
+
+    /**
+     Returns the index of the first object matching the predicate, or `nil` if no objects match.
+
+     - parameter predicateFormat: A predicate format string, optionally followed by a variable number of arguments.
+     */
+    func indexOf(predicateFormat: String, _ args: AnyObject...) -> Int?
+
+
+    // MARK: Filtering
+
+    /**
+     Returns all objects matching the given predicate in the collection.
+
+     - parameter predicateFormat: A predicate format string, optionally followed by a variable number of arguments.
+
+     - returns: A `Results` containing objects that match the given predicate.
+     */
+    func filter(predicateFormat: String, _ args: AnyObject...) -> Results<Element>
+
+    /**
+     Returns all objects matching the given predicate in the collection.
+
+     - parameter predicate: The predicate to use to filter the objects.
+
+     - returns: A `Results` containing objects that match the given predicate.
+     */
+    func filter(predicate: NSPredicate) -> Results<Element>
+
+
+    // MARK: Sorting
+
+    /**
+     Returns a `Results` containing the objects in the collection, but sorted.
+
+     Objects are sorted based on the values of the given property. For example, to sort a collection of `Student`s from
+     youngest to oldest based on their `age` property, you might call `students.sorted("age", ascending: true)`.
+
+     - warning: Collections may only be sorted by properties of boolean, `NSDate`, single and double-precision floating
+                point, integer, and string types.
+
+     - parameter property:  The name of the property to sort by.
+     - parameter ascending: The direction to sort in.
+     */
+    func sorted(property: String, ascending: Bool) -> Results<Element>
+
+    /**
+     Returns a `Results` containing the objects in the collection, but sorted.
+
+     - warning: Collections may only be sorted by properties of boolean, `NSDate`, single and double-precision floating
+                point, integer, and string types.
+
+     - see: `sorted(_:ascending:)`
+
+     - parameter sortDescriptors: A sequence of `SortDescriptor`s to sort by.
+     */
+    func sorted<S: SequenceType where S.Generator.Element == SortDescriptor>(sortDescriptors: S) -> Results<Element>
+
+
+    // MARK: Aggregate Operations
+
+    /**
+     Returns the minimum (lowest) value of the given property among all the objects represented by the collection.
+
+     - warning: Only a property whose type conforms to the `MinMaxType` protocol can be specified.
+
+     - parameter property: The name of a property whose minimum value is desired.
+
+     - returns: The minimum value of the property, or `nil` if the collection is empty.
+     */
+    func min<U: MinMaxType>(property: String) -> U?
+
+    /**
+     Returns the maximum (highest) value of the given property among all the objects represented by the collection.
+
+     - warning: Only a property whose type conforms to the `MinMaxType` protocol can be specified.
+
+     - parameter property: The name of a property whose minimum value is desired.
+
+     - returns: The maximum value of the property, or `nil` if the collection is empty.
+     */
+    func max<U: MinMaxType>(property: String) -> U?
+
+    /**
+     Returns the sum of the values of a given property over all the objects represented by the collection.
+
+     - warning: Only a property whose type conforms to the `AddableType` protocol can be specified.
+
+     - parameter property: The name of a property whose values should be summed.
+
+     - returns: The sum of the given property.
+     */
+    func sum<U: AddableType>(property: String) -> U
+
+    /**
+     Returns the average value of a given property over all the objects represented by the collection.
+
+     - warning: Only the name of a property whose type conforms to the `AddableType` protocol can be specified.
+
+     - parameter property: The name of a property whose average value should be calculated.
+
+     - returns: The average value of the given property, or `nil` if the collection is empty.
+     */
+    func average<U: AddableType>(property: String) -> U?
+
+
+    // MARK: Key-Value Coding
+
+    /**
+     Returns an `Array` containing the results of invoking `valueForKey(_:)` with `key` on each of the collection's
+     objects.
+
+     - parameter key: The name of the property whose values are desired.
+     */
+    func valueForKey(key: String) -> AnyObject?
+
+    /**
+     Returns an `Array` containing the results of invoking `valueForKeyPath(_:)` with `keyPath` on each of the
+     collection's objects.
+
+     - parameter keyPath: The key path to the property whose values are desired.
+     */
+    func valueForKeyPath(keyPath: String) -> AnyObject?
+
+    /**
+     Invokes `setValue(_:forKey:)` on each of the collection's objects using the specified `value` and `key`.
+
+     - warning: This method may only be called during a write transaction.
+
+     - parameter value: The object value.
+     - parameter key:   The name of the property whose value should be set on each object.
+     */
+    func setValue(value: AnyObject?, forKey key: String)
+
+    // MARK: Notifications
+
+    /**
+     Registers a block to be called each time the collection changes.
+
+     The block will be asynchronously called with the initial results, and then
+     called again after each write transaction which changes either any of the
+     objects in the collection, or which objects are in the collection.
+
+     The `change` parameter that is passed to the block reports, in the form of indices within the
+     collection, which of the objects were added, removed, or modified during each write transaction. See the
+     `RealmCollectionChange` documentation for more information on the change information supplied and an example of how
+     to use it to update a `UITableView`.
+
+     At the time when the block is called, the collection will be fully
+     evaluated and up-to-date, and as long as you do not perform a write
+     transaction on the same thread or explicitly call `realm.refresh()`,
+     accessing it will never perform blocking work.
+
+     Notifications are delivered via the standard run loop, and so can't be
+     delivered while the run loop is blocked by other activity. When
+     notifications can't be delivered instantly, multiple notifications may be
+     coalesced into a single notification. This can include the notification
+     with the initial collection. For example, the following code performs a write
+     transaction immediately after adding the notification block, so there is no
+     opportunity for the initial notification to be delivered first. As a
+     result, the initial notification will reflect the state of the Realm after
+     the write transaction.
+
+     ```swift
+     let results = realm.objects(Dog.self)
+     print("dogs.count: \(dogs?.count)") // => 0
+     let token = dogs.addNotificationBlock { changes in
+         switch changes {
+             case .Initial(let dogs):
+                 // Will print "dogs.count: 1"
+                 print("dogs.count: \(dogs.count)")
+                 break
+             case .Update:
+                 // Will not be hit in this example
+                 break
+             case .Error:
+                 break
+         }
+     }
+     try! realm.write {
+         let dog = Dog()
+         dog.name = "Rex"
+         person.dogs.append(dog)
+     }
+     // end of run loop execution context
+     ```
+
+     You must retain the returned token for as long as you want updates to be sent to the block. To stop receiving
+     updates, call `stop()` on the token.
+
+     - warning: This method cannot be called during a write transaction, or when
+                the containing Realm is read-only.
+
+     - parameter block: The block to be called whenever a change occurs.
+     - returns: A token which must be retained for as long as you want updates to be delivered.
+     */
+    func addNotificationBlock(block: (RealmCollectionChange<Self>) -> Void) -> NotificationToken
+
+    /// :nodoc:
+    func _addNotificationBlock(block: (RealmCollectionChange<AnyRealmCollection<Element>>) -> Void) -> NotificationToken
+}
+
+private class _AnyRealmCollectionBase<T: Object> {
+    typealias Wrapper = AnyRealmCollection<Element>
+    typealias Element = T
+    var realm: Realm? { fatalError() }
+    var invalidated: Bool { fatalError() }
+    var count: Int { fatalError() }
+    var description: String { fatalError() }
+    func indexOf(object: Element) -> Int? { fatalError() }
+    func indexOf(predicate: NSPredicate) -> Int? { fatalError() }
+    func indexOf(predicateFormat: String, _ args: AnyObject...) -> Int? { fatalError() }
+    func filter(predicateFormat: String, _ args: AnyObject...) -> Results<Element> { fatalError() }
+    func filter(predicate: NSPredicate) -> Results<Element> { fatalError() }
+    func sorted(property: String, ascending: Bool) -> Results<Element> { fatalError() }
+    func sorted<S: SequenceType where S.Generator.Element == SortDescriptor>(sortDescriptors: S) -> Results<Element> {
+        fatalError()
+    }
+    func min<U: MinMaxType>(property: String) -> U? { fatalError() }
+    func max<U: MinMaxType>(property: String) -> U? { fatalError() }
+    func sum<U: AddableType>(property: String) -> U { fatalError() }
+    func average<U: AddableType>(property: String) -> U? { fatalError() }
+    subscript(index: Int) -> Element { fatalError() }
+    func generate() -> RLMGenerator<T> { fatalError() }
+    var startIndex: Int { fatalError() }
+    var endIndex: Int { fatalError() }
+    func valueForKey(key: String) -> AnyObject? { fatalError() }
+    func valueForKeyPath(keyPath: String) -> AnyObject? { fatalError() }
+    func setValue(value: AnyObject?, forKey key: String) { fatalError() }
+    func _addNotificationBlock(block: (RealmCollectionChange<Wrapper>) -> Void)
+        -> NotificationToken { fatalError() }
+}
+
+private final class _AnyRealmCollection<C: RealmCollectionType>: _AnyRealmCollectionBase<C.Element> {
+    let base: C
+    init(base: C) {
+        self.base = base
+    }
+
+    // TODO (az): copyedit private docstrings
+    // MARK: Properties
+
+    /// The Realm the objects in this collection belong to, or `nil` if the
+    /// collection's owning object does not belong to a realm (the collection is
+    /// unmanaged).
+    override var realm: Realm? { return base.realm }
+
+    /// Indicates if the collection can no longer be accessed.
+    ///
+    /// The collection can no longer be accessed if `invalidate` is called on the containing `Realm`.
+    override var invalidated: Bool { return base.invalidated }
+
+    /// Returns the number of objects in this collection.
+    override var count: Int { return base.count }
+
+    /// Returns a human-readable description of the objects contained in this collection.
+    override var description: String { return base.description }
+
+
+    // MARK: Index Retrieval
+
+    /**
+    Returns the index of the given object, or `nil` if the object is not in the collection.
+
+    - parameter object: The object whose index is being queried.
+    */
+    override func indexOf(object: C.Element) -> Int? { return base.indexOf(object) }
+
+    /**
+    Returns the index of the first object matching the given predicate, or `nil` no objects match.
+
+    - parameter predicate: The `NSPredicate` used to filter the objects.
+    */
+    override func indexOf(predicate: NSPredicate) -> Int? { return base.indexOf(predicate) }
+
+    /**
+    Returns the index of the first object matching the given predicate, or `nil` if no objects match.
+
+    - parameter predicateFormat: A predicate format string, optionally followed by a variable number
+                                 of arguments.
+    */
+    override func indexOf(predicateFormat: String, _ args: AnyObject...) -> Int? {
+        return base.indexOf(NSPredicate(format: predicateFormat, argumentArray: args))
+    }
+
+    // MARK: Filtering
+
+    /**
+    Returns a `Results` containing collection elements that match the given predicate.
+
+     - parameter predicateFormat: A predicate format string, optionally followed by a variable number
+                                  of arguments.
+
+    - returns: `Results` containing collection elements that match the given predicate.
+    */
+    override func filter(predicateFormat: String, _ args: AnyObject...) -> Results<C.Element> {
+        return base.filter(NSPredicate(format: predicateFormat, argumentArray: args))
+    }
+
+    /**
+    Returns a `Results` containing collection elements that match the given predicate.
+
+    - parameter predicate: The predicate to use to filter the objects.
+
+    - returns: `Results` containing collection elements that match the given predicate.
+    */
+    override func filter(predicate: NSPredicate) -> Results<C.Element> { return base.filter(predicate) }
+
+
+    // MARK: Sorting
+
+    /**
+     Returns a `Results` containing the objects in the collection, but sorted.
+
+     Objects are sorted based on the values of the given property. For example, to sort a collection of `Student`s from
+     youngest to oldest based on their `age` property, you might call `students.sorted("age", ascending: true)`.
+
+     - warning: Collections may only be sorted by properties of boolean, `NSDate`, single and double-precision floating
+                point, integer, and string types.
+
+     - parameter property:  The name of the property to sort by.
+     - parameter ascending: The direction to sort in.
+     */
+    override func sorted(property: String, ascending: Bool) -> Results<C.Element> {
+        return base.sorted(property, ascending: ascending)
+    }
+
+    /**
+     Returns a `Results` containing the objects in the collection, but sorted.
+
+     - warning: Collections may only be sorted by properties of boolean, `NSDate`, single and double-precision floating
+                point, integer, and string types.
+
+     - see: `sorted(_:ascending:)`
+
+     - parameter sortDescriptors: A sequence of `SortDescriptor`s to sort by.
+     */
+    override func sorted<S: SequenceType where S.Generator.Element == SortDescriptor>
+                        (sortDescriptors: S) -> Results<C.Element> {
+        return base.sorted(sortDescriptors)
+    }
+
+
+    // MARK: Aggregate Operations
+
+    /**
+    Returns the minimum value of the given property.
+
+    - warning: Only names of properties of a type conforming to the `MinMaxType` protocol can be used.
+
+    - parameter property: The name of a property conforming to `MinMaxType` to look for a minimum on.
+
+    - returns: The minimum value of the property amongst objects in the collection, or `nil` if the
+               collection is empty.
+    */
+    override func min<U: MinMaxType>(property: String) -> U? { return base.min(property) }
+
+    /**
+    Returns the maximum value of the given property.
+
+    - warning: Only names of properties of a type conforming to the `MinMaxType` protocol can be used.
+
+    - parameter property: The name of a property conforming to `MinMaxType` to look for a maximum on.
+
+    - returns: The maximum value of the property amongst objects in the collection, or `nil` if the
+               collection is empty.
+    */
+    override func max<U: MinMaxType>(property: String) -> U? { return base.max(property) }
+
+    /**
+    Returns the sum of the given property for objects in the collection.
+
+    - warning: Only names of properties of a type conforming to the `AddableType` protocol can be used.
+
+    - parameter property: The name of a property conforming to `AddableType` to calculate sum on.
+
+    - returns: The sum of the given property over all objects in the collection.
+    */
+    override func sum<U: AddableType>(property: String) -> U { return base.sum(property) }
+
+    /**
+    Returns the average of the given property for objects in the collection.
+
+    - warning: Only names of properties of a type conforming to the `AddableType` protocol can be used.
+
+    - parameter property: The name of a property conforming to `AddableType` to calculate average on.
+
+    - returns: The average of the given property over all objects in the collection, or `nil` if the
+               collection is empty.
+    */
+    override func average<U: AddableType>(property: String) -> U? { return base.average(property) }
+
+
+    // MARK: Sequence Support
+
+    /**
+    Returns the object at the given `index`.
+
+    - parameter index: The index.
+
+    - returns: The object at the given `index`.
+    */
+    override subscript(index: Int) -> C.Element {
+        // FIXME: it should be possible to avoid this force-casting
+        return unsafeBitCast(base[index as! C.Index], C.Element.self)
+    }
+
+    /// Returns an `RLMGenerator` that yields successive elements in the collection.
+    override func generate() -> RLMGenerator<Element> {
+        // FIXME: it should be possible to avoid this force-casting
+        return base.generate() as! RLMGenerator<Element>
+    }
+
+
+    // MARK: Collection Support
+
+    /// The position of the first element in a non-empty collection.
+    /// Identical to endIndex in an empty collection.
+    override var startIndex: Int {
+        // FIXME: it should be possible to avoid this force-casting
+        return base.startIndex as! Int
+    }
+
+    /// The collection's "past the end" position.
+    /// endIndex is not a valid argument to subscript, and is always reachable from startIndex by
+    /// zero or more applications of successor().
+    override var endIndex: Int {
+        // FIXME: it should be possible to avoid this force-casting
+        return base.endIndex as! Int
+    }
+
+
+    // MARK: Key-Value Coding
+
+    /**
+    Returns an Array containing the results of invoking `valueForKey(_:)` using key on each of the collection's objects.
+
+    - parameter key: The name of the property.
+
+    - returns: Array containing the results of invoking `valueForKey(_:)` using key on each of the collection's objects.
+    */
+    override func valueForKey(key: String) -> AnyObject? { return base.valueForKey(key) }
+
+    /**
+     Returns an Array containing the results of invoking `valueForKeyPath(_:)` using keyPath on each of the
+     collection's objects.
+
+     - parameter keyPath: The key path to the property.
+
+     - returns: Array containing the results of invoking `valueForKeyPath(_:)` using keyPath on each of the
+       collection's objects.
+     */
+    override func valueForKeyPath(keyPath: String) -> AnyObject? { return base.valueForKeyPath(keyPath) }
+
+    /**
+    Invokes `setValue(_:forKey:)` on each of the collection's objects using the specified value and key.
+
+    - warning: This method can only be called during a write transaction.
+
+    - parameter value: The object value.
+    - parameter key:   The name of the property.
+    */
+    override func setValue(value: AnyObject?, forKey key: String) { base.setValue(value, forKey: key) }
+
+    // MARK: Notifications
+
+    /// :nodoc:
+    override func _addNotificationBlock(block: (RealmCollectionChange<Wrapper>) -> Void)
+        -> NotificationToken { return base._addNotificationBlock(block) }
+}
+
+/**
+ A type-erased `RealmCollectionType`.
+
+ Instances of `RealmCollectionType` forward operations to an opaque underlying collection having the same `Element`
+ type.
+ */
+public final class AnyRealmCollection<T: Object>: RealmCollectionType {
+
+    /// The type of the objects contained in the collection.
+    public typealias Element = T
+    private let base: _AnyRealmCollectionBase<T>
+
+    /// Creates an `AnyRealmCollection` wrapping `base`.
+    public init<C: RealmCollectionType where C.Element == T>(_ base: C) {
+        self.base = _AnyRealmCollection(base: base)
+    }
+
+    // MARK: Properties
+
+    /// The Realm which manages this collection, or `nil` if the collection is unmanaged.
+    public var realm: Realm? { return base.realm }
+
+    /// Indicates if the collection can no longer be accessed.
+    ///
+    /// The collection can no longer be accessed if `invalidate` is called on the containing `realm`.
+    public var invalidated: Bool { return base.invalidated }
+
+    /// The number of objects in the collection.
+    public var count: Int { return base.count }
+
+    /// A human-readable description of the objects contained in the collection.
+    public var description: String { return base.description }
+
+
+    // MARK: Index Retrieval
+
+    /**
+     Returns the index of the given object, or `nil` if the object is not in the collection.
+
+     - parameter object: An object.
+     */
+    public func indexOf(object: Element) -> Int? { return base.indexOf(object) }
+
+    /**
+     Returns the index of the first object matching the given predicate, or `nil` if no objects match.
+
+     - parameter predicate: The predicate with which to filter the objects.
+     */
+    public func indexOf(predicate: NSPredicate) -> Int? { return base.indexOf(predicate) }
+
+    /**
+     Returns the index of the first object matching the given predicate, or `nil` if no objects match.
+
+     - parameter predicateFormat: A predicate format string, optionally followed by a variable number of arguments.
+     */
+    public func indexOf(predicateFormat: String, _ args: AnyObject...) -> Int? {
+        return base.indexOf(NSPredicate(format: predicateFormat, argumentArray: args))
+    }
+
+    // MARK: Filtering
+
+    /**
+     Returns a `Results` containing all objects matching the given predicate in the collection.
+
+     - parameter predicateFormat: A predicate format string, optionally followed by a variable number of arguments.
+     */
+    public func filter(predicateFormat: String, _ args: AnyObject...) -> Results<Element> {
+        return base.filter(NSPredicate(format: predicateFormat, argumentArray: args))
+    }
+
+    /**
+     Returns a `Results` containing all objects matching the given predicate in the collection.
+
+     - parameter predicate: The predicate with which to filter the objects.
+
+     - returns: A `Results` containing objects that match the given predicate.
+     */
+    public func filter(predicate: NSPredicate) -> Results<Element> { return base.filter(predicate) }
+
+
+    // MARK: Sorting
+
+    /**
+     Returns a `Results` containing the objects in the collection, but sorted.
+
+     Objects are sorted based on the values of the given property. For example, to sort a collection of `Student`s from
+     youngest to oldest based on their `age` property, you might call `students.sorted("age", ascending: true)`.
+
+     - warning: Collections may only be sorted by properties of boolean, `NSDate`, single and double-precision floating
+                point, integer, and string types.
+
+     - parameter property:  The name of the property to sort by.
+     - parameter ascending: The direction to sort in.
+     */
+    public func sorted(property: String, ascending: Bool) -> Results<Element> {
+        return base.sorted(property, ascending: ascending)
+    }
+
+    /**
+     Returns a `Results` containing the objects in the collection, but sorted.
+
+     - warning: Collections may only be sorted by properties of boolean, `NSDate`, single and double-precision floating
+                point, integer, and string types.
+
+     - see: `sorted(_:ascending:)`
+
+     - parameter sortDescriptors: A sequence of `SortDescriptor`s to sort by.
+     */
+    public func sorted<S: SequenceType where S.Generator.Element == SortDescriptor>
+                      (sortDescriptors: S) -> Results<Element> {
+        return base.sorted(sortDescriptors)
+    }
+
+
+    // MARK: Aggregate Operations
+
+    /**
+     Returns the minimum (lowest) value of the given property among all the objects represented by the collection.
+
+     - warning: Only a property whose type conforms to the `MinMaxType` protocol can be specified.
+
+     - parameter property: The name of a property whose minimum value is desired.
+
+     - returns: The minimum value of the property, or `nil` if the collection is empty.
+     */
+    public func min<U: MinMaxType>(property: String) -> U? { return base.min(property) }
+
+    /**
+     Returns the maximum (highest) value of the given property among all the objects represented by the collection.
+
+     - warning: Only a property whose type conforms to the `MinMaxType` protocol can be specified.
+
+     - parameter property: The name of a property whose minimum value is desired.
+
+     - returns: The maximum value of the property, or `nil` if the collection is empty.
+     */
+    public func max<U: MinMaxType>(property: String) -> U? { return base.max(property) }
+
+    /**
+     Returns the sum of the values of a given property over all the objects represented by the collection.
+
+     - warning: Only a property whose type conforms to the `AddableType` protocol can be specified.
+
+     - parameter property: The name of a property whose values should be summed.
+
+     - returns: The sum of the given property.
+     */
+    public func sum<U: AddableType>(property: String) -> U { return base.sum(property) }
+
+    /**
+     Returns the average value of a given property over all the objects represented by the collection.
+
+     - warning: Only the name of a property whose type conforms to the `AddableType` protocol can be specified.
+
+     - parameter property: The name of a property whose average value should be calculated.
+
+     - returns: The average value of the given property, or `nil` if the collection is empty.
+     */
+    public func average<U: AddableType>(property: String) -> U? { return base.average(property) }
+
+
+    // MARK: Sequence Support
+
+    /**
+     Returns the object at the given `index`.
+
+     - parameter index: The index.
+
+     - returns: The object at the given `index`.
+    */
+    public subscript(index: Int) -> T { return base[index] }
+
+    /// Returns an `RLMGenerator` that yields successive elements in the collection.
+    public func generate() -> RLMGenerator<T> { return base.generate() }
+
+
+    // MARK: Collection Support
+
+    /// The position of the first element in a non-empty collection.
+    /// Identical to `endIndex` in an empty collection.
+    public var startIndex: Int { return base.startIndex }
+
+    /// The collection's "past the end" position.
+    /// `endIndex` is not a valid argument to `subscript`, and is always reachable from `startIndex` by
+    /// zero or more applications of `successor()`.
+    public var endIndex: Int { return base.endIndex }
+
+
+    // MARK: Key-Value Coding
+
+    /**
+     Returns an `Array` containing the results of invoking `valueForKey(_:)` with `key` on each of the collection's
+     objects.
+
+     - parameter key: The name of the property whose values are desired.
+
+     - returns: An `Array` containing the results.
+     */
+    public func valueForKey(key: String) -> AnyObject? { return base.valueForKey(key) }
+
+    /**
+     Returns an `Array` containing the results of invoking `valueForKeyPath(_:)` with `keyPath` on each of the
+     collection's objects.
+
+     - parameter keyPath: The key path to the property whose values are desired.
+
+     - returns: An `Array` containing the results.
+     */
+    public func valueForKeyPath(keyPath: String) -> AnyObject? { return base.valueForKeyPath(keyPath) }
+
+    /**
+     Invokes `setValue(_:forKey:)` on each of the collection's objects using the specified `value` and `key`.
+
+     - warning: This method may only be called during a write transaction.
+
+     - parameter value: The value to set the property to.
+     - parameter key:   The name of the property whose value should be set on each object.
+     */
+    public func setValue(value: AnyObject?, forKey key: String) { base.setValue(value, forKey: key) }
+
+    // MARK: Notifications
+
+    /**
+     Registers a block to be called each time the collection changes.
+
+     The block will be asynchronously called with the initial results, and then
+     called again after each write transaction which changes either any of the
+     objects in the collection, or which objects are in the collection.
+
+     The `change` parameter that is passed to the block reports, in the form of indices within the
+     collection, which of the objects were added, removed, or modified during each write transaction. See the
+     `RealmCollectionChange` documentation for more information on the change information supplied and an example of how
+     to use it to update a `UITableView`.
+
+     At the time when the block is called, the collection will be fully
+     evaluated and up-to-date, and as long as you do not perform a write
+     transaction on the same thread or explicitly call `realm.refresh()`,
+     accessing it will never perform blocking work.
+
+     Notifications are delivered via the standard run loop, and so can't be
+     delivered while the run loop is blocked by other activity. When
+     notifications can't be delivered instantly, multiple notifications may be
+     coalesced into a single notification. This can include the notification
+     with the initial collection. For example, the following code performs a write
+     transaction immediately after adding the notification block, so there is no
+     opportunity for the initial notification to be delivered first. As a
+     result, the initial notification will reflect the state of the Realm after
+     the write transaction.
+
+     ```swift
+     let results = realm.objects(Dog.self)
+     print("dogs.count: \(dogs?.count)") // => 0
+     let token = dogs.addNotificationBlock { changes in
+         switch changes {
+             case .Initial(let dogs):
+                 // Will print "dogs.count: 1"
+                 print("dogs.count: \(dogs.count)")
+                 break
+             case .Update:
+                 // Will not be hit in this example
+                 break
+             case .Error:
+                 break
+         }
+     }
+     try! realm.write {
+         let dog = Dog()
+         dog.name = "Rex"
+         person.dogs.append(dog)
+     }
+     // end of run loop execution context
+     ```
+
+     You must retain the returned token for as long as you want updates to be sent to the block. To stop receiving
+     updates, call `stop()` on the token.
+
+     - warning: This method cannot be called during a write transaction, or when
+                the containing Realm is read-only.
+
+     - parameter block: The block to be called whenever a change occurs.
+     - returns: A token which must be retained for as long as you want updates to be delivered.
+     */
+    public func addNotificationBlock(block: (RealmCollectionChange<AnyRealmCollection>) -> ())
+        -> NotificationToken { return base._addNotificationBlock(block) }
+
+    /// :nodoc:
+    public func _addNotificationBlock(block: (RealmCollectionChange<AnyRealmCollection>) -> ())
+        -> NotificationToken { return base._addNotificationBlock(block) }
+}
+
+#endif
diff --git a/Pods/RealmSwift/RealmSwift/RealmConfiguration.swift b/Pods/RealmSwift/RealmSwift/RealmConfiguration.swift
new file mode 100644
index 0000000..38914ff
--- /dev/null
+++ b/Pods/RealmSwift/RealmSwift/RealmConfiguration.swift
@@ -0,0 +1,400 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2015 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+import Foundation
+import Realm
+import Realm.Private
+
+#if swift(>=3.0)
+
+extension Realm {
+    /**
+    A `Realm.Configuration` is used to describe the different options used to
+    create a `Realm` instance.
+
+    `Realm.Configuration` instances are just plain Swift structs, and unlike
+    `Realm` and `Object`s can be freely shared between threads. Creating
+    configuration objects for class subsets (by setting the `objectTypes`
+    property) can be expensive, and so you will normally want to cache and reuse
+    a single configuration object for each distinct configuration that you are
+    using rather than creating a new one each time you open a `Realm`.
+    */
+    public struct Configuration {
+
+        // MARK: Default Configuration
+
+        /// Returns the default Realm.Configuration used to create Realms when no other
+        /// configuration is explicitly specified (i.e. `Realm()`).
+        public static var defaultConfiguration: Configuration {
+            get {
+                return fromRLMRealmConfiguration(rlmConfiguration: RLMRealmConfiguration.default())
+            }
+            set {
+                RLMRealmConfiguration.setDefault(newValue.rlmConfiguration)
+            }
+        }
+
+        // MARK: Initialization
+
+        /**
+        Initializes a `Realm.Configuration`, suitable for creating new `Realm` instances.
+
+        - parameter fileURL:            The local URL to the realm file.
+        - parameter inMemoryIdentifier: A string used to identify a particular in-memory Realm.
+        - parameter encryptionKey:      64-byte key to use to encrypt the data.
+        - parameter readOnly:           Whether the Realm is read-only (must be true for read-only files).
+        - parameter schemaVersion:      The current schema version.
+        - parameter migrationBlock:     The block which migrates the Realm to the current version.
+        - parameter deleteRealmIfMigrationNeeded: If `true`, recreate the Realm file with the provided
+                                                  schema if a migration is required.
+        - parameter objectTypes:        The subset of `Object` subclasses persisted in the Realm.
+        */
+        public init(fileURL: URL? = URL(fileURLWithPath: RLMRealmPathForFile("default.realm"), isDirectory: false),
+            inMemoryIdentifier: String? = nil,
+            encryptionKey: Data? = nil,
+            readOnly: Bool = false,
+            schemaVersion: UInt64 = 0,
+            migrationBlock: MigrationBlock? = nil,
+            deleteRealmIfMigrationNeeded: Bool = false,
+            objectTypes: [Object.Type]? = nil) {
+                self.fileURL = fileURL
+                if inMemoryIdentifier != nil {
+                    self.inMemoryIdentifier = inMemoryIdentifier
+                }
+                self.encryptionKey = encryptionKey
+                self.readOnly = readOnly
+                self.schemaVersion = schemaVersion
+                self.migrationBlock = migrationBlock
+                self.deleteRealmIfMigrationNeeded = deleteRealmIfMigrationNeeded
+                self.objectTypes = objectTypes
+        }
+
+        // MARK: Configuration Properties
+
+        /// The local URL to the realm file.
+        /// Mutually exclusive with `inMemoryIdentifier`.
+        public var fileURL: URL? {
+            set {
+                _inMemoryIdentifier = nil
+                _path = newValue?.path
+            }
+            get {
+                return _path.map { URL(fileURLWithPath: $0) }
+            }
+        }
+
+        private var _path: String?
+
+        /// A string used to identify a particular in-memory Realm.
+        /// Mutually exclusive with `path`.
+        public var inMemoryIdentifier: String? {
+            set {
+                _path = nil
+                _inMemoryIdentifier = newValue
+            }
+            get {
+                return _inMemoryIdentifier
+            }
+        }
+
+        private var _inMemoryIdentifier: String? = nil
+
+        /// 64-byte key to use to encrypt the data.
+        public var encryptionKey: Data? = nil
+
+        /// Whether the Realm is read-only (must be true for read-only files).
+        public var readOnly: Bool = false
+
+        /// The current schema version.
+        public var schemaVersion: UInt64 = 0
+
+        /// The block which migrates the Realm to the current version.
+        public var migrationBlock: MigrationBlock? = nil
+
+        /**
+        Recreate the Realm file with the provided schema if a migration is required.
+        This is the case when the stored schema differs from the provided schema or
+        the stored schema version differs from the version on this configuration.
+        This deletes the file if a migration would otherwise be required or run.
+
+        - note: This doesn't disable file format migrations.
+        */
+        public var deleteRealmIfMigrationNeeded: Bool = false
+
+        /// The classes persisted in the Realm.
+        public var objectTypes: [Object.Type]? {
+            set {
+                self.customSchema = newValue.map { RLMSchema(objectClasses: $0) }
+            }
+            get {
+                return self.customSchema.map { $0.objectSchema.map { $0.objectClass as! Object.Type } }
+            }
+        }
+
+        /// A custom schema to use for the Realm.
+        private var customSchema: RLMSchema? = nil
+
+        /// Allows to disable automatic format upgrades when accessing the Realm.
+        internal var disableFormatUpgrade: Bool = false
+
+        // MARK: Private Methods
+
+        internal var rlmConfiguration: RLMRealmConfiguration {
+            let configuration = RLMRealmConfiguration()
+            if let fileURL = fileURL {
+                configuration.fileURL = fileURL
+            } else if let inMemoryIdentifier = inMemoryIdentifier {
+                configuration.inMemoryIdentifier = inMemoryIdentifier
+            } else {
+                fatalError("A Realm Configuration must specify a path or an in-memory identifier.")
+            }
+            configuration.encryptionKey = self.encryptionKey
+            configuration.readOnly = self.readOnly
+            configuration.schemaVersion = self.schemaVersion
+            configuration.migrationBlock = self.migrationBlock.map { accessorMigrationBlock($0) }
+            configuration.deleteRealmIfMigrationNeeded = self.deleteRealmIfMigrationNeeded
+            configuration.customSchema = self.customSchema
+            configuration.disableFormatUpgrade = self.disableFormatUpgrade
+            return configuration
+        }
+
+        internal static func fromRLMRealmConfiguration(rlmConfiguration: RLMRealmConfiguration) -> Configuration {
+            var configuration = Configuration()
+            configuration._path = rlmConfiguration.fileURL?.path
+            configuration._inMemoryIdentifier = rlmConfiguration.inMemoryIdentifier
+            configuration.encryptionKey = rlmConfiguration.encryptionKey
+            configuration.readOnly = rlmConfiguration.readOnly
+            configuration.schemaVersion = rlmConfiguration.schemaVersion
+            configuration.migrationBlock = rlmConfiguration.migrationBlock.map { rlmMigration in
+                return { migration, schemaVersion in
+                    rlmMigration(migration.rlmMigration, schemaVersion)
+                }
+            }
+            configuration.deleteRealmIfMigrationNeeded = rlmConfiguration.deleteRealmIfMigrationNeeded
+            configuration.customSchema = rlmConfiguration.customSchema
+            configuration.disableFormatUpgrade = rlmConfiguration.disableFormatUpgrade
+            return configuration
+        }
+    }
+}
+
+// MARK: CustomStringConvertible
+
+extension Realm.Configuration: CustomStringConvertible {
+    /// Returns a human-readable description of the configuration.
+    public var description: String {
+        return gsub(pattern: "\\ARLMRealmConfiguration",
+                    template: "Realm.Configuration",
+                    string: rlmConfiguration.description) ?? ""
+    }
+}
+
+#else
+
+extension Realm {
+    /**
+     A `Configuration` instance describes the different options used to
+     create an instance of a Realm.
+
+     `Configuration` instances are just plain Swift structs. Unlike `Realm`s
+     and `Object`s, they can be freely shared between threads as long as you do not
+     mutate them.
+
+     Creating configuration values for class subsets (by setting the
+     `objectClasses` property) can be expensive. Because of this, you will normally want to
+     cache and reuse a single configuration value for each distinct configuration rather than
+     creating a new value each time you open a Realm.
+     */
+    public struct Configuration {
+
+        // MARK: Default Configuration
+
+        /// Returns the default configuration used to create Realms when no other
+        /// configuration is explicitly specified (i.e. `Realm()`).
+        public static var defaultConfiguration: Configuration {
+            get {
+                return fromRLMRealmConfiguration(RLMRealmConfiguration.defaultConfiguration())
+            }
+            set {
+                RLMRealmConfiguration.setDefaultConfiguration(newValue.rlmConfiguration)
+            }
+        }
+
+        // MARK: Initialization
+
+        /**
+        Initializes a `Realm.Configuration`, suitable for creating new `Realm` instances.
+
+        - parameter fileURL:            The local URL to the Realm file.
+        - parameter inMemoryIdentifier: A string used to identify a particular in-memory Realm.
+        - parameter encryptionKey:      An optional 64-byte key to use to encrypt the data.
+        - parameter readOnly:           Whether the Realm is read-only (must be true for read-only files).
+        - parameter schemaVersion:      The current schema version.
+        - parameter migrationBlock:     The block which migrates the Realm to the current version.
+        - parameter deleteRealmIfMigrationNeeded: If `true`, recreate the Realm file with the provided
+                                                  schema if a migration is required.
+        - parameter objectTypes:        The subset of `Object` subclasses managed by the Realm.
+        */
+        public init(fileURL: NSURL? = NSURL(fileURLWithPath: RLMRealmPathForFile("default.realm"), isDirectory: false),
+            inMemoryIdentifier: String? = nil,
+            encryptionKey: NSData? = nil,
+            readOnly: Bool = false,
+            schemaVersion: UInt64 = 0,
+            migrationBlock: MigrationBlock? = nil,
+            deleteRealmIfMigrationNeeded: Bool = false,
+            objectTypes: [Object.Type]? = nil) {
+                self.fileURL = fileURL
+                if inMemoryIdentifier != nil {
+                    self.inMemoryIdentifier = inMemoryIdentifier
+                }
+                self.encryptionKey = encryptionKey
+                self.readOnly = readOnly
+                self.schemaVersion = schemaVersion
+                self.migrationBlock = migrationBlock
+                self.deleteRealmIfMigrationNeeded = deleteRealmIfMigrationNeeded
+                self.objectTypes = objectTypes
+        }
+
+        // MARK: Configuration Properties
+
+        /// The local URL of the Realm file. Mutually exclusive with `inMemoryIdentifier`.
+        public var fileURL: NSURL? {
+            set {
+                _inMemoryIdentifier = nil
+                _path = newValue?.path
+            }
+            get {
+                return _path.map { NSURL(fileURLWithPath: $0) }
+            }
+        }
+
+        private var _path: String?
+
+        /// A string used to identify a particular in-memory Realm. Mutually exclusive with `fileURL`.
+        public var inMemoryIdentifier: String? {
+            set {
+                _path = nil
+                _inMemoryIdentifier = newValue
+            }
+            get {
+                return _inMemoryIdentifier
+            }
+        }
+
+        private var _inMemoryIdentifier: String? = nil
+
+        /// A 64-byte key to use to encrypt the data, or `nil` if encryption is not enabled.
+        public var encryptionKey: NSData? = nil
+
+        /// Whether to open the Realm in read-only mode.
+        ///
+        /// This is required to be able to open Realm files which are not
+        /// writeable or are in a directory which is not writeable. This should
+        /// only be used on files which will not be modified by anyone while
+        /// they are open, and not just to get a read-only view of a file which
+        /// may be written to by another thread or process. Opening in read-only
+        /// mode requires disabling Realm's reader/writer coordination, so
+        /// committing a write transaction from another process will result in
+        /// crashes.
+        public var readOnly: Bool = false
+
+        /// The current schema version.
+        public var schemaVersion: UInt64 = 0
+
+        /// The block which migrates the Realm to the current version.
+        public var migrationBlock: MigrationBlock? = nil
+
+        /**
+         Whether to recreate the Realm file with the provided schema if a migration is required.
+         This is the case when the stored schema differs from the provided schema or
+         the stored schema version differs from the version on this configuration.
+         Setting this property to `true` deletes the file if a migration would otherwise be required or executed.
+
+         - note: Setting this property to `true` doesn't disable file format migrations.
+        */
+        public var deleteRealmIfMigrationNeeded: Bool = false
+
+        /// The classes managed by the Realm.
+        public var objectTypes: [Object.Type]? {
+            set {
+                self.customSchema = newValue.map { RLMSchema(objectClasses: $0) }
+            }
+            get {
+                return self.customSchema.map { $0.objectSchema.map { $0.objectClass as! Object.Type } }
+            }
+        }
+
+        /// A custom schema to use for the Realm.
+        private var customSchema: RLMSchema? = nil
+
+        /// If `true`, disables automatic format upgrades when accessing the Realm.
+        internal var disableFormatUpgrade: Bool = false
+
+        // MARK: Private Methods
+
+        internal var rlmConfiguration: RLMRealmConfiguration {
+            let configuration = RLMRealmConfiguration()
+            if fileURL != nil {
+                configuration.fileURL = self.fileURL
+            } else if inMemoryIdentifier != nil {
+                configuration.inMemoryIdentifier = self.inMemoryIdentifier
+            } else {
+                fatalError("A Realm Configuration must specify a path or an in-memory identifier.")
+            }
+            configuration.encryptionKey = self.encryptionKey
+            configuration.readOnly = self.readOnly
+            configuration.schemaVersion = self.schemaVersion
+            configuration.migrationBlock = self.migrationBlock.map { accessorMigrationBlock($0) }
+            configuration.deleteRealmIfMigrationNeeded = self.deleteRealmIfMigrationNeeded
+            configuration.customSchema = self.customSchema
+            configuration.disableFormatUpgrade = self.disableFormatUpgrade
+            return configuration
+        }
+
+        internal static func fromRLMRealmConfiguration(rlmConfiguration: RLMRealmConfiguration) -> Configuration {
+            var configuration = Configuration()
+            configuration._path = rlmConfiguration.fileURL?.path
+            configuration._inMemoryIdentifier = rlmConfiguration.inMemoryIdentifier
+            configuration.encryptionKey = rlmConfiguration.encryptionKey
+            configuration.readOnly = rlmConfiguration.readOnly
+            configuration.schemaVersion = rlmConfiguration.schemaVersion
+            configuration.migrationBlock = rlmConfiguration.migrationBlock.map { rlmMigration in
+                return { migration, schemaVersion in
+                    rlmMigration(migration.rlmMigration, schemaVersion)
+                }
+            }
+            configuration.deleteRealmIfMigrationNeeded = rlmConfiguration.deleteRealmIfMigrationNeeded
+            configuration.customSchema = rlmConfiguration.customSchema
+            configuration.disableFormatUpgrade = rlmConfiguration.disableFormatUpgrade
+            return configuration
+        }
+    }
+}
+
+// MARK: CustomStringConvertible
+
+extension Realm.Configuration: CustomStringConvertible {
+    /// Returns a human-readable description of the configuration.
+    public var description: String {
+        return gsub("\\ARLMRealmConfiguration",
+                    template: "Realm.Configuration",
+                    string: rlmConfiguration.description) ?? ""
+    }
+}
+
+#endif
diff --git a/Pods/RealmSwift/RealmSwift/Results.swift b/Pods/RealmSwift/RealmSwift/Results.swift
new file mode 100644
index 0000000..3ae3166
--- /dev/null
+++ b/Pods/RealmSwift/RealmSwift/Results.swift
@@ -0,0 +1,857 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+import Foundation
+import Realm
+
+#if swift(>=3.0)
+
+// MARK: MinMaxType
+
+/// Types which can be used for min()/max().
+public protocol MinMaxType {}
+extension Double: MinMaxType {}
+extension Float: MinMaxType {}
+extension Int: MinMaxType {}
+extension Int8: MinMaxType {}
+extension Int16: MinMaxType {}
+extension Int32: MinMaxType {}
+extension Int64: MinMaxType {}
+extension NSDate: MinMaxType {}
+
+// MARK: AddableType
+
+/// Types which can be used for average()/sum().
+public protocol AddableType {}
+extension Double: AddableType {}
+extension Float: AddableType {}
+extension Int: AddableType {}
+extension Int8: AddableType {}
+extension Int16: AddableType {}
+extension Int32: AddableType {}
+extension Int64: AddableType {}
+
+/**
+Results is an auto-updating container type in Realm returned from object queries.
+
+Results can be queried with the same predicates as `List<T>` and you can chain
+queries to further filter query results.
+
+Results always reflect the current state of the Realm on the current thread,
+including during write transactions on the current thread. The one exception to
+this is when using `for...in` enumeration, which will always enumerate over the
+ objects which matched the query when the enumeration is begun, even if
+some of them are deleted or modified to be excluded by the filter during the
+enumeration.
+
+Results are initially lazily evaluated, and only run queries when the result
+of the query is requested. This means that chaining several temporary
+Results to sort and filter your data does not perform any extra work
+processing the intermediate state.
+
+Once the results have been evaluated or a notification block has been added,
+the results are eagerly kept up-to-date, with the work done to keep them
+up-to-date done on a background thread whenever possible.
+
+Results cannot be created directly.
+*/
+public final class Results<T: Object>: NSObject, NSFastEnumeration {
+
+    internal let rlmResults: RLMResults<RLMObject>
+
+    /// Returns a human-readable description of the objects contained in these results.
+    public override var description: String {
+        let type = "Results<\(rlmResults.objectClassName)>"
+        return gsub(pattern: "RLMResults <0x[a-z0-9]+>", template: type, string: rlmResults.description) ?? type
+    }
+
+    // MARK: Fast Enumeration
+
+    public func countByEnumerating(with state: UnsafeMutablePointer<NSFastEnumerationState>,
+                   objects buffer: AutoreleasingUnsafeMutablePointer<AnyObject?>!,
+                   count len: Int) -> Int {
+        return Int(rlmResults.countByEnumerating(with: state, objects: buffer, count: UInt(len)))
+    }
+
+    /// Element type contained in this collection.
+    public typealias Element = T
+
+    // MARK: Properties
+
+    /// Returns the Realm these results are associated with.
+    /// Despite returning an `Optional<Realm>` in order to conform to
+    /// `RealmCollection`, it will always return `.Some()` since a `Results`
+    /// cannot exist independently from a `Realm`.
+    public var realm: Realm? { return Realm(rlmResults.realm) }
+
+    /// Indicates if the results can no longer be accessed.
+    ///
+    /// Results can no longer be accessed if `invalidate` is called on the containing `Realm`.
+    public var isInvalidated: Bool { return rlmResults.isInvalidated }
+
+    /// Returns the number of objects in these results.
+    public var count: Int { return Int(rlmResults.count) }
+
+    // MARK: Initializers
+
+    internal init(_ rlmResults: RLMResults<RLMObject>) {
+        self.rlmResults = rlmResults
+    }
+
+    // MARK: Index Retrieval
+
+    /**
+    Returns the index of the given object, or `nil` if the object is not in the results.
+
+    - parameter object: The object whose index is being queried.
+
+    - returns: The index of the given object, or `nil` if the object is not in the results.
+    */
+    public func index(of object: T) -> Int? {
+        return notFoundToNil(index: rlmResults.index(of: unsafeBitCast(object, to: RLMObject.self)))
+    }
+
+    /**
+    Returns the index of the first object matching the given predicate,
+    or `nil` if no objects match.
+
+    - parameter predicate: The predicate to filter the objects.
+
+    - returns: The index of the first matching object, or `nil` if no objects match.
+    */
+    public func indexOfObject(for predicate: Predicate) -> Int? {
+        return notFoundToNil(index: rlmResults.indexOfObject(with: predicate))
+    }
+
+    /**
+    Returns the index of the first object matching the given predicate,
+    or `nil` if no objects match.
+
+    - parameter predicateFormat: The predicate format string which can accept variable arguments.
+
+    - returns: The index of the first matching object, or `nil` if no objects match.
+    */
+    public func indexOfObject(for predicateFormat: String, _ args: AnyObject...) -> Int? {
+        return notFoundToNil(index: rlmResults.indexOfObject(with: Predicate(format: predicateFormat,
+                                                                             argumentArray: args)))
+    }
+
+    // MARK: Object Retrieval
+
+    /**
+    Returns the object at the given `index`.
+
+    - parameter index: The index.
+
+    - returns: The object at the given `index`.
+    */
+    public subscript(position: Int) -> T {
+        throwForNegativeIndex(position)
+        return unsafeBitCast(rlmResults.object(at: UInt(position)), to: T.self)
+    }
+
+    /// Returns the first object in the results, or `nil` if empty.
+    public var first: T? { return unsafeBitCast(rlmResults.firstObject(), to: Optional<T>.self) }
+
+    /// Returns the last object in the results, or `nil` if empty.
+    public var last: T? { return unsafeBitCast(rlmResults.lastObject(), to: Optional<T>.self) }
+
+    // MARK: KVC
+
+    /**
+    Returns an Array containing the results of invoking `valueForKey(_:)` using key on each of the collection's objects.
+
+    - parameter key: The name of the property.
+
+    - returns: Array containing the results of invoking `valueForKey(_:)` using key on each of the collection's objects.
+    */
+    public override func value(forKey key: String) -> AnyObject? {
+        return value(forKeyPath: key)
+    }
+
+    /**
+     Returns an Array containing the results of invoking `valueForKeyPath(_:)` using keyPath on each of the
+     collection's objects.
+
+     - parameter keyPath: The key path to the property.
+
+     - returns: Array containing the results of invoking `valueForKeyPath(_:)` using keyPath on each of the
+     collection's objects.
+     */
+    public override func value(forKeyPath keyPath: String) -> AnyObject? {
+        return rlmResults.value(forKeyPath: keyPath)
+    }
+
+    /**
+    Invokes `setValue(_:forKey:)` on each of the collection's objects using the specified value and key.
+
+    - warning: This method can only be called during a write transaction.
+
+    - parameter value: The object value.
+    - parameter key:   The name of the property.
+    */
+    public override func setValue(_ value: AnyObject?, forKey key: String) {
+        return rlmResults.setValue(value, forKeyPath: key)
+    }
+
+    // MARK: Filtering
+
+    /**
+    Filters the results to the objects that match the given predicate.
+
+    - parameter predicateFormat: The predicate format string which can accept variable arguments.
+
+    - returns: Results containing objects that match the given predicate.
+    */
+    public func filter(using predicateFormat: String, _ args: AnyObject...) -> Results<T> {
+        return Results<T>(rlmResults.objects(with: Predicate(format: predicateFormat, argumentArray: args)))
+    }
+
+    /**
+    Filters the results to the objects that match the given predicate.
+
+    - parameter predicate: The predicate to filter the objects.
+
+    - returns: Results containing objects that match the given predicate.
+    */
+    public func filter(using predicate: Predicate) -> Results<T> {
+        return Results<T>(rlmResults.objects(with: predicate))
+    }
+
+    // MARK: Sorting
+
+    /**
+    Returns `Results` with elements sorted by the given property name.
+
+    - parameter property:  The property name to sort by.
+    - parameter ascending: The direction to sort by.
+
+    - returns: `Results` with elements sorted by the given property name.
+    */
+    public func sorted(onProperty property: String, ascending: Bool = true) -> Results<T> {
+        return sorted(with: [SortDescriptor(property: property, ascending: ascending)])
+    }
+
+    /**
+    Returns `Results` with elements sorted by the given sort descriptors.
+
+    - parameter sortDescriptors: `SortDescriptor`s to sort by.
+
+    - returns: `Results` with elements sorted by the given sort descriptors.
+    */
+    public func sorted<S: Sequence where S.Iterator.Element == SortDescriptor>(with sortDescriptors: S) -> Results<T> {
+        return Results<T>(rlmResults.sortedResults(using: sortDescriptors.map { $0.rlmSortDescriptorValue }))
+    }
+
+    // MARK: Aggregate Operations
+
+    /**
+    Returns the minimum value of the given property.
+
+    - warning: Only names of properties of a type conforming to the `MinMaxType` protocol can be used.
+
+    - parameter property: The name of a property conforming to `MinMaxType` to look for a minimum on.
+
+    - returns: The minimum value for the property amongst objects in the Results, or `nil` if the Results is empty.
+    */
+    public func minimumValue<U: MinMaxType>(ofProperty property: String) -> U? {
+        return rlmResults.min(ofProperty: property) as! U?
+    }
+
+    /**
+    Returns the maximum value of the given property.
+
+    - warning: Only names of properties of a type conforming to the `MinMaxType` protocol can be used.
+
+    - parameter property: The name of a property conforming to `MinMaxType` to look for a maximum on.
+
+    - returns: The maximum value for the property amongst objects in the Results, or `nil` if the Results is empty.
+    */
+    public func maximumValue<U: MinMaxType>(ofProperty property: String) -> U? {
+        return rlmResults.max(ofProperty: property) as! U?
+    }
+
+    /**
+    Returns the sum of the given property for objects in the Results.
+
+    - warning: Only names of properties of a type conforming to the `AddableType` protocol can be used.
+
+    - parameter property: The name of a property conforming to `AddableType` to calculate sum on.
+
+    - returns: The sum of the given property over all objects in the Results.
+    */
+    public func sum<U: AddableType>(ofProperty property: String) -> U {
+        return rlmResults.sum(ofProperty: property) as AnyObject as! U
+    }
+
+    /**
+    Returns the average of the given property for objects in the Results.
+
+    - warning: Only names of properties of a type conforming to the `AddableType` protocol can be used.
+
+    - parameter property: The name of a property conforming to `AddableType` to calculate average on.
+
+    - returns: The average of the given property over all objects in the Results, or `nil` if the Results is empty.
+    */
+    public func average<U: AddableType>(ofProperty property: String) -> U? {
+        return rlmResults.average(ofProperty: property) as! U?
+    }
+
+    // MARK: Notifications
+
+    /**
+     Register a block to be called each time the Results changes.
+
+     The block will be asynchronously called with the initial results, and then
+     called again after each write transaction which changes either any of the
+     objects in the results, or which objects are in the results.
+
+     This version of this method reports which of the objects in the results were
+     added, removed, or modified in each write transaction as indices within the
+     results. See the RealmCollectionChange documentation for more information on
+     the change information supplied and an example of how to use it to update
+     a UITableView.
+
+     At the time when the block is called, the Results object will be fully
+     evaluated and up-to-date, and as long as you do not perform a write transaction
+     on the same thread or explicitly call realm.refresh(), accessing it will never
+     perform blocking work.
+
+     Notifications are delivered via the standard run loop, and so can't be
+     delivered while the run loop is blocked by other activity. When
+     notifications can't be delivered instantly, multiple notifications may be
+     coalesced into a single notification. This can include the notification
+     with the initial results. For example, the following code performs a write
+     transaction immediately after adding the notification block, so there is no
+     opportunity for the initial notification to be delivered first. As a
+     result, the initial notification will reflect the state of the Realm after
+     the write transaction.
+
+         let dogs = realm.objects(Dog)
+         print("dogs.count: \(dogs?.count)") // => 0
+         let token = dogs.addNotificationBlock { (changes: RealmCollectionChange) in
+             switch changes {
+                 case .Initial(let dogs):
+                     // Will print "dogs.count: 1"
+                     print("dogs.count: \(dogs.count)")
+                     break
+                 case .Update:
+                     // Will not be hit in this example
+                     break
+                 case .Error:
+                     break
+             }
+         }
+         try! realm.write {
+             let dog = Dog()
+             dog.name = "Rex"
+             person.dogs.append(dog)
+         }
+         // end of run loop execution context
+
+     You must retain the returned token for as long as you want updates to continue
+     to be sent to the block. To stop receiving updates, call stop() on the token.
+
+     - warning: This method cannot be called during a write transaction, or when
+                the source realm is read-only.
+
+     - parameter block: The block to be called with the evaluated results and change information.
+     - returns: A token which must be held for as long as you want query results to be delivered.
+     */
+    public func addNotificationBlock(block: ((RealmCollectionChange<Results>) -> Void)) -> NotificationToken {
+        return rlmResults.addNotificationBlock { results, change, error in
+            block(RealmCollectionChange.fromObjc(value: self, change: change, error: error))
+        }
+    }
+}
+
+extension Results: RealmCollection {
+    // MARK: Sequence Support
+
+    /// Returns a `RLMIterator` that yields successive elements in the results.
+    public func makeIterator() -> RLMIterator<T> {
+        return RLMIterator(collection: rlmResults)
+    }
+
+    // MARK: Collection Support
+
+    /// The position of the first element in a non-empty collection.
+    /// Identical to endIndex in an empty collection.
+    public var startIndex: Int { return 0 }
+
+    /// The collection's "past the end" position.
+    /// endIndex is not a valid argument to subscript, and is always reachable from startIndex by
+    /// zero or more applications of successor().
+    public var endIndex: Int { return count }
+
+    public func index(after i: Int) -> Int { return i + 1 }
+    public func index(before i: Int) -> Int { return i - 1 }
+
+    /// :nodoc:
+    public func _addNotificationBlock(block: (RealmCollectionChange<AnyRealmCollection<T>>) -> Void) ->
+        NotificationToken {
+        let anyCollection = AnyRealmCollection(self)
+        return rlmResults.addNotificationBlock { _, change, error in
+            block(RealmCollectionChange.fromObjc(value: anyCollection, change: change, error: error))
+        }
+    }
+}
+
+// MARK: Unavailable
+
+extension Results {
+    @available(*, unavailable, renamed:"isInvalidated")
+    public var invalidated : Bool { fatalError() }
+
+    @available(*, unavailable, renamed:"indexOfObject(for:)")
+    public func index(of predicate: Predicate) -> Int? { fatalError() }
+
+    @available(*, unavailable, renamed:"indexOfObject(for:_:)")
+    public func index(of predicateFormat: String, _ args: AnyObject...) -> Int? { fatalError() }
+
+    @available(*, unavailable, renamed:"filter(using:)")
+    public func filter(_ predicate: Predicate) -> Results<T> { fatalError() }
+
+    @available(*, unavailable, renamed:"filter(using:_:)")
+    public func filter(_ predicateFormat: String, _ args: AnyObject...) -> Results<T> { fatalError() }
+
+    @available(*, unavailable, renamed:"sorted(onProperty:ascending:)")
+    public func sorted(_ property: String, ascending: Bool = true) -> Results<T> { fatalError() }
+
+    @available(*, unavailable, renamed:"sorted(with:)")
+    public func sorted<S: Sequence where S.Iterator.Element == SortDescriptor>(_ sortDescriptors: S) -> Results<T> {
+        fatalError()
+    }
+
+    @available(*, unavailable, renamed:"minimumValue(ofProperty:)")
+    public func min<U: MinMaxType>(_ property: String) -> U? { fatalError() }
+
+    @available(*, unavailable, renamed:"maximumValue(ofProperty:)")
+    public func max<U: MinMaxType>(_ property: String) -> U? { fatalError() }
+
+    @available(*, unavailable, renamed:"sum(ofProperty:)")
+    public func sum<U: AddableType>(_ property: String) -> U { fatalError() }
+
+    @available(*, unavailable, renamed:"average(ofProperty:)")
+    public func average<U: AddableType>(_ property: String) -> U? { fatalError() }
+}
+
+#else
+
+// MARK: MinMaxType
+
+/**
+ Types of properties which can be used with the minimum and maximum value APIs.
+
+ - see: `min(_:)`, `max(_:)`
+ */
+public protocol MinMaxType {}
+extension Double: MinMaxType {}
+extension Float: MinMaxType {}
+extension Int: MinMaxType {}
+extension Int8: MinMaxType {}
+extension Int16: MinMaxType {}
+extension Int32: MinMaxType {}
+extension Int64: MinMaxType {}
+extension NSDate: MinMaxType {}
+
+// MARK: AddableType
+
+/**
+ Types of properties which can be used with the sum and average value APIs.
+
+ - see: `sum(_:)`, `average(_:)`
+ */
+public protocol AddableType {}
+extension Double: AddableType {}
+extension Float: AddableType {}
+extension Int: AddableType {}
+extension Int8: AddableType {}
+extension Int16: AddableType {}
+extension Int32: AddableType {}
+extension Int64: AddableType {}
+
+/// :nodoc:
+/// Internal class. Do not use directly.
+public class ResultsBase: NSObject, NSFastEnumeration {
+    internal let rlmResults: RLMResults
+
+    /// Returns a human-readable description of the objects contained in these results.
+    public override var description: String {
+        let type = "Results<\(rlmResults.objectClassName)>"
+        return gsub("RLMResults <0x[a-z0-9]+>", template: type, string: rlmResults.description) ?? type
+    }
+
+    // MARK: Initializers
+
+    internal init(_ rlmResults: RLMResults) {
+        self.rlmResults = rlmResults
+    }
+
+    // MARK: Fast Enumeration
+
+    public func countByEnumeratingWithState(state: UnsafeMutablePointer<NSFastEnumerationState>,
+                                            objects buffer: AutoreleasingUnsafeMutablePointer<AnyObject?>,
+                                            count len: Int) -> Int {
+        return Int(rlmResults.countByEnumeratingWithState(state,
+                   objects: buffer,
+                   count: UInt(len)))
+    }
+}
+
+/**
+ `Results` is an auto-updating container type in Realm returned from object queries.
+
+ `Results` can be queried with the same predicates as `List<T>`, and you can chain
+ queries to further filter query results.
+
+ `Results` always reflect the current state of the Realm on the current thread,
+ including during write transactions on the current thread. The one exception to
+ this is when using `for...in` enumeration, which will always enumerate over the
+ objects which matched the query when the enumeration is begun, even if
+ some of them are deleted or modified to be excluded by the filter during the
+ enumeration.
+
+ `Results` are lazily evaluated the first time they are accessed; they only
+ run queries when the result of the query is requested. This means that
+ chaining several temporary `Results` to sort and filter your data does not
+ perform any extra work processing the intermediate state.
+
+ Once the results have been evaluated or a notification block has been added,
+ the results are eagerly kept up-to-date, with the work done to keep them
+ up-to-date done on a background thread whenever possible.
+
+ `Results` cannot be directly instantiated.
+*/
+public final class Results<T: Object>: ResultsBase {
+
+    /// The type of the objects contained in the collection.
+    public typealias Element = T
+
+    // MARK: Properties
+
+    /// The Realm which manages this results collection. Note that this property will never return `nil`.
+    public var realm: Realm? { return Realm(rlmResults.realm) }
+
+    /**
+     Indicates if the results collection is no longer valid.
+
+     The results collection becomes invalid if `invalidate` is called on the containing `realm`.
+     An invalidated results collection can be accessed, but will always be empty.
+     */
+    public var invalidated: Bool { return rlmResults.invalidated }
+
+    /// The number of objects in the results collection.
+    public var count: Int { return Int(rlmResults.count) }
+
+    // MARK: Initializers
+
+    internal override init(_ rlmResults: RLMResults) {
+        super.init(rlmResults)
+    }
+
+    // MARK: Index Retrieval
+
+    /**
+     Returns the index of an object in the results collection, or `nil` if the object is not present.
+
+     - parameter object: An object.
+     */
+    public func indexOf(object: T) -> Int? {
+        return notFoundToNil(rlmResults.indexOfObject(unsafeBitCast(object, RLMObject.self)))
+    }
+
+    /**
+     Returns the index of the first object matching the predicate, or `nil` if no objects match.
+
+     - parameter predicate: The predicate with which to filter the objects.
+     */
+    public func indexOf(predicate: NSPredicate) -> Int? {
+        return notFoundToNil(rlmResults.indexOfObjectWithPredicate(predicate))
+    }
+
+    /**
+     Returns the index of the first object matching the predicate, or `nil` if no objects match.
+
+     - parameter predicateFormat: A predicate format string, optionally followed by a variable number of arguments.`
+     */
+    public func indexOf(predicateFormat: String, _ args: AnyObject...) -> Int? {
+        return notFoundToNil(rlmResults.indexOfObjectWithPredicate(NSPredicate(format: predicateFormat,
+                                                                               argumentArray: args)))
+    }
+
+    // MARK: Object Retrieval
+
+    /**
+     Returns the object at the given `index`.
+
+     - parameter index: An index.
+
+     - returns: The object at the given `index`.
+     */
+    public subscript(index: Int) -> T {
+        get {
+            throwForNegativeIndex(index)
+            return unsafeBitCast(rlmResults[UInt(index)], T.self)
+        }
+    }
+
+    /// Returns the first object in the results collection, or `nil` if the collection is empty.
+    public var first: T? { return unsafeBitCast(rlmResults.firstObject(), Optional<T>.self) }
+
+    /// Returns the last object in the results collection, or `nil` if the collection is empty.
+    public var last: T? { return unsafeBitCast(rlmResults.lastObject(), Optional<T>.self) }
+
+    // MARK: KVC
+
+    /**
+     Returns an `Array` containing the results of invoking `valueForKey(_:)` with `key` on each of the results
+     collection's objects.
+
+     - parameter key: The name of the property whose values are desired.
+     */
+    public override func valueForKey(key: String) -> AnyObject? {
+        return rlmResults.valueForKey(key)
+    }
+
+    /**
+     Returns an `Array` containing the results of invoking `valueForKeyPath(_:)` with `keyPath` on each of the results
+     collection's objects.
+
+     - parameter keyPath: The key path to the property whose values are desired.
+     */
+    public override func valueForKeyPath(keyPath: String) -> AnyObject? {
+        return rlmResults.valueForKeyPath(keyPath)
+    }
+
+    /**
+     Invokes `setValue(_:forKey:)` on each of the results collection's objects using the specified `value` and `key`.
+
+     - warning: This method may only be called during a write transaction.
+
+     - parameter value: The object value.
+     - parameter key:   The name of the property whose value should be set on each object.
+     */
+    public override func setValue(value: AnyObject?, forKey key: String) {
+        return rlmResults.setValue(value, forKey: key)
+    }
+
+    // MARK: Filtering
+
+    /**
+     Returns a `Results` containing all objects matching the given predicate in the results collection.
+
+     - parameter predicateFormat: A predicate format string, optionally followed by a variable number of arguments.
+     */
+    public func filter(predicateFormat: String, _ args: AnyObject...) -> Results<T> {
+        return Results<T>(rlmResults.objectsWithPredicate(NSPredicate(format: predicateFormat, argumentArray: args)))
+    }
+
+    /**
+     Returns a `Results` containing all objects matching the given predicate in the results collection.
+
+     - parameter predicate: The predicate with which to filter the objects.
+     */
+    public func filter(predicate: NSPredicate) -> Results<T> {
+        return Results<T>(rlmResults.objectsWithPredicate(predicate))
+    }
+
+    // MARK: Sorting
+
+    /**
+     Returns a `Results` containing the objects in the results collection, but sorted.
+
+     Objects are sorted based on the values of the given property. For example, to sort a collection of `Student`s from
+     youngest to oldest based on their `age` property, you might call `students.sorted("age", ascending: true)`.
+
+     - warning: Collections may only be sorted by properties of boolean, `NSDate`, single and double-precision floating
+                point, integer, and string types.
+
+     - parameter property:  The name of the property to sort by.
+     - parameter ascending: The direction to sort in.
+     */
+    public func sorted(property: String, ascending: Bool = true) -> Results<T> {
+        return sorted([SortDescriptor(property: property, ascending: ascending)])
+    }
+
+    /**
+     Returns a `Results` containing the objects in the results collection, but sorted.
+
+     - warning: Collections may only be sorted by properties of boolean, `NSDate`, single and double-precision floating
+                point, integer, and string types.
+
+     - see: `sorted(_:ascending:)`
+
+     - parameter sortDescriptors: A sequence of `SortDescriptor`s to sort by.
+     */
+    public func sorted<S: SequenceType where S.Generator.Element == SortDescriptor>(sortDescriptors: S) -> Results<T> {
+        return Results<T>(rlmResults.sortedResultsUsingDescriptors(sortDescriptors.map { $0.rlmSortDescriptorValue }))
+    }
+
+    // MARK: Aggregate Operations
+
+    /**
+     Returns the minimum (lowest) value of the given property among all the objects represented by the collection.
+
+     - warning: Only a property whose type conforms to the `MinMaxType` protocol can be specified.
+
+     - parameter property: The name of a property whose minimum value is desired.
+
+     - returns: The minimum value of the property, or `nil` if the collection is empty.
+     */
+    public func min<U: MinMaxType>(property: String) -> U? {
+        return rlmResults.minOfProperty(property) as! U?
+    }
+
+    /**
+     Returns the maximum (highest) value of the given property among all the objects represented by the collection.
+
+     - warning: Only a property whose type conforms to the `MinMaxType` protocol can be specified.
+
+     - parameter property: The name of a property whose minimum value is desired.
+
+     - returns: The maximum value of the property, or `nil` if the collection is empty.
+     */
+    public func max<U: MinMaxType>(property: String) -> U? {
+        return rlmResults.maxOfProperty(property) as! U?
+    }
+
+    /**
+     Returns the sum of the values of a given property over all the objects represented by the collection.
+
+     - warning: Only a property whose type conforms to the `AddableType` protocol can be specified.
+
+     - parameter property: The name of a property whose values should be summed.
+
+     - returns: The sum of the given property.
+     */
+    public func sum<U: AddableType>(property: String) -> U {
+        return rlmResults.sumOfProperty(property) as AnyObject as! U
+    }
+
+    /**
+     Returns the average value of a given property over all the objects represented by the collection.
+
+     - warning: Only the name of a property whose type conforms to the `AddableType` protocol can be specified.
+
+     - parameter property: The name of a property whose average value should be calculated.
+
+     - returns: The average value of the given property, or `nil` if the collection is empty.
+     */
+    public func average<U: AddableType>(property: String) -> U? {
+        return rlmResults.averageOfProperty(property) as! U?
+    }
+
+    // MARK: Notifications
+
+    /**
+     Registers a block to be called each time the results collection changes.
+
+     The block will be asynchronously called with the initial results, and then
+     called again after each write transaction which changes either any of the
+     objects in the collection, or which objects are in the collection.
+
+     The `change` parameter that is passed to the block reports, in the form of indices within the
+     collection, which of the objects were added, removed, or modified during each write transaction. See the
+     `RealmCollectionChange` documentation for more information on the change information supplied and an example of how
+     to use it to update a `UITableView`.
+
+     At the time when the block is called, the collection will be fully
+     evaluated and up-to-date, and as long as you do not perform a write
+     transaction on the same thread or explicitly call `realm.refresh()`,
+     accessing it will never perform blocking work.
+
+     Notifications are delivered via the standard run loop, and so can't be
+     delivered while the run loop is blocked by other activity. When
+     notifications can't be delivered instantly, multiple notifications may be
+     coalesced into a single notification. This can include the notification
+     with the initial collection. For example, the following code performs a write
+     transaction immediately after adding the notification block, so there is no
+     opportunity for the initial notification to be delivered first. As a
+     result, the initial notification will reflect the state of the Realm after
+     the write transaction.
+
+         let dogs = realm.objects(Dog.self)
+         print("dogs.count: \(dogs?.count)") // => 0
+         let token = dogs.addNotificationBlock { (changes: RealmCollectionChange) in
+             switch changes {
+                 case .Initial(let dogs):
+                     // Will print "dogs.count: 1"
+                     print("dogs.count: \(dogs.count)")
+                     break
+                 case .Update:
+                     // Will not be hit in this example
+                     break
+                 case .Error:
+                     break
+             }
+         }
+         try! realm.write {
+             let dog = Dog()
+             dog.name = "Rex"
+             person.dogs.append(dog)
+         }
+         // end of run loop execution context
+
+     You must retain the returned token for as long as you want updates to continue
+     to be sent to the block. To stop receiving updates, call `stop()` on the token.
+
+     - warning: This method cannot be called during a write transaction, or when
+                the containing Realm is read-only.
+
+     - parameter block: The block to be called whenever a change occurs.
+     - returns: A token which must be retained for as long as you want updates to be delivered.
+     */
+    @warn_unused_result(message="You must hold on to the NotificationToken returned from addNotificationBlock")
+    public func addNotificationBlock(block: (RealmCollectionChange<Results> -> Void)) -> NotificationToken {
+        return rlmResults.addNotificationBlock { results, change, error in
+            block(RealmCollectionChange.fromObjc(self, change: change, error: error))
+        }
+    }
+}
+
+extension Results: RealmCollectionType {
+    // MARK: Sequence Support
+
+    /// Returns an `RLMGenerator` that yields successive elements in the results.
+    public func generate() -> RLMGenerator<T> {
+        return RLMGenerator(collection: rlmResults)
+    }
+
+    // MARK: Collection Support
+
+    /// The position of the first element in a non-empty collection.
+    /// Identical to `endIndex` in an empty collection.
+    public var startIndex: Int { return 0 }
+
+    /// The collection's "past the end" position.
+    /// `endIndex` is not a valid argument to `subscript`, and is always reachable from `startIndex` by
+    /// zero or more applications of `successor()`.
+    public var endIndex: Int { return count }
+
+    /// :nodoc:
+    public func _addNotificationBlock(block: (RealmCollectionChange<AnyRealmCollection<T>>) -> Void) ->
+        NotificationToken {
+        let anyCollection = AnyRealmCollection(self)
+        return rlmResults.addNotificationBlock { _, change, error in
+            block(RealmCollectionChange.fromObjc(anyCollection, change: change, error: error))
+        }
+    }
+}
+
+#endif
diff --git a/Pods/RealmSwift/RealmSwift/Schema.swift b/Pods/RealmSwift/RealmSwift/Schema.swift
new file mode 100644
index 0000000..fb21737
--- /dev/null
+++ b/Pods/RealmSwift/RealmSwift/Schema.swift
@@ -0,0 +1,127 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2014 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+import Foundation
+import Realm
+
+#if swift(>=3.0)
+
+/**
+This class represents the collection of model object schemas persisted to Realm.
+
+When using Realm, `Schema` objects allow performing migrations and
+introspecting the database's schema.
+
+`Schema`s map to collections of tables in the core database.
+*/
+public final class Schema: CustomStringConvertible {
+
+    // MARK: Properties
+
+    internal let rlmSchema: RLMSchema
+
+    /// `ObjectSchema`s for all object types in this Realm. Meant
+    /// to be used during migrations for dynamic introspection.
+    public var objectSchema: [ObjectSchema] {
+        return rlmSchema.objectSchema.map(ObjectSchema.init)
+    }
+
+    /// Returns a human-readable description of the object schemas contained in this schema.
+    public var description: String { return rlmSchema.description }
+
+    // MARK: Initializers
+
+    internal init(_ rlmSchema: RLMSchema) {
+        self.rlmSchema = rlmSchema
+    }
+
+    // MARK: ObjectSchema Retrieval
+
+    /// Returns the object schema with the given class name, if it exists.
+    public subscript(className: String) -> ObjectSchema? {
+        if let rlmObjectSchema = rlmSchema.schema(forClassName: className) {
+            return ObjectSchema(rlmObjectSchema)
+        }
+        return nil
+    }
+}
+
+// MARK: Equatable
+
+extension Schema: Equatable {}
+
+/// Returns whether the two schemas are equal.
+public func == (lhs: Schema, rhs: Schema) -> Bool { // swiftlint:disable:this valid_docs
+    return lhs.rlmSchema.isEqual(to: rhs.rlmSchema)
+}
+
+#else
+
+/**
+ `Schema` instances represent collections of model object schemas managed by a Realm.
+
+ When using Realm, `Schema` instances allow performing migrations and
+ introspecting the database's schema.
+
+ Schemas map to collections of tables in the core database.
+*/
+public final class Schema: CustomStringConvertible {
+
+    // MARK: Properties
+
+    internal let rlmSchema: RLMSchema
+
+    /**
+     An array of `ObjectSchema`s for all object types in the Realm.
+
+     This property is intended to be used during migrations for dynamic introspection.
+     */
+    public var objectSchema: [ObjectSchema] {
+        return rlmSchema.objectSchema.map(ObjectSchema.init)
+    }
+
+    /// Returns a human-readable description of the object schemas contained in this schema.
+    public var description: String { return rlmSchema.description }
+
+    // MARK: Initializers
+
+    internal init(_ rlmSchema: RLMSchema) {
+        self.rlmSchema = rlmSchema
+    }
+
+    // MARK: ObjectSchema Retrieval
+
+    /// Looks up and returns an `ObjectSchema` for the given class name in the Realm, if it exists.
+    public subscript(className: String) -> ObjectSchema? {
+        if let rlmObjectSchema = rlmSchema.schemaForClassName(className) {
+            return ObjectSchema(rlmObjectSchema)
+        }
+        return nil
+    }
+}
+
+// MARK: Equatable
+
+extension Schema: Equatable {}
+
+/// Returns a Boolean value that indicates whether two `Schema` instances are equivalent.
+public func == (lhs: Schema, rhs: Schema) -> Bool { // swiftlint:disable:this valid_docs
+    return lhs.rlmSchema.isEqualToSchema(rhs.rlmSchema)
+}
+
+#endif
diff --git a/Pods/RealmSwift/RealmSwift/SortDescriptor.swift b/Pods/RealmSwift/RealmSwift/SortDescriptor.swift
new file mode 100644
index 0000000..adf4a3a
--- /dev/null
+++ b/Pods/RealmSwift/RealmSwift/SortDescriptor.swift
@@ -0,0 +1,228 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2015 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+import Foundation
+import Realm
+
+#if swift(>=3.0)
+
+/**
+A `SortDescriptor` stores a property name and a sort order for use with
+`sorted(sortDescriptors:)`. It is similar to `NSSortDescriptor`, but supports
+only the subset of functionality which can be efficiently run by Realm's query
+engine.
+*/
+public struct SortDescriptor {
+
+    // MARK: Properties
+
+    /// The name of the property which this sort descriptor orders results by.
+    public let property: String
+
+    /// Whether this descriptor sorts in ascending or descending order.
+    public let ascending: Bool
+
+    /// Converts the receiver to an `RLMSortDescriptor`
+    internal var rlmSortDescriptorValue: RLMSortDescriptor {
+        return RLMSortDescriptor(property: property, ascending: ascending)
+    }
+
+    // MARK: Initializers
+
+    /**
+    Creates a `SortDescriptor` with the given property and ascending values.
+
+    - parameter property:  The name of the property which this sort descriptor orders results by.
+    - parameter ascending: Whether this descriptor sorts in ascending or descending order.
+    */
+    public init(property: String, ascending: Bool = true) {
+        self.property = property
+        self.ascending = ascending
+    }
+
+    // MARK: Functions
+
+    /// Returns a copy of the `SortDescriptor` with the sort order reversed.
+    public func reversed() -> SortDescriptor {
+        return SortDescriptor(property: property, ascending: !ascending)
+    }
+}
+
+// MARK: CustomStringConvertible
+
+extension SortDescriptor: CustomStringConvertible {
+    /// Returns a human-readable description of the sort descriptor.
+    public var description: String {
+        let direction = ascending ? "ascending" : "descending"
+        return "SortDescriptor (property: \(property), direction: \(direction))"
+    }
+}
+
+// MARK: Equatable
+
+extension SortDescriptor: Equatable {}
+
+/// Returns whether the two sort descriptors are equal.
+public func == (lhs: SortDescriptor, rhs: SortDescriptor) -> Bool {
+    // swiftlint:disable:previous valid_docs
+    return lhs.property == rhs.property &&
+        lhs.ascending == lhs.ascending
+}
+
+// MARK: StringLiteralConvertible
+
+extension SortDescriptor: StringLiteralConvertible {
+
+    /// `StringLiteralType`. Required for `StringLiteralConvertible` conformance.
+    public typealias UnicodeScalarLiteralType = StringLiteralType
+
+    /// `StringLiteralType`. Required for `StringLiteralConvertible` conformance.
+    public typealias ExtendedGraphemeClusterLiteralType = StringLiteralType
+
+    /**
+    Creates a `SortDescriptor` from a `UnicodeScalarLiteralType`.
+
+    - parameter unicodeScalarLiteral: Property name literal.
+    */
+    public init(unicodeScalarLiteral value: UnicodeScalarLiteralType) {
+        self.init(property: value)
+    }
+
+    /**
+    Creates a `SortDescriptor` from an `ExtendedGraphemeClusterLiteralType`.
+
+    - parameter extendedGraphemeClusterLiteral: Property name literal.
+    */
+    public init(extendedGraphemeClusterLiteral value: ExtendedGraphemeClusterLiteralType) {
+        self.init(property: value)
+    }
+
+    /**
+    Creates a `SortDescriptor` from a `StringLiteralType`.
+
+    - parameter stringLiteral: Property name literal.
+    */
+    public init(stringLiteral value: StringLiteralType) {
+        self.init(property: value)
+    }
+}
+
+#else
+
+/**
+ A `SortDescriptor` stores a property name and a sort order for use with
+ `sorted(sortDescriptors:)`. It is similar to `NSSortDescriptor`, but supports
+ only the subset of functionality which can be efficiently run by Realm's query
+ engine.
+ */
+public struct SortDescriptor {
+
+    // MARK: Properties
+
+    /// The name of the property which the sort descriptor orders results by.
+    public let property: String
+
+    /// Whether the descriptor sorts in ascending or descending order.
+    public let ascending: Bool
+
+    /// Converts the receiver to an `RLMSortDescriptor`
+    internal var rlmSortDescriptorValue: RLMSortDescriptor {
+        return RLMSortDescriptor(property: property, ascending: ascending)
+    }
+
+    // MARK: Initializers
+
+    /**
+     Initializes a sort descriptor with the given property and sort order values.
+
+    - parameter property:  The name of the property which the sort descriptor orders results by.
+    - parameter ascending: Whether the descriptor sorts in ascending or descending order.
+    */
+    public init(property: String, ascending: Bool = true) {
+        self.property = property
+        self.ascending = ascending
+    }
+
+    // MARK: Functions
+
+    /// Returns a copy of the sort descriptor with the sort order reversed.
+    public func reversed() -> SortDescriptor {
+        return SortDescriptor(property: property, ascending: !ascending)
+    }
+}
+
+// MARK: CustomStringConvertible
+
+extension SortDescriptor: CustomStringConvertible {
+    /// Returns a human-readable description of the sort descriptor.
+    public var description: String {
+        let direction = ascending ? "ascending" : "descending"
+        return "SortDescriptor (property: \(property), direction: \(direction))"
+    }
+}
+
+// MARK: Equatable
+
+extension SortDescriptor: Equatable {}
+
+/// Returns whether the two sort descriptors are equal.
+public func == (lhs: SortDescriptor, rhs: SortDescriptor) -> Bool {
+    // swiftlint:disable:previous valid_docs
+    return lhs.property == rhs.property &&
+        lhs.ascending == lhs.ascending
+}
+
+// MARK: StringLiteralConvertible
+
+extension SortDescriptor: StringLiteralConvertible {
+
+    /// `StringLiteralType`. Required for `StringLiteralConvertible` conformance.
+    public typealias UnicodeScalarLiteralType = StringLiteralType
+
+    /// `StringLiteralType`. Required for `StringLiteralConvertible` conformance.
+    public typealias ExtendedGraphemeClusterLiteralType = StringLiteralType
+
+    /**
+     Creates a `SortDescriptor` from a `UnicodeScalarLiteralType`.
+
+     - parameter unicodeScalarLiteral: Property name literal.
+    */
+    public init(unicodeScalarLiteral value: UnicodeScalarLiteralType) {
+        self.init(property: value)
+    }
+
+    /**
+     Creates a `SortDescriptor` from an `ExtendedGraphemeClusterLiteralType`.
+
+     - parameter extendedGraphemeClusterLiteral: Property name literal.
+    */
+    public init(extendedGraphemeClusterLiteral value: ExtendedGraphemeClusterLiteralType) {
+        self.init(property: value)
+    }
+
+    /**
+     Creates a `SortDescriptor` from a `StringLiteralType`.
+
+     - parameter stringLiteral: Property name literal.
+    */
+    public init(stringLiteral value: StringLiteralType) {
+        self.init(property: value)
+    }
+}
+
+#endif
diff --git a/Pods/RealmSwift/RealmSwift/SwiftVersion.swift b/Pods/RealmSwift/RealmSwift/SwiftVersion.swift
new file mode 100644
index 0000000..d5f8cfd
--- /dev/null
+++ b/Pods/RealmSwift/RealmSwift/SwiftVersion.swift
@@ -0,0 +1 @@
+let swiftLanguageVersion = "2.2"
diff --git a/Pods/RealmSwift/RealmSwift/Util.swift b/Pods/RealmSwift/RealmSwift/Util.swift
new file mode 100644
index 0000000..6dc158b
--- /dev/null
+++ b/Pods/RealmSwift/RealmSwift/Util.swift
@@ -0,0 +1,69 @@
+////////////////////////////////////////////////////////////////////////////
+//
+// Copyright 2015 Realm Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////
+
+import Foundation
+import Realm
+
+// MARK: Internal Helpers
+
+internal func notFoundToNil(index: UInt) -> Int? {
+    if index == UInt(NSNotFound) {
+        return nil
+    }
+    return Int(index)
+}
+
+#if swift(>=3.0)
+
+internal func throwRealmException(_ message: String, userInfo: [String:AnyObject] = [:]) {
+    NSException(name: NSExceptionName(rawValue: RLMExceptionName), reason: message, userInfo: userInfo).raise()
+}
+
+internal func throwForNegativeIndex(_ int: Int, parameterName: String = "index") {
+    if int < 0 {
+        throwRealmException("Cannot pass a negative value for '\(parameterName)'.")
+    }
+}
+
+internal func gsub(pattern: String, template: String, string: String, error: NSErrorPointer = nil) -> String? {
+    let regex = try? RegularExpression(pattern: pattern, options: [])
+    return regex?.stringByReplacingMatches(in: string, options: [],
+                                           range: NSRange(location: 0, length: string.utf16.count),
+                                           withTemplate: template)
+}
+
+#else
+
+internal func throwRealmException(message: String, userInfo: [String:AnyObject] = [:]) {
+    NSException(name: RLMExceptionName, reason: message, userInfo: userInfo).raise()
+}
+
+internal func throwForNegativeIndex(int: Int, parameterName: String = "index") {
+    if int < 0 {
+        throwRealmException("Cannot pass a negative value for '\(parameterName)'.")
+    }
+}
+
+internal func gsub(pattern: String, template: String, string: String, error: NSErrorPointer = nil) -> String? {
+    let regex = try? NSRegularExpression(pattern: pattern, options: [])
+    return regex?.stringByReplacingMatchesInString(string, options: [],
+                                                   range: NSRange(location: 0, length: string.utf16.count),
+                                                   withTemplate: template)
+}
+
+#endif
diff --git a/Pods/RealmSwift/build.sh b/Pods/RealmSwift/build.sh
new file mode 100755
index 0000000..d3d7078
--- /dev/null
+++ b/Pods/RealmSwift/build.sh
@@ -0,0 +1,1268 @@
+#!/bin/sh
+
+##################################################################################
+# Custom build tool for Realm Objective-C binding.
+#
+# (C) Copyright 2011-2015 by realm.io.
+##################################################################################
+
+# Warning: pipefail is not a POSIX compatible option, but on OS X it works just fine.
+#          OS X uses a POSIX complain version of bash as /bin/sh, but apparently it does
+#          not strip away this feature. Also, this will fail if somebody forces the script
+#          to be run with zsh.
+set -o pipefail
+set -e
+
+# You can override the version of the core library
+: ${REALM_CORE_VERSION:=1.3.1} # set to "current" to always use the current build
+
+# You can override the xcmode used
+: ${XCMODE:=xcodebuild} # must be one of: xcodebuild (default), xcpretty, xctool
+
+# Provide a fallback value for TMPDIR, relevant for Xcode Bots
+: ${TMPDIR:=$(getconf DARWIN_USER_TEMP_DIR)}
+
+PATH=/usr/libexec:$PATH
+
+if ! [ -z "${JENKINS_HOME}" ]; then
+    XCPRETTY_PARAMS="--no-utf --report junit --output build/reports/junit.xml"
+    CODESIGN_PARAMS="CODE_SIGN_IDENTITY= CODE_SIGNING_REQUIRED=NO"
+fi
+
+export REALM_SKIP_DEBUGGER_CHECKS=YES
+
+usage() {
+cat <<EOF
+Usage: sh $0 command [argument]
+
+command:
+  clean:                clean up/remove all generated files
+  download-core:        downloads core library (binary version)
+  build:                builds all iOS  and OS X frameworks
+  ios-static:           builds fat iOS static framework
+  ios-dynamic:          builds iOS dynamic frameworks
+  ios-swift:            builds RealmSwift frameworks for iOS
+  watchos:              builds watchOS framwork
+  watchos-swift:        builds RealmSwift framework for watchOS
+  tvos:                 builds tvOS framework
+  tvos-swift:           builds RealmSwift framework for tvOS
+  osx:                  builds OS X framework
+  osx-swift:            builds RealmSwift framework for OS X
+  analyze-osx:          analyzes OS X framework
+  test:                 tests all iOS and OS X frameworks
+  test-all:             tests all iOS and OS X frameworks in both Debug and Release configurations
+  test-ios-static:      tests static iOS framework on 32-bit and 64-bit simulators
+  test-ios-dynamic:     tests dynamic iOS framework on 32-bit and 64-bit simulators
+  test-ios-swift:       tests RealmSwift iOS framework on 32-bit and 64-bit simulators
+  test-ios-devices:     tests ObjC & Swift iOS frameworks on all attached iOS devices
+  test-ios-devices-objc:  tests ObjC iOS framework on all attached iOS devices
+  test-ios-devices-swift: tests Swift iOS framework on all attached iOS devices
+  test-tvos:            tests tvOS framework
+  test-tvos-swift:      tests RealmSwift tvOS framework
+  test-tvos-devices:    tests ObjC & Swift tvOS frameworks on all attached tvOS devices
+  test-osx:             tests OS X framework
+  test-osx-swift:       tests RealmSwift OS X framework
+  verify:               verifies docs, osx, osx-swift, ios-static, ios-dynamic, ios-swift, ios-device in both Debug and Release configurations, swiftlint
+  docs:                 builds docs in docs/output
+  examples:             builds all examples
+  examples-ios:         builds all static iOS examples
+  examples-ios-swift:   builds all Swift iOS examples
+  examples-osx:         builds all OS X examples
+  get-version:          get the current version
+  set-version version:  set the version
+  cocoapods-setup:      download realm-core and create a stub RLMPlatform.h file to enable building via CocoaPods
+
+
+argument:
+  version: version in the x.y.z format
+
+environment variables:
+  XCMODE: xcodebuild (default), xcpretty or xctool
+  CONFIGURATION: Debug or Release (default)
+  REALM_CORE_VERSION: version in x.y.z format or "current" to use local build
+  REALM_EXTRA_BUILD_ARGUMENTS: additional arguments to pass to the build tool
+EOF
+}
+
+######################################
+# Xcode Helpers
+######################################
+
+xcode() {
+    mkdir -p build/DerivedData
+    CMD="xcodebuild -IDECustomDerivedDataLocation=build/DerivedData $@ $REALM_EXTRA_BUILD_ARGUMENTS"
+    echo "Building with command:" $CMD
+    eval "$CMD"
+}
+
+xc() {
+    # Logs xcodebuild output in realtime
+    : ${NSUnbufferedIO:=YES}
+    if [[ "$XCMODE" == "xcodebuild" ]]; then
+        xcode "$@"
+    elif [[ "$XCMODE" == "xcpretty" ]]; then
+        mkdir -p build
+        xcode "$@" | tee build/build.log | xcpretty -c ${XCPRETTY_PARAMS} || {
+            echo "The raw xcodebuild output is available in build/build.log"
+            exit 1
+        }
+    elif [[ "$XCMODE" == "xctool" ]]; then
+        xctool "$@"
+    fi
+}
+
+copy_bcsymbolmap() {
+    find "$1" -name '*.bcsymbolmap' -type f -exec cp {} "$2" \;
+}
+
+build_combined() {
+    local scheme="$1"
+    local module_name="$2"
+    local os="$3"
+    local simulator="$4"
+    local scope_suffix="$5"
+    local version_suffix="$6"
+    local config="$CONFIGURATION"
+
+    local destination=""
+    local os_name=""
+    if [[ "$os" == "iphoneos" ]]; then
+        os_name="ios"
+        destination="iPhone 6"
+    elif [[ "$os" == "watchos"  ]]; then
+        os_name="$os"
+        destination="Apple Watch - 42mm"
+    elif [[ "$os" == "appletvos"  ]]; then
+        os_name="tvos"
+        destination="Apple TV 1080p"
+    fi
+
+    # Derive build paths
+    local build_products_path="build/DerivedData/Realm/Build/Products"
+    local product_name="$module_name.framework"
+    local binary_path="$module_name"
+    local os_path="$build_products_path/$config-$os$scope_suffix/$product_name"
+    local simulator_path="$build_products_path/$config-$simulator$scope_suffix/$product_name"
+    local out_path="build/$os_name$scope_suffix$version_suffix"
+
+    # Build for each platform
+    xc "-scheme '$scheme' -configuration $config -sdk $os"
+    xc "-scheme '$scheme' -configuration $config -sdk $simulator -destination 'name=$destination' ONLY_ACTIVE_ARCH=NO"
+
+    # Combine .swiftmodule
+    if [ -d $simulator_path/Modules/$module_name.swiftmodule ]; then
+      cp $simulator_path/Modules/$module_name.swiftmodule/* $os_path/Modules/$module_name.swiftmodule/
+    fi
+
+    # Copy *.bcsymbolmap to .framework for submitting app with bitcode
+    copy_bcsymbolmap "$build_products_path/$config-$os$scope_suffix" "$os_path"
+
+    # Retrieve build products
+    clean_retrieve $os_path $out_path $product_name
+
+    # Combine ar archives
+    LIPO_OUTPUT="$out_path/$product_name/$module_name"
+    xcrun lipo -create "$simulator_path/$binary_path" "$os_path/$binary_path" -output "$LIPO_OUTPUT"
+
+    if [[ "$destination" != "" && "$config" == "Release" ]]; then
+        sh build.sh binary-has-bitcode "$LIPO_OUTPUT"
+    fi
+}
+
+xc_work_around_rdar_23055637() {
+    # xcodebuild times out waiting for the iOS simulator to launch if it takes > 120 seconds for the tests to
+    # build (<http://openradar.appspot.com/23055637>). Work around this by having the test phases intentionally
+    # exit after they finish building the first time, then run the tests for real.
+    ( REALM_EXIT_AFTER_BUILDING_TESTS=YES xc "$1" ) || true
+    # Xcode 7.2.1 fails to run tests in the iOS simulator for unknown reasons. Resetting the simulator here works
+    # around this issue.
+    sh build.sh prelaunch-simulator
+    xc "$1"
+}
+
+clean_retrieve() {
+  mkdir -p "$2"
+  rm -rf "$2/$3"
+  cp -R "$1" "$2"
+}
+
+move_to_clean_dir() {
+    rm -rf "$2"
+    mkdir -p "$2"
+    mv "$1" "$2"
+}
+
+shutdown_simulators() {
+    # Shut down simulators until there's no booted ones left
+    # Only do one at a time because devices sometimes show up multiple times
+    while xcrun simctl list | grep -q Booted; do
+      xcrun simctl list | grep Booted | sed 's/.* (\(.*\)) (Booted)/\1/' | head -n 1 | xargs xcrun simctl shutdown
+    done
+}
+
+######################################
+# Device Test Helper
+######################################
+
+test_devices() {
+    serial_numbers_str=$(system_profiler SPUSBDataType | grep "Serial Number: ")
+    serial_numbers=()
+    while read -r line; do
+        number=${line:15} # Serial number starts at position 15
+        if [[ ${#number} == 40 ]]; then
+            serial_numbers+=("$number")
+        fi
+    done <<< "$serial_numbers_str"
+    if [[ ${#serial_numbers[@]} == 0 ]]; then
+        echo "At least one iOS/tvOS device must be connected to this computer to run device tests"
+        if [ -z "${JENKINS_HOME}" ]; then
+            # Don't fail if running locally and there's no device
+            exit 0
+        fi
+        exit 1
+    fi
+    local sdk="$1"
+    local scheme="$2"
+    local configuration="$3"
+    local failed=0
+    for device in "${serial_numbers[@]}"; do
+        xc "-scheme '$scheme' -configuration $configuration -destination 'id=$device' -sdk $sdk test" || failed=1
+    done
+    return $failed
+}
+
+######################################
+# Docs
+######################################
+
+build_docs() {
+    local language="$1"
+    local version=$(sh build.sh get-version)
+
+    local xcodebuild_arguments="--objc,Realm/Realm.h,--,-x,objective-c,-isysroot,$(xcrun --show-sdk-path),-I,$(pwd)"
+    local module="Realm"
+    local objc="--objc"
+
+    if [[ "$language" == "swift" ]]; then
+        : ${REALM_SWIFT_VERSION:=2.2}
+        sh build.sh set-swift-version
+        xcodebuild_arguments="-scheme,RealmSwift"
+        module="RealmSwift"
+        objc=""
+    fi
+
+    touch Realm/RLMPlatform.h # jazzy will fail if it can't find all public header files
+    jazzy \
+      ${objc} \
+      --swift-version 2.2 \
+      --clean \
+      --author Realm \
+      --author_url https://realm.io \
+      --github_url https://github.com/realm/realm-cocoa \
+      --github-file-prefix https://github.com/realm/realm-cocoa/tree/v${version} \
+      --module-version ${version} \
+      --xcodebuild-arguments ${xcodebuild_arguments} \
+      --module ${module} \
+      --root-url https://realm.io/docs/${language}/${version}/api/ \
+      --output docs/${language}_output \
+      --head "$(cat docs/custom_head.html)"
+
+    rm Realm/RLMPlatform.h
+}
+
+######################################
+# Input Validation
+######################################
+
+if [ "$#" -eq 0 -o "$#" -gt 3 ]; then
+    usage
+    exit 1
+fi
+
+######################################
+# Variables
+######################################
+
+download_core() {
+    echo "Downloading dependency: core ${REALM_CORE_VERSION}"
+    TMP_DIR="$TMPDIR/core_bin"
+    mkdir -p "${TMP_DIR}"
+    CORE_TMP_TAR="${TMP_DIR}/core-${REALM_CORE_VERSION}.tar.xz.tmp"
+    CORE_TAR="${TMP_DIR}/core-${REALM_CORE_VERSION}.tar.xz"
+    if [ ! -f "${CORE_TAR}" ]; then
+        local CORE_URL="https://static.realm.io/downloads/core/realm-core-${REALM_CORE_VERSION}.tar.xz"
+        set +e # temporarily disable immediate exit
+        local ERROR # sweeps the exit code unless declared separately
+        ERROR=$(curl --fail --silent --show-error --location "$CORE_URL" --output "${CORE_TMP_TAR}" 2>&1 >/dev/null)
+        if [[ $? -ne 0 ]]; then
+            echo "Downloading core failed:\n${ERROR}"
+            exit 1
+        fi
+        set -e # re-enable flag
+        mv "${CORE_TMP_TAR}" "${CORE_TAR}"
+    fi
+
+    (
+        cd "${TMP_DIR}"
+        rm -rf core
+        tar xf "${CORE_TAR}" --xz
+        mv core core-${REALM_CORE_VERSION}
+    )
+
+    rm -rf core-${REALM_CORE_VERSION} core
+    mv ${TMP_DIR}/core-${REALM_CORE_VERSION} .
+    ln -s core-${REALM_CORE_VERSION} core
+}
+
+COMMAND="$1"
+
+# Use Debug config if command ends with -debug, otherwise default to Release
+case "$COMMAND" in
+    *-debug)
+        COMMAND="${COMMAND%-debug}"
+        CONFIGURATION="Debug"
+        ;;
+    *) CONFIGURATION=${CONFIGURATION:-Release}
+esac
+export CONFIGURATION
+
+source "$(dirname "$0")/scripts/swift-version.sh"
+
+case "$COMMAND" in
+
+    ######################################
+    # Clean
+    ######################################
+    "clean")
+        find . -type d -name build -exec rm -r "{}" +\;
+        exit 0
+        ;;
+
+    ######################################
+    # Core
+    ######################################
+    "download-core")
+        if [ "$REALM_CORE_VERSION" = "current" ]; then
+            echo "Using version of core already in core/ directory"
+            exit 0
+        fi
+        if [ -d core -a -d ../realm-core -a ! -L core ]; then
+          # Allow newer versions than expected for local builds as testing
+          # with unreleased versions is one of the reasons to use a local build
+          if ! $(grep -i "${REALM_CORE_VERSION} Release notes" core/release_notes.txt >/dev/null); then
+              echo "Local build of core is out of date."
+              exit 1
+          else
+              echo "The core library seems to be up to date."
+          fi
+        elif ! [ -L core ]; then
+            echo "core is not a symlink. Deleting..."
+            rm -rf core
+            download_core
+        # With a prebuilt version we only want to check the first non-empty
+        # line so that checking out an older commit will download the
+        # appropriate version of core if the already-present version is too new
+        elif ! $(grep -m 1 . core/release_notes.txt | grep -i "${REALM_CORE_VERSION} RELEASE NOTES" >/dev/null); then
+            download_core
+        else
+            echo "The core library seems to be up to date."
+        fi
+        exit 0
+        ;;
+
+    ######################################
+    # Object Store
+    ######################################
+    "push-object-store-changes")
+        commit="$2"
+        path="$3"
+        if [ -z "$commit" -o -z "$path" ]; then
+            echo "usage: sh build.sh push-object-store-changes [base commit] [path to objectore repo]"
+            exit 1
+        fi
+
+        # List all commits since $commit which touched the objecstore, generate
+        # patches for each of them, and then apply those patches to the
+        # objectstore repo
+        git rev-list --reverse $commit..HEAD -- Realm/ObjectStore \
+            | xargs -I@ git format-patch --stdout @^! Realm/ObjectStore \
+            | git -C $path am -p 3 --directory src
+        ;;
+
+    "pull-object-store-changes")
+        commit="$2"
+        path="$3"
+        if [ -z "$commit" -o -z "$path" ]; then
+            echo "usage: sh build.sh pull-object-store-changes [base commit] [path to objectore repo]"
+            exit 1
+        fi
+
+        git -C $path format-patch --stdout $commit..HEAD src | git am -p 2 --directory Realm/ObjectStore --exclude='*CMake*' --reject
+        ;;
+
+    ######################################
+    # Swift versioning
+    ######################################
+    "set-swift-version")
+        version="$2"
+        if [[ -z "$version" ]]; then
+            version="$REALM_SWIFT_VERSION"
+        fi
+
+        SWIFT_VERSION_FILE="RealmSwift/SwiftVersion.swift"
+        CONTENTS="let swiftLanguageVersion = \"$version\""
+        if [ ! -f "$SWIFT_VERSION_FILE" ] || ! grep -q "$CONTENTS" "$SWIFT_VERSION_FILE"; then
+            echo "$CONTENTS" > "$SWIFT_VERSION_FILE"
+        fi
+
+        exit 0
+        ;;
+
+    "prelaunch-simulator")
+        sh $(dirname $0)/scripts/reset-simulators.sh
+        ;;
+
+    ######################################
+    # Building
+    ######################################
+    "build")
+        sh build.sh ios-static
+        sh build.sh ios-dynamic
+        sh build.sh ios-swift
+        sh build.sh watchos
+        sh build.sh watchos-swift
+        sh build.sh tvos
+        sh build.sh tvos-swift
+        sh build.sh osx
+        sh build.sh osx-swift
+        exit 0
+        ;;
+
+    "ios-static")
+        build_combined 'Realm iOS static' Realm iphoneos iphonesimulator "-static"
+        exit 0
+        ;;
+
+    "ios-dynamic")
+        build_combined Realm Realm iphoneos iphonesimulator
+        exit 0
+        ;;
+
+    "ios-swift")
+        sh build.sh ios-dynamic
+        build_combined RealmSwift RealmSwift iphoneos iphonesimulator '' "/swift-$REALM_SWIFT_VERSION"
+        cp -R build/ios/Realm.framework build/ios/swift-$REALM_SWIFT_VERSION
+        exit 0
+        ;;
+
+    "watchos")
+        build_combined Realm Realm watchos watchsimulator
+        exit 0
+        ;;
+
+    "watchos-swift")
+        sh build.sh watchos
+        build_combined RealmSwift RealmSwift watchos watchsimulator
+        exit 0
+        ;;
+
+    "tvos")
+        build_combined Realm Realm appletvos appletvsimulator
+        exit 0
+        ;;
+
+    "tvos-swift")
+        sh build.sh tvos
+        build_combined RealmSwift RealmSwift appletvos appletvsimulator
+        exit 0
+        ;;
+
+    "osx")
+        xc "-scheme Realm -configuration $CONFIGURATION"
+        rm -rf build/osx
+        mkdir build/osx
+        cp -R build/DerivedData/Realm/Build/Products/$CONFIGURATION/Realm.framework build/osx
+        exit 0
+        ;;
+
+    "osx-swift")
+        sh build.sh osx
+        xc "-scheme 'RealmSwift' -configuration $CONFIGURATION build"
+        destination="build/osx/swift-$REALM_SWIFT_VERSION"
+        clean_retrieve "build/DerivedData/Realm/Build/Products/$CONFIGURATION/RealmSwift.framework" "$destination" "RealmSwift.framework"
+        cp -R build/osx/Realm.framework "$destination"
+        exit 0
+        ;;
+
+    ######################################
+    # Analysis
+    ######################################
+
+    "analyze-osx")
+        xc "-scheme Realm -configuration $CONFIGURATION analyze"
+        exit 0
+        ;;
+
+    ######################################
+    # Testing
+    ######################################
+    "test")
+        set +e # Run both sets of tests even if the first fails
+        failed=0
+        sh build.sh test-ios-static || failed=1
+        sh build.sh test-ios-dynamic || failed=1
+        sh build.sh test-ios-swift || failed=1
+        sh build.sh test-ios-devices || failed=1
+        sh build.sh test-tvos-devices || failed=1
+        sh build.sh test-osx || failed=1
+        sh build.sh test-osx-swift || failed=1
+        exit $failed
+        ;;
+
+    "test-all")
+        set +e
+        failed=0
+        sh build.sh test || failed=1
+        sh build.sh test-debug || failed=1
+        exit $failed
+        ;;
+
+    "test-ios-static")
+        xc_work_around_rdar_23055637 "-scheme 'Realm iOS static' -configuration $CONFIGURATION -sdk iphonesimulator -destination 'name=iPhone 6' test"
+        shutdown_simulators
+        xc_work_around_rdar_23055637 "-scheme 'Realm iOS static' -configuration $CONFIGURATION -sdk iphonesimulator -destination 'name=iPhone 4s' test"
+        exit 0
+        ;;
+
+    "test-ios7-static")
+        xc_work_around_rdar_23055637 "-scheme 'Realm iOS static' -configuration $CONFIGURATION -sdk iphonesimulator -destination 'name=iPhone 5S,OS=7.1' test"
+        shutdown_simulators
+        xc_work_around_rdar_23055637 "-scheme 'Realm iOS static' -configuration $CONFIGURATION -sdk iphonesimulator -destination 'name=iPhone 4s,OS=7.1' test"
+        exit 0
+        ;;
+
+    "test-ios-dynamic")
+        xc_work_around_rdar_23055637 "-scheme Realm -configuration $CONFIGURATION -sdk iphonesimulator -destination 'name=iPhone 6' test"
+        shutdown_simulators
+        xc_work_around_rdar_23055637 "-scheme Realm -configuration $CONFIGURATION -sdk iphonesimulator -destination 'name=iPhone 4s' test"
+        exit 0
+        ;;
+
+    "test-ios-swift")
+        xc_work_around_rdar_23055637 "-scheme RealmSwift -configuration $CONFIGURATION -sdk iphonesimulator -destination 'name=iPhone 6' build test"
+        shutdown_simulators
+        xc_work_around_rdar_23055637 "-scheme RealmSwift -configuration $CONFIGURATION -sdk iphonesimulator -destination 'name=iPhone 4s' build test"
+        exit 0
+        ;;
+
+    "test-ios-devices")
+        failed=0
+        trap "failed=1" ERR
+        sh build.sh test-ios-devices-objc
+        sh build.sh test-ios-devices-swift
+        exit $failed
+        ;;
+
+    "test-ios-devices-objc")
+        test_devices iphoneos "Realm iOS static" "$CONFIGURATION"
+        exit $?
+        ;;
+
+    "test-ios-devices-swift")
+        test_devices iphoneos "RealmSwift" "$CONFIGURATION"
+        exit $?
+        ;;
+
+    "test-tvos")
+        xc_work_around_rdar_23055637 "-scheme Realm -configuration $CONFIGURATION -sdk appletvsimulator -destination 'name=Apple TV 1080p' test"
+        exit $?
+        ;;
+
+    "test-tvos-swift")
+        xc_work_around_rdar_23055637 "-scheme RealmSwift -configuration $CONFIGURATION -sdk appletvsimulator -destination 'name=Apple TV 1080p' test"
+        exit $?
+        ;;
+
+    "test-tvos-devices")
+        test_devices appletvos TestHost "$CONFIGURATION"
+        ;;
+
+    "test-osx")
+        COVERAGE_PARAMS=""
+        if [[ "$CONFIGURATION" == "Debug" ]]; then
+            COVERAGE_PARAMS="GCC_GENERATE_TEST_COVERAGE_FILES=YES GCC_INSTRUMENT_PROGRAM_FLOW_ARCS=YES"
+        fi
+        xc "-scheme Realm -configuration $CONFIGURATION test $COVERAGE_PARAMS"
+        exit 0
+        ;;
+
+    "test-osx-swift")
+        xc "-scheme RealmSwift -configuration $CONFIGURATION test"
+        exit 0
+        ;;
+
+    ######################################
+    # Full verification
+    ######################################
+    "verify")
+        sh build.sh verify-cocoapods
+        sh build.sh verify-docs
+        sh build.sh verify-osx
+        sh build.sh verify-osx-debug
+        sh build.sh verify-osx-swift
+        sh build.sh verify-osx-swift-debug
+        sh build.sh verify-ios-static
+        sh build.sh verify-ios-static-debug
+        sh build.sh verify-ios7-static
+        sh build.sh verify-ios7-static-debug
+        sh build.sh verify-ios-dynamic
+        sh build.sh verify-ios-dynamic-debug
+        sh build.sh verify-ios-swift
+        sh build.sh verify-ios-swift-debug
+        sh build.sh verify-ios-device-objc
+        sh build.sh verify-ios-device-swift
+        sh build.sh verify-watchos
+        sh build.sh verify-tvos
+        sh build.sh verify-tvos-debug
+        sh build.sh verify-tvos-device
+        sh build.sh verify-swiftlint
+        ;;
+
+    "verify-cocoapods")
+        if [[ -d .git ]]; then
+          # Verify the current branch, unless one was already specified in the sha environment variable.
+          if [[ -z $sha ]]; then
+            export sha=$(git rev-parse --abbrev-ref HEAD)
+          fi
+
+          if [[ $(git log -1 @{push}..) != "" ]] || ! git diff-index --quiet HEAD; then
+            echo "WARNING: verify-cocoapods will test the latest revision of $sha found on GitHub."
+            echo "         Any unpushed local changes will not be tested."
+            echo ""
+            sleep 1
+          fi
+        fi
+
+        cd examples/installation
+        sh build.sh test-ios-objc-cocoapods
+        sh build.sh test-ios-objc-cocoapods-dynamic
+        sh build.sh test-ios-swift-cocoapods
+        sh build.sh test-osx-objc-cocoapods
+        sh build.sh test-osx-swift-cocoapods
+        sh build.sh test-watchos-objc-cocoapods
+        sh build.sh test-watchos-swift-cocoapods
+        ;;
+
+    "verify-osx-encryption")
+        REALM_ENCRYPT_ALL=YES sh build.sh test-osx
+        exit 0
+        ;;
+
+    "verify-osx")
+        sh build.sh test-osx
+        sh build.sh analyze-osx
+        sh build.sh examples-osx
+
+        (
+            cd examples/osx/objc/build/DerivedData/RealmExamples/Build/Products/$CONFIGURATION
+            DYLD_FRAMEWORK_PATH=. ./JSONImport >/dev/null
+        )
+        exit 0
+        ;;
+
+    "verify-osx-swift")
+        sh build.sh test-osx-swift
+        exit 0
+        ;;
+
+    "verify-ios-static")
+        sh build.sh test-ios-static
+        sh build.sh examples-ios
+        ;;
+
+    "verify-ios7-static")
+        sh build.sh test-ios7-static
+        ;;
+
+    "verify-ios-dynamic")
+        sh build.sh test-ios-dynamic
+        ;;
+
+    "verify-ios-swift")
+        sh build.sh test-ios-swift
+        sh build.sh examples-ios-swift
+        ;;
+
+    "verify-ios-device-objc")
+        sh build.sh test-ios-devices-objc
+        exit 0
+        ;;
+
+    "verify-ios-device-swift")
+        sh build.sh test-ios-devices-swift
+        exit 0
+        ;;
+
+    "verify-docs")
+        sh build.sh docs
+        for lang in swift objc; do
+            undocumented="docs/${lang}_output/undocumented.json"
+            if ! cat "$undocumented" | grep '"warnings":\[\]' > /dev/null 2>&1; then
+              echo "Undocumented Realm $lang declarations:"
+              cat "$undocumented"
+              exit 1
+            fi
+        done
+        exit 0
+        ;;
+
+    "verify-watchos")
+        sh build.sh watchos-swift
+        exit 0
+        ;;
+
+    "verify-tvos")
+        sh build.sh test-tvos
+        sh build.sh test-tvos-swift
+        sh build.sh examples-tvos
+        sh build.sh examples-tvos-swift
+        exit 0
+        ;;
+
+    "verify-tvos-device")
+        sh build.sh test-tvos-devices
+        exit 0
+        ;;
+
+    "verify-swiftlint")
+        swiftlint lint --strict
+        exit 0
+        ;;
+
+    ######################################
+    # Docs
+    ######################################
+    "docs")
+        build_docs objc
+        build_docs swift
+        exit 0
+        ;;
+
+    ######################################
+    # Examples
+    ######################################
+    "examples")
+        sh build.sh clean
+        sh build.sh examples-ios
+        sh build.sh examples-ios-swift
+        sh build.sh examples-osx
+        sh build.sh examples-tvos
+        sh build.sh examples-tvos-swift
+        exit 0
+        ;;
+
+    "examples-ios")
+        sh build.sh prelaunch-simulator
+        if [[ -d "examples/ios/objc" ]]; then
+            workspace="examples/ios/objc/RealmExamples.xcworkspace"
+        else
+            workspace="examples/ios/xcode-7/objc/RealmExamples.xcworkspace"
+        fi
+        pod install --project-directory="$workspace/.." --no-repo-update
+        xc "-workspace $workspace -scheme Simple -configuration $CONFIGURATION -destination 'name=iPhone 6' build ${CODESIGN_PARAMS}"
+        xc "-workspace $workspace -scheme TableView -configuration $CONFIGURATION -destination 'name=iPhone 6' build ${CODESIGN_PARAMS}"
+        xc "-workspace $workspace -scheme Migration -configuration $CONFIGURATION -destination 'name=iPhone 6' build ${CODESIGN_PARAMS}"
+        xc "-workspace $workspace -scheme Backlink -configuration $CONFIGURATION -destination 'name=iPhone 6' build ${CODESIGN_PARAMS}"
+        xc "-workspace $workspace -scheme GroupedTableView -configuration $CONFIGURATION -destination 'name=iPhone 6' build ${CODESIGN_PARAMS}"
+        xc "-workspace $workspace -scheme RACTableView -configuration $CONFIGURATION -destination 'name=iPhone 6' build ${CODESIGN_PARAMS}"
+        xc "-workspace $workspace -scheme Encryption -configuration $CONFIGURATION -destination 'name=iPhone 6' build ${CODESIGN_PARAMS}"
+
+        if [ ! -z "${JENKINS_HOME}" ]; then
+            xc "-workspace $workspace -scheme Extension -configuration $CONFIGURATION -destination 'name=iPhone 6' build ${CODESIGN_PARAMS}"
+        fi
+
+        exit 0
+        ;;
+
+    "examples-ios-swift")
+        sh build.sh prelaunch-simulator
+        workspace="examples/ios/swift-$REALM_SWIFT_VERSION/RealmExamples.xcworkspace"
+        pod install --project-directory="$workspace/.." --no-repo-update
+        xc "-workspace $workspace -scheme Simple -configuration $CONFIGURATION -destination 'name=iPhone 6' build ${CODESIGN_PARAMS}"
+        xc "-workspace $workspace -scheme TableView -configuration $CONFIGURATION -destination 'name=iPhone 6' build ${CODESIGN_PARAMS}"
+        xc "-workspace $workspace -scheme Migration -configuration $CONFIGURATION -destination 'name=iPhone 6' build ${CODESIGN_PARAMS}"
+        xc "-workspace $workspace -scheme Encryption -configuration $CONFIGURATION -destination 'name=iPhone 6' build ${CODESIGN_PARAMS}"
+        xc "-workspace $workspace -scheme Backlink -configuration $CONFIGURATION -destination 'name=iPhone 6' build ${CODESIGN_PARAMS}"
+        xc "-workspace $workspace -scheme GroupedTableView -configuration $CONFIGURATION -destination 'name=iPhone 6' build ${CODESIGN_PARAMS}"
+        xc "-workspace $workspace -scheme ReactKitTableView -configuration $CONFIGURATION -destination 'name=iPhone 6' build ${CODESIGN_PARAMS}"
+        exit 0
+        ;;
+
+    "examples-osx")
+        xc "-workspace examples/osx/objc/RealmExamples.xcworkspace -scheme JSONImport -configuration ${CONFIGURATION} build ${CODESIGN_PARAMS}"
+        ;;
+
+    "examples-tvos")
+        workspace="examples/tvos/objc/RealmExamples.xcworkspace"
+        xc "-workspace $workspace -scheme DownloadCache -configuration $CONFIGURATION -destination 'name=Apple TV 1080p' build ${CODESIGN_PARAMS}"
+        xc "-workspace $workspace -scheme PreloadedData -configuration $CONFIGURATION -destination 'name=Apple TV 1080p' build ${CODESIGN_PARAMS}"
+        exit 0
+        ;;
+
+    "examples-tvos-swift")
+        workspace="examples/tvos/swift/RealmExamples.xcworkspace"
+        xc "-workspace $workspace -scheme DownloadCache -configuration $CONFIGURATION -destination 'name=Apple TV 1080p' build ${CODESIGN_PARAMS}"
+        xc "-workspace $workspace -scheme PreloadedData -configuration $CONFIGURATION -destination 'name=Apple TV 1080p' build ${CODESIGN_PARAMS}"
+        exit 0
+        ;;
+
+    ######################################
+    # Versioning
+    ######################################
+    "get-version")
+        version_file="Realm/Realm-Info.plist"
+        echo "$(PlistBuddy -c "Print :CFBundleVersion" "$version_file")"
+        exit 0
+        ;;
+
+    "set-version")
+        realm_version="$2"
+        version_files="Realm/Realm-Info.plist"
+
+        if [ -z "$realm_version" ]; then
+            echo "You must specify a version."
+            exit 1
+        fi
+        for version_file in $version_files; do
+            PlistBuddy -c "Set :CFBundleVersion $realm_version" "$version_file"
+            PlistBuddy -c "Set :CFBundleShortVersionString $realm_version" "$version_file"
+        done
+        exit 0
+        ;;
+
+    ######################################
+    # Bitcode Detection
+    ######################################
+
+    "binary-has-bitcode")
+        BINARY="$2"
+        # Although grep has a '-q' flag to prevent logging to stdout, grep
+        # behaves differently when used, so redirect stdout to /dev/null.
+        if otool -l "$BINARY" | grep "segname __LLVM" > /dev/null 2>&1; then
+            exit 0
+        fi
+        # Work around rdar://21826157 by checking for bitcode in thin binaries
+
+        # Get architectures for binary
+        archs="$(lipo -info "$BINARY" | rev | cut -d ':' -f1 | rev)"
+
+        archs_array=( $archs )
+        if [[ ${#archs_array[@]} < 2 ]]; then
+            exit 1 # Early exit if not a fat binary
+        fi
+
+        TEMPDIR=$(mktemp -d $TMPDIR/realm-bitcode-check.XXXX)
+
+        for arch in $archs; do
+            lipo -thin "$arch" "$BINARY" -output "$TEMPDIR/$arch"
+            if otool -l "$TEMPDIR/$arch" | grep -q "segname __LLVM"; then
+                exit 0
+            fi
+        done
+        exit 1
+        ;;
+
+    ######################################
+    # CocoaPods
+    ######################################
+    "cocoapods-setup")
+        if [ ! -d core ]; then
+          sh build.sh download-core
+          rm core
+          mv core-* core
+        fi
+
+        if [[ "$2" != "swift" ]]; then
+          rm -rf include
+          mkdir -p include
+          mv core/include include/core
+
+          mkdir -p include/impl/apple
+          mkdir -p include/util
+          cp Realm/*.hpp include
+          cp Realm/ObjectStore/*.hpp include
+          cp Realm/ObjectStore/impl/*.hpp include/impl
+          cp Realm/ObjectStore/impl/apple/*.hpp include/impl/apple
+          cp Realm/ObjectStore/util/*.hpp include/util
+
+          touch Realm/RLMPlatform.h
+          if [ -n "$COCOAPODS_VERSION" ]; then
+            # This variable is set for the prepare_command available
+            # from the 1.0 prereleases, which requires a different
+            # header layout within the header_mappings_dir.
+            cp Realm/*.h include
+          else
+            # For CocoaPods < 1.0, we need to scope the headers within
+            # the header_mappings_dir by another subdirectory to avoid
+            # Clang from complaining about non-modular headers.
+            mkdir -p include/Realm
+            cp Realm/*.h include/Realm
+          fi
+        else
+          sh build.sh set-swift-version
+        fi
+        ;;
+
+    ######################################
+    # Continuous Integration
+    ######################################
+
+    "ci-pr")
+        mkdir -p build/reports
+
+        if [ "$target" = "docs" ]; then
+            sh build.sh set-swift-version
+            sh build.sh verify-docs
+        elif [ "$target" = "swiftlint" ]; then
+            sh build.sh verify-swiftlint
+        else
+            export sha=$ghprbSourceBranch
+            export REALM_SWIFT_VERSION=$swift_version
+            export CONFIGURATION=$configuration
+            export REALM_EXTRA_BUILD_ARGUMENTS='GCC_GENERATE_DEBUGGING_SYMBOLS=NO REALM_PREFIX_HEADER=Realm/RLMPrefix.h'
+            sh build.sh prelaunch-simulator
+            # Verify that no Realm files still exist
+            ! find ~/Library/Developer/CoreSimulator/Devices/ -name '*.realm' | grep -q .
+
+            sh build.sh verify-$target | tee build/build.log | xcpretty -r junit -o build/reports/junit.xml || \
+                (echo "\n\n***\nbuild/build.log\n***\n\n" && cat build/build.log && exit 1)
+        fi
+
+        if [ "$target" = "osx" ] && [ "$configuration" = "Debug" ]; then
+          gcovr -r . -f ".*Realm.*" -e ".*Tests.*" -e ".*core.*" --xml > build/reports/coverage-report.xml
+          WS=$(pwd | sed "s/\//\\\\\//g")
+          sed -i ".bak" "s/<source>\./<source>${WS}/" build/reports/coverage-report.xml
+        fi
+        ;;
+
+    ######################################
+    # Release packaging
+    ######################################
+
+    "package-examples")
+        cd tightdb_objc
+        ./scripts/package_examples.rb
+        zip --symlinks -r realm-examples.zip examples -x "examples/installation/*"
+        ;;
+
+    "package-test-examples")
+        if ! VERSION=$(echo realm-objc-*.zip | grep -o '\d*\.\d*\.\d*-[a-z]*'); then
+            VERSION=$(echo realm-objc-*.zip | grep -o '\d*\.\d*\.\d*')
+        fi
+        OBJC="realm-objc-${VERSION}"
+        SWIFT="realm-swift-${VERSION}"
+        unzip ${OBJC}.zip
+
+        cp $0 ${OBJC}
+        cp -r $(dirname $0)/scripts ${OBJC}
+        cd ${OBJC}
+        sh build.sh examples-ios
+        sh build.sh examples-osx
+        cd ..
+        rm -rf ${OBJC}
+
+        unzip ${SWIFT}.zip
+
+        cp $0 ${SWIFT}
+        cp -r $(dirname $0)/scripts ${SWIFT}
+        cd ${SWIFT}
+        sh build.sh examples-ios-swift
+        cd ..
+        rm -rf ${SWIFT}
+        ;;
+
+    "package-ios-static")
+        cd tightdb_objc
+
+        sh build.sh prelaunch-simulator
+        sh build.sh test-ios-static
+        sh build.sh ios-static
+        move_to_clean_dir build/ios-static/Realm.framework xcode-7
+
+        zip --symlinks -r build/ios-static/realm-framework-ios.zip xcode-7
+        ;;
+
+    "package-ios-dynamic")
+        cd tightdb_objc
+
+        sh build.sh prelaunch-simulator
+        sh build.sh ios-dynamic
+        move_to_clean_dir build/ios/Realm.framework xcode-7
+
+        zip --symlinks -r build/ios/realm-dynamic-framework-ios.zip xcode-7
+        ;;
+
+    "package-osx")
+        cd tightdb_objc
+        sh build.sh test-osx
+
+        cd build/DerivedData/Realm/Build/Products/Release
+        zip --symlinks -r realm-framework-osx.zip Realm.framework
+        ;;
+
+    "package-ios-swift")
+        cd tightdb_objc
+        rm -rf build/ios/Realm.framework
+        sh build.sh prelaunch-simulator
+        sh build.sh ios-swift
+
+        cd build/ios
+        zip --symlinks -r realm-swift-framework-ios.zip swift-2.2
+        ;;
+
+    "package-osx-swift")
+        cd tightdb_objc
+        sh build.sh osx-swift
+
+        cd build/osx
+        zip --symlinks -r realm-swift-framework-osx.zip swift-2.2
+        ;;
+
+    "package-watchos")
+        cd tightdb_objc
+        sh build.sh watchos
+
+        cd build/watchos
+        zip --symlinks -r realm-framework-watchos.zip Realm.framework
+        ;;
+
+    "package-watchos-swift")
+        cd tightdb_objc
+        sh build.sh watchos-swift
+
+        cd build/watchos
+        zip --symlinks -r realm-swift-framework-watchos.zip RealmSwift.framework Realm.framework
+        ;;
+
+    "package-tvos")
+        cd tightdb_objc
+        sh build.sh tvos
+
+        cd build/tvos
+        zip --symlinks -r realm-framework-tvos.zip Realm.framework
+        ;;
+
+    "package-tvos-swift")
+        cd tightdb_objc
+        sh build.sh tvos-swift
+
+        cd build/tvos
+        zip --symlinks -r realm-swift-framework-tvos.zip RealmSwift.framework Realm.framework
+        ;;
+
+    "package-release")
+        LANG="$2"
+        TEMPDIR=$(mktemp -d $TMPDIR/realm-release-package-${LANG}.XXXX)
+
+        cd tightdb_objc
+        VERSION=$(sh build.sh get-version)
+        cd ..
+
+        FOLDER=${TEMPDIR}/realm-${LANG}-${VERSION}
+
+        mkdir -p ${FOLDER}/osx ${FOLDER}/ios ${FOLDER}/watchos ${FOLDER}/tvos
+
+        if [[ "${LANG}" == "objc" ]]; then
+            mkdir -p ${FOLDER}/ios/static
+            mkdir -p ${FOLDER}/ios/dynamic
+            mkdir -p ${FOLDER}/Swift
+
+            (
+                cd ${FOLDER}/osx
+                unzip ${WORKSPACE}/realm-framework-osx.zip
+            )
+
+            (
+                cd ${FOLDER}/ios/static
+                unzip ${WORKSPACE}/realm-framework-ios.zip
+            )
+
+            (
+                cd ${FOLDER}/ios/dynamic
+                unzip ${WORKSPACE}/realm-dynamic-framework-ios.zip
+            )
+
+            (
+                cd ${FOLDER}/watchos
+                unzip ${WORKSPACE}/realm-framework-watchos.zip
+            )
+
+            (
+                cd ${FOLDER}/tvos
+                unzip ${WORKSPACE}/realm-framework-tvos.zip
+            )
+        else
+            (
+                cd ${FOLDER}/osx
+                unzip ${WORKSPACE}/realm-swift-framework-osx.zip
+            )
+
+            (
+                cd ${FOLDER}/ios
+                unzip ${WORKSPACE}/realm-swift-framework-ios.zip
+            )
+
+            (
+                cd ${FOLDER}/watchos
+                unzip ${WORKSPACE}/realm-swift-framework-watchos.zip
+            )
+
+            (
+                cd ${FOLDER}/tvos
+                unzip ${WORKSPACE}/realm-swift-framework-tvos.zip
+            )
+        fi
+
+        (
+            cd ${WORKSPACE}/tightdb_objc
+            cp -R plugin ${FOLDER}
+            cp LICENSE ${FOLDER}/LICENSE.txt
+            if [[ "${LANG}" == "objc" ]]; then
+                cp Realm/Swift/RLMSupport.swift ${FOLDER}/Swift/
+            fi
+        )
+
+        (
+            cd ${FOLDER}
+            unzip ${WORKSPACE}/realm-examples.zip
+            cd examples
+            if [[ "${LANG}" == "objc" ]]; then
+                rm -rf ios/swift-2.2
+            else
+                rm -rf ios/objc ios/rubymotion osx
+            fi
+        )
+
+        cat > ${FOLDER}/docs.webloc <<EOF
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+    <key>URL</key>
+    <string>https://realm.io/docs/${LANG}/${VERSION}</string>
+</dict>
+</plist>
+EOF
+
+        (
+          cd ${TEMPDIR}
+          zip --symlinks -r realm-${LANG}-${VERSION}.zip realm-${LANG}-${VERSION}
+          mv realm-${LANG}-${VERSION}.zip ${WORKSPACE}
+        )
+        ;;
+
+    "test-package-release")
+        # Generate a release package locally for testing purposes
+        # Real releases should always be done via Jenkins
+        if [ -z "${WORKSPACE}" ]; then
+            echo 'WORKSPACE must be set to a directory to assemble the release in'
+            exit 1
+        fi
+        if [ -d "${WORKSPACE}" ]; then
+            echo 'WORKSPACE directory should not already exist'
+            exit 1
+        fi
+
+        REALM_SOURCE="$(pwd)"
+        mkdir -p "$WORKSPACE"
+        WORKSPACE="$(cd "$WORKSPACE" && pwd)"
+        export WORKSPACE
+        cd $WORKSPACE
+        git clone $REALM_SOURCE tightdb_objc
+
+        echo 'Packaging iOS static'
+        sh tightdb_objc/build.sh package-ios-static
+        cp tightdb_objc/build/ios-static/realm-framework-ios.zip .
+
+        echo 'Packaging iOS dynamic'
+        sh tightdb_objc/build.sh package-ios-dynamic
+        cp tightdb_objc/build/ios/realm-dynamic-framework-ios.zip .
+
+        echo 'Packaging OS X'
+        sh tightdb_objc/build.sh package-osx
+        cp tightdb_objc/build/DerivedData/Realm/Build/Products/Release/realm-framework-osx.zip .
+
+        echo 'Packaging examples'
+        (
+            cd tightdb_objc/examples
+            git clean -xfd
+        )
+        sh tightdb_objc/build.sh package-examples
+        cp tightdb_objc/realm-examples.zip .
+
+        echo 'Packaging iOS Swift'
+        sh tightdb_objc/build.sh package-ios-swift
+        cp tightdb_objc/build/ios/realm-swift-framework-ios.zip .
+
+        echo 'Packaging OS X Swift'
+        sh tightdb_objc/build.sh package-osx-swift
+        cp tightdb_objc/build/osx/realm-swift-framework-osx.zip .
+
+        echo 'Packaging watchOS'
+        sh tightdb_objc/build.sh package-watchos
+        sh tightdb_objc/build.sh package-watchos-swift
+        cp tightdb_objc/build/watchos/realm-swift-framework-watchos.zip .
+        cp tightdb_objc/build/watchos/realm-framework-watchos.zip .
+
+        echo 'Packaging tvOS'
+        sh tightdb_objc/build.sh package-tvos
+        sh tightdb_objc/build.sh package-tvos-swift
+        cp tightdb_objc/build/tvos/realm-swift-framework-tvos.zip .
+        cp tightdb_objc/build/tvos/realm-framework-tvos.zip .
+
+        echo 'Building final release packages'
+        sh tightdb_objc/build.sh package-release objc
+        sh tightdb_objc/build.sh package-release swift
+
+        echo 'Testing packaged examples'
+        sh tightdb_objc/build.sh package-test-examples
+
+        ;;
+
+    "github-release")
+        if [ -z "${GITHUB_ACCESS_TOKEN}" ]; then
+            echo 'GITHUB_ACCESS_TOKEN must be set to create GitHub releases'
+            exit 1
+        fi
+        ./scripts/github_release.rb
+        ;;
+
+    "add-empty-changelog")
+        empty_section=$(cat <<EOS
+x.x.x Release notes (yyyy-MM-dd)
+=============================================================
+
+### API breaking changes
+
+* None.
+
+### Enhancements
+
+* None.
+
+### Bugfixes
+
+* None.
+EOS)
+        changelog=$(cat CHANGELOG.md)
+        echo "$empty_section" > CHANGELOG.md
+        echo >> CHANGELOG.md
+        echo "$changelog" >> CHANGELOG.md
+        ;;
+
+    *)
+        echo "Unknown command '$COMMAND'"
+        usage
+        exit 1
+        ;;
+esac
diff --git a/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016-acknowledgements.markdown b/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016-acknowledgements.markdown
index 0fa66f5..ea33c43 100644
--- a/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016-acknowledgements.markdown	
+++ b/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016-acknowledgements.markdown	
@@ -34,6 +34,552 @@ The original TCP version (AsyncSocket) was created by Dustin Voss in January 200
 Updated and maintained by Deusty LLC and the Apple development community.
 
 
+## Realm
+
+TABLE OF CONTENTS
+
+1. Apache License version 2.0
+2. Realm Components
+3. Export Compliance
+
+-------------------------------------------------------------------------------
+
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "{}"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright {yyyy} {name of copyright owner}
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+
+REALM COMPONENTS
+
+This software contains components with separate copyright and license terms.
+Your use of these components is subject to the terms and conditions of the
+following licenses.
+
+For the Realm Core component
+
+  Realm Core Binary License
+
+  Copyright (c) 2011-2014 Realm Inc All rights reserved
+
+  Redistribution and use in binary form, with or without modification, is
+  permitted provided that the following conditions are met:
+
+  1. You agree not to attempt to decompile, disassemble, reverse engineer or
+  otherwise discover the source code from which the binary code was derived.
+  You may, however, access and obtain a separate license for most of the
+  source code from which this Software was created, at
+  http://realm.io/pricing/.
+
+  2. Redistributions in binary form must reproduce the above copyright notice,
+  this list of conditions and the following disclaimer in the documentation
+  and/or other materials provided with the distribution.
+
+  3. Neither the name of the copyright holder nor the names of its
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+  POSSIBILITY OF SUCH DAMAGE.
+
+EXPORT COMPLIANCE
+
+You understand that the Software may contain cryptographic functions that may be
+subject to export restrictions, and you represent and warrant that you are not
+located in a country that is subject to United States export restriction or embargo,
+including Cuba, Iran, North Korea, Sudan, Syria or the Crimea region, and that you
+are not on the Department of Commerce list of Denied Persons, Unverified Parties,
+or affiliated with a Restricted Entity.
+
+You agree to comply with all export, re-export and import restrictions and
+regulations of the Department of Commerce or other agency or authority of the
+United States or other applicable countries. You also agree not to transfer, or
+authorize the transfer of, directly or indirectly, the Software to any prohibited
+country, including Cuba, Iran, North Korea, Sudan, Syria or the Crimea region,
+or to any person or organization on or affiliated with the Department of
+Commerce lists of Denied Persons, Unverified Parties or Restricted Entities, or
+otherwise in violation of any such restrictions or regulations.
+
+
+## RealmSwift
+
+TABLE OF CONTENTS
+
+1. Apache License version 2.0
+2. Realm Components
+3. Export Compliance
+
+-------------------------------------------------------------------------------
+
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "{}"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright {yyyy} {name of copyright owner}
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+
+REALM COMPONENTS
+
+This software contains components with separate copyright and license terms.
+Your use of these components is subject to the terms and conditions of the
+following licenses.
+
+For the Realm Core component
+
+  Realm Core Binary License
+
+  Copyright (c) 2011-2014 Realm Inc All rights reserved
+
+  Redistribution and use in binary form, with or without modification, is
+  permitted provided that the following conditions are met:
+
+  1. You agree not to attempt to decompile, disassemble, reverse engineer or
+  otherwise discover the source code from which the binary code was derived.
+  You may, however, access and obtain a separate license for most of the
+  source code from which this Software was created, at
+  http://realm.io/pricing/.
+
+  2. Redistributions in binary form must reproduce the above copyright notice,
+  this list of conditions and the following disclaimer in the documentation
+  and/or other materials provided with the distribution.
+
+  3. Neither the name of the copyright holder nor the names of its
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+  POSSIBILITY OF SUCH DAMAGE.
+
+EXPORT COMPLIANCE
+
+You understand that the Software may contain cryptographic functions that may be
+subject to export restrictions, and you represent and warrant that you are not
+located in a country that is subject to United States export restriction or embargo,
+including Cuba, Iran, North Korea, Sudan, Syria or the Crimea region, and that you
+are not on the Department of Commerce list of Denied Persons, Unverified Parties,
+or affiliated with a Restricted Entity.
+
+You agree to comply with all export, re-export and import restrictions and
+regulations of the Department of Commerce or other agency or authority of the
+United States or other applicable countries. You also agree not to transfer, or
+authorize the transfer of, directly or indirectly, the Software to any prohibited
+country, including Cuba, Iran, North Korea, Sudan, Syria or the Crimea region,
+or to any person or organization on or affiliated with the Department of
+Commerce lists of Denied Persons, Unverified Parties or Restricted Entities, or
+otherwise in violation of any such restrictions or regulations.
+
+
 ## SWXMLHash
 
 Copyright (c) 2014 David Mohundro
diff --git a/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016-acknowledgements.plist b/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016-acknowledgements.plist
index bb3fd6f..8f0c423 100644
--- a/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016-acknowledgements.plist	
+++ b/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016-acknowledgements.plist	
@@ -55,6 +55,560 @@ Updated and maintained by Deusty LLC and the Apple development community.
 		</dict>
 		<dict>
 			<key>FooterText</key>
+			<string>TABLE OF CONTENTS
+
+1. Apache License version 2.0
+2. Realm Components
+3. Export Compliance
+
+-------------------------------------------------------------------------------
+
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "{}"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright {yyyy} {name of copyright owner}
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+
+REALM COMPONENTS
+
+This software contains components with separate copyright and license terms.
+Your use of these components is subject to the terms and conditions of the
+following licenses.
+
+For the Realm Core component
+
+  Realm Core Binary License
+
+  Copyright (c) 2011-2014 Realm Inc All rights reserved
+
+  Redistribution and use in binary form, with or without modification, is
+  permitted provided that the following conditions are met:
+
+  1. You agree not to attempt to decompile, disassemble, reverse engineer or
+  otherwise discover the source code from which the binary code was derived.
+  You may, however, access and obtain a separate license for most of the
+  source code from which this Software was created, at
+  http://realm.io/pricing/.
+
+  2. Redistributions in binary form must reproduce the above copyright notice,
+  this list of conditions and the following disclaimer in the documentation
+  and/or other materials provided with the distribution.
+
+  3. Neither the name of the copyright holder nor the names of its
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+  POSSIBILITY OF SUCH DAMAGE.
+
+EXPORT COMPLIANCE
+
+You understand that the Software may contain cryptographic functions that may be
+subject to export restrictions, and you represent and warrant that you are not
+located in a country that is subject to United States export restriction or embargo,
+including Cuba, Iran, North Korea, Sudan, Syria or the Crimea region, and that you
+are not on the Department of Commerce list of Denied Persons, Unverified Parties,
+or affiliated with a Restricted Entity.
+
+You agree to comply with all export, re-export and import restrictions and
+regulations of the Department of Commerce or other agency or authority of the
+United States or other applicable countries. You also agree not to transfer, or
+authorize the transfer of, directly or indirectly, the Software to any prohibited
+country, including Cuba, Iran, North Korea, Sudan, Syria or the Crimea region,
+or to any person or organization on or affiliated with the Department of
+Commerce lists of Denied Persons, Unverified Parties or Restricted Entities, or
+otherwise in violation of any such restrictions or regulations.
+</string>
+			<key>Title</key>
+			<string>Realm</string>
+			<key>Type</key>
+			<string>PSGroupSpecifier</string>
+		</dict>
+		<dict>
+			<key>FooterText</key>
+			<string>TABLE OF CONTENTS
+
+1. Apache License version 2.0
+2. Realm Components
+3. Export Compliance
+
+-------------------------------------------------------------------------------
+
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "{}"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright {yyyy} {name of copyright owner}
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+
+REALM COMPONENTS
+
+This software contains components with separate copyright and license terms.
+Your use of these components is subject to the terms and conditions of the
+following licenses.
+
+For the Realm Core component
+
+  Realm Core Binary License
+
+  Copyright (c) 2011-2014 Realm Inc All rights reserved
+
+  Redistribution and use in binary form, with or without modification, is
+  permitted provided that the following conditions are met:
+
+  1. You agree not to attempt to decompile, disassemble, reverse engineer or
+  otherwise discover the source code from which the binary code was derived.
+  You may, however, access and obtain a separate license for most of the
+  source code from which this Software was created, at
+  http://realm.io/pricing/.
+
+  2. Redistributions in binary form must reproduce the above copyright notice,
+  this list of conditions and the following disclaimer in the documentation
+  and/or other materials provided with the distribution.
+
+  3. Neither the name of the copyright holder nor the names of its
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+  POSSIBILITY OF SUCH DAMAGE.
+
+EXPORT COMPLIANCE
+
+You understand that the Software may contain cryptographic functions that may be
+subject to export restrictions, and you represent and warrant that you are not
+located in a country that is subject to United States export restriction or embargo,
+including Cuba, Iran, North Korea, Sudan, Syria or the Crimea region, and that you
+are not on the Department of Commerce list of Denied Persons, Unverified Parties,
+or affiliated with a Restricted Entity.
+
+You agree to comply with all export, re-export and import restrictions and
+regulations of the Department of Commerce or other agency or authority of the
+United States or other applicable countries. You also agree not to transfer, or
+authorize the transfer of, directly or indirectly, the Software to any prohibited
+country, including Cuba, Iran, North Korea, Sudan, Syria or the Crimea region,
+or to any person or organization on or affiliated with the Department of
+Commerce lists of Denied Persons, Unverified Parties or Restricted Entities, or
+otherwise in violation of any such restrictions or regulations.
+</string>
+			<key>Title</key>
+			<string>RealmSwift</string>
+			<key>Type</key>
+			<string>PSGroupSpecifier</string>
+		</dict>
+		<dict>
+			<key>FooterText</key>
 			<string>Copyright (c) 2014 David Mohundro
  
 Permission is hereby granted, free of charge, to any person obtaining
diff --git a/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016-frameworks.sh b/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016-frameworks.sh
index 54d016b..fc5d344 100755
--- a/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016-frameworks.sh	
+++ b/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016-frameworks.sh	
@@ -86,10 +86,14 @@ strip_invalid_archs() {
 if [[ "$CONFIGURATION" == "Debug" ]]; then
   install_framework "$BUILT_PRODUCTS_DIR/Alamofire/Alamofire.framework"
   install_framework "$BUILT_PRODUCTS_DIR/CocoaAsyncSocket/CocoaAsyncSocket.framework"
+  install_framework "$BUILT_PRODUCTS_DIR/Realm/Realm.framework"
+  install_framework "$BUILT_PRODUCTS_DIR/RealmSwift/RealmSwift.framework"
   install_framework "$BUILT_PRODUCTS_DIR/SWXMLHash/SWXMLHash.framework"
 fi
 if [[ "$CONFIGURATION" == "Release" ]]; then
   install_framework "$BUILT_PRODUCTS_DIR/Alamofire/Alamofire.framework"
   install_framework "$BUILT_PRODUCTS_DIR/CocoaAsyncSocket/CocoaAsyncSocket.framework"
+  install_framework "$BUILT_PRODUCTS_DIR/Realm/Realm.framework"
+  install_framework "$BUILT_PRODUCTS_DIR/RealmSwift/RealmSwift.framework"
   install_framework "$BUILT_PRODUCTS_DIR/SWXMLHash/SWXMLHash.framework"
 fi
diff --git a/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016.debug.xcconfig b/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016.debug.xcconfig
index 261e5cb..c9984f4 100644
--- a/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016.debug.xcconfig	
+++ b/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016.debug.xcconfig	
@@ -1,10 +1,10 @@
 CODE_SIGN_IDENTITY =
 EMBEDDED_CONTENT_CONTAINS_SWIFT = YES
-FRAMEWORK_SEARCH_PATHS = $(inherited) "$PODS_CONFIGURATION_BUILD_DIR/Alamofire" "$PODS_CONFIGURATION_BUILD_DIR/CocoaAsyncSocket" "$PODS_CONFIGURATION_BUILD_DIR/SWXMLHash"
+FRAMEWORK_SEARCH_PATHS = $(inherited) "$PODS_CONFIGURATION_BUILD_DIR/Alamofire" "$PODS_CONFIGURATION_BUILD_DIR/CocoaAsyncSocket" "$PODS_CONFIGURATION_BUILD_DIR/Realm" "$PODS_CONFIGURATION_BUILD_DIR/RealmSwift" "$PODS_CONFIGURATION_BUILD_DIR/SWXMLHash"
 GCC_PREPROCESSOR_DEFINITIONS = $(inherited) COCOAPODS=1
 LD_RUNPATH_SEARCH_PATHS = $(inherited) '@executable_path/../Frameworks' '@loader_path/Frameworks'
-OTHER_CFLAGS = $(inherited) -iquote "$PODS_CONFIGURATION_BUILD_DIR/Alamofire/Alamofire.framework/Headers" -iquote "$PODS_CONFIGURATION_BUILD_DIR/CocoaAsyncSocket/CocoaAsyncSocket.framework/Headers" -iquote "$PODS_CONFIGURATION_BUILD_DIR/SWXMLHash/SWXMLHash.framework/Headers"
-OTHER_LDFLAGS = $(inherited) -framework "Alamofire" -framework "CocoaAsyncSocket" -framework "SWXMLHash"
+OTHER_CFLAGS = $(inherited) -iquote "$PODS_CONFIGURATION_BUILD_DIR/Alamofire/Alamofire.framework/Headers" -iquote "$PODS_CONFIGURATION_BUILD_DIR/CocoaAsyncSocket/CocoaAsyncSocket.framework/Headers" -iquote "$PODS_CONFIGURATION_BUILD_DIR/Realm/Realm.framework/Headers" -iquote "$PODS_CONFIGURATION_BUILD_DIR/RealmSwift/RealmSwift.framework/Headers" -iquote "$PODS_CONFIGURATION_BUILD_DIR/SWXMLHash/SWXMLHash.framework/Headers"
+OTHER_LDFLAGS = $(inherited) -ObjC -framework "Alamofire" -framework "CocoaAsyncSocket" -framework "Realm" -framework "RealmSwift" -framework "SWXMLHash"
 OTHER_SWIFT_FLAGS = $(inherited) "-D" "COCOAPODS"
 PODS_BUILD_DIR = $BUILD_DIR
 PODS_CONFIGURATION_BUILD_DIR = $PODS_BUILD_DIR/$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME)
diff --git a/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016.release.xcconfig b/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016.release.xcconfig
index 261e5cb..c9984f4 100644
--- a/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016.release.xcconfig	
+++ b/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016.release.xcconfig	
@@ -1,10 +1,10 @@
 CODE_SIGN_IDENTITY =
 EMBEDDED_CONTENT_CONTAINS_SWIFT = YES
-FRAMEWORK_SEARCH_PATHS = $(inherited) "$PODS_CONFIGURATION_BUILD_DIR/Alamofire" "$PODS_CONFIGURATION_BUILD_DIR/CocoaAsyncSocket" "$PODS_CONFIGURATION_BUILD_DIR/SWXMLHash"
+FRAMEWORK_SEARCH_PATHS = $(inherited) "$PODS_CONFIGURATION_BUILD_DIR/Alamofire" "$PODS_CONFIGURATION_BUILD_DIR/CocoaAsyncSocket" "$PODS_CONFIGURATION_BUILD_DIR/Realm" "$PODS_CONFIGURATION_BUILD_DIR/RealmSwift" "$PODS_CONFIGURATION_BUILD_DIR/SWXMLHash"
 GCC_PREPROCESSOR_DEFINITIONS = $(inherited) COCOAPODS=1
 LD_RUNPATH_SEARCH_PATHS = $(inherited) '@executable_path/../Frameworks' '@loader_path/Frameworks'
-OTHER_CFLAGS = $(inherited) -iquote "$PODS_CONFIGURATION_BUILD_DIR/Alamofire/Alamofire.framework/Headers" -iquote "$PODS_CONFIGURATION_BUILD_DIR/CocoaAsyncSocket/CocoaAsyncSocket.framework/Headers" -iquote "$PODS_CONFIGURATION_BUILD_DIR/SWXMLHash/SWXMLHash.framework/Headers"
-OTHER_LDFLAGS = $(inherited) -framework "Alamofire" -framework "CocoaAsyncSocket" -framework "SWXMLHash"
+OTHER_CFLAGS = $(inherited) -iquote "$PODS_CONFIGURATION_BUILD_DIR/Alamofire/Alamofire.framework/Headers" -iquote "$PODS_CONFIGURATION_BUILD_DIR/CocoaAsyncSocket/CocoaAsyncSocket.framework/Headers" -iquote "$PODS_CONFIGURATION_BUILD_DIR/Realm/Realm.framework/Headers" -iquote "$PODS_CONFIGURATION_BUILD_DIR/RealmSwift/RealmSwift.framework/Headers" -iquote "$PODS_CONFIGURATION_BUILD_DIR/SWXMLHash/SWXMLHash.framework/Headers"
+OTHER_LDFLAGS = $(inherited) -ObjC -framework "Alamofire" -framework "CocoaAsyncSocket" -framework "Realm" -framework "RealmSwift" -framework "SWXMLHash"
 OTHER_SWIFT_FLAGS = $(inherited) "-D" "COCOAPODS"
 PODS_BUILD_DIR = $BUILD_DIR
 PODS_CONFIGURATION_BUILD_DIR = $PODS_BUILD_DIR/$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME)
diff --git a/Pods/Target Support Files/Realm/Info.plist b/Pods/Target Support Files/Realm/Info.plist
new file mode 100644
index 0000000..b35ab35
--- /dev/null
+++ b/Pods/Target Support Files/Realm/Info.plist	
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+  <key>CFBundleDevelopmentRegion</key>
+  <string>en</string>
+  <key>CFBundleExecutable</key>
+  <string>${EXECUTABLE_NAME}</string>
+  <key>CFBundleIdentifier</key>
+  <string>${PRODUCT_BUNDLE_IDENTIFIER}</string>
+  <key>CFBundleInfoDictionaryVersion</key>
+  <string>6.0</string>
+  <key>CFBundleName</key>
+  <string>${PRODUCT_NAME}</string>
+  <key>CFBundlePackageType</key>
+  <string>FMWK</string>
+  <key>CFBundleShortVersionString</key>
+  <string>1.0.2</string>
+  <key>CFBundleSignature</key>
+  <string>????</string>
+  <key>CFBundleVersion</key>
+  <string>${CURRENT_PROJECT_VERSION}</string>
+  <key>NSPrincipalClass</key>
+  <string></string>
+</dict>
+</plist>
diff --git a/Pods/Target Support Files/Realm/Realm-dummy.m b/Pods/Target Support Files/Realm/Realm-dummy.m
new file mode 100644
index 0000000..dd775bf
--- /dev/null
+++ b/Pods/Target Support Files/Realm/Realm-dummy.m	
@@ -0,0 +1,5 @@
+#import <Foundation/Foundation.h>
+@interface PodsDummy_Realm : NSObject
+@end
+@implementation PodsDummy_Realm
+@end
diff --git a/Pods/Target Support Files/Realm/Realm-prefix.pch b/Pods/Target Support Files/Realm/Realm-prefix.pch
new file mode 100644
index 0000000..b9c163b
--- /dev/null
+++ b/Pods/Target Support Files/Realm/Realm-prefix.pch	
@@ -0,0 +1,4 @@
+#ifdef __OBJC__
+#import <Cocoa/Cocoa.h>
+#endif
+
diff --git a/Pods/Target Support Files/Realm/Realm.modulemap b/Pods/Target Support Files/Realm/Realm.modulemap
new file mode 100644
index 0000000..18b5e2e
--- /dev/null
+++ b/Pods/Target Support Files/Realm/Realm.modulemap	
@@ -0,0 +1,27 @@
+framework module Realm {
+    umbrella header "Realm.h"
+
+    export *
+    module * { export * }
+
+    explicit module Private {
+        header "RLMAccessor.h"
+        header "RLMArray_Private.h"
+        header "RLMListBase.h"
+        header "RLMMigration_Private.h"
+        header "RLMObjectSchema_Private.h"
+        header "RLMObjectStore.h"
+        header "RLMObject_Private.h"
+        header "RLMOptionalBase.h"
+        header "RLMProperty_Private.h"
+        header "RLMRealmConfiguration_Private.h"
+        header "RLMRealm_Private.h"
+        header "RLMResults_Private.h"
+        header "RLMSchema_Private.h"
+    }
+
+    explicit module Dynamic {
+        header "RLMRealm_Dynamic.h"
+        header "RLMObjectBase_Dynamic.h"
+    }
+}
diff --git a/Pods/Target Support Files/Realm/Realm.xcconfig b/Pods/Target Support Files/Realm/Realm.xcconfig
new file mode 100644
index 0000000..6d0bb8a
--- /dev/null
+++ b/Pods/Target Support Files/Realm/Realm.xcconfig	
@@ -0,0 +1,15 @@
+APPLICATION_EXTENSION_API_ONLY = YES
+CLANG_CXX_LANGUAGE_STANDARD = compiler-default
+CODE_SIGN_IDENTITY =
+CONFIGURATION_BUILD_DIR = $PODS_CONFIGURATION_BUILD_DIR/Realm
+GCC_PREPROCESSOR_DEFINITIONS = $(inherited) COCOAPODS=1
+HEADER_SEARCH_PATHS = "${PODS_ROOT}/Headers/Private" "${PODS_ROOT}/Headers/Public" "${PODS_ROOT}/Realm/include/core"
+LIBRARY_SEARCH_PATHS = $(inherited) "${PODS_ROOT}/Realm/core"
+OTHER_CPLUSPLUSFLAGS = -std=c++1y $(inherited)
+OTHER_LDFLAGS = -l"c++" -l"realm-macosx"
+PODS_BUILD_DIR = $BUILD_DIR
+PODS_CONFIGURATION_BUILD_DIR = $PODS_BUILD_DIR/$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME)
+PODS_ROOT = ${SRCROOT}
+PRODUCT_BUNDLE_IDENTIFIER = org.cocoapods.${PRODUCT_NAME:rfc1034identifier}
+SKIP_INSTALL = YES
+USER_HEADER_SEARCH_PATHS = "${PODS_ROOT}/Realm/include" "${PODS_ROOT}/Realm/include/Realm"
diff --git a/Pods/Target Support Files/RealmSwift/Info.plist b/Pods/Target Support Files/RealmSwift/Info.plist
new file mode 100644
index 0000000..b35ab35
--- /dev/null
+++ b/Pods/Target Support Files/RealmSwift/Info.plist	
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+  <key>CFBundleDevelopmentRegion</key>
+  <string>en</string>
+  <key>CFBundleExecutable</key>
+  <string>${EXECUTABLE_NAME}</string>
+  <key>CFBundleIdentifier</key>
+  <string>${PRODUCT_BUNDLE_IDENTIFIER}</string>
+  <key>CFBundleInfoDictionaryVersion</key>
+  <string>6.0</string>
+  <key>CFBundleName</key>
+  <string>${PRODUCT_NAME}</string>
+  <key>CFBundlePackageType</key>
+  <string>FMWK</string>
+  <key>CFBundleShortVersionString</key>
+  <string>1.0.2</string>
+  <key>CFBundleSignature</key>
+  <string>????</string>
+  <key>CFBundleVersion</key>
+  <string>${CURRENT_PROJECT_VERSION}</string>
+  <key>NSPrincipalClass</key>
+  <string></string>
+</dict>
+</plist>
diff --git a/Pods/Target Support Files/RealmSwift/RealmSwift-dummy.m b/Pods/Target Support Files/RealmSwift/RealmSwift-dummy.m
new file mode 100644
index 0000000..cf759b1
--- /dev/null
+++ b/Pods/Target Support Files/RealmSwift/RealmSwift-dummy.m	
@@ -0,0 +1,5 @@
+#import <Foundation/Foundation.h>
+@interface PodsDummy_RealmSwift : NSObject
+@end
+@implementation PodsDummy_RealmSwift
+@end
diff --git a/Pods/Target Support Files/RealmSwift/RealmSwift-prefix.pch b/Pods/Target Support Files/RealmSwift/RealmSwift-prefix.pch
new file mode 100644
index 0000000..b9c163b
--- /dev/null
+++ b/Pods/Target Support Files/RealmSwift/RealmSwift-prefix.pch	
@@ -0,0 +1,4 @@
+#ifdef __OBJC__
+#import <Cocoa/Cocoa.h>
+#endif
+
diff --git a/Pods/Target Support Files/RealmSwift/RealmSwift-umbrella.h b/Pods/Target Support Files/RealmSwift/RealmSwift-umbrella.h
new file mode 100644
index 0000000..1c50054
--- /dev/null
+++ b/Pods/Target Support Files/RealmSwift/RealmSwift-umbrella.h	
@@ -0,0 +1,6 @@
+#import <Cocoa/Cocoa.h>
+
+
+FOUNDATION_EXPORT double RealmSwiftVersionNumber;
+FOUNDATION_EXPORT const unsigned char RealmSwiftVersionString[];
+
diff --git a/Pods/Target Support Files/RealmSwift/RealmSwift.modulemap b/Pods/Target Support Files/RealmSwift/RealmSwift.modulemap
new file mode 100644
index 0000000..7f9767a
--- /dev/null
+++ b/Pods/Target Support Files/RealmSwift/RealmSwift.modulemap	
@@ -0,0 +1,6 @@
+framework module RealmSwift {
+  umbrella header "RealmSwift-umbrella.h"
+
+  export *
+  module * { export * }
+}
diff --git a/Pods/Target Support Files/RealmSwift/RealmSwift.xcconfig b/Pods/Target Support Files/RealmSwift/RealmSwift.xcconfig
new file mode 100644
index 0000000..2732d1d
--- /dev/null
+++ b/Pods/Target Support Files/RealmSwift/RealmSwift.xcconfig	
@@ -0,0 +1,13 @@
+APPLICATION_EXTENSION_API_ONLY = YES
+CODE_SIGN_IDENTITY =
+CONFIGURATION_BUILD_DIR = $PODS_CONFIGURATION_BUILD_DIR/RealmSwift
+FRAMEWORK_SEARCH_PATHS = $(inherited) "$PODS_CONFIGURATION_BUILD_DIR/Realm"
+GCC_PREPROCESSOR_DEFINITIONS = $(inherited) COCOAPODS=1
+HEADER_SEARCH_PATHS = "${PODS_ROOT}/Headers/Private" "${PODS_ROOT}/Headers/Public"
+OTHER_SWIFT_FLAGS = $(inherited) "-D" "COCOAPODS"
+PODS_BUILD_DIR = $BUILD_DIR
+PODS_CONFIGURATION_BUILD_DIR = $PODS_BUILD_DIR/$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME)
+PODS_ROOT = ${SRCROOT}
+PRODUCT_BUNDLE_IDENTIFIER = org.cocoapods.${PRODUCT_NAME:rfc1034identifier}
+SKIP_INSTALL = YES
+SWIFT_WHOLE_MODULE_OPTIMIZATION = YES
