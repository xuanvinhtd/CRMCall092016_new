diff --git a/.DS_Store b/.DS_Store
index 0ab3ed8..cc4920b 100644
Binary files a/.DS_Store and b/.DS_Store differ
diff --git a/CRMCall092016.xcodeproj/project.pbxproj b/CRMCall092016.xcodeproj/project.pbxproj
index 6a921f0..7c41d9c 100644
--- a/CRMCall092016.xcodeproj/project.pbxproj
+++ b/CRMCall092016.xcodeproj/project.pbxproj
@@ -7,14 +7,18 @@
 	objects = {
 
 /* Begin PBXBuildFile section */
+		922840301D865A720059A0D7 /* CRMCallSocket.swift in Sources */ = {isa = PBXBuildFile; fileRef = 9228402F1D865A720059A0D7 /* CRMCallSocket.swift */; };
+		92E2341A1D812899006C988E /* ModelManger.swift in Sources */ = {isa = PBXBuildFile; fileRef = 92E234191D812899006C988E /* ModelManger.swift */; };
+		92E2341D1D81443F006C988E /* AlamofireManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 92E2341C1D81443F006C988E /* AlamofireManager.swift */; };
+		92E2341F1D81447D006C988E /* SWXMLHashManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 92E2341E1D81447D006C988E /* SWXMLHashManager.swift */; };
+		92E234241D814647006C988E /* XMLRequestBuilder.swift in Sources */ = {isa = PBXBuildFile; fileRef = 92E234231D814647006C988E /* XMLRequestBuilder.swift */; };
 		92E3E3131D8004C3008033ED /* AppDelegate.swift in Sources */ = {isa = PBXBuildFile; fileRef = 92E3E3121D8004C3008033ED /* AppDelegate.swift */; };
 		92E3E3151D8004C3008033ED /* ViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 92E3E3141D8004C3008033ED /* ViewController.swift */; };
 		92E3E3171D8004C3008033ED /* Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = 92E3E3161D8004C3008033ED /* Assets.xcassets */; };
 		92E3E31A1D8004C3008033ED /* Main.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = 92E3E3181D8004C3008033ED /* Main.storyboard */; };
 		92E3E3291D8005E2008033ED /* AESExtension.m in Sources */ = {isa = PBXBuildFile; fileRef = 92E3E3281D8005E2008033ED /* AESExtension.m */; };
-		92E3E32F1D8008B9008033ED /* XMLRequestBuilder.swift in Sources */ = {isa = PBXBuildFile; fileRef = 92E3E32E1D8008B9008033ED /* XMLRequestBuilder.swift */; };
 		92E3E3311D800947008033ED /* CRMCallConfig.swift in Sources */ = {isa = PBXBuildFile; fileRef = 92E3E3301D800947008033ED /* CRMCallConfig.swift */; };
-		92E3E3331D800C8B008033ED /* SocketManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 92E3E3321D800C8B008033ED /* SocketManager.swift */; };
+		92E3E3331D800C8B008033ED /* BaseSocket.swift in Sources */ = {isa = PBXBuildFile; fileRef = 92E3E3321D800C8B008033ED /* BaseSocket.swift */; };
 		92E3E3351D8011FC008033ED /* CRMCallLog.swift in Sources */ = {isa = PBXBuildFile; fileRef = 92E3E3341D8011FC008033ED /* CRMCallLog.swift */; };
 		A786E68B3F379810ED36B746 /* Pods_CRMCall092016.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 0F2F9C69A515659B29DDA8FF /* Pods_CRMCall092016.framework */; };
 /* End PBXBuildFile section */
@@ -23,6 +27,11 @@
 		0F2F9C69A515659B29DDA8FF /* Pods_CRMCall092016.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Pods_CRMCall092016.framework; sourceTree = BUILT_PRODUCTS_DIR; };
 		638056E88800D61CD44C46F6 /* Pods-CRMCall092016.release.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-CRMCall092016.release.xcconfig"; path = "Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016.release.xcconfig"; sourceTree = "<group>"; };
 		867B73DF25B4547C396A7607 /* Pods-CRMCall092016.debug.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-CRMCall092016.debug.xcconfig"; path = "Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016.debug.xcconfig"; sourceTree = "<group>"; };
+		9228402F1D865A720059A0D7 /* CRMCallSocket.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = CRMCallSocket.swift; sourceTree = "<group>"; };
+		92E234191D812899006C988E /* ModelManger.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = ModelManger.swift; sourceTree = "<group>"; };
+		92E2341C1D81443F006C988E /* AlamofireManager.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = AlamofireManager.swift; sourceTree = "<group>"; };
+		92E2341E1D81447D006C988E /* SWXMLHashManager.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = SWXMLHashManager.swift; sourceTree = "<group>"; };
+		92E234231D814647006C988E /* XMLRequestBuilder.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = XMLRequestBuilder.swift; sourceTree = "<group>"; };
 		92E3E30F1D8004C3008033ED /* CRMCall092016.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = CRMCall092016.app; sourceTree = BUILT_PRODUCTS_DIR; };
 		92E3E3121D8004C3008033ED /* AppDelegate.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AppDelegate.swift; sourceTree = "<group>"; };
 		92E3E3141D8004C3008033ED /* ViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ViewController.swift; sourceTree = "<group>"; };
@@ -32,9 +41,8 @@
 		92E3E3221D800538008033ED /* CRMCall092016-Bridging-Header.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = "CRMCall092016-Bridging-Header.h"; sourceTree = "<group>"; };
 		92E3E3271D8005E2008033ED /* AESExtension.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = AESExtension.h; sourceTree = "<group>"; };
 		92E3E3281D8005E2008033ED /* AESExtension.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = AESExtension.m; sourceTree = "<group>"; };
-		92E3E32E1D8008B9008033ED /* XMLRequestBuilder.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = XMLRequestBuilder.swift; sourceTree = "<group>"; };
 		92E3E3301D800947008033ED /* CRMCallConfig.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = CRMCallConfig.swift; sourceTree = "<group>"; };
-		92E3E3321D800C8B008033ED /* SocketManager.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = SocketManager.swift; sourceTree = "<group>"; };
+		92E3E3321D800C8B008033ED /* BaseSocket.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = BaseSocket.swift; sourceTree = "<group>"; };
 		92E3E3341D8011FC008033ED /* CRMCallLog.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = CRMCallLog.swift; sourceTree = "<group>"; };
 /* End PBXFileReference section */
 
@@ -50,6 +58,22 @@
 /* End PBXFrameworksBuildPhase section */
 
 /* Begin PBXGroup section */
+		92E234181D81281D006C988E /* Models */ = {
+			isa = PBXGroup;
+			children = (
+				92E234191D812899006C988E /* ModelManger.swift */,
+			);
+			path = Models;
+			sourceTree = "<group>";
+		};
+		92E234221D8145ED006C988E /* XML */ = {
+			isa = PBXGroup;
+			children = (
+				92E234231D814647006C988E /* XMLRequestBuilder.swift */,
+			);
+			path = XML;
+			sourceTree = "<group>";
+		};
 		92E3E3061D8004C3008033ED = {
 			isa = PBXGroup;
 			children = (
@@ -71,6 +95,7 @@
 		92E3E3111D8004C3008033ED /* CRMCall092016 */ = {
 			isa = PBXGroup;
 			children = (
+				92E234181D81281D006C988E /* Models */,
 				92E3E3211D8004F4008033ED /* Helpers */,
 				92E3E32C1D80066C008033ED /* Library */,
 				92E3E32B1D80063C008033ED /* Server */,
@@ -87,6 +112,7 @@
 		92E3E3211D8004F4008033ED /* Helpers */ = {
 			isa = PBXGroup;
 			children = (
+				92E234221D8145ED006C988E /* XML */,
 				92E3E3261D8005E2008033ED /* AES */,
 				92E3E3221D800538008033ED /* CRMCall092016-Bridging-Header.h */,
 				92E3E3301D800947008033ED /* CRMCallConfig.swift */,
@@ -115,7 +141,6 @@
 			isa = PBXGroup;
 			children = (
 				92E3E32D1D8007F4008033ED /* Socket */,
-				92E3E32E1D8008B9008033ED /* XMLRequestBuilder.swift */,
 			);
 			path = Server;
 			sourceTree = "<group>";
@@ -123,6 +148,8 @@
 		92E3E32C1D80066C008033ED /* Library */ = {
 			isa = PBXGroup;
 			children = (
+				92E2341C1D81443F006C988E /* AlamofireManager.swift */,
+				92E2341E1D81447D006C988E /* SWXMLHashManager.swift */,
 			);
 			path = Library;
 			sourceTree = "<group>";
@@ -130,7 +157,8 @@
 		92E3E32D1D8007F4008033ED /* Socket */ = {
 			isa = PBXGroup;
 			children = (
-				92E3E3321D800C8B008033ED /* SocketManager.swift */,
+				92E3E3321D800C8B008033ED /* BaseSocket.swift */,
+				9228402F1D865A720059A0D7 /* CRMCallSocket.swift */,
 			);
 			path = Socket;
 			sourceTree = "<group>";
@@ -273,12 +301,16 @@
 			isa = PBXSourcesBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
+				92E2341F1D81447D006C988E /* SWXMLHashManager.swift in Sources */,
+				922840301D865A720059A0D7 /* CRMCallSocket.swift in Sources */,
+				92E234241D814647006C988E /* XMLRequestBuilder.swift in Sources */,
 				92E3E3151D8004C3008033ED /* ViewController.swift in Sources */,
 				92E3E3131D8004C3008033ED /* AppDelegate.swift in Sources */,
 				92E3E3291D8005E2008033ED /* AESExtension.m in Sources */,
-				92E3E32F1D8008B9008033ED /* XMLRequestBuilder.swift in Sources */,
-				92E3E3331D800C8B008033ED /* SocketManager.swift in Sources */,
+				92E2341A1D812899006C988E /* ModelManger.swift in Sources */,
+				92E3E3331D800C8B008033ED /* BaseSocket.swift in Sources */,
 				92E3E3351D8011FC008033ED /* CRMCallLog.swift in Sources */,
+				92E2341D1D81443F006C988E /* AlamofireManager.swift in Sources */,
 				92E3E3311D800947008033ED /* CRMCallConfig.swift in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
@@ -388,7 +420,7 @@
 				COMBINE_HIDPI_IMAGES = YES;
 				INFOPLIST_FILE = CRMCall092016/Info.plist;
 				LD_RUNPATH_SEARCH_PATHS = "$(inherited) @executable_path/../Frameworks";
-				OTHER_SWIFT_FLAGS = "-DDEBUG";
+				OTHER_SWIFT_FLAGS = "$(inherited) -D DEBUG";
 				PRODUCT_BUNDLE_IDENTIFIER = com.xuanvintd.CRMCall092016;
 				PRODUCT_NAME = "$(TARGET_NAME)";
 				SWIFT_OBJC_BRIDGING_HEADER = "CRMCall092016/Helpers/CRMCall092016-Bridging-Header.h";
@@ -405,6 +437,7 @@
 				COMBINE_HIDPI_IMAGES = YES;
 				INFOPLIST_FILE = CRMCall092016/Info.plist;
 				LD_RUNPATH_SEARCH_PATHS = "$(inherited) @executable_path/../Frameworks";
+				OTHER_SWIFT_FLAGS = "$(inherited)";
 				PRODUCT_BUNDLE_IDENTIFIER = com.xuanvintd.CRMCall092016;
 				PRODUCT_NAME = "$(TARGET_NAME)";
 				SWIFT_OBJC_BRIDGING_HEADER = "CRMCall092016/Helpers/CRMCall092016-Bridging-Header.h";
diff --git a/CRMCall092016.xcworkspace/xcuserdata/hanbiro.xcuserdatad/UserInterfaceState.xcuserstate b/CRMCall092016.xcworkspace/xcuserdata/hanbiro.xcuserdatad/UserInterfaceState.xcuserstate
index 626175e..9ee2155 100644
Binary files a/CRMCall092016.xcworkspace/xcuserdata/hanbiro.xcuserdatad/UserInterfaceState.xcuserstate and b/CRMCall092016.xcworkspace/xcuserdata/hanbiro.xcuserdatad/UserInterfaceState.xcuserstate differ
diff --git a/CRMCall092016/.DS_Store b/CRMCall092016/.DS_Store
new file mode 100644
index 0000000..e9dd625
Binary files /dev/null and b/CRMCall092016/.DS_Store differ
diff --git a/CRMCall092016/Base.lproj/Main.storyboard b/CRMCall092016/Base.lproj/Main.storyboard
index bce5247..6971220 100644
--- a/CRMCall092016/Base.lproj/Main.storyboard
+++ b/CRMCall092016/Base.lproj/Main.storyboard
@@ -672,7 +672,117 @@
                     <view key="view" id="m2S-Jp-Qdl">
                         <rect key="frame" x="0.0" y="0.0" width="480" height="270"/>
                         <autoresizingMask key="autoresizingMask"/>
+                        <subviews>
+                            <textField horizontalHuggingPriority="251" verticalHuggingPriority="750" translatesAutoresizingMaskIntoConstraints="NO" id="YWn-PH-WzV">
+                                <rect key="frame" x="49" y="210" width="50" height="17"/>
+                                <textFieldCell key="cell" scrollable="YES" lineBreakMode="clipping" sendsActionOnEndEditing="YES" title="Domain" id="mWy-w5-bSu">
+                                    <font key="font" metaFont="system"/>
+                                    <color key="textColor" name="labelColor" catalog="System" colorSpace="catalog"/>
+                                    <color key="backgroundColor" name="controlColor" catalog="System" colorSpace="catalog"/>
+                                </textFieldCell>
+                            </textField>
+                            <textField horizontalHuggingPriority="251" verticalHuggingPriority="750" translatesAutoresizingMaskIntoConstraints="NO" id="SDN-0s-DTb">
+                                <rect key="frame" x="49" y="171" width="33" height="17"/>
+                                <textFieldCell key="cell" scrollable="YES" lineBreakMode="clipping" sendsActionOnEndEditing="YES" title="User" id="UKh-EO-mUV">
+                                    <font key="font" metaFont="system"/>
+                                    <color key="textColor" name="labelColor" catalog="System" colorSpace="catalog"/>
+                                    <color key="backgroundColor" name="controlColor" catalog="System" colorSpace="catalog"/>
+                                </textFieldCell>
+                            </textField>
+                            <textField horizontalHuggingPriority="251" verticalHuggingPriority="750" translatesAutoresizingMaskIntoConstraints="NO" id="JS7-Io-Koi">
+                                <rect key="frame" x="49" y="132" width="63" height="17"/>
+                                <textFieldCell key="cell" scrollable="YES" lineBreakMode="clipping" sendsActionOnEndEditing="YES" title="Password" id="DgM-0W-UBM">
+                                    <font key="font" metaFont="system"/>
+                                    <color key="textColor" name="labelColor" catalog="System" colorSpace="catalog"/>
+                                    <color key="backgroundColor" name="controlColor" catalog="System" colorSpace="catalog"/>
+                                </textFieldCell>
+                            </textField>
+                            <textField hidden="YES" horizontalHuggingPriority="251" verticalHuggingPriority="750" translatesAutoresizingMaskIntoConstraints="NO" id="nGf-xq-RQu">
+                                <rect key="frame" x="194" y="40" width="92" height="17"/>
+                                <textFieldCell key="cell" scrollable="YES" lineBreakMode="clipping" sendsActionOnEndEditing="YES" title="login Success!" id="h53-kc-rEE">
+                                    <font key="font" metaFont="system"/>
+                                    <color key="textColor" red="0.0" green="0.50196081400000003" blue="0.0" alpha="1" colorSpace="calibratedRGB"/>
+                                    <color key="backgroundColor" name="controlColor" catalog="System" colorSpace="catalog"/>
+                                </textFieldCell>
+                            </textField>
+                            <textField verticalHuggingPriority="750" translatesAutoresizingMaskIntoConstraints="NO" id="ohl-5L-mtw">
+                                <rect key="frame" x="117" y="205" width="263" height="22"/>
+                                <textFieldCell key="cell" scrollable="YES" lineBreakMode="clipping" selectable="YES" editable="YES" sendsActionOnEndEditing="YES" state="on" borderStyle="bezel" title="global3.hanbiro.com" placeholderString="" drawsBackground="YES" id="Osp-Th-EIE">
+                                    <font key="font" metaFont="system"/>
+                                    <color key="textColor" name="textColor" catalog="System" colorSpace="catalog"/>
+                                    <color key="backgroundColor" name="textBackgroundColor" catalog="System" colorSpace="catalog"/>
+                                </textFieldCell>
+                            </textField>
+                            <textField verticalHuggingPriority="750" translatesAutoresizingMaskIntoConstraints="NO" id="KtV-vx-4vz">
+                                <rect key="frame" x="117" y="166" width="263" height="22"/>
+                                <textFieldCell key="cell" scrollable="YES" lineBreakMode="clipping" selectable="YES" editable="YES" sendsActionOnEndEditing="YES" state="on" borderStyle="bezel" title="hcsong" drawsBackground="YES" id="l0S-uL-xDB">
+                                    <font key="font" metaFont="system"/>
+                                    <color key="textColor" name="textColor" catalog="System" colorSpace="catalog"/>
+                                    <color key="backgroundColor" name="textBackgroundColor" catalog="System" colorSpace="catalog"/>
+                                </textFieldCell>
+                            </textField>
+                            <secureTextField verticalHuggingPriority="750" translatesAutoresizingMaskIntoConstraints="NO" id="p4h-qf-Wor">
+                                <rect key="frame" x="117" y="127" width="263" height="22"/>
+                                <secureTextFieldCell key="cell" scrollable="YES" lineBreakMode="clipping" selectable="YES" editable="YES" sendsActionOnEndEditing="YES" borderStyle="bezel" title="gksqlfhWkd1!" drawsBackground="YES" usesSingleLineMode="YES" id="esa-sk-9hO">
+                                    <font key="font" metaFont="system"/>
+                                    <color key="textColor" name="textColor" catalog="System" colorSpace="catalog"/>
+                                    <color key="backgroundColor" name="textBackgroundColor" catalog="System" colorSpace="catalog"/>
+                                    <allowedInputSourceLocales>
+                                        <string>NSAllRomanInputSourcesLocaleIdentifier</string>
+                                    </allowedInputSourceLocales>
+                                </secureTextFieldCell>
+                            </secureTextField>
+                            <button verticalHuggingPriority="750" translatesAutoresizingMaskIntoConstraints="NO" id="U6H-wJ-C1H">
+                                <rect key="frame" x="135" y="81" width="74" height="32"/>
+                                <buttonCell key="cell" type="push" title="Login" bezelStyle="rounded" alignment="center" borderStyle="border" imageScaling="proportionallyDown" inset="2" id="het-M0-VTE">
+                                    <behavior key="behavior" pushIn="YES" lightByBackground="YES" lightByGray="YES"/>
+                                    <font key="font" metaFont="system"/>
+                                </buttonCell>
+                                <connections>
+                                    <action selector="actionLogin:" target="XfG-lQ-9wD" id="tak-Hv-Wh1"/>
+                                </connections>
+                            </button>
+                            <button verticalHuggingPriority="750" translatesAutoresizingMaskIntoConstraints="NO" id="7TL-H2-Tmu">
+                                <rect key="frame" x="276" y="81" width="83" height="32"/>
+                                <buttonCell key="cell" type="push" title="Logout" bezelStyle="rounded" alignment="center" borderStyle="border" imageScaling="proportionallyDown" inset="2" id="huG-hN-Hf8">
+                                    <behavior key="behavior" pushIn="YES" lightByBackground="YES" lightByGray="YES"/>
+                                    <font key="font" metaFont="system"/>
+                                </buttonCell>
+                                <connections>
+                                    <action selector="actionLogout:" target="XfG-lQ-9wD" id="Cm8-rP-HqD"/>
+                                </connections>
+                            </button>
+                        </subviews>
+                        <constraints>
+                            <constraint firstItem="SDN-0s-DTb" firstAttribute="leading" secondItem="YWn-PH-WzV" secondAttribute="leading" id="0bQ-a5-6v5"/>
+                            <constraint firstItem="p4h-qf-Wor" firstAttribute="top" secondItem="JS7-Io-Koi" secondAttribute="top" id="1Vw-w7-BgT"/>
+                            <constraint firstAttribute="trailing" secondItem="KtV-vx-4vz" secondAttribute="trailing" constant="100" id="4Me-Lx-2oV"/>
+                            <constraint firstItem="nGf-xq-RQu" firstAttribute="centerX" secondItem="m2S-Jp-Qdl" secondAttribute="centerX" id="6sK-sd-xaz"/>
+                            <constraint firstAttribute="trailing" secondItem="ohl-5L-mtw" secondAttribute="trailing" constant="100" id="6uU-Jd-wgH"/>
+                            <constraint firstItem="ohl-5L-mtw" firstAttribute="top" secondItem="YWn-PH-WzV" secondAttribute="top" id="FGv-8D-zBy"/>
+                            <constraint firstItem="JS7-Io-Koi" firstAttribute="top" secondItem="SDN-0s-DTb" secondAttribute="bottom" constant="22" id="MdJ-Rh-cUc"/>
+                            <constraint firstItem="YWn-PH-WzV" firstAttribute="top" secondItem="m2S-Jp-Qdl" secondAttribute="top" constant="43" id="Nwz-DJ-TYu"/>
+                            <constraint firstItem="U6H-wJ-C1H" firstAttribute="top" secondItem="p4h-qf-Wor" secondAttribute="bottom" constant="18" id="SoE-dx-UYh"/>
+                            <constraint firstItem="U6H-wJ-C1H" firstAttribute="leading" secondItem="m2S-Jp-Qdl" secondAttribute="leading" constant="141" id="TBJ-Nv-2wi"/>
+                            <constraint firstItem="7TL-H2-Tmu" firstAttribute="top" secondItem="p4h-qf-Wor" secondAttribute="bottom" constant="18" id="Tpd-KH-xFG"/>
+                            <constraint firstItem="p4h-qf-Wor" firstAttribute="leading" secondItem="KtV-vx-4vz" secondAttribute="leading" id="VP5-RK-Zmd"/>
+                            <constraint firstItem="SDN-0s-DTb" firstAttribute="top" secondItem="YWn-PH-WzV" secondAttribute="bottom" constant="22" id="g5B-y9-RWb"/>
+                            <constraint firstItem="YWn-PH-WzV" firstAttribute="leading" secondItem="m2S-Jp-Qdl" secondAttribute="leading" constant="51" id="h6A-wr-R66"/>
+                            <constraint firstAttribute="bottom" secondItem="nGf-xq-RQu" secondAttribute="bottom" constant="40" id="iG9-Fb-lxv"/>
+                            <constraint firstItem="KtV-vx-4vz" firstAttribute="leading" secondItem="ohl-5L-mtw" secondAttribute="leading" id="oWd-Ad-Omk"/>
+                            <constraint firstItem="ohl-5L-mtw" firstAttribute="leading" secondItem="YWn-PH-WzV" secondAttribute="trailing" constant="20" id="pGC-hm-gqw"/>
+                            <constraint firstItem="JS7-Io-Koi" firstAttribute="leading" secondItem="YWn-PH-WzV" secondAttribute="leading" id="pZC-ai-PHd"/>
+                            <constraint firstItem="KtV-vx-4vz" firstAttribute="top" secondItem="SDN-0s-DTb" secondAttribute="top" id="rpH-EV-ily"/>
+                            <constraint firstAttribute="trailing" secondItem="p4h-qf-Wor" secondAttribute="trailing" constant="100" id="sDU-vI-rBb"/>
+                            <constraint firstItem="7TL-H2-Tmu" firstAttribute="leading" secondItem="U6H-wJ-C1H" secondAttribute="trailing" constant="79" id="uL1-yw-ven"/>
+                        </constraints>
                     </view>
+                    <connections>
+                        <outlet property="domanTextField" destination="ohl-5L-mtw" id="9cW-Cd-wuR"/>
+                        <outlet property="passTextField" destination="p4h-qf-Wor" id="dE8-Dr-Kou"/>
+                        <outlet property="statusLogin" destination="nGf-xq-RQu" id="CiT-Yx-cBU"/>
+                        <outlet property="userTextField" destination="KtV-vx-4vz" id="0lv-YN-WQw"/>
+                    </connections>
                 </viewController>
                 <customObject id="rPt-NT-nkU" userLabel="First Responder" customClass="NSResponder" sceneMemberID="firstResponder"/>
             </objects>
diff --git a/CRMCall092016/Helpers/CRMCallConfig.swift b/CRMCall092016/Helpers/CRMCallConfig.swift
index eb697bd..e3d3a96 100644
--- a/CRMCall092016/Helpers/CRMCallConfig.swift
+++ b/CRMCall092016/Helpers/CRMCallConfig.swift
@@ -12,13 +12,29 @@ final class CRMCallConfig {
     
     static let Version = "20150202"
     static let DeviceID = "MAC"
+    static let HostName = "global3.hanbiro.com"
     
+    static let HeaderLength:UInt = 6
+    
+    // MARK: Tab
     struct Tab {
         static let Default = 0
         static let Header = 1
         static let BodyData = 2
     }
     
+    // MARK: Notification
+    struct Notification {
+        static let SocketDidConnected = "SocketManager.SocketDidConnected"
+        static let SocketDisConnected = "SocketManager.SocketDisConnected"
+    }
+    
+    // MARK: API
+    struct API {
+        static let GetPortAndHostURL = "http://\(CRMCallConfig.HostName)/winapp/hcsong/crmcall/\(CRMCallConfig.HostName)/server.xml"
+    }
+    
+    
     
     
 }
diff --git a/CRMCall092016/Helpers/XML/XMLRequestBuilder.swift b/CRMCall092016/Helpers/XML/XMLRequestBuilder.swift
new file mode 100644
index 0000000..db4a433
--- /dev/null
+++ b/CRMCall092016/Helpers/XML/XMLRequestBuilder.swift
@@ -0,0 +1,28 @@
+//
+//  XMLRequestBuilder.swift
+//  CRMCall092016
+//
+//  Created by Hanbiro on 9/7/16.
+//  Copyright © 2016 xuanvinhtd. All rights reserved.
+//
+
+import Foundation
+
+final class XMLRequestBuilder {
+    
+    // MARK: - LOGIN/LOGOUT
+    static func loginRequest(with userID: String, pass: String, domain: String) -> String {
+        
+        return  String(format: "<XML> <VER>%@</VER> <USER> <LOGIN ID=\"%@\" PASSWORD=\"%@\" DOMAIN=\"%@\" VER=\"1.0\" ISPTYPE=\"\" PHONE=\"\" DEVICE=\"%@\"></LOGIN> </USER> </XML>", CRMCallConfig.Version, userID, pass, domain, CRMCallConfig.DeviceID)
+        
+    }
+    
+    static func logOutRequest() -> String {
+        
+        return String(format: "<XML><VER>%@</VER><USER><LOGOUT></LOGOUT></USER></XML>", CRMCallConfig.Version)
+    }
+    
+    static func liveRequest() -> String {
+        return String(format: "<XML><VER>%@</VER><ALARM><LIVE/></ALARM></XML>", CRMCallConfig.Version)
+    }
+}
\ No newline at end of file
diff --git a/CRMCall092016/Info.plist b/CRMCall092016/Info.plist
index e435186..4001dfd 100644
--- a/CRMCall092016/Info.plist
+++ b/CRMCall092016/Info.plist
@@ -2,6 +2,11 @@
 <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
 <plist version="1.0">
 <dict>
+	<key>NSAppTransportSecurity</key>
+	<dict>
+		<key>NSAllowsArbitraryLoads</key>
+		<true/>
+	</dict>
 	<key>CFBundleDevelopmentRegion</key>
 	<string>en</string>
 	<key>CFBundleExecutable</key>
diff --git a/CRMCall092016/Library/AlamofireManager.swift b/CRMCall092016/Library/AlamofireManager.swift
new file mode 100644
index 0000000..ddf3f38
--- /dev/null
+++ b/CRMCall092016/Library/AlamofireManager.swift
@@ -0,0 +1,36 @@
+//
+//  AlamofireManager.swift
+//  CRMCall092016
+//
+//  Created by Hanbiro on 9/8/16.
+//  Copyright © 2016 xuanvinhtd. All rights reserved.
+//
+
+import Foundation
+import Alamofire
+
+final class AlamofireManager {
+    
+    static func getData(withURL url: String, withCompletion completion: ((withData: NSData?) ->Void)?) {
+    
+        Alamofire.request(.GET, url)
+            .responseString { response in
+                
+                println("\(response)")
+                
+                guard let Completion = completion else {
+                    fatalError("Not found Closure completion")
+                }
+                
+                if response.result.isSuccess {
+                    
+                    Completion(withData: response.data)
+
+                } else {
+                    println("get data by Alamofire fail")
+                    Completion(withData: nil)
+                }
+        }
+        
+    }
+}
\ No newline at end of file
diff --git a/CRMCall092016/Library/SWXMLHashManager.swift b/CRMCall092016/Library/SWXMLHashManager.swift
new file mode 100644
index 0000000..aa21a07
--- /dev/null
+++ b/CRMCall092016/Library/SWXMLHashManager.swift
@@ -0,0 +1,113 @@
+//
+//  SWXMLHashManager.swift
+//  CRMCall092016
+//
+//  Created by Hanbiro on 9/8/16.
+//  Copyright © 2016 xuanvinhtd. All rights reserved.
+//
+
+import Foundation
+
+import SWXMLHash
+
+
+final class SWXMLHashManager {
+    
+    // MARK: - XML PARSER
+    static func parseXMLToDictionary(withXML xmlData: String) -> [String: String] {
+        
+        let xmlDocument = SWXMLHash.parse(xmlData)
+        
+        if let _ = xmlDocument["XML"]["USER"].element {
+            return userData(withData: xmlDocument)
+        }
+        
+        if let _ = xmlDocument["XML"]["SERVERINFO"].element {
+            return getHostAndPost(withData: xmlDocument)
+        }
+        
+        return [:]
+    }
+    
+    private static func userData(withData data: XMLIndexer) -> [String: String]{
+        
+        if let _ = data["XML"]["USER"]["LOGIN"].element {
+            
+            guard let userDictionnary = data["XML"]["USER"].element else {
+                println("Cannot parse XML: USER LOGIN")
+                return [:]
+            }
+            
+            println("Result parse User: --------XXX------- \n \(userDictionnary)")
+            
+            NSNotificationCenter.defaultCenter().postNotificationName(ViewController.Notification.loginSuccess, object: nil, userInfo: nil)
+            
+            return userDictionnary.attributes
+        }
+        
+        if let _ = data["XML"]["USER"]["LOGOUT"].element {
+
+            guard let userDictionnary = data["XML"]["USER"].element else {
+                println("Cannot parse XML: USER LOGIN")
+                return [:]
+            }
+
+            println("Result parse User: --------XXX------- \n \(userDictionnary)")
+            
+            NSNotificationCenter.defaultCenter().postNotificationName(ViewController.Notification.logoutSuccess, object: nil, userInfo: nil)
+            
+            return userDictionnary.attributes
+        }
+        
+        return [:]
+    }
+
+    private static func getHostAndPost(withData data: XMLIndexer) -> [String: String]{
+
+        guard let userDictionnary = data["XML"]["SERVERINFO"].element else {
+            println("Cannot parse XML: SERVERINFO")
+            return [:]
+        }
+        
+        println("Result parse SERVERINFO: --------XXX------- \n \(userDictionnary)")
+        
+        return userDictionnary.attributes
+    }
+}
+
+// MARK: USER
+struct User: XMLIndexerDeserializable {
+    let baseURL: String?
+    let cacheProduct: Int?
+    let cachePurpose: String?
+    let companyPhone: String?
+    let email: String?
+    let nickName: String?
+    let id: String?
+    let localPhone: String?
+    let mobilePhone: String?
+    let telephone: String?
+    let sex: String?
+    let userKey: String?
+    let userName: String?
+    let result: String?
+    
+    static func deserialize(note: XMLIndexer) throws -> User {
+        return try User(
+            baseURL: note["BASEURL"].value(),
+            cacheProduct: note["CACHE_PRODUCT"].value(),
+            cachePurpose: note["CACHE_PURPOSE"].value(),
+            companyPhone: note["COMPANYPHONE"].value(),
+            email: note["EMAIL"].value(),
+            nickName: note["NICKNAME"].value(),
+            id: note["ID"].value(),
+            localPhone: note["LOCALPHONE"].value(),
+            mobilePhone: note["MOBILEPHONE"].value(),
+            telephone: note["TELEPHONE"].value(),
+            sex: note["SEX"].value(),
+            userKey: note["USERKEY"].value(),
+            userName: note["USERNAME"].value(),
+            result: note["RESULT"].value()
+        )
+    }
+}
\ No newline at end of file
diff --git a/CRMCall092016/Models/ModelManger.swift b/CRMCall092016/Models/ModelManger.swift
new file mode 100644
index 0000000..2ec3b9e
--- /dev/null
+++ b/CRMCall092016/Models/ModelManger.swift
@@ -0,0 +1,12 @@
+//
+//  User.swift
+//  CRMCall092016
+//
+//  Created by Hanbiro on 9/8/16.
+//  Copyright © 2016 xuanvinhtd. All rights reserved.
+//
+
+import Foundation
+
+
+
diff --git a/CRMCall092016/Server/.DS_Store b/CRMCall092016/Server/.DS_Store
new file mode 100644
index 0000000..5008ddf
Binary files /dev/null and b/CRMCall092016/Server/.DS_Store differ
diff --git a/CRMCall092016/Server/Socket/BaseSocket.swift b/CRMCall092016/Server/Socket/BaseSocket.swift
new file mode 100644
index 0000000..a74e975
--- /dev/null
+++ b/CRMCall092016/Server/Socket/BaseSocket.swift
@@ -0,0 +1,178 @@
+//
+//  SocketManager.swift
+//  CRMCall092016
+//
+//  Created by Hanbiro on 9/7/16.
+//  Copyright © 2016 xuanvinhtd. All rights reserved.
+//
+
+import Foundation
+import CocoaAsyncSocket
+
+class BaseSocket: NSObject {
+    
+    // MARK: - Properties
+    private var flagEncrypt: String = "1"
+    private var readTimeOut: Double = 60.0
+    private var writeTimeOut: Double = 5.0
+    
+    var isConnectedToHost: Bool = false
+    
+    private var aesExtension: AESExtension
+    private var asynSocket: GCDAsyncSocket!
+
+    private var port: UInt16
+    private var host: String
+    
+    // MARK: - Initialize
+    
+    init(withHost host: String, port: UInt16) {
+
+        self.host = host
+        self.port = port
+        self.aesExtension = AESExtension()
+        
+        super.init()
+        
+        self.asynSocket = GCDAsyncSocket(delegate: self, delegateQueue: dispatch_get_main_queue())
+    }
+    
+    override init() {
+        
+        self.host = ""
+        self.port = 0
+        self.aesExtension = AESExtension()
+        
+        super.init()
+        
+        self.asynSocket = GCDAsyncSocket(delegate: self, delegateQueue: dispatch_get_main_queue())
+        
+        getIdAndHost()
+    }
+    
+    // MARK: - Socket handling
+    
+    func connect() {
+        
+        do {
+
+           try asynSocket.connectToHost(host, onPort: port)
+            
+        } catch let err {
+            println("Error connect socket: \(err)")
+        }
+    }
+    
+    func disConnect() {
+        
+        asynSocket.disconnect()
+        
+        isConnectedToHost = false
+    }
+    
+    func configData(withData strData: String) {
+        
+        let encryptData = aesExtension.aesEncryptString(strData)
+        
+        let headerData = String(format: "%05lu", (encryptData?.characters.count)! + 1)
+        
+        let requestData = headerData + String(format: "%@%@", flagEncrypt, encryptData!)
+        
+        sendData(requestData.dataUsingEncoding(NSUTF8StringEncoding)!)
+    }
+    
+   private func sendData(data: NSData) {
+    
+    asynSocket.writeData(data, withTimeout: writeTimeOut, tag: CRMCallConfig.Tab.Default)
+    
+    }
+    
+    private func getIdAndHost() {
+        
+        AlamofireManager.getData(withURL: CRMCallConfig.API.GetPortAndHostURL) { response in
+            
+            guard let _response = response else {
+                println("Cannot get port and host to hostName: \(CRMCallConfig.HostName)")
+                return
+            }
+            
+            guard let result = NSString(data: _response, encoding: NSUTF8StringEncoding) as? String else {
+                println("Not found data to server")
+                return
+            }
+            
+            let resultDic = SWXMLHashManager.parseXMLToDictionary(withXML: result)
+            
+            if let port = resultDic["PORT"], host = resultDic["IP"] {
+                self.port = UInt16(port)!
+                self.host = host
+            } else {
+                println("Cannot parse port and host: \(CRMCallConfig.HostName)")
+            }
+            
+            NSNotificationCenter.defaultCenter().postNotificationName(ViewController.Notification.connectToHost, object: nil, userInfo: nil)
+        }
+    }
+}
+
+// MARK: - Socket Delegate 
+extension BaseSocket: GCDAsyncSocketDelegate {
+    
+    func socket(sock: GCDAsyncSocket, didReadData data: NSData, withTag tag: Int) {
+        
+        if tag == CRMCallConfig.Tab.Header {
+            
+            guard let headerData = NSString(data: data, encoding: NSUTF8StringEncoding) else {
+                fatalError("Not found header data")
+            }
+
+            println("Data header: \(headerData)")
+            
+            let lenghtHeader = (UInt(headerData.substringToIndex(5))! - 1)
+            flagEncrypt = headerData.substringFromIndex(5)
+            
+            asynSocket.readDataToLength(lenghtHeader, withTimeout: readTimeOut , tag: CRMCallConfig.Tab.BodyData)
+            
+            
+        } else if (tag == CRMCallConfig.Tab.BodyData) {
+            
+            guard let bodyData = NSString(data: data, encoding: NSUTF8StringEncoding) as? String else {
+                fatalError("Not found body data")
+            }
+
+            var decryptBodyData = ""
+            
+            if flagEncrypt == "1" {
+                
+                guard let dataDecrypt = aesExtension.aesDecryptString(bodyData) else {
+                    fatalError("Not Decrypt body data")
+                }
+                
+                decryptBodyData = dataDecrypt
+            } else {
+                decryptBodyData = bodyData
+            }
+            
+            println("Data body: \(decryptBodyData)")
+            
+            asynSocket.readDataToLength(CRMCallConfig.HeaderLength, withTimeout: readTimeOut, tag: CRMCallConfig.Tab.Header)
+            
+            SWXMLHashManager.parseXMLToDictionary(withXML: decryptBodyData)
+        }
+    }
+    
+    func socket(sock: GCDAsyncSocket, didWritePartialDataOfLength partialLength: UInt, tag: Int) {
+        println("lenght: \(partialLength)")
+    }
+    
+    func socket(sock: GCDAsyncSocket, didConnectToHost host: String, port: UInt16) {
+        
+        println("Did connet to host: \(host) and post: \(port)")
+        
+        isConnectedToHost = true
+        
+        asynSocket.readDataToLength(CRMCallConfig.HeaderLength, withTimeout: readTimeOut, tag: CRMCallConfig.Tab.Header)
+        
+        NSNotificationCenter.defaultCenter().postNotificationName(CRMCallConfig.Notification.SocketDidConnected, object: nil, userInfo: nil)
+    }
+}
diff --git a/CRMCall092016/Server/Socket/CRMCallSocket.swift b/CRMCall092016/Server/Socket/CRMCallSocket.swift
new file mode 100644
index 0000000..bcc5fb3
--- /dev/null
+++ b/CRMCall092016/Server/Socket/CRMCallSocket.swift
@@ -0,0 +1,40 @@
+//
+//  CRMCallSocket.swift
+//  CRMCall092016
+//
+//  Created by Hanbiro on 9/12/16.
+//  Copyright © 2016 xuanvinhtd. All rights reserved.
+//
+
+import Foundation
+
+final class CRMCallSocket: BaseSocket {
+    
+    // MARK: - Properties
+    var timerLive: String
+    
+    // MARK: - Initialzation
+    override init() {
+        
+        timerLive = ""
+        super.init()
+        
+    }
+    
+    // MARK: - COMUNICATION API
+    
+    func requestLogin(withUserID userID: String, passwold: String, domain: String) {
+        
+        let xmlLogin = XMLRequestBuilder.loginRequest(with: userID, pass: passwold, domain: domain)
+        
+        configData(withData: xmlLogin)
+    }
+    
+    func requestLogout() {
+        
+        let xmlLogOut = XMLRequestBuilder.logOutRequest()
+        
+        configData(withData: xmlLogOut)
+    }
+    
+}
\ No newline at end of file
diff --git a/CRMCall092016/Server/Socket/SocketManager.swift b/CRMCall092016/Server/Socket/SocketManager.swift
deleted file mode 100644
index 13022fb..0000000
--- a/CRMCall092016/Server/Socket/SocketManager.swift
+++ /dev/null
@@ -1,98 +0,0 @@
-//
-//  SocketManager.swift
-//  CRMCall092016
-//
-//  Created by Hanbiro on 9/7/16.
-//  Copyright © 2016 xuanvinhtd. All rights reserved.
-//
-
-import Foundation
-import CocoaAsyncSocket
-
-class SocketManager: NSObject {
-    
-    // MARK: - Properties
-    private var flagEncrypt: String = "1"
-    private var readTimeOut: Double = 60.0
-    private var writeTimeOut: Double = 5.0
-    
-    private var aesExtension: AESExtension?
-    private var asynSocket: GCDAsyncSocket?
-    
-    private var port: UInt16?
-    private var host: String?
-    
-    // MARK: - Initialize
-     init (with host: String, port: UInt16) {
-        
-        super.init()
-        
-        self.host = host
-        self.port = port
-        self.aesExtension = AESExtension()
-        self.asynSocket = GCDAsyncSocket(delegate: self, delegateQueue: dispatch_get_main_queue())
-    }
-    
-    // MARK: - Socket handling
-    func connect() {
-        
-        guard let host = self.host, port = self.port else { fatalError() }
-        
-        do {
-
-           try asynSocket?.connectToHost(host, onPort: port)
-            
-        } catch let err {
-            println("Error connect socket: \(err)")
-        }
-    }
-    
-    func disConnect() {
-        
-        guard let socket = self.asynSocket else { fatalError() }
-        
-        socket.disconnect()
-    }
-    
-    func configData(With strData: String) {
-        
-        let encryptData = aesExtension?.aesEncryptString(strData)
-        
-        let headerData = String(format: "%05lu", (encryptData?.characters.count)! + 1)
-        
-        let requestData = headerData + String(format: "%@%@", flagEncrypt, encryptData!)
-        
-        sendData(requestData.dataUsingEncoding(NSUTF8StringEncoding)!)
-    }
-    
-    func sendData(data: NSData) {
-        asynSocket?.writeData(data, withTimeout: writeTimeOut, tag: CRMCallConfig.Tab.Default)
-    }
-    
-}
-
-// MARK: - Delegate Socket
-extension SocketManager: GCDAsyncSocketDelegate {
-    
-    func socket(sock: GCDAsyncSocket, didReadData data: NSData, withTag tag: Int) {
-        
-        if tag == CRMCallConfig.Tab.Header {
-            print("data server: \(data)")
-        } else if (tag == CRMCallConfig.Tab.BodyData) {
-            
-        } else {
-            
-        }
-        
-    }
-    
-    func socket(sock: GCDAsyncSocket, didWritePartialDataOfLength partialLength: UInt, tag: Int) {
-        print("lenght: \(partialLength)")
-    }
-    
-    func socket(sock: GCDAsyncSocket, didConnectToHost host: String, port: UInt16) {
-        
-        println("DidConnet to host: \(host) and post: \(port)")
-        
-    }
-}
diff --git a/CRMCall092016/Server/XMLRequestBuilder.swift b/CRMCall092016/Server/XMLRequestBuilder.swift
deleted file mode 100644
index 202f606..0000000
--- a/CRMCall092016/Server/XMLRequestBuilder.swift
+++ /dev/null
@@ -1,20 +0,0 @@
-//
-//  XMLRequestBuilder.swift
-//  CRMCall092016
-//
-//  Created by Hanbiro on 9/7/16.
-//  Copyright © 2016 xuanvinhtd. All rights reserved.
-//
-
-import Foundation
-
-final class XMLRequestBuilder {
-    
-    // MARK: - LOGIN/LOGOUT
-    class func createLoginRequest(with userID: String, pass: String, domain: String) -> String {
-        
-        let xml = String(format: "<XML> <VER>%@</VER> <USER> <LOGIN ID=\"%@\" PASSWORD=\"%@\" DOMAIN=\"%@\" VER=\"1.0\" ISPTYPE=\"\" PHONE=\"\" DEVICE=\"%@\"></LOGIN> </USER> </XML>", CRMCallConfig.Version, userID, pass, domain, CRMCallConfig.DeviceID)
-        
-        return xml
-    }
-}
\ No newline at end of file
diff --git a/CRMCall092016/ViewController.swift b/CRMCall092016/ViewController.swift
index 95fd570..7872dd3 100644
--- a/CRMCall092016/ViewController.swift
+++ b/CRMCall092016/ViewController.swift
@@ -10,22 +10,126 @@ import Cocoa
 
 class ViewController: NSViewController {
 
-    var aesExtension: AESExtension?
+    // MARK: - Properties
+    private var socketManager: BaseSocket!
+    
+    private var handlerNotificationSocketDidConnected: AnyObject?
+    private var handlerNotificationLoginSuccess: AnyObject?
+    private var handlerNotificationLogoutSuccess: AnyObject?
+    private var handlerNotificationConnectToHost: AnyObject?
+    
+    @IBOutlet weak var domanTextField: NSTextField!
+    @IBOutlet weak var userTextField: NSTextField!
+    @IBOutlet weak var passTextField: NSSecureTextField!
+    @IBOutlet weak var statusLogin: NSTextField!
+    
+    // MARK: - View life cycle
     
     override func viewDidLoad() {
         super.viewDidLoad()
-
-        aesExtension = AESExtension()
         
-        // Do any additional setup after loading the view.
+        registerNotification()
+        
+        socketManager = CRMCallSocket()
     }
 
+    deinit {
+        deRegisterNotification()
+    }
+    
     override var representedObject: AnyObject? {
         didSet {
         // Update the view, if already loaded.
         }
     }
+    
+    
+    // MARK: - Handling event
+    
+    @IBAction func actionLogin(sender: AnyObject) {
+        
+        if socketManager.isConnectedToHost == true {
+            
+            requestLogin(withUserID: userTextField.stringValue, pass: passTextField.stringValue, domain: domanTextField.stringValue)
+        } else {
+            println("Waiting connect to server .....")
+        }
+        
+    }
+    
+    @IBAction func actionLogout(sender: AnyObject) {
+        
+        if socketManager.isConnectedToHost == true {
+            requestLogOut()
+        } else {
+            println("Disconnect to server")
+        }
 
-
+    }
+    
+    // MARK: - Notification
+    struct Notification {
+        static let loginSuccess = "LoginSuccessNotification"
+        static let logoutSuccess = "LogoutSuccessNotification"
+        static let connectToHost = "ConnectHostNotification"
+    }
+    
+    private func registerNotification() {
+        
+        handlerNotificationSocketDidConnected = NSNotificationCenter.defaultCenter().addObserverForName(CRMCallConfig.Notification.SocketDidConnected, object: nil, queue: nil) { notification in
+            
+            println("\(notification)")
+        }
+        
+        handlerNotificationLoginSuccess = NSNotificationCenter.defaultCenter().addObserverForName(ViewController.Notification.loginSuccess, object: nil, queue: nil) { notification in
+            
+            println("\(notification)")
+            self.statusLogin.hidden = false
+        }
+        
+        handlerNotificationLogoutSuccess = NSNotificationCenter.defaultCenter().addObserverForName(ViewController.Notification.logoutSuccess, object: nil, queue: nil) { notification in
+            
+            println("\(notification)")
+            self.statusLogin.hidden = true
+        }
+        
+        handlerNotificationConnectToHost = NSNotificationCenter.defaultCenter().addObserverForName(ViewController.Notification.connectToHost, object: nil, queue: nil) { notification in
+            
+            println("\(notification)")
+            
+            self.socketManager.connect()
+        }
+    }
+    
+    private func deRegisterNotification() {
+        
+        if let notification = handlerNotificationSocketDidConnected {
+            NSNotificationCenter.defaultCenter().removeObserver(notification)
+        }
+        
+        if let notification = handlerNotificationLoginSuccess {
+            NSNotificationCenter.defaultCenter().removeObserver(notification)
+        }
+        
+        if let notification = handlerNotificationLogoutSuccess {
+            NSNotificationCenter.defaultCenter().removeObserver(notification)
+        }
+        
+        if let notification = handlerNotificationConnectToHost {
+            NSNotificationCenter.defaultCenter().removeObserver(notification)
+        }
+    }
+    
+    // MARK: - USER LOGIN/OUT
+    private func requestLogin(withUserID userID: String, pass: String, domain: String) {
+        
+        let xmlLogin = XMLRequestBuilder.loginRequest(with: userID, pass: pass, domain: domain)
+        
+        socketManager.configData(withData: xmlLogin)
+    }
+    
+    private func requestLogOut() {
+        
+    }
 }
 
diff --git a/Podfile b/Podfile
index 3f528b0..f57e6c5 100644
--- a/Podfile
+++ b/Podfile
@@ -5,6 +5,9 @@ project 'CRMCall092016.xcodeproj'
 
 target 'CRMCall092016' do
  use_frameworks!
+ 
 pod 'CocoaAsyncSocket'
+pod 'Alamofire'
+pod 'SWXMLHash'
 
 end
diff --git a/Podfile.lock b/Podfile.lock
index 4be331a..0ae9987 100644
--- a/Podfile.lock
+++ b/Podfile.lock
@@ -1,14 +1,20 @@
 PODS:
+  - Alamofire (3.4.1)
   - CocoaAsyncSocket (7.5.0):
     - CocoaAsyncSocket/GCD (= 7.5.0)
   - CocoaAsyncSocket/GCD (7.5.0)
+  - SWXMLHash (2.4.0)
 
 DEPENDENCIES:
+  - Alamofire
   - CocoaAsyncSocket
+  - SWXMLHash
 
 SPEC CHECKSUMS:
+  Alamofire: 01a82e2f6c0f860ade35534c8dd88be61bdef40c
   CocoaAsyncSocket: 3baeb1ddd969f81cf9fca81053ae49ef2d1cbbfa
+  SWXMLHash: 507397103325f140863d09040c04ae14a49a16cb
 
-PODFILE CHECKSUM: e6332a1e2227a6d3ff82fcc374286642be589891
+PODFILE CHECKSUM: 3d088204bac8fcec64bd2420b15ef2f3c7764d77
 
 COCOAPODS: 1.0.0
diff --git a/Pods/Alamofire/LICENSE b/Pods/Alamofire/LICENSE
new file mode 100644
index 0000000..4cfbf72
--- /dev/null
+++ b/Pods/Alamofire/LICENSE
@@ -0,0 +1,19 @@
+Copyright (c) 2014-2016 Alamofire Software Foundation (http://alamofire.org/)
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
diff --git a/Pods/Alamofire/README.md b/Pods/Alamofire/README.md
new file mode 100644
index 0000000..56a6771
--- /dev/null
+++ b/Pods/Alamofire/README.md
@@ -0,0 +1,1297 @@
+![Alamofire: Elegant Networking in Swift](https://raw.githubusercontent.com/Alamofire/Alamofire/assets/alamofire.png)
+
+[![Build Status](https://travis-ci.org/Alamofire/Alamofire.svg)](https://travis-ci.org/Alamofire/Alamofire)
+[![CocoaPods Compatible](https://img.shields.io/cocoapods/v/Alamofire.svg)](https://img.shields.io/cocoapods/v/Alamofire.svg)
+[![Carthage Compatible](https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat)](https://github.com/Carthage/Carthage)
+[![Platform](https://img.shields.io/cocoapods/p/Alamofire.svg?style=flat)](http://cocoadocs.org/docsets/Alamofire)
+[![Twitter](https://img.shields.io/badge/twitter-@AlamofireSF-blue.svg?style=flat)](http://twitter.com/AlamofireSF)
+
+Alamofire is an HTTP networking library written in Swift.
+
+## Features
+
+- [x] Chainable Request / Response methods
+- [x] URL / JSON / plist Parameter Encoding
+- [x] Upload File / Data / Stream / MultipartFormData
+- [x] Download using Request or Resume data
+- [x] Authentication with NSURLCredential
+- [x] HTTP Response Validation
+- [x] TLS Certificate and Public Key Pinning
+- [x] Progress Closure & NSProgress
+- [x] cURL Debug Output
+- [x] Comprehensive Unit Test Coverage
+- [x] [Complete Documentation](http://cocoadocs.org/docsets/Alamofire)
+
+## Component Libraries
+
+In order to keep Alamofire focused specifically on core networking implementations, additional component libraries have been created by the [Alamofire Software Foundation](https://github.com/Alamofire/Foundation) to bring additional functionality to the Alamofire ecosystem.
+
+* [AlamofireImage](https://github.com/Alamofire/AlamofireImage) - An image library including image response serializers, `UIImage` and `UIImageView` extensions, custom image filters, an auto-purging in-memory cache and a priority-based image downloading system.
+* [AlamofireNetworkActivityIndicator](https://github.com/Alamofire/AlamofireNetworkActivityIndicator) - Controls the visibility of the network activity indicator on iOS using Alamofire. It contains configurable delay timers to help mitigate flicker and can support `NSURLSession` instances not managed by Alamofire.
+
+## Requirements
+
+- iOS 8.0+ / Mac OS X 10.9+ / tvOS 9.0+ / watchOS 2.0+
+- Xcode 7.3+
+
+## Migration Guides
+
+- [Alamofire 3.0 Migration Guide](https://github.com/Alamofire/Alamofire/blob/master/Documentation/Alamofire%203.0%20Migration%20Guide.md)
+- [Alamofire 2.0 Migration Guide](https://github.com/Alamofire/Alamofire/blob/master/Documentation/Alamofire%202.0%20Migration%20Guide.md)
+
+## Communication
+
+- If you **need help**, use [Stack Overflow](http://stackoverflow.com/questions/tagged/alamofire). (Tag 'alamofire')
+- If you'd like to **ask a general question**, use [Stack Overflow](http://stackoverflow.com/questions/tagged/alamofire).
+- If you **found a bug**, open an issue.
+- If you **have a feature request**, open an issue.
+- If you **want to contribute**, submit a pull request.
+
+## Installation
+
+> **Embedded frameworks require a minimum deployment target of iOS 8 or OS X Mavericks (10.9).**
+>
+> Alamofire is no longer supported on iOS 7 due to the lack of support for frameworks. Without frameworks, running Travis-CI against iOS 7 would require a second duplicated test target. The separate test suite would need to import all the Swift files and the tests would need to be duplicated and re-written. This split would be too difficult to maintain to ensure the highest possible quality of the Alamofire ecosystem.
+
+### CocoaPods
+
+[CocoaPods](http://cocoapods.org) is a dependency manager for Cocoa projects. You can install it with the following command:
+
+```bash
+$ gem install cocoapods
+```
+
+> CocoaPods 0.39.0+ is required to build Alamofire 3.0.0+.
+
+To integrate Alamofire into your Xcode project using CocoaPods, specify it in your `Podfile`:
+
+```ruby
+source 'https://github.com/CocoaPods/Specs.git'
+platform :ios, '9.0'
+use_frameworks!
+
+target '<Your Target Name>' do
+    pod 'Alamofire', '~> 3.4'
+end
+```
+
+Then, run the following command:
+
+```bash
+$ pod install
+```
+
+### Carthage
+
+[Carthage](https://github.com/Carthage/Carthage) is a decentralized dependency manager that builds your dependencies and provides you with binary frameworks.
+
+You can install Carthage with [Homebrew](http://brew.sh/) using the following command:
+
+```bash
+$ brew update
+$ brew install carthage
+```
+
+To integrate Alamofire into your Xcode project using Carthage, specify it in your `Cartfile`:
+
+```ogdl
+github "Alamofire/Alamofire" ~> 3.4
+```
+
+Run `carthage update` to build the framework and drag the built `Alamofire.framework` into your Xcode project.
+
+### Manually
+
+If you prefer not to use either of the aforementioned dependency managers, you can integrate Alamofire into your project manually.
+
+#### Embedded Framework
+
+- Open up Terminal, `cd` into your top-level project directory, and run the following command "if" your project is not initialized as a git repository:
+
+```bash
+$ git init
+```
+
+- Add Alamofire as a git [submodule](http://git-scm.com/docs/git-submodule) by running the following command:
+
+```bash
+$ git submodule add https://github.com/Alamofire/Alamofire.git
+```
+
+- Open the new `Alamofire` folder, and drag the `Alamofire.xcodeproj` into the Project Navigator of your application's Xcode project.
+
+    > It should appear nested underneath your application's blue project icon. Whether it is above or below all the other Xcode groups does not matter.
+
+- Select the `Alamofire.xcodeproj` in the Project Navigator and verify the deployment target matches that of your application target.
+- Next, select your application project in the Project Navigator (blue project icon) to navigate to the target configuration window and select the application target under the "Targets" heading in the sidebar.
+- In the tab bar at the top of that window, open the "General" panel.
+- Click on the `+` button under the "Embedded Binaries" section.
+- You will see two different `Alamofire.xcodeproj` folders each with two different versions of the `Alamofire.framework` nested inside a `Products` folder.
+
+    > It does not matter which `Products` folder you choose from, but it does matter whether you choose the top or bottom `Alamofire.framework`. 
+    
+- Select the top `Alamofire.framework` for iOS and the bottom one for OS X.
+
+    > You can verify which one you selected by inspecting the build log for your project. The build target for `Alamofire` will be listed as either `Alamofire iOS` or `Alamofire OSX`.
+
+- And that's it!
+
+> The `Alamofire.framework` is automagically added as a target dependency, linked framework and embedded framework in a copy files build phase which is all you need to build on the simulator and a device.
+
+---
+
+## Usage
+
+### Making a Request
+
+```swift
+import Alamofire
+
+Alamofire.request(.GET, "https://httpbin.org/get")
+```
+
+### Response Handling
+
+```swift
+Alamofire.request(.GET, "https://httpbin.org/get", parameters: ["foo": "bar"])
+         .responseJSON { response in
+             print(response.request)  // original URL request
+             print(response.response) // URL response
+             print(response.data)     // server data
+             print(response.result)   // result of response serialization
+
+             if let JSON = response.result.value {
+                 print("JSON: \(JSON)")
+             }
+         }
+```
+
+> Networking in Alamofire is done _asynchronously_. Asynchronous programming may be a source of frustration to programmers unfamiliar with the concept, but there are [very good reasons](https://developer.apple.com/library/ios/qa/qa1693/_index.html) for doing it this way.
+
+> Rather than blocking execution to wait for a response from the server, a [callback](http://en.wikipedia.org/wiki/Callback_%28computer_programming%29) is specified to handle the response once it's received. The result of a request is only available inside the scope of a response handler. Any execution contingent on the response or data received from the server must be done within a handler.
+
+### Validation
+
+By default, Alamofire treats any completed request to be successful, regardless of the content of the response. Calling `validate` before a response handler causes an error to be generated if the response had an unacceptable status code or MIME type.
+
+#### Manual Validation
+
+```swift
+Alamofire.request(.GET, "https://httpbin.org/get", parameters: ["foo": "bar"])
+         .validate(statusCode: 200..<300)
+         .validate(contentType: ["application/json"])
+         .response { response in
+             print(response)
+         }
+```
+
+#### Automatic Validation
+
+Automatically validates status code within `200...299` range, and that the `Content-Type` header of the response matches the `Accept` header of the request, if one is provided.
+
+```swift
+Alamofire.request(.GET, "https://httpbin.org/get", parameters: ["foo": "bar"])
+         .validate()
+         .responseJSON { response in
+             switch response.result {
+             case .Success:
+                 print("Validation Successful")
+             case .Failure(let error):
+                 print(error)
+             }
+         }
+```
+
+### Response Serialization
+
+**Built-in Response Methods**
+
+- `response()`
+- `responseData()`
+- `responseString(encoding: NSStringEncoding)`
+- `responseJSON(options: NSJSONReadingOptions)`
+- `responsePropertyList(options: NSPropertyListReadOptions)`
+
+#### Response Handler
+
+```swift
+Alamofire.request(.GET, "https://httpbin.org/get", parameters: ["foo": "bar"])
+         .validate()
+         .response { request, response, data, error in
+             print(request)
+             print(response)
+             print(data)
+             print(error)
+          }
+```
+
+> The `response` serializer does NOT evaluate any of the response data. It merely forwards on all the information directly from the URL session delegate. We strongly encourage you to leverage the other response serializers taking advantage of `Response` and `Result` types.
+
+#### Response Data Handler
+
+```swift
+Alamofire.request(.GET, "https://httpbin.org/get", parameters: ["foo": "bar"])
+         .validate()
+         .responseData { response in
+             print(response.request)
+             print(response.response)
+             print(response.result)
+          }
+```
+
+#### Response String Handler
+
+```swift
+Alamofire.request(.GET, "https://httpbin.org/get")
+         .validate()
+         .responseString { response in
+             print("Success: \(response.result.isSuccess)")
+             print("Response String: \(response.result.value)")
+         }
+```
+
+#### Response JSON Handler
+
+```swift
+Alamofire.request(.GET, "https://httpbin.org/get")
+         .validate()
+         .responseJSON { response in
+             debugPrint(response)
+         }
+```
+
+#### Chained Response Handlers
+
+Response handlers can even be chained:
+
+```swift
+Alamofire.request(.GET, "https://httpbin.org/get")
+         .validate()
+         .responseString { response in
+             print("Response String: \(response.result.value)")
+         }
+         .responseJSON { response in
+             print("Response JSON: \(response.result.value)")
+         }
+```
+
+### HTTP Methods
+
+`Alamofire.Method` lists the HTTP methods defined in [RFC 7231 §4.3](http://tools.ietf.org/html/rfc7231#section-4.3):
+
+```swift
+public enum Method: String {
+    case OPTIONS, GET, HEAD, POST, PUT, PATCH, DELETE, TRACE, CONNECT
+}
+```
+
+These values can be passed as the first argument of the `Alamofire.request` method:
+
+```swift
+Alamofire.request(.POST, "https://httpbin.org/post")
+
+Alamofire.request(.PUT, "https://httpbin.org/put")
+
+Alamofire.request(.DELETE, "https://httpbin.org/delete")
+```
+
+### Parameters
+
+#### GET Request With URL-Encoded Parameters
+
+```swift
+Alamofire.request(.GET, "https://httpbin.org/get", parameters: ["foo": "bar"])
+// https://httpbin.org/get?foo=bar
+```
+
+#### POST Request With URL-Encoded Parameters
+
+```swift
+let parameters = [
+    "foo": "bar",
+    "baz": ["a", 1],
+    "qux": [
+        "x": 1,
+        "y": 2,
+        "z": 3
+    ]
+]
+
+Alamofire.request(.POST, "https://httpbin.org/post", parameters: parameters)
+// HTTP body: foo=bar&baz[]=a&baz[]=1&qux[x]=1&qux[y]=2&qux[z]=3
+```
+
+### Parameter Encoding
+
+Parameters can also be encoded as JSON, Property List, or any custom format, using the `ParameterEncoding` enum:
+
+```swift
+enum ParameterEncoding {
+    case URL
+    case URLEncodedInURL
+    case JSON
+    case PropertyList(format: NSPropertyListFormat, options: NSPropertyListWriteOptions)
+    case Custom((URLRequestConvertible, [String: AnyObject]?) -> (NSMutableURLRequest, NSError?))
+
+    func encode(request: NSURLRequest, parameters: [String: AnyObject]?) -> (NSURLRequest, NSError?)
+    { ... }
+}
+```
+
+- `URL`: A query string to be set as or appended to any existing URL query for `GET`, `HEAD`, and `DELETE` requests, or set as the body for requests with any other HTTP method. The `Content-Type` HTTP header field of an encoded request with HTTP body is set to `application/x-www-form-urlencoded`. _Since there is no published specification for how to encode collection types, Alamofire follows the convention of appending `[]` to the key for array values (`foo[]=1&foo[]=2`), and appending the key surrounded by square brackets for nested dictionary values (`foo[bar]=baz`)._
+- `URLEncodedInURL`: Creates query string to be set as or appended to any existing URL query. Uses the same implementation as the `.URL` case, but always applies the encoded result to the URL.
+- `JSON`: Uses `NSJSONSerialization` to create a JSON representation of the parameters object, which is set as the body of the request. The `Content-Type` HTTP header field of an encoded request is set to `application/json`.
+- `PropertyList`: Uses `NSPropertyListSerialization` to create a plist representation of the parameters object, according to the associated format and write options values, which is set as the body of the request. The `Content-Type` HTTP header field of an encoded request is set to `application/x-plist`.
+- `Custom`: Uses the associated closure value to construct a new request given an existing request and parameters.
+
+#### Manual Parameter Encoding of an NSURLRequest
+
+```swift
+let URL = NSURL(string: "https://httpbin.org/get")!
+var request = NSMutableURLRequest(URL: URL)
+
+let parameters = ["foo": "bar"]
+let encoding = Alamofire.ParameterEncoding.URL
+(request, _) = encoding.encode(request, parameters: parameters)
+```
+
+#### POST Request with JSON-encoded Parameters
+
+```swift
+let parameters = [
+    "foo": [1,2,3],
+    "bar": [
+        "baz": "qux"
+    ]
+]
+
+Alamofire.request(.POST, "https://httpbin.org/post", parameters: parameters, encoding: .JSON)
+// HTTP body: {"foo": [1, 2, 3], "bar": {"baz": "qux"}}
+```
+
+### HTTP Headers
+
+Adding a custom HTTP header to a `Request` is supported directly in the global `request` method. This makes it easy to attach HTTP headers to a `Request` that can be constantly changing.
+
+> For HTTP headers that do not change, it is recommended to set them on the `NSURLSessionConfiguration` so they are automatically applied to any `NSURLSessionTask` created by the underlying `NSURLSession`.
+
+```swift
+let headers = [
+    "Authorization": "Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==",
+    "Accept": "application/json"
+]
+
+Alamofire.request(.GET, "https://httpbin.org/get", headers: headers)
+         .responseJSON { response in
+             debugPrint(response)
+         }
+```
+
+### Caching
+
+Caching is handled on the system framework level by [`NSURLCache`](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html#//apple_ref/occ/cl/NSURLCache).
+
+### Uploading
+
+**Supported Upload Types**
+
+- File
+- Data
+- Stream
+- MultipartFormData
+
+#### Uploading a File
+
+```swift
+let fileURL = NSBundle.mainBundle().URLForResource("Default", withExtension: "png")
+Alamofire.upload(.POST, "https://httpbin.org/post", file: fileURL)
+```
+
+#### Uploading with Progress
+
+```swift
+Alamofire.upload(.POST, "https://httpbin.org/post", file: fileURL)
+         .progress { bytesWritten, totalBytesWritten, totalBytesExpectedToWrite in
+             print(totalBytesWritten)
+
+             // This closure is NOT called on the main queue for performance
+             // reasons. To update your ui, dispatch to the main queue.
+             dispatch_async(dispatch_get_main_queue()) {
+                 print("Total bytes written on main queue: \(totalBytesWritten)")
+             }
+         }
+         .validate()
+         .responseJSON { response in
+             debugPrint(response)
+         }
+```
+
+#### Uploading MultipartFormData
+
+```swift
+Alamofire.upload(
+    .POST,
+    "https://httpbin.org/post",
+    multipartFormData: { multipartFormData in
+        multipartFormData.appendBodyPart(fileURL: unicornImageURL, name: "unicorn")
+        multipartFormData.appendBodyPart(fileURL: rainbowImageURL, name: "rainbow")
+    },
+    encodingCompletion: { encodingResult in
+    	switch encodingResult {
+    	case .Success(let upload, _, _):
+            upload.responseJSON { response in
+                debugPrint(response)
+            }
+    	case .Failure(let encodingError):
+    	    print(encodingError)
+    	}
+    }
+)
+```
+
+### Downloading
+
+**Supported Download Types**
+
+- Request
+- Resume Data
+
+#### Downloading a File
+
+```swift
+Alamofire.download(.GET, "https://httpbin.org/stream/100") { temporaryURL, response in
+    let fileManager = NSFileManager.defaultManager()
+    let directoryURL = fileManager.URLsForDirectory(.DocumentDirectory, inDomains: .UserDomainMask)[0]
+    let pathComponent = response.suggestedFilename
+
+    return directoryURL.URLByAppendingPathComponent(pathComponent!)
+}
+```
+
+#### Using the Default Download Destination
+
+```swift
+let destination = Alamofire.Request.suggestedDownloadDestination(directory: .DocumentDirectory, domain: .UserDomainMask)
+Alamofire.download(.GET, "https://httpbin.org/stream/100", destination: destination)
+```
+
+#### Downloading a File w/Progress
+
+```swift
+Alamofire.download(.GET, "https://httpbin.org/stream/100", destination: destination)
+         .progress { bytesRead, totalBytesRead, totalBytesExpectedToRead in
+             print(totalBytesRead)
+
+             // This closure is NOT called on the main queue for performance
+             // reasons. To update your ui, dispatch to the main queue.
+             dispatch_async(dispatch_get_main_queue()) {
+                 print("Total bytes read on main queue: \(totalBytesRead)")
+             }
+         }
+         .response { _, _, _, error in
+             if let error = error {
+                 print("Failed with error: \(error)")
+             } else {
+                 print("Downloaded file successfully")
+             }
+         }
+```
+
+#### Accessing Resume Data for Failed Downloads
+
+```swift
+Alamofire.download(.GET, "https://httpbin.org/stream/100", destination: destination)
+         .response { _, _, data, _ in
+             if let
+                 data = data,
+                 resumeDataString = NSString(data: data, encoding: NSUTF8StringEncoding)
+             {
+                 print("Resume Data: \(resumeDataString)")
+             } else {
+                 print("Resume Data was empty")
+             }
+         }
+```
+
+> The `data` parameter is automatically populated with the `resumeData` if available.
+
+```swift
+let download = Alamofire.download(.GET, "https://httpbin.org/stream/100", destination: destination)
+download.response { _, _, _, _ in
+    if let
+        resumeData = download.resumeData,
+        resumeDataString = NSString(data: resumeData, encoding: NSUTF8StringEncoding)
+    {
+        print("Resume Data: \(resumeDataString)")
+    } else {
+        print("Resume Data was empty")
+    }
+}
+```
+
+### Authentication
+
+Authentication is handled on the system framework level by [`NSURLCredential` and `NSURLAuthenticationChallenge`](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLAuthenticationChallenge_Class/Reference/Reference.html).
+
+**Supported Authentication Schemes**
+
+- [HTTP Basic](http://en.wikipedia.org/wiki/Basic_access_authentication)
+- [HTTP Digest](http://en.wikipedia.org/wiki/Digest_access_authentication)
+- [Kerberos](http://en.wikipedia.org/wiki/Kerberos_%28protocol%29)
+- [NTLM](http://en.wikipedia.org/wiki/NT_LAN_Manager)
+
+#### HTTP Basic Authentication
+
+The `authenticate` method on a `Request` will automatically provide an `NSURLCredential` to an `NSURLAuthenticationChallenge` when appropriate:
+
+```swift
+let user = "user"
+let password = "password"
+
+Alamofire.request(.GET, "https://httpbin.org/basic-auth/\(user)/\(password)")
+         .authenticate(user: user, password: password)
+         .responseJSON { response in
+             debugPrint(response)
+         }
+```
+
+Depending upon your server implementation, an `Authorization` header may also be appropriate:
+
+```swift
+let user = "user"
+let password = "password"
+
+let credentialData = "\(user):\(password)".dataUsingEncoding(NSUTF8StringEncoding)!
+let base64Credentials = credentialData.base64EncodedStringWithOptions([])
+
+let headers = ["Authorization": "Basic \(base64Credentials)"]
+
+Alamofire.request(.GET, "https://httpbin.org/basic-auth/user/password", headers: headers)
+         .responseJSON { response in
+             debugPrint(response)
+         }
+```
+
+#### Authentication with NSURLCredential
+
+```swift
+let user = "user"
+let password = "password"
+
+let credential = NSURLCredential(user: user, password: password, persistence: .ForSession)
+
+Alamofire.request(.GET, "https://httpbin.org/basic-auth/\(user)/\(password)")
+         .authenticate(usingCredential: credential)
+         .responseJSON { response in
+             debugPrint(response)
+         }
+```
+
+### Timeline
+
+Alamofire collects timings throughout the lifecycle of a `Request` and creates a `Timeline` object exposed as a property on a `Response`.
+
+```swift
+Alamofire.request(.GET, "https://httpbin.org/get", parameters: ["foo": "bar"])
+         .validate()
+         .responseJSON { response in
+             print(response.timeline)
+         }
+```
+
+The above reports the following `Timeline` info:
+
+- `Latency`: 0.428 seconds
+- `Request Duration`: 0.428 seconds
+- `Serialization Duration`: 0.001 seconds
+- `Total Duration`: 0.429 seconds
+
+### Printable
+
+```swift
+let request = Alamofire.request(.GET, "https://httpbin.org/ip")
+
+print(request)
+// GET https://httpbin.org/ip (200)
+```
+
+### DebugPrintable
+
+```swift
+let request = Alamofire.request(.GET, "https://httpbin.org/get", parameters: ["foo": "bar"])
+
+debugPrint(request)
+```
+
+#### Output (cURL)
+
+```bash
+$ curl -i \
+	-H "User-Agent: Alamofire" \
+	-H "Accept-Encoding: Accept-Encoding: gzip;q=1.0,compress;q=0.5" \
+	-H "Accept-Language: en;q=1.0,fr;q=0.9,de;q=0.8,zh-Hans;q=0.7,zh-Hant;q=0.6,ja;q=0.5" \
+	"https://httpbin.org/get?foo=bar"
+```
+
+---
+
+## Advanced Usage
+
+> Alamofire is built on `NSURLSession` and the Foundation URL Loading System. To make the most of
+this framework, it is recommended that you be familiar with the concepts and capabilities of the underlying networking stack.
+
+**Recommended Reading**
+
+- [URL Loading System Programming Guide](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html)
+- [NSURLSession Class Reference](https://developer.apple.com/library/mac/documentation/Foundation/Reference/NSURLSession_class/Introduction/Introduction.html#//apple_ref/occ/cl/NSURLSession)
+- [NSURLCache Class Reference](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLCache_Class/Reference/Reference.html#//apple_ref/occ/cl/NSURLCache)
+- [NSURLAuthenticationChallenge Class Reference](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLAuthenticationChallenge_Class/Reference/Reference.html)
+
+### Manager
+
+Top-level convenience methods like `Alamofire.request` use a shared instance of `Alamofire.Manager`, which is configured with the default `NSURLSessionConfiguration`.
+
+As such, the following two statements are equivalent:
+
+```swift
+Alamofire.request(.GET, "https://httpbin.org/get")
+```
+
+```swift
+let manager = Alamofire.Manager.sharedInstance
+manager.request(NSURLRequest(URL: NSURL(string: "https://httpbin.org/get")!))
+```
+
+Applications can create managers for background and ephemeral sessions, as well as new managers that customize the default session configuration, such as for default headers (`HTTPAdditionalHeaders`) or timeout interval (`timeoutIntervalForRequest`).
+
+#### Creating a Manager with Default Configuration
+
+```swift
+let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
+let manager = Alamofire.Manager(configuration: configuration)
+```
+
+#### Creating a Manager with Background Configuration
+
+```swift
+let configuration = NSURLSessionConfiguration.backgroundSessionConfigurationWithIdentifier("com.example.app.background")
+let manager = Alamofire.Manager(configuration: configuration)
+```
+
+#### Creating a Manager with Ephemeral Configuration
+
+```swift
+let configuration = NSURLSessionConfiguration.ephemeralSessionConfiguration()
+let manager = Alamofire.Manager(configuration: configuration)
+```
+
+#### Modifying Session Configuration
+
+```swift
+var defaultHeaders = Alamofire.Manager.sharedInstance.session.configuration.HTTPAdditionalHeaders ?? [:]
+defaultHeaders["DNT"] = "1 (Do Not Track Enabled)"
+
+let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
+configuration.HTTPAdditionalHeaders = defaultHeaders
+
+let manager = Alamofire.Manager(configuration: configuration)
+```
+
+> This is **not** recommended for `Authorization` or `Content-Type` headers. Instead, use `URLRequestConvertible` and `ParameterEncoding`, respectively.
+
+### Request
+
+The result of a `request`, `upload`, or `download` method is an instance of `Alamofire.Request`. A request is always created using a constructor method from an owning manager, and never initialized directly.
+
+Methods like `authenticate`, `validate` and `responseData` return the caller in order to facilitate chaining.
+
+Requests can be suspended, resumed, and cancelled:
+
+- `suspend()`: Suspends the underlying task and dispatch queue
+- `resume()`: Resumes the underlying task and dispatch queue. If the owning manager does not have `startRequestsImmediately` set to `true`, the request must call `resume()` in order to start.
+- `cancel()`: Cancels the underlying task, producing an error that is passed to any registered response handlers.
+
+### Response Serialization
+
+#### Handling Errors
+
+Before implementing custom response serializers or object serialization methods, it's important to be prepared to handle any errors that may occur. Alamofire recommends handling these through the use of either your own `NSError` creation methods, or a simple `enum` that conforms to `ErrorType`. For example, this `BackendError` type, which will be used in later examples:
+
+```swift
+enum BackendError: ErrorType {
+    case Network(error: NSError)
+    case DataSerialization(reason: String)
+    case JSONSerialization(error: NSError)
+    case ObjectSerialization(reason: String)
+    case XMLSerialization(error: NSError)
+}
+```
+
+#### Creating a Custom Response Serializer
+
+Alamofire provides built-in response serialization for strings, JSON, and property lists, but others can be added in extensions on `Alamofire.Request`.
+
+For example, here's how a response handler using [Ono](https://github.com/mattt/Ono) might be implemented:
+
+```swift
+extension Request {
+    public static func XMLResponseSerializer() -> ResponseSerializer<ONOXMLDocument, BackendError> {
+        return ResponseSerializer { request, response, data, error in
+            guard error == nil else { return .Failure(.Network(error: error!)) }
+
+            guard let validData = data else {
+                return .Failure(.DataSerialization(reason: "Data could not be serialized. Input data was nil."))
+            }
+
+            do {
+                let XML = try ONOXMLDocument(data: validData)
+                return .Success(XML)
+            } catch {
+                return .Failure(.XMLSerialization(error: error as NSError))
+            }
+        }
+    }
+
+    public func responseXMLDocument(completionHandler: Response<ONOXMLDocument, BackendError> -> Void) -> Self {
+        return response(responseSerializer: Request.XMLResponseSerializer(), completionHandler: completionHandler)
+    }
+}
+```
+
+#### Generic Response Object Serialization
+
+Generics can be used to provide automatic, type-safe response object serialization.
+
+```swift
+public protocol ResponseObjectSerializable {
+    init?(response: NSHTTPURLResponse, representation: AnyObject)
+}
+
+extension Request {
+    public func responseObject<T: ResponseObjectSerializable>(completionHandler: Response<T, BackendError> -> Void) -> Self {
+        let responseSerializer = ResponseSerializer<T, BackendError> { request, response, data, error in
+            guard error == nil else { return .Failure(.Network(error: error!)) }
+
+            let JSONResponseSerializer = Request.JSONResponseSerializer(options: .AllowFragments)
+            let result = JSONResponseSerializer.serializeResponse(request, response, data, error)
+
+            switch result {
+            case .Success(let value):
+                if let
+                    response = response,
+                    responseObject = T(response: response, representation: value)
+                {
+                    return .Success(responseObject)
+                } else {
+                    return .Failure(.ObjectSerialization(reason: "JSON could not be serialized into response object: \(value)"))
+                }
+            case .Failure(let error):
+                return .Failure(.JSONSerialization(error: error))
+            }
+        }
+
+        return response(responseSerializer: responseSerializer, completionHandler: completionHandler)
+    }
+}
+```
+
+```swift
+final class User: ResponseObjectSerializable {
+    let username: String
+    let name: String
+
+    init?(response: NSHTTPURLResponse, representation: AnyObject) {
+        self.username = response.URL!.lastPathComponent!
+        self.name = representation.valueForKeyPath("name") as! String
+    }
+}
+```
+
+```swift
+Alamofire.request(.GET, "https://example.com/users/mattt")
+         .responseObject { (response: Response<User, BackendError>) in
+             debugPrint(response)
+         }
+```
+
+The same approach can also be used to handle endpoints that return a representation of a collection of objects:
+
+```swift
+public protocol ResponseCollectionSerializable {
+    static func collection(response response: NSHTTPURLResponse, representation: AnyObject) -> [Self]
+}
+
+extension ResponseCollectionSerializable where Self: ResponseObjectSerializable {
+    static func collection(response response: NSHTTPURLResponse, representation: AnyObject) -> [Self] {
+        var collection = [Self]()
+        
+        if let representation = representation as? [[String: AnyObject]] {
+            for itemRepresentation in representation {
+                if let item = Self(response: response, representation: itemRepresentation) {
+                    collection.append(item)
+                }
+            }
+        }
+        
+        return collection
+    }
+}
+
+extension Alamofire.Request {
+    public func responseCollection<T: ResponseCollectionSerializable>(completionHandler: Response<[T], BackendError> -> Void) -> Self {
+        let responseSerializer = ResponseSerializer<[T], BackendError> { request, response, data, error in
+            guard error == nil else { return .Failure(.Network(error: error!)) }
+
+            let JSONSerializer = Request.JSONResponseSerializer(options: .AllowFragments)
+            let result = JSONSerializer.serializeResponse(request, response, data, error)
+
+            switch result {
+            case .Success(let value):
+                if let response = response {
+                    return .Success(T.collection(response: response, representation: value))
+                } else {
+                    return .Failure(. ObjectSerialization(reason: "Response collection could not be serialized due to nil response"))
+                }
+            case .Failure(let error):
+                return .Failure(.JSONSerialization(error: error))
+            }
+        }
+
+        return response(responseSerializer: responseSerializer, completionHandler: completionHandler)
+    }
+}
+```
+
+```swift
+final class User: ResponseObjectSerializable, ResponseCollectionSerializable {
+    let username: String
+    let name: String
+
+    init?(response: NSHTTPURLResponse, representation: AnyObject) {
+        self.username = response.URL!.lastPathComponent!
+        self.name = representation.valueForKeyPath("name") as! String
+    }
+}
+```
+
+```swift
+Alamofire.request(.GET, "http://example.com/users")
+         .responseCollection { (response: Response<[User], BackendError>) in
+             debugPrint(response)
+         }
+```
+
+### URLStringConvertible
+
+Types adopting the `URLStringConvertible` protocol can be used to construct URL strings, which are then used to construct URL requests. `NSString`, `NSURL`, `NSURLComponents`, and `NSURLRequest` conform to `URLStringConvertible` by default, allowing any of them to be passed as `URLString` parameters to the `request`, `upload`, and `download` methods:
+
+```swift
+let string = NSString(string: "https://httpbin.org/post")
+Alamofire.request(.POST, string)
+
+let URL = NSURL(string: string)!
+Alamofire.request(.POST, URL)
+
+let URLRequest = NSURLRequest(URL: URL)
+Alamofire.request(.POST, URLRequest) // overrides `HTTPMethod` of `URLRequest`
+
+let URLComponents = NSURLComponents(URL: URL, resolvingAgainstBaseURL: true)
+Alamofire.request(.POST, URLComponents)
+```
+
+Applications interacting with web applications in a significant manner are encouraged to have custom types conform to `URLStringConvertible` as a convenient way to map domain-specific models to server resources.
+
+#### Type-Safe Routing
+
+```swift
+extension User: URLStringConvertible {
+    static let baseURLString = "http://example.com"
+
+    var URLString: String {
+        return User.baseURLString + "/users/\(username)/"
+    }
+}
+```
+
+```swift
+let user = User(username: "mattt")
+Alamofire.request(.GET, user) // http://example.com/users/mattt
+```
+
+### URLRequestConvertible
+
+Types adopting the `URLRequestConvertible` protocol can be used to construct URL requests. `NSURLRequest` conforms to `URLRequestConvertible` by default, allowing it to be passed into `request`, `upload`, and `download` methods directly (this is the recommended way to specify custom HTTP body for individual requests):
+
+```swift
+let URL = NSURL(string: "https://httpbin.org/post")!
+let mutableURLRequest = NSMutableURLRequest(URL: URL)
+mutableURLRequest.HTTPMethod = "POST"
+
+let parameters = ["foo": "bar"]
+
+do {
+    mutableURLRequest.HTTPBody = try NSJSONSerialization.dataWithJSONObject(parameters, options: NSJSONWritingOptions())
+} catch {
+    // No-op
+}
+
+mutableURLRequest.setValue("application/json", forHTTPHeaderField: "Content-Type")
+
+Alamofire.request(mutableURLRequest)
+```
+
+Applications interacting with web applications in a significant manner are encouraged to have custom types conform to `URLRequestConvertible` as a way to ensure consistency of requested endpoints. Such an approach can be used to abstract away server-side inconsistencies and provide type-safe routing, as well as manage authentication credentials and other state.
+
+#### API Parameter Abstraction
+
+```swift
+enum Router: URLRequestConvertible {
+    static let baseURLString = "http://example.com"
+    static let perPage = 50
+
+    case Search(query: String, page: Int)
+
+    // MARK: URLRequestConvertible
+
+    var URLRequest: NSMutableURLRequest {
+        let result: (path: String, parameters: [String: AnyObject]) = {
+            switch self {
+            case .Search(let query, let page) where page > 0:
+                return ("/search", ["q": query, "offset": Router.perPage * page])
+            case .Search(let query, _):
+                return ("/search", ["q": query])
+            }
+        }()
+
+        let URL = NSURL(string: Router.baseURLString)!
+        let URLRequest = NSURLRequest(URL: URL.URLByAppendingPathComponent(result.path))
+        let encoding = Alamofire.ParameterEncoding.URL
+
+        return encoding.encode(URLRequest, parameters: result.parameters).0
+    }
+}
+```
+
+```swift
+Alamofire.request(Router.Search(query: "foo bar", page: 1)) // ?q=foo%20bar&offset=50
+```
+
+#### CRUD & Authorization
+
+```swift
+enum Router: URLRequestConvertible {
+    static let baseURLString = "http://example.com"
+    static var OAuthToken: String?
+
+    case CreateUser([String: AnyObject])
+    case ReadUser(String)
+    case UpdateUser(String, [String: AnyObject])
+    case DestroyUser(String)
+
+    var method: Alamofire.Method {
+        switch self {
+        case .CreateUser:
+            return .POST
+        case .ReadUser:
+            return .GET
+        case .UpdateUser:
+            return .PUT
+        case .DestroyUser:
+            return .DELETE
+        }
+    }
+
+    var path: String {
+        switch self {
+        case .CreateUser:
+            return "/users"
+        case .ReadUser(let username):
+            return "/users/\(username)"
+        case .UpdateUser(let username, _):
+            return "/users/\(username)"
+        case .DestroyUser(let username):
+            return "/users/\(username)"
+        }
+    }
+
+    // MARK: URLRequestConvertible
+
+    var URLRequest: NSMutableURLRequest {
+        let URL = NSURL(string: Router.baseURLString)!
+        let mutableURLRequest = NSMutableURLRequest(URL: URL.URLByAppendingPathComponent(path))
+        mutableURLRequest.HTTPMethod = method.rawValue
+
+        if let token = Router.OAuthToken {
+            mutableURLRequest.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
+        }
+
+        switch self {
+        case .CreateUser(let parameters):
+            return Alamofire.ParameterEncoding.JSON.encode(mutableURLRequest, parameters: parameters).0
+        case .UpdateUser(_, let parameters):
+            return Alamofire.ParameterEncoding.URL.encode(mutableURLRequest, parameters: parameters).0
+        default:
+            return mutableURLRequest
+        }
+    }
+}
+```
+
+```swift
+Alamofire.request(Router.ReadUser("mattt")) // GET /users/mattt
+```
+
+### SessionDelegate
+
+By default, an Alamofire `Manager` instance creates an internal `SessionDelegate` object to handle all the various types of delegate callbacks that are generated by the underlying `NSURLSession`. The implementations of each delegate method handle the most common use cases for these types of calls abstracting the complexity away from the top-level APIs. However, advanced users may find the need to override the default functionality for various reasons.
+
+#### Override Closures
+
+The first way to customize the `SessionDelegate` behavior is through the use of the override closures. Each closure gives you the ability to override the implementation of the matching `SessionDelegate` API, yet still use the default implementation for all other APIs. This makes it easy to customize subsets of the delegate functionality. Here are a few examples of some of the override closures available:
+
+```swift
+/// Overrides default behavior for NSURLSessionDelegate method `URLSession:didReceiveChallenge:completionHandler:`.
+public var sessionDidReceiveChallenge: ((NSURLSession, NSURLAuthenticationChallenge) -> (NSURLSessionAuthChallengeDisposition, NSURLCredential?))?
+
+/// Overrides default behavior for NSURLSessionDelegate method `URLSessionDidFinishEventsForBackgroundURLSession:`.
+public var sessionDidFinishEventsForBackgroundURLSession: ((NSURLSession) -> Void)?
+
+/// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:`.
+public var taskWillPerformHTTPRedirection: ((NSURLSession, NSURLSessionTask, NSHTTPURLResponse, NSURLRequest) -> NSURLRequest?)?
+
+/// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:willCacheResponse:completionHandler:`.
+public var dataTaskWillCacheResponse: ((NSURLSession, NSURLSessionDataTask, NSCachedURLResponse) -> NSCachedURLResponse?)?
+```
+
+The following is a short example of how to use the `taskWillPerformHTTPRedirection` to avoid following redirects to any `apple.com` domains.
+
+```swift
+let delegate: Alamofire.Manager.SessionDelegate = manager.delegate
+
+delegate.taskWillPerformHTTPRedirection = { session, task, response, request in
+    var finalRequest = request
+
+    if let originalRequest = task.originalRequest where originalRequest.URLString.containsString("apple.com") {
+		finalRequest = originalRequest
+	}
+
+	return finalRequest
+}
+```
+
+#### Subclassing
+
+Another way to override the default implementation of the `SessionDelegate` is to subclass it. Subclassing allows you completely customize the behavior of the API or to create a proxy for the API and still use the default implementation. Creating a proxy allows you to log events, emit notifications, provide pre and post hook implementations, etc. Here's a quick example of subclassing the `SessionDelegate` and logging a message when a redirect occurs.
+
+```swift
+class LoggingSessionDelegate: Manager.SessionDelegate {
+    override func URLSession(
+        session: NSURLSession,
+        task: NSURLSessionTask,
+        willPerformHTTPRedirection response: NSHTTPURLResponse,
+        newRequest request: NSURLRequest,
+        completionHandler: NSURLRequest? -> Void)
+    {
+        print("URLSession will perform HTTP redirection to request: \(request)")
+
+        super.URLSession(
+            session,
+            task: task,
+            willPerformHTTPRedirection: response,
+            newRequest: request,
+            completionHandler: completionHandler
+        )
+    }
+}
+```
+
+Generally, either the default implementation or the override closures should provide the necessary functionality required. Subclassing should only be used as a last resort.
+
+> It is important to keep in mind that the `subdelegates` are initialized and destroyed in the default implementation. Be careful when subclassing to not introduce memory leaks.
+
+### Security
+
+Using a secure HTTPS connection when communicating with servers and web services is an important step in securing sensitive data. By default, Alamofire will evaluate the certificate chain provided by the server using Apple's built in validation provided by the Security framework. While this guarantees the certificate chain is valid, it does not prevent man-in-the-middle (MITM) attacks or other potential vulnerabilities. In order to mitigate MITM attacks, applications dealing with sensitive customer data or financial information should use certificate or public key pinning provided by the `ServerTrustPolicy`.
+
+#### ServerTrustPolicy
+
+The `ServerTrustPolicy` enumeration evaluates the server trust generally provided by an `NSURLAuthenticationChallenge` when connecting to a server over a secure HTTPS connection.
+
+```swift
+let serverTrustPolicy = ServerTrustPolicy.PinCertificates(
+    certificates: ServerTrustPolicy.certificatesInBundle(),
+    validateCertificateChain: true,
+    validateHost: true
+)
+```
+
+There are many different cases of server trust evaluation giving you complete control over the validation process:
+
+* `PerformDefaultEvaluation`: Uses the default server trust evaluation while allowing you to control whether to validate the host provided by the challenge. 
+* `PinCertificates`: Uses the pinned certificates to validate the server trust. The server trust is considered valid if one of the pinned certificates match one of the server certificates.
+* `PinPublicKeys`: Uses the pinned public keys to validate the server trust. The server trust is considered valid if one of the pinned public keys match one of the server certificate public keys.
+* `DisableEvaluation`: Disables all evaluation which in turn will always consider any server trust as valid.
+* `CustomEvaluation`: Uses the associated closure to evaluate the validity of the server trust thus giving you complete control over the validation process. Use with caution.
+
+#### Server Trust Policy Manager
+
+The `ServerTrustPolicyManager` is responsible for storing an internal mapping of server trust policies to a particular host. This allows Alamofire to evaluate each host against a different server trust policy. 
+
+```swift
+let serverTrustPolicies: [String: ServerTrustPolicy] = [
+    "test.example.com": .PinCertificates(
+        certificates: ServerTrustPolicy.certificatesInBundle(),
+        validateCertificateChain: true,
+        validateHost: true
+    ),
+    "insecure.expired-apis.com": .DisableEvaluation
+]
+
+let manager = Manager(
+    serverTrustPolicyManager: ServerTrustPolicyManager(policies: serverTrustPolicies)
+)
+```
+
+> Make sure to keep a reference to the new `Manager` instance, otherwise your requests will all get cancelled when your `manager` is deallocated.
+
+These server trust policies will result in the following behavior:
+
+* `test.example.com` will always use certificate pinning with certificate chain and host validation enabled thus requiring the following criteria to be met to allow the TLS handshake to succeed:
+  * Certificate chain MUST be valid.
+  * Certificate chain MUST include one of the pinned certificates.
+  * Challenge host MUST match the host in the certificate chain's leaf certificate.
+* `insecure.expired-apis.com` will never evaluate the certificate chain and will always allow the TLS handshake to succeed.
+* All other hosts will use the default evaluation provided by Apple.
+
+##### Subclassing Server Trust Policy Manager
+
+If you find yourself needing more flexible server trust policy matching behavior (i.e. wildcarded domains), then subclass the `ServerTrustPolicyManager` and override the `serverTrustPolicyForHost` method with your own custom implementation.
+
+```swift
+class CustomServerTrustPolicyManager: ServerTrustPolicyManager {
+    override func serverTrustPolicyForHost(host: String) -> ServerTrustPolicy? {
+        var policy: ServerTrustPolicy?
+
+        // Implement your custom domain matching behavior...
+
+        return policy
+    }
+}
+```
+
+#### Validating the Host
+
+The `.PerformDefaultEvaluation`, `.PinCertificates` and `.PinPublicKeys` server trust policies all take a `validateHost` parameter. Setting the value to `true` will cause the server trust evaluation to verify that hostname in the certificate matches the hostname of the challenge. If they do not match, evaluation will fail. A `validateHost` value of `false` will still evaluate the full certificate chain, but will not validate the hostname of the leaf certificate.
+
+> It is recommended that `validateHost` always be set to `true` in production environments.
+
+#### Validating the Certificate Chain
+
+Pinning certificates and public keys both have the option of validating the certificate chain using the `validateCertificateChain` parameter. By setting this value to `true`, the full certificate chain will be evaluated in addition to performing a byte equality check against the pinned certificates or public keys. A value of `false` will skip the certificate chain validation, but will still perform the byte equality check.
+
+There are several cases where it may make sense to disable certificate chain validation. The most common use cases for disabling validation are self-signed and expired certificates. The evaluation would always fail in both of these cases, but the byte equality check will still ensure you are receiving the certificate you expect from the server.
+
+> It is recommended that `validateCertificateChain` always be set to `true` in production environments.
+
+#### App Transport Security
+
+With the addition of App Transport Security (ATS) in iOS 9, it is possible that using a custom `ServerTrustPolicyManager` with several `ServerTrustPolicy` objects will have no effect. If you continuously see `CFNetwork SSLHandshake failed (-9806)` errors, you have probably run into this problem. Apple's ATS system overrides the entire challenge system unless you configure the ATS settings in your app's plist to disable enough of it to allow your app to evaluate the server trust.
+
+If you run into this problem (high probability with self-signed certificates), you can work around this issue by adding the following to your `Info.plist`.
+
+```xml
+<dict>
+	<key>NSAppTransportSecurity</key>
+	<dict>
+		<key>NSExceptionDomains</key>
+		<dict>
+			<key>example.com</key>
+			<dict>
+				<key>NSExceptionAllowsInsecureHTTPLoads</key>
+				<true/>
+				<key>NSExceptionRequiresForwardSecrecy</key>
+				<false/>
+				<key>NSIncludesSubdomains</key>
+				<true/>
+				<!-- Optional: Specify minimum TLS version -->
+				<key>NSTemporaryExceptionMinimumTLSVersion</key>
+				<string>TLSv1.2</string>
+			</dict>
+		</dict>
+	</dict>
+</dict>
+```
+
+Whether you need to set the `NSExceptionRequiresForwardSecrecy` to `NO` depends on whether your TLS connection is using an allowed cipher suite. In certain cases, it will need to be set to `NO`. The `NSExceptionAllowsInsecureHTTPLoads` MUST be set to `YES` in order to allow the `SessionDelegate` to receive challenge callbacks. Once the challenge callbacks are being called, the `ServerTrustPolicyManager` will take over the server trust evaluation. You may also need to specify the `NSTemporaryExceptionMinimumTLSVersion` if you're trying to connect to a host that only supports TLS versions less than `1.2`.
+
+> It is recommended to always use valid certificates in production environments.
+
+### Network Reachability
+
+The `NetworkReachabilityManager` listens for reachability changes of hosts and addresses for both WWAN and WiFi network interfaces.
+
+```swift
+let manager = NetworkReachabilityManager(host: "www.apple.com")
+
+manager?.listener = { status in
+    print("Network Status Changed: \(status)")
+}
+
+manager?.startListening()
+```
+
+> Make sure to remember to retain the `manager` in the above example, or no status changes will be reported.
+
+There are some important things to remember when using network reachability to determine what to do next.
+
+* **Do NOT** use Reachability to determine if a network request should be sent.
+  * You should **ALWAYS** send it.
+* When Reachability is restored, use the event to retry failed network requests.
+  * Even though the network requests may still fail, this is a good moment to retry them.
+* The network reachability status can be useful for determining why a network request may have failed.
+  * If a network request fails, it is more useful to tell the user that the network request failed due to being offline rather than a more technical error, such as "request timed out."
+
+> It is recommended to check out [WWDC 2012 Session 706, "Networking Best Practices"](https://developer.apple.com/videos/play/wwdc2012-706/) for more info.
+
+---
+
+## Open Rdars
+
+The following rdars have some affect on the current implementation of Alamofire.
+
+* [rdar://21349340](http://www.openradar.me/radar?id=5517037090635776) - Compiler throwing warning due to toll-free bridging issue in test case
+* [rdar://26761490](http://www.openradar.me/radar?id=5010235949318144) - Swift string interpolation causing memory leak with common usage
+
+## FAQ
+
+### What's the origin of the name Alamofire?
+
+Alamofire is named after the [Alamo Fire flower](https://aggie-horticulture.tamu.edu/wildseed/alamofire.html), a hybrid variant of the Bluebonnet, the official state flower of Texas.
+
+---
+
+## Credits
+
+Alamofire is owned and maintained by the [Alamofire Software Foundation](http://alamofire.org). You can follow them on Twitter at [@AlamofireSF](https://twitter.com/AlamofireSF) for project updates and releases.
+
+### Security Disclosure
+
+If you believe you have identified a security vulnerability with Alamofire, you should report it as soon as possible via email to security@alamofire.org. Please do not post it to a public issue tracker.
+
+## Donations
+
+The [ASF](https://github.com/Alamofire/Foundation#members) is looking to raise money to officially register as a federal non-profit organization. Registering will allow us members to gain some legal protections and also allow us to put donations to use, tax free. Donating to the ASF will enable us to:
+
+* Pay our legal fees to register as a federal non-profit organization
+* Pay our yearly legal fees to keep the non-profit in good status
+* Pay for our mail servers to help us stay on top of all questions and security issues
+* Potentially fund test servers to make it easier for us to test the edge cases
+* Potentially fund developers to work on one of our projects full-time
+
+The community adoption of the ASF libraries has been amazing. We are greatly humbled by your enthusiam around the projects, and want to continue to do everything we can to move the needle forward. With your continued support, the ASF will be able to improve its reach and also provide better legal safety for the core members. If you use any of our libraries for work, see if your employers would be interested in donating. Our initial goal is to raise $1000 to get all our legal ducks in a row and kickstart this campaign. Any amount you can donate today to help us reach our goal would be greatly appreciated.
+
+<a href='https://pledgie.com/campaigns/31474'><img alt='Click here to lend your support to: Alamofire Software Foundation and make a donation at pledgie.com !' src='https://pledgie.com/campaigns/31474.png?skin_name=chrome' border='0' ></a>
+
+## License
+
+Alamofire is released under the MIT license. See LICENSE for details.
diff --git a/Pods/Alamofire/Source/Alamofire.swift b/Pods/Alamofire/Source/Alamofire.swift
new file mode 100644
index 0000000..cb4b36a
--- /dev/null
+++ b/Pods/Alamofire/Source/Alamofire.swift
@@ -0,0 +1,370 @@
+//
+//  Alamofire.swift
+//
+//  Copyright (c) 2014-2016 Alamofire Software Foundation (http://alamofire.org/)
+//
+//  Permission is hereby granted, free of charge, to any person obtaining a copy
+//  of this software and associated documentation files (the "Software"), to deal
+//  in the Software without restriction, including without limitation the rights
+//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+//  copies of the Software, and to permit persons to whom the Software is
+//  furnished to do so, subject to the following conditions:
+//
+//  The above copyright notice and this permission notice shall be included in
+//  all copies or substantial portions of the Software.
+//
+//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+//  THE SOFTWARE.
+//
+
+import Foundation
+
+// MARK: - URLStringConvertible
+
+/**
+    Types adopting the `URLStringConvertible` protocol can be used to construct URL strings, which are then used to 
+    construct URL requests.
+*/
+public protocol URLStringConvertible {
+    /**
+        A URL that conforms to RFC 2396.
+
+        Methods accepting a `URLStringConvertible` type parameter parse it according to RFCs 1738 and 1808.
+
+        See https://tools.ietf.org/html/rfc2396
+        See https://tools.ietf.org/html/rfc1738
+        See https://tools.ietf.org/html/rfc1808
+    */
+    var URLString: String { get }
+}
+
+extension String: URLStringConvertible {
+    public var URLString: String {
+        return self
+    }
+}
+
+extension NSURL: URLStringConvertible {
+    public var URLString: String {
+        return absoluteString
+    }
+}
+
+extension NSURLComponents: URLStringConvertible {
+    public var URLString: String {
+        return URL!.URLString
+    }
+}
+
+extension NSURLRequest: URLStringConvertible {
+    public var URLString: String {
+        return URL!.URLString
+    }
+}
+
+// MARK: - URLRequestConvertible
+
+/**
+    Types adopting the `URLRequestConvertible` protocol can be used to construct URL requests.
+*/
+public protocol URLRequestConvertible {
+    /// The URL request.
+    var URLRequest: NSMutableURLRequest { get }
+}
+
+extension NSURLRequest: URLRequestConvertible {
+    public var URLRequest: NSMutableURLRequest {
+        return self.mutableCopy() as! NSMutableURLRequest
+    }
+}
+
+// MARK: - Convenience
+
+func URLRequest(
+    method: Method,
+    _ URLString: URLStringConvertible,
+    headers: [String: String]? = nil)
+    -> NSMutableURLRequest
+{
+    let mutableURLRequest = NSMutableURLRequest(URL: NSURL(string: URLString.URLString)!)
+    mutableURLRequest.HTTPMethod = method.rawValue
+
+    if let headers = headers {
+        for (headerField, headerValue) in headers {
+            mutableURLRequest.setValue(headerValue, forHTTPHeaderField: headerField)
+        }
+    }
+
+    return mutableURLRequest
+}
+
+// MARK: - Request Methods
+
+/**
+    Creates a request using the shared manager instance for the specified method, URL string, parameters, and
+    parameter encoding.
+
+    - parameter method:     The HTTP method.
+    - parameter URLString:  The URL string.
+    - parameter parameters: The parameters. `nil` by default.
+    - parameter encoding:   The parameter encoding. `.URL` by default.
+    - parameter headers:    The HTTP headers. `nil` by default.
+
+    - returns: The created request.
+*/
+public func request(
+    method: Method,
+    _ URLString: URLStringConvertible,
+    parameters: [String: AnyObject]? = nil,
+    encoding: ParameterEncoding = .URL,
+    headers: [String: String]? = nil)
+    -> Request
+{
+    return Manager.sharedInstance.request(
+        method,
+        URLString,
+        parameters: parameters,
+        encoding: encoding,
+        headers: headers
+    )
+}
+
+/**
+    Creates a request using the shared manager instance for the specified URL request.
+
+    If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
+
+    - parameter URLRequest: The URL request
+
+    - returns: The created request.
+*/
+public func request(URLRequest: URLRequestConvertible) -> Request {
+    return Manager.sharedInstance.request(URLRequest.URLRequest)
+}
+
+// MARK: - Upload Methods
+
+// MARK: File
+
+/**
+    Creates an upload request using the shared manager instance for the specified method, URL string, and file.
+
+    - parameter method:    The HTTP method.
+    - parameter URLString: The URL string.
+    - parameter headers:   The HTTP headers. `nil` by default.
+    - parameter file:      The file to upload.
+
+    - returns: The created upload request.
+*/
+public func upload(
+    method: Method,
+    _ URLString: URLStringConvertible,
+    headers: [String: String]? = nil,
+    file: NSURL)
+    -> Request
+{
+    return Manager.sharedInstance.upload(method, URLString, headers: headers, file: file)
+}
+
+/**
+    Creates an upload request using the shared manager instance for the specified URL request and file.
+
+    - parameter URLRequest: The URL request.
+    - parameter file:       The file to upload.
+
+    - returns: The created upload request.
+*/
+public func upload(URLRequest: URLRequestConvertible, file: NSURL) -> Request {
+    return Manager.sharedInstance.upload(URLRequest, file: file)
+}
+
+// MARK: Data
+
+/**
+    Creates an upload request using the shared manager instance for the specified method, URL string, and data.
+
+    - parameter method:    The HTTP method.
+    - parameter URLString: The URL string.
+    - parameter headers:   The HTTP headers. `nil` by default.
+    - parameter data:      The data to upload.
+
+    - returns: The created upload request.
+*/
+public func upload(
+    method: Method,
+    _ URLString: URLStringConvertible,
+    headers: [String: String]? = nil,
+    data: NSData)
+    -> Request
+{
+    return Manager.sharedInstance.upload(method, URLString, headers: headers, data: data)
+}
+
+/**
+    Creates an upload request using the shared manager instance for the specified URL request and data.
+
+    - parameter URLRequest: The URL request.
+    - parameter data:       The data to upload.
+
+    - returns: The created upload request.
+*/
+public func upload(URLRequest: URLRequestConvertible, data: NSData) -> Request {
+    return Manager.sharedInstance.upload(URLRequest, data: data)
+}
+
+// MARK: Stream
+
+/**
+    Creates an upload request using the shared manager instance for the specified method, URL string, and stream.
+
+    - parameter method:    The HTTP method.
+    - parameter URLString: The URL string.
+    - parameter headers:   The HTTP headers. `nil` by default.
+    - parameter stream:    The stream to upload.
+
+    - returns: The created upload request.
+*/
+public func upload(
+    method: Method,
+    _ URLString: URLStringConvertible,
+    headers: [String: String]? = nil,
+    stream: NSInputStream)
+    -> Request
+{
+    return Manager.sharedInstance.upload(method, URLString, headers: headers, stream: stream)
+}
+
+/**
+    Creates an upload request using the shared manager instance for the specified URL request and stream.
+
+    - parameter URLRequest: The URL request.
+    - parameter stream:     The stream to upload.
+
+    - returns: The created upload request.
+*/
+public func upload(URLRequest: URLRequestConvertible, stream: NSInputStream) -> Request {
+    return Manager.sharedInstance.upload(URLRequest, stream: stream)
+}
+
+// MARK: MultipartFormData
+
+/**
+    Creates an upload request using the shared manager instance for the specified method and URL string.
+
+    - parameter method:                  The HTTP method.
+    - parameter URLString:               The URL string.
+    - parameter headers:                 The HTTP headers. `nil` by default.
+    - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
+    - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
+                                         `MultipartFormDataEncodingMemoryThreshold` by default.
+    - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
+*/
+public func upload(
+    method: Method,
+    _ URLString: URLStringConvertible,
+    headers: [String: String]? = nil,
+    multipartFormData: MultipartFormData -> Void,
+    encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
+    encodingCompletion: (Manager.MultipartFormDataEncodingResult -> Void)?)
+{
+    return Manager.sharedInstance.upload(
+        method,
+        URLString,
+        headers: headers,
+        multipartFormData: multipartFormData,
+        encodingMemoryThreshold: encodingMemoryThreshold,
+        encodingCompletion: encodingCompletion
+    )
+}
+
+/**
+    Creates an upload request using the shared manager instance for the specified method and URL string.
+
+    - parameter URLRequest:              The URL request.
+    - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
+    - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
+                                         `MultipartFormDataEncodingMemoryThreshold` by default.
+    - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
+*/
+public func upload(
+    URLRequest: URLRequestConvertible,
+    multipartFormData: MultipartFormData -> Void,
+    encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
+    encodingCompletion: (Manager.MultipartFormDataEncodingResult -> Void)?)
+{
+    return Manager.sharedInstance.upload(
+        URLRequest,
+        multipartFormData: multipartFormData,
+        encodingMemoryThreshold: encodingMemoryThreshold,
+        encodingCompletion: encodingCompletion
+    )
+}
+
+// MARK: - Download Methods
+
+// MARK: URL Request
+
+/**
+    Creates a download request using the shared manager instance for the specified method and URL string.
+
+    - parameter method:      The HTTP method.
+    - parameter URLString:   The URL string.
+    - parameter parameters:  The parameters. `nil` by default.
+    - parameter encoding:    The parameter encoding. `.URL` by default.
+    - parameter headers:     The HTTP headers. `nil` by default.
+    - parameter destination: The closure used to determine the destination of the downloaded file.
+
+    - returns: The created download request.
+*/
+public func download(
+    method: Method,
+    _ URLString: URLStringConvertible,
+    parameters: [String: AnyObject]? = nil,
+    encoding: ParameterEncoding = .URL,
+    headers: [String: String]? = nil,
+    destination: Request.DownloadFileDestination)
+    -> Request
+{
+    return Manager.sharedInstance.download(
+        method,
+        URLString,
+        parameters: parameters,
+        encoding: encoding,
+        headers: headers,
+        destination: destination
+    )
+}
+
+/**
+    Creates a download request using the shared manager instance for the specified URL request.
+
+    - parameter URLRequest:  The URL request.
+    - parameter destination: The closure used to determine the destination of the downloaded file.
+
+    - returns: The created download request.
+*/
+public func download(URLRequest: URLRequestConvertible, destination: Request.DownloadFileDestination) -> Request {
+    return Manager.sharedInstance.download(URLRequest, destination: destination)
+}
+
+// MARK: Resume Data
+
+/**
+    Creates a request using the shared manager instance for downloading from the resume data produced from a 
+    previous request cancellation.
+
+    - parameter resumeData:  The resume data. This is an opaque data blob produced by `NSURLSessionDownloadTask`
+                             when a task is cancelled. See `NSURLSession -downloadTaskWithResumeData:` for additional 
+                             information.
+    - parameter destination: The closure used to determine the destination of the downloaded file.
+
+    - returns: The created download request.
+*/
+public func download(resumeData data: NSData, destination: Request.DownloadFileDestination) -> Request {
+    return Manager.sharedInstance.download(data, destination: destination)
+}
diff --git a/Pods/Alamofire/Source/Download.swift b/Pods/Alamofire/Source/Download.swift
new file mode 100644
index 0000000..97b146f
--- /dev/null
+++ b/Pods/Alamofire/Source/Download.swift
@@ -0,0 +1,248 @@
+//
+//  Download.swift
+//
+//  Copyright (c) 2014-2016 Alamofire Software Foundation (http://alamofire.org/)
+//
+//  Permission is hereby granted, free of charge, to any person obtaining a copy
+//  of this software and associated documentation files (the "Software"), to deal
+//  in the Software without restriction, including without limitation the rights
+//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+//  copies of the Software, and to permit persons to whom the Software is
+//  furnished to do so, subject to the following conditions:
+//
+//  The above copyright notice and this permission notice shall be included in
+//  all copies or substantial portions of the Software.
+//
+//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+//  THE SOFTWARE.
+//
+
+import Foundation
+
+extension Manager {
+    private enum Downloadable {
+        case Request(NSURLRequest)
+        case ResumeData(NSData)
+    }
+
+    private func download(downloadable: Downloadable, destination: Request.DownloadFileDestination) -> Request {
+        var downloadTask: NSURLSessionDownloadTask!
+
+        switch downloadable {
+        case .Request(let request):
+            dispatch_sync(queue) {
+                downloadTask = self.session.downloadTaskWithRequest(request)
+            }
+        case .ResumeData(let resumeData):
+            dispatch_sync(queue) {
+                downloadTask = self.session.downloadTaskWithResumeData(resumeData)
+            }
+        }
+
+        let request = Request(session: session, task: downloadTask)
+
+        if let downloadDelegate = request.delegate as? Request.DownloadTaskDelegate {
+            downloadDelegate.downloadTaskDidFinishDownloadingToURL = { session, downloadTask, URL in
+                return destination(URL, downloadTask.response as! NSHTTPURLResponse)
+            }
+        }
+
+        delegate[request.delegate.task] = request.delegate
+
+        if startRequestsImmediately {
+            request.resume()
+        }
+
+        return request
+    }
+
+    // MARK: Request
+
+    /**
+        Creates a download request for the specified method, URL string, parameters, parameter encoding, headers
+        and destination.
+
+        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
+
+        - parameter method:      The HTTP method.
+        - parameter URLString:   The URL string.
+        - parameter parameters:  The parameters. `nil` by default.
+        - parameter encoding:    The parameter encoding. `.URL` by default.
+        - parameter headers:     The HTTP headers. `nil` by default.
+        - parameter destination: The closure used to determine the destination of the downloaded file.
+
+        - returns: The created download request.
+    */
+    public func download(
+        method: Method,
+        _ URLString: URLStringConvertible,
+        parameters: [String: AnyObject]? = nil,
+        encoding: ParameterEncoding = .URL,
+        headers: [String: String]? = nil,
+        destination: Request.DownloadFileDestination)
+        -> Request
+    {
+        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
+        let encodedURLRequest = encoding.encode(mutableURLRequest, parameters: parameters).0
+
+        return download(encodedURLRequest, destination: destination)
+    }
+
+    /**
+        Creates a request for downloading from the specified URL request.
+
+        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
+
+        - parameter URLRequest:  The URL request
+        - parameter destination: The closure used to determine the destination of the downloaded file.
+
+        - returns: The created download request.
+    */
+    public func download(URLRequest: URLRequestConvertible, destination: Request.DownloadFileDestination) -> Request {
+        return download(.Request(URLRequest.URLRequest), destination: destination)
+    }
+
+    // MARK: Resume Data
+
+    /**
+        Creates a request for downloading from the resume data produced from a previous request cancellation.
+
+        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
+
+        - parameter resumeData:  The resume data. This is an opaque data blob produced by `NSURLSessionDownloadTask` 
+                                 when a task is cancelled. See `NSURLSession -downloadTaskWithResumeData:` for 
+                                 additional information.
+        - parameter destination: The closure used to determine the destination of the downloaded file.
+
+        - returns: The created download request.
+    */
+    public func download(resumeData: NSData, destination: Request.DownloadFileDestination) -> Request {
+        return download(.ResumeData(resumeData), destination: destination)
+    }
+}
+
+// MARK: -
+
+extension Request {
+    /**
+        A closure executed once a request has successfully completed in order to determine where to move the temporary 
+        file written to during the download process. The closure takes two arguments: the temporary file URL and the URL 
+        response, and returns a single argument: the file URL where the temporary file should be moved.
+    */
+    public typealias DownloadFileDestination = (NSURL, NSHTTPURLResponse) -> NSURL
+
+    /**
+        Creates a download file destination closure which uses the default file manager to move the temporary file to a 
+        file URL in the first available directory with the specified search path directory and search path domain mask.
+
+        - parameter directory: The search path directory. `.DocumentDirectory` by default.
+        - parameter domain:    The search path domain mask. `.UserDomainMask` by default.
+
+        - returns: A download file destination closure.
+    */
+    public class func suggestedDownloadDestination(
+        directory directory: NSSearchPathDirectory = .DocumentDirectory,
+        domain: NSSearchPathDomainMask = .UserDomainMask)
+        -> DownloadFileDestination
+    {
+        return { temporaryURL, response -> NSURL in
+            let directoryURLs = NSFileManager.defaultManager().URLsForDirectory(directory, inDomains: domain)
+
+            if !directoryURLs.isEmpty {
+                return directoryURLs[0].URLByAppendingPathComponent(response.suggestedFilename!)
+            }
+
+            return temporaryURL
+        }
+    }
+
+    /// The resume data of the underlying download task if available after a failure.
+    public var resumeData: NSData? {
+        var data: NSData?
+
+        if let delegate = delegate as? DownloadTaskDelegate {
+            data = delegate.resumeData
+        }
+
+        return data
+    }
+
+    // MARK: - DownloadTaskDelegate
+
+    class DownloadTaskDelegate: TaskDelegate, NSURLSessionDownloadDelegate {
+        var downloadTask: NSURLSessionDownloadTask? { return task as? NSURLSessionDownloadTask }
+        var downloadProgress: ((Int64, Int64, Int64) -> Void)?
+
+        var resumeData: NSData?
+        override var data: NSData? { return resumeData }
+
+        // MARK: - NSURLSessionDownloadDelegate
+
+        // MARK: Override Closures
+
+        var downloadTaskDidFinishDownloadingToURL: ((NSURLSession, NSURLSessionDownloadTask, NSURL) -> NSURL)?
+        var downloadTaskDidWriteData: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64, Int64) -> Void)?
+        var downloadTaskDidResumeAtOffset: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64) -> Void)?
+
+        // MARK: Delegate Methods
+
+        func URLSession(
+            session: NSURLSession,
+            downloadTask: NSURLSessionDownloadTask,
+            didFinishDownloadingToURL location: NSURL)
+        {
+            if let downloadTaskDidFinishDownloadingToURL = downloadTaskDidFinishDownloadingToURL {
+                do {
+                    let destination = downloadTaskDidFinishDownloadingToURL(session, downloadTask, location)
+                    try NSFileManager.defaultManager().moveItemAtURL(location, toURL: destination)
+                } catch {
+                    self.error = error as NSError
+                }
+            }
+        }
+
+        func URLSession(
+            session: NSURLSession,
+            downloadTask: NSURLSessionDownloadTask,
+            didWriteData bytesWritten: Int64,
+            totalBytesWritten: Int64,
+            totalBytesExpectedToWrite: Int64)
+        {
+            if initialResponseTime == nil { initialResponseTime = CFAbsoluteTimeGetCurrent() }
+
+            if let downloadTaskDidWriteData = downloadTaskDidWriteData {
+                downloadTaskDidWriteData(
+                    session,
+                    downloadTask,
+                    bytesWritten,
+                    totalBytesWritten, 
+                    totalBytesExpectedToWrite
+                )
+            } else {
+                progress.totalUnitCount = totalBytesExpectedToWrite
+                progress.completedUnitCount = totalBytesWritten
+
+                downloadProgress?(bytesWritten, totalBytesWritten, totalBytesExpectedToWrite)
+            }
+        }
+
+        func URLSession(
+            session: NSURLSession,
+            downloadTask: NSURLSessionDownloadTask,
+            didResumeAtOffset fileOffset: Int64,
+            expectedTotalBytes: Int64)
+        {
+            if let downloadTaskDidResumeAtOffset = downloadTaskDidResumeAtOffset {
+                downloadTaskDidResumeAtOffset(session, downloadTask, fileOffset, expectedTotalBytes)
+            } else {
+                progress.totalUnitCount = expectedTotalBytes
+                progress.completedUnitCount = fileOffset
+            }
+        }
+    }
+}
diff --git a/Pods/Alamofire/Source/Error.swift b/Pods/Alamofire/Source/Error.swift
new file mode 100644
index 0000000..467d99c
--- /dev/null
+++ b/Pods/Alamofire/Source/Error.swift
@@ -0,0 +1,88 @@
+//
+//  Error.swift
+//
+//  Copyright (c) 2014-2016 Alamofire Software Foundation (http://alamofire.org/)
+//
+//  Permission is hereby granted, free of charge, to any person obtaining a copy
+//  of this software and associated documentation files (the "Software"), to deal
+//  in the Software without restriction, including without limitation the rights
+//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+//  copies of the Software, and to permit persons to whom the Software is
+//  furnished to do so, subject to the following conditions:
+//
+//  The above copyright notice and this permission notice shall be included in
+//  all copies or substantial portions of the Software.
+//
+//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+//  THE SOFTWARE.
+//
+
+import Foundation
+
+/// The `Error` struct provides a convenience for creating custom Alamofire NSErrors.
+public struct Error {
+    /// The domain used for creating all Alamofire errors.
+    public static let Domain = "com.alamofire.error"
+
+    /// The custom error codes generated by Alamofire.
+    public enum Code: Int {
+        case InputStreamReadFailed           = -6000
+        case OutputStreamWriteFailed         = -6001
+        case ContentTypeValidationFailed     = -6002
+        case StatusCodeValidationFailed      = -6003
+        case DataSerializationFailed         = -6004
+        case StringSerializationFailed       = -6005
+        case JSONSerializationFailed         = -6006
+        case PropertyListSerializationFailed = -6007
+    }
+
+    /// Custom keys contained within certain NSError `userInfo` dictionaries generated by Alamofire.
+    public struct UserInfoKeys {
+        /// The content type user info key for a `.ContentTypeValidationFailed` error stored as a `String` value.
+        public static let ContentType = "ContentType"
+
+        /// The status code user info key for a `.StatusCodeValidationFailed` error stored as an `Int` value.
+        public static let StatusCode = "StatusCode"
+    }
+
+    /**
+        Creates an `NSError` with the given error code and failure reason.
+
+        - parameter code:          The error code.
+        - parameter failureReason: The failure reason.
+
+        - returns: An `NSError` with the given error code and failure reason.
+    */
+    @available(*, deprecated=3.4.0)
+    public static func errorWithCode(code: Code, failureReason: String) -> NSError {
+        return errorWithCode(code.rawValue, failureReason: failureReason)
+    }
+
+    /**
+        Creates an `NSError` with the given error code and failure reason.
+
+        - parameter code:          The error code.
+        - parameter failureReason: The failure reason.
+
+        - returns: An `NSError` with the given error code and failure reason.
+    */
+    @available(*, deprecated=3.4.0)
+    public static func errorWithCode(code: Int, failureReason: String) -> NSError {
+        let userInfo = [NSLocalizedFailureReasonErrorKey: failureReason]
+        return NSError(domain: Domain, code: code, userInfo: userInfo)
+    }
+
+    static func error(domain domain: String = Error.Domain, code: Code, failureReason: String) -> NSError {
+        return error(domain: domain, code: code.rawValue, failureReason: failureReason)
+    }
+
+    static func error(domain domain: String = Error.Domain, code: Int, failureReason: String) -> NSError {
+        let userInfo = [NSLocalizedFailureReasonErrorKey: failureReason]
+        return NSError(domain: domain, code: code, userInfo: userInfo)
+    }
+}
diff --git a/Pods/Alamofire/Source/Manager.swift b/Pods/Alamofire/Source/Manager.swift
new file mode 100644
index 0000000..691d31f
--- /dev/null
+++ b/Pods/Alamofire/Source/Manager.swift
@@ -0,0 +1,778 @@
+//
+//  Manager.swift
+//
+//  Copyright (c) 2014-2016 Alamofire Software Foundation (http://alamofire.org/)
+//
+//  Permission is hereby granted, free of charge, to any person obtaining a copy
+//  of this software and associated documentation files (the "Software"), to deal
+//  in the Software without restriction, including without limitation the rights
+//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+//  copies of the Software, and to permit persons to whom the Software is
+//  furnished to do so, subject to the following conditions:
+//
+//  The above copyright notice and this permission notice shall be included in
+//  all copies or substantial portions of the Software.
+//
+//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+//  THE SOFTWARE.
+//
+
+import Foundation
+
+/**
+    Responsible for creating and managing `Request` objects, as well as their underlying `NSURLSession`.
+*/
+public class Manager {
+
+    // MARK: - Properties
+
+    /**
+        A shared instance of `Manager`, used by top-level Alamofire request methods, and suitable for use directly 
+        for any ad hoc requests.
+    */
+    public static let sharedInstance: Manager = {
+        let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
+        configuration.HTTPAdditionalHeaders = Manager.defaultHTTPHeaders
+
+        return Manager(configuration: configuration)
+    }()
+
+    /**
+        Creates default values for the "Accept-Encoding", "Accept-Language" and "User-Agent" headers.
+    */
+    public static let defaultHTTPHeaders: [String: String] = {
+        // Accept-Encoding HTTP Header; see https://tools.ietf.org/html/rfc7230#section-4.2.3
+        let acceptEncoding: String = "gzip;q=1.0, compress;q=0.5"
+
+        // Accept-Language HTTP Header; see https://tools.ietf.org/html/rfc7231#section-5.3.5
+        let acceptLanguage = NSLocale.preferredLanguages().prefix(6).enumerate().map { index, languageCode in
+            let quality = 1.0 - (Double(index) * 0.1)
+            return "\(languageCode);q=\(quality)"
+        }.joinWithSeparator(", ")
+
+        // User-Agent Header; see https://tools.ietf.org/html/rfc7231#section-5.5.3
+        let userAgent: String = {
+            if let info = NSBundle.mainBundle().infoDictionary {
+                let executable = info[kCFBundleExecutableKey as String] as? String ?? "Unknown"
+                let bundle = info[kCFBundleIdentifierKey as String] as? String ?? "Unknown"
+                let version = info[kCFBundleVersionKey as String] as? String ?? "Unknown"
+
+                let osNameVersion: String = {
+                    let versionString: String
+
+                    if #available(OSX 10.10, *) {
+                        let version = NSProcessInfo.processInfo().operatingSystemVersion
+                        versionString = "\(version.majorVersion).\(version.minorVersion).\(version.patchVersion)"
+                    } else {
+                        versionString = "10.9"
+                    }
+
+                    let osName: String = {
+                        #if os(iOS)
+                            return "iOS"
+                        #elseif os(watchOS)
+                            return "watchOS"
+                        #elseif os(tvOS)
+                            return "tvOS"
+                        #elseif os(OSX)
+                            return "OS X"
+                        #elseif os(Linux)
+                            return "Linux"
+                        #else
+                            return "Unknown"
+                        #endif
+                    }()
+
+                    return "\(osName) \(versionString)"
+                }()
+
+                return "\(executable)/\(bundle) (\(version); \(osNameVersion))"
+            }
+
+            return "Alamofire"
+        }()
+
+        return [
+            "Accept-Encoding": acceptEncoding,
+            "Accept-Language": acceptLanguage,
+            "User-Agent": userAgent
+        ]
+    }()
+
+    let queue = dispatch_queue_create(nil, DISPATCH_QUEUE_SERIAL)
+
+    /// The underlying session.
+    public let session: NSURLSession
+
+    /// The session delegate handling all the task and session delegate callbacks.
+    public let delegate: SessionDelegate
+
+    /// Whether to start requests immediately after being constructed. `true` by default.
+    public var startRequestsImmediately: Bool = true
+
+    /**
+        The background completion handler closure provided by the UIApplicationDelegate 
+        `application:handleEventsForBackgroundURLSession:completionHandler:` method. By setting the background 
+        completion handler, the SessionDelegate `sessionDidFinishEventsForBackgroundURLSession` closure implementation 
+        will automatically call the handler.
+    
+        If you need to handle your own events before the handler is called, then you need to override the 
+        SessionDelegate `sessionDidFinishEventsForBackgroundURLSession` and manually call the handler when finished.
+    
+        `nil` by default.
+    */
+    public var backgroundCompletionHandler: (() -> Void)?
+
+    // MARK: - Lifecycle
+
+    /**
+        Initializes the `Manager` instance with the specified configuration, delegate and server trust policy.
+
+        - parameter configuration:            The configuration used to construct the managed session. 
+                                              `NSURLSessionConfiguration.defaultSessionConfiguration()` by default.
+        - parameter delegate:                 The delegate used when initializing the session. `SessionDelegate()` by
+                                              default.
+        - parameter serverTrustPolicyManager: The server trust policy manager to use for evaluating all server trust 
+                                              challenges. `nil` by default.
+
+        - returns: The new `Manager` instance.
+    */
+    public init(
+        configuration: NSURLSessionConfiguration = NSURLSessionConfiguration.defaultSessionConfiguration(),
+        delegate: SessionDelegate = SessionDelegate(),
+        serverTrustPolicyManager: ServerTrustPolicyManager? = nil)
+    {
+        self.delegate = delegate
+        self.session = NSURLSession(configuration: configuration, delegate: delegate, delegateQueue: nil)
+
+        commonInit(serverTrustPolicyManager: serverTrustPolicyManager)
+    }
+
+    /**
+        Initializes the `Manager` instance with the specified session, delegate and server trust policy.
+
+        - parameter session:                  The URL session.
+        - parameter delegate:                 The delegate of the URL session. Must equal the URL session's delegate.
+        - parameter serverTrustPolicyManager: The server trust policy manager to use for evaluating all server trust
+                                              challenges. `nil` by default.
+
+        - returns: The new `Manager` instance if the URL session's delegate matches the delegate parameter.
+    */
+    public init?(
+        session: NSURLSession,
+        delegate: SessionDelegate,
+        serverTrustPolicyManager: ServerTrustPolicyManager? = nil)
+    {
+        guard delegate === session.delegate else { return nil }
+
+        self.delegate = delegate
+        self.session = session
+
+        commonInit(serverTrustPolicyManager: serverTrustPolicyManager)
+    }
+
+    private func commonInit(serverTrustPolicyManager serverTrustPolicyManager: ServerTrustPolicyManager?) {
+        session.serverTrustPolicyManager = serverTrustPolicyManager
+
+        delegate.sessionDidFinishEventsForBackgroundURLSession = { [weak self] session in
+            guard let strongSelf = self else { return }
+            dispatch_async(dispatch_get_main_queue()) { strongSelf.backgroundCompletionHandler?() }
+        }
+    }
+
+    deinit {
+        session.invalidateAndCancel()
+    }
+
+    // MARK: - Request
+
+    /**
+        Creates a request for the specified method, URL string, parameters, parameter encoding and headers.
+
+        - parameter method:     The HTTP method.
+        - parameter URLString:  The URL string.
+        - parameter parameters: The parameters. `nil` by default.
+        - parameter encoding:   The parameter encoding. `.URL` by default.
+        - parameter headers:    The HTTP headers. `nil` by default.
+
+        - returns: The created request.
+    */
+    public func request(
+        method: Method,
+        _ URLString: URLStringConvertible,
+        parameters: [String: AnyObject]? = nil,
+        encoding: ParameterEncoding = .URL,
+        headers: [String: String]? = nil)
+        -> Request
+    {
+        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
+        let encodedURLRequest = encoding.encode(mutableURLRequest, parameters: parameters).0
+        return request(encodedURLRequest)
+    }
+
+    /**
+        Creates a request for the specified URL request.
+
+        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
+
+        - parameter URLRequest: The URL request
+
+        - returns: The created request.
+    */
+    public func request(URLRequest: URLRequestConvertible) -> Request {
+        var dataTask: NSURLSessionDataTask!
+        dispatch_sync(queue) { dataTask = self.session.dataTaskWithRequest(URLRequest.URLRequest) }
+
+        let request = Request(session: session, task: dataTask)
+        delegate[request.delegate.task] = request.delegate
+
+        if startRequestsImmediately {
+            request.resume()
+        }
+
+        return request
+    }
+
+    // MARK: - SessionDelegate
+
+    /**
+        Responsible for handling all delegate callbacks for the underlying session.
+    */
+    public class SessionDelegate: NSObject, NSURLSessionDelegate, NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate {
+        private var subdelegates: [Int: Request.TaskDelegate] = [:]
+        private let subdelegateQueue = dispatch_queue_create(nil, DISPATCH_QUEUE_CONCURRENT)
+
+        /// Access the task delegate for the specified task in a thread-safe manner.
+        public subscript(task: NSURLSessionTask) -> Request.TaskDelegate? {
+            get {
+                var subdelegate: Request.TaskDelegate?
+                dispatch_sync(subdelegateQueue) { subdelegate = self.subdelegates[task.taskIdentifier] }
+
+                return subdelegate
+            }
+            set {
+                dispatch_barrier_async(subdelegateQueue) { self.subdelegates[task.taskIdentifier] = newValue }
+            }
+        }
+
+        /**
+            Initializes the `SessionDelegate` instance.
+
+            - returns: The new `SessionDelegate` instance.
+        */
+        public override init() {
+            super.init()
+        }
+
+        // MARK: - NSURLSessionDelegate
+
+        // MARK: Override Closures
+
+        /// Overrides default behavior for NSURLSessionDelegate method `URLSession:didBecomeInvalidWithError:`.
+        public var sessionDidBecomeInvalidWithError: ((NSURLSession, NSError?) -> Void)?
+
+        /// Overrides default behavior for NSURLSessionDelegate method `URLSession:didReceiveChallenge:completionHandler:`.
+        public var sessionDidReceiveChallenge: ((NSURLSession, NSURLAuthenticationChallenge) -> (NSURLSessionAuthChallengeDisposition, NSURLCredential?))?
+
+        /// Overrides all behavior for NSURLSessionDelegate method `URLSession:didReceiveChallenge:completionHandler:` and requires the caller to call the `completionHandler`.
+        public var sessionDidReceiveChallengeWithCompletion: ((NSURLSession, NSURLAuthenticationChallenge, (NSURLSessionAuthChallengeDisposition, NSURLCredential?) -> Void) -> Void)?
+
+        /// Overrides default behavior for NSURLSessionDelegate method `URLSessionDidFinishEventsForBackgroundURLSession:`.
+        public var sessionDidFinishEventsForBackgroundURLSession: ((NSURLSession) -> Void)?
+
+        // MARK: Delegate Methods
+
+        /**
+            Tells the delegate that the session has been invalidated.
+
+            - parameter session: The session object that was invalidated.
+            - parameter error:   The error that caused invalidation, or nil if the invalidation was explicit.
+        */
+        public func URLSession(session: NSURLSession, didBecomeInvalidWithError error: NSError?) {
+            sessionDidBecomeInvalidWithError?(session, error)
+        }
+
+        /**
+            Requests credentials from the delegate in response to a session-level authentication request from the remote server.
+
+            - parameter session:           The session containing the task that requested authentication.
+            - parameter challenge:         An object that contains the request for authentication.
+            - parameter completionHandler: A handler that your delegate method must call providing the disposition and credential.
+        */
+        public func URLSession(
+            session: NSURLSession,
+            didReceiveChallenge challenge: NSURLAuthenticationChallenge,
+            completionHandler: ((NSURLSessionAuthChallengeDisposition, NSURLCredential?) -> Void))
+        {
+            guard sessionDidReceiveChallengeWithCompletion == nil else {
+                sessionDidReceiveChallengeWithCompletion?(session, challenge, completionHandler)
+                return
+            }
+
+            var disposition: NSURLSessionAuthChallengeDisposition = .PerformDefaultHandling
+            var credential: NSURLCredential?
+
+            if let sessionDidReceiveChallenge = sessionDidReceiveChallenge {
+                (disposition, credential) = sessionDidReceiveChallenge(session, challenge)
+            } else if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
+                let host = challenge.protectionSpace.host
+
+                if let
+                    serverTrustPolicy = session.serverTrustPolicyManager?.serverTrustPolicyForHost(host),
+                    serverTrust = challenge.protectionSpace.serverTrust
+                {
+                    if serverTrustPolicy.evaluateServerTrust(serverTrust, isValidForHost: host) {
+                        disposition = .UseCredential
+                        credential = NSURLCredential(forTrust: serverTrust)
+                    } else {
+                        disposition = .CancelAuthenticationChallenge
+                    }
+                }
+            }
+
+            completionHandler(disposition, credential)
+        }
+
+        /**
+            Tells the delegate that all messages enqueued for a session have been delivered.
+
+            - parameter session: The session that no longer has any outstanding requests.
+        */
+        public func URLSessionDidFinishEventsForBackgroundURLSession(session: NSURLSession) {
+            sessionDidFinishEventsForBackgroundURLSession?(session)
+        }
+
+        // MARK: - NSURLSessionTaskDelegate
+
+        // MARK: Override Closures
+
+        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:`.
+        public var taskWillPerformHTTPRedirection: ((NSURLSession, NSURLSessionTask, NSHTTPURLResponse, NSURLRequest) -> NSURLRequest?)?
+
+        /// Overrides all behavior for NSURLSessionTaskDelegate method `URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:` and
+        /// requires the caller to call the `completionHandler`.
+        public var taskWillPerformHTTPRedirectionWithCompletion: ((NSURLSession, NSURLSessionTask, NSHTTPURLResponse, NSURLRequest, NSURLRequest? -> Void) -> Void)?
+
+        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:didReceiveChallenge:completionHandler:`.
+        public var taskDidReceiveChallenge: ((NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge) -> (NSURLSessionAuthChallengeDisposition, NSURLCredential?))?
+
+        /// Overrides all behavior for NSURLSessionTaskDelegate method `URLSession:task:didReceiveChallenge:completionHandler:` and 
+        /// requires the caller to call the `completionHandler`.
+        public var taskDidReceiveChallengeWithCompletion: ((NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge, (NSURLSessionAuthChallengeDisposition, NSURLCredential?) -> Void) -> Void)?
+
+        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:session:task:needNewBodyStream:`.
+        public var taskNeedNewBodyStream: ((NSURLSession, NSURLSessionTask) -> NSInputStream?)?
+
+        /// Overrides all behavior for NSURLSessionTaskDelegate method `URLSession:session:task:needNewBodyStream:` and 
+        /// requires the caller to call the `completionHandler`.
+        public var taskNeedNewBodyStreamWithCompletion: ((NSURLSession, NSURLSessionTask, NSInputStream? -> Void) -> Void)?
+
+        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:`.
+        public var taskDidSendBodyData: ((NSURLSession, NSURLSessionTask, Int64, Int64, Int64) -> Void)?
+
+        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:didCompleteWithError:`.
+        public var taskDidComplete: ((NSURLSession, NSURLSessionTask, NSError?) -> Void)?
+
+        // MARK: Delegate Methods
+
+        /**
+            Tells the delegate that the remote server requested an HTTP redirect.
+
+            - parameter session:           The session containing the task whose request resulted in a redirect.
+            - parameter task:              The task whose request resulted in a redirect.
+            - parameter response:          An object containing the server’s response to the original request.
+            - parameter request:           A URL request object filled out with the new location.
+            - parameter completionHandler: A closure that your handler should call with either the value of the request 
+                                           parameter, a modified URL request object, or NULL to refuse the redirect and 
+                                           return the body of the redirect response.
+        */
+        public func URLSession(
+            session: NSURLSession,
+            task: NSURLSessionTask,
+            willPerformHTTPRedirection response: NSHTTPURLResponse,
+            newRequest request: NSURLRequest,
+            completionHandler: NSURLRequest? -> Void)
+        {
+            guard taskWillPerformHTTPRedirectionWithCompletion == nil else {
+                taskWillPerformHTTPRedirectionWithCompletion?(session, task, response, request, completionHandler)
+                return
+            }
+
+            var redirectRequest: NSURLRequest? = request
+
+            if let taskWillPerformHTTPRedirection = taskWillPerformHTTPRedirection {
+                redirectRequest = taskWillPerformHTTPRedirection(session, task, response, request)
+            }
+
+            completionHandler(redirectRequest)
+        }
+
+        /**
+            Requests credentials from the delegate in response to an authentication request from the remote server.
+
+            - parameter session:           The session containing the task whose request requires authentication.
+            - parameter task:              The task whose request requires authentication.
+            - parameter challenge:         An object that contains the request for authentication.
+            - parameter completionHandler: A handler that your delegate method must call providing the disposition and credential.
+        */
+        public func URLSession(
+            session: NSURLSession,
+            task: NSURLSessionTask,
+            didReceiveChallenge challenge: NSURLAuthenticationChallenge,
+            completionHandler: (NSURLSessionAuthChallengeDisposition, NSURLCredential?) -> Void)
+        {
+            guard taskDidReceiveChallengeWithCompletion == nil else {
+                taskDidReceiveChallengeWithCompletion?(session, task, challenge, completionHandler)
+                return
+            }
+
+            if let taskDidReceiveChallenge = taskDidReceiveChallenge {
+                let result = taskDidReceiveChallenge(session, task, challenge)
+                completionHandler(result.0, result.1)
+            } else if let delegate = self[task] {
+                delegate.URLSession(
+                    session,
+                    task: task,
+                    didReceiveChallenge: challenge,
+                    completionHandler: completionHandler
+                )
+            } else {
+                URLSession(session, didReceiveChallenge: challenge, completionHandler: completionHandler)
+            }
+        }
+
+        /**
+            Tells the delegate when a task requires a new request body stream to send to the remote server.
+
+            - parameter session:           The session containing the task that needs a new body stream.
+            - parameter task:              The task that needs a new body stream.
+            - parameter completionHandler: A completion handler that your delegate method should call with the new body stream.
+        */
+        public func URLSession(
+            session: NSURLSession,
+            task: NSURLSessionTask,
+            needNewBodyStream completionHandler: NSInputStream? -> Void)
+        {
+            guard taskNeedNewBodyStreamWithCompletion == nil else {
+                taskNeedNewBodyStreamWithCompletion?(session, task, completionHandler)
+                return
+            }
+
+            if let taskNeedNewBodyStream = taskNeedNewBodyStream {
+                completionHandler(taskNeedNewBodyStream(session, task))
+            } else if let delegate = self[task] {
+                delegate.URLSession(session, task: task, needNewBodyStream: completionHandler)
+            }
+        }
+
+        /**
+            Periodically informs the delegate of the progress of sending body content to the server.
+
+            - parameter session:                  The session containing the data task.
+            - parameter task:                     The data task.
+            - parameter bytesSent:                The number of bytes sent since the last time this delegate method was called.
+            - parameter totalBytesSent:           The total number of bytes sent so far.
+            - parameter totalBytesExpectedToSend: The expected length of the body data.
+        */
+        public func URLSession(
+            session: NSURLSession,
+            task: NSURLSessionTask,
+            didSendBodyData bytesSent: Int64,
+            totalBytesSent: Int64,
+            totalBytesExpectedToSend: Int64)
+        {
+            if let taskDidSendBodyData = taskDidSendBodyData {
+                taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalBytesExpectedToSend)
+            } else if let delegate = self[task] as? Request.UploadTaskDelegate {
+                delegate.URLSession(
+                    session,
+                    task: task,
+                    didSendBodyData: bytesSent,
+                    totalBytesSent: totalBytesSent,
+                    totalBytesExpectedToSend: totalBytesExpectedToSend
+                )
+            }
+        }
+
+        /**
+            Tells the delegate that the task finished transferring data.
+
+            - parameter session: The session containing the task whose request finished transferring data.
+            - parameter task:    The task whose request finished transferring data.
+            - parameter error:   If an error occurred, an error object indicating how the transfer failed, otherwise nil.
+        */
+        public func URLSession(session: NSURLSession, task: NSURLSessionTask, didCompleteWithError error: NSError?) {
+            if let taskDidComplete = taskDidComplete {
+                taskDidComplete(session, task, error)
+            } else if let delegate = self[task] {
+                delegate.URLSession(session, task: task, didCompleteWithError: error)
+            }
+
+            NSNotificationCenter.defaultCenter().postNotificationName(Notifications.Task.DidComplete, object: task)
+
+            self[task] = nil
+        }
+
+        // MARK: - NSURLSessionDataDelegate
+
+        // MARK: Override Closures
+
+        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:didReceiveResponse:completionHandler:`.
+        public var dataTaskDidReceiveResponse: ((NSURLSession, NSURLSessionDataTask, NSURLResponse) -> NSURLSessionResponseDisposition)?
+
+        /// Overrides all behavior for NSURLSessionDataDelegate method `URLSession:dataTask:didReceiveResponse:completionHandler:` and 
+        /// requires caller to call the `completionHandler`.
+        public var dataTaskDidReceiveResponseWithCompletion: ((NSURLSession, NSURLSessionDataTask, NSURLResponse, NSURLSessionResponseDisposition -> Void) -> Void)?
+
+        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:didBecomeDownloadTask:`.
+        public var dataTaskDidBecomeDownloadTask: ((NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask) -> Void)?
+
+        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:didReceiveData:`.
+        public var dataTaskDidReceiveData: ((NSURLSession, NSURLSessionDataTask, NSData) -> Void)?
+
+        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:willCacheResponse:completionHandler:`.
+        public var dataTaskWillCacheResponse: ((NSURLSession, NSURLSessionDataTask, NSCachedURLResponse) -> NSCachedURLResponse?)?
+
+        /// Overrides all behavior for NSURLSessionDataDelegate method `URLSession:dataTask:willCacheResponse:completionHandler:` and 
+        /// requires caller to call the `completionHandler`.
+        public var dataTaskWillCacheResponseWithCompletion: ((NSURLSession, NSURLSessionDataTask, NSCachedURLResponse, NSCachedURLResponse? -> Void) -> Void)?
+
+        // MARK: Delegate Methods
+
+        /**
+            Tells the delegate that the data task received the initial reply (headers) from the server.
+
+            - parameter session:           The session containing the data task that received an initial reply.
+            - parameter dataTask:          The data task that received an initial reply.
+            - parameter response:          A URL response object populated with headers.
+            - parameter completionHandler: A completion handler that your code calls to continue the transfer, passing a 
+                                           constant to indicate whether the transfer should continue as a data task or 
+                                           should become a download task.
+        */
+        public func URLSession(
+            session: NSURLSession,
+            dataTask: NSURLSessionDataTask,
+            didReceiveResponse response: NSURLResponse,
+            completionHandler: NSURLSessionResponseDisposition -> Void)
+        {
+            guard dataTaskDidReceiveResponseWithCompletion == nil else {
+                dataTaskDidReceiveResponseWithCompletion?(session, dataTask, response, completionHandler)
+                return
+            }
+
+            var disposition: NSURLSessionResponseDisposition = .Allow
+
+            if let dataTaskDidReceiveResponse = dataTaskDidReceiveResponse {
+                disposition = dataTaskDidReceiveResponse(session, dataTask, response)
+            }
+
+            completionHandler(disposition)
+        }
+
+        /**
+            Tells the delegate that the data task was changed to a download task.
+
+            - parameter session:      The session containing the task that was replaced by a download task.
+            - parameter dataTask:     The data task that was replaced by a download task.
+            - parameter downloadTask: The new download task that replaced the data task.
+        */
+        public func URLSession(
+            session: NSURLSession,
+            dataTask: NSURLSessionDataTask,
+            didBecomeDownloadTask downloadTask: NSURLSessionDownloadTask)
+        {
+            if let dataTaskDidBecomeDownloadTask = dataTaskDidBecomeDownloadTask {
+                dataTaskDidBecomeDownloadTask(session, dataTask, downloadTask)
+            } else {
+                let downloadDelegate = Request.DownloadTaskDelegate(task: downloadTask)
+                self[downloadTask] = downloadDelegate
+            }
+        }
+
+        /**
+            Tells the delegate that the data task has received some of the expected data.
+
+            - parameter session:  The session containing the data task that provided data.
+            - parameter dataTask: The data task that provided data.
+            - parameter data:     A data object containing the transferred data.
+        */
+        public func URLSession(session: NSURLSession, dataTask: NSURLSessionDataTask, didReceiveData data: NSData) {
+            if let dataTaskDidReceiveData = dataTaskDidReceiveData {
+                dataTaskDidReceiveData(session, dataTask, data)
+            } else if let delegate = self[dataTask] as? Request.DataTaskDelegate {
+                delegate.URLSession(session, dataTask: dataTask, didReceiveData: data)
+            }
+        }
+
+        /**
+            Asks the delegate whether the data (or upload) task should store the response in the cache.
+
+            - parameter session:           The session containing the data (or upload) task.
+            - parameter dataTask:          The data (or upload) task.
+            - parameter proposedResponse:  The default caching behavior. This behavior is determined based on the current 
+                                           caching policy and the values of certain received headers, such as the Pragma 
+                                           and Cache-Control headers.
+            - parameter completionHandler: A block that your handler must call, providing either the original proposed 
+                                           response, a modified version of that response, or NULL to prevent caching the 
+                                           response. If your delegate implements this method, it must call this completion 
+                                           handler; otherwise, your app leaks memory.
+        */
+        public func URLSession(
+            session: NSURLSession,
+            dataTask: NSURLSessionDataTask,
+            willCacheResponse proposedResponse: NSCachedURLResponse,
+            completionHandler: NSCachedURLResponse? -> Void)
+        {
+            guard dataTaskWillCacheResponseWithCompletion == nil else {
+                dataTaskWillCacheResponseWithCompletion?(session, dataTask, proposedResponse, completionHandler)
+                return
+            }
+
+            if let dataTaskWillCacheResponse = dataTaskWillCacheResponse {
+                completionHandler(dataTaskWillCacheResponse(session, dataTask, proposedResponse))
+            } else if let delegate = self[dataTask] as? Request.DataTaskDelegate {
+                delegate.URLSession(
+                    session,
+                    dataTask: dataTask,
+                    willCacheResponse: proposedResponse,
+                    completionHandler: completionHandler
+                )
+            } else {
+                completionHandler(proposedResponse)
+            }
+        }
+
+        // MARK: - NSURLSessionDownloadDelegate
+
+        // MARK: Override Closures
+
+        /// Overrides default behavior for NSURLSessionDownloadDelegate method `URLSession:downloadTask:didFinishDownloadingToURL:`.
+        public var downloadTaskDidFinishDownloadingToURL: ((NSURLSession, NSURLSessionDownloadTask, NSURL) -> Void)?
+
+        /// Overrides default behavior for NSURLSessionDownloadDelegate method `URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:`.
+        public var downloadTaskDidWriteData: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64, Int64) -> Void)?
+
+        /// Overrides default behavior for NSURLSessionDownloadDelegate method `URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:`.
+        public var downloadTaskDidResumeAtOffset: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64) -> Void)?
+
+        // MARK: Delegate Methods
+
+        /**
+            Tells the delegate that a download task has finished downloading.
+
+            - parameter session:      The session containing the download task that finished.
+            - parameter downloadTask: The download task that finished.
+            - parameter location:     A file URL for the temporary file. Because the file is temporary, you must either 
+                                      open the file for reading or move it to a permanent location in your app’s sandbox 
+                                      container directory before returning from this delegate method.
+        */
+        public func URLSession(
+            session: NSURLSession,
+            downloadTask: NSURLSessionDownloadTask,
+            didFinishDownloadingToURL location: NSURL)
+        {
+            if let downloadTaskDidFinishDownloadingToURL = downloadTaskDidFinishDownloadingToURL {
+                downloadTaskDidFinishDownloadingToURL(session, downloadTask, location)
+            } else if let delegate = self[downloadTask] as? Request.DownloadTaskDelegate {
+                delegate.URLSession(session, downloadTask: downloadTask, didFinishDownloadingToURL: location)
+            }
+        }
+
+        /**
+            Periodically informs the delegate about the download’s progress.
+
+            - parameter session:                   The session containing the download task.
+            - parameter downloadTask:              The download task.
+            - parameter bytesWritten:              The number of bytes transferred since the last time this delegate 
+                                                   method was called.
+            - parameter totalBytesWritten:         The total number of bytes transferred so far.
+            - parameter totalBytesExpectedToWrite: The expected length of the file, as provided by the Content-Length 
+                                                   header. If this header was not provided, the value is 
+                                                   `NSURLSessionTransferSizeUnknown`.
+        */
+        public func URLSession(
+            session: NSURLSession,
+            downloadTask: NSURLSessionDownloadTask,
+            didWriteData bytesWritten: Int64,
+            totalBytesWritten: Int64,
+            totalBytesExpectedToWrite: Int64)
+        {
+            if let downloadTaskDidWriteData = downloadTaskDidWriteData {
+                downloadTaskDidWriteData(session, downloadTask, bytesWritten, totalBytesWritten, totalBytesExpectedToWrite)
+            } else if let delegate = self[downloadTask] as? Request.DownloadTaskDelegate {
+                delegate.URLSession(
+                    session,
+                    downloadTask: downloadTask,
+                    didWriteData: bytesWritten,
+                    totalBytesWritten: totalBytesWritten,
+                    totalBytesExpectedToWrite: totalBytesExpectedToWrite
+                )
+            }
+        }
+
+        /**
+            Tells the delegate that the download task has resumed downloading.
+
+            - parameter session:            The session containing the download task that finished.
+            - parameter downloadTask:       The download task that resumed. See explanation in the discussion.
+            - parameter fileOffset:         If the file's cache policy or last modified date prevents reuse of the 
+                                            existing content, then this value is zero. Otherwise, this value is an 
+                                            integer representing the number of bytes on disk that do not need to be 
+                                            retrieved again.
+            - parameter expectedTotalBytes: The expected length of the file, as provided by the Content-Length header. 
+                                            If this header was not provided, the value is NSURLSessionTransferSizeUnknown.
+        */
+        public func URLSession(
+            session: NSURLSession,
+            downloadTask: NSURLSessionDownloadTask,
+            didResumeAtOffset fileOffset: Int64,
+            expectedTotalBytes: Int64)
+        {
+            if let downloadTaskDidResumeAtOffset = downloadTaskDidResumeAtOffset {
+                downloadTaskDidResumeAtOffset(session, downloadTask, fileOffset, expectedTotalBytes)
+            } else if let delegate = self[downloadTask] as? Request.DownloadTaskDelegate {
+                delegate.URLSession(
+                    session,
+                    downloadTask: downloadTask,
+                    didResumeAtOffset: fileOffset,
+                    expectedTotalBytes: expectedTotalBytes
+                )
+            }
+        }
+
+        // MARK: - NSURLSessionStreamDelegate
+
+        var _streamTaskReadClosed: Any?
+        var _streamTaskWriteClosed: Any?
+        var _streamTaskBetterRouteDiscovered: Any?
+        var _streamTaskDidBecomeInputStream: Any?
+
+        // MARK: - NSObject
+
+        public override func respondsToSelector(selector: Selector) -> Bool {
+            #if !os(OSX)
+                if selector == #selector(NSURLSessionDelegate.URLSessionDidFinishEventsForBackgroundURLSession(_:)) {
+                    return sessionDidFinishEventsForBackgroundURLSession != nil
+                }
+            #endif
+
+            switch selector {
+            case #selector(NSURLSessionDelegate.URLSession(_:didBecomeInvalidWithError:)):
+                return sessionDidBecomeInvalidWithError != nil
+            case #selector(NSURLSessionDelegate.URLSession(_:didReceiveChallenge:completionHandler:)):
+                return (sessionDidReceiveChallenge != nil  || sessionDidReceiveChallengeWithCompletion != nil)
+            case #selector(NSURLSessionTaskDelegate.URLSession(_:task:willPerformHTTPRedirection:newRequest:completionHandler:)):
+                return (taskWillPerformHTTPRedirection != nil || taskWillPerformHTTPRedirectionWithCompletion != nil)
+            case #selector(NSURLSessionDataDelegate.URLSession(_:dataTask:didReceiveResponse:completionHandler:)):
+                return (dataTaskDidReceiveResponse != nil || dataTaskDidReceiveResponseWithCompletion != nil)
+            default:
+                return self.dynamicType.instancesRespondToSelector(selector)
+            }
+        }
+    }
+}
diff --git a/Pods/Alamofire/Source/MultipartFormData.swift b/Pods/Alamofire/Source/MultipartFormData.swift
new file mode 100644
index 0000000..b4087ec
--- /dev/null
+++ b/Pods/Alamofire/Source/MultipartFormData.swift
@@ -0,0 +1,659 @@
+//
+//  MultipartFormData.swift
+//
+//  Copyright (c) 2014-2016 Alamofire Software Foundation (http://alamofire.org/)
+//
+//  Permission is hereby granted, free of charge, to any person obtaining a copy
+//  of this software and associated documentation files (the "Software"), to deal
+//  in the Software without restriction, including without limitation the rights
+//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+//  copies of the Software, and to permit persons to whom the Software is
+//  furnished to do so, subject to the following conditions:
+//
+//  The above copyright notice and this permission notice shall be included in
+//  all copies or substantial portions of the Software.
+//
+//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+//  THE SOFTWARE.
+//
+
+import Foundation
+
+#if os(iOS) || os(watchOS) || os(tvOS)
+import MobileCoreServices
+#elseif os(OSX)
+import CoreServices
+#endif
+
+/**
+    Constructs `multipart/form-data` for uploads within an HTTP or HTTPS body. There are currently two ways to encode 
+    multipart form data. The first way is to encode the data directly in memory. This is very efficient, but can lead 
+    to memory issues if the dataset is too large. The second way is designed for larger datasets and will write all the 
+    data to a single file on disk with all the proper boundary segmentation. The second approach MUST be used for 
+    larger datasets such as video content, otherwise your app may run out of memory when trying to encode the dataset.
+
+    For more information on `multipart/form-data` in general, please refer to the RFC-2388 and RFC-2045 specs as well
+    and the w3 form documentation.
+
+    - https://www.ietf.org/rfc/rfc2388.txt
+    - https://www.ietf.org/rfc/rfc2045.txt
+    - https://www.w3.org/TR/html401/interact/forms.html#h-17.13
+*/
+public class MultipartFormData {
+
+    // MARK: - Helper Types
+
+    struct EncodingCharacters {
+        static let CRLF = "\r\n"
+    }
+
+    struct BoundaryGenerator {
+        enum BoundaryType {
+            case Initial, Encapsulated, Final
+        }
+
+        static func randomBoundary() -> String {
+            return String(format: "alamofire.boundary.%08x%08x", arc4random(), arc4random())
+        }
+
+        static func boundaryData(boundaryType boundaryType: BoundaryType, boundary: String) -> NSData {
+            let boundaryText: String
+
+            switch boundaryType {
+            case .Initial:
+                boundaryText = "--\(boundary)\(EncodingCharacters.CRLF)"
+            case .Encapsulated:
+                boundaryText = "\(EncodingCharacters.CRLF)--\(boundary)\(EncodingCharacters.CRLF)"
+            case .Final:
+                boundaryText = "\(EncodingCharacters.CRLF)--\(boundary)--\(EncodingCharacters.CRLF)"
+            }
+
+            return boundaryText.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)!
+        }
+    }
+
+    class BodyPart {
+        let headers: [String: String]
+        let bodyStream: NSInputStream
+        let bodyContentLength: UInt64
+        var hasInitialBoundary = false
+        var hasFinalBoundary = false
+
+        init(headers: [String: String], bodyStream: NSInputStream, bodyContentLength: UInt64) {
+            self.headers = headers
+            self.bodyStream = bodyStream
+            self.bodyContentLength = bodyContentLength
+        }
+    }
+
+    // MARK: - Properties
+
+    /// The `Content-Type` header value containing the boundary used to generate the `multipart/form-data`.
+    public var contentType: String { return "multipart/form-data; boundary=\(boundary)" }
+
+    /// The content length of all body parts used to generate the `multipart/form-data` not including the boundaries.
+    public var contentLength: UInt64 { return bodyParts.reduce(0) { $0 + $1.bodyContentLength } }
+
+    /// The boundary used to separate the body parts in the encoded form data.
+    public let boundary: String
+
+    private var bodyParts: [BodyPart]
+    private var bodyPartError: NSError?
+    private let streamBufferSize: Int
+
+    // MARK: - Lifecycle
+
+    /**
+        Creates a multipart form data object.
+
+        - returns: The multipart form data object.
+    */
+    public init() {
+        self.boundary = BoundaryGenerator.randomBoundary()
+        self.bodyParts = []
+
+        /**
+         *  The optimal read/write buffer size in bytes for input and output streams is 1024 (1KB). For more 
+         *  information, please refer to the following article:
+         *    - https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Streams/Articles/ReadingInputStreams.html
+         */
+
+        self.streamBufferSize = 1024
+    }
+
+    // MARK: - Body Parts
+
+    /**
+        Creates a body part from the data and appends it to the multipart form data object.
+
+        The body part data will be encoded using the following format:
+
+        - `Content-Disposition: form-data; name=#{name}` (HTTP Header)
+        - Encoded data
+        - Multipart form boundary
+
+        - parameter data: The data to encode into the multipart form data.
+        - parameter name: The name to associate with the data in the `Content-Disposition` HTTP header.
+    */
+    public func appendBodyPart(data data: NSData, name: String) {
+        let headers = contentHeaders(name: name)
+        let stream = NSInputStream(data: data)
+        let length = UInt64(data.length)
+
+        appendBodyPart(stream: stream, length: length, headers: headers)
+    }
+
+    /**
+        Creates a body part from the data and appends it to the multipart form data object.
+
+        The body part data will be encoded using the following format:
+
+        - `Content-Disposition: form-data; name=#{name}` (HTTP Header)
+        - `Content-Type: #{generated mimeType}` (HTTP Header)
+        - Encoded data
+        - Multipart form boundary
+
+        - parameter data:     The data to encode into the multipart form data.
+        - parameter name:     The name to associate with the data in the `Content-Disposition` HTTP header.
+        - parameter mimeType: The MIME type to associate with the data content type in the `Content-Type` HTTP header.
+    */
+    public func appendBodyPart(data data: NSData, name: String, mimeType: String) {
+        let headers = contentHeaders(name: name, mimeType: mimeType)
+        let stream = NSInputStream(data: data)
+        let length = UInt64(data.length)
+
+        appendBodyPart(stream: stream, length: length, headers: headers)
+    }
+
+    /**
+        Creates a body part from the data and appends it to the multipart form data object.
+
+        The body part data will be encoded using the following format:
+
+        - `Content-Disposition: form-data; name=#{name}; filename=#{filename}` (HTTP Header)
+        - `Content-Type: #{mimeType}` (HTTP Header)
+        - Encoded file data
+        - Multipart form boundary
+
+        - parameter data:     The data to encode into the multipart form data.
+        - parameter name:     The name to associate with the data in the `Content-Disposition` HTTP header.
+        - parameter fileName: The filename to associate with the data in the `Content-Disposition` HTTP header.
+        - parameter mimeType: The MIME type to associate with the data in the `Content-Type` HTTP header.
+    */
+    public func appendBodyPart(data data: NSData, name: String, fileName: String, mimeType: String) {
+        let headers = contentHeaders(name: name, fileName: fileName, mimeType: mimeType)
+        let stream = NSInputStream(data: data)
+        let length = UInt64(data.length)
+
+        appendBodyPart(stream: stream, length: length, headers: headers)
+    }
+
+    /**
+        Creates a body part from the file and appends it to the multipart form data object.
+
+        The body part data will be encoded using the following format:
+
+        - `Content-Disposition: form-data; name=#{name}; filename=#{generated filename}` (HTTP Header)
+        - `Content-Type: #{generated mimeType}` (HTTP Header)
+        - Encoded file data
+        - Multipart form boundary
+
+        The filename in the `Content-Disposition` HTTP header is generated from the last path component of the
+        `fileURL`. The `Content-Type` HTTP header MIME type is generated by mapping the `fileURL` extension to the
+        system associated MIME type.
+
+        - parameter fileURL: The URL of the file whose content will be encoded into the multipart form data.
+        - parameter name:    The name to associate with the file content in the `Content-Disposition` HTTP header.
+    */
+    public func appendBodyPart(fileURL fileURL: NSURL, name: String) {
+        if let
+            fileName = fileURL.lastPathComponent,
+            pathExtension = fileURL.pathExtension
+        {
+            let mimeType = mimeTypeForPathExtension(pathExtension)
+            appendBodyPart(fileURL: fileURL, name: name, fileName: fileName, mimeType: mimeType)
+        } else {
+            let failureReason = "Failed to extract the fileName of the provided URL: \(fileURL)"
+            setBodyPartError(code: NSURLErrorBadURL, failureReason: failureReason)
+        }
+    }
+
+    /**
+        Creates a body part from the file and appends it to the multipart form data object.
+
+        The body part data will be encoded using the following format:
+
+        - Content-Disposition: form-data; name=#{name}; filename=#{filename} (HTTP Header)
+        - Content-Type: #{mimeType} (HTTP Header)
+        - Encoded file data
+        - Multipart form boundary
+
+        - parameter fileURL:  The URL of the file whose content will be encoded into the multipart form data.
+        - parameter name:     The name to associate with the file content in the `Content-Disposition` HTTP header.
+        - parameter fileName: The filename to associate with the file content in the `Content-Disposition` HTTP header.
+        - parameter mimeType: The MIME type to associate with the file content in the `Content-Type` HTTP header.
+    */
+    public func appendBodyPart(fileURL fileURL: NSURL, name: String, fileName: String, mimeType: String) {
+        let headers = contentHeaders(name: name, fileName: fileName, mimeType: mimeType)
+
+        //============================================================
+        //                 Check 1 - is file URL?
+        //============================================================
+
+        guard fileURL.fileURL else {
+            let failureReason = "The file URL does not point to a file URL: \(fileURL)"
+            setBodyPartError(code: NSURLErrorBadURL, failureReason: failureReason)
+            return
+        }
+
+        //============================================================
+        //              Check 2 - is file URL reachable?
+        //============================================================
+
+        var isReachable = true
+
+        if #available(OSX 10.10, *) {
+            isReachable = fileURL.checkPromisedItemIsReachableAndReturnError(nil)
+        }
+
+        guard isReachable else {
+            setBodyPartError(code: NSURLErrorBadURL, failureReason: "The file URL is not reachable: \(fileURL)")
+            return
+        }
+
+        //============================================================
+        //            Check 3 - is file URL a directory?
+        //============================================================
+
+        var isDirectory: ObjCBool = false
+
+        guard let
+            path = fileURL.path
+            where NSFileManager.defaultManager().fileExistsAtPath(path, isDirectory: &isDirectory) && !isDirectory else
+        {
+            let failureReason = "The file URL is a directory, not a file: \(fileURL)"
+            setBodyPartError(code: NSURLErrorBadURL, failureReason: failureReason)
+            return
+        }
+
+        //============================================================
+        //          Check 4 - can the file size be extracted?
+        //============================================================
+
+        var bodyContentLength: UInt64?
+
+        do {
+            if let
+                path = fileURL.path,
+                fileSize = try NSFileManager.defaultManager().attributesOfItemAtPath(path)[NSFileSize] as? NSNumber
+            {
+                bodyContentLength = fileSize.unsignedLongLongValue
+            }
+        } catch {
+            // No-op
+        }
+
+        guard let length = bodyContentLength else {
+            let failureReason = "Could not fetch attributes from the file URL: \(fileURL)"
+            setBodyPartError(code: NSURLErrorBadURL, failureReason: failureReason)
+            return
+        }
+
+        //============================================================
+        //       Check 5 - can a stream be created from file URL?
+        //============================================================
+
+        guard let stream = NSInputStream(URL: fileURL) else {
+            let failureReason = "Failed to create an input stream from the file URL: \(fileURL)"
+            setBodyPartError(code: NSURLErrorCannotOpenFile, failureReason: failureReason)
+            return
+        }
+
+        appendBodyPart(stream: stream, length: length, headers: headers)
+    }
+
+    /**
+        Creates a body part from the stream and appends it to the multipart form data object.
+
+        The body part data will be encoded using the following format:
+
+        - `Content-Disposition: form-data; name=#{name}; filename=#{filename}` (HTTP Header)
+        - `Content-Type: #{mimeType}` (HTTP Header)
+        - Encoded stream data
+        - Multipart form boundary
+
+        - parameter stream:   The input stream to encode in the multipart form data.
+        - parameter length:   The content length of the stream.
+        - parameter name:     The name to associate with the stream content in the `Content-Disposition` HTTP header.
+        - parameter fileName: The filename to associate with the stream content in the `Content-Disposition` HTTP header.
+        - parameter mimeType: The MIME type to associate with the stream content in the `Content-Type` HTTP header.
+    */
+    public func appendBodyPart(
+        stream stream: NSInputStream,
+        length: UInt64,
+        name: String,
+        fileName: String,
+        mimeType: String)
+    {
+        let headers = contentHeaders(name: name, fileName: fileName, mimeType: mimeType)
+        appendBodyPart(stream: stream, length: length, headers: headers)
+    }
+
+    /**
+        Creates a body part with the headers, stream and length and appends it to the multipart form data object.
+
+        The body part data will be encoded using the following format:
+
+        - HTTP headers
+        - Encoded stream data
+        - Multipart form boundary
+
+        - parameter stream:  The input stream to encode in the multipart form data.
+        - parameter length:  The content length of the stream.
+        - parameter headers: The HTTP headers for the body part.
+    */
+    public func appendBodyPart(stream stream: NSInputStream, length: UInt64, headers: [String: String]) {
+        let bodyPart = BodyPart(headers: headers, bodyStream: stream, bodyContentLength: length)
+        bodyParts.append(bodyPart)
+    }
+
+    // MARK: - Data Encoding
+
+    /**
+        Encodes all the appended body parts into a single `NSData` object.
+
+        It is important to note that this method will load all the appended body parts into memory all at the same 
+        time. This method should only be used when the encoded data will have a small memory footprint. For large data 
+        cases, please use the `writeEncodedDataToDisk(fileURL:completionHandler:)` method.
+
+        - throws: An `NSError` if encoding encounters an error.
+
+        - returns: The encoded `NSData` if encoding is successful.
+    */
+    public func encode() throws -> NSData {
+        if let bodyPartError = bodyPartError {
+            throw bodyPartError
+        }
+
+        let encoded = NSMutableData()
+
+        bodyParts.first?.hasInitialBoundary = true
+        bodyParts.last?.hasFinalBoundary = true
+
+        for bodyPart in bodyParts {
+            let encodedData = try encodeBodyPart(bodyPart)
+            encoded.appendData(encodedData)
+        }
+
+        return encoded
+    }
+
+    /**
+        Writes the appended body parts into the given file URL.
+
+        This process is facilitated by reading and writing with input and output streams, respectively. Thus,
+        this approach is very memory efficient and should be used for large body part data.
+
+        - parameter fileURL: The file URL to write the multipart form data into.
+
+        - throws: An `NSError` if encoding encounters an error.
+    */
+    public func writeEncodedDataToDisk(fileURL: NSURL) throws {
+        if let bodyPartError = bodyPartError {
+            throw bodyPartError
+        }
+
+        if let path = fileURL.path where NSFileManager.defaultManager().fileExistsAtPath(path) {
+            let failureReason = "A file already exists at the given file URL: \(fileURL)"
+            throw Error.error(domain: NSURLErrorDomain, code: NSURLErrorBadURL, failureReason: failureReason)
+        } else if !fileURL.fileURL {
+            let failureReason = "The URL does not point to a valid file: \(fileURL)"
+            throw Error.error(domain: NSURLErrorDomain, code: NSURLErrorBadURL, failureReason: failureReason)
+        }
+
+        let outputStream: NSOutputStream
+
+        if let possibleOutputStream = NSOutputStream(URL: fileURL, append: false) {
+            outputStream = possibleOutputStream
+        } else {
+            let failureReason = "Failed to create an output stream with the given URL: \(fileURL)"
+            throw Error.error(domain: NSURLErrorDomain, code: NSURLErrorCannotOpenFile, failureReason: failureReason)
+        }
+
+        outputStream.open()
+
+        self.bodyParts.first?.hasInitialBoundary = true
+        self.bodyParts.last?.hasFinalBoundary = true
+
+        for bodyPart in self.bodyParts {
+            try writeBodyPart(bodyPart, toOutputStream: outputStream)
+        }
+
+        outputStream.close()
+    }
+
+    // MARK: - Private - Body Part Encoding
+
+    private func encodeBodyPart(bodyPart: BodyPart) throws -> NSData {
+        let encoded = NSMutableData()
+
+        let initialData = bodyPart.hasInitialBoundary ? initialBoundaryData() : encapsulatedBoundaryData()
+        encoded.appendData(initialData)
+
+        let headerData = encodeHeaderDataForBodyPart(bodyPart)
+        encoded.appendData(headerData)
+
+        let bodyStreamData = try encodeBodyStreamDataForBodyPart(bodyPart)
+        encoded.appendData(bodyStreamData)
+
+        if bodyPart.hasFinalBoundary {
+            encoded.appendData(finalBoundaryData())
+        }
+
+        return encoded
+    }
+
+    private func encodeHeaderDataForBodyPart(bodyPart: BodyPart) -> NSData {
+        var headerText = ""
+
+        for (key, value) in bodyPart.headers {
+            headerText += "\(key): \(value)\(EncodingCharacters.CRLF)"
+        }
+        headerText += EncodingCharacters.CRLF
+
+        return headerText.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)!
+    }
+
+    private func encodeBodyStreamDataForBodyPart(bodyPart: BodyPart) throws -> NSData {
+        let inputStream = bodyPart.bodyStream
+        inputStream.open()
+
+        var error: NSError?
+        let encoded = NSMutableData()
+
+        while inputStream.hasBytesAvailable {
+            var buffer = [UInt8](count: streamBufferSize, repeatedValue: 0)
+            let bytesRead = inputStream.read(&buffer, maxLength: streamBufferSize)
+
+            if inputStream.streamError != nil {
+                error = inputStream.streamError
+                break
+            }
+
+            if bytesRead > 0 {
+                encoded.appendBytes(buffer, length: bytesRead)
+            } else if bytesRead < 0 {
+                let failureReason = "Failed to read from input stream: \(inputStream)"
+                error = Error.error(domain: NSURLErrorDomain, code: .InputStreamReadFailed, failureReason: failureReason)
+                break
+            } else {
+                break
+            }
+        }
+
+        inputStream.close()
+
+        if let error = error {
+            throw error
+        }
+
+        return encoded
+    }
+
+    // MARK: - Private - Writing Body Part to Output Stream
+
+    private func writeBodyPart(bodyPart: BodyPart, toOutputStream outputStream: NSOutputStream) throws {
+        try writeInitialBoundaryDataForBodyPart(bodyPart, toOutputStream: outputStream)
+        try writeHeaderDataForBodyPart(bodyPart, toOutputStream: outputStream)
+        try writeBodyStreamForBodyPart(bodyPart, toOutputStream: outputStream)
+        try writeFinalBoundaryDataForBodyPart(bodyPart, toOutputStream: outputStream)
+    }
+
+    private func writeInitialBoundaryDataForBodyPart(
+        bodyPart: BodyPart,
+        toOutputStream outputStream: NSOutputStream)
+        throws
+    {
+        let initialData = bodyPart.hasInitialBoundary ? initialBoundaryData() : encapsulatedBoundaryData()
+        return try writeData(initialData, toOutputStream: outputStream)
+    }
+
+    private func writeHeaderDataForBodyPart(bodyPart: BodyPart, toOutputStream outputStream: NSOutputStream) throws {
+        let headerData = encodeHeaderDataForBodyPart(bodyPart)
+        return try writeData(headerData, toOutputStream: outputStream)
+    }
+
+    private func writeBodyStreamForBodyPart(bodyPart: BodyPart, toOutputStream outputStream: NSOutputStream) throws {
+        let inputStream = bodyPart.bodyStream
+        inputStream.open()
+
+        while inputStream.hasBytesAvailable {
+            var buffer = [UInt8](count: streamBufferSize, repeatedValue: 0)
+            let bytesRead = inputStream.read(&buffer, maxLength: streamBufferSize)
+
+            if let streamError = inputStream.streamError {
+                throw streamError
+            }
+
+            if bytesRead > 0 {
+                if buffer.count != bytesRead {
+                    buffer = Array(buffer[0..<bytesRead])
+                }
+
+                try writeBuffer(&buffer, toOutputStream: outputStream)
+            } else if bytesRead < 0 {
+                let failureReason = "Failed to read from input stream: \(inputStream)"
+                throw Error.error(domain: NSURLErrorDomain, code: .InputStreamReadFailed, failureReason: failureReason)
+            } else {
+                break
+            }
+        }
+
+        inputStream.close()
+    }
+
+    private func writeFinalBoundaryDataForBodyPart(
+        bodyPart: BodyPart,
+        toOutputStream outputStream: NSOutputStream)
+        throws
+    {
+        if bodyPart.hasFinalBoundary {
+            return try writeData(finalBoundaryData(), toOutputStream: outputStream)
+        }
+    }
+
+    // MARK: - Private - Writing Buffered Data to Output Stream
+
+    private func writeData(data: NSData, toOutputStream outputStream: NSOutputStream) throws {
+        var buffer = [UInt8](count: data.length, repeatedValue: 0)
+        data.getBytes(&buffer, length: data.length)
+
+        return try writeBuffer(&buffer, toOutputStream: outputStream)
+    }
+
+    private func writeBuffer(inout buffer: [UInt8], toOutputStream outputStream: NSOutputStream) throws {
+        var bytesToWrite = buffer.count
+
+        while bytesToWrite > 0 {
+            if outputStream.hasSpaceAvailable {
+                let bytesWritten = outputStream.write(buffer, maxLength: bytesToWrite)
+
+                if let streamError = outputStream.streamError {
+                    throw streamError
+                }
+
+                if bytesWritten < 0 {
+                    let failureReason = "Failed to write to output stream: \(outputStream)"
+                    throw Error.error(domain: NSURLErrorDomain, code: .OutputStreamWriteFailed, failureReason: failureReason)
+                }
+
+                bytesToWrite -= bytesWritten
+
+                if bytesToWrite > 0 {
+                    buffer = Array(buffer[bytesWritten..<buffer.count])
+                }
+            } else if let streamError = outputStream.streamError {
+                throw streamError
+            }
+        }
+    }
+
+    // MARK: - Private - Mime Type
+
+    private func mimeTypeForPathExtension(pathExtension: String) -> String {
+        if let
+            id = UTTypeCreatePreferredIdentifierForTag(kUTTagClassFilenameExtension, pathExtension, nil)?.takeRetainedValue(),
+            contentType = UTTypeCopyPreferredTagWithClass(id, kUTTagClassMIMEType)?.takeRetainedValue()
+        {
+            return contentType as String
+        }
+
+        return "application/octet-stream"
+    }
+
+    // MARK: - Private - Content Headers
+
+    private func contentHeaders(name name: String) -> [String: String] {
+        return ["Content-Disposition": "form-data; name=\"\(name)\""]
+    }
+
+    private func contentHeaders(name name: String, mimeType: String) -> [String: String] {
+        return [
+            "Content-Disposition": "form-data; name=\"\(name)\"",
+            "Content-Type": "\(mimeType)"
+        ]
+    }
+
+    private func contentHeaders(name name: String, fileName: String, mimeType: String) -> [String: String] {
+        return [
+            "Content-Disposition": "form-data; name=\"\(name)\"; filename=\"\(fileName)\"",
+            "Content-Type": "\(mimeType)"
+        ]
+    }
+
+    // MARK: - Private - Boundary Encoding
+
+    private func initialBoundaryData() -> NSData {
+        return BoundaryGenerator.boundaryData(boundaryType: .Initial, boundary: boundary)
+    }
+
+    private func encapsulatedBoundaryData() -> NSData {
+        return BoundaryGenerator.boundaryData(boundaryType: .Encapsulated, boundary: boundary)
+    }
+
+    private func finalBoundaryData() -> NSData {
+        return BoundaryGenerator.boundaryData(boundaryType: .Final, boundary: boundary)
+    }
+
+    // MARK: - Private - Errors
+
+    private func setBodyPartError(code code: Int, failureReason: String) {
+        guard bodyPartError == nil else { return }
+        bodyPartError = Error.error(domain: NSURLErrorDomain, code: code, failureReason: failureReason)
+    }
+}
diff --git a/Pods/Alamofire/Source/NetworkReachabilityManager.swift b/Pods/Alamofire/Source/NetworkReachabilityManager.swift
new file mode 100644
index 0000000..1e5c7b0
--- /dev/null
+++ b/Pods/Alamofire/Source/NetworkReachabilityManager.swift
@@ -0,0 +1,244 @@
+//
+//  NetworkReachabilityManager.swift
+//
+//  Copyright (c) 2014-2016 Alamofire Software Foundation (http://alamofire.org/)
+//
+//  Permission is hereby granted, free of charge, to any person obtaining a copy
+//  of this software and associated documentation files (the "Software"), to deal
+//  in the Software without restriction, including without limitation the rights
+//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+//  copies of the Software, and to permit persons to whom the Software is
+//  furnished to do so, subject to the following conditions:
+//
+//  The above copyright notice and this permission notice shall be included in
+//  all copies or substantial portions of the Software.
+//
+//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+//  THE SOFTWARE.
+//
+
+#if !os(watchOS)
+
+import Foundation
+import SystemConfiguration
+
+/**
+    The `NetworkReachabilityManager` class listens for reachability changes of hosts and addresses for both WWAN and
+    WiFi network interfaces.
+
+    Reachability can be used to determine background information about why a network operation failed, or to retry
+    network requests when a connection is established. It should not be used to prevent a user from initiating a network
+    request, as it's possible that an initial request may be required to establish reachability.
+*/
+public class NetworkReachabilityManager {
+    /**
+        Defines the various states of network reachability.
+
+        - Unknown:         It is unknown whether the network is reachable.
+        - NotReachable:    The network is not reachable.
+        - ReachableOnWWAN: The network is reachable over the WWAN connection.
+        - ReachableOnWiFi: The network is reachable over the WiFi connection.
+    */
+    public enum NetworkReachabilityStatus {
+        case Unknown
+        case NotReachable
+        case Reachable(ConnectionType)
+    }
+
+    /**
+        Defines the various connection types detected by reachability flags.
+
+        - EthernetOrWiFi: The connection type is either over Ethernet or WiFi.
+        - WWAN:           The connection type is a WWAN connection.
+    */
+    public enum ConnectionType {
+        case EthernetOrWiFi
+        case WWAN
+    }
+
+    /// A closure executed when the network reachability status changes. The closure takes a single argument: the 
+    /// network reachability status.
+    public typealias Listener = NetworkReachabilityStatus -> Void
+
+    // MARK: - Properties
+
+    /// Whether the network is currently reachable.
+    public var isReachable: Bool { return isReachableOnWWAN || isReachableOnEthernetOrWiFi }
+
+    /// Whether the network is currently reachable over the WWAN interface.
+    public var isReachableOnWWAN: Bool { return networkReachabilityStatus == .Reachable(.WWAN) }
+
+    /// Whether the network is currently reachable over Ethernet or WiFi interface.
+    public var isReachableOnEthernetOrWiFi: Bool { return networkReachabilityStatus == .Reachable(.EthernetOrWiFi) }
+
+    /// The current network reachability status.
+    public var networkReachabilityStatus: NetworkReachabilityStatus {
+        guard let flags = self.flags else { return .Unknown }
+        return networkReachabilityStatusForFlags(flags)
+    }
+
+    /// The dispatch queue to execute the `listener` closure on.
+    public var listenerQueue: dispatch_queue_t = dispatch_get_main_queue()
+
+    /// A closure executed when the network reachability status changes.
+    public var listener: Listener?
+
+    private var flags: SCNetworkReachabilityFlags? {
+        var flags = SCNetworkReachabilityFlags()
+
+        if SCNetworkReachabilityGetFlags(reachability, &flags) {
+            return flags
+        }
+
+        return nil
+    }
+
+    private let reachability: SCNetworkReachability
+    private var previousFlags: SCNetworkReachabilityFlags
+
+    // MARK: - Initialization
+
+    /**
+        Creates a `NetworkReachabilityManager` instance with the specified host.
+
+        - parameter host: The host used to evaluate network reachability.
+
+        - returns: The new `NetworkReachabilityManager` instance.
+    */
+    public convenience init?(host: String) {
+        guard let reachability = SCNetworkReachabilityCreateWithName(nil, host) else { return nil }
+        self.init(reachability: reachability)
+    }
+
+    /**
+        Creates a `NetworkReachabilityManager` instance that monitors the address 0.0.0.0.
+
+        Reachability treats the 0.0.0.0 address as a special token that causes it to monitor the general routing
+        status of the device, both IPv4 and IPv6.
+
+        - returns: The new `NetworkReachabilityManager` instance.
+    */
+    public convenience init?() {
+        var address = sockaddr_in()
+        address.sin_len = UInt8(sizeofValue(address))
+        address.sin_family = sa_family_t(AF_INET)
+
+        guard let reachability = withUnsafePointer(&address, {
+            SCNetworkReachabilityCreateWithAddress(nil, UnsafePointer($0))
+        }) else { return nil }
+
+        self.init(reachability: reachability)
+    }
+
+    private init(reachability: SCNetworkReachability) {
+        self.reachability = reachability
+        self.previousFlags = SCNetworkReachabilityFlags()
+    }
+
+    deinit {
+        stopListening()
+    }
+
+    // MARK: - Listening
+
+    /**
+        Starts listening for changes in network reachability status.
+
+        - returns: `true` if listening was started successfully, `false` otherwise.
+    */
+    public func startListening() -> Bool {
+        var context = SCNetworkReachabilityContext(version: 0, info: nil, retain: nil, release: nil, copyDescription: nil)
+        context.info = UnsafeMutablePointer(Unmanaged.passUnretained(self).toOpaque())
+
+        let callbackEnabled = SCNetworkReachabilitySetCallback(
+            reachability,
+            { (_, flags, info) in
+                let reachability = Unmanaged<NetworkReachabilityManager>.fromOpaque(COpaquePointer(info)).takeUnretainedValue()
+                reachability.notifyListener(flags)
+            },
+            &context
+        )
+
+        let queueEnabled = SCNetworkReachabilitySetDispatchQueue(reachability, listenerQueue)
+
+        dispatch_async(listenerQueue) {
+            self.previousFlags = SCNetworkReachabilityFlags()
+            self.notifyListener(self.flags ?? SCNetworkReachabilityFlags())
+        }
+
+        return callbackEnabled && queueEnabled
+    }
+
+    /**
+        Stops listening for changes in network reachability status.
+    */
+    public func stopListening() {
+        SCNetworkReachabilitySetCallback(reachability, nil, nil)
+        SCNetworkReachabilitySetDispatchQueue(reachability, nil)
+    }
+
+    // MARK: - Internal - Listener Notification
+
+    func notifyListener(flags: SCNetworkReachabilityFlags) {
+        guard previousFlags != flags else { return }
+        previousFlags = flags
+
+        listener?(networkReachabilityStatusForFlags(flags))
+    }
+
+    // MARK: - Internal - Network Reachability Status
+
+    func networkReachabilityStatusForFlags(flags: SCNetworkReachabilityFlags) -> NetworkReachabilityStatus {
+        guard flags.contains(.Reachable) else { return .NotReachable }
+
+        var networkStatus: NetworkReachabilityStatus = .NotReachable
+
+        if !flags.contains(.ConnectionRequired) { networkStatus = .Reachable(.EthernetOrWiFi) }
+
+        if flags.contains(.ConnectionOnDemand) || flags.contains(.ConnectionOnTraffic) {
+            if !flags.contains(.InterventionRequired) { networkStatus = .Reachable(.EthernetOrWiFi) }
+        }
+
+        #if os(iOS)
+            if flags.contains(.IsWWAN) { networkStatus = .Reachable(.WWAN) }
+        #endif
+
+        return networkStatus
+    }
+}
+
+// MARK: -
+
+extension NetworkReachabilityManager.NetworkReachabilityStatus: Equatable {}
+
+/**
+    Returns whether the two network reachability status values are equal.
+
+    - parameter lhs: The left-hand side value to compare.
+    - parameter rhs: The right-hand side value to compare.
+
+    - returns: `true` if the two values are equal, `false` otherwise.
+*/
+public func ==(
+    lhs: NetworkReachabilityManager.NetworkReachabilityStatus,
+    rhs: NetworkReachabilityManager.NetworkReachabilityStatus)
+    -> Bool
+{
+    switch (lhs, rhs) {
+    case (.Unknown, .Unknown):
+        return true
+    case (.NotReachable, .NotReachable):
+        return true
+    case let (.Reachable(lhsConnectionType), .Reachable(rhsConnectionType)):
+        return lhsConnectionType == rhsConnectionType
+    default:
+        return false
+    }
+}
+
+#endif
diff --git a/Pods/Alamofire/Source/Notifications.swift b/Pods/Alamofire/Source/Notifications.swift
new file mode 100644
index 0000000..cece87a
--- /dev/null
+++ b/Pods/Alamofire/Source/Notifications.swift
@@ -0,0 +1,47 @@
+//
+//  Notifications.swift
+//
+//  Copyright (c) 2014-2016 Alamofire Software Foundation (http://alamofire.org/)
+//
+//  Permission is hereby granted, free of charge, to any person obtaining a copy
+//  of this software and associated documentation files (the "Software"), to deal
+//  in the Software without restriction, including without limitation the rights
+//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+//  copies of the Software, and to permit persons to whom the Software is
+//  furnished to do so, subject to the following conditions:
+//
+//  The above copyright notice and this permission notice shall be included in
+//  all copies or substantial portions of the Software.
+//
+//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+//  THE SOFTWARE.
+//
+
+import Foundation
+
+/// Contains all the `NSNotification` names posted by Alamofire with descriptions of each notification's payload.
+public struct Notifications {
+    /// Used as a namespace for all `NSURLSessionTask` related notifications.
+    public struct Task {
+        /// Notification posted when an `NSURLSessionTask` is resumed. The notification `object` contains the resumed
+        /// `NSURLSessionTask`.
+        public static let DidResume = "com.alamofire.notifications.task.didResume"
+
+        /// Notification posted when an `NSURLSessionTask` is suspended. The notification `object` contains the 
+        /// suspended `NSURLSessionTask`.
+        public static let DidSuspend = "com.alamofire.notifications.task.didSuspend"
+
+        /// Notification posted when an `NSURLSessionTask` is cancelled. The notification `object` contains the
+        /// cancelled `NSURLSessionTask`.
+        public static let DidCancel = "com.alamofire.notifications.task.didCancel"
+
+        /// Notification posted when an `NSURLSessionTask` is completed. The notification `object` contains the
+        /// completed `NSURLSessionTask`.
+        public static let DidComplete = "com.alamofire.notifications.task.didComplete"
+    }
+}
diff --git a/Pods/Alamofire/Source/ParameterEncoding.swift b/Pods/Alamofire/Source/ParameterEncoding.swift
new file mode 100644
index 0000000..32e63d9
--- /dev/null
+++ b/Pods/Alamofire/Source/ParameterEncoding.swift
@@ -0,0 +1,261 @@
+//
+//  ParameterEncoding.swift
+//
+//  Copyright (c) 2014-2016 Alamofire Software Foundation (http://alamofire.org/)
+//
+//  Permission is hereby granted, free of charge, to any person obtaining a copy
+//  of this software and associated documentation files (the "Software"), to deal
+//  in the Software without restriction, including without limitation the rights
+//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+//  copies of the Software, and to permit persons to whom the Software is
+//  furnished to do so, subject to the following conditions:
+//
+//  The above copyright notice and this permission notice shall be included in
+//  all copies or substantial portions of the Software.
+//
+//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+//  THE SOFTWARE.
+//
+
+import Foundation
+
+/**
+    HTTP method definitions.
+
+    See https://tools.ietf.org/html/rfc7231#section-4.3
+*/
+public enum Method: String {
+    case OPTIONS, GET, HEAD, POST, PUT, PATCH, DELETE, TRACE, CONNECT
+}
+
+// MARK: ParameterEncoding
+
+/**
+    Used to specify the way in which a set of parameters are applied to a URL request.
+
+    - `URL`:             Creates a query string to be set as or appended to any existing URL query for `GET`, `HEAD`, 
+                         and `DELETE` requests, or set as the body for requests with any other HTTP method. The 
+                         `Content-Type` HTTP header field of an encoded request with HTTP body is set to
+                         `application/x-www-form-urlencoded; charset=utf-8`. Since there is no published specification
+                         for how to encode collection types, the convention of appending `[]` to the key for array
+                         values (`foo[]=1&foo[]=2`), and appending the key surrounded by square brackets for nested
+                         dictionary values (`foo[bar]=baz`).
+
+    - `URLEncodedInURL`: Creates query string to be set as or appended to any existing URL query. Uses the same
+                         implementation as the `.URL` case, but always applies the encoded result to the URL.
+
+    - `JSON`:            Uses `NSJSONSerialization` to create a JSON representation of the parameters object, which is 
+                         set as the body of the request. The `Content-Type` HTTP header field of an encoded request is 
+                         set to `application/json`.
+
+    - `PropertyList`:    Uses `NSPropertyListSerialization` to create a plist representation of the parameters object,
+                         according to the associated format and write options values, which is set as the body of the
+                         request. The `Content-Type` HTTP header field of an encoded request is set to
+                         `application/x-plist`.
+
+    - `Custom`:          Uses the associated closure value to construct a new request given an existing request and
+                         parameters.
+*/
+public enum ParameterEncoding {
+    case URL
+    case URLEncodedInURL
+    case JSON
+    case PropertyList(NSPropertyListFormat, NSPropertyListWriteOptions)
+    case Custom((URLRequestConvertible, [String: AnyObject]?) -> (NSMutableURLRequest, NSError?))
+
+    /**
+        Creates a URL request by encoding parameters and applying them onto an existing request.
+
+        - parameter URLRequest: The request to have parameters applied.
+        - parameter parameters: The parameters to apply.
+
+        - returns: A tuple containing the constructed request and the error that occurred during parameter encoding, 
+                   if any.
+    */
+    public func encode(
+        URLRequest: URLRequestConvertible,
+        parameters: [String: AnyObject]?)
+        -> (NSMutableURLRequest, NSError?)
+    {
+        var mutableURLRequest = URLRequest.URLRequest
+
+        guard let parameters = parameters else { return (mutableURLRequest, nil) }
+
+        var encodingError: NSError? = nil
+
+        switch self {
+        case .URL, .URLEncodedInURL:
+            func query(parameters: [String: AnyObject]) -> String {
+                var components: [(String, String)] = []
+
+                for key in parameters.keys.sort(<) {
+                    let value = parameters[key]!
+                    components += queryComponents(key, value)
+                }
+
+                return (components.map { "\($0)=\($1)" } as [String]).joinWithSeparator("&")
+            }
+
+            func encodesParametersInURL(method: Method) -> Bool {
+                switch self {
+                case .URLEncodedInURL:
+                    return true
+                default:
+                    break
+                }
+
+                switch method {
+                case .GET, .HEAD, .DELETE:
+                    return true
+                default:
+                    return false
+                }
+            }
+
+            if let method = Method(rawValue: mutableURLRequest.HTTPMethod) where encodesParametersInURL(method) {
+                if let
+                    URLComponents = NSURLComponents(URL: mutableURLRequest.URL!, resolvingAgainstBaseURL: false)
+                    where !parameters.isEmpty
+                {
+                    let percentEncodedQuery = (URLComponents.percentEncodedQuery.map { $0 + "&" } ?? "") + query(parameters)
+                    URLComponents.percentEncodedQuery = percentEncodedQuery
+                    mutableURLRequest.URL = URLComponents.URL
+                }
+            } else {
+                if mutableURLRequest.valueForHTTPHeaderField("Content-Type") == nil {
+                    mutableURLRequest.setValue(
+                        "application/x-www-form-urlencoded; charset=utf-8",
+                        forHTTPHeaderField: "Content-Type"
+                    )
+                }
+
+                mutableURLRequest.HTTPBody = query(parameters).dataUsingEncoding(
+                    NSUTF8StringEncoding,
+                    allowLossyConversion: false
+                )
+            }
+        case .JSON:
+            do {
+                let options = NSJSONWritingOptions()
+                let data = try NSJSONSerialization.dataWithJSONObject(parameters, options: options)
+
+                if mutableURLRequest.valueForHTTPHeaderField("Content-Type") == nil {
+                    mutableURLRequest.setValue("application/json", forHTTPHeaderField: "Content-Type")
+                }
+
+                mutableURLRequest.HTTPBody = data
+            } catch {
+                encodingError = error as NSError
+            }
+        case .PropertyList(let format, let options):
+            do {
+                let data = try NSPropertyListSerialization.dataWithPropertyList(
+                    parameters,
+                    format: format,
+                    options: options
+                )
+
+                if mutableURLRequest.valueForHTTPHeaderField("Content-Type") == nil {
+                    mutableURLRequest.setValue("application/x-plist", forHTTPHeaderField: "Content-Type")
+                }
+
+                mutableURLRequest.HTTPBody = data
+            } catch {
+                encodingError = error as NSError
+            }
+        case .Custom(let closure):
+            (mutableURLRequest, encodingError) = closure(mutableURLRequest, parameters)
+        }
+
+        return (mutableURLRequest, encodingError)
+    }
+
+    /**
+        Creates percent-escaped, URL encoded query string components from the given key-value pair using recursion.
+
+        - parameter key:   The key of the query component.
+        - parameter value: The value of the query component.
+
+        - returns: The percent-escaped, URL encoded query string components.
+    */
+    public func queryComponents(key: String, _ value: AnyObject) -> [(String, String)] {
+        var components: [(String, String)] = []
+
+        if let dictionary = value as? [String: AnyObject] {
+            for (nestedKey, value) in dictionary {
+                components += queryComponents("\(key)[\(nestedKey)]", value)
+            }
+        } else if let array = value as? [AnyObject] {
+            for value in array {
+                components += queryComponents("\(key)[]", value)
+            }
+        } else {
+            components.append((escape(key), escape("\(value)")))
+        }
+
+        return components
+    }
+
+    /**
+        Returns a percent-escaped string following RFC 3986 for a query string key or value.
+
+        RFC 3986 states that the following characters are "reserved" characters.
+
+        - General Delimiters: ":", "#", "[", "]", "@", "?", "/"
+        - Sub-Delimiters: "!", "$", "&", "'", "(", ")", "*", "+", ",", ";", "="
+
+        In RFC 3986 - Section 3.4, it states that the "?" and "/" characters should not be escaped to allow
+        query strings to include a URL. Therefore, all "reserved" characters with the exception of "?" and "/"
+        should be percent-escaped in the query string.
+
+        - parameter string: The string to be percent-escaped.
+
+        - returns: The percent-escaped string.
+    */
+    public func escape(string: String) -> String {
+        let generalDelimitersToEncode = ":#[]@" // does not include "?" or "/" due to RFC 3986 - Section 3.4
+        let subDelimitersToEncode = "!$&'()*+,;="
+
+        let allowedCharacterSet = NSCharacterSet.URLQueryAllowedCharacterSet().mutableCopy() as! NSMutableCharacterSet
+        allowedCharacterSet.removeCharactersInString(generalDelimitersToEncode + subDelimitersToEncode)
+
+        var escaped = ""
+
+        //==========================================================================================================
+        //
+        //  Batching is required for escaping due to an internal bug in iOS 8.1 and 8.2. Encoding more than a few
+        //  hundred Chinese characters causes various malloc error crashes. To avoid this issue until iOS 8 is no
+        //  longer supported, batching MUST be used for encoding. This introduces roughly a 20% overhead. For more
+        //  info, please refer to:
+        //
+        //      - https://github.com/Alamofire/Alamofire/issues/206
+        //
+        //==========================================================================================================
+
+        if #available(iOS 8.3, OSX 10.10, *) {
+            escaped = string.stringByAddingPercentEncodingWithAllowedCharacters(allowedCharacterSet) ?? string
+        } else {
+            let batchSize = 50
+            var index = string.startIndex
+
+            while index != string.endIndex {
+                let startIndex = index
+                let endIndex = index.advancedBy(batchSize, limit: string.endIndex)
+                let range = startIndex..<endIndex
+
+                let substring = string.substringWithRange(range)
+
+                escaped += substring.stringByAddingPercentEncodingWithAllowedCharacters(allowedCharacterSet) ?? substring
+
+                index = endIndex
+            }
+        }
+
+        return escaped
+    }
+}
diff --git a/Pods/Alamofire/Source/Request.swift b/Pods/Alamofire/Source/Request.swift
new file mode 100644
index 0000000..817cca5
--- /dev/null
+++ b/Pods/Alamofire/Source/Request.swift
@@ -0,0 +1,568 @@
+//
+//  Request.swift
+//
+//  Copyright (c) 2014-2016 Alamofire Software Foundation (http://alamofire.org/)
+//
+//  Permission is hereby granted, free of charge, to any person obtaining a copy
+//  of this software and associated documentation files (the "Software"), to deal
+//  in the Software without restriction, including without limitation the rights
+//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+//  copies of the Software, and to permit persons to whom the Software is
+//  furnished to do so, subject to the following conditions:
+//
+//  The above copyright notice and this permission notice shall be included in
+//  all copies or substantial portions of the Software.
+//
+//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+//  THE SOFTWARE.
+//
+
+import Foundation
+
+/**
+    Responsible for sending a request and receiving the response and associated data from the server, as well as 
+    managing its underlying `NSURLSessionTask`.
+*/
+public class Request {
+
+    // MARK: - Properties
+
+    /// The delegate for the underlying task.
+    public let delegate: TaskDelegate
+
+    /// The underlying task.
+    public var task: NSURLSessionTask { return delegate.task }
+
+    /// The session belonging to the underlying task.
+    public let session: NSURLSession
+
+    /// The request sent or to be sent to the server.
+    public var request: NSURLRequest? { return task.originalRequest }
+
+    /// The response received from the server, if any.
+    public var response: NSHTTPURLResponse? { return task.response as? NSHTTPURLResponse }
+
+    /// The progress of the request lifecycle.
+    public var progress: NSProgress { return delegate.progress }
+
+    var startTime: CFAbsoluteTime?
+    var endTime: CFAbsoluteTime?
+
+    // MARK: - Lifecycle
+
+    init(session: NSURLSession, task: NSURLSessionTask) {
+        self.session = session
+
+        switch task {
+        case is NSURLSessionUploadTask:
+            delegate = UploadTaskDelegate(task: task)
+        case is NSURLSessionDataTask:
+            delegate = DataTaskDelegate(task: task)
+        case is NSURLSessionDownloadTask:
+            delegate = DownloadTaskDelegate(task: task)
+        default:
+            delegate = TaskDelegate(task: task)
+        }
+
+        delegate.queue.addOperationWithBlock { self.endTime = CFAbsoluteTimeGetCurrent() }
+    }
+
+    // MARK: - Authentication
+
+    /**
+        Associates an HTTP Basic credential with the request.
+
+        - parameter user:        The user.
+        - parameter password:    The password.
+        - parameter persistence: The URL credential persistence. `.ForSession` by default.
+
+        - returns: The request.
+    */
+    public func authenticate(
+        user user: String,
+        password: String,
+        persistence: NSURLCredentialPersistence = .ForSession)
+        -> Self
+    {
+        let credential = NSURLCredential(user: user, password: password, persistence: persistence)
+
+        return authenticate(usingCredential: credential)
+    }
+
+    /**
+        Associates a specified credential with the request.
+
+        - parameter credential: The credential.
+
+        - returns: The request.
+    */
+    public func authenticate(usingCredential credential: NSURLCredential) -> Self {
+        delegate.credential = credential
+
+        return self
+    }
+
+    /**
+        Returns a base64 encoded basic authentication credential as an authorization header dictionary.
+
+        - parameter user:     The user.
+        - parameter password: The password.
+
+        - returns: A dictionary with Authorization key and credential value or empty dictionary if encoding fails.
+    */
+    public static func authorizationHeader(user user: String, password: String) -> [String: String] {
+        guard let data = "\(user):\(password)".dataUsingEncoding(NSUTF8StringEncoding) else { return [:] }
+
+        let credential = data.base64EncodedStringWithOptions([])
+
+        return ["Authorization": "Basic \(credential)"]
+    }
+
+    // MARK: - Progress
+
+    /**
+        Sets a closure to be called periodically during the lifecycle of the request as data is written to or read 
+        from the server.
+
+        - For uploads, the progress closure returns the bytes written, total bytes written, and total bytes expected 
+          to write.
+        - For downloads and data tasks, the progress closure returns the bytes read, total bytes read, and total bytes 
+          expected to read.
+
+        - parameter closure: The code to be executed periodically during the lifecycle of the request.
+
+        - returns: The request.
+    */
+    public func progress(closure: ((Int64, Int64, Int64) -> Void)? = nil) -> Self {
+        if let uploadDelegate = delegate as? UploadTaskDelegate {
+            uploadDelegate.uploadProgress = closure
+        } else if let dataDelegate = delegate as? DataTaskDelegate {
+            dataDelegate.dataProgress = closure
+        } else if let downloadDelegate = delegate as? DownloadTaskDelegate {
+            downloadDelegate.downloadProgress = closure
+        }
+
+        return self
+    }
+
+    /**
+        Sets a closure to be called periodically during the lifecycle of the request as data is read from the server.
+
+        This closure returns the bytes most recently received from the server, not including data from previous calls. 
+        If this closure is set, data will only be available within this closure, and will not be saved elsewhere. It is 
+        also important to note that the `response` closure will be called with nil `responseData`.
+
+        - parameter closure: The code to be executed periodically during the lifecycle of the request.
+
+        - returns: The request.
+    */
+    public func stream(closure: (NSData -> Void)? = nil) -> Self {
+        if let dataDelegate = delegate as? DataTaskDelegate {
+            dataDelegate.dataStream = closure
+        }
+
+        return self
+    }
+
+    // MARK: - State
+
+    /**
+        Resumes the request.
+    */
+    public func resume() {
+        if startTime == nil { startTime = CFAbsoluteTimeGetCurrent() }
+
+        task.resume()
+        NSNotificationCenter.defaultCenter().postNotificationName(Notifications.Task.DidResume, object: task)
+    }
+
+    /**
+        Suspends the request.
+    */
+    public func suspend() {
+        task.suspend()
+        NSNotificationCenter.defaultCenter().postNotificationName(Notifications.Task.DidSuspend, object: task)
+    }
+
+    /**
+        Cancels the request.
+    */
+    public func cancel() {
+        if let
+            downloadDelegate = delegate as? DownloadTaskDelegate,
+            downloadTask = downloadDelegate.downloadTask
+        {
+            downloadTask.cancelByProducingResumeData { data in
+                downloadDelegate.resumeData = data
+            }
+        } else {
+            task.cancel()
+        }
+
+        NSNotificationCenter.defaultCenter().postNotificationName(Notifications.Task.DidCancel, object: task)
+    }
+
+    // MARK: - TaskDelegate
+
+    /**
+        The task delegate is responsible for handling all delegate callbacks for the underlying task as well as 
+        executing all operations attached to the serial operation queue upon task completion.
+    */
+    public class TaskDelegate: NSObject {
+
+        /// The serial operation queue used to execute all operations after the task completes.
+        public let queue: NSOperationQueue
+
+        let task: NSURLSessionTask
+        let progress: NSProgress
+
+        var data: NSData? { return nil }
+        var error: NSError?
+
+        var initialResponseTime: CFAbsoluteTime?
+        var credential: NSURLCredential?
+
+        init(task: NSURLSessionTask) {
+            self.task = task
+            self.progress = NSProgress(totalUnitCount: 0)
+            self.queue = {
+                let operationQueue = NSOperationQueue()
+                operationQueue.maxConcurrentOperationCount = 1
+                operationQueue.suspended = true
+
+                if #available(OSX 10.10, *) {
+                    operationQueue.qualityOfService = NSQualityOfService.Utility
+                }
+
+                return operationQueue
+            }()
+        }
+
+        deinit {
+            queue.cancelAllOperations()
+            queue.suspended = false
+        }
+
+        // MARK: - NSURLSessionTaskDelegate
+
+        // MARK: Override Closures
+
+        var taskWillPerformHTTPRedirection: ((NSURLSession, NSURLSessionTask, NSHTTPURLResponse, NSURLRequest) -> NSURLRequest?)?
+        var taskDidReceiveChallenge: ((NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge) -> (NSURLSessionAuthChallengeDisposition, NSURLCredential?))?
+        var taskNeedNewBodyStream: ((NSURLSession, NSURLSessionTask) -> NSInputStream?)?
+        var taskDidCompleteWithError: ((NSURLSession, NSURLSessionTask, NSError?) -> Void)?
+
+        // MARK: Delegate Methods
+
+        func URLSession(
+            session: NSURLSession,
+            task: NSURLSessionTask,
+            willPerformHTTPRedirection response: NSHTTPURLResponse,
+            newRequest request: NSURLRequest,
+            completionHandler: ((NSURLRequest?) -> Void))
+        {
+            var redirectRequest: NSURLRequest? = request
+
+            if let taskWillPerformHTTPRedirection = taskWillPerformHTTPRedirection {
+                redirectRequest = taskWillPerformHTTPRedirection(session, task, response, request)
+            }
+
+            completionHandler(redirectRequest)
+        }
+
+        func URLSession(
+            session: NSURLSession,
+            task: NSURLSessionTask,
+            didReceiveChallenge challenge: NSURLAuthenticationChallenge,
+            completionHandler: ((NSURLSessionAuthChallengeDisposition, NSURLCredential?) -> Void))
+        {
+            var disposition: NSURLSessionAuthChallengeDisposition = .PerformDefaultHandling
+            var credential: NSURLCredential?
+
+            if let taskDidReceiveChallenge = taskDidReceiveChallenge {
+                (disposition, credential) = taskDidReceiveChallenge(session, task, challenge)
+            } else if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
+                let host = challenge.protectionSpace.host
+
+                if let
+                    serverTrustPolicy = session.serverTrustPolicyManager?.serverTrustPolicyForHost(host),
+                    serverTrust = challenge.protectionSpace.serverTrust
+                {
+                    if serverTrustPolicy.evaluateServerTrust(serverTrust, isValidForHost: host) {
+                        disposition = .UseCredential
+                        credential = NSURLCredential(forTrust: serverTrust)
+                    } else {
+                        disposition = .CancelAuthenticationChallenge
+                    }
+                }
+            } else {
+                if challenge.previousFailureCount > 0 {
+                    disposition = .RejectProtectionSpace
+                } else {
+                    credential = self.credential ?? session.configuration.URLCredentialStorage?.defaultCredentialForProtectionSpace(challenge.protectionSpace)
+
+                    if credential != nil {
+                        disposition = .UseCredential
+                    }
+                }
+            }
+
+            completionHandler(disposition, credential)
+        }
+
+        func URLSession(
+            session: NSURLSession,
+            task: NSURLSessionTask,
+            needNewBodyStream completionHandler: ((NSInputStream?) -> Void))
+        {
+            var bodyStream: NSInputStream?
+
+            if let taskNeedNewBodyStream = taskNeedNewBodyStream {
+                bodyStream = taskNeedNewBodyStream(session, task)
+            }
+
+            completionHandler(bodyStream)
+        }
+
+        func URLSession(session: NSURLSession, task: NSURLSessionTask, didCompleteWithError error: NSError?) {
+            if let taskDidCompleteWithError = taskDidCompleteWithError {
+                taskDidCompleteWithError(session, task, error)
+            } else {
+                if let error = error {
+                    self.error = error
+
+                    if let
+                        downloadDelegate = self as? DownloadTaskDelegate,
+                        userInfo = error.userInfo as? [String: AnyObject],
+                        resumeData = userInfo[NSURLSessionDownloadTaskResumeData] as? NSData
+                    {
+                        downloadDelegate.resumeData = resumeData
+                    }
+                }
+
+                queue.suspended = false
+            }
+        }
+    }
+
+    // MARK: - DataTaskDelegate
+
+    class DataTaskDelegate: TaskDelegate, NSURLSessionDataDelegate {
+        var dataTask: NSURLSessionDataTask? { return task as? NSURLSessionDataTask }
+
+        private var totalBytesReceived: Int64 = 0
+        private var mutableData: NSMutableData
+        override var data: NSData? {
+            if dataStream != nil {
+                return nil
+            } else {
+                return mutableData
+            }
+        }
+
+        private var expectedContentLength: Int64?
+        private var dataProgress: ((bytesReceived: Int64, totalBytesReceived: Int64, totalBytesExpectedToReceive: Int64) -> Void)?
+        private var dataStream: ((data: NSData) -> Void)?
+
+        override init(task: NSURLSessionTask) {
+            mutableData = NSMutableData()
+            super.init(task: task)
+        }
+
+        // MARK: - NSURLSessionDataDelegate
+
+        // MARK: Override Closures
+
+        var dataTaskDidReceiveResponse: ((NSURLSession, NSURLSessionDataTask, NSURLResponse) -> NSURLSessionResponseDisposition)?
+        var dataTaskDidBecomeDownloadTask: ((NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask) -> Void)?
+        var dataTaskDidReceiveData: ((NSURLSession, NSURLSessionDataTask, NSData) -> Void)?
+        var dataTaskWillCacheResponse: ((NSURLSession, NSURLSessionDataTask, NSCachedURLResponse) -> NSCachedURLResponse?)?
+
+        // MARK: Delegate Methods
+
+        func URLSession(
+            session: NSURLSession,
+            dataTask: NSURLSessionDataTask,
+            didReceiveResponse response: NSURLResponse,
+            completionHandler: (NSURLSessionResponseDisposition -> Void))
+        {
+            var disposition: NSURLSessionResponseDisposition = .Allow
+
+            expectedContentLength = response.expectedContentLength
+
+            if let dataTaskDidReceiveResponse = dataTaskDidReceiveResponse {
+                disposition = dataTaskDidReceiveResponse(session, dataTask, response)
+            }
+
+            completionHandler(disposition)
+        }
+
+        func URLSession(
+            session: NSURLSession,
+            dataTask: NSURLSessionDataTask,
+            didBecomeDownloadTask downloadTask: NSURLSessionDownloadTask)
+        {
+            dataTaskDidBecomeDownloadTask?(session, dataTask, downloadTask)
+        }
+
+        func URLSession(session: NSURLSession, dataTask: NSURLSessionDataTask, didReceiveData data: NSData) {
+            if initialResponseTime == nil { initialResponseTime = CFAbsoluteTimeGetCurrent() }
+
+            if let dataTaskDidReceiveData = dataTaskDidReceiveData {
+                dataTaskDidReceiveData(session, dataTask, data)
+            } else {
+                if let dataStream = dataStream {
+                    dataStream(data: data)
+                } else {
+                    mutableData.appendData(data)
+                }
+
+                totalBytesReceived += data.length
+                let totalBytesExpected = dataTask.response?.expectedContentLength ?? NSURLSessionTransferSizeUnknown
+
+                progress.totalUnitCount = totalBytesExpected
+                progress.completedUnitCount = totalBytesReceived
+
+                dataProgress?(
+                    bytesReceived: Int64(data.length),
+                    totalBytesReceived: totalBytesReceived,
+                    totalBytesExpectedToReceive: totalBytesExpected
+                )
+            }
+        }
+
+        func URLSession(
+            session: NSURLSession,
+            dataTask: NSURLSessionDataTask,
+            willCacheResponse proposedResponse: NSCachedURLResponse,
+            completionHandler: ((NSCachedURLResponse?) -> Void))
+        {
+            var cachedResponse: NSCachedURLResponse? = proposedResponse
+
+            if let dataTaskWillCacheResponse = dataTaskWillCacheResponse {
+                cachedResponse = dataTaskWillCacheResponse(session, dataTask, proposedResponse)
+            }
+
+            completionHandler(cachedResponse)
+        }
+    }
+}
+
+// MARK: - CustomStringConvertible
+
+extension Request: CustomStringConvertible {
+
+    /**
+        The textual representation used when written to an output stream, which includes the HTTP method and URL, as 
+        well as the response status code if a response has been received.
+    */
+    public var description: String {
+        var components: [String] = []
+
+        if let HTTPMethod = request?.HTTPMethod {
+            components.append(HTTPMethod)
+        }
+
+        if let URLString = request?.URL?.absoluteString {
+            components.append(URLString)
+        }
+
+        if let response = response {
+            components.append("(\(response.statusCode))")
+        }
+
+        return components.joinWithSeparator(" ")
+    }
+}
+
+// MARK: - CustomDebugStringConvertible
+
+extension Request: CustomDebugStringConvertible {
+    func cURLRepresentation() -> String {
+        var components = ["$ curl -i"]
+
+        guard let
+            request = self.request,
+            URL = request.URL,
+            host = URL.host
+        else {
+            return "$ curl command could not be created"
+        }
+
+        if let HTTPMethod = request.HTTPMethod where HTTPMethod != "GET" {
+            components.append("-X \(HTTPMethod)")
+        }
+
+        if let credentialStorage = self.session.configuration.URLCredentialStorage {
+            let protectionSpace = NSURLProtectionSpace(
+                host: host,
+                port: URL.port?.integerValue ?? 0,
+                protocol: URL.scheme,
+                realm: host,
+                authenticationMethod: NSURLAuthenticationMethodHTTPBasic
+            )
+
+            if let credentials = credentialStorage.credentialsForProtectionSpace(protectionSpace)?.values {
+                for credential in credentials {
+                    components.append("-u \(credential.user!):\(credential.password!)")
+                }
+            } else {
+                if let credential = delegate.credential {
+                    components.append("-u \(credential.user!):\(credential.password!)")
+                }
+            }
+        }
+
+        if session.configuration.HTTPShouldSetCookies {
+            if let
+                cookieStorage = session.configuration.HTTPCookieStorage,
+                cookies = cookieStorage.cookiesForURL(URL) where !cookies.isEmpty
+            {
+                let string = cookies.reduce("") { $0 + "\($1.name)=\($1.value ?? String());" }
+                components.append("-b \"\(string.substringToIndex(string.endIndex.predecessor()))\"")
+            }
+        }
+
+        var headers: [NSObject: AnyObject] = [:]
+
+        if let additionalHeaders = session.configuration.HTTPAdditionalHeaders {
+            for (field, value) in additionalHeaders where field != "Cookie" {
+                headers[field] = value
+            }
+        }
+
+        if let headerFields = request.allHTTPHeaderFields {
+            for (field, value) in headerFields where field != "Cookie" {
+                headers[field] = value
+            }
+        }
+
+        for (field, value) in headers {
+            components.append("-H \"\(field): \(value)\"")
+        }
+
+        if let
+            HTTPBodyData = request.HTTPBody,
+            HTTPBody = String(data: HTTPBodyData, encoding: NSUTF8StringEncoding)
+        {
+            var escapedBody = HTTPBody.stringByReplacingOccurrencesOfString("\\\"", withString: "\\\\\"")
+            escapedBody = escapedBody.stringByReplacingOccurrencesOfString("\"", withString: "\\\"")
+
+            components.append("-d \"\(escapedBody)\"")
+        }
+
+        components.append("\"\(URL.absoluteString)\"")
+
+        return components.joinWithSeparator(" \\\n\t")
+    }
+
+    /// The textual representation used when written to an output stream, in the form of a cURL command.
+    public var debugDescription: String {
+        return cURLRepresentation()
+    }
+}
diff --git a/Pods/Alamofire/Source/Response.swift b/Pods/Alamofire/Source/Response.swift
new file mode 100644
index 0000000..dd700bb
--- /dev/null
+++ b/Pods/Alamofire/Source/Response.swift
@@ -0,0 +1,97 @@
+//
+//  Response.swift
+//
+//  Copyright (c) 2014-2016 Alamofire Software Foundation (http://alamofire.org/)
+//
+//  Permission is hereby granted, free of charge, to any person obtaining a copy
+//  of this software and associated documentation files (the "Software"), to deal
+//  in the Software without restriction, including without limitation the rights
+//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+//  copies of the Software, and to permit persons to whom the Software is
+//  furnished to do so, subject to the following conditions:
+//
+//  The above copyright notice and this permission notice shall be included in
+//  all copies or substantial portions of the Software.
+//
+//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+//  THE SOFTWARE.
+//
+
+import Foundation
+
+/// Used to store all response data returned from a completed `Request`.
+public struct Response<Value, Error: ErrorType> {
+    /// The URL request sent to the server.
+    public let request: NSURLRequest?
+
+    /// The server's response to the URL request.
+    public let response: NSHTTPURLResponse?
+
+    /// The data returned by the server.
+    public let data: NSData?
+
+    /// The result of response serialization.
+    public let result: Result<Value, Error>
+
+    /// The timeline of the complete lifecycle of the `Request`.
+    public let timeline: Timeline
+
+    /**
+        Initializes the `Response` instance with the specified URL request, URL response, server data and response
+        serialization result.
+    
+        - parameter request:  The URL request sent to the server.
+        - parameter response: The server's response to the URL request.
+        - parameter data:     The data returned by the server.
+        - parameter result:   The result of response serialization.
+        - parameter timeline: The timeline of the complete lifecycle of the `Request`. Defaults to `Timeline()`.
+
+        - returns: the new `Response` instance.
+    */
+    public init(
+        request: NSURLRequest?,
+        response: NSHTTPURLResponse?,
+        data: NSData?,
+        result: Result<Value, Error>,
+        timeline: Timeline = Timeline())
+    {
+        self.request = request
+        self.response = response
+        self.data = data
+        self.result = result
+        self.timeline = timeline
+    }
+}
+
+// MARK: - CustomStringConvertible
+
+extension Response: CustomStringConvertible {
+    /// The textual representation used when written to an output stream, which includes whether the result was a
+    /// success or failure.
+    public var description: String {
+        return result.debugDescription
+    }
+}
+
+// MARK: - CustomDebugStringConvertible
+
+extension Response: CustomDebugStringConvertible {
+    /// The debug textual representation used when written to an output stream, which includes the URL request, the URL
+    /// response, the server data and the response serialization result.
+    public var debugDescription: String {
+        var output: [String] = []
+
+        output.append(request != nil ? "[Request]: \(request!)" : "[Request]: nil")
+        output.append(response != nil ? "[Response]: \(response!)" : "[Response]: nil")
+        output.append("[Data]: \(data?.length ?? 0) bytes")
+        output.append("[Result]: \(result.debugDescription)")
+        output.append("[Timeline]: \(timeline.debugDescription)")
+
+        return output.joinWithSeparator("\n")
+    }
+}
diff --git a/Pods/Alamofire/Source/ResponseSerialization.swift b/Pods/Alamofire/Source/ResponseSerialization.swift
new file mode 100644
index 0000000..5b7b61f
--- /dev/null
+++ b/Pods/Alamofire/Source/ResponseSerialization.swift
@@ -0,0 +1,378 @@
+//
+//  ResponseSerialization.swift
+//
+//  Copyright (c) 2014-2016 Alamofire Software Foundation (http://alamofire.org/)
+//
+//  Permission is hereby granted, free of charge, to any person obtaining a copy
+//  of this software and associated documentation files (the "Software"), to deal
+//  in the Software without restriction, including without limitation the rights
+//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+//  copies of the Software, and to permit persons to whom the Software is
+//  furnished to do so, subject to the following conditions:
+//
+//  The above copyright notice and this permission notice shall be included in
+//  all copies or substantial portions of the Software.
+//
+//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+//  THE SOFTWARE.
+//
+
+import Foundation
+
+// MARK: ResponseSerializer
+
+/**
+    The type in which all response serializers must conform to in order to serialize a response.
+*/
+public protocol ResponseSerializerType {
+    /// The type of serialized object to be created by this `ResponseSerializerType`.
+    associatedtype SerializedObject
+
+    /// The type of error to be created by this `ResponseSerializer` if serialization fails.
+    associatedtype ErrorObject: ErrorType
+
+    /**
+        A closure used by response handlers that takes a request, response, data and error and returns a result.
+    */
+    var serializeResponse: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Result<SerializedObject, ErrorObject> { get }
+}
+
+// MARK: -
+
+/**
+    A generic `ResponseSerializerType` used to serialize a request, response, and data into a serialized object.
+*/
+public struct ResponseSerializer<Value, Error: ErrorType>: ResponseSerializerType {
+    /// The type of serialized object to be created by this `ResponseSerializer`.
+    public typealias SerializedObject = Value
+
+    /// The type of error to be created by this `ResponseSerializer` if serialization fails.
+    public typealias ErrorObject = Error
+
+    /**
+        A closure used by response handlers that takes a request, response, data and error and returns a result.
+    */
+    public var serializeResponse: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Result<Value, Error>
+
+    /**
+        Initializes the `ResponseSerializer` instance with the given serialize response closure.
+
+        - parameter serializeResponse: The closure used to serialize the response.
+
+        - returns: The new generic response serializer instance.
+    */
+    public init(serializeResponse: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Result<Value, Error>) {
+        self.serializeResponse = serializeResponse
+    }
+}
+
+// MARK: - Default
+
+extension Request {
+
+    /**
+        Adds a handler to be called once the request has finished.
+
+        - parameter queue:             The queue on which the completion handler is dispatched.
+        - parameter completionHandler: The code to be executed once the request has finished.
+
+        - returns: The request.
+    */
+    public func response(
+        queue queue: dispatch_queue_t? = nil,
+        completionHandler: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Void)
+        -> Self
+    {
+        delegate.queue.addOperationWithBlock {
+            dispatch_async(queue ?? dispatch_get_main_queue()) {
+                completionHandler(self.request, self.response, self.delegate.data, self.delegate.error)
+            }
+        }
+
+        return self
+    }
+
+    /**
+        Adds a handler to be called once the request has finished.
+
+        - parameter queue:              The queue on which the completion handler is dispatched.
+        - parameter responseSerializer: The response serializer responsible for serializing the request, response, 
+                                        and data.
+        - parameter completionHandler:  The code to be executed once the request has finished.
+
+        - returns: The request.
+    */
+    public func response<T: ResponseSerializerType>(
+        queue queue: dispatch_queue_t? = nil,
+        responseSerializer: T,
+        completionHandler: Response<T.SerializedObject, T.ErrorObject> -> Void)
+        -> Self
+    {
+        delegate.queue.addOperationWithBlock {
+            let result = responseSerializer.serializeResponse(
+                self.request,
+                self.response,
+                self.delegate.data,
+                self.delegate.error
+            )
+
+            let requestCompletedTime = self.endTime ?? CFAbsoluteTimeGetCurrent()
+            let initialResponseTime = self.delegate.initialResponseTime ?? requestCompletedTime
+
+            let timeline = Timeline(
+                requestStartTime: self.startTime ?? CFAbsoluteTimeGetCurrent(),
+                initialResponseTime: initialResponseTime,
+                requestCompletedTime: requestCompletedTime,
+                serializationCompletedTime: CFAbsoluteTimeGetCurrent()
+            )
+
+            let response = Response<T.SerializedObject, T.ErrorObject>(
+                request: self.request,
+                response: self.response,
+                data: self.delegate.data,
+                result: result,
+                timeline: timeline
+            )
+
+            dispatch_async(queue ?? dispatch_get_main_queue()) { completionHandler(response) }
+        }
+
+        return self
+    }
+}
+
+// MARK: - Data
+
+extension Request {
+
+    /**
+        Creates a response serializer that returns the associated data as-is.
+
+        - returns: A data response serializer.
+    */
+    public static func dataResponseSerializer() -> ResponseSerializer<NSData, NSError> {
+        return ResponseSerializer { _, response, data, error in
+            guard error == nil else { return .Failure(error!) }
+
+            if let response = response where response.statusCode == 204 { return .Success(NSData()) }
+
+            guard let validData = data else {
+                let failureReason = "Data could not be serialized. Input data was nil."
+                let error = Error.error(code: .DataSerializationFailed, failureReason: failureReason)
+                return .Failure(error)
+            }
+
+            return .Success(validData)
+        }
+    }
+
+    /**
+        Adds a handler to be called once the request has finished.
+
+        - parameter completionHandler: The code to be executed once the request has finished.
+
+        - returns: The request.
+    */
+    public func responseData(
+        queue queue: dispatch_queue_t? = nil,
+        completionHandler: Response<NSData, NSError> -> Void)
+        -> Self
+    {
+        return response(queue: queue, responseSerializer: Request.dataResponseSerializer(), completionHandler: completionHandler)
+    }
+}
+
+// MARK: - String
+
+extension Request {
+
+    /**
+        Creates a response serializer that returns a string initialized from the response data with the specified 
+        string encoding.
+
+        - parameter encoding: The string encoding. If `nil`, the string encoding will be determined from the server 
+                              response, falling back to the default HTTP default character set, ISO-8859-1.
+
+        - returns: A string response serializer.
+    */
+    public static func stringResponseSerializer(
+        encoding encoding: NSStringEncoding? = nil)
+        -> ResponseSerializer<String, NSError>
+    {
+        return ResponseSerializer { _, response, data, error in
+            guard error == nil else { return .Failure(error!) }
+
+            if let response = response where response.statusCode == 204 { return .Success("") }
+
+            guard let validData = data else {
+                let failureReason = "String could not be serialized. Input data was nil."
+                let error = Error.error(code: .StringSerializationFailed, failureReason: failureReason)
+                return .Failure(error)
+            }
+            
+            var convertedEncoding = encoding
+            
+            if let encodingName = response?.textEncodingName where convertedEncoding == nil {
+                convertedEncoding = CFStringConvertEncodingToNSStringEncoding(
+                    CFStringConvertIANACharSetNameToEncoding(encodingName)
+                )
+            }
+
+            let actualEncoding = convertedEncoding ?? NSISOLatin1StringEncoding
+
+            if let string = String(data: validData, encoding: actualEncoding) {
+                return .Success(string)
+            } else {
+                let failureReason = "String could not be serialized with encoding: \(actualEncoding)"
+                let error = Error.error(code: .StringSerializationFailed, failureReason: failureReason)
+                return .Failure(error)
+            }
+        }
+    }
+
+    /**
+        Adds a handler to be called once the request has finished.
+
+        - parameter encoding:          The string encoding. If `nil`, the string encoding will be determined from the 
+                                       server response, falling back to the default HTTP default character set, 
+                                       ISO-8859-1.
+        - parameter completionHandler: A closure to be executed once the request has finished.
+
+        - returns: The request.
+    */
+    public func responseString(
+        queue queue: dispatch_queue_t? = nil,
+        encoding: NSStringEncoding? = nil,
+        completionHandler: Response<String, NSError> -> Void)
+        -> Self
+    {
+        return response(
+            queue: queue,
+            responseSerializer: Request.stringResponseSerializer(encoding: encoding),
+            completionHandler: completionHandler
+        )
+    }
+}
+
+// MARK: - JSON
+
+extension Request {
+
+    /**
+        Creates a response serializer that returns a JSON object constructed from the response data using 
+        `NSJSONSerialization` with the specified reading options.
+
+        - parameter options: The JSON serialization reading options. `.AllowFragments` by default.
+
+        - returns: A JSON object response serializer.
+    */
+    public static func JSONResponseSerializer(
+        options options: NSJSONReadingOptions = .AllowFragments)
+        -> ResponseSerializer<AnyObject, NSError>
+    {
+        return ResponseSerializer { _, response, data, error in
+            guard error == nil else { return .Failure(error!) }
+
+            if let response = response where response.statusCode == 204 { return .Success(NSNull()) }
+
+            guard let validData = data where validData.length > 0 else {
+                let failureReason = "JSON could not be serialized. Input data was nil or zero length."
+                let error = Error.error(code: .JSONSerializationFailed, failureReason: failureReason)
+                return .Failure(error)
+            }
+
+            do {
+                let JSON = try NSJSONSerialization.JSONObjectWithData(validData, options: options)
+                return .Success(JSON)
+            } catch {
+                return .Failure(error as NSError)
+            }
+        }
+    }
+
+    /**
+        Adds a handler to be called once the request has finished.
+
+        - parameter options:           The JSON serialization reading options. `.AllowFragments` by default.
+        - parameter completionHandler: A closure to be executed once the request has finished.
+
+        - returns: The request.
+    */
+    public func responseJSON(
+        queue queue: dispatch_queue_t? = nil,
+        options: NSJSONReadingOptions = .AllowFragments,
+        completionHandler: Response<AnyObject, NSError> -> Void)
+        -> Self
+    {
+        return response(
+            queue: queue,
+            responseSerializer: Request.JSONResponseSerializer(options: options),
+            completionHandler: completionHandler
+        )
+    }
+}
+
+// MARK: - Property List
+
+extension Request {
+
+    /**
+        Creates a response serializer that returns an object constructed from the response data using 
+        `NSPropertyListSerialization` with the specified reading options.
+
+        - parameter options: The property list reading options. `NSPropertyListReadOptions()` by default.
+
+        - returns: A property list object response serializer.
+    */
+    public static func propertyListResponseSerializer(
+        options options: NSPropertyListReadOptions = NSPropertyListReadOptions())
+        -> ResponseSerializer<AnyObject, NSError>
+    {
+        return ResponseSerializer { _, response, data, error in
+            guard error == nil else { return .Failure(error!) }
+
+            if let response = response where response.statusCode == 204 { return .Success(NSNull()) }
+
+            guard let validData = data where validData.length > 0 else {
+                let failureReason = "Property list could not be serialized. Input data was nil or zero length."
+                let error = Error.error(code: .PropertyListSerializationFailed, failureReason: failureReason)
+                return .Failure(error)
+            }
+
+            do {
+                let plist = try NSPropertyListSerialization.propertyListWithData(validData, options: options, format: nil)
+                return .Success(plist)
+            } catch {
+                return .Failure(error as NSError)
+            }
+        }
+    }
+
+    /**
+        Adds a handler to be called once the request has finished.
+
+        - parameter options:           The property list reading options. `0` by default.
+        - parameter completionHandler: A closure to be executed once the request has finished. The closure takes 3
+                                       arguments: the URL request, the URL response, the server data and the result 
+                                       produced while creating the property list.
+
+        - returns: The request.
+    */
+    public func responsePropertyList(
+        queue queue: dispatch_queue_t? = nil,
+        options: NSPropertyListReadOptions = NSPropertyListReadOptions(),
+        completionHandler: Response<AnyObject, NSError> -> Void)
+        -> Self
+    {
+        return response(
+            queue: queue,
+            responseSerializer: Request.propertyListResponseSerializer(options: options),
+            completionHandler: completionHandler
+        )
+    }
+}
diff --git a/Pods/Alamofire/Source/Result.swift b/Pods/Alamofire/Source/Result.swift
new file mode 100644
index 0000000..ed1df0f
--- /dev/null
+++ b/Pods/Alamofire/Source/Result.swift
@@ -0,0 +1,103 @@
+//
+//  Result.swift
+//
+//  Copyright (c) 2014-2016 Alamofire Software Foundation (http://alamofire.org/)
+//
+//  Permission is hereby granted, free of charge, to any person obtaining a copy
+//  of this software and associated documentation files (the "Software"), to deal
+//  in the Software without restriction, including without limitation the rights
+//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+//  copies of the Software, and to permit persons to whom the Software is
+//  furnished to do so, subject to the following conditions:
+//
+//  The above copyright notice and this permission notice shall be included in
+//  all copies or substantial portions of the Software.
+//
+//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+//  THE SOFTWARE.
+//
+
+import Foundation
+
+/**
+    Used to represent whether a request was successful or encountered an error.
+
+    - Success: The request and all post processing operations were successful resulting in the serialization of the 
+               provided associated value.
+    - Failure: The request encountered an error resulting in a failure. The associated values are the original data 
+               provided by the server as well as the error that caused the failure.
+*/
+public enum Result<Value, Error: ErrorType> {
+    case Success(Value)
+    case Failure(Error)
+
+    /// Returns `true` if the result is a success, `false` otherwise.
+    public var isSuccess: Bool {
+        switch self {
+        case .Success:
+            return true
+        case .Failure:
+            return false
+        }
+    }
+
+    /// Returns `true` if the result is a failure, `false` otherwise.
+    public var isFailure: Bool {
+        return !isSuccess
+    }
+
+    /// Returns the associated value if the result is a success, `nil` otherwise.
+    public var value: Value? {
+        switch self {
+        case .Success(let value):
+            return value
+        case .Failure:
+            return nil
+        }
+    }
+
+    /// Returns the associated error value if the result is a failure, `nil` otherwise.
+    public var error: Error? {
+        switch self {
+        case .Success:
+            return nil
+        case .Failure(let error):
+            return error
+        }
+    }
+}
+
+// MARK: - CustomStringConvertible
+
+extension Result: CustomStringConvertible {
+    /// The textual representation used when written to an output stream, which includes whether the result was a 
+    /// success or failure.
+    public var description: String {
+        switch self {
+        case .Success:
+            return "SUCCESS"
+        case .Failure:
+            return "FAILURE"
+        }
+    }
+}
+
+// MARK: - CustomDebugStringConvertible
+
+extension Result: CustomDebugStringConvertible {
+    /// The debug textual representation used when written to an output stream, which includes whether the result was a
+    /// success or failure in addition to the value or error.
+    public var debugDescription: String {
+        switch self {
+        case .Success(let value):
+            return "SUCCESS: \(value)"
+        case .Failure(let error):
+            return "FAILURE: \(error)"
+        }
+    }
+}
diff --git a/Pods/Alamofire/Source/ServerTrustPolicy.swift b/Pods/Alamofire/Source/ServerTrustPolicy.swift
new file mode 100644
index 0000000..44ba100
--- /dev/null
+++ b/Pods/Alamofire/Source/ServerTrustPolicy.swift
@@ -0,0 +1,304 @@
+//
+//  ServerTrustPolicy.swift
+//
+//  Copyright (c) 2014-2016 Alamofire Software Foundation (http://alamofire.org/)
+//
+//  Permission is hereby granted, free of charge, to any person obtaining a copy
+//  of this software and associated documentation files (the "Software"), to deal
+//  in the Software without restriction, including without limitation the rights
+//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+//  copies of the Software, and to permit persons to whom the Software is
+//  furnished to do so, subject to the following conditions:
+//
+//  The above copyright notice and this permission notice shall be included in
+//  all copies or substantial portions of the Software.
+//
+//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+//  THE SOFTWARE.
+//
+
+import Foundation
+
+/// Responsible for managing the mapping of `ServerTrustPolicy` objects to a given host.
+public class ServerTrustPolicyManager {
+    /// The dictionary of policies mapped to a particular host.
+    public let policies: [String: ServerTrustPolicy]
+
+    /**
+        Initializes the `ServerTrustPolicyManager` instance with the given policies.
+
+        Since different servers and web services can have different leaf certificates, intermediate and even root 
+        certficates, it is important to have the flexibility to specify evaluation policies on a per host basis. This 
+        allows for scenarios such as using default evaluation for host1, certificate pinning for host2, public key 
+        pinning for host3 and disabling evaluation for host4.
+
+        - parameter policies: A dictionary of all policies mapped to a particular host.
+
+        - returns: The new `ServerTrustPolicyManager` instance.
+    */
+    public init(policies: [String: ServerTrustPolicy]) {
+        self.policies = policies
+    }
+
+    /**
+        Returns the `ServerTrustPolicy` for the given host if applicable.
+
+        By default, this method will return the policy that perfectly matches the given host. Subclasses could override
+        this method and implement more complex mapping implementations such as wildcards.
+
+        - parameter host: The host to use when searching for a matching policy.
+
+        - returns: The server trust policy for the given host if found.
+    */
+    public func serverTrustPolicyForHost(host: String) -> ServerTrustPolicy? {
+        return policies[host]
+    }
+}
+
+// MARK: -
+
+extension NSURLSession {
+    private struct AssociatedKeys {
+        static var ManagerKey = "NSURLSession.ServerTrustPolicyManager"
+    }
+
+    var serverTrustPolicyManager: ServerTrustPolicyManager? {
+        get {
+            return objc_getAssociatedObject(self, &AssociatedKeys.ManagerKey) as? ServerTrustPolicyManager
+        }
+        set (manager) {
+            objc_setAssociatedObject(self, &AssociatedKeys.ManagerKey, manager, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
+        }
+    }
+}
+
+// MARK: - ServerTrustPolicy
+
+/**
+    The `ServerTrustPolicy` evaluates the server trust generally provided by an `NSURLAuthenticationChallenge` when 
+    connecting to a server over a secure HTTPS connection. The policy configuration then evaluates the server trust 
+    with a given set of criteria to determine whether the server trust is valid and the connection should be made.
+
+    Using pinned certificates or public keys for evaluation helps prevent man-in-the-middle (MITM) attacks and other 
+    vulnerabilities. Applications dealing with sensitive customer data or financial information are strongly encouraged 
+    to route all communication over an HTTPS connection with pinning enabled.
+
+    - PerformDefaultEvaluation: Uses the default server trust evaluation while allowing you to control whether to 
+                                validate the host provided by the challenge. Applications are encouraged to always 
+                                validate the host in production environments to guarantee the validity of the server's 
+                                certificate chain.
+
+    - PinCertificates:          Uses the pinned certificates to validate the server trust. The server trust is
+                                considered valid if one of the pinned certificates match one of the server certificates. 
+                                By validating both the certificate chain and host, certificate pinning provides a very 
+                                secure form of server trust validation mitigating most, if not all, MITM attacks. 
+                                Applications are encouraged to always validate the host and require a valid certificate 
+                                chain in production environments.
+
+    - PinPublicKeys:            Uses the pinned public keys to validate the server trust. The server trust is considered
+                                valid if one of the pinned public keys match one of the server certificate public keys. 
+                                By validating both the certificate chain and host, public key pinning provides a very 
+                                secure form of server trust validation mitigating most, if not all, MITM attacks. 
+                                Applications are encouraged to always validate the host and require a valid certificate 
+                                chain in production environments.
+
+    - DisableEvaluation:        Disables all evaluation which in turn will always consider any server trust as valid.
+
+    - CustomEvaluation:         Uses the associated closure to evaluate the validity of the server trust.
+*/
+public enum ServerTrustPolicy {
+    case PerformDefaultEvaluation(validateHost: Bool)
+    case PinCertificates(certificates: [SecCertificate], validateCertificateChain: Bool, validateHost: Bool)
+    case PinPublicKeys(publicKeys: [SecKey], validateCertificateChain: Bool, validateHost: Bool)
+    case DisableEvaluation
+    case CustomEvaluation((serverTrust: SecTrust, host: String) -> Bool)
+
+    // MARK: - Bundle Location
+
+    /**
+        Returns all certificates within the given bundle with a `.cer` file extension.
+
+        - parameter bundle: The bundle to search for all `.cer` files.
+
+        - returns: All certificates within the given bundle.
+    */
+    public static func certificatesInBundle(bundle: NSBundle = NSBundle.mainBundle()) -> [SecCertificate] {
+        var certificates: [SecCertificate] = []
+
+        let paths = Set([".cer", ".CER", ".crt", ".CRT", ".der", ".DER"].map { fileExtension in
+            bundle.pathsForResourcesOfType(fileExtension, inDirectory: nil)
+        }.flatten())
+
+        for path in paths {
+            if let
+                certificateData = NSData(contentsOfFile: path),
+                certificate = SecCertificateCreateWithData(nil, certificateData)
+            {
+                certificates.append(certificate)
+            }
+        }
+
+        return certificates
+    }
+
+    /**
+        Returns all public keys within the given bundle with a `.cer` file extension.
+
+        - parameter bundle: The bundle to search for all `*.cer` files.
+
+        - returns: All public keys within the given bundle.
+    */
+    public static func publicKeysInBundle(bundle: NSBundle = NSBundle.mainBundle()) -> [SecKey] {
+        var publicKeys: [SecKey] = []
+
+        for certificate in certificatesInBundle(bundle) {
+            if let publicKey = publicKeyForCertificate(certificate) {
+                publicKeys.append(publicKey)
+            }
+        }
+
+        return publicKeys
+    }
+
+    // MARK: - Evaluation
+
+    /**
+        Evaluates whether the server trust is valid for the given host.
+
+        - parameter serverTrust: The server trust to evaluate.
+        - parameter host:        The host of the challenge protection space.
+
+        - returns: Whether the server trust is valid.
+    */
+    public func evaluateServerTrust(serverTrust: SecTrust, isValidForHost host: String) -> Bool {
+        var serverTrustIsValid = false
+
+        switch self {
+        case let .PerformDefaultEvaluation(validateHost):
+            let policy = SecPolicyCreateSSL(true, validateHost ? host as CFString : nil)
+            SecTrustSetPolicies(serverTrust, [policy])
+
+            serverTrustIsValid = trustIsValid(serverTrust)
+        case let .PinCertificates(pinnedCertificates, validateCertificateChain, validateHost):
+            if validateCertificateChain {
+                let policy = SecPolicyCreateSSL(true, validateHost ? host as CFString : nil)
+                SecTrustSetPolicies(serverTrust, [policy])
+
+                SecTrustSetAnchorCertificates(serverTrust, pinnedCertificates)
+                SecTrustSetAnchorCertificatesOnly(serverTrust, true)
+
+                serverTrustIsValid = trustIsValid(serverTrust)
+            } else {
+                let serverCertificatesDataArray = certificateDataForTrust(serverTrust)
+                let pinnedCertificatesDataArray = certificateDataForCertificates(pinnedCertificates)
+
+                outerLoop: for serverCertificateData in serverCertificatesDataArray {
+                    for pinnedCertificateData in pinnedCertificatesDataArray {
+                        if serverCertificateData.isEqualToData(pinnedCertificateData) {
+                            serverTrustIsValid = true
+                            break outerLoop
+                        }
+                    }
+                }
+            }
+        case let .PinPublicKeys(pinnedPublicKeys, validateCertificateChain, validateHost):
+            var certificateChainEvaluationPassed = true
+
+            if validateCertificateChain {
+                let policy = SecPolicyCreateSSL(true, validateHost ? host as CFString : nil)
+                SecTrustSetPolicies(serverTrust, [policy])
+
+                certificateChainEvaluationPassed = trustIsValid(serverTrust)
+            }
+
+            if certificateChainEvaluationPassed {
+                outerLoop: for serverPublicKey in ServerTrustPolicy.publicKeysForTrust(serverTrust) as [AnyObject] {
+                    for pinnedPublicKey in pinnedPublicKeys as [AnyObject] {
+                        if serverPublicKey.isEqual(pinnedPublicKey) {
+                            serverTrustIsValid = true
+                            break outerLoop
+                        }
+                    }
+                }
+            }
+        case .DisableEvaluation:
+            serverTrustIsValid = true
+        case let .CustomEvaluation(closure):
+            serverTrustIsValid = closure(serverTrust: serverTrust, host: host)
+        }
+
+        return serverTrustIsValid
+    }
+
+    // MARK: - Private - Trust Validation
+
+    private func trustIsValid(trust: SecTrust) -> Bool {
+        var isValid = false
+
+        var result = SecTrustResultType(kSecTrustResultInvalid)
+        let status = SecTrustEvaluate(trust, &result)
+
+        if status == errSecSuccess {
+            let unspecified = SecTrustResultType(kSecTrustResultUnspecified)
+            let proceed = SecTrustResultType(kSecTrustResultProceed)
+
+            isValid = result == unspecified || result == proceed
+        }
+
+        return isValid
+    }
+
+    // MARK: - Private - Certificate Data
+
+    private func certificateDataForTrust(trust: SecTrust) -> [NSData] {
+        var certificates: [SecCertificate] = []
+
+        for index in 0..<SecTrustGetCertificateCount(trust) {
+            if let certificate = SecTrustGetCertificateAtIndex(trust, index) {
+                certificates.append(certificate)
+            }
+        }
+
+        return certificateDataForCertificates(certificates)
+    }
+
+    private func certificateDataForCertificates(certificates: [SecCertificate]) -> [NSData] {
+        return certificates.map { SecCertificateCopyData($0) as NSData }
+    }
+
+    // MARK: - Private - Public Key Extraction
+
+    private static func publicKeysForTrust(trust: SecTrust) -> [SecKey] {
+        var publicKeys: [SecKey] = []
+
+        for index in 0..<SecTrustGetCertificateCount(trust) {
+            if let
+                certificate = SecTrustGetCertificateAtIndex(trust, index),
+                publicKey = publicKeyForCertificate(certificate)
+            {
+                publicKeys.append(publicKey)
+            }
+        }
+
+        return publicKeys
+    }
+
+    private static func publicKeyForCertificate(certificate: SecCertificate) -> SecKey? {
+        var publicKey: SecKey?
+
+        let policy = SecPolicyCreateBasicX509()
+        var trust: SecTrust?
+        let trustCreationStatus = SecTrustCreateWithCertificates(certificate, policy, &trust)
+
+        if let trust = trust where trustCreationStatus == errSecSuccess {
+            publicKey = SecTrustCopyPublicKey(trust)
+        }
+
+        return publicKey
+    }
+}
diff --git a/Pods/Alamofire/Source/Stream.swift b/Pods/Alamofire/Source/Stream.swift
new file mode 100644
index 0000000..07ebe33
--- /dev/null
+++ b/Pods/Alamofire/Source/Stream.swift
@@ -0,0 +1,182 @@
+//
+//  Stream.swift
+//
+//  Copyright (c) 2014-2016 Alamofire Software Foundation (http://alamofire.org/)
+//
+//  Permission is hereby granted, free of charge, to any person obtaining a copy
+//  of this software and associated documentation files (the "Software"), to deal
+//  in the Software without restriction, including without limitation the rights
+//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+//  copies of the Software, and to permit persons to whom the Software is
+//  furnished to do so, subject to the following conditions:
+//
+//  The above copyright notice and this permission notice shall be included in
+//  all copies or substantial portions of the Software.
+//
+//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+//  THE SOFTWARE.
+//
+
+import Foundation
+
+#if !os(watchOS)
+
+@available(iOS 9.0, OSX 10.11, tvOS 9.0, *)
+extension Manager {
+    private enum Streamable {
+        case Stream(String, Int)
+        case NetService(NSNetService)
+    }
+
+    private func stream(streamable: Streamable) -> Request {
+        var streamTask: NSURLSessionStreamTask!
+
+        switch streamable {
+        case .Stream(let hostName, let port):
+            dispatch_sync(queue) {
+                streamTask = self.session.streamTaskWithHostName(hostName, port: port)
+            }
+        case .NetService(let netService):
+            dispatch_sync(queue) {
+                streamTask = self.session.streamTaskWithNetService(netService)
+            }
+        }
+
+        let request = Request(session: session, task: streamTask)
+
+        delegate[request.delegate.task] = request.delegate
+
+        if startRequestsImmediately {
+            request.resume()
+        }
+
+        return request
+    }
+
+    /**
+        Creates a request for bidirectional streaming with the given hostname and port.
+
+        - parameter hostName: The hostname of the server to connect to.
+        - parameter port:     The port of the server to connect to.
+
+        :returns: The created stream request.
+    */
+    public func stream(hostName hostName: String, port: Int) -> Request {
+        return stream(.Stream(hostName, port))
+    }
+
+    /**
+        Creates a request for bidirectional streaming with the given `NSNetService`.
+
+        - parameter netService: The net service used to identify the endpoint.
+
+        - returns: The created stream request.
+    */
+    public func stream(netService netService: NSNetService) -> Request {
+        return stream(.NetService(netService))
+    }
+}
+
+// MARK: -
+
+@available(iOS 9.0, OSX 10.11, tvOS 9.0, *)
+extension Manager.SessionDelegate: NSURLSessionStreamDelegate {
+
+    // MARK: Override Closures
+
+    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:readClosedForStreamTask:`.
+    public var streamTaskReadClosed: ((NSURLSession, NSURLSessionStreamTask) -> Void)? {
+        get {
+            return _streamTaskReadClosed as? (NSURLSession, NSURLSessionStreamTask) -> Void
+        }
+        set {
+            _streamTaskReadClosed = newValue
+        }
+    }
+
+    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:writeClosedForStreamTask:`.
+    public var streamTaskWriteClosed: ((NSURLSession, NSURLSessionStreamTask) -> Void)? {
+        get {
+            return _streamTaskWriteClosed as? (NSURLSession, NSURLSessionStreamTask) -> Void
+        }
+        set {
+            _streamTaskWriteClosed = newValue
+        }
+    }
+
+    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:betterRouteDiscoveredForStreamTask:`.
+    public var streamTaskBetterRouteDiscovered: ((NSURLSession, NSURLSessionStreamTask) -> Void)? {
+        get {
+            return _streamTaskBetterRouteDiscovered as? (NSURLSession, NSURLSessionStreamTask) -> Void
+        }
+        set {
+            _streamTaskBetterRouteDiscovered = newValue
+        }
+    }
+
+    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:streamTask:didBecomeInputStream:outputStream:`.
+    public var streamTaskDidBecomeInputStream: ((NSURLSession, NSURLSessionStreamTask, NSInputStream, NSOutputStream) -> Void)? {
+        get {
+            return _streamTaskDidBecomeInputStream as? (NSURLSession, NSURLSessionStreamTask, NSInputStream, NSOutputStream) -> Void
+        }
+        set {
+            _streamTaskDidBecomeInputStream = newValue
+        }
+    }
+
+    // MARK: Delegate Methods
+
+    /**
+        Tells the delegate that the read side of the connection has been closed.
+
+        - parameter session:    The session.
+        - parameter streamTask: The stream task.
+    */
+    public func URLSession(session: NSURLSession, readClosedForStreamTask streamTask: NSURLSessionStreamTask) {
+        streamTaskReadClosed?(session, streamTask)
+    }
+
+    /**
+        Tells the delegate that the write side of the connection has been closed.
+
+        - parameter session:    The session.
+        - parameter streamTask: The stream task.
+    */
+    public func URLSession(session: NSURLSession, writeClosedForStreamTask streamTask: NSURLSessionStreamTask) {
+        streamTaskWriteClosed?(session, streamTask)
+    }
+
+    /**
+        Tells the delegate that the system has determined that a better route to the host is available.
+
+        - parameter session:    The session.
+        - parameter streamTask: The stream task.
+    */
+    public func URLSession(session: NSURLSession, betterRouteDiscoveredForStreamTask streamTask: NSURLSessionStreamTask) {
+        streamTaskBetterRouteDiscovered?(session, streamTask)
+    }
+
+    /**
+        Tells the delegate that the stream task has been completed and provides the unopened stream objects.
+
+        - parameter session:      The session.
+        - parameter streamTask:   The stream task.
+        - parameter inputStream:  The new input stream.
+        - parameter outputStream: The new output stream.
+    */
+    public func URLSession(
+        session: NSURLSession,
+        streamTask: NSURLSessionStreamTask,
+        didBecomeInputStream inputStream: NSInputStream,
+        outputStream: NSOutputStream)
+    {
+        streamTaskDidBecomeInputStream?(session, streamTask, inputStream, outputStream)
+    }
+}
+
+#endif
diff --git a/Pods/Alamofire/Source/Timeline.swift b/Pods/Alamofire/Source/Timeline.swift
new file mode 100644
index 0000000..9593682
--- /dev/null
+++ b/Pods/Alamofire/Source/Timeline.swift
@@ -0,0 +1,138 @@
+//
+//  Timeline.swift
+//
+//  Copyright (c) 2014-2016 Alamofire Software Foundation (http://alamofire.org/)
+//
+//  Permission is hereby granted, free of charge, to any person obtaining a copy
+//  of this software and associated documentation files (the "Software"), to deal
+//  in the Software without restriction, including without limitation the rights
+//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+//  copies of the Software, and to permit persons to whom the Software is
+//  furnished to do so, subject to the following conditions:
+//
+//  The above copyright notice and this permission notice shall be included in
+//  all copies or substantial portions of the Software.
+//
+//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+//  THE SOFTWARE.
+//
+
+import Foundation
+
+/// Responsible for computing the timing metrics for the complete lifecycle of a `Request`.
+public struct Timeline {
+    /// The time the request was initialized.
+    public let requestStartTime: CFAbsoluteTime
+
+    /// The time the first bytes were received from or sent to the server.
+    public let initialResponseTime: CFAbsoluteTime
+
+    /// The time when the request was completed.
+    public let requestCompletedTime: CFAbsoluteTime
+
+    /// The time when the response serialization was completed.
+    public let serializationCompletedTime: CFAbsoluteTime
+
+    /// The time interval in seconds from the time the request started to the initial response from the server.
+    public let latency: NSTimeInterval
+
+    /// The time interval in seconds from the time the request started to the time the request completed.
+    public let requestDuration: NSTimeInterval
+
+    /// The time interval in seconds from the time the request completed to the time response serialization completed.
+    public let serializationDuration: NSTimeInterval
+
+    /// The time interval in seconds from the time the request started to the time response serialization completed.
+    public let totalDuration: NSTimeInterval
+
+    /**
+        Creates a new `Timeline` instance with the specified request times.
+
+        - parameter requestStartTime:           The time the request was initialized. Defaults to `0.0`.
+        - parameter initialResponseTime:        The time the first bytes were received from or sent to the server. 
+                                                Defaults to `0.0`.
+        - parameter requestCompletedTime:       The time when the request was completed. Defaults to `0.0`.
+        - parameter serializationCompletedTime: The time when the response serialization was completed. Defaults 
+                                                to `0.0`.
+
+        - returns: The new `Timeline` instance.
+    */
+    public init(
+        requestStartTime: CFAbsoluteTime = 0.0,
+        initialResponseTime: CFAbsoluteTime = 0.0,
+        requestCompletedTime: CFAbsoluteTime = 0.0,
+        serializationCompletedTime: CFAbsoluteTime = 0.0)
+    {
+        self.requestStartTime = requestStartTime
+        self.initialResponseTime = initialResponseTime
+        self.requestCompletedTime = requestCompletedTime
+        self.serializationCompletedTime = serializationCompletedTime
+
+        self.latency = initialResponseTime - requestStartTime
+        self.requestDuration = requestCompletedTime - requestStartTime
+        self.serializationDuration = serializationCompletedTime - requestCompletedTime
+        self.totalDuration = serializationCompletedTime - requestStartTime
+    }
+}
+
+// MARK: - CustomStringConvertible
+
+extension Timeline: CustomStringConvertible {
+    /// The textual representation used when written to an output stream, which includes the latency, the request 
+    /// duration and the total duration.
+    public var description: String {
+        let latency = String(format: "%.3f", self.latency)
+        let requestDuration = String(format: "%.3f", self.requestDuration)
+        let serializationDuration = String(format: "%.3f", self.serializationDuration)
+        let totalDuration = String(format: "%.3f", self.totalDuration)
+
+        // NOTE: Had to move to string concatenation due to memory leak filed as rdar://26761490. Once memory leak is
+        // fixed, we should move back to string interpolation by reverting commit 7d4a43b1.
+        let timings = [
+            "\"Latency\": " + latency + " secs",
+            "\"Request Duration\": " + requestDuration + " secs",
+            "\"Serialization Duration\": " + serializationDuration + " secs",
+            "\"Total Duration\": " + totalDuration + " secs"
+        ]
+
+        return "Timeline: { " + timings.joinWithSeparator(", ") + " }"
+    }
+}
+
+// MARK: - CustomDebugStringConvertible
+
+extension Timeline: CustomDebugStringConvertible {
+    /// The textual representation used when written to an output stream, which includes the request start time, the 
+    /// initial response time, the request completed time, the serialization completed time, the latency, the request
+    /// duration and the total duration.
+    public var debugDescription: String {
+        let requestStartTime = String(format: "%.3f", self.requestStartTime)
+        let initialResponseTime = String(format: "%.3f", self.initialResponseTime)
+        let requestCompletedTime = String(format: "%.3f", self.requestCompletedTime)
+        let serializationCompletedTime = String(format: "%.3f", self.serializationCompletedTime)
+        let latency = String(format: "%.3f", self.latency)
+        let requestDuration = String(format: "%.3f", self.requestDuration)
+        let serializationDuration = String(format: "%.3f", self.serializationDuration)
+        let totalDuration = String(format: "%.3f", self.totalDuration)
+
+        // NOTE: Had to move to string concatenation due to memory leak filed as rdar://26761490. Once memory leak is
+        // fixed, we should move back to string interpolation by reverting commit 7d4a43b1.
+        let timings = [
+            "\"Request Start Time\": " + requestStartTime,
+            "\"Initial Response Time\": " + initialResponseTime,
+            "\"Request Completed Time\": " + requestCompletedTime,
+            "\"Serialization Completed Time\": " + serializationCompletedTime,
+            "\"Latency\": " + latency + " secs",
+            "\"Request Duration\": " + requestDuration + " secs",
+            "\"Serialization Duration\": " + serializationDuration + " secs",
+            "\"Total Duration\": " + totalDuration + " secs"
+        ]
+
+        return "Timeline: { " + timings.joinWithSeparator(", ") + " }"
+    }
+}
diff --git a/Pods/Alamofire/Source/Upload.swift b/Pods/Alamofire/Source/Upload.swift
new file mode 100644
index 0000000..7b31ba5
--- /dev/null
+++ b/Pods/Alamofire/Source/Upload.swift
@@ -0,0 +1,376 @@
+//
+//  Upload.swift
+//
+//  Copyright (c) 2014-2016 Alamofire Software Foundation (http://alamofire.org/)
+//
+//  Permission is hereby granted, free of charge, to any person obtaining a copy
+//  of this software and associated documentation files (the "Software"), to deal
+//  in the Software without restriction, including without limitation the rights
+//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+//  copies of the Software, and to permit persons to whom the Software is
+//  furnished to do so, subject to the following conditions:
+//
+//  The above copyright notice and this permission notice shall be included in
+//  all copies or substantial portions of the Software.
+//
+//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+//  THE SOFTWARE.
+//
+
+import Foundation
+
+extension Manager {
+    private enum Uploadable {
+        case Data(NSURLRequest, NSData)
+        case File(NSURLRequest, NSURL)
+        case Stream(NSURLRequest, NSInputStream)
+    }
+
+    private func upload(uploadable: Uploadable) -> Request {
+        var uploadTask: NSURLSessionUploadTask!
+        var HTTPBodyStream: NSInputStream?
+
+        switch uploadable {
+        case .Data(let request, let data):
+            dispatch_sync(queue) {
+                uploadTask = self.session.uploadTaskWithRequest(request, fromData: data)
+            }
+        case .File(let request, let fileURL):
+            dispatch_sync(queue) {
+                uploadTask = self.session.uploadTaskWithRequest(request, fromFile: fileURL)
+            }
+        case .Stream(let request, let stream):
+            dispatch_sync(queue) {
+                uploadTask = self.session.uploadTaskWithStreamedRequest(request)
+            }
+
+            HTTPBodyStream = stream
+        }
+
+        let request = Request(session: session, task: uploadTask)
+
+        if HTTPBodyStream != nil {
+            request.delegate.taskNeedNewBodyStream = { _, _ in
+                return HTTPBodyStream
+            }
+        }
+
+        delegate[request.delegate.task] = request.delegate
+
+        if startRequestsImmediately {
+            request.resume()
+        }
+
+        return request
+    }
+
+    // MARK: File
+
+    /**
+        Creates a request for uploading a file to the specified URL request.
+
+        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
+
+        - parameter URLRequest: The URL request
+        - parameter file:       The file to upload
+
+        - returns: The created upload request.
+    */
+    public func upload(URLRequest: URLRequestConvertible, file: NSURL) -> Request {
+        return upload(.File(URLRequest.URLRequest, file))
+    }
+
+    /**
+        Creates a request for uploading a file to the specified URL request.
+
+        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
+
+        - parameter method:    The HTTP method.
+        - parameter URLString: The URL string.
+        - parameter headers:   The HTTP headers. `nil` by default.
+        - parameter file:      The file to upload
+
+        - returns: The created upload request.
+    */
+    public func upload(
+        method: Method,
+        _ URLString: URLStringConvertible,
+        headers: [String: String]? = nil,
+        file: NSURL)
+        -> Request
+    {
+        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
+        return upload(mutableURLRequest, file: file)
+    }
+
+    // MARK: Data
+
+    /**
+        Creates a request for uploading data to the specified URL request.
+
+        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
+
+        - parameter URLRequest: The URL request.
+        - parameter data:       The data to upload.
+
+        - returns: The created upload request.
+    */
+    public func upload(URLRequest: URLRequestConvertible, data: NSData) -> Request {
+        return upload(.Data(URLRequest.URLRequest, data))
+    }
+
+    /**
+        Creates a request for uploading data to the specified URL request.
+
+        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
+
+        - parameter method:    The HTTP method.
+        - parameter URLString: The URL string.
+        - parameter headers:   The HTTP headers. `nil` by default.
+        - parameter data:      The data to upload
+
+        - returns: The created upload request.
+    */
+    public func upload(
+        method: Method,
+        _ URLString: URLStringConvertible,
+        headers: [String: String]? = nil,
+        data: NSData)
+        -> Request
+    {
+        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
+
+        return upload(mutableURLRequest, data: data)
+    }
+
+    // MARK: Stream
+
+    /**
+        Creates a request for uploading a stream to the specified URL request.
+
+        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
+
+        - parameter URLRequest: The URL request.
+        - parameter stream:     The stream to upload.
+
+        - returns: The created upload request.
+    */
+    public func upload(URLRequest: URLRequestConvertible, stream: NSInputStream) -> Request {
+        return upload(.Stream(URLRequest.URLRequest, stream))
+    }
+
+    /**
+        Creates a request for uploading a stream to the specified URL request.
+
+        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
+
+        - parameter method:    The HTTP method.
+        - parameter URLString: The URL string.
+        - parameter headers:   The HTTP headers. `nil` by default.
+        - parameter stream:    The stream to upload.
+
+        - returns: The created upload request.
+    */
+    public func upload(
+        method: Method,
+        _ URLString: URLStringConvertible,
+        headers: [String: String]? = nil,
+        stream: NSInputStream)
+        -> Request
+    {
+        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
+
+        return upload(mutableURLRequest, stream: stream)
+    }
+
+    // MARK: MultipartFormData
+
+    /// Default memory threshold used when encoding `MultipartFormData`.
+    public static let MultipartFormDataEncodingMemoryThreshold: UInt64 = 10 * 1024 * 1024
+
+    /**
+        Defines whether the `MultipartFormData` encoding was successful and contains result of the encoding as 
+        associated values.
+
+        - Success: Represents a successful `MultipartFormData` encoding and contains the new `Request` along with 
+                   streaming information.
+        - Failure: Used to represent a failure in the `MultipartFormData` encoding and also contains the encoding 
+                   error.
+    */
+    public enum MultipartFormDataEncodingResult {
+        case Success(request: Request, streamingFromDisk: Bool, streamFileURL: NSURL?)
+        case Failure(ErrorType)
+    }
+
+    /**
+        Encodes the `MultipartFormData` and creates a request to upload the result to the specified URL request.
+
+        It is important to understand the memory implications of uploading `MultipartFormData`. If the cummulative 
+        payload is small, encoding the data in-memory and directly uploading to a server is the by far the most 
+        efficient approach. However, if the payload is too large, encoding the data in-memory could cause your app to 
+        be terminated. Larger payloads must first be written to disk using input and output streams to keep the memory 
+        footprint low, then the data can be uploaded as a stream from the resulting file. Streaming from disk MUST be 
+        used for larger payloads such as video content.
+
+        The `encodingMemoryThreshold` parameter allows Alamofire to automatically determine whether to encode in-memory 
+        or stream from disk. If the content length of the `MultipartFormData` is below the `encodingMemoryThreshold`,
+        encoding takes place in-memory. If the content length exceeds the threshold, the data is streamed to disk 
+        during the encoding process. Then the result is uploaded as data or as a stream depending on which encoding 
+        technique was used.
+
+        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
+
+        - parameter method:                  The HTTP method.
+        - parameter URLString:               The URL string.
+        - parameter headers:                 The HTTP headers. `nil` by default.
+        - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
+        - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
+                                             `MultipartFormDataEncodingMemoryThreshold` by default.
+        - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
+    */
+    public func upload(
+        method: Method,
+        _ URLString: URLStringConvertible,
+        headers: [String: String]? = nil,
+        multipartFormData: MultipartFormData -> Void,
+        encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
+        encodingCompletion: (MultipartFormDataEncodingResult -> Void)?)
+    {
+        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
+
+        return upload(
+            mutableURLRequest,
+            multipartFormData: multipartFormData,
+            encodingMemoryThreshold: encodingMemoryThreshold,
+            encodingCompletion: encodingCompletion
+        )
+    }
+
+    /**
+        Encodes the `MultipartFormData` and creates a request to upload the result to the specified URL request.
+
+        It is important to understand the memory implications of uploading `MultipartFormData`. If the cummulative
+        payload is small, encoding the data in-memory and directly uploading to a server is the by far the most
+        efficient approach. However, if the payload is too large, encoding the data in-memory could cause your app to
+        be terminated. Larger payloads must first be written to disk using input and output streams to keep the memory
+        footprint low, then the data can be uploaded as a stream from the resulting file. Streaming from disk MUST be
+        used for larger payloads such as video content.
+
+        The `encodingMemoryThreshold` parameter allows Alamofire to automatically determine whether to encode in-memory
+        or stream from disk. If the content length of the `MultipartFormData` is below the `encodingMemoryThreshold`,
+        encoding takes place in-memory. If the content length exceeds the threshold, the data is streamed to disk
+        during the encoding process. Then the result is uploaded as data or as a stream depending on which encoding
+        technique was used.
+
+        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
+
+        - parameter URLRequest:              The URL request.
+        - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
+        - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
+                                             `MultipartFormDataEncodingMemoryThreshold` by default.
+        - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
+    */
+    public func upload(
+        URLRequest: URLRequestConvertible,
+        multipartFormData: MultipartFormData -> Void,
+        encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
+        encodingCompletion: (MultipartFormDataEncodingResult -> Void)?)
+    {
+        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)) {
+            let formData = MultipartFormData()
+            multipartFormData(formData)
+
+            let URLRequestWithContentType = URLRequest.URLRequest
+            URLRequestWithContentType.setValue(formData.contentType, forHTTPHeaderField: "Content-Type")
+
+            let isBackgroundSession = self.session.configuration.identifier != nil
+
+            if formData.contentLength < encodingMemoryThreshold && !isBackgroundSession {
+                do {
+                    let data = try formData.encode()
+                    let encodingResult = MultipartFormDataEncodingResult.Success(
+                        request: self.upload(URLRequestWithContentType, data: data),
+                        streamingFromDisk: false,
+                        streamFileURL: nil
+                    )
+
+                    dispatch_async(dispatch_get_main_queue()) {
+                        encodingCompletion?(encodingResult)
+                    }
+                } catch {
+                    dispatch_async(dispatch_get_main_queue()) {
+                        encodingCompletion?(.Failure(error as NSError))
+                    }
+                }
+            } else {
+                let fileManager = NSFileManager.defaultManager()
+                let tempDirectoryURL = NSURL(fileURLWithPath: NSTemporaryDirectory())
+                let directoryURL = tempDirectoryURL.URLByAppendingPathComponent("com.alamofire.manager/multipart.form.data")
+                let fileName = NSUUID().UUIDString
+                let fileURL = directoryURL.URLByAppendingPathComponent(fileName)
+
+                do {
+                    try fileManager.createDirectoryAtURL(directoryURL, withIntermediateDirectories: true, attributes: nil)
+                    try formData.writeEncodedDataToDisk(fileURL)
+
+                    dispatch_async(dispatch_get_main_queue()) {
+                        let encodingResult = MultipartFormDataEncodingResult.Success(
+                            request: self.upload(URLRequestWithContentType, file: fileURL),
+                            streamingFromDisk: true,
+                            streamFileURL: fileURL
+                        )
+                        encodingCompletion?(encodingResult)
+                    }
+                } catch {
+                    dispatch_async(dispatch_get_main_queue()) {
+                        encodingCompletion?(.Failure(error as NSError))
+                    }
+                }
+            }
+        }
+    }
+}
+
+// MARK: -
+
+extension Request {
+
+    // MARK: - UploadTaskDelegate
+
+    class UploadTaskDelegate: DataTaskDelegate {
+        var uploadTask: NSURLSessionUploadTask? { return task as? NSURLSessionUploadTask }
+        var uploadProgress: ((Int64, Int64, Int64) -> Void)!
+
+        // MARK: - NSURLSessionTaskDelegate
+
+        // MARK: Override Closures
+
+        var taskDidSendBodyData: ((NSURLSession, NSURLSessionTask, Int64, Int64, Int64) -> Void)?
+
+        // MARK: Delegate Methods
+
+        func URLSession(
+            session: NSURLSession,
+            task: NSURLSessionTask,
+            didSendBodyData bytesSent: Int64,
+            totalBytesSent: Int64,
+            totalBytesExpectedToSend: Int64)
+        {
+            if initialResponseTime == nil { initialResponseTime = CFAbsoluteTimeGetCurrent() }
+
+            if let taskDidSendBodyData = taskDidSendBodyData {
+                taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalBytesExpectedToSend)
+            } else {
+                progress.totalUnitCount = totalBytesExpectedToSend
+                progress.completedUnitCount = totalBytesSent
+
+                uploadProgress?(bytesSent, totalBytesSent, totalBytesExpectedToSend)
+            }
+        }
+    }
+}
diff --git a/Pods/Alamofire/Source/Validation.swift b/Pods/Alamofire/Source/Validation.swift
new file mode 100644
index 0000000..e90db2d
--- /dev/null
+++ b/Pods/Alamofire/Source/Validation.swift
@@ -0,0 +1,214 @@
+//
+//  Validation.swift
+//
+//  Copyright (c) 2014-2016 Alamofire Software Foundation (http://alamofire.org/)
+//
+//  Permission is hereby granted, free of charge, to any person obtaining a copy
+//  of this software and associated documentation files (the "Software"), to deal
+//  in the Software without restriction, including without limitation the rights
+//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+//  copies of the Software, and to permit persons to whom the Software is
+//  furnished to do so, subject to the following conditions:
+//
+//  The above copyright notice and this permission notice shall be included in
+//  all copies or substantial portions of the Software.
+//
+//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+//  THE SOFTWARE.
+//
+
+import Foundation
+
+extension Request {
+
+    /**
+        Used to represent whether validation was successful or encountered an error resulting in a failure.
+
+        - Success: The validation was successful.
+        - Failure: The validation failed encountering the provided error.
+    */
+    public enum ValidationResult {
+        case Success
+        case Failure(NSError)
+    }
+
+    /**
+        A closure used to validate a request that takes a URL request and URL response, and returns whether the 
+        request was valid.
+    */
+    public typealias Validation = (NSURLRequest?, NSHTTPURLResponse) -> ValidationResult
+
+    /**
+        Validates the request, using the specified closure.
+
+        If validation fails, subsequent calls to response handlers will have an associated error.
+
+        - parameter validation: A closure to validate the request.
+
+        - returns: The request.
+    */
+    public func validate(validation: Validation) -> Self {
+        delegate.queue.addOperationWithBlock {
+            if let
+                response = self.response where self.delegate.error == nil,
+                case let .Failure(error) = validation(self.request, response)
+            {
+                self.delegate.error = error
+            }
+        }
+
+        return self
+    }
+
+    // MARK: - Status Code
+
+    /**
+        Validates that the response has a status code in the specified range.
+
+        If validation fails, subsequent calls to response handlers will have an associated error.
+
+        - parameter range: The range of acceptable status codes.
+
+        - returns: The request.
+    */
+    public func validate<S: SequenceType where S.Generator.Element == Int>(statusCode acceptableStatusCode: S) -> Self {
+        return validate { _, response in
+            if acceptableStatusCode.contains(response.statusCode) {
+                return .Success
+            } else {
+                let failureReason = "Response status code was unacceptable: \(response.statusCode)"
+
+                let error = NSError(
+                    domain: Error.Domain,
+                    code: Error.Code.StatusCodeValidationFailed.rawValue,
+                    userInfo: [
+                        NSLocalizedFailureReasonErrorKey: failureReason,
+                        Error.UserInfoKeys.StatusCode: response.statusCode
+                    ]
+                )
+
+                return .Failure(error)
+            }
+        }
+    }
+
+    // MARK: - Content-Type
+
+    private struct MIMEType {
+        let type: String
+        let subtype: String
+
+        init?(_ string: String) {
+            let components: [String] = {
+                let stripped = string.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet())
+                let split = stripped.substringToIndex(stripped.rangeOfString(";")?.startIndex ?? stripped.endIndex)
+                return split.componentsSeparatedByString("/")
+            }()
+
+            if let
+                type = components.first,
+                subtype = components.last
+            {
+                self.type = type
+                self.subtype = subtype
+            } else {
+                return nil
+            }
+        }
+
+        func matches(MIME: MIMEType) -> Bool {
+            switch (type, subtype) {
+            case (MIME.type, MIME.subtype), (MIME.type, "*"), ("*", MIME.subtype), ("*", "*"):
+                return true
+            default:
+                return false
+            }
+        }
+    }
+
+    /**
+        Validates that the response has a content type in the specified array.
+
+        If validation fails, subsequent calls to response handlers will have an associated error.
+
+        - parameter contentType: The acceptable content types, which may specify wildcard types and/or subtypes.
+
+        - returns: The request.
+    */
+    public func validate<S : SequenceType where S.Generator.Element == String>(contentType acceptableContentTypes: S) -> Self {
+        return validate { _, response in
+            guard let validData = self.delegate.data where validData.length > 0 else { return .Success }
+
+            if let
+                responseContentType = response.MIMEType,
+                responseMIMEType = MIMEType(responseContentType)
+            {
+                for contentType in acceptableContentTypes {
+                    if let acceptableMIMEType = MIMEType(contentType) where acceptableMIMEType.matches(responseMIMEType) {
+                        return .Success
+                    }
+                }
+            } else {
+                for contentType in acceptableContentTypes {
+                    if let MIMEType = MIMEType(contentType) where MIMEType.type == "*" && MIMEType.subtype == "*" {
+                        return .Success
+                    }
+                }
+            }
+
+            let contentType: String
+            let failureReason: String
+
+            if let responseContentType = response.MIMEType {
+                contentType = responseContentType
+
+                failureReason = (
+                    "Response content type \"\(responseContentType)\" does not match any acceptable " +
+                    "content types: \(acceptableContentTypes)"
+                )
+            } else {
+                contentType = ""
+                failureReason = "Response content type was missing and acceptable content type does not match \"*/*\""
+            }
+
+            let error = NSError(
+                domain: Error.Domain,
+                code: Error.Code.ContentTypeValidationFailed.rawValue,
+                userInfo: [
+                    NSLocalizedFailureReasonErrorKey: failureReason,
+                    Error.UserInfoKeys.ContentType: contentType
+                ]
+            )
+
+            return .Failure(error)
+        }
+    }
+
+    // MARK: - Automatic
+
+    /**
+        Validates that the response has a status code in the default acceptable range of 200...299, and that the content 
+        type matches any specified in the Accept HTTP header field.
+
+        If validation fails, subsequent calls to response handlers will have an associated error.
+
+        - returns: The request.
+    */
+    public func validate() -> Self {
+        let acceptableStatusCodes: Range<Int> = 200..<300
+        let acceptableContentTypes: [String] = {
+            if let accept = request?.valueForHTTPHeaderField("Accept") {
+                return accept.componentsSeparatedByString(",")
+            }
+
+            return ["*/*"]
+        }()
+
+        return validate(statusCode: acceptableStatusCodes).validate(contentType: acceptableContentTypes)
+    }
+}
diff --git a/Pods/Manifest.lock b/Pods/Manifest.lock
index 4be331a..0ae9987 100644
--- a/Pods/Manifest.lock
+++ b/Pods/Manifest.lock
@@ -1,14 +1,20 @@
 PODS:
+  - Alamofire (3.4.1)
   - CocoaAsyncSocket (7.5.0):
     - CocoaAsyncSocket/GCD (= 7.5.0)
   - CocoaAsyncSocket/GCD (7.5.0)
+  - SWXMLHash (2.4.0)
 
 DEPENDENCIES:
+  - Alamofire
   - CocoaAsyncSocket
+  - SWXMLHash
 
 SPEC CHECKSUMS:
+  Alamofire: 01a82e2f6c0f860ade35534c8dd88be61bdef40c
   CocoaAsyncSocket: 3baeb1ddd969f81cf9fca81053ae49ef2d1cbbfa
+  SWXMLHash: 507397103325f140863d09040c04ae14a49a16cb
 
-PODFILE CHECKSUM: e6332a1e2227a6d3ff82fcc374286642be589891
+PODFILE CHECKSUM: 3d088204bac8fcec64bd2420b15ef2f3c7764d77
 
 COCOAPODS: 1.0.0
diff --git a/Pods/Pods.xcodeproj/project.pbxproj b/Pods/Pods.xcodeproj/project.pbxproj
index dc930dc..a791ba2 100644
--- a/Pods/Pods.xcodeproj/project.pbxproj
+++ b/Pods/Pods.xcodeproj/project.pbxproj
@@ -7,65 +7,153 @@
 	objects = {
 
 /* Begin PBXBuildFile section */
-		3A3F65A9CFEBD04E71A6E05108F795D0 /* Cocoa.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 7C56649C408E00F4469558EBC9AF1BA3 /* Cocoa.framework */; };
+		095406039B4D371E48D08B38A2975AC8 /* Error.swift in Sources */ = {isa = PBXBuildFile; fileRef = EF9B2AFCE03477C50F07C48E33A463FF /* Error.swift */; };
+		16102E4E35FAA0FC4161282FECE56469 /* Timeline.swift in Sources */ = {isa = PBXBuildFile; fileRef = D77E19C3839748928122D0DEAC1BA1F4 /* Timeline.swift */; };
+		1E5602BF3A87A7353DA77A2EE51EED93 /* SWXMLHash-umbrella.h in Headers */ = {isa = PBXBuildFile; fileRef = 5F0B453266F2DE0B098E2B994FE716CD /* SWXMLHash-umbrella.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		2D3405986FC586FA6C0A5E0B6BA7E64E /* Validation.swift in Sources */ = {isa = PBXBuildFile; fileRef = 84395B1E623BD8F9DE2F7E16CA43251F /* Validation.swift */; };
+		34CCDCA848A701466256BC2927DA8856 /* NetworkReachabilityManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 64E8485F5FCFC4FDB8D6CE0BFC980C58 /* NetworkReachabilityManager.swift */; };
+		3EA8F215C9C1432D74E5CCA4834AA8C0 /* ResponseSerialization.swift in Sources */ = {isa = PBXBuildFile; fileRef = B7C925E8849659F01450961BB1FFA23D /* ResponseSerialization.swift */; };
+		4081EA628AF0B73AC51FFB9D7AB3B89E /* Manager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 7031D4000017108DC80504B065340368 /* Manager.swift */; };
+		515FD66E0570F0E6B6D6F6B4AE427CC2 /* Pods-CRMCall092016-dummy.m in Sources */ = {isa = PBXBuildFile; fileRef = 2AE57F75653AE6E263CFF4332F052094 /* Pods-CRMCall092016-dummy.m */; };
 		551864BF98FF39945A2F33B4C0B97A06 /* Cocoa.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 7C56649C408E00F4469558EBC9AF1BA3 /* Cocoa.framework */; };
 		58CE33E7875BEC7B12D551A398FB9A97 /* Security.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = E35F27DD11D07BB27A6C8CE52CD34061 /* Security.framework */; };
-		6AAFA2F344A6B58F728AF958F3FE6D89 /* GCDAsyncSocket.h in Headers */ = {isa = PBXBuildFile; fileRef = 4CA8FFB2F306345702A20E3FE7CE6EF7 /* GCDAsyncSocket.h */; settings = {ATTRIBUTES = (Public, ); }; };
-		92AED971B91C640191A5ABA1567FE358 /* GCDAsyncUdpSocket.h in Headers */ = {isa = PBXBuildFile; fileRef = 84A110336E93C3E786F9B32956E29A3E /* GCDAsyncUdpSocket.h */; settings = {ATTRIBUTES = (Public, ); }; };
-		991BFD139F6A45C9B654960C2F6A7F09 /* GCDAsyncSocket.m in Sources */ = {isa = PBXBuildFile; fileRef = 1D696A8CDEBE87CDE80E57AE0E305C5F /* GCDAsyncSocket.m */; settings = {COMPILER_FLAGS = "-DOS_OBJECT_USE_OBJC=0"; }; };
-		AC9CFE1768573A23FAACC873AAFA8EA1 /* Pods-CRMCall092016-umbrella.h in Headers */ = {isa = PBXBuildFile; fileRef = 8204EF2923FBB8554D93693870D0BBBC /* Pods-CRMCall092016-umbrella.h */; settings = {ATTRIBUTES = (Public, ); }; };
-		ACFE60AB34A7FEF697E6EEFB62436A8D /* CocoaAsyncSocket-umbrella.h in Headers */ = {isa = PBXBuildFile; fileRef = D6D9F3F23E9E53DAFA379995A9E13E58 /* CocoaAsyncSocket-umbrella.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		5BC19E6E0F199276003F0AF96838BCE5 /* Upload.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8991BF3DBE2A9AD6CB35BF27297CC8FD /* Upload.swift */; };
+		5CB05FBCB32D21E194B5ECF680CB6AE0 /* Download.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2AA16A476F2771B1B74FB14947F24E02 /* Download.swift */; };
+		5CEBE5DA1F9A37F09EE1389B645FD1B4 /* Cocoa.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 7C56649C408E00F4469558EBC9AF1BA3 /* Cocoa.framework */; };
+		62E8346F03C03E7F4D631361F325689E /* Response.swift in Sources */ = {isa = PBXBuildFile; fileRef = DDE49D9DCF93A390B23188C67221ECA8 /* Response.swift */; };
+		6AAFA2F344A6B58F728AF958F3FE6D89 /* GCDAsyncSocket.h in Headers */ = {isa = PBXBuildFile; fileRef = D1519185135D5351111F109E89AF0F64 /* GCDAsyncSocket.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		723E6C875E842A6DA996001BDFAF520E /* SWXMLHash+TypeConversion.swift in Sources */ = {isa = PBXBuildFile; fileRef = CE89954F8A8211757E95D5E68308F52F /* SWXMLHash+TypeConversion.swift */; };
+		72504A8A3AD0249F8A37515A72C2DF98 /* SWXMLHash.swift in Sources */ = {isa = PBXBuildFile; fileRef = 7201E46C9812098E184043C076154118 /* SWXMLHash.swift */; };
+		7560CA92AA1E62C1C39BBA309960C36A /* SWXMLHash-dummy.m in Sources */ = {isa = PBXBuildFile; fileRef = 2BDE952759498BFF23C89A0302BD584C /* SWXMLHash-dummy.m */; };
+		7B48852C4D848FA2DA416A98F6425869 /* ServerTrustPolicy.swift in Sources */ = {isa = PBXBuildFile; fileRef = 62073F3761055A46F154B11F061A08AF /* ServerTrustPolicy.swift */; };
+		8EB11202167FCDDF1257AAAB1D1FB244 /* Alamofire.swift in Sources */ = {isa = PBXBuildFile; fileRef = E01E26D8749A98484E8DD7726148EC20 /* Alamofire.swift */; };
+		92AED971B91C640191A5ABA1567FE358 /* GCDAsyncUdpSocket.h in Headers */ = {isa = PBXBuildFile; fileRef = 540A59953BD2C3205CF5F2CE7B7BFC1F /* GCDAsyncUdpSocket.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		9469DF81ECB494E84675969B5E13374C /* Alamofire-umbrella.h in Headers */ = {isa = PBXBuildFile; fileRef = 588A6F6AFA80EA93ECB5E93B156711EC /* Alamofire-umbrella.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		991BFD139F6A45C9B654960C2F6A7F09 /* GCDAsyncSocket.m in Sources */ = {isa = PBXBuildFile; fileRef = FB4019B4F3DF5D7B015227F280ABBE9C /* GCDAsyncSocket.m */; settings = {COMPILER_FLAGS = "-DOS_OBJECT_USE_OBJC=0"; }; };
+		A2BFC3BB72F0CAF82F3CEF224DE6752D /* Pods-CRMCall092016-umbrella.h in Headers */ = {isa = PBXBuildFile; fileRef = 8204EF2923FBB8554D93693870D0BBBC /* Pods-CRMCall092016-umbrella.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		AA314156AC500125F4078EE968DB14C6 /* Result.swift in Sources */ = {isa = PBXBuildFile; fileRef = E2A2BD6EE0720A5171EF80B09CFD4224 /* Result.swift */; };
+		ACFE60AB34A7FEF697E6EEFB62436A8D /* CocoaAsyncSocket-umbrella.h in Headers */ = {isa = PBXBuildFile; fileRef = 5F955B5F2D78E83D6BA538909B360F55 /* CocoaAsyncSocket-umbrella.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		ADF19C953CE2A7D0B72EC93A81FCCC26 /* Alamofire-dummy.m in Sources */ = {isa = PBXBuildFile; fileRef = 5399F7CAF2240783134915CC1CBEF3E5 /* Alamofire-dummy.m */; };
+		AE4CF87C02C042DF13ED5B21C4FDC1E0 /* Stream.swift in Sources */ = {isa = PBXBuildFile; fileRef = 5B2BB4979BAD0CF7156F74E71CAD3041 /* Stream.swift */; };
+		B93BDD4D746BA45D62DC63CA9E5BF338 /* Cocoa.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 7C56649C408E00F4469558EBC9AF1BA3 /* Cocoa.framework */; };
+		BE41196F6A3903E59C3306FE3F8B43FE /* Notifications.swift in Sources */ = {isa = PBXBuildFile; fileRef = ECD84F348832D77D5059D066749346A4 /* Notifications.swift */; };
+		C0DB70AB368765DC64BFB5FEA75E0696 /* ParameterEncoding.swift in Sources */ = {isa = PBXBuildFile; fileRef = 125D17DF5E6A1A7420D1F1A975DD7EB9 /* ParameterEncoding.swift */; };
 		C5C58FEE0A35A9EF7DA80B26B6DF2089 /* CoreServices.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 8028EBFA77CCF460ADEBC79B87525C3D /* CoreServices.framework */; };
-		D9A44696356E299F3C9A4BFF9E57343F /* GCDAsyncUdpSocket.m in Sources */ = {isa = PBXBuildFile; fileRef = 098765466D421180F3953EF8EEDDCEF1 /* GCDAsyncUdpSocket.m */; settings = {COMPILER_FLAGS = "-DOS_OBJECT_USE_OBJC=0"; }; };
-		F32AB407361604D69C1D26A59004F99F /* Pods-CRMCall092016-dummy.m in Sources */ = {isa = PBXBuildFile; fileRef = 2AE57F75653AE6E263CFF4332F052094 /* Pods-CRMCall092016-dummy.m */; };
-		F45B40DF0BF596BDCD96B2D85EF848FA /* CocoaAsyncSocket-dummy.m in Sources */ = {isa = PBXBuildFile; fileRef = 8E98378F2CF04086E8088C6A14347C33 /* CocoaAsyncSocket-dummy.m */; };
+		C7B6DD7C0456C50289A2C381DFE9FA3F /* MultipartFormData.swift in Sources */ = {isa = PBXBuildFile; fileRef = AF650B57C6596DA153F5900EA61CC5A7 /* MultipartFormData.swift */; };
+		D9A44696356E299F3C9A4BFF9E57343F /* GCDAsyncUdpSocket.m in Sources */ = {isa = PBXBuildFile; fileRef = ED466E93414A976222AFAF321E9AF11C /* GCDAsyncUdpSocket.m */; settings = {COMPILER_FLAGS = "-DOS_OBJECT_USE_OBJC=0"; }; };
+		EFE92E8D3813DD26E78E93EEAF6D7E7E /* Request.swift in Sources */ = {isa = PBXBuildFile; fileRef = F14E627DC549703B46315BBCCDD362AE /* Request.swift */; };
+		F3F3FD9096F43B73CBB52EF0E1CCF73E /* Cocoa.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 7C56649C408E00F4469558EBC9AF1BA3 /* Cocoa.framework */; };
+		F45B40DF0BF596BDCD96B2D85EF848FA /* CocoaAsyncSocket-dummy.m in Sources */ = {isa = PBXBuildFile; fileRef = ABC09E1DCC49261B7629CD82626C21FA /* CocoaAsyncSocket-dummy.m */; };
 /* End PBXBuildFile section */
 
 /* Begin PBXContainerItemProxy section */
-		FEE18F96712D8E1EC56662C660E9DB97 /* PBXContainerItemProxy */ = {
+		1F41FB1990B1F3A39ADE4AEDF3C3DE3A /* PBXContainerItemProxy */ = {
+			isa = PBXContainerItemProxy;
+			containerPortal = D41D8CD98F00B204E9800998ECF8427E /* Project object */;
+			proxyType = 1;
+			remoteGlobalIDString = 79C040AFDDCE1BCBF6D8B5EB0B85887F;
+			remoteInfo = Alamofire;
+		};
+		A6ED361CEE1ECD9230711154275A9274 /* PBXContainerItemProxy */ = {
 			isa = PBXContainerItemProxy;
 			containerPortal = D41D8CD98F00B204E9800998ECF8427E /* Project object */;
 			proxyType = 1;
 			remoteGlobalIDString = B37E19CA872A7535725D1E1946E5C271;
 			remoteInfo = CocoaAsyncSocket;
 		};
+		A98B988E365E15D4E2D8C73D59A5F0EE /* PBXContainerItemProxy */ = {
+			isa = PBXContainerItemProxy;
+			containerPortal = D41D8CD98F00B204E9800998ECF8427E /* Project object */;
+			proxyType = 1;
+			remoteGlobalIDString = 67C63D588DA997BFF7D3C999DA7A5A23;
+			remoteInfo = SWXMLHash;
+		};
 /* End PBXContainerItemProxy section */
 
 /* Begin PBXFileReference section */
-		02F721520946E3ED0F5A5A2CBC3AA2F1 /* CocoaAsyncSocket.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = CocoaAsyncSocket.framework; sourceTree = BUILT_PRODUCTS_DIR; };
 		06FB8D033CAD052B54E275B7C0A5F2A4 /* Pods-CRMCall092016-resources.sh */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.script.sh; path = "Pods-CRMCall092016-resources.sh"; sourceTree = "<group>"; };
-		098765466D421180F3953EF8EEDDCEF1 /* GCDAsyncUdpSocket.m */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.objc; name = GCDAsyncUdpSocket.m; path = Source/GCD/GCDAsyncUdpSocket.m; sourceTree = "<group>"; };
+		0E50EC0B768D99DF8AA54CEF00DCD620 /* CocoaAsyncSocket-prefix.pch */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; path = "CocoaAsyncSocket-prefix.pch"; sourceTree = "<group>"; };
 		11566DE119910F4F8728001B55582E0A /* Pods-CRMCall092016.debug.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; path = "Pods-CRMCall092016.debug.xcconfig"; sourceTree = "<group>"; };
-		1D696A8CDEBE87CDE80E57AE0E305C5F /* GCDAsyncSocket.m */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.objc; name = GCDAsyncSocket.m; path = Source/GCD/GCDAsyncSocket.m; sourceTree = "<group>"; };
+		125D17DF5E6A1A7420D1F1A975DD7EB9 /* ParameterEncoding.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = ParameterEncoding.swift; path = Source/ParameterEncoding.swift; sourceTree = "<group>"; };
+		26831C2816B1A793F64FFC713F267BB3 /* Pods_CRMCall092016.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Pods_CRMCall092016.framework; sourceTree = BUILT_PRODUCTS_DIR; };
 		27183F652B0581A2389A12BA7AFAF98A /* Pods-CRMCall092016-frameworks.sh */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.script.sh; path = "Pods-CRMCall092016-frameworks.sh"; sourceTree = "<group>"; };
+		2AA16A476F2771B1B74FB14947F24E02 /* Download.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Download.swift; path = Source/Download.swift; sourceTree = "<group>"; };
 		2AE57F75653AE6E263CFF4332F052094 /* Pods-CRMCall092016-dummy.m */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.objc; path = "Pods-CRMCall092016-dummy.m"; sourceTree = "<group>"; };
-		2EF436B09B560AF848B4D98C55F61FE0 /* CocoaAsyncSocket.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; path = CocoaAsyncSocket.xcconfig; sourceTree = "<group>"; };
+		2BDE952759498BFF23C89A0302BD584C /* SWXMLHash-dummy.m */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.objc; path = "SWXMLHash-dummy.m"; sourceTree = "<group>"; };
 		3344C80F9295CA22275F8A0581FF4EAB /* Pods-CRMCall092016.release.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; path = "Pods-CRMCall092016.release.xcconfig"; sourceTree = "<group>"; };
 		38BAD449C799FB480EAEF1177A7D5534 /* Pods-CRMCall092016-acknowledgements.plist */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.plist.xml; path = "Pods-CRMCall092016-acknowledgements.plist"; sourceTree = "<group>"; };
-		4CA8FFB2F306345702A20E3FE7CE6EF7 /* GCDAsyncSocket.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = GCDAsyncSocket.h; path = Source/GCD/GCDAsyncSocket.h; sourceTree = "<group>"; };
+		3E8CB71BFFC59E2E3BA715D7AEF30B56 /* SWXMLHash.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; path = SWXMLHash.xcconfig; sourceTree = "<group>"; };
+		421DBE2696953979E49FD7BBE38C3847 /* CocoaAsyncSocket.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; path = CocoaAsyncSocket.xcconfig; sourceTree = "<group>"; };
+		428FFE99F83C8F7F2E1E0A88D7622693 /* Alamofire-prefix.pch */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; path = "Alamofire-prefix.pch"; sourceTree = "<group>"; };
+		530C70E607990B234619FFA25EF6C451 /* SWXMLHash-prefix.pch */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; path = "SWXMLHash-prefix.pch"; sourceTree = "<group>"; };
+		5399F7CAF2240783134915CC1CBEF3E5 /* Alamofire-dummy.m */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.objc; path = "Alamofire-dummy.m"; sourceTree = "<group>"; };
+		540A59953BD2C3205CF5F2CE7B7BFC1F /* GCDAsyncUdpSocket.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = GCDAsyncUdpSocket.h; path = Source/GCD/GCDAsyncUdpSocket.h; sourceTree = "<group>"; };
+		588A6F6AFA80EA93ECB5E93B156711EC /* Alamofire-umbrella.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; path = "Alamofire-umbrella.h"; sourceTree = "<group>"; };
+		5B2BB4979BAD0CF7156F74E71CAD3041 /* Stream.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Stream.swift; path = Source/Stream.swift; sourceTree = "<group>"; };
+		5F0B453266F2DE0B098E2B994FE716CD /* SWXMLHash-umbrella.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; path = "SWXMLHash-umbrella.h"; sourceTree = "<group>"; };
 		5F10F69CC4AED6A9E8880E0026D1641C /* Pods-CRMCall092016.modulemap */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = "sourcecode.module-map"; path = "Pods-CRMCall092016.modulemap"; sourceTree = "<group>"; };
-		607059846E83C82CDCE4A0DC0CC4E112 /* Pods_CRMCall092016.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Pods_CRMCall092016.framework; sourceTree = BUILT_PRODUCTS_DIR; };
+		5F955B5F2D78E83D6BA538909B360F55 /* CocoaAsyncSocket-umbrella.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; path = "CocoaAsyncSocket-umbrella.h"; sourceTree = "<group>"; };
+		62073F3761055A46F154B11F061A08AF /* ServerTrustPolicy.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = ServerTrustPolicy.swift; path = Source/ServerTrustPolicy.swift; sourceTree = "<group>"; };
+		64E8485F5FCFC4FDB8D6CE0BFC980C58 /* NetworkReachabilityManager.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = NetworkReachabilityManager.swift; path = Source/NetworkReachabilityManager.swift; sourceTree = "<group>"; };
 		686F90C995F21EC49B98AEDDD4DFE31A /* Info.plist */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
-		75F9206B99E5B5423D6B61D755C011CC /* CocoaAsyncSocket-prefix.pch */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; path = "CocoaAsyncSocket-prefix.pch"; sourceTree = "<group>"; };
+		6D0E27C7C865AC6950E934CB59C487B1 /* Alamofire.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; path = Alamofire.xcconfig; sourceTree = "<group>"; };
+		7031D4000017108DC80504B065340368 /* Manager.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Manager.swift; path = Source/Manager.swift; sourceTree = "<group>"; };
+		7201E46C9812098E184043C076154118 /* SWXMLHash.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = SWXMLHash.swift; path = Source/SWXMLHash.swift; sourceTree = "<group>"; };
+		72118B3908192BACF6200F55157D9D71 /* Info.plist */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
+		7911AB14649A75D2129B7AF99D9F284F /* CocoaAsyncSocket.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = CocoaAsyncSocket.framework; sourceTree = BUILT_PRODUCTS_DIR; };
+		7B57FE540E66A44F3A0381EE3E553552 /* Alamofire.modulemap */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = "sourcecode.module-map"; path = Alamofire.modulemap; sourceTree = "<group>"; };
 		7C56649C408E00F4469558EBC9AF1BA3 /* Cocoa.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Cocoa.framework; path = Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk/System/Library/Frameworks/Cocoa.framework; sourceTree = DEVELOPER_DIR; };
 		8028EBFA77CCF460ADEBC79B87525C3D /* CoreServices.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = CoreServices.framework; path = Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk/System/Library/Frameworks/CoreServices.framework; sourceTree = DEVELOPER_DIR; };
 		8204EF2923FBB8554D93693870D0BBBC /* Pods-CRMCall092016-umbrella.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; path = "Pods-CRMCall092016-umbrella.h"; sourceTree = "<group>"; };
-		84A110336E93C3E786F9B32956E29A3E /* GCDAsyncUdpSocket.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = GCDAsyncUdpSocket.h; path = Source/GCD/GCDAsyncUdpSocket.h; sourceTree = "<group>"; };
-		86340A99F20BEC0D9E6F18F9080B8720 /* CocoaAsyncSocket.modulemap */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = "sourcecode.module-map"; path = CocoaAsyncSocket.modulemap; sourceTree = "<group>"; };
-		8897EF90B2D55946A61AD5A10C38B75C /* Info.plist */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
-		8E98378F2CF04086E8088C6A14347C33 /* CocoaAsyncSocket-dummy.m */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.objc; path = "CocoaAsyncSocket-dummy.m"; sourceTree = "<group>"; };
+		84395B1E623BD8F9DE2F7E16CA43251F /* Validation.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Validation.swift; path = Source/Validation.swift; sourceTree = "<group>"; };
+		875107E5B1CD30A24F90CC34B1452862 /* Info.plist */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
+		8991BF3DBE2A9AD6CB35BF27297CC8FD /* Upload.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Upload.swift; path = Source/Upload.swift; sourceTree = "<group>"; };
+		8D365AF8CA284382154A3FCADC2924CC /* Alamofire.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Alamofire.framework; sourceTree = BUILT_PRODUCTS_DIR; };
 		92BE530B50F95F40971BFC22BF7114AF /* Pods-CRMCall092016-acknowledgements.markdown */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text; path = "Pods-CRMCall092016-acknowledgements.markdown"; sourceTree = "<group>"; };
 		93A4A3777CF96A4AAC1D13BA6DCCEA73 /* Podfile */ = {isa = PBXFileReference; explicitFileType = text.script.ruby; includeInIndex = 1; name = Podfile; path = ../Podfile; sourceTree = SOURCE_ROOT; xcLanguageSpecificationIdentifier = xcode.lang.ruby; };
-		D6D9F3F23E9E53DAFA379995A9E13E58 /* CocoaAsyncSocket-umbrella.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; path = "CocoaAsyncSocket-umbrella.h"; sourceTree = "<group>"; };
+		ABC09E1DCC49261B7629CD82626C21FA /* CocoaAsyncSocket-dummy.m */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.objc; path = "CocoaAsyncSocket-dummy.m"; sourceTree = "<group>"; };
+		AF650B57C6596DA153F5900EA61CC5A7 /* MultipartFormData.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = MultipartFormData.swift; path = Source/MultipartFormData.swift; sourceTree = "<group>"; };
+		B7C925E8849659F01450961BB1FFA23D /* ResponseSerialization.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = ResponseSerialization.swift; path = Source/ResponseSerialization.swift; sourceTree = "<group>"; };
+		BC6E9E2C5DCCD36683912082D39D119C /* SWXMLHash.modulemap */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = "sourcecode.module-map"; path = SWXMLHash.modulemap; sourceTree = "<group>"; };
+		C3D72D35EB73312A9630B6441B6D65DC /* Info.plist */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
+		C608DAD3E8D1E316C917482D1150C9E4 /* SWXMLHash.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = SWXMLHash.framework; sourceTree = BUILT_PRODUCTS_DIR; };
+		CE89954F8A8211757E95D5E68308F52F /* SWXMLHash+TypeConversion.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = "SWXMLHash+TypeConversion.swift"; path = "Source/SWXMLHash+TypeConversion.swift"; sourceTree = "<group>"; };
+		D1519185135D5351111F109E89AF0F64 /* GCDAsyncSocket.h */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.h; name = GCDAsyncSocket.h; path = Source/GCD/GCDAsyncSocket.h; sourceTree = "<group>"; };
+		D77E19C3839748928122D0DEAC1BA1F4 /* Timeline.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Timeline.swift; path = Source/Timeline.swift; sourceTree = "<group>"; };
+		DDE49D9DCF93A390B23188C67221ECA8 /* Response.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Response.swift; path = Source/Response.swift; sourceTree = "<group>"; };
+		E01E26D8749A98484E8DD7726148EC20 /* Alamofire.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Alamofire.swift; path = Source/Alamofire.swift; sourceTree = "<group>"; };
+		E0D2633544BCFC90D4DD429B2FE884D7 /* CocoaAsyncSocket.modulemap */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = "sourcecode.module-map"; path = CocoaAsyncSocket.modulemap; sourceTree = "<group>"; };
+		E2A2BD6EE0720A5171EF80B09CFD4224 /* Result.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Result.swift; path = Source/Result.swift; sourceTree = "<group>"; };
 		E35F27DD11D07BB27A6C8CE52CD34061 /* Security.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Security.framework; path = Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk/System/Library/Frameworks/Security.framework; sourceTree = DEVELOPER_DIR; };
+		ECD84F348832D77D5059D066749346A4 /* Notifications.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Notifications.swift; path = Source/Notifications.swift; sourceTree = "<group>"; };
+		ED466E93414A976222AFAF321E9AF11C /* GCDAsyncUdpSocket.m */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.objc; name = GCDAsyncUdpSocket.m; path = Source/GCD/GCDAsyncUdpSocket.m; sourceTree = "<group>"; };
+		EF9B2AFCE03477C50F07C48E33A463FF /* Error.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Error.swift; path = Source/Error.swift; sourceTree = "<group>"; };
+		F14E627DC549703B46315BBCCDD362AE /* Request.swift */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.swift; name = Request.swift; path = Source/Request.swift; sourceTree = "<group>"; };
+		FB4019B4F3DF5D7B015227F280ABBE9C /* GCDAsyncSocket.m */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = sourcecode.c.objc; name = GCDAsyncSocket.m; path = Source/GCD/GCDAsyncSocket.m; sourceTree = "<group>"; };
 /* End PBXFileReference section */
 
 /* Begin PBXFrameworksBuildPhase section */
-		EDB9B30DC8B486582976DE7ABD029042 /* Frameworks */ = {
+		057374DBF94AB4C711C95D3C81644697 /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				B93BDD4D746BA45D62DC63CA9E5BF338 /* Cocoa.framework in Frameworks */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		86631BCDD6995CFD2A8A7716F3673282 /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				F3F3FD9096F43B73CBB52EF0E1CCF73E /* Cocoa.framework in Frameworks */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		88126D8EF116B657E2FD26AB2C7D7C76 /* Frameworks */ = {
 			isa = PBXFrameworksBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
-				3A3F65A9CFEBD04E71A6E05108F795D0 /* Cocoa.framework in Frameworks */,
+				5CEBE5DA1F9A37F09EE1389B645FD1B4 /* Cocoa.framework in Frameworks */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -82,6 +170,30 @@
 /* End PBXFrameworksBuildPhase section */
 
 /* Begin PBXGroup section */
+		01B95DBFE667B00CC6977BD31CE4F3B2 /* Support Files */ = {
+			isa = PBXGroup;
+			children = (
+				7B57FE540E66A44F3A0381EE3E553552 /* Alamofire.modulemap */,
+				6D0E27C7C865AC6950E934CB59C487B1 /* Alamofire.xcconfig */,
+				5399F7CAF2240783134915CC1CBEF3E5 /* Alamofire-dummy.m */,
+				428FFE99F83C8F7F2E1E0A88D7622693 /* Alamofire-prefix.pch */,
+				588A6F6AFA80EA93ECB5E93B156711EC /* Alamofire-umbrella.h */,
+				72118B3908192BACF6200F55157D9D71 /* Info.plist */,
+			);
+			name = "Support Files";
+			path = "../Target Support Files/Alamofire";
+			sourceTree = "<group>";
+		};
+		0D755FC3415F3E7464CA4F3CD0BEF91A /* Pods */ = {
+			isa = PBXGroup;
+			children = (
+				71982584ECA5E3C8D7B92572F29AA8DA /* Alamofire */,
+				FF778D1838A3F60CF9CF2403E182E955 /* CocoaAsyncSocket */,
+				E7FACF9BF4BA24608BB789AF7D8A102F /* SWXMLHash */,
+			);
+			name = Pods;
+			sourceTree = "<group>";
+		};
 		125C76EFFE45A468598601061FFD20C1 /* OS X */ = {
 			isa = PBXGroup;
 			children = (
@@ -92,34 +204,48 @@
 			name = "OS X";
 			sourceTree = "<group>";
 		};
-		3750E20CAB4987ACB8AB27B6C25C1D60 /* Pods */ = {
+		6B7D6DAD89010B625FD7D6631AB356FF /* Products */ = {
 			isa = PBXGroup;
 			children = (
-				B16CCCC916CD9D13BBF53EA0C69C4615 /* CocoaAsyncSocket */,
+				8D365AF8CA284382154A3FCADC2924CC /* Alamofire.framework */,
+				7911AB14649A75D2129B7AF99D9F284F /* CocoaAsyncSocket.framework */,
+				26831C2816B1A793F64FFC713F267BB3 /* Pods_CRMCall092016.framework */,
+				C608DAD3E8D1E316C917482D1150C9E4 /* SWXMLHash.framework */,
 			);
-			name = Pods;
+			name = Products;
 			sourceTree = "<group>";
 		};
-		557C7CF8D4466D636F16673BAB31EEF1 /* Support Files */ = {
+		6BAE03FB7B81BD8D4DD2F62159D790F2 /* Targets Support Files */ = {
 			isa = PBXGroup;
 			children = (
-				86340A99F20BEC0D9E6F18F9080B8720 /* CocoaAsyncSocket.modulemap */,
-				2EF436B09B560AF848B4D98C55F61FE0 /* CocoaAsyncSocket.xcconfig */,
-				8E98378F2CF04086E8088C6A14347C33 /* CocoaAsyncSocket-dummy.m */,
-				75F9206B99E5B5423D6B61D755C011CC /* CocoaAsyncSocket-prefix.pch */,
-				D6D9F3F23E9E53DAFA379995A9E13E58 /* CocoaAsyncSocket-umbrella.h */,
-				8897EF90B2D55946A61AD5A10C38B75C /* Info.plist */,
+				B8A9724351936E298AF17D9B38E4AA57 /* Pods-CRMCall092016 */,
 			);
-			name = "Support Files";
-			path = "../Target Support Files/CocoaAsyncSocket";
+			name = "Targets Support Files";
 			sourceTree = "<group>";
 		};
-		6BAE03FB7B81BD8D4DD2F62159D790F2 /* Targets Support Files */ = {
+		71982584ECA5E3C8D7B92572F29AA8DA /* Alamofire */ = {
 			isa = PBXGroup;
 			children = (
-				B8A9724351936E298AF17D9B38E4AA57 /* Pods-CRMCall092016 */,
+				E01E26D8749A98484E8DD7726148EC20 /* Alamofire.swift */,
+				2AA16A476F2771B1B74FB14947F24E02 /* Download.swift */,
+				EF9B2AFCE03477C50F07C48E33A463FF /* Error.swift */,
+				7031D4000017108DC80504B065340368 /* Manager.swift */,
+				AF650B57C6596DA153F5900EA61CC5A7 /* MultipartFormData.swift */,
+				64E8485F5FCFC4FDB8D6CE0BFC980C58 /* NetworkReachabilityManager.swift */,
+				ECD84F348832D77D5059D066749346A4 /* Notifications.swift */,
+				125D17DF5E6A1A7420D1F1A975DD7EB9 /* ParameterEncoding.swift */,
+				F14E627DC549703B46315BBCCDD362AE /* Request.swift */,
+				DDE49D9DCF93A390B23188C67221ECA8 /* Response.swift */,
+				B7C925E8849659F01450961BB1FFA23D /* ResponseSerialization.swift */,
+				E2A2BD6EE0720A5171EF80B09CFD4224 /* Result.swift */,
+				62073F3761055A46F154B11F061A08AF /* ServerTrustPolicy.swift */,
+				5B2BB4979BAD0CF7156F74E71CAD3041 /* Stream.swift */,
+				D77E19C3839748928122D0DEAC1BA1F4 /* Timeline.swift */,
+				8991BF3DBE2A9AD6CB35BF27297CC8FD /* Upload.swift */,
+				84395B1E623BD8F9DE2F7E16CA43251F /* Validation.swift */,
+				01B95DBFE667B00CC6977BD31CE4F3B2 /* Support Files */,
 			);
-			name = "Targets Support Files";
+			path = Alamofire;
 			sourceTree = "<group>";
 		};
 		7DB346D0F39D3F0E887471402A8071AB = {
@@ -127,19 +253,24 @@
 			children = (
 				93A4A3777CF96A4AAC1D13BA6DCCEA73 /* Podfile */,
 				96D996393384F21972E2DD81788EE22C /* Frameworks */,
-				3750E20CAB4987ACB8AB27B6C25C1D60 /* Pods */,
-				89C122A58C976DAED8C4212AAC8AFB74 /* Products */,
+				0D755FC3415F3E7464CA4F3CD0BEF91A /* Pods */,
+				6B7D6DAD89010B625FD7D6631AB356FF /* Products */,
 				6BAE03FB7B81BD8D4DD2F62159D790F2 /* Targets Support Files */,
 			);
 			sourceTree = "<group>";
 		};
-		89C122A58C976DAED8C4212AAC8AFB74 /* Products */ = {
+		93A0D837347BC14B6101239D93030AC4 /* Support Files */ = {
 			isa = PBXGroup;
 			children = (
-				02F721520946E3ED0F5A5A2CBC3AA2F1 /* CocoaAsyncSocket.framework */,
-				607059846E83C82CDCE4A0DC0CC4E112 /* Pods_CRMCall092016.framework */,
+				E0D2633544BCFC90D4DD429B2FE884D7 /* CocoaAsyncSocket.modulemap */,
+				421DBE2696953979E49FD7BBE38C3847 /* CocoaAsyncSocket.xcconfig */,
+				ABC09E1DCC49261B7629CD82626C21FA /* CocoaAsyncSocket-dummy.m */,
+				0E50EC0B768D99DF8AA54CEF00DCD620 /* CocoaAsyncSocket-prefix.pch */,
+				5F955B5F2D78E83D6BA538909B360F55 /* CocoaAsyncSocket-umbrella.h */,
+				875107E5B1CD30A24F90CC34B1452862 /* Info.plist */,
 			);
-			name = Products;
+			name = "Support Files";
+			path = "../Target Support Files/CocoaAsyncSocket";
 			sourceTree = "<group>";
 		};
 		96D996393384F21972E2DD81788EE22C /* Frameworks */ = {
@@ -150,26 +281,17 @@
 			name = Frameworks;
 			sourceTree = "<group>";
 		};
-		982AE8715AD34D5D99A50B615809B1F1 /* GCD */ = {
+		B4AEF557D0B20590FFF106A8AB52A7AE /* GCD */ = {
 			isa = PBXGroup;
 			children = (
-				4CA8FFB2F306345702A20E3FE7CE6EF7 /* GCDAsyncSocket.h */,
-				1D696A8CDEBE87CDE80E57AE0E305C5F /* GCDAsyncSocket.m */,
-				84A110336E93C3E786F9B32956E29A3E /* GCDAsyncUdpSocket.h */,
-				098765466D421180F3953EF8EEDDCEF1 /* GCDAsyncUdpSocket.m */,
+				D1519185135D5351111F109E89AF0F64 /* GCDAsyncSocket.h */,
+				FB4019B4F3DF5D7B015227F280ABBE9C /* GCDAsyncSocket.m */,
+				540A59953BD2C3205CF5F2CE7B7BFC1F /* GCDAsyncUdpSocket.h */,
+				ED466E93414A976222AFAF321E9AF11C /* GCDAsyncUdpSocket.m */,
 			);
 			name = GCD;
 			sourceTree = "<group>";
 		};
-		B16CCCC916CD9D13BBF53EA0C69C4615 /* CocoaAsyncSocket */ = {
-			isa = PBXGroup;
-			children = (
-				982AE8715AD34D5D99A50B615809B1F1 /* GCD */,
-				557C7CF8D4466D636F16673BAB31EEF1 /* Support Files */,
-			);
-			path = CocoaAsyncSocket;
-			sourceTree = "<group>";
-		};
 		B8A9724351936E298AF17D9B38E4AA57 /* Pods-CRMCall092016 */ = {
 			isa = PBXGroup;
 			children = (
@@ -188,63 +310,148 @@
 			path = "Target Support Files/Pods-CRMCall092016";
 			sourceTree = "<group>";
 		};
+		DE3FD61F7CCDAC4566744964D80318A9 /* Support Files */ = {
+			isa = PBXGroup;
+			children = (
+				C3D72D35EB73312A9630B6441B6D65DC /* Info.plist */,
+				BC6E9E2C5DCCD36683912082D39D119C /* SWXMLHash.modulemap */,
+				3E8CB71BFFC59E2E3BA715D7AEF30B56 /* SWXMLHash.xcconfig */,
+				2BDE952759498BFF23C89A0302BD584C /* SWXMLHash-dummy.m */,
+				530C70E607990B234619FFA25EF6C451 /* SWXMLHash-prefix.pch */,
+				5F0B453266F2DE0B098E2B994FE716CD /* SWXMLHash-umbrella.h */,
+			);
+			name = "Support Files";
+			path = "../Target Support Files/SWXMLHash";
+			sourceTree = "<group>";
+		};
+		E7FACF9BF4BA24608BB789AF7D8A102F /* SWXMLHash */ = {
+			isa = PBXGroup;
+			children = (
+				7201E46C9812098E184043C076154118 /* SWXMLHash.swift */,
+				CE89954F8A8211757E95D5E68308F52F /* SWXMLHash+TypeConversion.swift */,
+				DE3FD61F7CCDAC4566744964D80318A9 /* Support Files */,
+			);
+			path = SWXMLHash;
+			sourceTree = "<group>";
+		};
+		FF778D1838A3F60CF9CF2403E182E955 /* CocoaAsyncSocket */ = {
+			isa = PBXGroup;
+			children = (
+				B4AEF557D0B20590FFF106A8AB52A7AE /* GCD */,
+				93A0D837347BC14B6101239D93030AC4 /* Support Files */,
+			);
+			path = CocoaAsyncSocket;
+			sourceTree = "<group>";
+		};
 /* End PBXGroup section */
 
 /* Begin PBXHeadersBuildPhase section */
-		31CCA99E660F3538D5DF69A9EED7821E /* Headers */ = {
+		41F6279547BA8C6095CA882FB1059614 /* Headers */ = {
 			isa = PBXHeadersBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
-				AC9CFE1768573A23FAACC873AAFA8EA1 /* Pods-CRMCall092016-umbrella.h in Headers */,
+				ACFE60AB34A7FEF697E6EEFB62436A8D /* CocoaAsyncSocket-umbrella.h in Headers */,
+				6AAFA2F344A6B58F728AF958F3FE6D89 /* GCDAsyncSocket.h in Headers */,
+				92AED971B91C640191A5ABA1567FE358 /* GCDAsyncUdpSocket.h in Headers */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
-		41F6279547BA8C6095CA882FB1059614 /* Headers */ = {
+		97EF195315ED04EDCCAC31D70A583B2E /* Headers */ = {
 			isa = PBXHeadersBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
-				ACFE60AB34A7FEF697E6EEFB62436A8D /* CocoaAsyncSocket-umbrella.h in Headers */,
-				6AAFA2F344A6B58F728AF958F3FE6D89 /* GCDAsyncSocket.h in Headers */,
-				92AED971B91C640191A5ABA1567FE358 /* GCDAsyncUdpSocket.h in Headers */,
+				1E5602BF3A87A7353DA77A2EE51EED93 /* SWXMLHash-umbrella.h in Headers */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		EFDF3B631BBB965A372347705CA14854 /* Headers */ = {
+			isa = PBXHeadersBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				9469DF81ECB494E84675969B5E13374C /* Alamofire-umbrella.h in Headers */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		FA82F97F3394B160E11E80A19D26FB84 /* Headers */ = {
+			isa = PBXHeadersBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				A2BFC3BB72F0CAF82F3CEF224DE6752D /* Pods-CRMCall092016-umbrella.h in Headers */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
 /* End PBXHeadersBuildPhase section */
 
 /* Begin PBXNativeTarget section */
-		B37E19CA872A7535725D1E1946E5C271 /* CocoaAsyncSocket */ = {
+		67C63D588DA997BFF7D3C999DA7A5A23 /* SWXMLHash */ = {
 			isa = PBXNativeTarget;
-			buildConfigurationList = 551479B287B69C7447DFBC6CA5EADF0B /* Build configuration list for PBXNativeTarget "CocoaAsyncSocket" */;
+			buildConfigurationList = 659D84DB6B9CFB1996FB238A044A68A1 /* Build configuration list for PBXNativeTarget "SWXMLHash" */;
 			buildPhases = (
-				217D9EA001DB8A7A00EBCC79A99280A3 /* Sources */,
-				F324C34599273EC2FE98A8DA30CE302F /* Frameworks */,
-				41F6279547BA8C6095CA882FB1059614 /* Headers */,
+				6266862713B40A60E6D5BC64F94F70F7 /* Sources */,
+				057374DBF94AB4C711C95D3C81644697 /* Frameworks */,
+				97EF195315ED04EDCCAC31D70A583B2E /* Headers */,
 			);
 			buildRules = (
 			);
 			dependencies = (
 			);
-			name = CocoaAsyncSocket;
-			productName = CocoaAsyncSocket;
-			productReference = 02F721520946E3ED0F5A5A2CBC3AA2F1 /* CocoaAsyncSocket.framework */;
+			name = SWXMLHash;
+			productName = SWXMLHash;
+			productReference = C608DAD3E8D1E316C917482D1150C9E4 /* SWXMLHash.framework */;
 			productType = "com.apple.product-type.framework";
 		};
-		ED9EA20B7A8CD0AA34A09F4F5CB87BEB /* Pods-CRMCall092016 */ = {
+		6A0818B9C68C8B9F82A2B6E85576006B /* Pods-CRMCall092016 */ = {
 			isa = PBXNativeTarget;
-			buildConfigurationList = B03ED2000B166CDC5CD804541F3FA0E9 /* Build configuration list for PBXNativeTarget "Pods-CRMCall092016" */;
+			buildConfigurationList = 238EE128C1BFD4365A9742EBAD4D8641 /* Build configuration list for PBXNativeTarget "Pods-CRMCall092016" */;
 			buildPhases = (
-				912F583C9F47FD8040B2EC902E7C303C /* Sources */,
-				EDB9B30DC8B486582976DE7ABD029042 /* Frameworks */,
-				31CCA99E660F3538D5DF69A9EED7821E /* Headers */,
+				32B5968CACDE4124ECD593156BE64DF2 /* Sources */,
+				88126D8EF116B657E2FD26AB2C7D7C76 /* Frameworks */,
+				FA82F97F3394B160E11E80A19D26FB84 /* Headers */,
 			);
 			buildRules = (
 			);
 			dependencies = (
-				AC6BD82C86275A2C3A88628826BFD192 /* PBXTargetDependency */,
+				71045A2931E715998C8E89599499B57E /* PBXTargetDependency */,
+				868B73927BF599C3CA77C6C45D6DD6E1 /* PBXTargetDependency */,
+				0DC5F42F629BD17706FF7A44455C12F4 /* PBXTargetDependency */,
 			);
 			name = "Pods-CRMCall092016";
 			productName = "Pods-CRMCall092016";
-			productReference = 607059846E83C82CDCE4A0DC0CC4E112 /* Pods_CRMCall092016.framework */;
+			productReference = 26831C2816B1A793F64FFC713F267BB3 /* Pods_CRMCall092016.framework */;
+			productType = "com.apple.product-type.framework";
+		};
+		79C040AFDDCE1BCBF6D8B5EB0B85887F /* Alamofire */ = {
+			isa = PBXNativeTarget;
+			buildConfigurationList = 3CFB42910790CF0BDBCCEBAACD6B9367 /* Build configuration list for PBXNativeTarget "Alamofire" */;
+			buildPhases = (
+				95CC2C7E06DC188A05DAAEE9CAA555A3 /* Sources */,
+				86631BCDD6995CFD2A8A7716F3673282 /* Frameworks */,
+				EFDF3B631BBB965A372347705CA14854 /* Headers */,
+			);
+			buildRules = (
+			);
+			dependencies = (
+			);
+			name = Alamofire;
+			productName = Alamofire;
+			productReference = 8D365AF8CA284382154A3FCADC2924CC /* Alamofire.framework */;
+			productType = "com.apple.product-type.framework";
+		};
+		B37E19CA872A7535725D1E1946E5C271 /* CocoaAsyncSocket */ = {
+			isa = PBXNativeTarget;
+			buildConfigurationList = 551479B287B69C7447DFBC6CA5EADF0B /* Build configuration list for PBXNativeTarget "CocoaAsyncSocket" */;
+			buildPhases = (
+				217D9EA001DB8A7A00EBCC79A99280A3 /* Sources */,
+				F324C34599273EC2FE98A8DA30CE302F /* Frameworks */,
+				41F6279547BA8C6095CA882FB1059614 /* Headers */,
+			);
+			buildRules = (
+			);
+			dependencies = (
+			);
+			name = CocoaAsyncSocket;
+			productName = CocoaAsyncSocket;
+			productReference = 7911AB14649A75D2129B7AF99D9F284F /* CocoaAsyncSocket.framework */;
 			productType = "com.apple.product-type.framework";
 		};
 /* End PBXNativeTarget section */
@@ -264,12 +471,14 @@
 				en,
 			);
 			mainGroup = 7DB346D0F39D3F0E887471402A8071AB;
-			productRefGroup = 89C122A58C976DAED8C4212AAC8AFB74 /* Products */;
+			productRefGroup = 6B7D6DAD89010B625FD7D6631AB356FF /* Products */;
 			projectDirPath = "";
 			projectRoot = "";
 			targets = (
+				79C040AFDDCE1BCBF6D8B5EB0B85887F /* Alamofire */,
 				B37E19CA872A7535725D1E1946E5C271 /* CocoaAsyncSocket */,
-				ED9EA20B7A8CD0AA34A09F4F5CB87BEB /* Pods-CRMCall092016 */,
+				6A0818B9C68C8B9F82A2B6E85576006B /* Pods-CRMCall092016 */,
+				67C63D588DA997BFF7D3C999DA7A5A23 /* SWXMLHash */,
 			);
 		};
 /* End PBXProject section */
@@ -285,22 +494,69 @@
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
-		912F583C9F47FD8040B2EC902E7C303C /* Sources */ = {
+		32B5968CACDE4124ECD593156BE64DF2 /* Sources */ = {
 			isa = PBXSourcesBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
-				F32AB407361604D69C1D26A59004F99F /* Pods-CRMCall092016-dummy.m in Sources */,
+				515FD66E0570F0E6B6D6F6B4AE427CC2 /* Pods-CRMCall092016-dummy.m in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		6266862713B40A60E6D5BC64F94F70F7 /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				723E6C875E842A6DA996001BDFAF520E /* SWXMLHash+TypeConversion.swift in Sources */,
+				7560CA92AA1E62C1C39BBA309960C36A /* SWXMLHash-dummy.m in Sources */,
+				72504A8A3AD0249F8A37515A72C2DF98 /* SWXMLHash.swift in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		95CC2C7E06DC188A05DAAEE9CAA555A3 /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				ADF19C953CE2A7D0B72EC93A81FCCC26 /* Alamofire-dummy.m in Sources */,
+				8EB11202167FCDDF1257AAAB1D1FB244 /* Alamofire.swift in Sources */,
+				5CB05FBCB32D21E194B5ECF680CB6AE0 /* Download.swift in Sources */,
+				095406039B4D371E48D08B38A2975AC8 /* Error.swift in Sources */,
+				4081EA628AF0B73AC51FFB9D7AB3B89E /* Manager.swift in Sources */,
+				C7B6DD7C0456C50289A2C381DFE9FA3F /* MultipartFormData.swift in Sources */,
+				34CCDCA848A701466256BC2927DA8856 /* NetworkReachabilityManager.swift in Sources */,
+				BE41196F6A3903E59C3306FE3F8B43FE /* Notifications.swift in Sources */,
+				C0DB70AB368765DC64BFB5FEA75E0696 /* ParameterEncoding.swift in Sources */,
+				EFE92E8D3813DD26E78E93EEAF6D7E7E /* Request.swift in Sources */,
+				62E8346F03C03E7F4D631361F325689E /* Response.swift in Sources */,
+				3EA8F215C9C1432D74E5CCA4834AA8C0 /* ResponseSerialization.swift in Sources */,
+				AA314156AC500125F4078EE968DB14C6 /* Result.swift in Sources */,
+				7B48852C4D848FA2DA416A98F6425869 /* ServerTrustPolicy.swift in Sources */,
+				AE4CF87C02C042DF13ED5B21C4FDC1E0 /* Stream.swift in Sources */,
+				16102E4E35FAA0FC4161282FECE56469 /* Timeline.swift in Sources */,
+				5BC19E6E0F199276003F0AF96838BCE5 /* Upload.swift in Sources */,
+				2D3405986FC586FA6C0A5E0B6BA7E64E /* Validation.swift in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
 /* End PBXSourcesBuildPhase section */
 
 /* Begin PBXTargetDependency section */
-		AC6BD82C86275A2C3A88628826BFD192 /* PBXTargetDependency */ = {
+		0DC5F42F629BD17706FF7A44455C12F4 /* PBXTargetDependency */ = {
+			isa = PBXTargetDependency;
+			name = SWXMLHash;
+			target = 67C63D588DA997BFF7D3C999DA7A5A23 /* SWXMLHash */;
+			targetProxy = A98B988E365E15D4E2D8C73D59A5F0EE /* PBXContainerItemProxy */;
+		};
+		71045A2931E715998C8E89599499B57E /* PBXTargetDependency */ = {
+			isa = PBXTargetDependency;
+			name = Alamofire;
+			target = 79C040AFDDCE1BCBF6D8B5EB0B85887F /* Alamofire */;
+			targetProxy = 1F41FB1990B1F3A39ADE4AEDF3C3DE3A /* PBXContainerItemProxy */;
+		};
+		868B73927BF599C3CA77C6C45D6DD6E1 /* PBXTargetDependency */ = {
 			isa = PBXTargetDependency;
 			name = CocoaAsyncSocket;
 			target = B37E19CA872A7535725D1E1946E5C271 /* CocoaAsyncSocket */;
-			targetProxy = FEE18F96712D8E1EC56662C660E9DB97 /* PBXContainerItemProxy */;
+			targetProxy = A6ED361CEE1ECD9230711154275A9274 /* PBXContainerItemProxy */;
 		};
 /* End PBXTargetDependency section */
 
@@ -349,7 +605,7 @@
 		};
 		22E1B933B435A6CDC7F2DDEA5826ADB0 /* Release */ = {
 			isa = XCBuildConfiguration;
-			baseConfigurationReference = 2EF436B09B560AF848B4D98C55F61FE0 /* CocoaAsyncSocket.xcconfig */;
+			baseConfigurationReference = 421DBE2696953979E49FD7BBE38C3847 /* CocoaAsyncSocket.xcconfig */;
 			buildSettings = {
 				CODE_SIGN_IDENTITY = "-";
 				COMBINE_HIDPI_IMAGES = YES;
@@ -377,40 +633,6 @@
 			};
 			name = Release;
 		};
-		521DC92EB5E96081859D95B644FA15CF /* Debug */ = {
-			isa = XCBuildConfiguration;
-			baseConfigurationReference = 11566DE119910F4F8728001B55582E0A /* Pods-CRMCall092016.debug.xcconfig */;
-			buildSettings = {
-				CODE_SIGN_IDENTITY = "-";
-				COMBINE_HIDPI_IMAGES = YES;
-				CURRENT_PROJECT_VERSION = 1;
-				DEBUG_INFORMATION_FORMAT = dwarf;
-				DEFINES_MODULE = YES;
-				DYLIB_COMPATIBILITY_VERSION = 1;
-				DYLIB_CURRENT_VERSION = 1;
-				DYLIB_INSTALL_NAME_BASE = "@rpath";
-				ENABLE_STRICT_OBJC_MSGSEND = YES;
-				FRAMEWORK_VERSION = A;
-				GCC_NO_COMMON_BLOCKS = YES;
-				INFOPLIST_FILE = "Target Support Files/Pods-CRMCall092016/Info.plist";
-				INSTALL_PATH = "$(LOCAL_LIBRARY_DIR)/Frameworks";
-				LD_RUNPATH_SEARCH_PATHS = "$(inherited) @executable_path/../Frameworks @loader_path/Frameworks";
-				MACH_O_TYPE = staticlib;
-				MACOSX_DEPLOYMENT_TARGET = 10.11;
-				MODULEMAP_FILE = "Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016.modulemap";
-				MTL_ENABLE_DEBUG_INFO = YES;
-				OTHER_LDFLAGS = "";
-				OTHER_LIBTOOLFLAGS = "";
-				PODS_ROOT = "$(SRCROOT)";
-				PRODUCT_BUNDLE_IDENTIFIER = "org.cocoapods.${PRODUCT_NAME:rfc1034identifier}";
-				PRODUCT_NAME = Pods_CRMCall092016;
-				SDKROOT = macosx;
-				SKIP_INSTALL = YES;
-				VERSIONING_SYSTEM = "apple-generic";
-				VERSION_INFO_PREFIX = "";
-			};
-			name = Debug;
-		};
 		578820E498FFD85CA5D93A33D365FBED /* Release */ = {
 			isa = XCBuildConfiguration;
 			buildSettings = {
@@ -449,9 +671,135 @@
 			};
 			name = Release;
 		};
+		6CE0C113B81940025E3A2FB05117B621 /* Release */ = {
+			isa = XCBuildConfiguration;
+			baseConfigurationReference = 3E8CB71BFFC59E2E3BA715D7AEF30B56 /* SWXMLHash.xcconfig */;
+			buildSettings = {
+				CODE_SIGN_IDENTITY = "-";
+				COMBINE_HIDPI_IMAGES = YES;
+				CURRENT_PROJECT_VERSION = 1;
+				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
+				DEFINES_MODULE = YES;
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				DYLIB_INSTALL_NAME_BASE = "@rpath";
+				ENABLE_STRICT_OBJC_MSGSEND = YES;
+				FRAMEWORK_VERSION = A;
+				GCC_NO_COMMON_BLOCKS = YES;
+				GCC_PREFIX_HEADER = "Target Support Files/SWXMLHash/SWXMLHash-prefix.pch";
+				INFOPLIST_FILE = "Target Support Files/SWXMLHash/Info.plist";
+				INSTALL_PATH = "$(LOCAL_LIBRARY_DIR)/Frameworks";
+				LD_RUNPATH_SEARCH_PATHS = "$(inherited) @executable_path/../Frameworks @loader_path/Frameworks";
+				MACOSX_DEPLOYMENT_TARGET = 10.9;
+				MODULEMAP_FILE = "Target Support Files/SWXMLHash/SWXMLHash.modulemap";
+				MTL_ENABLE_DEBUG_INFO = NO;
+				PRODUCT_NAME = SWXMLHash;
+				SDKROOT = macosx;
+				SKIP_INSTALL = YES;
+				VERSIONING_SYSTEM = "apple-generic";
+				VERSION_INFO_PREFIX = "";
+			};
+			name = Release;
+		};
+		81B3096945D568104AC14EE4F805950B /* Release */ = {
+			isa = XCBuildConfiguration;
+			baseConfigurationReference = 6D0E27C7C865AC6950E934CB59C487B1 /* Alamofire.xcconfig */;
+			buildSettings = {
+				CODE_SIGN_IDENTITY = "-";
+				COMBINE_HIDPI_IMAGES = YES;
+				CURRENT_PROJECT_VERSION = 1;
+				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
+				DEFINES_MODULE = YES;
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				DYLIB_INSTALL_NAME_BASE = "@rpath";
+				ENABLE_STRICT_OBJC_MSGSEND = YES;
+				FRAMEWORK_VERSION = A;
+				GCC_NO_COMMON_BLOCKS = YES;
+				GCC_PREFIX_HEADER = "Target Support Files/Alamofire/Alamofire-prefix.pch";
+				INFOPLIST_FILE = "Target Support Files/Alamofire/Info.plist";
+				INSTALL_PATH = "$(LOCAL_LIBRARY_DIR)/Frameworks";
+				LD_RUNPATH_SEARCH_PATHS = "$(inherited) @executable_path/../Frameworks @loader_path/Frameworks";
+				MACOSX_DEPLOYMENT_TARGET = 10.9;
+				MODULEMAP_FILE = "Target Support Files/Alamofire/Alamofire.modulemap";
+				MTL_ENABLE_DEBUG_INFO = NO;
+				PRODUCT_NAME = Alamofire;
+				SDKROOT = macosx;
+				SKIP_INSTALL = YES;
+				VERSIONING_SYSTEM = "apple-generic";
+				VERSION_INFO_PREFIX = "";
+			};
+			name = Release;
+		};
+		82B1EC5E8815E78991717D970C44B8D8 /* Debug */ = {
+			isa = XCBuildConfiguration;
+			baseConfigurationReference = 6D0E27C7C865AC6950E934CB59C487B1 /* Alamofire.xcconfig */;
+			buildSettings = {
+				CODE_SIGN_IDENTITY = "-";
+				COMBINE_HIDPI_IMAGES = YES;
+				CURRENT_PROJECT_VERSION = 1;
+				DEBUG_INFORMATION_FORMAT = dwarf;
+				DEFINES_MODULE = YES;
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				DYLIB_INSTALL_NAME_BASE = "@rpath";
+				ENABLE_STRICT_OBJC_MSGSEND = YES;
+				FRAMEWORK_VERSION = A;
+				GCC_NO_COMMON_BLOCKS = YES;
+				GCC_PREFIX_HEADER = "Target Support Files/Alamofire/Alamofire-prefix.pch";
+				INFOPLIST_FILE = "Target Support Files/Alamofire/Info.plist";
+				INSTALL_PATH = "$(LOCAL_LIBRARY_DIR)/Frameworks";
+				LD_RUNPATH_SEARCH_PATHS = "$(inherited) @executable_path/../Frameworks @loader_path/Frameworks";
+				MACOSX_DEPLOYMENT_TARGET = 10.9;
+				MODULEMAP_FILE = "Target Support Files/Alamofire/Alamofire.modulemap";
+				MTL_ENABLE_DEBUG_INFO = YES;
+				PRODUCT_NAME = Alamofire;
+				SDKROOT = macosx;
+				SKIP_INSTALL = YES;
+				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
+				VERSIONING_SYSTEM = "apple-generic";
+				VERSION_INFO_PREFIX = "";
+			};
+			name = Debug;
+		};
+		ABD52582A0CA0880395B592CF2D53A8C /* Debug */ = {
+			isa = XCBuildConfiguration;
+			baseConfigurationReference = 11566DE119910F4F8728001B55582E0A /* Pods-CRMCall092016.debug.xcconfig */;
+			buildSettings = {
+				CODE_SIGN_IDENTITY = "-";
+				COMBINE_HIDPI_IMAGES = YES;
+				CURRENT_PROJECT_VERSION = 1;
+				DEBUG_INFORMATION_FORMAT = dwarf;
+				DEFINES_MODULE = YES;
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				DYLIB_INSTALL_NAME_BASE = "@rpath";
+				ENABLE_STRICT_OBJC_MSGSEND = YES;
+				FRAMEWORK_VERSION = A;
+				GCC_NO_COMMON_BLOCKS = YES;
+				INFOPLIST_FILE = "Target Support Files/Pods-CRMCall092016/Info.plist";
+				INSTALL_PATH = "$(LOCAL_LIBRARY_DIR)/Frameworks";
+				LD_RUNPATH_SEARCH_PATHS = "$(inherited) @executable_path/../Frameworks @loader_path/Frameworks";
+				MACH_O_TYPE = staticlib;
+				MACOSX_DEPLOYMENT_TARGET = 10.11;
+				MODULEMAP_FILE = "Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016.modulemap";
+				MTL_ENABLE_DEBUG_INFO = YES;
+				OTHER_LDFLAGS = "";
+				OTHER_LIBTOOLFLAGS = "";
+				PODS_ROOT = "$(SRCROOT)";
+				PRODUCT_BUNDLE_IDENTIFIER = "org.cocoapods.${PRODUCT_NAME:rfc1034identifier}";
+				PRODUCT_NAME = Pods_CRMCall092016;
+				SDKROOT = macosx;
+				SKIP_INSTALL = YES;
+				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
+				VERSIONING_SYSTEM = "apple-generic";
+				VERSION_INFO_PREFIX = "";
+			};
+			name = Debug;
+		};
 		AC06A033185F3EDFA2433C8F90A0A7F2 /* Debug */ = {
 			isa = XCBuildConfiguration;
-			baseConfigurationReference = 2EF436B09B560AF848B4D98C55F61FE0 /* CocoaAsyncSocket.xcconfig */;
+			baseConfigurationReference = 421DBE2696953979E49FD7BBE38C3847 /* CocoaAsyncSocket.xcconfig */;
 			buildSettings = {
 				CODE_SIGN_IDENTITY = "-";
 				COMBINE_HIDPI_IMAGES = YES;
@@ -479,7 +827,38 @@
 			};
 			name = Debug;
 		};
-		E4DEC30E809251C58B0C7BF7802F5CFD /* Release */ = {
+		AC82647F4C2BE5E8CCF859C6D6F8141E /* Debug */ = {
+			isa = XCBuildConfiguration;
+			baseConfigurationReference = 3E8CB71BFFC59E2E3BA715D7AEF30B56 /* SWXMLHash.xcconfig */;
+			buildSettings = {
+				CODE_SIGN_IDENTITY = "-";
+				COMBINE_HIDPI_IMAGES = YES;
+				CURRENT_PROJECT_VERSION = 1;
+				DEBUG_INFORMATION_FORMAT = dwarf;
+				DEFINES_MODULE = YES;
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				DYLIB_INSTALL_NAME_BASE = "@rpath";
+				ENABLE_STRICT_OBJC_MSGSEND = YES;
+				FRAMEWORK_VERSION = A;
+				GCC_NO_COMMON_BLOCKS = YES;
+				GCC_PREFIX_HEADER = "Target Support Files/SWXMLHash/SWXMLHash-prefix.pch";
+				INFOPLIST_FILE = "Target Support Files/SWXMLHash/Info.plist";
+				INSTALL_PATH = "$(LOCAL_LIBRARY_DIR)/Frameworks";
+				LD_RUNPATH_SEARCH_PATHS = "$(inherited) @executable_path/../Frameworks @loader_path/Frameworks";
+				MACOSX_DEPLOYMENT_TARGET = 10.9;
+				MODULEMAP_FILE = "Target Support Files/SWXMLHash/SWXMLHash.modulemap";
+				MTL_ENABLE_DEBUG_INFO = YES;
+				PRODUCT_NAME = SWXMLHash;
+				SDKROOT = macosx;
+				SKIP_INSTALL = YES;
+				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
+				VERSIONING_SYSTEM = "apple-generic";
+				VERSION_INFO_PREFIX = "";
+			};
+			name = Debug;
+		};
+		D1217757FF60B0DDC6ED1BAE3F3421A4 /* Release */ = {
 			isa = XCBuildConfiguration;
 			baseConfigurationReference = 3344C80F9295CA22275F8A0581FF4EAB /* Pods-CRMCall092016.release.xcconfig */;
 			buildSettings = {
@@ -516,6 +895,15 @@
 /* End XCBuildConfiguration section */
 
 /* Begin XCConfigurationList section */
+		238EE128C1BFD4365A9742EBAD4D8641 /* Build configuration list for PBXNativeTarget "Pods-CRMCall092016" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				ABD52582A0CA0880395B592CF2D53A8C /* Debug */,
+				D1217757FF60B0DDC6ED1BAE3F3421A4 /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
 		2D8E8EC45A3A1A1D94AE762CB5028504 /* Build configuration list for PBXProject "Pods" */ = {
 			isa = XCConfigurationList;
 			buildConfigurations = (
@@ -525,6 +913,15 @@
 			defaultConfigurationIsVisible = 0;
 			defaultConfigurationName = Release;
 		};
+		3CFB42910790CF0BDBCCEBAACD6B9367 /* Build configuration list for PBXNativeTarget "Alamofire" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				82B1EC5E8815E78991717D970C44B8D8 /* Debug */,
+				81B3096945D568104AC14EE4F805950B /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
 		551479B287B69C7447DFBC6CA5EADF0B /* Build configuration list for PBXNativeTarget "CocoaAsyncSocket" */ = {
 			isa = XCConfigurationList;
 			buildConfigurations = (
@@ -534,11 +931,11 @@
 			defaultConfigurationIsVisible = 0;
 			defaultConfigurationName = Release;
 		};
-		B03ED2000B166CDC5CD804541F3FA0E9 /* Build configuration list for PBXNativeTarget "Pods-CRMCall092016" */ = {
+		659D84DB6B9CFB1996FB238A044A68A1 /* Build configuration list for PBXNativeTarget "SWXMLHash" */ = {
 			isa = XCConfigurationList;
 			buildConfigurations = (
-				521DC92EB5E96081859D95B644FA15CF /* Debug */,
-				E4DEC30E809251C58B0C7BF7802F5CFD /* Release */,
+				AC82647F4C2BE5E8CCF859C6D6F8141E /* Debug */,
+				6CE0C113B81940025E3A2FB05117B621 /* Release */,
 			);
 			defaultConfigurationIsVisible = 0;
 			defaultConfigurationName = Release;
diff --git a/Pods/Pods.xcodeproj/xcuserdata/.xcuserdatad/xcschemes/Alamofire.xcscheme b/Pods/Pods.xcodeproj/xcuserdata/.xcuserdatad/xcschemes/Alamofire.xcscheme
new file mode 100644
index 0000000..c0e3115
--- /dev/null
+++ b/Pods/Pods.xcodeproj/xcuserdata/.xcuserdatad/xcschemes/Alamofire.xcscheme
@@ -0,0 +1,60 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<Scheme
+   LastUpgradeVersion = "0700"
+   version = "1.3">
+   <BuildAction
+      parallelizeBuildables = "YES"
+      buildImplicitDependencies = "YES">
+      <BuildActionEntries>
+         <BuildActionEntry
+            buildForAnalyzing = "YES"
+            buildForTesting = "YES"
+            buildForRunning = "YES"
+            buildForProfiling = "YES"
+            buildForArchiving = "YES">
+            <BuildableReference
+               BuildableIdentifier = 'primary'
+               BlueprintIdentifier = '79C040AFDDCE1BCBF6D8B5EB0B85887F'
+               BlueprintName = 'Alamofire'
+               ReferencedContainer = 'container:Pods.xcodeproj'
+               BuildableName = 'Alamofire.framework'>
+            </BuildableReference>
+         </BuildActionEntry>
+      </BuildActionEntries>
+   </BuildAction>
+   <TestAction
+      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
+      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
+      shouldUseLaunchSchemeArgsEnv = "YES"
+      buildConfiguration = "Debug">
+      <AdditionalOptions>
+      </AdditionalOptions>
+   </TestAction>
+   <LaunchAction
+      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
+      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
+      launchStyle = "0"
+      useCustomWorkingDirectory = "NO"
+      ignoresPersistentStateOnLaunch = "NO"
+      debugDocumentVersioning = "YES"
+      debugServiceExtension = "internal"
+      buildConfiguration = "Debug"
+      allowLocationSimulation = "YES">
+      <AdditionalOptions>
+      </AdditionalOptions>
+   </LaunchAction>
+   <ProfileAction
+      savedToolIdentifier = ""
+      useCustomWorkingDirectory = "NO"
+      debugDocumentVersioning = "YES"
+      buildConfiguration = "Release"
+      shouldUseLaunchSchemeArgsEnv = "YES">
+   </ProfileAction>
+   <AnalyzeAction
+      buildConfiguration = "Debug">
+   </AnalyzeAction>
+   <ArchiveAction
+      buildConfiguration = "Release"
+      revealArchiveInOrganizer = "YES">
+   </ArchiveAction>
+</Scheme>
diff --git a/Pods/Pods.xcodeproj/xcuserdata/.xcuserdatad/xcschemes/Pods-CRMCall092016.xcscheme b/Pods/Pods.xcodeproj/xcuserdata/.xcuserdatad/xcschemes/Pods-CRMCall092016.xcscheme
index 993381f..9e1ec01 100644
--- a/Pods/Pods.xcodeproj/xcuserdata/.xcuserdatad/xcschemes/Pods-CRMCall092016.xcscheme
+++ b/Pods/Pods.xcodeproj/xcuserdata/.xcuserdatad/xcschemes/Pods-CRMCall092016.xcscheme
@@ -14,7 +14,7 @@
             buildForArchiving = "YES">
             <BuildableReference
                BuildableIdentifier = 'primary'
-               BlueprintIdentifier = 'ED9EA20B7A8CD0AA34A09F4F5CB87BEB'
+               BlueprintIdentifier = '6A0818B9C68C8B9F82A2B6E85576006B'
                BlueprintName = 'Pods-CRMCall092016'
                ReferencedContainer = 'container:Pods.xcodeproj'
                BuildableName = 'Pods-CRMCall092016.framework'>
diff --git a/Pods/Pods.xcodeproj/xcuserdata/.xcuserdatad/xcschemes/SWXMLHash.xcscheme b/Pods/Pods.xcodeproj/xcuserdata/.xcuserdatad/xcschemes/SWXMLHash.xcscheme
new file mode 100644
index 0000000..ef70ff0
--- /dev/null
+++ b/Pods/Pods.xcodeproj/xcuserdata/.xcuserdatad/xcschemes/SWXMLHash.xcscheme
@@ -0,0 +1,60 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<Scheme
+   LastUpgradeVersion = "0700"
+   version = "1.3">
+   <BuildAction
+      parallelizeBuildables = "YES"
+      buildImplicitDependencies = "YES">
+      <BuildActionEntries>
+         <BuildActionEntry
+            buildForAnalyzing = "YES"
+            buildForTesting = "YES"
+            buildForRunning = "YES"
+            buildForProfiling = "YES"
+            buildForArchiving = "YES">
+            <BuildableReference
+               BuildableIdentifier = 'primary'
+               BlueprintIdentifier = '67C63D588DA997BFF7D3C999DA7A5A23'
+               BlueprintName = 'SWXMLHash'
+               ReferencedContainer = 'container:Pods.xcodeproj'
+               BuildableName = 'SWXMLHash.framework'>
+            </BuildableReference>
+         </BuildActionEntry>
+      </BuildActionEntries>
+   </BuildAction>
+   <TestAction
+      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
+      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
+      shouldUseLaunchSchemeArgsEnv = "YES"
+      buildConfiguration = "Debug">
+      <AdditionalOptions>
+      </AdditionalOptions>
+   </TestAction>
+   <LaunchAction
+      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
+      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
+      launchStyle = "0"
+      useCustomWorkingDirectory = "NO"
+      ignoresPersistentStateOnLaunch = "NO"
+      debugDocumentVersioning = "YES"
+      debugServiceExtension = "internal"
+      buildConfiguration = "Debug"
+      allowLocationSimulation = "YES">
+      <AdditionalOptions>
+      </AdditionalOptions>
+   </LaunchAction>
+   <ProfileAction
+      savedToolIdentifier = ""
+      useCustomWorkingDirectory = "NO"
+      debugDocumentVersioning = "YES"
+      buildConfiguration = "Release"
+      shouldUseLaunchSchemeArgsEnv = "YES">
+   </ProfileAction>
+   <AnalyzeAction
+      buildConfiguration = "Debug">
+   </AnalyzeAction>
+   <ArchiveAction
+      buildConfiguration = "Release"
+      revealArchiveInOrganizer = "YES">
+   </ArchiveAction>
+</Scheme>
diff --git a/Pods/Pods.xcodeproj/xcuserdata/.xcuserdatad/xcschemes/xcschememanagement.plist b/Pods/Pods.xcodeproj/xcuserdata/.xcuserdatad/xcschemes/xcschememanagement.plist
index 2bef9aa..015401b 100644
--- a/Pods/Pods.xcodeproj/xcuserdata/.xcuserdatad/xcschemes/xcschememanagement.plist
+++ b/Pods/Pods.xcodeproj/xcuserdata/.xcuserdatad/xcschemes/xcschememanagement.plist
@@ -4,6 +4,11 @@
 <dict>
 	<key>SchemeUserState</key>
 	<dict>
+		<key>Alamofire.xcscheme</key>
+		<dict>
+			<key>isShown</key>
+			<false/>
+		</dict>
 		<key>CocoaAsyncSocket.xcscheme</key>
 		<dict>
 			<key>isShown</key>
@@ -14,6 +19,11 @@
 			<key>isShown</key>
 			<false/>
 		</dict>
+		<key>SWXMLHash.xcscheme</key>
+		<dict>
+			<key>isShown</key>
+			<false/>
+		</dict>
 	</dict>
 	<key>SuppressBuildableAutocreation</key>
 	<dict/>
diff --git a/Pods/Pods.xcodeproj/xcuserdata/hanbiro.xcuserdatad/xcschemes/Alamofire.xcscheme b/Pods/Pods.xcodeproj/xcuserdata/hanbiro.xcuserdatad/xcschemes/Alamofire.xcscheme
new file mode 100644
index 0000000..e393073
--- /dev/null
+++ b/Pods/Pods.xcodeproj/xcuserdata/hanbiro.xcuserdatad/xcschemes/Alamofire.xcscheme
@@ -0,0 +1,80 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<Scheme
+   LastUpgradeVersion = "0730"
+   version = "1.3">
+   <BuildAction
+      parallelizeBuildables = "YES"
+      buildImplicitDependencies = "YES">
+      <BuildActionEntries>
+         <BuildActionEntry
+            buildForTesting = "YES"
+            buildForRunning = "YES"
+            buildForProfiling = "YES"
+            buildForArchiving = "YES"
+            buildForAnalyzing = "YES">
+            <BuildableReference
+               BuildableIdentifier = "primary"
+               BlueprintIdentifier = "79C040AFDDCE1BCBF6D8B5EB0B85887F"
+               BuildableName = "Alamofire.framework"
+               BlueprintName = "Alamofire"
+               ReferencedContainer = "container:Pods.xcodeproj">
+            </BuildableReference>
+         </BuildActionEntry>
+      </BuildActionEntries>
+   </BuildAction>
+   <TestAction
+      buildConfiguration = "Debug"
+      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
+      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
+      shouldUseLaunchSchemeArgsEnv = "YES">
+      <Testables>
+      </Testables>
+      <AdditionalOptions>
+      </AdditionalOptions>
+   </TestAction>
+   <LaunchAction
+      buildConfiguration = "Debug"
+      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
+      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
+      launchStyle = "0"
+      useCustomWorkingDirectory = "NO"
+      ignoresPersistentStateOnLaunch = "NO"
+      debugDocumentVersioning = "YES"
+      debugServiceExtension = "internal"
+      allowLocationSimulation = "YES">
+      <MacroExpansion>
+         <BuildableReference
+            BuildableIdentifier = "primary"
+            BlueprintIdentifier = "79C040AFDDCE1BCBF6D8B5EB0B85887F"
+            BuildableName = "Alamofire.framework"
+            BlueprintName = "Alamofire"
+            ReferencedContainer = "container:Pods.xcodeproj">
+         </BuildableReference>
+      </MacroExpansion>
+      <AdditionalOptions>
+      </AdditionalOptions>
+   </LaunchAction>
+   <ProfileAction
+      buildConfiguration = "Release"
+      shouldUseLaunchSchemeArgsEnv = "YES"
+      savedToolIdentifier = ""
+      useCustomWorkingDirectory = "NO"
+      debugDocumentVersioning = "YES">
+      <MacroExpansion>
+         <BuildableReference
+            BuildableIdentifier = "primary"
+            BlueprintIdentifier = "79C040AFDDCE1BCBF6D8B5EB0B85887F"
+            BuildableName = "Alamofire.framework"
+            BlueprintName = "Alamofire"
+            ReferencedContainer = "container:Pods.xcodeproj">
+         </BuildableReference>
+      </MacroExpansion>
+   </ProfileAction>
+   <AnalyzeAction
+      buildConfiguration = "Debug">
+   </AnalyzeAction>
+   <ArchiveAction
+      buildConfiguration = "Release"
+      revealArchiveInOrganizer = "YES">
+   </ArchiveAction>
+</Scheme>
diff --git a/Pods/Pods.xcodeproj/xcuserdata/hanbiro.xcuserdatad/xcschemes/Pods-CRMCall092016.xcscheme b/Pods/Pods.xcodeproj/xcuserdata/hanbiro.xcuserdatad/xcschemes/Pods-CRMCall092016.xcscheme
index bcfec86..03cb029 100644
--- a/Pods/Pods.xcodeproj/xcuserdata/hanbiro.xcuserdatad/xcschemes/Pods-CRMCall092016.xcscheme
+++ b/Pods/Pods.xcodeproj/xcuserdata/hanbiro.xcuserdatad/xcschemes/Pods-CRMCall092016.xcscheme
@@ -14,7 +14,7 @@
             buildForAnalyzing = "YES">
             <BuildableReference
                BuildableIdentifier = "primary"
-               BlueprintIdentifier = "ED9EA20B7A8CD0AA34A09F4F5CB87BEB"
+               BlueprintIdentifier = "6DC3AF9E2B939DEDE599F677CB6A2DFC"
                BuildableName = "Pods_CRMCall092016.framework"
                BlueprintName = "Pods-CRMCall092016"
                ReferencedContainer = "container:Pods.xcodeproj">
@@ -45,7 +45,7 @@
       <MacroExpansion>
          <BuildableReference
             BuildableIdentifier = "primary"
-            BlueprintIdentifier = "ED9EA20B7A8CD0AA34A09F4F5CB87BEB"
+            BlueprintIdentifier = "6DC3AF9E2B939DEDE599F677CB6A2DFC"
             BuildableName = "Pods_CRMCall092016.framework"
             BlueprintName = "Pods-CRMCall092016"
             ReferencedContainer = "container:Pods.xcodeproj">
@@ -63,7 +63,7 @@
       <MacroExpansion>
          <BuildableReference
             BuildableIdentifier = "primary"
-            BlueprintIdentifier = "ED9EA20B7A8CD0AA34A09F4F5CB87BEB"
+            BlueprintIdentifier = "6DC3AF9E2B939DEDE599F677CB6A2DFC"
             BuildableName = "Pods_CRMCall092016.framework"
             BlueprintName = "Pods-CRMCall092016"
             ReferencedContainer = "container:Pods.xcodeproj">
diff --git a/Pods/Pods.xcodeproj/xcuserdata/hanbiro.xcuserdatad/xcschemes/SWXMLHash 2.xcscheme b/Pods/Pods.xcodeproj/xcuserdata/hanbiro.xcuserdatad/xcschemes/SWXMLHash 2.xcscheme
new file mode 100644
index 0000000..4903aa6
--- /dev/null
+++ b/Pods/Pods.xcodeproj/xcuserdata/hanbiro.xcuserdatad/xcschemes/SWXMLHash 2.xcscheme	
@@ -0,0 +1,80 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<Scheme
+   LastUpgradeVersion = "0730"
+   version = "1.3">
+   <BuildAction
+      parallelizeBuildables = "YES"
+      buildImplicitDependencies = "YES">
+      <BuildActionEntries>
+         <BuildActionEntry
+            buildForTesting = "YES"
+            buildForRunning = "YES"
+            buildForProfiling = "YES"
+            buildForArchiving = "YES"
+            buildForAnalyzing = "YES">
+            <BuildableReference
+               BuildableIdentifier = "primary"
+               BlueprintIdentifier = "67C63D588DA997BFF7D3C999DA7A5A23"
+               BuildableName = "SWXMLHash.framework"
+               BlueprintName = "SWXMLHash"
+               ReferencedContainer = "container:Pods.xcodeproj">
+            </BuildableReference>
+         </BuildActionEntry>
+      </BuildActionEntries>
+   </BuildAction>
+   <TestAction
+      buildConfiguration = "Debug"
+      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
+      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
+      shouldUseLaunchSchemeArgsEnv = "YES">
+      <Testables>
+      </Testables>
+      <AdditionalOptions>
+      </AdditionalOptions>
+   </TestAction>
+   <LaunchAction
+      buildConfiguration = "Debug"
+      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
+      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
+      launchStyle = "0"
+      useCustomWorkingDirectory = "NO"
+      ignoresPersistentStateOnLaunch = "NO"
+      debugDocumentVersioning = "YES"
+      debugServiceExtension = "internal"
+      allowLocationSimulation = "YES">
+      <MacroExpansion>
+         <BuildableReference
+            BuildableIdentifier = "primary"
+            BlueprintIdentifier = "67C63D588DA997BFF7D3C999DA7A5A23"
+            BuildableName = "SWXMLHash.framework"
+            BlueprintName = "SWXMLHash"
+            ReferencedContainer = "container:Pods.xcodeproj">
+         </BuildableReference>
+      </MacroExpansion>
+      <AdditionalOptions>
+      </AdditionalOptions>
+   </LaunchAction>
+   <ProfileAction
+      buildConfiguration = "Release"
+      shouldUseLaunchSchemeArgsEnv = "YES"
+      savedToolIdentifier = ""
+      useCustomWorkingDirectory = "NO"
+      debugDocumentVersioning = "YES">
+      <MacroExpansion>
+         <BuildableReference
+            BuildableIdentifier = "primary"
+            BlueprintIdentifier = "67C63D588DA997BFF7D3C999DA7A5A23"
+            BuildableName = "SWXMLHash.framework"
+            BlueprintName = "SWXMLHash"
+            ReferencedContainer = "container:Pods.xcodeproj">
+         </BuildableReference>
+      </MacroExpansion>
+   </ProfileAction>
+   <AnalyzeAction
+      buildConfiguration = "Debug">
+   </AnalyzeAction>
+   <ArchiveAction
+      buildConfiguration = "Release"
+      revealArchiveInOrganizer = "YES">
+   </ArchiveAction>
+</Scheme>
diff --git a/Pods/Pods.xcodeproj/xcuserdata/hanbiro.xcuserdatad/xcschemes/SWXMLHash.xcscheme b/Pods/Pods.xcodeproj/xcuserdata/hanbiro.xcuserdatad/xcschemes/SWXMLHash.xcscheme
new file mode 100644
index 0000000..9a1df9b
--- /dev/null
+++ b/Pods/Pods.xcodeproj/xcuserdata/hanbiro.xcuserdatad/xcschemes/SWXMLHash.xcscheme
@@ -0,0 +1,46 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<Scheme
+   LastUpgradeVersion = "0730"
+   version = "1.3">
+   <BuildAction
+      parallelizeBuildables = "YES"
+      buildImplicitDependencies = "YES">
+   </BuildAction>
+   <TestAction
+      buildConfiguration = "Debug"
+      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
+      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
+      shouldUseLaunchSchemeArgsEnv = "YES">
+      <Testables>
+      </Testables>
+      <AdditionalOptions>
+      </AdditionalOptions>
+   </TestAction>
+   <LaunchAction
+      buildConfiguration = "Debug"
+      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
+      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
+      launchStyle = "0"
+      useCustomWorkingDirectory = "NO"
+      ignoresPersistentStateOnLaunch = "NO"
+      debugDocumentVersioning = "YES"
+      debugServiceExtension = "internal"
+      allowLocationSimulation = "YES">
+      <AdditionalOptions>
+      </AdditionalOptions>
+   </LaunchAction>
+   <ProfileAction
+      buildConfiguration = "Release"
+      shouldUseLaunchSchemeArgsEnv = "YES"
+      savedToolIdentifier = ""
+      useCustomWorkingDirectory = "NO"
+      debugDocumentVersioning = "YES">
+   </ProfileAction>
+   <AnalyzeAction
+      buildConfiguration = "Debug">
+   </AnalyzeAction>
+   <ArchiveAction
+      buildConfiguration = "Release"
+      revealArchiveInOrganizer = "YES">
+   </ArchiveAction>
+</Scheme>
diff --git a/Pods/Pods.xcodeproj/xcuserdata/hanbiro.xcuserdatad/xcschemes/xcschememanagement.plist b/Pods/Pods.xcodeproj/xcuserdata/hanbiro.xcuserdatad/xcschemes/xcschememanagement.plist
index 91212f6..18f8564 100644
--- a/Pods/Pods.xcodeproj/xcuserdata/hanbiro.xcuserdatad/xcschemes/xcschememanagement.plist
+++ b/Pods/Pods.xcodeproj/xcuserdata/hanbiro.xcuserdatad/xcschemes/xcschememanagement.plist
@@ -4,6 +4,11 @@
 <dict>
 	<key>SchemeUserState</key>
 	<dict>
+		<key>Alamofire.xcscheme</key>
+		<dict>
+			<key>orderHint</key>
+			<integer>4</integer>
+		</dict>
 		<key>CocoaAsyncSocket.xcscheme</key>
 		<dict>
 			<key>orderHint</key>
@@ -14,9 +19,49 @@
 			<key>orderHint</key>
 			<integer>2</integer>
 		</dict>
+		<key>SWXMLHash 2.xcscheme</key>
+		<dict>
+			<key>orderHint</key>
+			<integer>5</integer>
+		</dict>
+		<key>SWXMLHash.xcscheme</key>
+		<dict>
+			<key>orderHint</key>
+			<integer>3</integer>
+		</dict>
 	</dict>
 	<key>SuppressBuildableAutocreation</key>
 	<dict>
+		<key>67C63D588DA997BFF7D3C999DA7A5A23</key>
+		<dict>
+			<key>primary</key>
+			<true/>
+		</dict>
+		<key>6A0818B9C68C8B9F82A2B6E85576006B</key>
+		<dict>
+			<key>primary</key>
+			<true/>
+		</dict>
+		<key>6DC3AF9E2B939DEDE599F677CB6A2DFC</key>
+		<dict>
+			<key>primary</key>
+			<true/>
+		</dict>
+		<key>6FF4900D90DA59447E562D6888408670</key>
+		<dict>
+			<key>primary</key>
+			<true/>
+		</dict>
+		<key>79C040AFDDCE1BCBF6D8B5EB0B85887F</key>
+		<dict>
+			<key>primary</key>
+			<true/>
+		</dict>
+		<key>B146E7512E9CA5F0BB2EDF3F86841CA4</key>
+		<dict>
+			<key>primary</key>
+			<true/>
+		</dict>
 		<key>B37E19CA872A7535725D1E1946E5C271</key>
 		<dict>
 			<key>primary</key>
diff --git a/Pods/SWXMLHash/LICENSE b/Pods/SWXMLHash/LICENSE
new file mode 100644
index 0000000..3d21445
--- /dev/null
+++ b/Pods/SWXMLHash/LICENSE
@@ -0,0 +1,20 @@
+Copyright (c) 2014 David Mohundro
+ 
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+ 
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+ 
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/Pods/SWXMLHash/README.md b/Pods/SWXMLHash/README.md
new file mode 100644
index 0000000..25e83a6
--- /dev/null
+++ b/Pods/SWXMLHash/README.md
@@ -0,0 +1,387 @@
+# SWXMLHash
+
+[![CocoaPods](https://img.shields.io/cocoapods/p/SWXMLHash.svg)]()
+[![Carthage compatible](https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat)](https://github.com/Carthage/Carthage)
+[![CocoaPods](https://img.shields.io/cocoapods/v/SWXMLHash.svg)](https://cocoapods.org/pods/SWXMLHash)
+[![Join the chat at https://gitter.im/drmohundro/SWXMLHash](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/drmohundro/SWXMLHash?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)
+[![codebeat](https://codebeat.co/badges/893cc640-c5d9-45b2-a3ff-426e6e6b7b80)](https://codebeat.co/projects/github-com-drmohundro-swxmlhash)
+
+SWXMLHash is a relatively simple way to parse XML in Swift. If you're familiar with `NSXMLParser`, this library is a simple wrapper around it. Conceptually, it provides a translation from XML to a dictionary of arrays (aka hash).
+
+The API takes a lot of inspiration from [SwiftyJSON](https://github.com/SwiftyJSON/SwiftyJSON).
+
+## Contents
+
+* [Requirements](#requirements)
+* [Installation](#installation)
+* [Getting Started](#getting-started)
+* [Configuration](#configuration)
+* [Examples](#examples)
+* [FAQ](#faq)
+* [Changelog](#changelog)
+* [Contributing](#contributing)
+* [License](#license)
+
+## Requirements
+
+- iOS 8.0+ / Mac OS X 10.9+ / tvOS 9.0+ / watchOS 2.0+
+- Xcode 7.1+
+
+(note that Xcode 8 beta and Swift 3 support are being tracked in [PR 78](https://github.com/drmohundro/SWXMLHash/pull/78))
+
+## Installation
+
+SWXMLHash can be installed using [CocoaPods](http://cocoapods.org/), [Carthage](https://github.com/Carthage/Carthage), or manually.
+
+### CocoaPods
+
+To install CocoaPods, run:
+
+```bash
+$ gem install cocoapods
+```
+
+Then create a `Podfile` with the following contents:
+
+```ruby
+source 'https://github.com/CocoaPods/Specs.git'
+platform :ios, '8.0'
+
+pod 'SWXMLHash', '~> 2.4.0'
+```
+
+Finally, run the following command to install it:
+
+```bash
+$ pod install
+```
+
+### Carthage
+
+To install Carthage, run (using Homebrew):
+
+```bash
+$ brew update
+$ brew install carthage
+```
+
+Then add the following line to your `Cartfile`:
+
+```
+github "drmohundro/SWXMLHash" ~> 2.3
+```
+
+### Manual Installation
+
+To install manually, you'll need to clone the SWXMLHash repository. You can do this in a separate directory or you can make use of git submodules - in this case, git submodules are recommended so that your repository has details about which commit of SWXMLHash you're using. Once this is done, you can just drop the `SWXMLHash.swift` file into your project.
+
+> NOTE: if you're targeting iOS 7, you'll have to install manually because embedded frameworks require a minimum deployment target of iOS 8 or OSX Mavericks.
+
+## Getting Started
+
+If you're just getting started with SWXMLHash, I'd recommend cloning the repository down and opening the workspace. I've included a Swift playground in the workspace which makes it *very* easy to experiment with the API and the calls.
+
+<img src="https://raw.githubusercontent.com/drmohundro/SWXMLHash/assets/swift-playground@2x.png" width="600" alt="Swift Playground" />
+
+## Configuration
+
+SWXMLHash allows for limited configuration in terms of its approach to parsing. To set any of the configuration options, you use the `configure` method, like so:
+
+```swift
+let xml = SWXMLHash.config {
+              config in
+              // set any config options here
+          }.parse(xmlToParse)
+```
+
+The available options at this time are:
+
+* `shouldProcessLazily`
+    * This determines whether not to use lazy loading of the XML. It can significantly increase the performance of parsing if your XML is very large.
+    * Defaults to `false`
+* `shouldProcessNamespaces`
+    * This setting is forwarded on to the internal `NSXMLParser` instance. It will return any XML elements without their namespace parts (i.e. "\<h:table\>" will be returned as "\<table\>")
+    * Defaults to `false`
+
+## Examples
+
+All examples below can be found in the included [specs](https://github.com/drmohundro/SWXMLHash/blob/master/Tests/SWXMLHashSpecs.swift).
+
+### Initialization
+
+```swift
+let xml = SWXMLHash.parse(xmlToParse)
+```
+
+Alternatively, if you're parsing a large XML file and need the best performance, you may wish to configure the parsing to be processed lazily. Lazy processing avoids loading the entire XML document into memory, so it could be preferable for performance reasons. See the error handling for one caveat regarding lazy loading.
+
+```swift
+let xml = SWXMLHash.config {
+              config in
+              config.shouldProcessLazily = true
+          }.parse(xmlToParse)
+```
+
+The above approach uses the new config method, but there is also a `lazy` method directly off of `SWXMLHash`.
+
+```swift
+let xml = SWXMLHash.lazy(xmlToParse)
+```
+
+### Single Element Lookup
+
+Given:
+
+```xml
+<root>
+  <header>
+    <title>Foo</title>
+  </header>
+  ...
+</root>
+```
+
+Will return "Foo".
+
+```swift
+xml["root"]["header"]["title"].element?.text
+```
+
+### Multiple Elements Lookup
+
+Given:
+
+```xml
+<root>
+  ...
+  <catalog>
+    <book><author>Bob</author></book>
+    <book><author>John</author></book>
+    <book><author>Mark</author></book>
+  </catalog>
+  ...
+</root>
+```
+
+The below will return "John".
+
+```swift
+xml["root"]["catalog"]["book"][1]["author"].element?.text
+```
+
+### Attributes Usage
+
+Given:
+
+```xml
+<root>
+  ...
+  <catalog>
+    <book id="1"><author>Bob</author></book>
+    <book id="123"><author>John</author></book>
+    <book id="456"><author>Mark</author></book>
+  </catalog>
+  ...
+</root>
+```
+
+The below will return "123".
+
+```swift
+xml["root"]["catalog"]["book"][1].element?.attributes["id"]
+```
+
+Alternatively, you can look up an element with specific attributes. The below will return "John".
+
+```swift
+xml["root"]["catalog"]["book"].withAttr("id", "123")["author"].element?.text
+```
+
+### Returning All Elements At Current Level
+
+Given:
+
+```xml
+<root>
+  ...
+  <catalog>
+    <book><genre>Fiction</genre></book>
+    <book><genre>Non-fiction</genre></book>
+    <book><genre>Technical</genre></book>
+  </catalog>
+  ...
+</root>
+```
+
+The below will return "Fiction, Non-fiction, Technical" (note the `all` method).
+
+```swift
+", ".join(xml["root"]["catalog"]["book"].all.map { elem in
+  elem["genre"].element!.text!
+})
+```
+
+Alternatively, you can just iterate over the elements using `for-in` directly against an element.
+
+```swift
+for elem in xml["root"]["catalog"]["book"] {
+  NSLog(elem["genre"].element!.text!)
+}
+```
+
+### Returning All Child Elements At Current Level
+
+Given:
+
+```xml
+<root>
+  <catalog>
+    <book>
+      <genre>Fiction</genre>
+      <title>Book</title>
+      <date>1/1/2015</date>
+    </book>
+  </catalog>
+</root>
+```
+
+The below will `NSLog` "root", "catalog", "book", "genre", "title", and "date" (note the `children` method).
+
+```swift
+func enumerate(indexer: XMLIndexer) {
+  for child in indexer.children {
+    NSLog(child.element!.name)
+    enumerate(child)
+  }
+}
+
+enumerate(xml)
+```
+
+### Error Handling
+
+Using Swift 2.0's new error handling feature:
+
+```swift
+do {
+  try xml!.byKey("root").byKey("what").byKey("header").byKey("foo")
+} catch let error as XMLIndexer.Error {
+  // error is an XMLIndexer.Error instance that you can deal with
+}
+```
+
+__Or__ using the existing indexing functionality (__NOTE__ that the `.Error` case has been renamed to `.XMLError` so as to not conflict with the `XMLIndexer.Error` error type):
+
+```swift
+switch xml["root"]["what"]["header"]["foo"] {
+case .Element(let elem):
+  // everything is good, code away!
+case .XMLError(let error):
+  // error is an XMLIndexer.Error instance that you can deal with
+}
+```
+
+Note that error handling as shown above will not work with lazy loaded XML. The lazy parsing doesn't actually occur until the `element` or `all` method are called - as a result, there isn't any way to know prior to asking for an element if it exists or not.
+
+### Types conversion
+
+Given:
+
+```xml
+<root>
+  <books>
+    <book>
+      <title>Book A</title>
+      <price>12.5</price>
+      <year>2015</year>
+    </book>
+    <book>
+      <title>Book B</title>
+      <price>10</price>
+      <year>1988</year>
+    </book>
+    <book>
+      <title>Book C</title>
+      <price>8.33</price>
+      <year>1990</year>
+      <amount>10</amount>
+    </book>
+  <books>
+</root>
+```
+with `Book` struct implementing `XMLIndexerDeserializable`:
+
+```swift
+struct Book: XMLIndexerDeserializable {
+    let title: String
+    let price: Double
+    let year: Int
+    let amount: Int?
+
+    static func deserialize(node: XMLIndexer) throws -> Book {
+        return try Book(
+            title: node["title"].value(),
+            price: node["price"].value(),
+            year: node["year"].value(),
+            amount: node["amount"].value()
+        )
+    }
+}
+```
+
+The below will return array of `Book` structs:
+
+```swift
+let books: [Book] = try xml["root"]["books"]["book"].value()
+```
+
+<img src="https://raw.githubusercontent.com/ncreated/SWXMLHash/assets/types-conversion%402x.png" width="600" alt="Types Conversion" />
+
+Built-in, leaf-nodes converters support `Int`, `Double`, `Float`, `Bool`, and `String` values (both non- and -optional variants). Custom converters can be added by implementing `XMLElementDeserializable`.
+
+You can convert any XML to your custom type by implementing `XMLIndexerDeserializable`.
+
+Types conversion supports error handling, optionals and arrays. For more examples, look into `SWXMLHashTests.swift` or play with types conversion directly in the Swift playground.
+
+
+## FAQ
+
+### Does SWXMLHash handle URLs for me?
+
+No - SWXMLHash only handles parsing of XML. If you have a URL that has XML content on it, I'd recommend using a library like [AlamoFire](https://github.com/Alamofire/Alamofire) to download the content into a string and then parsing it.
+
+### Does SWXMLHash support writing XML content?
+
+No, not at the moment - SWXMLHash only supports parsing XML (via indexing, deserialization, etc.).
+
+### I'm getting an "Ambiguous reference to member 'subscript'" when I call `.value()`.
+
+`.value()` is used for deserialization - you have to have something that implements `XMLIndexerDeserializable` and that can handle deserialization to the left-hand side of expression.
+
+For example, given the following:
+
+```swift
+let dateValue: NSDate = try! xml["root"]["date"].value()
+```
+
+You'll get an error because there isn't any built-in deserializer for `NSDate`. See the above documentation on adding your own deserialization support.
+
+### I'm getting an `EXC_BAD_ACCESS (SIGSEGV)` when I call `parse()`
+
+Chances are very good that your XML content has what is called a "byte order mark" or BOM. SWXMLHash uses `NSXMLParser` for its parsing logic and there are issues with it and handling BOM characters. See [issue #65](https://github.com/drmohundro/SWXMLHash/issues/65) for more details. Others who have run into this problem have just rstripped the BOM out of their content prior to parsing.
+
+### Have a different question?
+
+Feel free to shoot me an email, post a [question on StackOverflow](http://stackoverflow.com/questions/tagged/swxmlhash), or open an issue if you think you've found a bug. I'm happy to try to help!
+
+## Changelog
+
+See [CHANGELOG](CHANGELOG.md) for a list of all changes and their corresponding versions.
+
+## Contributing
+
+See [CONTRIBUTING](CONTRIBUTING.md) for guidelines to contribute back to SWXMLHash.
+
+## License
+
+SWXMLHash is released under the MIT license. See [LICENSE](LICENSE) for details.
diff --git a/Pods/SWXMLHash/Source/SWXMLHash+TypeConversion.swift b/Pods/SWXMLHash/Source/SWXMLHash+TypeConversion.swift
new file mode 100644
index 0000000..a4e1bef
--- /dev/null
+++ b/Pods/SWXMLHash/Source/SWXMLHash+TypeConversion.swift
@@ -0,0 +1,364 @@
+//
+//  SWXMLHash+TypeConversion.swift
+//  SWXMLHash
+//
+//  Created by Maciek Grzybowski on 29.02.2016.
+//
+//
+
+import Foundation
+
+// MARK: - XMLIndexerDeserializable
+
+/// Provides XMLIndexer deserialization / type transformation support
+public protocol XMLIndexerDeserializable {
+    static func deserialize(element: XMLIndexer) throws -> Self
+}
+
+/// Provides XMLIndexer deserialization / type transformation support
+public extension XMLIndexerDeserializable {
+    /**
+    A default implementation that will throw an error if it is called
+
+    - parameters:
+        - element: the XMLIndexer to be deserialized
+    - throws: an XMLDeserializationError.ImplementationIsMissing if no implementation is found
+    - returns: this won't ever return because of the error being thrown
+    */
+    static func deserialize(element: XMLIndexer) throws -> Self {
+        throw XMLDeserializationError.ImplementationIsMissing(
+            method: "XMLIndexerDeserializable.deserialize(element: XMLIndexer)")
+    }
+}
+
+
+// MARK: - XMLElementDeserializable
+
+/// Provides XMLElement deserialization / type transformation support
+public protocol XMLElementDeserializable {
+    static func deserialize(element: XMLElement) throws -> Self
+}
+
+/// Provides XMLElement deserialization / type transformation support
+public extension XMLElementDeserializable {
+    /**
+    A default implementation that will throw an error if it is called
+
+    - parameters:
+        - element: the XMLElement to be deserialized
+    - throws: an XMLDeserializationError.ImplementationIsMissing if no implementation is found
+    - returns: this won't ever return because of the error being thrown
+    */
+    static func deserialize(element: XMLElement) throws -> Self {
+        throw XMLDeserializationError.ImplementationIsMissing(
+            method: "XMLElementDeserializable.deserialize(element: XMLElement)")
+    }
+}
+
+
+public extension XMLIndexer {
+
+    // MARK: - XMLElementDeserializable
+
+    /**
+    Attempts to deserialize the current XMLElement element to `T`
+
+    - throws: an XMLDeserializationError.NodeIsInvalid if the current indexed level isn't an Element
+    - returns: the deserialized `T` value
+    */
+    func value<T: XMLElementDeserializable>() throws -> T {
+        switch self {
+        case .Element(let element):
+            return try T.deserialize(element)
+        case .Stream(let opStream):
+            return try! opStream.findElements().value()
+        default:
+            throw XMLDeserializationError.NodeIsInvalid(node: self)
+        }
+    }
+
+    /**
+    Attempts to deserialize the current XMLElement element to `T?`
+
+    - returns: the deserialized `T?` value
+    - throws: an XMLDeserializationError is there is a problem with deserialization
+    */
+    func value<T: XMLElementDeserializable>() throws -> T? {
+        switch self {
+        case .Element(let element):
+            return try T.deserialize(element)
+        case .Stream(let opStream):
+            return try! opStream.findElements().value()
+        default:
+            return nil
+        }
+    }
+
+    /**
+    Attempts to deserialize the current XMLElement element to `[T]`
+
+    - returns: the deserialized `[T]` value
+    - throws: an XMLDeserializationError is there is a problem with deserialization
+    */
+    func value<T: XMLElementDeserializable>() throws -> [T] {
+        switch self {
+        case .List(let elements):
+            return try elements.map { try T.deserialize($0) }
+        case .Element(let element):
+            return try [element].map { try T.deserialize($0) }
+        case .Stream(let opStream):
+            return try! opStream.findElements().value()
+        default:
+            return []
+        }
+    }
+
+    /**
+    Attempts to deserialize the current XMLElement element to `[T]?`
+
+    - returns: the deserialized `[T]?` value
+    - throws: an XMLDeserializationError is there is a problem with deserialization
+    */
+    func value<T: XMLElementDeserializable>() throws -> [T]? {
+        switch self {
+        case .List(let elements):
+            return try elements.map { try T.deserialize($0) }
+        case .Element(let element):
+            return try [element].map { try T.deserialize($0) }
+        case .Stream(let opStream):
+            return try! opStream.findElements().value()
+        default:
+            return nil
+        }
+    }
+
+    /**
+    Attempts to deserialize the current XMLElement element to `[T?]`
+
+    - returns: the deserialized `[T?]` value
+    - throws: an XMLDeserializationError is there is a problem with deserialization
+    */
+    func value<T: XMLElementDeserializable>() throws -> [T?] {
+        switch self {
+        case .List(let elements):
+            return try elements.map { try T.deserialize($0) }
+        case .Element(let element):
+            return try [element].map { try T.deserialize($0) }
+        case .Stream(let opStream):
+            return try! opStream.findElements().value()
+        default:
+            return []
+        }
+    }
+
+
+    // MARK: - XMLIndexerDeserializable
+
+    /**
+    Attempts to deserialize the current XMLIndexer element to `T`
+
+    - returns: the deserialized `T` value
+    - throws: an XMLDeserializationError is there is a problem with deserialization
+    */
+    func value<T: XMLIndexerDeserializable>() throws -> T {
+        switch self {
+        case .Element:
+            return try T.deserialize(self)
+        case .Stream(let opStream):
+            return try! opStream.findElements().value()
+        default:
+            throw XMLDeserializationError.NodeIsInvalid(node: self)
+        }
+    }
+
+    /**
+    Attempts to deserialize the current XMLIndexer element to `T?`
+
+    - returns: the deserialized `T?` value
+    - throws: an XMLDeserializationError is there is a problem with deserialization
+    */
+    func value<T: XMLIndexerDeserializable>() throws -> T? {
+        switch self {
+        case .Element:
+            return try T.deserialize(self)
+        case .Stream(let opStream):
+            return try! opStream.findElements().value()
+        default:
+            return nil
+        }
+    }
+
+    /**
+    Attempts to deserialize the current XMLIndexer element to `[T]`
+
+    - returns: the deserialized `[T]` value
+    - throws: an XMLDeserializationError is there is a problem with deserialization
+    */
+    func value<T where T: XMLIndexerDeserializable>() throws -> [T] {
+        switch self {
+        case .List(let elements):
+            return try elements.map { try T.deserialize( XMLIndexer($0) ) }
+        case .Element(let element):
+            return try [element].map { try T.deserialize( XMLIndexer($0) ) }
+        case .Stream(let opStream):
+            return try! opStream.findElements().value()
+        default:
+            throw XMLDeserializationError.NodeIsInvalid(node: self)
+        }
+    }
+
+    /**
+    Attempts to deserialize the current XMLIndexer element to `[T]?`
+
+    - returns: the deserialized `[T]?` value
+    - throws: an XMLDeserializationError is there is a problem with deserialization
+    */
+    func value<T: XMLIndexerDeserializable>() throws -> [T]? {
+        switch self {
+        case .List(let elements):
+            return try elements.map { try T.deserialize( XMLIndexer($0) ) }
+        case .Element(let element):
+            return try [element].map { try T.deserialize( XMLIndexer($0) ) }
+        case .Stream(let opStream):
+            return try! opStream.findElements().value()
+        default:
+            throw XMLDeserializationError.NodeIsInvalid(node: self)
+        }
+    }
+
+    /**
+    Attempts to deserialize the current XMLIndexer element to `[T?]`
+
+    - returns: the deserialized `[T?]` value
+    - throws: an XMLDeserializationError is there is a problem with deserialization
+    */
+    func value<T: XMLIndexerDeserializable>() throws -> [T?] {
+        switch self {
+        case .List(let elements):
+            return try elements.map {  try T.deserialize( XMLIndexer($0) ) }
+        case .Element(let element):
+            return try [element].map { try T.deserialize( XMLIndexer($0) ) }
+        case .Stream(let opStream):
+            return try! opStream.findElements().value()
+        default:
+            throw XMLDeserializationError.NodeIsInvalid(node: self)
+        }
+    }
+}
+
+private extension XMLElement {
+    func nonEmptyTextOrThrow() throws -> String {
+        if let text = self.text where !text.characters.isEmpty {
+            return text
+        } else { throw XMLDeserializationError.NodeHasNoValue }
+    }
+}
+
+/// The error that is thrown if there is a problem with deserialization
+public enum XMLDeserializationError: ErrorType, CustomStringConvertible {
+    case ImplementationIsMissing(method: String)
+    case NodeIsInvalid(node: XMLIndexer)
+    case NodeHasNoValue
+    case TypeConversionFailed(type: String, element: XMLElement)
+
+    /// The text description for the error thrown
+    public var description: String {
+        switch self {
+        case .ImplementationIsMissing(let method):
+            return "This deserialization method is not implemented: \(method)"
+        case .NodeIsInvalid(let node):
+            return "This node is invalid: \(node)"
+        case .NodeHasNoValue:
+            return "This node is empty"
+        case .TypeConversionFailed(let type, let node):
+            return "Can't convert node \(node) to value of type \(type)"
+        }
+    }
+}
+
+
+// MARK: - Common types deserialization
+
+extension String: XMLElementDeserializable {
+    /**
+    Attempts to deserialize XML element content to a String
+
+    - parameters:
+        - element: the XMLElement to be deserialized
+    - throws: an XMLDeserializationError.TypeConversionFailed if the element cannot be deserialized
+    - returns: the deserialized String value
+    */
+    public static func deserialize(element: XMLElement) throws -> String {
+        guard let text = element.text
+        else {
+            throw XMLDeserializationError.TypeConversionFailed(type: "String", element: element)
+        }
+        return text
+    }
+}
+
+extension Int: XMLElementDeserializable {
+    /**
+    Attempts to deserialize XML element content to a Int
+
+    - parameters:
+        - element: the XMLElement to be deserialized
+    - throws: an XMLDeserializationError.TypeConversionFailed if the element cannot be deserialized
+    - returns: the deserialized Int value
+    */
+    public static func deserialize(element: XMLElement) throws -> Int {
+        guard let value = Int(try element.nonEmptyTextOrThrow())
+        else { throw XMLDeserializationError.TypeConversionFailed(type: "Int", element: element) }
+        return value
+    }
+}
+
+extension Double: XMLElementDeserializable {
+    /**
+    Attempts to deserialize XML element content to a Double
+
+    - parameters:
+        - element: the XMLElement to be deserialized
+    - throws: an XMLDeserializationError.TypeConversionFailed if the element cannot be deserialized
+    - returns: the deserialized Double value
+    */
+    public static func deserialize(element: XMLElement) throws -> Double {
+        guard let value = Double(try element.nonEmptyTextOrThrow())
+        else {
+            throw XMLDeserializationError.TypeConversionFailed(type: "Double", element: element)
+        }
+        return value
+    }
+}
+
+extension Float: XMLElementDeserializable {
+    /**
+    Attempts to deserialize XML element content to a Float
+
+    - parameters:
+        - element: the XMLElement to be deserialized
+    - throws: an XMLDeserializationError.TypeConversionFailed if the element cannot be deserialized
+    - returns: the deserialized Float value
+    */
+    public static func deserialize(element: XMLElement) throws -> Float {
+        guard let value = Float(try element.nonEmptyTextOrThrow())
+        else { throw XMLDeserializationError.TypeConversionFailed(type: "Float", element: element) }
+        return value
+    }
+}
+
+extension Bool: XMLElementDeserializable {
+    /**
+     Attempts to deserialize XML element content to a Bool. This uses NSString's 'boolValue' described
+     [here](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSString_Class/#//apple_ref/occ/instp/NSString/boolValue)
+
+     - parameters:
+     - element: the XMLElement to be deserialized
+     - throws: an XMLDeserializationError.TypeConversionFailed if the element cannot be deserialized
+     - returns: the deserialized Bool value
+     */
+    public static func deserialize(element: XMLElement) throws -> Bool {
+        let value = Bool(NSString(string: try element.nonEmptyTextOrThrow()).boolValue)
+        return value
+    }
+}
diff --git a/Pods/SWXMLHash/Source/SWXMLHash.swift b/Pods/SWXMLHash/Source/SWXMLHash.swift
new file mode 100644
index 0000000..da75fc9
--- /dev/null
+++ b/Pods/SWXMLHash/Source/SWXMLHash.swift
@@ -0,0 +1,732 @@
+//
+//  SWXMLHash.swift
+//
+//  Copyright (c) 2014 David Mohundro
+//
+//  Permission is hereby granted, free of charge, to any person obtaining a copy
+//  of this software and associated documentation files (the "Software"), to deal
+//  in the Software without restriction, including without limitation the rights
+//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+//  copies of the Software, and to permit persons to whom the Software is
+//  furnished to do so, subject to the following conditions:
+//
+//  The above copyright notice and this permission notice shall be included in
+//  all copies or substantial portions of the Software.
+//
+//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+//  THE SOFTWARE.
+
+// swiftlint exceptions:
+// - Disabled file_length because there are a number of users that still pull the
+//   source down as is and it makes pulling the code into a project easier.
+
+// swiftlint:disable file_length
+
+import Foundation
+
+let rootElementName = "SWXMLHash_Root_Element"
+
+/// Parser options
+public class SWXMLHashOptions {
+    internal init() {}
+
+    /// determines whether to parse the XML with lazy parsing or not
+    public var shouldProcessLazily = false
+
+    /// determines whether to parse XML namespaces or not (forwards to
+    /// `NSXMLParser.shouldProcessNamespaces`)
+    public var shouldProcessNamespaces = false
+}
+
+/// Simple XML parser
+public class SWXMLHash {
+    let options: SWXMLHashOptions
+
+    private init(_ options: SWXMLHashOptions = SWXMLHashOptions()) {
+        self.options = options
+    }
+
+    /**
+    Method to configure how parsing works.
+
+    - parameters:
+        - configAction: a block that passes in an `SWXMLHashOptions` object with
+        options to be set
+    - returns: an `SWXMLHash` instance
+    */
+    class public func config(configAction: (SWXMLHashOptions) -> ()) -> SWXMLHash {
+        let opts = SWXMLHashOptions()
+        configAction(opts)
+        return SWXMLHash(opts)
+    }
+
+    /**
+    Begins parsing the passed in XML string.
+
+    - parameters:
+        - xml: an XML string. __Note__ that this is not a URL but a
+        string containing XML.
+    - returns: an `XMLIndexer` instance that can be iterated over
+    */
+    public func parse(xml: String) -> XMLIndexer {
+        return parse((xml as NSString).dataUsingEncoding(NSUTF8StringEncoding)!)
+    }
+
+    /**
+    Begins parsing the passed in XML string.
+
+    - parameters:
+        - data: an `NSData` instance containing XML
+        - returns: an `XMLIndexer` instance that can be iterated over
+    */
+    public func parse(data: NSData) -> XMLIndexer {
+        let parser: SimpleXmlParser = options.shouldProcessLazily
+            ? LazyXMLParser(options)
+            : XMLParser(options)
+        return parser.parse(data)
+    }
+
+    /**
+    Method to parse XML passed in as a string.
+
+    - parameter xml: The XML to be parsed
+    - returns: An XMLIndexer instance that is used to look up elements in the XML
+    */
+    class public func parse(xml: String) -> XMLIndexer {
+        return SWXMLHash().parse(xml)
+    }
+
+    /**
+    Method to parse XML passed in as an NSData instance.
+
+    - parameter data: The XML to be parsed
+    - returns: An XMLIndexer instance that is used to look up elements in the XML
+    */
+    class public func parse(data: NSData) -> XMLIndexer {
+        return SWXMLHash().parse(data)
+    }
+
+    /**
+    Method to lazily parse XML passed in as a string.
+
+    - parameter xml: The XML to be parsed
+    - returns: An XMLIndexer instance that is used to look up elements in the XML
+    */
+    class public func lazy(xml: String) -> XMLIndexer {
+        return config { conf in conf.shouldProcessLazily = true }.parse(xml)
+    }
+
+    /**
+    Method to lazily parse XML passed in as an NSData instance.
+
+    - parameter data: The XML to be parsed
+    - returns: An XMLIndexer instance that is used to look up elements in the XML
+    */
+    class public func lazy(data: NSData) -> XMLIndexer {
+        return config { conf in conf.shouldProcessLazily = true }.parse(data)
+    }
+}
+
+struct Stack<T> {
+    var items = [T]()
+    mutating func push(item: T) {
+        items.append(item)
+    }
+    mutating func pop() -> T {
+        return items.removeLast()
+    }
+    mutating func removeAll() {
+        items.removeAll(keepCapacity: false)
+    }
+    func top() -> T {
+        return items[items.count - 1]
+    }
+}
+
+protocol SimpleXmlParser {
+    init(_ options: SWXMLHashOptions)
+    func parse(data: NSData) -> XMLIndexer
+}
+
+/// The implementation of NSXMLParserDelegate and where the lazy parsing actually happens.
+class LazyXMLParser: NSObject, SimpleXmlParser, NSXMLParserDelegate {
+    required init(_ options: SWXMLHashOptions) {
+        self.options = options
+        super.init()
+    }
+
+    var root = XMLElement(name: rootElementName)
+    var parentStack = Stack<XMLElement>()
+    var elementStack = Stack<String>()
+
+    var data: NSData?
+    var ops: [IndexOp] = []
+    let options: SWXMLHashOptions
+
+    func parse(data: NSData) -> XMLIndexer {
+        self.data = data
+        return XMLIndexer(self)
+    }
+
+    func startParsing(ops: [IndexOp]) {
+        // clear any prior runs of parse... expected that this won't be necessary,
+        // but you never know
+        parentStack.removeAll()
+        root = XMLElement(name: rootElementName)
+        parentStack.push(root)
+
+        self.ops = ops
+        let parser = NSXMLParser(data: data!)
+        parser.shouldProcessNamespaces = options.shouldProcessNamespaces
+        parser.delegate = self
+        parser.parse()
+    }
+
+    func parser(parser: NSXMLParser,
+                didStartElement elementName: String,
+                namespaceURI: String?,
+                qualifiedName qName: String?,
+                attributes attributeDict: [String: String]) {
+
+        elementStack.push(elementName)
+
+        if !onMatch() {
+            return
+        }
+        let currentNode = parentStack.top().addElement(elementName, withAttributes: attributeDict)
+        parentStack.push(currentNode)
+    }
+
+    func parser(parser: NSXMLParser, foundCharacters string: String) {
+        if !onMatch() {
+            return
+        }
+
+        let current = parentStack.top()
+
+        current.addText(string)
+    }
+
+    func parser(parser: NSXMLParser,
+                didEndElement elementName: String,
+                namespaceURI: String?,
+                qualifiedName qName: String?) {
+
+        let match = onMatch()
+
+        elementStack.pop()
+
+        if match {
+            parentStack.pop()
+        }
+    }
+
+    func onMatch() -> Bool {
+        // we typically want to compare against the elementStack to see if it matches ops, *but*
+        // if we're on the first element, we'll instead compare the other direction.
+        if elementStack.items.count > ops.count {
+            return elementStack.items.startsWith(ops.map { $0.key })
+        } else {
+            return ops.map { $0.key }.startsWith(elementStack.items)
+        }
+    }
+}
+
+/// The implementation of NSXMLParserDelegate and where the parsing actually happens.
+class XMLParser: NSObject, SimpleXmlParser, NSXMLParserDelegate {
+    required init(_ options: SWXMLHashOptions) {
+        self.options = options
+        super.init()
+    }
+
+    var root = XMLElement(name: rootElementName)
+    var parentStack = Stack<XMLElement>()
+    let options: SWXMLHashOptions
+
+    func parse(data: NSData) -> XMLIndexer {
+        // clear any prior runs of parse... expected that this won't be necessary,
+        // but you never know
+        parentStack.removeAll()
+
+        parentStack.push(root)
+
+        let parser = NSXMLParser(data: data)
+        parser.shouldProcessNamespaces = options.shouldProcessNamespaces
+        parser.delegate = self
+        parser.parse()
+
+        return XMLIndexer(root)
+    }
+
+    func parser(parser: NSXMLParser,
+                didStartElement elementName: String,
+                namespaceURI: String?,
+                qualifiedName qName: String?,
+                attributes attributeDict: [String: String]) {
+
+        let currentNode = parentStack.top().addElement(elementName, withAttributes: attributeDict)
+        parentStack.push(currentNode)
+    }
+
+    func parser(parser: NSXMLParser, foundCharacters string: String) {
+        let current = parentStack.top()
+
+        current.addText(string)
+    }
+
+    func parser(parser: NSXMLParser,
+                didEndElement elementName: String,
+                namespaceURI: String?,
+                qualifiedName qName: String?) {
+
+        parentStack.pop()
+    }
+}
+
+/// Represents an indexed operation against a lazily parsed `XMLIndexer`
+public class IndexOp {
+    var index: Int
+    let key: String
+
+    init(_ key: String) {
+        self.key = key
+        self.index = -1
+    }
+
+    func toString() -> String {
+        if index >= 0 {
+            return key + " " + index.description
+        }
+
+        return key
+    }
+}
+
+/// Represents a collection of `IndexOp` instances. Provides a means of iterating them
+/// to find a match in a lazily parsed `XMLIndexer` instance.
+public class IndexOps {
+    var ops: [IndexOp] = []
+
+    let parser: LazyXMLParser
+
+    init(parser: LazyXMLParser) {
+        self.parser = parser
+    }
+
+    func findElements() -> XMLIndexer {
+        parser.startParsing(ops)
+        let indexer = XMLIndexer(parser.root)
+        var childIndex = indexer
+        for op in ops {
+            childIndex = childIndex[op.key]
+            if op.index >= 0 {
+                childIndex = childIndex[op.index]
+            }
+        }
+        ops.removeAll(keepCapacity: false)
+        return childIndex
+    }
+
+    func stringify() -> String {
+        var s = ""
+        for op in ops {
+            s += "[" + op.toString() + "]"
+        }
+        return s
+    }
+}
+
+/// Returned from SWXMLHash, allows easy element lookup into XML data.
+public enum XMLIndexer: SequenceType {
+    case Element(XMLElement)
+    case List([XMLElement])
+    case Stream(IndexOps)
+    case XMLError(Error)
+
+    /// Error type that is thrown when an indexing or parsing operation fails.
+    public enum Error: ErrorType {
+        case Attribute(attr: String)
+        case AttributeValue(attr: String, value: String)
+        case Key(key: String)
+        case Index(idx: Int)
+        case Init(instance: AnyObject)
+        case Error
+    }
+
+    /// The underlying XMLElement at the currently indexed level of XML.
+    public var element: XMLElement? {
+        switch self {
+        case .Element(let elem):
+            return elem
+        case .Stream(let ops):
+            let list = ops.findElements()
+            return list.element
+        default:
+            return nil
+        }
+    }
+
+    /// All elements at the currently indexed level
+    public var all: [XMLIndexer] {
+        switch self {
+        case .List(let list):
+            var xmlList = [XMLIndexer]()
+            for elem in list {
+                xmlList.append(XMLIndexer(elem))
+            }
+            return xmlList
+        case .Element(let elem):
+            return [XMLIndexer(elem)]
+        case .Stream(let ops):
+            let list = ops.findElements()
+            return list.all
+        default:
+            return []
+        }
+    }
+
+    /// All child elements from the currently indexed level
+    public var children: [XMLIndexer] {
+        var list = [XMLIndexer]()
+        for elem in all.map({ $0.element! }).flatMap({ $0 }) {
+            for elem in elem.xmlChildren {
+                list.append(XMLIndexer(elem))
+            }
+        }
+        return list
+    }
+
+    /**
+    Allows for element lookup by matching attribute values.
+
+    - parameters:
+        - attr: should the name of the attribute to match on
+        - value: should be the value of the attribute to match on
+    - throws: an XMLIndexer.XMLError if an element with the specified attribute isn't found
+    - returns: instance of XMLIndexer
+    */
+    public func withAttr(attr: String, _ value: String) throws -> XMLIndexer {
+        switch self {
+        case .Stream(let opStream):
+            let match = opStream.findElements()
+            return try match.withAttr(attr, value)
+        case .List(let list):
+            if let elem = list.filter({$0.attributes[attr] == value}).first {
+                return .Element(elem)
+            }
+            throw Error.AttributeValue(attr: attr, value: value)
+        case .Element(let elem):
+            if let attr = elem.attributes[attr] {
+                if attr == value {
+                    return .Element(elem)
+                }
+                throw Error.AttributeValue(attr: attr, value: value)
+            }
+            fallthrough
+        default:
+            throw Error.Attribute(attr: attr)
+        }
+    }
+
+    /**
+    Initializes the XMLIndexer
+
+    - parameter _: should be an instance of XMLElement, but supports other values for error handling
+    - throws: an Error if the object passed in isn't an XMLElement or LaxyXMLParser
+    */
+    public init(_ rawObject: AnyObject) throws {
+        switch rawObject {
+        case let value as XMLElement:
+            self = .Element(value)
+        case let value as LazyXMLParser:
+            self = .Stream(IndexOps(parser: value))
+        default:
+            throw Error.Init(instance: rawObject)
+        }
+    }
+
+    /**
+    Initializes the XMLIndexer
+
+    - parameter _: an instance of XMLElement
+    */
+    public init(_ elem: XMLElement) {
+        self = .Element(elem)
+    }
+
+    init(_ stream: LazyXMLParser) {
+        self = .Stream(IndexOps(parser: stream))
+    }
+
+    /**
+    Find an XML element at the current level by element name
+
+    - parameter key: The element name to index by
+    - returns: instance of XMLIndexer to match the element (or elements) found by key
+    - throws: Throws an XMLIndexerError.Key if no element was found
+    */
+    public func byKey(key: String) throws -> XMLIndexer {
+        switch self {
+        case .Stream(let opStream):
+            let op = IndexOp(key)
+            opStream.ops.append(op)
+            return .Stream(opStream)
+        case .Element(let elem):
+            let match = elem.xmlChildren.filter({ $0.name == key })
+            if !match.isEmpty {
+                if match.count == 1 {
+                    return .Element(match[0])
+                } else {
+                    return .List(match)
+                }
+            }
+            fallthrough
+        default:
+            throw Error.Key(key: key)
+        }
+    }
+
+    /**
+    Find an XML element at the current level by element name
+
+    - parameter key: The element name to index by
+    - returns: instance of XMLIndexer to match the element (or elements) found by
+    */
+    public subscript(key: String) -> XMLIndexer {
+        do {
+           return try self.byKey(key)
+        } catch let error as Error {
+            return .XMLError(error)
+        } catch {
+            return .XMLError(.Key(key: key))
+        }
+    }
+
+    /**
+    Find an XML element by index within a list of XML Elements at the current level
+
+    - parameter index: The 0-based index to index by
+    - throws: XMLIndexer.XMLError if the index isn't found
+    - returns: instance of XMLIndexer to match the element (or elements) found by index
+    */
+    public func byIndex(index: Int) throws -> XMLIndexer {
+        switch self {
+        case .Stream(let opStream):
+            opStream.ops[opStream.ops.count - 1].index = index
+            return .Stream(opStream)
+        case .List(let list):
+            if index <= list.count {
+                return .Element(list[index])
+            }
+            return .XMLError(.Index(idx: index))
+        case .Element(let elem):
+            if index == 0 {
+                return .Element(elem)
+            }
+            fallthrough
+        default:
+            return .XMLError(.Index(idx: index))
+        }
+    }
+
+    /**
+    Find an XML element by index
+
+    - parameter index: The 0-based index to index by
+    - returns: instance of XMLIndexer to match the element (or elements) found by index
+    */
+    public subscript(index: Int) -> XMLIndexer {
+        do {
+            return try byIndex(index)
+        } catch let error as Error {
+            return .XMLError(error)
+        } catch {
+            return .XMLError(.Index(idx: index))
+        }
+    }
+
+    typealias GeneratorType = XMLIndexer
+
+    /**
+    Method to iterate (for-in) over the `all` collection
+
+    - returns: an array of `XMLIndexer` instances
+    */
+    public func generate() -> IndexingGenerator<[XMLIndexer]> {
+        return all.generate()
+    }
+}
+
+/// XMLIndexer extensions
+extension XMLIndexer: BooleanType {
+    /// True if a valid XMLIndexer, false if an error type
+    public var boolValue: Bool {
+        switch self {
+        case .XMLError:
+            return false
+        default:
+            return true
+        }
+    }
+}
+
+extension XMLIndexer: CustomStringConvertible {
+    /// The XML representation of the XMLIndexer at the current level
+    public var description: String {
+        switch self {
+        case .List(let list):
+            return list.map { $0.description }.joinWithSeparator("")
+        case .Element(let elem):
+            if elem.name == rootElementName {
+                return elem.children.map { $0.description }.joinWithSeparator("")
+            }
+
+            return elem.description
+        default:
+            return ""
+        }
+    }
+}
+
+extension XMLIndexer.Error: CustomStringConvertible {
+    /// The description for the `XMLIndexer.Error`.
+    public var description: String {
+        switch self {
+        case .Attribute(let attr):
+            return "XML Attribute Error: Missing attribute [\"\(attr)\"]"
+        case .AttributeValue(let attr, let value):
+            return "XML Attribute Error: Missing attribute [\"\(attr)\"] with value [\"\(value)\"]"
+        case .Key(let key):
+            return "XML Element Error: Incorrect key [\"\(key)\"]"
+        case .Index(let index):
+            return "XML Element Error: Incorrect index [\"\(index)\"]"
+        case .Init(let instance):
+            return "XML Indexer Error: initialization with Object [\"\(instance)\"]"
+        case .Error:
+            return "Unknown Error"
+        }
+    }
+}
+
+/// Models content for an XML doc, whether it is text or XML
+public protocol XMLContent: CustomStringConvertible {
+}
+
+/// Models a text element
+public class TextElement: XMLContent {
+    public let text: String
+    init(text: String) {
+        self.text = text
+    }
+}
+
+/// Models an XML element, including name, text and attributes
+public class XMLElement: XMLContent {
+    /// The name of the element
+    public let name: String
+    /// The attributes of the element
+    public var attributes = [String:String]()
+
+    /// The inner text of the element, if it exists
+    public var text: String? {
+        return children
+            .map({ $0 as? TextElement })
+            .flatMap({ $0 })
+            .reduce("", combine: { $0 + $1!.text })
+    }
+
+    public var children = [XMLContent]()
+    var count: Int = 0
+    var index: Int
+
+    var xmlChildren: [XMLElement] {
+        return children.map { $0 as? XMLElement }.flatMap { $0 }
+    }
+
+    /**
+    Initialize an XMLElement instance
+
+    - parameters:
+        - name: The name of the element to be initialized
+        - index: The index of the element to be initialized
+    */
+    init(name: String, index: Int = 0) {
+        self.name = name
+        self.index = index
+    }
+
+    /**
+    Adds a new XMLElement underneath this instance of XMLElement
+
+    - parameters:
+        - name: The name of the new element to be added
+        - withAttributes: The attributes dictionary for the element being added
+    - returns: The XMLElement that has now been added
+    */
+    func addElement(name: String, withAttributes attributes: NSDictionary) -> XMLElement {
+        let element = XMLElement(name: name, index: count)
+        count += 1
+
+        children.append(element)
+
+        for (keyAny, valueAny) in attributes {
+            if let key = keyAny as? String,
+                let value = valueAny as? String {
+                element.attributes[key] = value
+            }
+        }
+
+        return element
+    }
+
+    func addText(text: String) {
+        let elem = TextElement(text: text)
+
+        children.append(elem)
+    }
+}
+
+extension TextElement: CustomStringConvertible {
+    /// The text value for a `TextElement` instance.
+    public var description: String {
+        return text
+    }
+}
+
+extension XMLElement: CustomStringConvertible {
+    /// The tag, attributes and content for a `XMLElement` instance (<elem id="foo">content</elem>)
+    public var description: String {
+        var attributesStringList = [String]()
+        if !attributes.isEmpty {
+            for (key, val) in attributes {
+                attributesStringList.append("\(key)=\"\(val)\"")
+            }
+        }
+
+        var attributesString = attributesStringList.joinWithSeparator(" ")
+        if !attributesString.isEmpty {
+            attributesString = " " + attributesString
+        }
+
+        if !children.isEmpty {
+            var xmlReturn = [String]()
+            xmlReturn.append("<\(name)\(attributesString)>")
+            for child in children {
+                xmlReturn.append(child.description)
+            }
+            xmlReturn.append("</\(name)>")
+            return xmlReturn.joinWithSeparator("")
+        }
+
+        if text != nil {
+            return "<\(name)\(attributesString)>\(text!)</\(name)>"
+        } else {
+            return "<\(name)\(attributesString)/>"
+        }
+    }
+}
diff --git a/Pods/Target Support Files/Alamofire/Alamofire-dummy.m b/Pods/Target Support Files/Alamofire/Alamofire-dummy.m
new file mode 100644
index 0000000..a6c4594
--- /dev/null
+++ b/Pods/Target Support Files/Alamofire/Alamofire-dummy.m	
@@ -0,0 +1,5 @@
+#import <Foundation/Foundation.h>
+@interface PodsDummy_Alamofire : NSObject
+@end
+@implementation PodsDummy_Alamofire
+@end
diff --git a/Pods/Target Support Files/Alamofire/Alamofire-prefix.pch b/Pods/Target Support Files/Alamofire/Alamofire-prefix.pch
new file mode 100644
index 0000000..b9c163b
--- /dev/null
+++ b/Pods/Target Support Files/Alamofire/Alamofire-prefix.pch	
@@ -0,0 +1,4 @@
+#ifdef __OBJC__
+#import <Cocoa/Cocoa.h>
+#endif
+
diff --git a/Pods/Target Support Files/Alamofire/Alamofire-umbrella.h b/Pods/Target Support Files/Alamofire/Alamofire-umbrella.h
new file mode 100644
index 0000000..17f78f7
--- /dev/null
+++ b/Pods/Target Support Files/Alamofire/Alamofire-umbrella.h	
@@ -0,0 +1,6 @@
+#import <Cocoa/Cocoa.h>
+
+
+FOUNDATION_EXPORT double AlamofireVersionNumber;
+FOUNDATION_EXPORT const unsigned char AlamofireVersionString[];
+
diff --git a/Pods/Target Support Files/Alamofire/Alamofire.modulemap b/Pods/Target Support Files/Alamofire/Alamofire.modulemap
new file mode 100644
index 0000000..d1f125f
--- /dev/null
+++ b/Pods/Target Support Files/Alamofire/Alamofire.modulemap	
@@ -0,0 +1,6 @@
+framework module Alamofire {
+  umbrella header "Alamofire-umbrella.h"
+
+  export *
+  module * { export * }
+}
diff --git a/Pods/Target Support Files/Alamofire/Alamofire.xcconfig b/Pods/Target Support Files/Alamofire/Alamofire.xcconfig
new file mode 100644
index 0000000..085c786
--- /dev/null
+++ b/Pods/Target Support Files/Alamofire/Alamofire.xcconfig	
@@ -0,0 +1,10 @@
+CODE_SIGN_IDENTITY =
+CONFIGURATION_BUILD_DIR = $PODS_CONFIGURATION_BUILD_DIR/Alamofire
+GCC_PREPROCESSOR_DEFINITIONS = $(inherited) COCOAPODS=1
+HEADER_SEARCH_PATHS = "${PODS_ROOT}/Headers/Private" "${PODS_ROOT}/Headers/Public"
+OTHER_SWIFT_FLAGS = $(inherited) "-D" "COCOAPODS"
+PODS_BUILD_DIR = $BUILD_DIR
+PODS_CONFIGURATION_BUILD_DIR = $PODS_BUILD_DIR/$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME)
+PODS_ROOT = ${SRCROOT}
+PRODUCT_BUNDLE_IDENTIFIER = org.cocoapods.${PRODUCT_NAME:rfc1034identifier}
+SKIP_INSTALL = YES
diff --git a/Pods/Target Support Files/Alamofire/Info.plist b/Pods/Target Support Files/Alamofire/Info.plist
new file mode 100644
index 0000000..7694605
--- /dev/null
+++ b/Pods/Target Support Files/Alamofire/Info.plist	
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+  <key>CFBundleDevelopmentRegion</key>
+  <string>en</string>
+  <key>CFBundleExecutable</key>
+  <string>${EXECUTABLE_NAME}</string>
+  <key>CFBundleIdentifier</key>
+  <string>${PRODUCT_BUNDLE_IDENTIFIER}</string>
+  <key>CFBundleInfoDictionaryVersion</key>
+  <string>6.0</string>
+  <key>CFBundleName</key>
+  <string>${PRODUCT_NAME}</string>
+  <key>CFBundlePackageType</key>
+  <string>FMWK</string>
+  <key>CFBundleShortVersionString</key>
+  <string>3.4.1</string>
+  <key>CFBundleSignature</key>
+  <string>????</string>
+  <key>CFBundleVersion</key>
+  <string>${CURRENT_PROJECT_VERSION}</string>
+  <key>NSPrincipalClass</key>
+  <string></string>
+</dict>
+</plist>
diff --git a/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016-acknowledgements.markdown b/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016-acknowledgements.markdown
index 8909bc0..0fa66f5 100644
--- a/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016-acknowledgements.markdown	
+++ b/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016-acknowledgements.markdown	
@@ -1,6 +1,29 @@
 # Acknowledgements
 This application makes use of the following third party libraries:
 
+## Alamofire
+
+Copyright (c) 2014-2016 Alamofire Software Foundation (http://alamofire.org/)
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+
+
 ## CocoaAsyncSocket
 
 Public Domain License
@@ -10,4 +33,28 @@ The CocoaAsyncSocket project is in the public domain.
 The original TCP version (AsyncSocket) was created by Dustin Voss in January 2003.
 Updated and maintained by Deusty LLC and the Apple development community.
 
+
+## SWXMLHash
+
+Copyright (c) 2014 David Mohundro
+ 
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+ 
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+ 
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
 Generated by CocoaPods - https://cocoapods.org
diff --git a/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016-acknowledgements.plist b/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016-acknowledgements.plist
index c215120..bb3fd6f 100644
--- a/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016-acknowledgements.plist	
+++ b/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016-acknowledgements.plist	
@@ -14,6 +14,33 @@
 		</dict>
 		<dict>
 			<key>FooterText</key>
+			<string>Copyright (c) 2014-2016 Alamofire Software Foundation (http://alamofire.org/)
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+</string>
+			<key>Title</key>
+			<string>Alamofire</string>
+			<key>Type</key>
+			<string>PSGroupSpecifier</string>
+		</dict>
+		<dict>
+			<key>FooterText</key>
 			<string>Public Domain License
 
 The CocoaAsyncSocket project is in the public domain.
@@ -28,6 +55,34 @@ Updated and maintained by Deusty LLC and the Apple development community.
 		</dict>
 		<dict>
 			<key>FooterText</key>
+			<string>Copyright (c) 2014 David Mohundro
+ 
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+ 
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+ 
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+</string>
+			<key>Title</key>
+			<string>SWXMLHash</string>
+			<key>Type</key>
+			<string>PSGroupSpecifier</string>
+		</dict>
+		<dict>
+			<key>FooterText</key>
 			<string>Generated by CocoaPods - https://cocoapods.org</string>
 			<key>Title</key>
 			<string></string>
diff --git a/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016-frameworks.sh b/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016-frameworks.sh
index 2cfb978..54d016b 100755
--- a/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016-frameworks.sh	
+++ b/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016-frameworks.sh	
@@ -84,8 +84,12 @@ strip_invalid_archs() {
 
 
 if [[ "$CONFIGURATION" == "Debug" ]]; then
+  install_framework "$BUILT_PRODUCTS_DIR/Alamofire/Alamofire.framework"
   install_framework "$BUILT_PRODUCTS_DIR/CocoaAsyncSocket/CocoaAsyncSocket.framework"
+  install_framework "$BUILT_PRODUCTS_DIR/SWXMLHash/SWXMLHash.framework"
 fi
 if [[ "$CONFIGURATION" == "Release" ]]; then
+  install_framework "$BUILT_PRODUCTS_DIR/Alamofire/Alamofire.framework"
   install_framework "$BUILT_PRODUCTS_DIR/CocoaAsyncSocket/CocoaAsyncSocket.framework"
+  install_framework "$BUILT_PRODUCTS_DIR/SWXMLHash/SWXMLHash.framework"
 fi
diff --git a/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016.debug.xcconfig b/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016.debug.xcconfig
index 6699faa..261e5cb 100644
--- a/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016.debug.xcconfig	
+++ b/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016.debug.xcconfig	
@@ -1,9 +1,11 @@
 CODE_SIGN_IDENTITY =
-FRAMEWORK_SEARCH_PATHS = $(inherited) "$PODS_CONFIGURATION_BUILD_DIR/CocoaAsyncSocket"
+EMBEDDED_CONTENT_CONTAINS_SWIFT = YES
+FRAMEWORK_SEARCH_PATHS = $(inherited) "$PODS_CONFIGURATION_BUILD_DIR/Alamofire" "$PODS_CONFIGURATION_BUILD_DIR/CocoaAsyncSocket" "$PODS_CONFIGURATION_BUILD_DIR/SWXMLHash"
 GCC_PREPROCESSOR_DEFINITIONS = $(inherited) COCOAPODS=1
 LD_RUNPATH_SEARCH_PATHS = $(inherited) '@executable_path/../Frameworks' '@loader_path/Frameworks'
-OTHER_CFLAGS = $(inherited) -iquote "$PODS_CONFIGURATION_BUILD_DIR/CocoaAsyncSocket/CocoaAsyncSocket.framework/Headers"
-OTHER_LDFLAGS = $(inherited) -framework "CocoaAsyncSocket"
+OTHER_CFLAGS = $(inherited) -iquote "$PODS_CONFIGURATION_BUILD_DIR/Alamofire/Alamofire.framework/Headers" -iquote "$PODS_CONFIGURATION_BUILD_DIR/CocoaAsyncSocket/CocoaAsyncSocket.framework/Headers" -iquote "$PODS_CONFIGURATION_BUILD_DIR/SWXMLHash/SWXMLHash.framework/Headers"
+OTHER_LDFLAGS = $(inherited) -framework "Alamofire" -framework "CocoaAsyncSocket" -framework "SWXMLHash"
+OTHER_SWIFT_FLAGS = $(inherited) "-D" "COCOAPODS"
 PODS_BUILD_DIR = $BUILD_DIR
 PODS_CONFIGURATION_BUILD_DIR = $PODS_BUILD_DIR/$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME)
 PODS_ROOT = ${SRCROOT}/Pods
diff --git a/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016.release.xcconfig b/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016.release.xcconfig
index 6699faa..261e5cb 100644
--- a/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016.release.xcconfig	
+++ b/Pods/Target Support Files/Pods-CRMCall092016/Pods-CRMCall092016.release.xcconfig	
@@ -1,9 +1,11 @@
 CODE_SIGN_IDENTITY =
-FRAMEWORK_SEARCH_PATHS = $(inherited) "$PODS_CONFIGURATION_BUILD_DIR/CocoaAsyncSocket"
+EMBEDDED_CONTENT_CONTAINS_SWIFT = YES
+FRAMEWORK_SEARCH_PATHS = $(inherited) "$PODS_CONFIGURATION_BUILD_DIR/Alamofire" "$PODS_CONFIGURATION_BUILD_DIR/CocoaAsyncSocket" "$PODS_CONFIGURATION_BUILD_DIR/SWXMLHash"
 GCC_PREPROCESSOR_DEFINITIONS = $(inherited) COCOAPODS=1
 LD_RUNPATH_SEARCH_PATHS = $(inherited) '@executable_path/../Frameworks' '@loader_path/Frameworks'
-OTHER_CFLAGS = $(inherited) -iquote "$PODS_CONFIGURATION_BUILD_DIR/CocoaAsyncSocket/CocoaAsyncSocket.framework/Headers"
-OTHER_LDFLAGS = $(inherited) -framework "CocoaAsyncSocket"
+OTHER_CFLAGS = $(inherited) -iquote "$PODS_CONFIGURATION_BUILD_DIR/Alamofire/Alamofire.framework/Headers" -iquote "$PODS_CONFIGURATION_BUILD_DIR/CocoaAsyncSocket/CocoaAsyncSocket.framework/Headers" -iquote "$PODS_CONFIGURATION_BUILD_DIR/SWXMLHash/SWXMLHash.framework/Headers"
+OTHER_LDFLAGS = $(inherited) -framework "Alamofire" -framework "CocoaAsyncSocket" -framework "SWXMLHash"
+OTHER_SWIFT_FLAGS = $(inherited) "-D" "COCOAPODS"
 PODS_BUILD_DIR = $BUILD_DIR
 PODS_CONFIGURATION_BUILD_DIR = $PODS_BUILD_DIR/$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME)
 PODS_ROOT = ${SRCROOT}/Pods
diff --git a/Pods/Target Support Files/SWXMLHash/Info.plist b/Pods/Target Support Files/SWXMLHash/Info.plist
new file mode 100644
index 0000000..e526849
--- /dev/null
+++ b/Pods/Target Support Files/SWXMLHash/Info.plist	
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+  <key>CFBundleDevelopmentRegion</key>
+  <string>en</string>
+  <key>CFBundleExecutable</key>
+  <string>${EXECUTABLE_NAME}</string>
+  <key>CFBundleIdentifier</key>
+  <string>${PRODUCT_BUNDLE_IDENTIFIER}</string>
+  <key>CFBundleInfoDictionaryVersion</key>
+  <string>6.0</string>
+  <key>CFBundleName</key>
+  <string>${PRODUCT_NAME}</string>
+  <key>CFBundlePackageType</key>
+  <string>FMWK</string>
+  <key>CFBundleShortVersionString</key>
+  <string>2.4.0</string>
+  <key>CFBundleSignature</key>
+  <string>????</string>
+  <key>CFBundleVersion</key>
+  <string>${CURRENT_PROJECT_VERSION}</string>
+  <key>NSPrincipalClass</key>
+  <string></string>
+</dict>
+</plist>
diff --git a/Pods/Target Support Files/SWXMLHash/SWXMLHash-dummy.m b/Pods/Target Support Files/SWXMLHash/SWXMLHash-dummy.m
new file mode 100644
index 0000000..6a0dbe3
--- /dev/null
+++ b/Pods/Target Support Files/SWXMLHash/SWXMLHash-dummy.m	
@@ -0,0 +1,5 @@
+#import <Foundation/Foundation.h>
+@interface PodsDummy_SWXMLHash : NSObject
+@end
+@implementation PodsDummy_SWXMLHash
+@end
diff --git a/Pods/Target Support Files/SWXMLHash/SWXMLHash-prefix.pch b/Pods/Target Support Files/SWXMLHash/SWXMLHash-prefix.pch
new file mode 100644
index 0000000..b9c163b
--- /dev/null
+++ b/Pods/Target Support Files/SWXMLHash/SWXMLHash-prefix.pch	
@@ -0,0 +1,4 @@
+#ifdef __OBJC__
+#import <Cocoa/Cocoa.h>
+#endif
+
diff --git a/Pods/Target Support Files/SWXMLHash/SWXMLHash-umbrella.h b/Pods/Target Support Files/SWXMLHash/SWXMLHash-umbrella.h
new file mode 100644
index 0000000..4031b21
--- /dev/null
+++ b/Pods/Target Support Files/SWXMLHash/SWXMLHash-umbrella.h	
@@ -0,0 +1,6 @@
+#import <Cocoa/Cocoa.h>
+
+
+FOUNDATION_EXPORT double SWXMLHashVersionNumber;
+FOUNDATION_EXPORT const unsigned char SWXMLHashVersionString[];
+
diff --git a/Pods/Target Support Files/SWXMLHash/SWXMLHash.modulemap b/Pods/Target Support Files/SWXMLHash/SWXMLHash.modulemap
new file mode 100644
index 0000000..42b046c
--- /dev/null
+++ b/Pods/Target Support Files/SWXMLHash/SWXMLHash.modulemap	
@@ -0,0 +1,6 @@
+framework module SWXMLHash {
+  umbrella header "SWXMLHash-umbrella.h"
+
+  export *
+  module * { export * }
+}
diff --git a/Pods/Target Support Files/SWXMLHash/SWXMLHash.xcconfig b/Pods/Target Support Files/SWXMLHash/SWXMLHash.xcconfig
new file mode 100644
index 0000000..a3b85e0
--- /dev/null
+++ b/Pods/Target Support Files/SWXMLHash/SWXMLHash.xcconfig	
@@ -0,0 +1,10 @@
+CODE_SIGN_IDENTITY =
+CONFIGURATION_BUILD_DIR = $PODS_CONFIGURATION_BUILD_DIR/SWXMLHash
+GCC_PREPROCESSOR_DEFINITIONS = $(inherited) COCOAPODS=1
+HEADER_SEARCH_PATHS = "${PODS_ROOT}/Headers/Private" "${PODS_ROOT}/Headers/Public"
+OTHER_SWIFT_FLAGS = $(inherited) "-D" "COCOAPODS"
+PODS_BUILD_DIR = $BUILD_DIR
+PODS_CONFIGURATION_BUILD_DIR = $PODS_BUILD_DIR/$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME)
+PODS_ROOT = ${SRCROOT}
+PRODUCT_BUNDLE_IDENTIFIER = org.cocoapods.${PRODUCT_NAME:rfc1034identifier}
+SKIP_INSTALL = YES
diff --git a/initDiff b/initDiff
new file mode 100644
index 0000000..e69de29
diff --git a/output-file b/output-file
new file mode 100644
index 0000000..e69de29
diff --git a/patch.diff b/patch.diff
new file mode 100644
index 0000000..e69de29
diff --git a/patch.txt b/patch.txt
new file mode 100644
index 0000000..e69de29
